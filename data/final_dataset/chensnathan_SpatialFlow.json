{"home.repos.pwc.inspect_result.chensnathan_SpatialFlow.None.setup.readme": [[10, 14], ["open", "f.read"], "function", ["None"], ["def", "readme", "(", ")", ":", "\n", "    ", "with", "open", "(", "'README.md'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "return", "content", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.None.setup.get_version": [[19, 23], ["open", "exec", "locals", "compile", "f.read"], "function", ["None"], ["def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.None.setup.make_cuda_ext": [[25, 48], ["extension", "torch.cuda.is_available", "print", "os.getenv", "os.path.join", "module.split"], "function", ["None"], ["", "def", "make_cuda_ext", "(", "name", ",", "module", ",", "sources", ",", "sources_cuda", "=", "[", "]", ")", ":", "\n", "\n", "    ", "define_macros", "=", "[", "]", "\n", "extra_compile_args", "=", "{", "'cxx'", ":", "[", "]", "}", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "or", "os", ".", "getenv", "(", "'FORCE_CUDA'", ",", "'0'", ")", "==", "'1'", ":", "\n", "        ", "define_macros", "+=", "[", "(", "'WITH_CUDA'", ",", "None", ")", "]", "\n", "extension", "=", "CUDAExtension", "\n", "extra_compile_args", "[", "'nvcc'", "]", "=", "[", "\n", "'-D__CUDA_NO_HALF_OPERATORS__'", ",", "\n", "'-D__CUDA_NO_HALF_CONVERSIONS__'", ",", "\n", "'-D__CUDA_NO_HALF2_OPERATORS__'", ",", "\n", "]", "\n", "sources", "+=", "sources_cuda", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'Compiling {name} without CUDA'", ")", "\n", "extension", "=", "CppExtension", "\n", "\n", "", "return", "extension", "(", "\n", "name", "=", "f'{module}.{name}'", ",", "\n", "sources", "=", "[", "os", ".", "path", ".", "join", "(", "*", "module", ".", "split", "(", "'.'", ")", ",", "p", ")", "for", "p", "in", "sources", "]", ",", "\n", "define_macros", "=", "define_macros", ",", "\n", "extra_compile_args", "=", "extra_compile_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.None.setup.parse_requirements": [[50, 126], ["list", "line.strip.startswith", "exists", "setup.parse_requirements.gen_packages_items"], "function", ["None"], ["", "def", "parse_requirements", "(", "fname", "=", "'requirements.txt'", ",", "with_version", "=", "True", ")", ":", "\n", "    ", "\"\"\"Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if True include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n    \"\"\"", "\n", "import", "sys", "\n", "from", "os", ".", "path", "import", "exists", "\n", "import", "re", "\n", "require_fpath", "=", "fname", "\n", "\n", "def", "parse_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"Parse information from a line in a requirements text file.\"\"\"", "\n", "if", "line", ".", "startswith", "(", "'-r '", ")", ":", "\n", "# Allow specifying requirements in other files", "\n", "            ", "target", "=", "line", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "for", "info", "in", "parse_require_file", "(", "target", ")", ":", "\n", "                ", "yield", "info", "\n", "", "", "else", ":", "\n", "            ", "info", "=", "{", "'line'", ":", "line", "}", "\n", "if", "line", ".", "startswith", "(", "'-e '", ")", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", ".", "split", "(", "'#egg='", ")", "[", "1", "]", "\n", "", "elif", "'@git+'", "in", "line", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", "\n", "", "else", ":", "\n", "# Remove versioning from the package", "\n", "                ", "pat", "=", "'('", "+", "'|'", ".", "join", "(", "[", "'>='", ",", "'=='", ",", "'>'", "]", ")", "+", "')'", "\n", "parts", "=", "re", ".", "split", "(", "pat", ",", "line", ",", "maxsplit", "=", "1", ")", "\n", "parts", "=", "[", "p", ".", "strip", "(", ")", "for", "p", "in", "parts", "]", "\n", "\n", "info", "[", "'package'", "]", "=", "parts", "[", "0", "]", "\n", "if", "len", "(", "parts", ")", ">", "1", ":", "\n", "                    ", "op", ",", "rest", "=", "parts", "[", "1", ":", "]", "\n", "if", "';'", "in", "rest", ":", "\n", "# Handle platform specific dependencies", "\n", "# http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies", "\n", "                        ", "version", ",", "platform_deps", "=", "map", "(", "str", ".", "strip", ",", "\n", "rest", ".", "split", "(", "';'", ")", ")", "\n", "info", "[", "'platform_deps'", "]", "=", "platform_deps", "\n", "", "else", ":", "\n", "                        ", "version", "=", "rest", "# NOQA", "\n", "", "info", "[", "'version'", "]", "=", "(", "op", ",", "version", ")", "\n", "", "", "yield", "info", "\n", "\n", "", "", "def", "parse_require_file", "(", "fpath", ")", ":", "\n", "        ", "with", "open", "(", "fpath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "and", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "                    ", "for", "info", "in", "parse_line", "(", "line", ")", ":", "\n", "                        ", "yield", "info", "\n", "\n", "", "", "", "", "", "def", "gen_packages_items", "(", ")", ":", "\n", "        ", "if", "exists", "(", "require_fpath", ")", ":", "\n", "            ", "for", "info", "in", "parse_require_file", "(", "require_fpath", ")", ":", "\n", "                ", "parts", "=", "[", "info", "[", "'package'", "]", "]", "\n", "if", "with_version", "and", "'version'", "in", "info", ":", "\n", "                    ", "parts", ".", "extend", "(", "info", "[", "'version'", "]", ")", "\n", "", "if", "not", "sys", ".", "version", ".", "startswith", "(", "'3.4'", ")", ":", "\n", "# apparently package_deps are broken in 3.4", "\n", "                    ", "platform_deps", "=", "info", ".", "get", "(", "'platform_deps'", ")", "\n", "if", "platform_deps", "is", "not", "None", ":", "\n", "                        ", "parts", ".", "append", "(", "';'", "+", "platform_deps", ")", "\n", "", "", "item", "=", "''", ".", "join", "(", "parts", ")", "\n", "yield", "item", "\n", "\n", "", "", "", "packages", "=", "list", "(", "gen_packages_items", "(", ")", ")", "\n", "return", "packages", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version": [[6, 16], ["version_str.split", "x.isdigit", "digit_version.append", "int", "x.find", "x.split", "digit_version.append", "digit_version.append", "int", "int", "mmcv.__version__"], "function", ["None"], ["def", "digit_version", "(", "version_str", ")", ":", "\n", "    ", "digit_version", "=", "[", "]", "\n", "for", "x", "in", "version_str", ".", "split", "(", "'.'", ")", ":", "\n", "        ", "if", "x", ".", "isdigit", "(", ")", ":", "\n", "            ", "digit_version", ".", "append", "(", "int", "(", "x", ")", ")", "\n", "", "elif", "x", ".", "find", "(", "'rc'", ")", "!=", "-", "1", ":", "\n", "            ", "patch_version", "=", "x", ".", "split", "(", "'rc'", ")", "\n", "digit_version", ".", "append", "(", "int", "(", "patch_version", "[", "0", "]", ")", "-", "1", ")", "\n", "digit_version", ".", "append", "(", "int", "(", "patch_version", "[", "1", "]", ")", ")", "\n", "", "", "return", "digit_version", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.version.parse_version_info": [[7, 17], ["version_str.split", "tuple", "x.isdigit", "version_info.append", "int", "x.find", "x.split", "version_info.append", "version_info.append", "int"], "function", ["None"], ["def", "parse_version_info", "(", "version_str", ")", ":", "\n", "    ", "version_info", "=", "[", "]", "\n", "for", "x", "in", "version_str", ".", "split", "(", "'.'", ")", ":", "\n", "        ", "if", "x", ".", "isdigit", "(", ")", ":", "\n", "            ", "version_info", ".", "append", "(", "int", "(", "x", ")", ")", "\n", "", "elif", "x", ".", "find", "(", "'rc'", ")", "!=", "-", "1", ":", "\n", "            ", "patch_version", "=", "x", ".", "split", "(", "'rc'", ")", "\n", "version_info", ".", "append", "(", "int", "(", "patch_version", "[", "0", "]", ")", ")", "\n", "version_info", ".", "append", "(", "f'rc{patch_version[1]}'", ")", "\n", "", "", "return", "tuple", "(", "version_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.util_mixins.NiceRepr.__nice__": [[75, 85], ["hasattr", "str", "NotImplementedError", "len"], "methods", ["None"], ["def", "__nice__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a \"nice\" summary string describing this module\"\"\"", "\n", "if", "hasattr", "(", "self", ",", "'__len__'", ")", ":", "\n", "# It is a common pattern for objects to use __len__ in __nice__", "\n", "# As a convenience we define a default __nice__ for these objects", "\n", "            ", "return", "str", "(", "len", "(", "self", ")", ")", "\n", "", "else", ":", "\n", "# In all other cases force the subclass to overload __nice__", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "f'Define the __nice__ method for {self.__class__!r}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.util_mixins.NiceRepr.__repr__": [[86, 95], ["util_mixins.NiceRepr.__nice__", "warnings.warn", "object.__repr__", "hex", "str", "id"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.__nice__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.BboxOverlaps2D.__repr__"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: the string of the module\"\"\"", "\n", "try", ":", "\n", "            ", "nice", "=", "self", ".", "__nice__", "(", ")", "\n", "classname", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "f'<{classname}({nice}) at {hex(id(self))}>'", "\n", "", "except", "NotImplementedError", "as", "ex", ":", "\n", "            ", "warnings", ".", "warn", "(", "str", "(", "ex", ")", ",", "category", "=", "RuntimeWarning", ")", "\n", "return", "object", ".", "__repr__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.util_mixins.NiceRepr.__str__": [[96, 105], ["util_mixins.NiceRepr.__nice__", "warnings.warn", "object.__repr__", "str"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.__nice__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.BboxOverlaps2D.__repr__"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: the string of the module\"\"\"", "\n", "try", ":", "\n", "            ", "classname", "=", "self", ".", "__class__", ".", "__name__", "\n", "nice", "=", "self", ".", "__nice__", "(", ")", "\n", "return", "f'<{classname}({nice})>'", "\n", "", "except", "NotImplementedError", "as", "ex", ":", "\n", "            ", "warnings", ".", "warn", "(", "str", "(", "ex", ")", ",", "category", "=", "RuntimeWarning", ")", "\n", "return", "object", ".", "__repr__", "(", "self", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger": [[6, 20], ["mmcv.utils.get_logger"], "function", ["None"], ["def", "get_root_logger", "(", "log_file", "=", "None", ",", "log_level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "\"\"\"Get root logger.\n\n    Args:\n        log_file (str, optional): File path of log. Defaults to None.\n        log_level (int, optional): The level of logger.\n            Defaults to logging.INFO.\n\n    Returns:\n        :obj:`logging.Logger`: The obtained logger\n    \"\"\"", "\n", "logger", "=", "get_logger", "(", "name", "=", "'mmdet'", ",", "log_file", "=", "log_file", ",", "log_level", "=", "log_level", ")", "\n", "\n", "return", "logger", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.collect_env.collect_env": [[15, 61], ["sys.version.replace", "torch.cuda.is_available", "subprocess.check_output", "gcc.decode().strip.decode().strip", "mmcv.utils.get_build_config", "get_compiler_version", "get_compiling_cuda_version", "collections.defaultdict", "range", "collections.defaultdict.items", "os.isdir", "torch.cuda.device_count", "devices[].append", "gcc.decode().strip.decode", "mmcv.utils.get_git_hash", "os.join", "subprocess.check_output", "nvcc.decode().strip.decode().strip", "str", "nvcc.decode().strip.decode", "torch.cuda.get_device_name"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["def", "collect_env", "(", ")", ":", "\n", "    ", "\"\"\"Collect the information of the running environments.\"\"\"", "\n", "env_info", "=", "{", "}", "\n", "env_info", "[", "'sys.platform'", "]", "=", "sys", ".", "platform", "\n", "env_info", "[", "'Python'", "]", "=", "sys", ".", "version", ".", "replace", "(", "'\\n'", ",", "''", ")", "\n", "\n", "cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "env_info", "[", "'CUDA available'", "]", "=", "cuda_available", "\n", "\n", "if", "cuda_available", ":", "\n", "        ", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "CUDA_HOME", "\n", "env_info", "[", "'CUDA_HOME'", "]", "=", "CUDA_HOME", "\n", "\n", "if", "CUDA_HOME", "is", "not", "None", "and", "osp", ".", "isdir", "(", "CUDA_HOME", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "nvcc", "=", "osp", ".", "join", "(", "CUDA_HOME", ",", "'bin/nvcc'", ")", "\n", "nvcc", "=", "subprocess", ".", "check_output", "(", "\n", "f'\"{nvcc}\" -V | tail -n1'", ",", "shell", "=", "True", ")", "\n", "nvcc", "=", "nvcc", ".", "decode", "(", "'utf-8'", ")", ".", "strip", "(", ")", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                ", "nvcc", "=", "'Not Available'", "\n", "", "env_info", "[", "'NVCC'", "]", "=", "nvcc", "\n", "\n", "", "devices", "=", "defaultdict", "(", "list", ")", "\n", "for", "k", "in", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ":", "\n", "            ", "devices", "[", "torch", ".", "cuda", ".", "get_device_name", "(", "k", ")", "]", ".", "append", "(", "str", "(", "k", ")", ")", "\n", "", "for", "name", ",", "devids", "in", "devices", ".", "items", "(", ")", ":", "\n", "            ", "env_info", "[", "'GPU '", "+", "','", ".", "join", "(", "devids", ")", "]", "=", "name", "\n", "\n", "", "", "gcc", "=", "subprocess", ".", "check_output", "(", "'gcc --version | head -n1'", ",", "shell", "=", "True", ")", "\n", "gcc", "=", "gcc", ".", "decode", "(", "'utf-8'", ")", ".", "strip", "(", ")", "\n", "env_info", "[", "'GCC'", "]", "=", "gcc", "\n", "\n", "env_info", "[", "'PyTorch'", "]", "=", "torch", ".", "__version__", "\n", "env_info", "[", "'PyTorch compiling details'", "]", "=", "get_build_config", "(", ")", "\n", "\n", "env_info", "[", "'TorchVision'", "]", "=", "torchvision", ".", "__version__", "\n", "\n", "env_info", "[", "'OpenCV'", "]", "=", "cv2", ".", "__version__", "\n", "\n", "env_info", "[", "'MMCV'", "]", "=", "mmcv", ".", "__version__", "\n", "env_info", "[", "'MMDetection'", "]", "=", "mmdet", ".", "__version__", "+", "'+'", "+", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "from", "mmcv", ".", "ops", "import", "get_compiler_version", ",", "get_compiling_cuda_version", "\n", "env_info", "[", "'MMDetection Compiler'", "]", "=", "get_compiler_version", "(", ")", "\n", "env_info", "[", "'MMDetection CUDA Compiler'", "]", "=", "get_compiling_cuda_version", "(", ")", "\n", "return", "env_info", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gaussian2D": [[6, 28], ["torch.arange().view", "torch.arange().view", "torch.arange", "torch.arange", "h.max", "torch.finfo"], "function", ["None"], ["def", "gaussian2D", "(", "radius", ",", "sigma", "=", "1", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"Generate 2D gaussian kernel.\n\n    Args:\n        radius (int): Radius of gaussian kernel.\n        sigma (int): Sigma of gaussian function. Default: 1.\n        dtype (torch.dtype): Dtype of gaussian tensor. Default: torch.float32.\n        device (str): Device of gaussian tensor. Default: 'cpu'.\n\n    Returns:\n        h (Tensor): Gaussian kernel with a\n            ``(2 * radius + 1) * (2 * radius + 1)`` shape.\n    \"\"\"", "\n", "x", "=", "torch", ".", "arange", "(", "\n", "-", "radius", ",", "radius", "+", "1", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "y", "=", "torch", ".", "arange", "(", "\n", "-", "radius", ",", "radius", "+", "1", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "h", "=", "(", "-", "(", "x", "*", "x", "+", "y", "*", "y", ")", "/", "(", "2", "*", "sigma", "*", "sigma", ")", ")", ".", "exp", "(", ")", "\n", "\n", "h", "[", "h", "<", "torch", ".", "finfo", "(", "h", ".", "dtype", ")", ".", "eps", "*", "h", ".", "max", "(", ")", "]", "=", "0", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gen_gaussian_target": [[30, 64], ["gaussian_target.gaussian2D", "torch.zeros_like", "torch.max", "min", "min", "min", "min"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gaussian2D"], ["", "def", "gen_gaussian_target", "(", "heatmap", ",", "center", ",", "radius", ",", "k", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate 2D gaussian heatmap.\n\n    Args:\n        heatmap (Tensor): Input heatmap, the gaussian kernel will cover on\n            it and maintain the max value.\n        center (list[int]): Coord of gaussian kernel's center.\n        radius (int): Radius of gaussian kernel.\n        k (int): Coefficient of gaussian kernel. Default: 1.\n\n    Returns:\n        out_heatmap (Tensor): Updated heatmap covered by gaussian kernel.\n    \"\"\"", "\n", "diameter", "=", "2", "*", "radius", "+", "1", "\n", "gaussian_kernel", "=", "gaussian2D", "(", "\n", "radius", ",", "sigma", "=", "diameter", "/", "6", ",", "dtype", "=", "heatmap", ".", "dtype", ",", "device", "=", "heatmap", ".", "device", ")", "\n", "\n", "x", ",", "y", "=", "center", "\n", "\n", "height", ",", "width", "=", "heatmap", ".", "shape", "[", ":", "2", "]", "\n", "\n", "left", ",", "right", "=", "min", "(", "x", ",", "radius", ")", ",", "min", "(", "width", "-", "x", ",", "radius", "+", "1", ")", "\n", "top", ",", "bottom", "=", "min", "(", "y", ",", "radius", ")", ",", "min", "(", "height", "-", "y", ",", "radius", "+", "1", ")", "\n", "\n", "masked_heatmap", "=", "heatmap", "[", "y", "-", "top", ":", "y", "+", "bottom", ",", "x", "-", "left", ":", "x", "+", "right", "]", "\n", "masked_gaussian", "=", "gaussian_kernel", "[", "radius", "-", "top", ":", "radius", "+", "bottom", ",", "\n", "radius", "-", "left", ":", "radius", "+", "right", "]", "\n", "out_heatmap", "=", "torch", ".", "zeros_like", "(", "heatmap", ")", "\n", "torch", ".", "max", "(", "\n", "masked_heatmap", ",", "\n", "masked_gaussian", "*", "k", ",", "\n", "out", "=", "out_heatmap", "[", "y", "-", "top", ":", "y", "+", "bottom", ",", "x", "-", "left", ":", "x", "+", "right", "]", ")", "\n", "\n", "return", "out_heatmap", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gaussian_radius": [[66, 186], ["math.sqrt", "math.sqrt", "math.sqrt", "min"], "function", ["None"], ["", "def", "gaussian_radius", "(", "det_size", ",", "min_overlap", ")", ":", "\n", "    ", "r\"\"\"Generate 2D gaussian radius.\n\n    This function is modified from the `official github repo\n    <https://github.com/princeton-vl/CornerNet-Lite/blob/master/core/sample/\n    utils.py#L65>`_.\n\n    Given ``min_overlap``, radius could computed by a quadratic equation\n    according to Vieta's formulas.\n\n    There are 3 cases for computing gaussian radius, details are following:\n\n    - Explanation of figure: ``lt`` and ``br`` indicates the left-top and\n      bottom-right corner of ground truth box. ``x`` indicates the\n      generated corner at the limited position when ``radius=r``.\n\n    - Case1: one corner is inside the gt box and the other is outside.\n\n    .. code:: text\n\n        |<   width   >|\n\n        lt-+----------+         -\n        |  |          |         ^\n        +--x----------+--+\n        |  |          |  |\n        |  |          |  |    height\n        |  | overlap  |  |\n        |  |          |  |\n        |  |          |  |      v\n        +--+---------br--+      -\n           |          |  |\n           +----------+--x\n\n    To ensure IoU of generated box and gt box is larger than ``min_overlap``:\n\n    .. math::\n        \\cfrac{(w-r)*(h-r)}{w*h+(w+h)r-r^2} \\ge {iou} \\quad\\Rightarrow\\quad\n        {r^2-(w+h)r+\\cfrac{1-iou}{1+iou}*w*h} \\ge 0 \\\\\n        {a} = 1,\\quad{b} = {-(w+h)},\\quad{c} = {\\cfrac{1-iou}{1+iou}*w*h}\n        {r} \\le \\cfrac{-b-\\sqrt{b^2-4*a*c}}{2*a}\n\n    - Case2: both two corners are inside the gt box.\n\n    .. code:: text\n\n        |<   width   >|\n\n        lt-+----------+         -\n        |  |          |         ^\n        +--x-------+  |\n        |  |       |  |\n        |  |overlap|  |       height\n        |  |       |  |\n        |  +-------x--+\n        |          |  |         v\n        +----------+-br         -\n\n    To ensure IoU of generated box and gt box is larger than ``min_overlap``:\n\n    .. math::\n        \\cfrac{(w-2*r)*(h-2*r)}{w*h} \\ge {iou} \\quad\\Rightarrow\\quad\n        {4r^2-2(w+h)r+(1-iou)*w*h} \\ge 0 \\\\\n        {a} = 4,\\quad {b} = {-2(w+h)},\\quad {c} = {(1-iou)*w*h}\n        {r} \\le \\cfrac{-b-\\sqrt{b^2-4*a*c}}{2*a}\n\n    - Case3: both two corners are outside the gt box.\n\n    .. code:: text\n\n           |<   width   >|\n\n        x--+----------------+\n        |  |                |\n        +-lt-------------+  |   -\n        |  |             |  |   ^\n        |  |             |  |\n        |  |   overlap   |  | height\n        |  |             |  |\n        |  |             |  |   v\n        |  +------------br--+   -\n        |                |  |\n        +----------------+--x\n\n    To ensure IoU of generated box and gt box is larger than ``min_overlap``:\n\n    .. math::\n        \\cfrac{w*h}{(w+2*r)*(h+2*r)} \\ge {iou} \\quad\\Rightarrow\\quad\n        {4*iou*r^2+2*iou*(w+h)r+(iou-1)*w*h} \\le 0 \\\\\n        {a} = {4*iou},\\quad {b} = {2*iou*(w+h)},\\quad {c} = {(iou-1)*w*h} \\\\\n        {r} \\le \\cfrac{-b+\\sqrt{b^2-4*a*c}}{2*a}\n\n    Args:\n        det_size (list[int]): Shape of object.\n        min_overlap (float): Min IoU with ground truth for boxes generated by\n            keypoints inside the gaussian kernel.\n\n    Returns:\n        radius (int): Radius of gaussian kernel.\n    \"\"\"", "\n", "height", ",", "width", "=", "det_size", "\n", "\n", "a1", "=", "1", "\n", "b1", "=", "(", "height", "+", "width", ")", "\n", "c1", "=", "width", "*", "height", "*", "(", "1", "-", "min_overlap", ")", "/", "(", "1", "+", "min_overlap", ")", "\n", "sq1", "=", "sqrt", "(", "b1", "**", "2", "-", "4", "*", "a1", "*", "c1", ")", "\n", "r1", "=", "(", "b1", "-", "sq1", ")", "/", "(", "2", "*", "a1", ")", "\n", "\n", "a2", "=", "4", "\n", "b2", "=", "2", "*", "(", "height", "+", "width", ")", "\n", "c2", "=", "(", "1", "-", "min_overlap", ")", "*", "width", "*", "height", "\n", "sq2", "=", "sqrt", "(", "b2", "**", "2", "-", "4", "*", "a2", "*", "c2", ")", "\n", "r2", "=", "(", "b2", "-", "sq2", ")", "/", "(", "2", "*", "a2", ")", "\n", "\n", "a3", "=", "4", "*", "min_overlap", "\n", "b3", "=", "-", "2", "*", "min_overlap", "*", "(", "height", "+", "width", ")", "\n", "c3", "=", "(", "min_overlap", "-", "1", ")", "*", "width", "*", "height", "\n", "sq3", "=", "sqrt", "(", "b3", "**", "2", "-", "4", "*", "a3", "*", "c3", ")", "\n", "r3", "=", "(", "b3", "+", "sq3", ")", "/", "(", "2", "*", "a3", ")", "\n", "return", "min", "(", "r1", ",", "r2", ",", "r3", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.res_layer.ResLayer.__init__": [[24, 103], ["dict", "torch.nn.Sequential.__init__", "torch.nn.Sequential.extend", "torch.nn.Sequential", "layers.append", "range", "range", "layers.append", "torch.nn.Sequential.append", "block", "layers.append", "layers.append", "block", "torch.nn.AvgPool2d", "mmcv.cnn.build_conv_layer", "block", "block", "mmcv.cnn.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "1", ",", "\n", "avg_down", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "downsample_first", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "block", "=", "block", "\n", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "[", "]", "\n", "conv_stride", "=", "stride", "\n", "if", "avg_down", "and", "stride", "!=", "1", ":", "\n", "                ", "conv_stride", "=", "1", "\n", "downsample", ".", "append", "(", "\n", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "stride", ",", "\n", "stride", "=", "stride", ",", "\n", "ceil_mode", "=", "True", ",", "\n", "count_include_pad", "=", "False", ")", ")", "\n", "", "downsample", ".", "extend", "(", "[", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "conv_stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", "\n", "]", ")", "\n", "downsample", "=", "nn", ".", "Sequential", "(", "*", "downsample", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "if", "downsample_first", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "                ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "", "else", ":", "# downsample_first=False is for HourglassModule", "\n", "            ", "for", "_", "in", "range", "(", "num_blocks", "-", "1", ")", ":", "\n", "                ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "inplanes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "", "super", "(", "ResLayer", ",", "self", ")", ".", "__init__", "(", "*", "layers", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.dist_utils.DistOptimizerHook.__init__": [[57, 61], ["warnings.warn", "mmcv.runner.OptimizerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "'\"DistOptimizerHook\" is deprecated, please switch to'", "\n", "'\"mmcv.runner.OptimizerHook\".'", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.dist_utils._allreduce_coalesced": [[10, 30], ["torch._utils._take_tensors", "collections.OrderedDict", "buckets.values.values", "torch._utils._flatten_dense_tensors", "torch.all_reduce", "torch._utils._flatten_dense_tensors.div_", "zip", "tensor.type", "buckets[].append", "torch._utils._unflatten_dense_tensors", "tensor.copy_"], "function", ["None"], ["def", "_allreduce_coalesced", "(", "tensors", ",", "world_size", ",", "bucket_size_mb", "=", "-", "1", ")", ":", "\n", "    ", "if", "bucket_size_mb", ">", "0", ":", "\n", "        ", "bucket_size_bytes", "=", "bucket_size_mb", "*", "1024", "*", "1024", "\n", "buckets", "=", "_take_tensors", "(", "tensors", ",", "bucket_size_bytes", ")", "\n", "", "else", ":", "\n", "        ", "buckets", "=", "OrderedDict", "(", ")", "\n", "for", "tensor", "in", "tensors", ":", "\n", "            ", "tp", "=", "tensor", ".", "type", "(", ")", "\n", "if", "tp", "not", "in", "buckets", ":", "\n", "                ", "buckets", "[", "tp", "]", "=", "[", "]", "\n", "", "buckets", "[", "tp", "]", ".", "append", "(", "tensor", ")", "\n", "", "buckets", "=", "buckets", ".", "values", "(", ")", "\n", "\n", "", "for", "bucket", "in", "buckets", ":", "\n", "        ", "flat_tensors", "=", "_flatten_dense_tensors", "(", "bucket", ")", "\n", "dist", ".", "all_reduce", "(", "flat_tensors", ")", "\n", "flat_tensors", ".", "div_", "(", "world_size", ")", "\n", "for", "tensor", ",", "synced", "in", "zip", "(", "\n", "bucket", ",", "_unflatten_dense_tensors", "(", "flat_tensors", ",", "bucket", ")", ")", ":", "\n", "            ", "tensor", ".", "copy_", "(", "synced", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.dist_utils.allreduce_grads": [[32, 52], ["torch.get_world_size", "dist_utils._allreduce_coalesced", "torch.all_reduce", "tensor.div_"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.dist_utils._allreduce_coalesced"], ["", "", "", "def", "allreduce_grads", "(", "params", ",", "coalesce", "=", "True", ",", "bucket_size_mb", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"Allreduce gradients.\n\n    Args:\n        params (list[torch.Parameters]): List of parameters of a model\n        coalesce (bool, optional): Whether allreduce parameters as a whole.\n            Defaults to True.\n        bucket_size_mb (int, optional): Size of bucket, the unit is MB.\n            Defaults to -1.\n    \"\"\"", "\n", "grads", "=", "[", "\n", "param", ".", "grad", ".", "data", "for", "param", "in", "params", "\n", "if", "param", ".", "requires_grad", "and", "param", ".", "grad", "is", "not", "None", "\n", "]", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "if", "coalesce", ":", "\n", "        ", "_allreduce_coalesced", "(", "grads", ",", "world_size", ",", "bucket_size_mb", ")", "\n", "", "else", ":", "\n", "        ", "for", "tensor", "in", "grads", ":", "\n", "            ", "dist", ".", "all_reduce", "(", "tensor", ".", "div_", "(", "world_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.tensor2imgs": [[9, 33], ["tensor.size", "numpy.array", "numpy.array", "range", "tensor[].cpu().numpy().transpose", "mmcv.imdenormalize().astype", "imgs.append", "numpy.ascontiguousarray", "tensor[].cpu().numpy", "mmcv.imdenormalize", "tensor[].cpu"], "function", ["None"], ["def", "tensor2imgs", "(", "tensor", ",", "mean", "=", "(", "0", ",", "0", ",", "0", ")", ",", "std", "=", "(", "1", ",", "1", ",", "1", ")", ",", "to_rgb", "=", "True", ")", ":", "\n", "    ", "\"\"\"Convert tensor to images.\n\n    Args:\n        tensor (torch.Tensor): Tensor that contains multiple images\n        mean (tuple[float], optional): Mean of images. Defaults to (0, 0, 0).\n        std (tuple[float], optional): Standard deviation of images.\n            Defaults to (1, 1, 1).\n        to_rgb (bool, optional): Whether convert the images to RGB format.\n            Defaults to True.\n\n    Returns:\n        list[np.ndarray]: A list that contains multiple images.\n    \"\"\"", "\n", "num_imgs", "=", "tensor", ".", "size", "(", "0", ")", "\n", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "img", "=", "tensor", "[", "img_id", ",", "...", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "img", "=", "mmcv", ".", "imdenormalize", "(", "\n", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "to_rgb", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "imgs", ".", "append", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", "\n", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply": [[35, 55], ["six.moves.map", "tuple", "functools.partial", "six.moves.map", "six.moves.zip"], "function", ["None"], ["", "def", "multi_apply", "(", "func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Apply function to a list of arguments.\n\n    Note:\n        This function applies the ``func`` to multiple inputs and\n        map the multiple outputs of the ``func`` into different\n        list. Each list contains the same type of outputs corresponding\n        to different inputs.\n\n    Args:\n        func (Function): A function that will be applied to a list of\n            arguments\n\n    Returns:\n        tuple(list): A tuple containing multiple list, each list contains \\\n            a kind of returned results by the function\n    \"\"\"", "\n", "pfunc", "=", "partial", "(", "func", ",", "**", "kwargs", ")", "if", "kwargs", "else", "func", "\n", "map_results", "=", "map", "(", "pfunc", ",", "*", "args", ")", "\n", "return", "tuple", "(", "map", "(", "list", ",", "zip", "(", "*", "map_results", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap": [[57, 68], ["data.dim", "data.new_full", "data.new_full", "inds.type", "data.size", "inds.type"], "function", ["None"], ["", "def", "unmap", "(", "data", ",", "count", ",", "inds", ",", "fill", "=", "0", ")", ":", "\n", "    ", "\"\"\"Unmap a subset of item (data) back to the original set of items (of size\n    count)\"\"\"", "\n", "if", "data", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "ret", "=", "data", ".", "new_full", "(", "(", "count", ",", ")", ",", "fill", ")", "\n", "ret", "[", "inds", ".", "type", "(", "torch", ".", "bool", ")", "]", "=", "data", "\n", "", "else", ":", "\n", "        ", "new_size", "=", "(", "count", ",", ")", "+", "data", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "ret", "=", "data", ".", "new_full", "(", "new_size", ",", "fill", ")", "\n", "ret", "[", "inds", ".", "type", "(", "torch", ".", "bool", ")", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.__init__": [[33, 39], ["set", "panoptic_utils.IdGenerator.categories.values", "panoptic_utils.IdGenerator.taken_colors.add", "tuple"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "categories", ")", ":", "\n", "        ", "self", ".", "taken_colors", "=", "set", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "self", ".", "categories", "=", "categories", "\n", "for", "category", "in", "self", ".", "categories", ".", "values", "(", ")", ":", "\n", "            ", "if", "category", "[", "'isthing'", "]", "==", "0", ":", "\n", "                ", "self", ".", "taken_colors", ".", "add", "(", "tuple", "(", "category", "[", "'color'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_color": [[40, 61], ["tuple", "tuple", "panoptic_utils.IdGenerator.taken_colors.add", "numpy.random.randint", "numpy.maximum", "panoptic_utils.IdGenerator.get_color.random_color"], "methods", ["None"], ["", "", "", "def", "get_color", "(", "self", ",", "cat_id", ")", ":", "\n", "        ", "def", "random_color", "(", "base", ",", "max_dist", "=", "30", ")", ":", "\n", "            ", "new_color", "=", "base", "+", "np", ".", "random", ".", "randint", "(", "low", "=", "-", "max_dist", ",", "\n", "high", "=", "max_dist", "+", "1", ",", "\n", "size", "=", "3", ")", "\n", "return", "tuple", "(", "np", ".", "maximum", "(", "0", ",", "np", ".", "minimum", "(", "255", ",", "new_color", ")", ")", ")", "\n", "\n", "", "category", "=", "self", ".", "categories", "[", "cat_id", "]", "\n", "if", "category", "[", "'isthing'", "]", "==", "0", ":", "\n", "            ", "return", "category", "[", "'color'", "]", "\n", "", "base_color_array", "=", "category", "[", "'color'", "]", "\n", "base_color", "=", "tuple", "(", "base_color_array", ")", "\n", "if", "base_color", "not", "in", "self", ".", "taken_colors", ":", "\n", "            ", "self", ".", "taken_colors", ".", "add", "(", "base_color", ")", "\n", "return", "base_color", "\n", "", "else", ":", "\n", "            ", "while", "True", ":", "\n", "                ", "color", "=", "random_color", "(", "base_color_array", ")", "\n", "if", "color", "not", "in", "self", ".", "taken_colors", ":", "\n", "                    ", "self", ".", "taken_colors", ".", "add", "(", "color", ")", "\n", "return", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id": [[62, 65], ["panoptic_utils.IdGenerator.get_color", "panoptic_utils.rgb2id"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_color", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id"], ["", "", "", "", "def", "get_id", "(", "self", ",", "cat_id", ")", ":", "\n", "        ", "color", "=", "self", ".", "get_color", "(", "cat_id", ")", "\n", "return", "rgb2id", "(", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id_and_color": [[66, 69], ["panoptic_utils.IdGenerator.get_color", "panoptic_utils.rgb2id"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_color", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id"], ["", "def", "get_id_and_color", "(", "self", ",", "cat_id", ")", ":", "\n", "        ", "color", "=", "self", ".", "get_color", "(", "cat_id", ")", "\n", "return", "rgb2id", "(", "color", ")", ",", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.MyJsonEncoder.default": [[98, 109], ["isinstance", "int", "isinstance", "float", "isinstance", "obj.tolist", "isinstance", "str", "super().default"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.MyJsonEncoder.default"], ["    ", "def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "np", ".", "integer", ")", ":", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "np", ".", "floating", ")", ":", "\n", "            ", "return", "float", "(", "obj", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "return", "obj", ".", "tolist", "(", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "bytes", ")", ":", "\n", "            ", "return", "str", "(", "obj", ",", "encoding", "=", "'utf-8'", ")", "\n", "", "else", ":", "\n", "            ", "return", "super", "(", "MyJsonEncoder", ",", "self", ")", ".", "default", "(", "obj", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.get_traceback": [[10, 21], ["functools.wraps", "f", "print", "traceback.print_exc"], "function", ["None"], ["def", "get_traceback", "(", "f", ")", ":", "\n", "    ", "\"\"\"The decorator is used to prints an error thrown inside process\"\"\"", "\n", "@", "functools", ".", "wraps", "(", "f", ")", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "'Caught exception in worker thread:'", ")", "\n", "traceback", ".", "print_exc", "(", ")", "\n", "raise", "e", "\n", "", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id": [[71, 79], ["isinstance", "len", "color.astype.astype"], "function", ["None"], ["", "", "def", "rgb2id", "(", "color", ")", ":", "\n", "    ", "if", "isinstance", "(", "color", ",", "np", ".", "ndarray", ")", "and", "len", "(", "color", ".", "shape", ")", "==", "3", ":", "\n", "        ", "if", "color", ".", "dtype", "==", "np", ".", "uint8", ":", "\n", "            ", "color", "=", "color", ".", "astype", "(", "np", ".", "uint32", ")", "\n", "", "return", "color", "[", ":", ",", ":", ",", "0", "]", "+", "256", "*", "color", "[", ":", ",", ":", ",", "1", "]", "+", "256", "*", "256", "*", "color", "[", ":", ",", ":", ",", "2", "]", "\n", "", "return", "color", "[", "0", "]", "+", "256", "*", "color", "[", "1", "]", "+", "256", "*", "256", "*", "color", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.id2rgb": [[81, 95], ["isinstance", "range", "id_map.copy", "tuple", "numpy.zeros", "range", "color.append", "list"], "function", ["None"], ["", "def", "id2rgb", "(", "id_map", ")", ":", "\n", "    ", "if", "isinstance", "(", "id_map", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "id_map_copy", "=", "id_map", ".", "copy", "(", ")", "\n", "rgb_shape", "=", "tuple", "(", "list", "(", "id_map", ".", "shape", ")", "+", "[", "3", "]", ")", "\n", "rgb_map", "=", "np", ".", "zeros", "(", "rgb_shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "rgb_map", "[", "...", ",", "i", "]", "=", "id_map_copy", "%", "256", "\n", "id_map_copy", "//=", "256", "\n", "", "return", "rgb_map", "\n", "", "color", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "color", ".", "append", "(", "id_map", "%", "256", ")", "\n", "id_map", "//=", "256", "\n", "", "return", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.__init__": [[50, 102], ["custom.CustomDataset.get_classes", "custom.CustomDataset.load_annotations", "pipelines.Compose", "custom.CustomDataset.get_subset_by_classes", "custom.CustomDataset.load_proposals", "custom.CustomDataset._filter_imgs", "custom.CustomDataset._set_group_flag", "os.isabs", "os.join", "os.join", "os.join", "os.join", "os.isabs", "os.isabs", "os.isabs"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.get_classes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.lvis.LVISV1Dataset.load_annotations", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_subset_by_classes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.load_proposals", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._filter_imgs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset._set_group_flag"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "pipeline", ",", "\n", "classes", "=", "None", ",", "\n", "data_root", "=", "None", ",", "\n", "img_prefix", "=", "''", ",", "\n", "seg_prefix", "=", "None", ",", "\n", "proposal_file", "=", "None", ",", "\n", "test_mode", "=", "False", ",", "\n", "filter_empty_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "ann_file", "=", "ann_file", "\n", "self", ".", "data_root", "=", "data_root", "\n", "self", ".", "img_prefix", "=", "img_prefix", "\n", "self", ".", "seg_prefix", "=", "seg_prefix", "\n", "self", ".", "proposal_file", "=", "proposal_file", "\n", "self", ".", "test_mode", "=", "test_mode", "\n", "self", ".", "filter_empty_gt", "=", "filter_empty_gt", "\n", "self", ".", "CLASSES", "=", "self", ".", "get_classes", "(", "classes", ")", "\n", "\n", "# join paths if data_root is specified", "\n", "if", "self", ".", "data_root", "is", "not", "None", ":", "\n", "            ", "if", "not", "osp", ".", "isabs", "(", "self", ".", "ann_file", ")", ":", "\n", "                ", "self", ".", "ann_file", "=", "osp", ".", "join", "(", "self", ".", "data_root", ",", "self", ".", "ann_file", ")", "\n", "", "if", "not", "(", "self", ".", "img_prefix", "is", "None", "or", "osp", ".", "isabs", "(", "self", ".", "img_prefix", ")", ")", ":", "\n", "                ", "self", ".", "img_prefix", "=", "osp", ".", "join", "(", "self", ".", "data_root", ",", "self", ".", "img_prefix", ")", "\n", "", "if", "not", "(", "self", ".", "seg_prefix", "is", "None", "or", "osp", ".", "isabs", "(", "self", ".", "seg_prefix", ")", ")", ":", "\n", "                ", "self", ".", "seg_prefix", "=", "osp", ".", "join", "(", "self", ".", "data_root", ",", "self", ".", "seg_prefix", ")", "\n", "", "if", "not", "(", "self", ".", "proposal_file", "is", "None", "\n", "or", "osp", ".", "isabs", "(", "self", ".", "proposal_file", ")", ")", ":", "\n", "                ", "self", ".", "proposal_file", "=", "osp", ".", "join", "(", "self", ".", "data_root", ",", "\n", "self", ".", "proposal_file", ")", "\n", "# load annotations (and proposals)", "\n", "", "", "self", ".", "data_infos", "=", "self", ".", "load_annotations", "(", "self", ".", "ann_file", ")", "\n", "# filter data infos if classes are customized", "\n", "if", "self", ".", "custom_classes", ":", "\n", "            ", "self", ".", "data_infos", "=", "self", ".", "get_subset_by_classes", "(", ")", "\n", "\n", "", "if", "self", ".", "proposal_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposals", "=", "self", ".", "load_proposals", "(", "self", ".", "proposal_file", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "None", "\n", "# filter images too small", "\n", "", "if", "not", "test_mode", ":", "\n", "            ", "valid_inds", "=", "self", ".", "_filter_imgs", "(", ")", "\n", "self", ".", "data_infos", "=", "[", "self", ".", "data_infos", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "                ", "self", ".", "proposals", "=", "[", "self", ".", "proposals", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "# set group flag for the sampler", "\n", "", "", "if", "not", "self", ".", "test_mode", ":", "\n", "            ", "self", ".", "_set_group_flag", "(", ")", "\n", "# processing pipeline", "\n", "", "self", ".", "pipeline", "=", "Compose", "(", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.__len__": [[103, 106], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Total number of samples of data.\"\"\"", "\n", "return", "len", "(", "self", ".", "data_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.load_annotations": [[107, 110], ["mmcv.load"], "methods", ["None"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from annotation file.\"\"\"", "\n", "return", "mmcv", ".", "load", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.load_proposals": [[111, 114], ["mmcv.load"], "methods", ["None"], ["", "def", "load_proposals", "(", "self", ",", "proposal_file", ")", ":", "\n", "        ", "\"\"\"Load proposal from proposal file.\"\"\"", "\n", "return", "mmcv", ".", "load", "(", "proposal_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.get_ann_info": [[115, 126], ["None"], "methods", ["None"], ["", "def", "get_ann_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get annotation by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Annotation info of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "data_infos", "[", "idx", "]", "[", "'ann'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.get_cat_ids": [[127, 138], ["[].astype().tolist", "[].astype"], "methods", ["None"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "data_infos", "[", "idx", "]", "[", "'ann'", "]", "[", "'labels'", "]", ".", "astype", "(", "np", ".", "int", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.pre_pipeline": [[139, 147], ["None"], "methods", ["None"], ["", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Prepare results dict for pipeline.\"\"\"", "\n", "results", "[", "'img_prefix'", "]", "=", "self", ".", "img_prefix", "\n", "results", "[", "'seg_prefix'", "]", "=", "self", ".", "seg_prefix", "\n", "results", "[", "'proposal_file'", "]", "=", "self", ".", "proposal_file", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "results", "[", "'seg_fields'", "]", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset._filter_imgs": [[148, 155], ["enumerate", "min", "valid_inds.append"], "methods", ["None"], ["", "def", "_filter_imgs", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n", "for", "i", ",", "img_info", "in", "enumerate", "(", "self", ".", "data_infos", ")", ":", "\n", "            ", "if", "min", "(", "img_info", "[", "'width'", "]", ",", "img_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n", "", "", "return", "valid_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset._set_group_flag": [[156, 167], ["numpy.zeros", "range", "len", "len"], "methods", ["None"], ["", "def", "_set_group_flag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set flag according to image aspect ratio.\n\n        Images with aspect ratio greater than 1 will be set as group 1,\n        otherwise group 0.\n        \"\"\"", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_info", "=", "self", ".", "data_infos", "[", "i", "]", "\n", "if", "img_info", "[", "'width'", "]", "/", "img_info", "[", "'height'", "]", ">", "1", ":", "\n", "                ", "self", ".", "flag", "[", "i", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset._rand_another": [[168, 172], ["numpy.random.choice", "numpy.where"], "methods", ["None"], ["", "", "", "def", "_rand_another", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get another random index from the same group as the given index.\"\"\"", "\n", "pool", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "self", ".", "flag", "[", "idx", "]", ")", "[", "0", "]", "\n", "return", "np", ".", "random", ".", "choice", "(", "pool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.__getitem__": [[173, 192], ["custom.CustomDataset.prepare_test_img", "custom.CustomDataset.prepare_train_img", "custom.CustomDataset._rand_another"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.prepare_test_img", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.prepare_train_img", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset._rand_another"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get training/test data after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Training/test data (with annotation if `test_mode` is set \\\n                True).\n        \"\"\"", "\n", "\n", "if", "self", ".", "test_mode", ":", "\n", "            ", "return", "self", ".", "prepare_test_img", "(", "idx", ")", "\n", "", "while", "True", ":", "\n", "            ", "data", "=", "self", ".", "prepare_train_img", "(", "idx", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "idx", "=", "self", ".", "_rand_another", "(", "idx", ")", "\n", "continue", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.prepare_train_img": [[193, 211], ["custom.CustomDataset.get_ann_info", "dict", "custom.CustomDataset.pre_pipeline", "custom.CustomDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_ann_info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.pre_pipeline"], ["", "", "def", "prepare_train_img", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys \\\n                introduced by pipeline.\n        \"\"\"", "\n", "\n", "img_info", "=", "self", ".", "data_infos", "[", "idx", "]", "\n", "ann_info", "=", "self", ".", "get_ann_info", "(", "idx", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "results", "[", "'proposals'", "]", "=", "self", ".", "proposals", "[", "idx", "]", "\n", "", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.prepare_test_img": [[212, 229], ["dict", "custom.CustomDataset.pre_pipeline", "custom.CustomDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.pre_pipeline"], ["", "def", "prepare_test_img", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get testing data  after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Testing data after pipeline with new keys intorduced by \\\n                piepline.\n        \"\"\"", "\n", "\n", "img_info", "=", "self", ".", "data_infos", "[", "idx", "]", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "results", "[", "'proposals'", "]", "=", "self", ".", "proposals", "[", "idx", "]", "\n", "", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.get_classes": [[230, 255], ["isinstance", "mmcv.list_from_file", "isinstance", "ValueError", "type"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "get_classes", "(", "cls", ",", "classes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get class names of current dataset.\n\n        Args:\n            classes (Sequence[str] | str | None): If classes is None, use\n                default CLASSES defined by builtin dataset. If classes is a\n                string, take it as a file name. The file contains the name of\n                classes where each line contains one class name. If classes is\n                a tuple or list, override the CLASSES defined by the dataset.\n        \"\"\"", "\n", "if", "classes", "is", "None", ":", "\n", "            ", "cls", ".", "custom_classes", "=", "False", "\n", "return", "cls", ".", "CLASSES", "\n", "\n", "", "cls", ".", "custom_classes", "=", "True", "\n", "if", "isinstance", "(", "classes", ",", "str", ")", ":", "\n", "# take it as a file path", "\n", "            ", "class_names", "=", "mmcv", ".", "list_from_file", "(", "classes", ")", "\n", "", "elif", "isinstance", "(", "classes", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "class_names", "=", "classes", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported type {type(classes)} of classes.'", ")", "\n", "\n", "", "return", "class_names", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.get_subset_by_classes": [[256, 258], ["None"], "methods", ["None"], ["", "def", "get_subset_by_classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.format_results": [[259, 262], ["None"], "methods", ["None"], ["", "def", "format_results", "(", "self", ",", "results", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Place holder to format result to dataset specific output.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.custom.CustomDataset.evaluate": [[263, 319], ["isinstance", "KeyError", "custom.CustomDataset.get_ann_info", "isinstance", "mmdet.core.eval_map", "len", "range", "isinstance", "mmdet.core.eval_recalls", "enumerate", "len", "enumerate", "mmdet.core.eval_recalls.mean", "enumerate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_ann_info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.eval_map", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.eval_recalls"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'mAP'", ",", "\n", "logger", "=", "None", ",", "\n", "proposal_nums", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "scale_ranges", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            logger (logging.Logger | None | str): Logger used for printing\n                related information during evaluation. Default: None.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thr (float | list[float]): IoU threshold. It must be a float\n                when evaluating mAP, and can be a list when evaluating recall.\n                Default: 0.5.\n            scale_ranges (list[tuple] | None): Scale ranges for evaluating mAP.\n                Default: None.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "metric", ",", "str", ")", ":", "\n", "            ", "assert", "len", "(", "metric", ")", "==", "1", "\n", "metric", "=", "metric", "[", "0", "]", "\n", "", "allowed_metrics", "=", "[", "'mAP'", ",", "'recall'", "]", "\n", "if", "metric", "not", "in", "allowed_metrics", ":", "\n", "            ", "raise", "KeyError", "(", "f'metric {metric} is not supported'", ")", "\n", "", "annotations", "=", "[", "self", ".", "get_ann_info", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", "]", "\n", "eval_results", "=", "{", "}", "\n", "if", "metric", "==", "'mAP'", ":", "\n", "            ", "assert", "isinstance", "(", "iou_thr", ",", "float", ")", "\n", "mean_ap", ",", "_", "=", "eval_map", "(", "\n", "results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "scale_ranges", ",", "\n", "iou_thr", "=", "iou_thr", ",", "\n", "dataset", "=", "self", ".", "CLASSES", ",", "\n", "logger", "=", "logger", ")", "\n", "eval_results", "[", "'mAP'", "]", "=", "mean_ap", "\n", "", "elif", "metric", "==", "'recall'", ":", "\n", "            ", "gt_bboxes", "=", "[", "ann", "[", "'bboxes'", "]", "for", "ann", "in", "annotations", "]", "\n", "if", "isinstance", "(", "iou_thr", ",", "float", ")", ":", "\n", "                ", "iou_thr", "=", "[", "iou_thr", "]", "\n", "", "recalls", "=", "eval_recalls", "(", "\n", "gt_bboxes", ",", "results", ",", "proposal_nums", ",", "iou_thr", ",", "logger", "=", "logger", ")", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                ", "for", "j", ",", "iou", "in", "enumerate", "(", "iou_thr", ")", ":", "\n", "                    ", "eval_results", "[", "f'recall@{num}@{iou}'", "]", "=", "recalls", "[", "i", ",", "j", "]", "\n", "", "", "if", "recalls", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "                ", "ar", "=", "recalls", ".", "mean", "(", "axis", "=", "1", ")", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                    ", "eval_results", "[", "f'AR@{num}'", "]", "=", "ar", "[", "i", "]", "\n", "", "", "", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.__init__": [[72, 110], ["custom.CustomDataset.__init__", "list", "coco.CocoDataset.STUFF_CLASSES.remove", "tuple", "coco.CocoDataset.seg_ids.remove", "enumerate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "with_panoptic", "=", "False", ",", "\n", "things_other", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "# set as panoptic segmentation", "\n", "        ", "self", ".", "with_panoptic", "=", "with_panoptic", "\n", "# map things to `other` or keep the original category", "\n", "self", ".", "things_other", "=", "things_other", "\n", "\n", "super", "(", "CocoDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "cat2label", "=", "{", "\n", "cat_id", ":", "i", "\n", "for", "i", ",", "cat_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", "\n", "}", "\n", "# for panoptic segmentation", "\n", "self", ".", "seg_ids", "=", "[", "92", ",", "93", ",", "95", ",", "100", ",", "107", ",", "109", ",", "112", ",", "118", ",", "119", ",", "\n", "122", ",", "125", ",", "128", ",", "130", ",", "133", ",", "138", ",", "141", ",", "144", ",", "\n", "145", ",", "147", ",", "148", ",", "149", ",", "151", ",", "154", ",", "155", ",", "156", ",", "\n", "159", ",", "161", ",", "166", ",", "168", ",", "171", ",", "175", ",", "176", ",", "177", ",", "\n", "178", ",", "180", ",", "181", ",", "183", ",", "184", ",", "185", ",", "186", ",", "187", ",", "\n", "188", ",", "189", ",", "190", ",", "191", ",", "192", ",", "193", ",", "194", ",", "195", ",", "\n", "196", ",", "197", ",", "198", ",", "199", ",", "200", "]", "\n", "if", "not", "self", ".", "things_other", ":", "\n", "# remove 'things-other' (convert tuple to list)", "\n", "            ", "self", ".", "STUFF_CLASSES", "=", "list", "(", "self", ".", "STUFF_CLASSES", ")", "\n", "self", ".", "STUFF_CLASSES", ".", "remove", "(", "'things-other'", ")", "\n", "self", ".", "STUFF_CLASSES", "=", "tuple", "(", "self", ".", "STUFF_CLASSES", ")", "\n", "# remove the `things-other` cat id", "\n", "self", ".", "seg_ids", ".", "remove", "(", "183", ")", "\n", "# when perform panoptic segmentation, thing classes will be", "\n", "# considered once not things_other", "\n", "if", "self", ".", "with_panoptic", ":", "\n", "                ", "self", ".", "STUFF_CLASSES", "=", "self", ".", "THINGS_CLASSES", "+", "self", ".", "STUFF_CLASSES", "\n", "self", ".", "seg_ids", "=", "self", ".", "cat_ids", "+", "self", ".", "seg_ids", "\n", "", "", "self", ".", "seg2label", "=", "{", "\n", "seg_id", ":", "i", "+", "1", "\n", "for", "i", ",", "seg_id", "in", "enumerate", "(", "self", ".", "seg_ids", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.load_annotations": [[112, 131], ["pycocotools.coco.COCO", "coco.CocoDataset.coco.getCatIds", "coco.CocoDataset.coco.getImgIds", "data_infos.append", "coco.CocoDataset.coco.loadImgs"], "methods", ["None"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from COCO style annotation file.\n\n        Args:\n            ann_file (str): Path of annotation file.\n\n        Returns:\n            list[dict]: Annotation info from COCO api.\n        \"\"\"", "\n", "\n", "self", ".", "coco", "=", "COCO", "(", "ann_file", ")", "\n", "self", ".", "cat_ids", "=", "self", ".", "coco", ".", "getCatIds", "(", ")", "\n", "self", ".", "img_ids", "=", "self", ".", "coco", ".", "getImgIds", "(", ")", "\n", "data_infos", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "img_ids", ":", "\n", "            ", "info", "=", "self", ".", "coco", ".", "loadImgs", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "info", "[", "'filename'", "]", "=", "info", "[", "'file_name'", "]", "\n", "data_infos", ".", "append", "(", "info", ")", "\n", "", "return", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.get_ann_info": [[132, 146], ["coco.CocoDataset.coco.getAnnIds", "coco.CocoDataset.coco.loadAnns", "coco.CocoDataset._parse_ann_info"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._parse_ann_info"], ["", "def", "get_ann_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get COCO annotation by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Annotation info of specified index.\n        \"\"\"", "\n", "\n", "img_id", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'id'", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "[", "img_id", "]", ")", "\n", "ann_info", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "return", "self", ".", "_parse_ann_info", "(", "self", ".", "data_infos", "[", "idx", "]", ",", "ann_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.get_cat_ids": [[147, 161], ["coco.CocoDataset.coco.getAnnIds", "coco.CocoDataset.coco.loadAnns"], "methods", ["None"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get COCO category ids by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "img_id", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'id'", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "[", "img_id", "]", ")", "\n", "ann_info", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "return", "[", "ann", "[", "'category_id'", "]", "for", "ann", "in", "ann_info", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._filter_imgs": [[162, 172], ["set", "enumerate", "min", "valid_inds.append", "coco.CocoDataset.coco.anns.values"], "methods", ["None"], ["", "def", "_filter_imgs", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small or without ground truths.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n", "ids_with_ann", "=", "set", "(", "_", "[", "'image_id'", "]", "for", "_", "in", "self", ".", "coco", ".", "anns", ".", "values", "(", ")", ")", "\n", "for", "i", ",", "img_info", "in", "enumerate", "(", "self", ".", "data_infos", ")", ":", "\n", "            ", "if", "self", ".", "filter_empty_gt", "and", "self", ".", "img_ids", "[", "i", "]", "not", "in", "ids_with_ann", ":", "\n", "                ", "continue", "\n", "", "if", "min", "(", "img_info", "[", "'width'", "]", ",", "img_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n", "", "", "return", "valid_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.get_subset_by_classes": [[173, 197], ["set", "enumerate", "list", "set", "data_infos.append", "coco.CocoDataset.coco.load_imgs"], "methods", ["None"], ["", "def", "get_subset_by_classes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get img ids that contain any category in class_ids.\n\n        Different from the coco.getImgIds(), this function returns the id if\n        the img contains one of the categories rather than all.\n\n        Args:\n            class_ids (list[int]): list of category ids\n\n        Return:\n            ids (list[int]): integer list of img ids\n        \"\"\"", "\n", "\n", "ids", "=", "set", "(", ")", "\n", "for", "i", ",", "class_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", ":", "\n", "            ", "ids", "|=", "set", "(", "self", ".", "coco", ".", "cat_img_map", "[", "class_id", "]", ")", "\n", "", "self", ".", "img_ids", "=", "list", "(", "ids", ")", "\n", "\n", "data_infos", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "img_ids", ":", "\n", "            ", "info", "=", "self", ".", "coco", ".", "load_imgs", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "info", "[", "'filename'", "]", "=", "info", "[", "'file_name'", "]", "\n", "data_infos", ".", "append", "(", "info", ")", "\n", "", "return", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._parse_ann_info": [[198, 257], ["enumerate", "img_info[].replace", "dict", "dict.get", "max", "max", "dict.get", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros.append", "numpy.zeros.append", "numpy.array.append", "gt_masks_ann.append", "min", "max", "min", "max"], "methods", ["None"], ["", "def", "_parse_ann_info", "(", "self", ",", "img_info", ",", "ann_info", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n\n        Args:\n            ann_info (list[dict]): Annotation info of an image.\n            with_mask (bool): Whether to parse mask annotations.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\\n                labels, masks, seg_map. \"masks\" are raw annotations and not \\\n                decoded into binary masks.\n        \"\"\"", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_bboxes_ignore", "=", "[", "]", "\n", "gt_masks_ann", "=", "[", "]", "\n", "for", "i", ",", "ann", "in", "enumerate", "(", "ann_info", ")", ":", "\n", "            ", "if", "ann", ".", "get", "(", "'ignore'", ",", "False", ")", ":", "\n", "                ", "continue", "\n", "", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "inter_w", "=", "max", "(", "0", ",", "min", "(", "x1", "+", "w", ",", "img_info", "[", "'width'", "]", ")", "-", "max", "(", "x1", ",", "0", ")", ")", "\n", "inter_h", "=", "max", "(", "0", ",", "min", "(", "y1", "+", "h", ",", "img_info", "[", "'height'", "]", ")", "-", "max", "(", "y1", ",", "0", ")", ")", "\n", "if", "inter_w", "*", "inter_h", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "ann", "[", "'area'", "]", "<=", "0", "or", "w", "<", "1", "or", "h", "<", "1", ":", "\n", "                ", "continue", "\n", "", "if", "ann", "[", "'category_id'", "]", "not", "in", "self", ".", "cat_ids", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", "\n", "if", "ann", ".", "get", "(", "'iscrowd'", ",", "False", ")", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_labels", ".", "append", "(", "self", ".", "cat2label", "[", "ann", "[", "'category_id'", "]", "]", ")", "\n", "gt_masks_ann", ".", "append", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "seg_map", "=", "img_info", "[", "'filename'", "]", ".", "replace", "(", "'jpg'", ",", "'png'", ")", "\n", "\n", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "\n", "labels", "=", "gt_labels", ",", "\n", "bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "masks", "=", "gt_masks_ann", ",", "\n", "seg_map", "=", "seg_map", ")", "\n", "ann", "[", "'seg2label'", "]", "=", "self", ".", "seg2label", "\n", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh": [[258, 276], ["bbox.tolist"], "methods", ["None"], ["", "def", "xyxy2xywh", "(", "self", ",", "bbox", ")", ":", "\n", "        ", "\"\"\"Convert ``xyxy`` style bounding boxes to ``xywh`` style for COCO\n        evaluation.\n\n        Args:\n            bbox (numpy.ndarray): The bounding boxes, shape (4, ), in\n                ``xyxy`` order.\n\n        Returns:\n            list[float]: The converted bounding boxes, in ``xywh`` order.\n        \"\"\"", "\n", "\n", "_bbox", "=", "bbox", ".", "tolist", "(", ")", "\n", "return", "[", "\n", "_bbox", "[", "0", "]", ",", "\n", "_bbox", "[", "1", "]", ",", "\n", "_bbox", "[", "2", "]", "-", "_bbox", "[", "0", "]", ",", "\n", "_bbox", "[", "3", "]", "-", "_bbox", "[", "1", "]", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._proposal2json": [[278, 292], ["range", "len", "range", "dict", "coco.CocoDataset.xyxy2xywh", "float", "json_results.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh"], ["", "def", "_proposal2json", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Convert proposal results to COCO json style.\"\"\"", "\n", "json_results", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_id", "=", "self", ".", "img_ids", "[", "idx", "]", "\n", "bboxes", "=", "results", "[", "idx", "]", "\n", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "data", "=", "dict", "(", ")", "\n", "data", "[", "'image_id'", "]", "=", "img_id", "\n", "data", "[", "'bbox'", "]", "=", "self", ".", "xyxy2xywh", "(", "bboxes", "[", "i", "]", ")", "\n", "data", "[", "'score'", "]", "=", "float", "(", "bboxes", "[", "i", "]", "[", "4", "]", ")", "\n", "data", "[", "'category_id'", "]", "=", "1", "\n", "json_results", ".", "append", "(", "data", ")", "\n", "", "", "return", "json_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._det2json": [[293, 309], ["range", "len", "range", "len", "range", "dict", "coco.CocoDataset.xyxy2xywh", "float", "json_results.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh"], ["", "def", "_det2json", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Convert detection results to COCO json style.\"\"\"", "\n", "json_results", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_id", "=", "self", ".", "img_ids", "[", "idx", "]", "\n", "result", "=", "results", "[", "idx", "]", "\n", "for", "label", "in", "range", "(", "len", "(", "result", ")", ")", ":", "\n", "                ", "bboxes", "=", "result", "[", "label", "]", "\n", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "data", "=", "dict", "(", ")", "\n", "data", "[", "'image_id'", "]", "=", "img_id", "\n", "data", "[", "'bbox'", "]", "=", "self", ".", "xyxy2xywh", "(", "bboxes", "[", "i", "]", ")", "\n", "data", "[", "'score'", "]", "=", "float", "(", "bboxes", "[", "i", "]", "[", "4", "]", ")", "\n", "data", "[", "'category_id'", "]", "=", "self", ".", "cat_ids", "[", "label", "]", "\n", "json_results", ".", "append", "(", "data", ")", "\n", "", "", "", "return", "json_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._segm2json": [[310, 347], ["range", "len", "range", "len", "range", "isinstance", "range", "dict", "coco.CocoDataset.xyxy2xywh", "float", "bbox_json_results.append", "dict", "coco.CocoDataset.xyxy2xywh", "float", "isinstance", "segm_json_results.append", "[].decode"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_segm2json", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Convert instance segmentation results to COCO json style.\"\"\"", "\n", "bbox_json_results", "=", "[", "]", "\n", "segm_json_results", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_id", "=", "self", ".", "img_ids", "[", "idx", "]", "\n", "det", ",", "seg", "=", "results", "[", "idx", "]", "\n", "for", "label", "in", "range", "(", "len", "(", "det", ")", ")", ":", "\n", "# bbox results", "\n", "                ", "bboxes", "=", "det", "[", "label", "]", "\n", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "data", "=", "dict", "(", ")", "\n", "data", "[", "'image_id'", "]", "=", "img_id", "\n", "data", "[", "'bbox'", "]", "=", "self", ".", "xyxy2xywh", "(", "bboxes", "[", "i", "]", ")", "\n", "data", "[", "'score'", "]", "=", "float", "(", "bboxes", "[", "i", "]", "[", "4", "]", ")", "\n", "data", "[", "'category_id'", "]", "=", "self", ".", "cat_ids", "[", "label", "]", "\n", "bbox_json_results", ".", "append", "(", "data", ")", "\n", "\n", "# segm results", "\n", "# some detectors use different scores for bbox and mask", "\n", "", "if", "isinstance", "(", "seg", ",", "tuple", ")", ":", "\n", "                    ", "segms", "=", "seg", "[", "0", "]", "[", "label", "]", "\n", "mask_score", "=", "seg", "[", "1", "]", "[", "label", "]", "\n", "", "else", ":", "\n", "                    ", "segms", "=", "seg", "[", "label", "]", "\n", "mask_score", "=", "[", "bbox", "[", "4", "]", "for", "bbox", "in", "bboxes", "]", "\n", "", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "data", "=", "dict", "(", ")", "\n", "data", "[", "'image_id'", "]", "=", "img_id", "\n", "data", "[", "'bbox'", "]", "=", "self", ".", "xyxy2xywh", "(", "bboxes", "[", "i", "]", ")", "\n", "data", "[", "'score'", "]", "=", "float", "(", "mask_score", "[", "i", "]", ")", "\n", "data", "[", "'category_id'", "]", "=", "self", ".", "cat_ids", "[", "label", "]", "\n", "if", "isinstance", "(", "segms", "[", "i", "]", "[", "'counts'", "]", ",", "bytes", ")", ":", "\n", "                        ", "segms", "[", "i", "]", "[", "'counts'", "]", "=", "segms", "[", "i", "]", "[", "'counts'", "]", ".", "decode", "(", ")", "\n", "", "data", "[", "'segmentation'", "]", "=", "segms", "[", "i", "]", "\n", "segm_json_results", ".", "append", "(", "data", ")", "\n", "", "", "", "return", "bbox_json_results", ",", "segm_json_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._panoptic2json": [[348, 399], ["range", "len", "range", "range", "len", "range", "range", "len", "isinstance", "dict", "stuff_label_result[].decode", "stuff_json_results.append", "dict", "coco.CocoDataset.xyxy2xywh", "float", "bbox_json_results.append", "len", "dict", "float", "[].decode", "segm_json_results.append", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.xyxy2xywh", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_panoptic2json", "(", "self", ",", "results", ")", ":", "\n", "        ", "bbox_json_results", "=", "[", "]", "\n", "segm_json_results", "=", "[", "]", "\n", "stuff_json_results", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_id", "=", "self", ".", "img_ids", "[", "idx", "]", "\n", "det", ",", "seg", ",", "stuff", "=", "results", "[", "idx", "]", "\n", "for", "thing_label", "in", "range", "(", "len", "(", "det", ")", ")", ":", "\n", "# bbox results", "\n", "                ", "bboxes", "=", "det", "[", "thing_label", "]", "\n", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "det_data", "=", "dict", "(", ")", "\n", "det_data", "[", "'image_id'", "]", "=", "img_id", "\n", "det_data", "[", "'bbox'", "]", "=", "self", ".", "xyxy2xywh", "(", "bboxes", "[", "i", "]", ")", "\n", "det_data", "[", "'score'", "]", "=", "float", "(", "bboxes", "[", "i", "]", "[", "4", "]", ")", "\n", "det_data", "[", "'category_id'", "]", "=", "self", ".", "cat_ids", "[", "thing_label", "]", "\n", "bbox_json_results", ".", "append", "(", "det_data", ")", "\n", "\n", "# segm results", "\n", "# some detectors use different score for det and segm", "\n", "", "if", "len", "(", "seg", ")", "==", "2", ":", "\n", "                    ", "segms", "=", "seg", "[", "0", "]", "[", "thing_label", "]", "\n", "mask_score", "=", "seg", "[", "1", "]", "[", "thing_label", "]", "\n", "", "else", ":", "\n", "                    ", "segms", "=", "seg", "[", "thing_label", "]", "\n", "mask_score", "=", "[", "bbox", "[", "4", "]", "for", "bbox", "in", "bboxes", "]", "\n", "", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "segm_data", "=", "dict", "(", ")", "\n", "segm_data", "[", "'image_id'", "]", "=", "img_id", "\n", "segm_data", "[", "'score'", "]", "=", "float", "(", "mask_score", "[", "i", "]", ")", "\n", "segm_data", "[", "'category_id'", "]", "=", "self", ".", "cat_ids", "[", "thing_label", "]", "\n", "segms", "[", "i", "]", "[", "'counts'", "]", "=", "segms", "[", "i", "]", "[", "'counts'", "]", ".", "decode", "(", ")", "\n", "segm_data", "[", "'segmentation'", "]", "=", "segms", "[", "i", "]", "\n", "segm_json_results", ".", "append", "(", "segm_data", ")", "\n", "\n", "", "", "for", "stuff_label", "in", "range", "(", "len", "(", "stuff", ")", ")", ":", "\n", "                ", "stuff_label_result", "=", "stuff", "[", "stuff_label", "]", "\n", "assert", "isinstance", "(", "stuff_label_result", ",", "list", ")", "\n", "if", "len", "(", "stuff_label_result", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "stuff_label_result", "=", "stuff_label_result", "[", "0", "]", "\n", "", "stuff_data", "=", "dict", "(", ")", "\n", "stuff_data", "[", "'image_id'", "]", "=", "img_id", "\n", "stuff_data", "[", "'category_id'", "]", "=", "self", ".", "seg_ids", "[", "stuff_label", "]", "\n", "stuff_label_result", "[", "'counts'", "]", "=", "stuff_label_result", "[", "'counts'", "]", ".", "decode", "(", ")", "\n", "stuff_data", "[", "'segmentation'", "]", "=", "stuff_label_result", "\n", "stuff_json_results", ".", "append", "(", "stuff_data", ")", "\n", "\n", "", "", "return", "bbox_json_results", ",", "segm_json_results", ",", "stuff_json_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.results2json": [[400, 451], ["dict", "isinstance", "coco.CocoDataset._det2json", "mmcv.dump", "isinstance", "isinstance", "len", "coco.CocoDataset._segm2json", "mmcv.dump", "mmcv.dump", "coco.CocoDataset._proposal2json", "mmcv.dump", "TypeError", "len", "coco.CocoDataset._panoptic2json", "mmcv.dump", "mmcv.dump", "mmcv.dump"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._det2json", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._segm2json", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._proposal2json", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset._panoptic2json"], ["", "def", "results2json", "(", "self", ",", "results", ",", "outfile_prefix", ")", ":", "\n", "        ", "\"\"\"Dump the detection results to a COCO style json file.\n\n        There are 3 types of results: proposals, bbox predictions, mask\n        predictions, and they have different data types. This method will\n        automatically recognize the type, and dump them to json files.\n\n        Args:\n            results (list[list | tuple | ndarray]): Testing results of the\n                dataset.\n            outfile_prefix (str): The filename prefix of the json files. If the\n                prefix is \"somepath/xxx\", the json files will be named\n                \"somepath/xxx.bbox.json\", \"somepath/xxx.segm.json\",\n                \"somepath/xxx.proposal.json\".\n\n        Returns:\n            dict[str: str]: Possible keys are \"bbox\", \"segm\", \"proposal\", and \\\n                values are corresponding filenames.\n        \"\"\"", "\n", "result_files", "=", "dict", "(", ")", "\n", "if", "isinstance", "(", "results", "[", "0", "]", ",", "list", ")", ":", "\n", "            ", "json_results", "=", "self", ".", "_det2json", "(", "results", ")", "\n", "result_files", "[", "'bbox'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "result_files", "[", "'proposal'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "mmcv", ".", "dump", "(", "json_results", ",", "result_files", "[", "'bbox'", "]", ")", "\n", "", "elif", "isinstance", "(", "results", "[", "0", "]", ",", "tuple", ")", ":", "\n", "# instance segmentation", "\n", "            ", "if", "len", "(", "results", "[", "0", "]", ")", "==", "2", ":", "\n", "                ", "json_results", "=", "self", ".", "_segm2json", "(", "results", ")", "\n", "result_files", "[", "'bbox'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "result_files", "[", "'proposal'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "result_files", "[", "'segm'", "]", "=", "f'{outfile_prefix}.segm.json'", "\n", "mmcv", ".", "dump", "(", "json_results", "[", "0", "]", ",", "result_files", "[", "'bbox'", "]", ")", "\n", "mmcv", ".", "dump", "(", "json_results", "[", "1", "]", ",", "result_files", "[", "'segm'", "]", ")", "\n", "# panoptic segmentation", "\n", "", "elif", "len", "(", "results", "[", "0", "]", ")", "==", "3", ":", "\n", "                ", "json_results", "=", "self", ".", "_panoptic2json", "(", "results", ")", "\n", "result_files", "[", "'bbox'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "result_files", "[", "'proposal'", "]", "=", "f'{outfile_prefix}.bbox.json'", "\n", "result_files", "[", "'segm'", "]", "=", "f'{outfile_prefix}.segm.json'", "\n", "result_files", "[", "'stuff'", "]", "=", "f'{outfile_prefix}.stuff.json'", "\n", "mmcv", ".", "dump", "(", "json_results", "[", "0", "]", ",", "result_files", "[", "'bbox'", "]", ")", "\n", "mmcv", ".", "dump", "(", "json_results", "[", "1", "]", ",", "result_files", "[", "'segm'", "]", ")", "\n", "mmcv", ".", "dump", "(", "json_results", "[", "2", "]", ",", "result_files", "[", "'stuff'", "]", ")", "\n", "", "", "elif", "isinstance", "(", "results", "[", "0", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "json_results", "=", "self", ".", "_proposal2json", "(", "results", ")", "\n", "result_files", "[", "'proposal'", "]", "=", "f'{outfile_prefix}.proposal.json'", "\n", "mmcv", ".", "dump", "(", "json_results", ",", "result_files", "[", "'proposal'", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'invalid type of results'", ")", "\n", "", "return", "result_files", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.fast_eval_recall": [[452, 475], ["range", "mmdet.core.eval_recalls", "mmdet.core.eval_recalls.mean", "len", "coco.CocoDataset.coco.get_ann_ids", "coco.CocoDataset.coco.load_anns", "numpy.array", "gt_bboxes.append", "len", "gt_bboxes.append", "numpy.zeros.append", "numpy.zeros", "numpy.zeros", "ann.get"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.eval_recalls"], ["", "def", "fast_eval_recall", "(", "self", ",", "results", ",", "proposal_nums", ",", "iou_thrs", ",", "logger", "=", "None", ")", ":", "\n", "        ", "gt_bboxes", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "img_ids", ")", ")", ":", "\n", "            ", "ann_ids", "=", "self", ".", "coco", ".", "get_ann_ids", "(", "img_ids", "=", "self", ".", "img_ids", "[", "i", "]", ")", "\n", "ann_info", "=", "self", ".", "coco", ".", "load_anns", "(", "ann_ids", ")", "\n", "if", "len", "(", "ann_info", ")", "==", "0", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", ")", "\n", "continue", "\n", "", "bboxes", "=", "[", "]", "\n", "for", "ann", "in", "ann_info", ":", "\n", "                ", "if", "ann", ".", "get", "(", "'ignore'", ",", "False", ")", "or", "ann", "[", "'iscrowd'", "]", ":", "\n", "                    ", "continue", "\n", "", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "bboxes", ".", "append", "(", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", ")", "\n", "", "bboxes", "=", "np", ".", "array", "(", "bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "", "gt_bboxes", ".", "append", "(", "bboxes", ")", "\n", "\n", "", "recalls", "=", "eval_recalls", "(", "\n", "gt_bboxes", ",", "results", ",", "proposal_nums", ",", "iou_thrs", ",", "logger", "=", "logger", ")", "\n", "ar", "=", "recalls", ".", "mean", "(", "axis", "=", "1", ")", "\n", "return", "ar", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.format_results": [[476, 503], ["isinstance", "coco.CocoDataset.results2json", "len", "len", "len", "len", "tempfile.TemporaryDirectory", "os.join"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.results2json"], ["", "def", "format_results", "(", "self", ",", "results", ",", "jsonfile_prefix", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Format the results to json (standard format for COCO evaluation).\n\n        Args:\n            results (list[tuple | numpy.ndarray]): Testing results of the\n                dataset.\n            jsonfile_prefix (str | None): The prefix of json files. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n\n        Returns:\n            tuple: (result_files, tmp_dir), result_files is a dict containing \\\n                the json filepaths, tmp_dir is the temporal directory created \\\n                for saving json files when jsonfile_prefix is not specified.\n        \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", ",", "'results must be a list'", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "self", ")", ",", "(", "\n", "'The length of results is not equal to the dataset len: {} != {}'", ".", "\n", "format", "(", "len", "(", "results", ")", ",", "len", "(", "self", ")", ")", ")", "\n", "\n", "if", "jsonfile_prefix", "is", "None", ":", "\n", "            ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "jsonfile_prefix", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'results'", ")", "\n", "", "else", ":", "\n", "            ", "tmp_dir", "=", "None", "\n", "", "result_files", "=", "self", ".", "results2json", "(", "results", ",", "jsonfile_prefix", ")", "\n", "return", "result_files", ",", "tmp_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.evaluate": [[504, 712], ["coco.CocoDataset.format_results", "isinstance", "numpy.linspace", "mmcv.utils.print_log", "pycocotools.cocoeval.COCOeval", "list", "tmp_dir.cleanup", "KeyError", "isinstance", "cfg.get", "cfg.get", "mmdet.core.combine_panoptic_predictions", "mmdet.core.pq_compute", "coco.CocoDataset.fast_eval_recall", "enumerate", "mmcv.utils.print_log", "KeyError", "cocoGt.loadRes", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "pycocotools.cocoeval.COCOeval.summarize", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "pycocotools.cocoeval.COCOeval.summarize", "int", "log_msg.append", "mmcv.utils.print_log", "float", "enumerate", "min", "list", "itertools.zip_longest", "terminaltables.AsciiTable", "mmcv.utils.print_log", "float", "numpy.round", "KeyError", "len", "results_per_category.append", "itertools.chain", "coco.CocoDataset.coco.loadCats", "numpy.mean", "float", "len", "range", "float"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.format_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.combine_panoptic.combine_panoptic_predictions", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.pq_compute", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.fast_eval_recall", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'bbox'", ",", "\n", "logger", "=", "None", ",", "\n", "jsonfile_prefix", "=", "None", ",", "\n", "classwise", "=", "False", ",", "\n", "proposal_nums", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "\n", "iou_thrs", "=", "None", ",", "\n", "metric_items", "=", "None", ",", "\n", "cfg", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluation in COCO protocol.\n\n        Args:\n            results (list[list | tuple]): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated. Options are\n                'bbox', 'segm', 'proposal', 'proposal_fast'.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n            jsonfile_prefix (str | None): The prefix of json files. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n            classwise (bool): Whether to evaluating the AP for each class.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thrs (Sequence[float], optional): IoU threshold used for\n                evaluating recalls/mAPs. If set to a list, the average of all\n                IoUs will also be computed. If not specified, [0.50, 0.55,\n                0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95] will be used.\n                Default: None.\n            metric_items (list[str] | str, optional): Metric items that will\n                be returned. If not specified, ``['AR@100', 'AR@300',\n                'AR@1000', 'AR_s@1000', 'AR_m@1000', 'AR_l@1000' ]`` will be\n                used when ``metric=='proposal'``, ``['mAP', 'mAP_50', 'mAP_75',\n                'mAP_s', 'mAP_m', 'mAP_l']`` will be used when\n                ``metric=='bbox' or metric=='segm'``.\n\n        Returns:\n            dict[str, float]: COCO style evaluation metric.\n        \"\"\"", "\n", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'bbox'", ",", "'segm'", ",", "'proposal'", ",", "'proposal_fast'", ",", "\n", "'panoptic'", "]", "\n", "for", "metric", "in", "metrics", ":", "\n", "            ", "if", "metric", "not", "in", "allowed_metrics", ":", "\n", "                ", "raise", "KeyError", "(", "f'metric {metric} is not supported'", ")", "\n", "", "", "if", "iou_thrs", "is", "None", ":", "\n", "            ", "iou_thrs", "=", "np", ".", "linspace", "(", "\n", ".5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", ".5", ")", "/", ".05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "", "if", "metric_items", "is", "not", "None", ":", "\n", "            ", "if", "not", "isinstance", "(", "metric_items", ",", "list", ")", ":", "\n", "                ", "metric_items", "=", "[", "metric_items", "]", "\n", "\n", "", "", "result_files", ",", "tmp_dir", "=", "self", ".", "format_results", "(", "results", ",", "jsonfile_prefix", ")", "\n", "\n", "eval_results", "=", "{", "}", "\n", "cocoGt", "=", "self", ".", "coco", "\n", "for", "metric", "in", "metrics", ":", "\n", "            ", "msg", "=", "f'Evaluating {metric}...'", "\n", "if", "logger", "is", "None", ":", "\n", "                ", "msg", "=", "'\\n'", "+", "msg", "\n", "", "print_log", "(", "msg", ",", "logger", "=", "logger", ")", "\n", "\n", "if", "metric", "==", "'panoptic'", ":", "\n", "                ", "ins_out_file", "=", "result_files", "[", "'segm'", "]", "\n", "stuff_out_file", "=", "result_files", "[", "'stuff'", "]", "\n", "bbox_out_file", "=", "result_files", "[", "'bbox'", "]", "\n", "using_bbox", "=", "cfg", ".", "get", "(", "'using_bbox'", ",", "False", ")", "\n", "bbox_overlap_thr", "=", "cfg", ".", "get", "(", "'bbox_overlap_thr'", ",", "0.", ")", "\n", "combine_panoptic_predictions", "(", "stuff_out_file", ",", "\n", "ins_out_file", ",", "\n", "bbox_out_file", ",", "\n", "cfg", ".", "images_json_file", ",", "\n", "cfg", ".", "categories_json_file", ",", "\n", "cfg", ".", "segmentations_folder", ",", "\n", "cfg", ".", "panoptic_json_file", ",", "\n", "cfg", ".", "confidence_thr", ",", "\n", "bbox_overlap_thr", ",", "\n", "cfg", ".", "overlap_thr", ",", "\n", "cfg", ".", "stuff_area_limit", ",", "\n", "using_bbox", "=", "using_bbox", ")", "\n", "pq_compute", "(", "cfg", ".", "gt_json_file", ",", "\n", "cfg", ".", "panoptic_json_file", ",", "cfg", ".", "gt_folder", ",", "\n", "cfg", ".", "segmentations_folder", ",", "\n", "logger", ")", "\n", "return", "\"Panoptic Segmentation Evaluated successfully!!!\"", "\n", "\n", "", "if", "metric", "==", "'proposal_fast'", ":", "\n", "                ", "ar", "=", "self", ".", "fast_eval_recall", "(", "\n", "results", ",", "proposal_nums", ",", "iou_thrs", ",", "logger", "=", "'silent'", ")", "\n", "log_msg", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                    ", "eval_results", "[", "f'AR@{num}'", "]", "=", "ar", "[", "i", "]", "\n", "log_msg", ".", "append", "(", "f'\\nAR@{num}\\t{ar[i]:.4f}'", ")", "\n", "", "log_msg", "=", "''", ".", "join", "(", "log_msg", ")", "\n", "print_log", "(", "log_msg", ",", "logger", "=", "logger", ")", "\n", "continue", "\n", "\n", "", "if", "metric", "not", "in", "result_files", ":", "\n", "                ", "raise", "KeyError", "(", "f'{metric} is not in results'", ")", "\n", "", "try", ":", "\n", "                ", "cocoDt", "=", "cocoGt", ".", "loadRes", "(", "result_files", "[", "metric", "]", ")", "\n", "", "except", "IndexError", ":", "\n", "                ", "print_log", "(", "\n", "'The testing results of the whole dataset is empty.'", ",", "\n", "logger", "=", "logger", ",", "\n", "level", "=", "logging", ".", "ERROR", ")", "\n", "break", "\n", "\n", "", "iou_type", "=", "'bbox'", "if", "metric", "==", "'proposal'", "else", "metric", "\n", "cocoEval", "=", "COCOeval", "(", "cocoGt", ",", "cocoDt", ",", "iou_type", ")", "\n", "cocoEval", ".", "params", ".", "catIds", "=", "self", ".", "cat_ids", "\n", "cocoEval", ".", "params", ".", "imgIds", "=", "self", ".", "img_ids", "\n", "cocoEval", ".", "params", ".", "maxDets", "=", "list", "(", "proposal_nums", ")", "\n", "cocoEval", ".", "params", ".", "iouThrs", "=", "iou_thrs", "\n", "# mapping of cocoEval.stats", "\n", "coco_metric_names", "=", "{", "\n", "'mAP'", ":", "0", ",", "\n", "'mAP_50'", ":", "1", ",", "\n", "'mAP_75'", ":", "2", ",", "\n", "'mAP_s'", ":", "3", ",", "\n", "'mAP_m'", ":", "4", ",", "\n", "'mAP_l'", ":", "5", ",", "\n", "'AR@100'", ":", "6", ",", "\n", "'AR@300'", ":", "7", ",", "\n", "'AR@1000'", ":", "8", ",", "\n", "'AR_s@1000'", ":", "9", ",", "\n", "'AR_m@1000'", ":", "10", ",", "\n", "'AR_l@1000'", ":", "11", "\n", "}", "\n", "if", "metric_items", "is", "not", "None", ":", "\n", "                ", "for", "metric_item", "in", "metric_items", ":", "\n", "                    ", "if", "metric_item", "not", "in", "coco_metric_names", ":", "\n", "                        ", "raise", "KeyError", "(", "\n", "f'metric item {metric_item} is not supported'", ")", "\n", "\n", "", "", "", "if", "metric", "==", "'proposal'", ":", "\n", "                ", "cocoEval", ".", "params", ".", "useCats", "=", "0", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "cocoEval", ".", "summarize", "(", ")", "\n", "if", "metric_items", "is", "None", ":", "\n", "                    ", "metric_items", "=", "[", "\n", "'AR@100'", ",", "'AR@300'", ",", "'AR@1000'", ",", "'AR_s@1000'", ",", "\n", "'AR_m@1000'", ",", "'AR_l@1000'", "\n", "]", "\n", "\n", "", "for", "item", "in", "metric_items", ":", "\n", "                    ", "val", "=", "float", "(", "\n", "f'{cocoEval.stats[coco_metric_names[item]]:.3f}'", ")", "\n", "eval_results", "[", "item", "]", "=", "val", "\n", "", "", "else", ":", "\n", "                ", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "cocoEval", ".", "summarize", "(", ")", "\n", "if", "classwise", ":", "# Compute per-category AP", "\n", "# Compute per-category AP", "\n", "# from https://github.com/facebookresearch/detectron2/", "\n", "                    ", "precisions", "=", "cocoEval", ".", "eval", "[", "'precision'", "]", "\n", "# precision: (iou, recall, cls, area range, max dets)", "\n", "assert", "len", "(", "self", ".", "cat_ids", ")", "==", "precisions", ".", "shape", "[", "2", "]", "\n", "\n", "results_per_category", "=", "[", "]", "\n", "for", "idx", ",", "catId", "in", "enumerate", "(", "self", ".", "cat_ids", ")", ":", "\n", "# area range index 0: all area ranges", "\n", "# max dets index -1: typically 100 per image", "\n", "                        ", "nm", "=", "self", ".", "coco", ".", "loadCats", "(", "catId", ")", "[", "0", "]", "\n", "precision", "=", "precisions", "[", ":", ",", ":", ",", "idx", ",", "0", ",", "-", "1", "]", "\n", "precision", "=", "precision", "[", "precision", ">", "-", "1", "]", "\n", "if", "precision", ".", "size", ":", "\n", "                            ", "ap", "=", "np", ".", "mean", "(", "precision", ")", "\n", "", "else", ":", "\n", "                            ", "ap", "=", "float", "(", "'nan'", ")", "\n", "", "results_per_category", ".", "append", "(", "\n", "(", "f'{nm[\"name\"]}'", ",", "f'{float(ap):0.3f}'", ")", ")", "\n", "\n", "", "num_columns", "=", "min", "(", "6", ",", "len", "(", "results_per_category", ")", "*", "2", ")", "\n", "results_flatten", "=", "list", "(", "\n", "itertools", ".", "chain", "(", "*", "results_per_category", ")", ")", "\n", "headers", "=", "[", "'category'", ",", "'AP'", "]", "*", "(", "num_columns", "//", "2", ")", "\n", "results_2d", "=", "itertools", ".", "zip_longest", "(", "*", "[", "\n", "results_flatten", "[", "i", ":", ":", "num_columns", "]", "\n", "for", "i", "in", "range", "(", "num_columns", ")", "\n", "]", ")", "\n", "table_data", "=", "[", "headers", "]", "\n", "table_data", "+=", "[", "result", "for", "result", "in", "results_2d", "]", "\n", "table", "=", "AsciiTable", "(", "table_data", ")", "\n", "print_log", "(", "'\\n'", "+", "table", ".", "table", ",", "logger", "=", "logger", ")", "\n", "\n", "", "if", "metric_items", "is", "None", ":", "\n", "                    ", "metric_items", "=", "[", "\n", "'mAP'", ",", "'mAP_50'", ",", "'mAP_75'", ",", "'mAP_s'", ",", "'mAP_m'", ",", "'mAP_l'", "\n", "]", "\n", "\n", "", "for", "metric_item", "in", "metric_items", ":", "\n", "                    ", "key", "=", "f'{metric}_{metric_item}'", "\n", "val", "=", "float", "(", "\n", "f'{cocoEval.stats[coco_metric_names[metric_item]]:.3f}'", "\n", ")", "\n", "eval_results", "[", "key", "]", "=", "val", "\n", "", "ap", "=", "cocoEval", ".", "stats", "[", ":", "6", "]", "\n", "eval_results", "[", "f'{metric}_mAP_copypaste'", "]", "=", "(", "\n", "f'{ap[0]:.3f} {ap[1]:.3f} {ap[2]:.3f} {ap[3]:.3f} '", "\n", "f'{ap[4]:.3f} {ap[5]:.3f}'", ")", "\n", "", "", "if", "tmp_dir", "is", "not", "None", ":", "\n", "            ", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._filter_imgs": [[24, 39], ["set", "enumerate", "cityscapes.CityscapesDataset.coco.getAnnIds", "cityscapes.CityscapesDataset.coco.loadAnns", "all", "min", "valid_inds.append", "cityscapes.CityscapesDataset.coco.anns.values"], "methods", ["None"], ["def", "_filter_imgs", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small or without ground truths.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n", "ids_with_ann", "=", "set", "(", "_", "[", "'image_id'", "]", "for", "_", "in", "self", ".", "coco", ".", "anns", ".", "values", "(", ")", ")", "\n", "for", "i", ",", "img_info", "in", "enumerate", "(", "self", ".", "data_infos", ")", ":", "\n", "            ", "img_id", "=", "img_info", "[", "'id'", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "[", "img_id", "]", ")", "\n", "ann_info", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "all_iscrowd", "=", "all", "(", "[", "_", "[", "'iscrowd'", "]", "for", "_", "in", "ann_info", "]", ")", "\n", "if", "self", ".", "filter_empty_gt", "and", "(", "self", ".", "img_ids", "[", "i", "]", "not", "in", "ids_with_ann", "\n", "or", "all_iscrowd", ")", ":", "\n", "                ", "continue", "\n", "", "if", "min", "(", "img_info", "[", "'width'", "]", ",", "img_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n", "", "", "return", "valid_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._parse_ann_info": [[40, 93], ["enumerate", "dict", "dict.get", "dict.get", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros.append", "numpy.zeros.append", "numpy.array.append", "gt_masks_ann.append"], "methods", ["None"], ["", "def", "_parse_ann_info", "(", "self", ",", "img_info", ",", "ann_info", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n\n        Args:\n            img_info (dict): Image info of an image.\n            ann_info (list[dict]): Annotation info of an image.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, \\\n                bboxes_ignore, labels, masks, seg_map. \\\n                \"masks\" are already decoded into binary masks.\n        \"\"\"", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_bboxes_ignore", "=", "[", "]", "\n", "gt_masks_ann", "=", "[", "]", "\n", "\n", "for", "i", ",", "ann", "in", "enumerate", "(", "ann_info", ")", ":", "\n", "            ", "if", "ann", ".", "get", "(", "'ignore'", ",", "False", ")", ":", "\n", "                ", "continue", "\n", "", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "if", "ann", "[", "'area'", "]", "<=", "0", "or", "w", "<", "1", "or", "h", "<", "1", ":", "\n", "                ", "continue", "\n", "", "if", "ann", "[", "'category_id'", "]", "not", "in", "self", ".", "cat_ids", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", "\n", "if", "ann", ".", "get", "(", "'iscrowd'", ",", "False", ")", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_labels", ".", "append", "(", "self", ".", "cat2label", "[", "ann", "[", "'category_id'", "]", "]", ")", "\n", "gt_masks_ann", ".", "append", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "\n", "labels", "=", "gt_labels", ",", "\n", "bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "masks", "=", "gt_masks_ann", ",", "\n", "seg_map", "=", "img_info", "[", "'segm_file'", "]", ")", "\n", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.results2txt": [[94, 159], ["os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "mmcv.ProgressBar", "range", "len", "len", "os.join", "os.join", "numpy.vstack", "isinstance", "numpy.concatenate", "len", "mmcv.ProgressBar.update", "result_files.append", "ImportError", "os.splitext", "os.splitext", "mmcv.concat_list", "mmcv.concat_list", "numpy.full", "len", "len", "len", "open", "range", "os.basename", "os.basename", "enumerate", "pycocotools.decode().astype", "os.join", "os.join", "mmcv.imwrite", "fout.write", "pycocotools.decode", "os.basename", "os.basename"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "results2txt", "(", "self", ",", "results", ",", "outfile_prefix", ")", ":", "\n", "        ", "\"\"\"Dump the detection results to a txt file.\n\n        Args:\n            results (list[list | tuple]): Testing results of the\n                dataset.\n            outfile_prefix (str): The filename prefix of the json files.\n                If the prefix is \"somepath/xxx\",\n                the txt files will be named \"somepath/xxx.txt\".\n\n        Returns:\n            list[str]: Result txt files which contains corresponding \\\n                instance segmentation images.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "import", "cityscapesscripts", ".", "helpers", ".", "labels", "as", "CSLabels", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please run \"pip install citscapesscripts\" to '", "\n", "'install cityscapesscripts first.'", ")", "\n", "", "result_files", "=", "[", "]", "\n", "os", ".", "makedirs", "(", "outfile_prefix", ",", "exist_ok", "=", "True", ")", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "self", ")", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "result", "=", "results", "[", "idx", "]", "\n", "filename", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'filename'", "]", "\n", "basename", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "filename", ")", ")", "[", "0", "]", "\n", "pred_txt", "=", "osp", ".", "join", "(", "outfile_prefix", ",", "basename", "+", "'_pred.txt'", ")", "\n", "\n", "bbox_result", ",", "segm_result", "=", "result", "\n", "bboxes", "=", "np", ".", "vstack", "(", "bbox_result", ")", "\n", "# segm results", "\n", "if", "isinstance", "(", "segm_result", ",", "tuple", ")", ":", "\n", "# Some detectors use different scores for bbox and mask,", "\n", "# like Mask Scoring R-CNN. Score of segm will be used instead", "\n", "# of bbox score.", "\n", "                ", "segms", "=", "mmcv", ".", "concat_list", "(", "segm_result", "[", "0", "]", ")", "\n", "mask_score", "=", "segm_result", "[", "1", "]", "\n", "", "else", ":", "\n", "# use bbox score for mask score", "\n", "                ", "segms", "=", "mmcv", ".", "concat_list", "(", "segm_result", ")", "\n", "mask_score", "=", "[", "bbox", "[", "-", "1", "]", "for", "bbox", "in", "bboxes", "]", "\n", "", "labels", "=", "[", "\n", "np", ".", "full", "(", "bbox", ".", "shape", "[", "0", "]", ",", "i", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", ",", "bbox", "in", "enumerate", "(", "bbox_result", ")", "\n", "]", "\n", "labels", "=", "np", ".", "concatenate", "(", "labels", ")", "\n", "\n", "assert", "len", "(", "bboxes", ")", "==", "len", "(", "segms", ")", "==", "len", "(", "labels", ")", "\n", "num_instances", "=", "len", "(", "bboxes", ")", "\n", "prog_bar", ".", "update", "(", ")", "\n", "with", "open", "(", "pred_txt", ",", "'w'", ")", "as", "fout", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "                    ", "pred_class", "=", "labels", "[", "i", "]", "\n", "classes", "=", "self", ".", "CLASSES", "[", "pred_class", "]", "\n", "class_id", "=", "CSLabels", ".", "name2label", "[", "classes", "]", ".", "id", "\n", "score", "=", "mask_score", "[", "i", "]", "\n", "mask", "=", "maskUtils", ".", "decode", "(", "segms", "[", "i", "]", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "png_filename", "=", "osp", ".", "join", "(", "outfile_prefix", ",", "\n", "basename", "+", "f'_{i}_{classes}.png'", ")", "\n", "mmcv", ".", "imwrite", "(", "mask", ",", "png_filename", ")", "\n", "fout", ".", "write", "(", "f'{osp.basename(png_filename)} {class_id} '", "\n", "f'{score}\\n'", ")", "\n", "", "", "result_files", ".", "append", "(", "pred_txt", ")", "\n", "\n", "", "return", "result_files", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.format_results": [[160, 193], ["isinstance", "isinstance", "cityscapes.CityscapesDataset.results2txt", "len", "len", "len", "len", "len", "len", "len", "len", "tempfile.TemporaryDirectory", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.results2txt"], ["", "def", "format_results", "(", "self", ",", "results", ",", "txtfile_prefix", "=", "None", ")", ":", "\n", "        ", "\"\"\"Format the results to txt (standard format for Cityscapes\n        evaluation).\n\n        Args:\n            results (list): Testing results of the dataset.\n            txtfile_prefix (str | None): The prefix of txt files. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n\n        Returns:\n            tuple: (result_files, tmp_dir), result_files is a dict containing \\\n                the json filepaths, tmp_dir is the temporal directory created \\\n                for saving txt/png files when txtfile_prefix is not specified.\n        \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", ",", "'results must be a list'", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "self", ")", ",", "(", "\n", "'The length of results is not equal to the dataset len: {} != {}'", ".", "\n", "format", "(", "len", "(", "results", ")", ",", "len", "(", "self", ")", ")", ")", "\n", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", ",", "'results must be a list'", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "self", ")", ",", "(", "\n", "'The length of results is not equal to the dataset len: {} != {}'", ".", "\n", "format", "(", "len", "(", "results", ")", ",", "len", "(", "self", ")", ")", ")", "\n", "\n", "if", "txtfile_prefix", "is", "None", ":", "\n", "            ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "txtfile_prefix", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'results'", ")", "\n", "", "else", ":", "\n", "            ", "tmp_dir", "=", "None", "\n", "", "result_files", "=", "self", ".", "results2txt", "(", "results", ",", "txtfile_prefix", ")", "\n", "\n", "return", "result_files", ",", "tmp_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.evaluate": [[194, 260], ["numpy.arange", "dict", "isinstance", "metric.copy", "dict.update", "metrics.remove", "len", "coco.CocoDataset", "coco.CocoDataset.load_annotations", "dict.update", "cityscapes.CityscapesDataset._evaluate_cityscapes", "coco.CocoDataset.evaluate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.lvis.LVISV1Dataset.load_annotations", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._evaluate_cityscapes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'bbox'", ",", "\n", "logger", "=", "None", ",", "\n", "outfile_prefix", "=", "None", ",", "\n", "classwise", "=", "False", ",", "\n", "proposal_nums", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "\n", "iou_thrs", "=", "np", ".", "arange", "(", "0.5", ",", "0.96", ",", "0.05", ")", ")", ":", "\n", "        ", "\"\"\"Evaluation in Cityscapes/COCO protocol.\n\n        Args:\n            results (list[list | tuple]): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated. Options are\n                'bbox', 'segm', 'proposal', 'proposal_fast'.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n            outfile_prefix (str | None): The prefix of output file. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If results are evaluated with COCO protocol, it would be the\n                prefix of output json file. For example, the metric is 'bbox'\n                and 'segm', then json files would be \"a/b/prefix.bbox.json\" and\n                \"a/b/prefix.segm.json\".\n                If results are evaluated with cityscapes protocol, it would be\n                the prefix of output txt/png files. The output files would be\n                png images under folder \"a/b/prefix/xxx/\" and the file name of\n                images would be written into a txt file\n                \"a/b/prefix/xxx_pred.txt\", where \"xxx\" is the video name of\n                cityscapes. If not specified, a temp file will be created.\n                Default: None.\n            classwise (bool): Whether to evaluating the AP for each class.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thrs (Sequence[float]): IoU threshold used for evaluating\n                recalls. If set to a list, the average recall of all IoUs will\n                also be computed. Default: 0.5.\n\n        Returns:\n            dict[str, float]: COCO style evaluation metric or cityscapes mAP \\\n                and AP@50.\n        \"\"\"", "\n", "eval_results", "=", "dict", "(", ")", "\n", "\n", "metrics", "=", "metric", ".", "copy", "(", ")", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "\n", "if", "'cityscapes'", "in", "metrics", ":", "\n", "            ", "eval_results", ".", "update", "(", "\n", "self", ".", "_evaluate_cityscapes", "(", "results", ",", "outfile_prefix", ",", "logger", ")", ")", "\n", "metrics", ".", "remove", "(", "'cityscapes'", ")", "\n", "\n", "# left metrics are all coco metric", "\n", "", "if", "len", "(", "metrics", ")", ">", "0", ":", "\n", "# create CocoDataset with CityscapesDataset annotation", "\n", "            ", "self_coco", "=", "CocoDataset", "(", "self", ".", "ann_file", ",", "self", ".", "pipeline", ".", "transforms", ",", "\n", "None", ",", "self", ".", "data_root", ",", "self", ".", "img_prefix", ",", "\n", "self", ".", "seg_prefix", ",", "self", ".", "proposal_file", ",", "\n", "self", ".", "test_mode", ",", "self", ".", "filter_empty_gt", ")", "\n", "# TODO: remove this in the future", "\n", "# reload annotations of correct class", "\n", "self_coco", ".", "CLASSES", "=", "self", ".", "CLASSES", "\n", "self_coco", ".", "data_infos", "=", "self_coco", ".", "load_annotations", "(", "self", ".", "ann_file", ")", "\n", "eval_results", ".", "update", "(", "\n", "self_coco", ".", "evaluate", "(", "results", ",", "metrics", ",", "logger", ",", "outfile_prefix", ",", "\n", "classwise", ",", "proposal_nums", ",", "iou_thrs", ")", ")", "\n", "\n", "", "return", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset._evaluate_cityscapes": [[261, 322], ["mmcv.utils.print_log", "cityscapes.CityscapesDataset.format_results", "mmcv.utils.print_log", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.abspath", "os.path.abspath", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "glob.glob", "len", "os.join", "os.join", "os.join", "os.join", "cityscapes.CityscapesDataset.img_prefix.replace", "predictionImgList.append", "CSEval.evaluateImgLists", "tmp_dir.cleanup", "ImportError", "CSEval.getPrediction"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.format_results"], ["", "def", "_evaluate_cityscapes", "(", "self", ",", "results", ",", "txtfile_prefix", ",", "logger", ")", ":", "\n", "        ", "\"\"\"Evaluation in Cityscapes protocol.\n\n        Args:\n            results (list): Testing results of the dataset.\n            txtfile_prefix (str | None): The prefix of output txt file\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n\n        Returns:\n            dict[str: float]: Cityscapes evaluation results, contains 'mAP' \\\n                and 'AP@50'.\n        \"\"\"", "\n", "\n", "try", ":", "\n", "            ", "import", "cityscapesscripts", ".", "evaluation", ".", "evalInstanceLevelSemanticLabeling", "as", "CSEval", "# noqa", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please run \"pip install citscapesscripts\" to '", "\n", "'install cityscapesscripts first.'", ")", "\n", "", "msg", "=", "'Evaluating in Cityscapes style'", "\n", "if", "logger", "is", "None", ":", "\n", "            ", "msg", "=", "'\\n'", "+", "msg", "\n", "", "print_log", "(", "msg", ",", "logger", "=", "logger", ")", "\n", "\n", "result_files", ",", "tmp_dir", "=", "self", ".", "format_results", "(", "results", ",", "txtfile_prefix", ")", "\n", "\n", "if", "tmp_dir", "is", "None", ":", "\n", "            ", "result_dir", "=", "osp", ".", "join", "(", "txtfile_prefix", ",", "'results'", ")", "\n", "", "else", ":", "\n", "            ", "result_dir", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'results'", ")", "\n", "\n", "", "eval_results", "=", "{", "}", "\n", "print_log", "(", "f'Evaluating results under {result_dir} ...'", ",", "logger", "=", "logger", ")", "\n", "\n", "# set global states in cityscapes evaluation API", "\n", "CSEval", ".", "args", ".", "cityscapesPath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_prefix", ",", "'../..'", ")", "\n", "CSEval", ".", "args", ".", "predictionPath", "=", "os", ".", "path", ".", "abspath", "(", "result_dir", ")", "\n", "CSEval", ".", "args", ".", "predictionWalk", "=", "None", "\n", "CSEval", ".", "args", ".", "JSONOutput", "=", "False", "\n", "CSEval", ".", "args", ".", "colorized", "=", "False", "\n", "CSEval", ".", "args", ".", "gtInstancesFile", "=", "os", ".", "path", ".", "join", "(", "result_dir", ",", "\n", "'gtInstances.json'", ")", "\n", "CSEval", ".", "args", ".", "groundTruthSearch", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "img_prefix", ".", "replace", "(", "'leftImg8bit'", ",", "'gtFine'", ")", ",", "\n", "'*/*_gtFine_instanceIds.png'", ")", "\n", "\n", "groundTruthImgList", "=", "glob", ".", "glob", "(", "CSEval", ".", "args", ".", "groundTruthSearch", ")", "\n", "assert", "len", "(", "groundTruthImgList", ")", ",", "'Cannot find ground truth images'", "f' in {CSEval.args.groundTruthSearch}.'", "\n", "predictionImgList", "=", "[", "]", "\n", "for", "gt", "in", "groundTruthImgList", ":", "\n", "            ", "predictionImgList", ".", "append", "(", "CSEval", ".", "getPrediction", "(", "gt", ",", "CSEval", ".", "args", ")", ")", "\n", "", "CSEval_results", "=", "CSEval", ".", "evaluateImgLists", "(", "predictionImgList", ",", "\n", "groundTruthImgList", ",", "\n", "CSEval", ".", "args", ")", "[", "'averages'", "]", "\n", "\n", "eval_results", "[", "'mAP'", "]", "=", "CSEval_results", "[", "'allAp'", "]", "\n", "eval_results", "[", "'AP@50'", "]", "=", "CSEval_results", "[", "'allAp50%'", "]", "\n", "if", "tmp_dir", "is", "not", "None", ":", "\n", "            ", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.wider_face.WIDERFaceDataset.__init__": [[19, 21], ["xml_style.XMLDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "WIDERFaceDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.wider_face.WIDERFaceDataset.load_annotations": [[22, 52], ["mmcv.list_from_file", "os.join", "xml.parse", "xml.parse.getroot", "ET.parse.getroot.find", "int", "int", "data_infos.append", "ET.parse.getroot.find", "dict", "tree.getroot.find.find", "tree.getroot.find.find", "os.join"], "methods", ["None"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from WIDERFace XML style annotation file.\n\n        Args:\n            ann_file (str): Path of XML file.\n\n        Returns:\n            list[dict]: Annotation info from XML file.\n        \"\"\"", "\n", "\n", "data_infos", "=", "[", "]", "\n", "img_ids", "=", "mmcv", ".", "list_from_file", "(", "ann_file", ")", "\n", "for", "img_id", "in", "img_ids", ":", "\n", "            ", "filename", "=", "f'{img_id}.jpg'", "\n", "xml_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'Annotations'", ",", "\n", "f'{img_id}.xml'", ")", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "size", "=", "root", ".", "find", "(", "'size'", ")", "\n", "width", "=", "int", "(", "size", ".", "find", "(", "'width'", ")", ".", "text", ")", "\n", "height", "=", "int", "(", "size", ".", "find", "(", "'height'", ")", ".", "text", ")", "\n", "folder", "=", "root", ".", "find", "(", "'folder'", ")", ".", "text", "\n", "data_infos", ".", "append", "(", "\n", "dict", "(", "\n", "id", "=", "img_id", ",", "\n", "filename", "=", "osp", ".", "join", "(", "folder", ",", "filename", ")", ",", "\n", "width", "=", "width", ",", "\n", "height", "=", "height", ")", ")", "\n", "\n", "", "return", "data_infos", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.__init__": [[22, 26], ["custom.CustomDataset.__init__", "enumerate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "min_size", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "XMLDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "cat2label", "=", "{", "cat", ":", "i", "for", "i", ",", "cat", "in", "enumerate", "(", "self", ".", "CLASSES", ")", "}", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.load_annotations": [[27, 60], ["mmcv.list_from_file", "os.join", "xml.parse", "xml.parse.getroot", "ET.parse.getroot.find", "data_infos.append", "int", "int", "os.join", "PIL.Image.open", "dict", "tree.getroot.find.find", "tree.getroot.find.find"], "methods", ["None"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from XML style ann_file.\n\n        Args:\n            ann_file (str): Path of XML file.\n\n        Returns:\n            list[dict]: Annotation info from XML file.\n        \"\"\"", "\n", "\n", "data_infos", "=", "[", "]", "\n", "img_ids", "=", "mmcv", ".", "list_from_file", "(", "ann_file", ")", "\n", "for", "img_id", "in", "img_ids", ":", "\n", "            ", "filename", "=", "f'JPEGImages/{img_id}.jpg'", "\n", "xml_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'Annotations'", ",", "\n", "f'{img_id}.xml'", ")", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "size", "=", "root", ".", "find", "(", "'size'", ")", "\n", "width", "=", "0", "\n", "height", "=", "0", "\n", "if", "size", "is", "not", "None", ":", "\n", "                ", "width", "=", "int", "(", "size", ".", "find", "(", "'width'", ")", ".", "text", ")", "\n", "height", "=", "int", "(", "size", ".", "find", "(", "'height'", ")", ".", "text", ")", "\n", "", "else", ":", "\n", "                ", "img_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'JPEGImages'", ",", "\n", "'{}.jpg'", ".", "format", "(", "img_id", ")", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_path", ")", "\n", "width", ",", "height", "=", "img", ".", "size", "\n", "", "data_infos", ".", "append", "(", "\n", "dict", "(", "id", "=", "img_id", ",", "filename", "=", "filename", ",", "width", "=", "width", ",", "height", "=", "height", ")", ")", "\n", "\n", "", "return", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_subset_by_classes": [[61, 77], ["os.join", "xml.parse", "xml.parse.getroot", "ET.parse.getroot.findall", "obj.find", "subset_data_infos.append"], "methods", ["None"], ["", "def", "get_subset_by_classes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Filter imgs by user-defined categories.\"\"\"", "\n", "subset_data_infos", "=", "[", "]", "\n", "for", "data_info", "in", "self", ".", "data_infos", ":", "\n", "            ", "img_id", "=", "data_info", "[", "'id'", "]", "\n", "xml_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'Annotations'", ",", "\n", "f'{img_id}.xml'", ")", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "for", "obj", "in", "root", ".", "findall", "(", "'object'", ")", ":", "\n", "                ", "name", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", "\n", "if", "name", "in", "self", ".", "CLASSES", ":", "\n", "                    ", "subset_data_infos", ".", "append", "(", "data_info", ")", "\n", "break", "\n", "\n", "", "", "", "return", "subset_data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_ann_info": [[78, 142], ["os.join", "xml.parse", "xml.parse.getroot", "ET.parse.getroot.findall", "dict", "int", "obj.find", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.zeros", "numpy.zeros", "numpy.array", "obj.find", "int", "int", "int", "int", "numpy.zeros.append", "numpy.array.append", "numpy.zeros.append", "numpy.array.append", "numpy.array", "numpy.array", "numpy.zeros.astype", "numpy.array.astype", "numpy.zeros.astype", "numpy.array.astype", "obj.find", "float", "float", "float", "float", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find"], "methods", ["None"], ["", "def", "get_ann_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get annotation from XML file by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Annotation info of specified index.\n        \"\"\"", "\n", "\n", "img_id", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'id'", "]", "\n", "xml_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'Annotations'", ",", "f'{img_id}.xml'", ")", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "bboxes", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "bboxes_ignore", "=", "[", "]", "\n", "labels_ignore", "=", "[", "]", "\n", "for", "obj", "in", "root", ".", "findall", "(", "'object'", ")", ":", "\n", "            ", "name", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", "\n", "if", "name", "not", "in", "self", ".", "CLASSES", ":", "\n", "                ", "continue", "\n", "", "label", "=", "self", ".", "cat2label", "[", "name", "]", "\n", "difficult", "=", "int", "(", "obj", ".", "find", "(", "'difficult'", ")", ".", "text", ")", "\n", "bnd_box", "=", "obj", ".", "find", "(", "'bndbox'", ")", "\n", "# TODO: check whether it is necessary to use int", "\n", "# Coordinates may be float type", "\n", "bbox", "=", "[", "\n", "int", "(", "float", "(", "bnd_box", ".", "find", "(", "'xmin'", ")", ".", "text", ")", ")", ",", "\n", "int", "(", "float", "(", "bnd_box", ".", "find", "(", "'ymin'", ")", ".", "text", ")", ")", ",", "\n", "int", "(", "float", "(", "bnd_box", ".", "find", "(", "'xmax'", ")", ".", "text", ")", ")", ",", "\n", "int", "(", "float", "(", "bnd_box", ".", "find", "(", "'ymax'", ")", ".", "text", ")", ")", "\n", "]", "\n", "ignore", "=", "False", "\n", "if", "self", ".", "min_size", ":", "\n", "                ", "assert", "not", "self", ".", "test_mode", "\n", "w", "=", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", "\n", "h", "=", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", "\n", "if", "w", "<", "self", ".", "min_size", "or", "h", "<", "self", ".", "min_size", ":", "\n", "                    ", "ignore", "=", "True", "\n", "", "", "if", "difficult", "or", "ignore", ":", "\n", "                ", "bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "labels_ignore", ".", "append", "(", "label", ")", "\n", "", "else", ":", "\n", "                ", "bboxes", ".", "append", "(", "bbox", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "if", "not", "bboxes", ":", "\n", "            ", "bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "labels", "=", "np", ".", "zeros", "(", "(", "0", ",", ")", ")", "\n", "", "else", ":", "\n", "            ", "bboxes", "=", "np", ".", "array", "(", "bboxes", ",", "ndmin", "=", "2", ")", "-", "1", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "", "if", "not", "bboxes_ignore", ":", "\n", "            ", "bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "labels_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", ")", ")", "\n", "", "else", ":", "\n", "            ", "bboxes_ignore", "=", "np", ".", "array", "(", "bboxes_ignore", ",", "ndmin", "=", "2", ")", "-", "1", "\n", "labels_ignore", "=", "np", ".", "array", "(", "labels_ignore", ")", "\n", "", "ann", "=", "dict", "(", "\n", "bboxes", "=", "bboxes", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "labels", "=", "labels", ".", "astype", "(", "np", ".", "int64", ")", ",", "\n", "bboxes_ignore", "=", "bboxes_ignore", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "labels_ignore", "=", "labels_ignore", ".", "astype", "(", "np", ".", "int64", ")", ")", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_cat_ids": [[143, 166], ["os.join", "xml.parse", "xml.parse.getroot", "ET.parse.getroot.findall", "cat_ids.append", "obj.find"], "methods", ["None"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids in XML file by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "cat_ids", "=", "[", "]", "\n", "img_id", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'id'", "]", "\n", "xml_path", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "'Annotations'", ",", "f'{img_id}.xml'", ")", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "for", "obj", "in", "root", ".", "findall", "(", "'object'", ")", ":", "\n", "            ", "name", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", "\n", "if", "name", "not", "in", "self", ".", "CLASSES", ":", "\n", "                ", "continue", "\n", "", "label", "=", "self", ".", "cat2label", "[", "name", "]", "\n", "cat_ids", ".", "append", "(", "label", ")", "\n", "\n", "", "return", "cat_ids", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder._concat_dataset": [[26, 47], ["cfg.get", "cfg.get", "cfg.get", "len", "range", "ConcatDataset", "copy.deepcopy", "isinstance", "isinstance", "isinstance", "datasets.append", "builder.build_dataset"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset"], ["def", "_concat_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "from", ".", "dataset_wrappers", "import", "ConcatDataset", "\n", "ann_files", "=", "cfg", "[", "'ann_file'", "]", "\n", "img_prefixes", "=", "cfg", ".", "get", "(", "'img_prefix'", ",", "None", ")", "\n", "seg_prefixes", "=", "cfg", ".", "get", "(", "'seg_prefix'", ",", "None", ")", "\n", "proposal_files", "=", "cfg", ".", "get", "(", "'proposal_file'", ",", "None", ")", "\n", "\n", "datasets", "=", "[", "]", "\n", "num_dset", "=", "len", "(", "ann_files", ")", "\n", "for", "i", "in", "range", "(", "num_dset", ")", ":", "\n", "        ", "data_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "data_cfg", "[", "'ann_file'", "]", "=", "ann_files", "[", "i", "]", "\n", "if", "isinstance", "(", "img_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'img_prefix'", "]", "=", "img_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "seg_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'seg_prefix'", "]", "=", "seg_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "proposal_files", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'proposal_file'", "]", "=", "proposal_files", "[", "i", "]", "\n", "", "datasets", ".", "append", "(", "build_dataset", "(", "data_cfg", ",", "default_args", ")", ")", "\n", "\n", "", "return", "ConcatDataset", "(", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset": [[49, 66], ["isinstance", "ConcatDataset", "RepeatDataset", "builder.build_dataset", "builder.build_dataset", "ClassBalancedDataset", "isinstance", "builder.build_dataset", "cfg.get", "builder._concat_dataset", "mmcv.utils.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder._concat_dataset"], ["", "def", "build_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "from", ".", "dataset_wrappers", "import", "(", "ConcatDataset", ",", "RepeatDataset", ",", "\n", "ClassBalancedDataset", ")", "\n", "if", "isinstance", "(", "cfg", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "ConcatDataset", "(", "[", "build_dataset", "(", "c", ",", "default_args", ")", "for", "c", "in", "cfg", "]", ")", "\n", "", "elif", "cfg", "[", "'type'", "]", "==", "'RepeatDataset'", ":", "\n", "        ", "dataset", "=", "RepeatDataset", "(", "\n", "build_dataset", "(", "cfg", "[", "'dataset'", "]", ",", "default_args", ")", ",", "cfg", "[", "'times'", "]", ")", "\n", "", "elif", "cfg", "[", "'type'", "]", "==", "'ClassBalancedDataset'", ":", "\n", "        ", "dataset", "=", "ClassBalancedDataset", "(", "\n", "build_dataset", "(", "cfg", "[", "'dataset'", "]", ",", "default_args", ")", ",", "cfg", "[", "'oversample_thr'", "]", ")", "\n", "", "elif", "isinstance", "(", "cfg", ".", "get", "(", "'ann_file'", ")", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "_concat_dataset", "(", "cfg", ",", "default_args", ")", "\n", "", "else", ":", "\n", "        ", "dataset", "=", "build_from_cfg", "(", "cfg", ",", "DATASETS", ",", "default_args", ")", "\n", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader": [[68, 128], ["mmcv.runner.get_dist_info", "torch.utils.data.DataLoader", "functools.partial", "samplers.DistributedGroupSampler", "samplers.DistributedSampler", "samplers.GroupSampler", "functools.partial"], "function", ["None"], ["", "def", "build_dataloader", "(", "dataset", ",", "\n", "samples_per_gpu", ",", "\n", "workers_per_gpu", ",", "\n", "num_gpus", "=", "1", ",", "\n", "dist", "=", "True", ",", "\n", "shuffle", "=", "True", ",", "\n", "seed", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build PyTorch DataLoader.\n\n    In distributed training, each GPU/process has a dataloader.\n    In non-distributed training, there is only one dataloader for all GPUs.\n\n    Args:\n        dataset (Dataset): A PyTorch dataset.\n        samples_per_gpu (int): Number of training samples on each GPU, i.e.,\n            batch size of each GPU.\n        workers_per_gpu (int): How many subprocesses to use for data loading\n            for each GPU.\n        num_gpus (int): Number of GPUs. Only used in non-distributed training.\n        dist (bool): Distributed training/test or not. Default: True.\n        shuffle (bool): Whether to shuffle the data at every epoch.\n            Default: True.\n        kwargs: any keyword argument to be used to initialize DataLoader\n\n    Returns:\n        DataLoader: A PyTorch dataloader.\n    \"\"\"", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "if", "dist", ":", "\n", "# DistributedGroupSampler will definitely shuffle the data to satisfy", "\n", "# that images on each GPU are in the same group", "\n", "        ", "if", "shuffle", ":", "\n", "            ", "sampler", "=", "DistributedGroupSampler", "(", "dataset", ",", "samples_per_gpu", ",", "\n", "world_size", ",", "rank", ")", "\n", "", "else", ":", "\n", "            ", "sampler", "=", "DistributedSampler", "(", "\n", "dataset", ",", "world_size", ",", "rank", ",", "shuffle", "=", "False", ")", "\n", "", "batch_size", "=", "samples_per_gpu", "\n", "num_workers", "=", "workers_per_gpu", "\n", "", "else", ":", "\n", "        ", "sampler", "=", "GroupSampler", "(", "dataset", ",", "samples_per_gpu", ")", "if", "shuffle", "else", "None", "\n", "batch_size", "=", "num_gpus", "*", "samples_per_gpu", "\n", "num_workers", "=", "num_gpus", "*", "workers_per_gpu", "\n", "\n", "", "init_fn", "=", "partial", "(", "\n", "worker_init_fn", ",", "num_workers", "=", "num_workers", ",", "rank", "=", "rank", ",", "\n", "seed", "=", "seed", ")", "if", "seed", "is", "not", "None", "else", "None", "\n", "\n", "data_loader", "=", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "collate_fn", "=", "partial", "(", "collate", ",", "samples_per_gpu", "=", "samples_per_gpu", ")", ",", "\n", "pin_memory", "=", "False", ",", "\n", "worker_init_fn", "=", "init_fn", ",", "\n", "**", "kwargs", ")", "\n", "\n", "return", "data_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.worker_init_fn": [[130, 136], ["numpy.random.seed", "random.seed"], "function", ["None"], ["", "def", "worker_init_fn", "(", "worker_id", ",", "num_workers", ",", "rank", ",", "seed", ")", ":", "\n", "# The seed of each worker equals to", "\n", "# num_worker * rank + worker_id + user_seed", "\n", "    ", "worker_seed", "=", "num_workers", "*", "rank", "+", "worker_id", "+", "seed", "\n", "np", ".", "random", ".", "seed", "(", "worker_seed", ")", "\n", "random", ".", "seed", "(", "worker_seed", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ConcatDataset.__init__": [[22, 30], ["torch.utils.data.dataset.ConcatDataset.__init__", "hasattr", "range", "numpy.concatenate", "len", "flags.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "super", "(", "ConcatDataset", ",", "self", ")", ".", "__init__", "(", "datasets", ")", "\n", "self", ".", "CLASSES", "=", "datasets", "[", "0", "]", ".", "CLASSES", "\n", "if", "hasattr", "(", "datasets", "[", "0", "]", ",", "'flag'", ")", ":", "\n", "            ", "flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "datasets", ")", ")", ":", "\n", "                ", "flags", ".", "append", "(", "datasets", "[", "i", "]", ".", "flag", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "concatenate", "(", "flags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ConcatDataset.get_cat_ids": [[31, 52], ["bisect.bisect_right", "dataset_wrappers.ConcatDataset.datasets[].get_cat_ids", "len", "ValueError", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids of concatenated dataset by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "if", "idx", "<", "0", ":", "\n", "            ", "if", "-", "idx", ">", "len", "(", "self", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'absolute value of index should not exceed dataset length'", ")", "\n", "", "idx", "=", "len", "(", "self", ")", "+", "idx", "\n", "", "dataset_idx", "=", "bisect", ".", "bisect_right", "(", "self", ".", "cumulative_sizes", ",", "idx", ")", "\n", "if", "dataset_idx", "==", "0", ":", "\n", "            ", "sample_idx", "=", "idx", "\n", "", "else", ":", "\n", "            ", "sample_idx", "=", "idx", "-", "self", ".", "cumulative_sizes", "[", "dataset_idx", "-", "1", "]", "\n", "", "return", "self", ".", "datasets", "[", "dataset_idx", "]", ".", "get_cat_ids", "(", "sample_idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.__init__": [[68, 76], ["hasattr", "len", "numpy.tile"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "times", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "times", "=", "times", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "self", ".", "flag", "=", "np", ".", "tile", "(", "self", ".", "dataset", ".", "flag", ",", "times", ")", "\n", "\n", "", "self", ".", "_ori_len", "=", "len", "(", "self", ".", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.__getitem__": [[77, 79], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "dataset", "[", "idx", "%", "self", ".", "_ori_len", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids": [[80, 91], ["dataset_wrappers.RepeatDataset.dataset.get_cat_ids"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids of repeat dataset by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", "%", "self", ".", "_ori_len", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.__len__": [[92, 95], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Length after repetition.\"\"\"", "\n", "return", "self", ".", "times", "*", "self", ".", "_ori_len", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ClassBalancedDataset.__init__": [[131, 148], ["dataset_wrappers.ClassBalancedDataset._get_repeat_factors", "enumerate", "hasattr", "numpy.asarray", "repeat_indices.extend", "zip", "flags.extend", "len", "len", "math.ceil", "int", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ClassBalancedDataset._get_repeat_factors"], ["def", "__init__", "(", "self", ",", "dataset", ",", "oversample_thr", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "oversample_thr", "=", "oversample_thr", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "\n", "repeat_factors", "=", "self", ".", "_get_repeat_factors", "(", "dataset", ",", "oversample_thr", ")", "\n", "repeat_indices", "=", "[", "]", "\n", "for", "dataset_index", ",", "repeat_factor", "in", "enumerate", "(", "repeat_factors", ")", ":", "\n", "            ", "repeat_indices", ".", "extend", "(", "[", "dataset_index", "]", "*", "math", ".", "ceil", "(", "repeat_factor", ")", ")", "\n", "", "self", ".", "repeat_indices", "=", "repeat_indices", "\n", "\n", "flags", "=", "[", "]", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "for", "flag", ",", "repeat_factor", "in", "zip", "(", "self", ".", "dataset", ".", "flag", ",", "repeat_factors", ")", ":", "\n", "                ", "flags", ".", "extend", "(", "[", "flag", "]", "*", "int", "(", "math", ".", "ceil", "(", "repeat_factor", ")", ")", ")", "\n", "", "assert", "len", "(", "flags", ")", "==", "len", "(", "repeat_indices", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "asarray", "(", "flags", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ClassBalancedDataset._get_repeat_factors": [[149, 191], ["collections.defaultdict", "len", "range", "collections.defaultdict.items", "range", "set", "max", "set", "max", "repeat_factors.append", "dataset_wrappers.ClassBalancedDataset.dataset.get_cat_ids", "math.sqrt", "collections.defaultdict.items", "dataset_wrappers.ClassBalancedDataset.dataset.get_cat_ids"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "def", "_get_repeat_factors", "(", "self", ",", "dataset", ",", "repeat_thr", ")", ":", "\n", "        ", "\"\"\"Get repeat factor for each images in the dataset.\n\n        Args:\n            dataset (:obj:`CustomDataset`): The dataset\n            repeat_thr (float): The threshold of frequency. If an image\n                contains the categories whose frequency below the threshold,\n                it would be repeated.\n\n        Returns:\n            list[float]: The repeat factors for each images in the dataset.\n        \"\"\"", "\n", "\n", "# 1. For each category c, compute the fraction # of images", "\n", "#   that contain it: f(c)", "\n", "category_freq", "=", "defaultdict", "(", "int", ")", "\n", "num_images", "=", "len", "(", "dataset", ")", "\n", "for", "idx", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "cat_ids", "=", "set", "(", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", ")", ")", "\n", "for", "cat_id", "in", "cat_ids", ":", "\n", "                ", "category_freq", "[", "cat_id", "]", "+=", "1", "\n", "", "", "for", "k", ",", "v", "in", "category_freq", ".", "items", "(", ")", ":", "\n", "            ", "category_freq", "[", "k", "]", "=", "v", "/", "num_images", "\n", "\n", "# 2. For each category c, compute the category-level repeat factor:", "\n", "#    r(c) = max(1, sqrt(t/f(c)))", "\n", "", "category_repeat", "=", "{", "\n", "cat_id", ":", "max", "(", "1.0", ",", "math", ".", "sqrt", "(", "repeat_thr", "/", "cat_freq", ")", ")", "\n", "for", "cat_id", ",", "cat_freq", "in", "category_freq", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# 3. For each image I, compute the image-level repeat factor:", "\n", "#    r(I) = max_{c in I} r(c)", "\n", "repeat_factors", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "cat_ids", "=", "set", "(", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", ")", ")", "\n", "repeat_factor", "=", "max", "(", "\n", "{", "category_repeat", "[", "cat_id", "]", "\n", "for", "cat_id", "in", "cat_ids", "}", ")", "\n", "repeat_factors", ".", "append", "(", "repeat_factor", ")", "\n", "\n", "", "return", "repeat_factors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ClassBalancedDataset.__getitem__": [[192, 195], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "ori_index", "=", "self", ".", "repeat_indices", "[", "idx", "]", "\n", "return", "self", ".", "dataset", "[", "ori_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.ClassBalancedDataset.__len__": [[196, 199], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Length after repetition.\"\"\"", "\n", "return", "len", "(", "self", ".", "repeat_indices", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.lvis.LVISV05Dataset.load_annotations": [[267, 300], ["LVIS", "lvis.LVISV05Dataset.coco.get_cat_ids", "lvis.LVISV05Dataset.coco.get_img_ids", "info[].startswith", "data_infos.append", "ImportError", "enumerate", "lvis.LVISV05Dataset.coco.load_imgs"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from lvis style annotation file.\n\n        Args:\n            ann_file (str): Path of annotation file.\n\n        Returns:\n            list[dict]: Annotation info from LVIS api.\n        \"\"\"", "\n", "\n", "try", ":", "\n", "            ", "from", "lvis", "import", "LVIS", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please follow config/lvis/README.md to '", "\n", "'install open-mmlab forked lvis first.'", ")", "\n", "", "self", ".", "coco", "=", "LVIS", "(", "ann_file", ")", "\n", "assert", "not", "self", ".", "custom_classes", ",", "'LVIS custom classes is not supported'", "\n", "self", ".", "cat_ids", "=", "self", ".", "coco", ".", "get_cat_ids", "(", ")", "\n", "self", ".", "cat2label", "=", "{", "cat_id", ":", "i", "for", "i", ",", "cat_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", "}", "\n", "self", ".", "img_ids", "=", "self", ".", "coco", ".", "get_img_ids", "(", ")", "\n", "data_infos", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "img_ids", ":", "\n", "            ", "info", "=", "self", ".", "coco", ".", "load_imgs", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "if", "info", "[", "'file_name'", "]", ".", "startswith", "(", "'COCO'", ")", ":", "\n", "# Convert form the COCO 2014 file naming convention of", "\n", "# COCO_[train/val/test]2014_000000000000.jpg to the 2017", "\n", "# naming convention of 000000000000.jpg", "\n", "# (LVIS v1 will fix this naming issue)", "\n", "                ", "info", "[", "'filename'", "]", "=", "info", "[", "'file_name'", "]", "[", "-", "16", ":", "]", "\n", "", "else", ":", "\n", "                ", "info", "[", "'filename'", "]", "=", "info", "[", "'file_name'", "]", "\n", "", "data_infos", ".", "append", "(", "info", ")", "\n", "", "return", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.lvis.LVISV05Dataset.evaluate": [[301, 450], ["numpy.arange", "isinstance", "lvis.LVISV05Dataset.results2json", "len", "len", "len", "len", "isinstance", "tempfile.TemporaryDirectory", "os.join", "mmcv.utils.print_log", "LVISEval", "LVISEval.print_results", "tempfile.TemporaryDirectory.cleanup", "ImportError", "KeyError", "lvis.LVISV05Dataset.fast_eval_recall", "enumerate", "mmcv.utils.print_log", "KeyError", "LVISResults", "list", "LVISEval.evaluate", "LVISEval.accumulate", "LVISEval.summarize", "LVISEval.get_results().items", "LVISEval.evaluate", "LVISEval.accumulate", "LVISEval.summarize", "LVISEval.get_results", "LVISEval.get_results.items", "log_msg.append", "mmcv.utils.print_log", "k.startswith", "enumerate", "min", "list", "itertools.zip_longest", "terminaltables.AsciiTable", "mmcv.utils.print_log", "k.startswith", "LVISEval.get_results", "float", "len", "results_per_category.append", "itertools.chain", "float", "lvis.LVISV05Dataset.coco.load_cats", "numpy.mean", "float", "len", "float", "LVISEval.get_results.items", "k.startswith", "float", "float", "range", "float"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.results2json", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.fast_eval_recall", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'bbox'", ",", "\n", "logger", "=", "None", ",", "\n", "jsonfile_prefix", "=", "None", ",", "\n", "classwise", "=", "False", ",", "\n", "proposal_nums", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "\n", "iou_thrs", "=", "np", ".", "arange", "(", "0.5", ",", "0.96", ",", "0.05", ")", ")", ":", "\n", "        ", "\"\"\"Evaluation in LVIS protocol.\n\n        Args:\n            results (list[list | tuple]): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated. Options are\n                'bbox', 'segm', 'proposal', 'proposal_fast'.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n            jsonfile_prefix (str | None):\n            classwise (bool): Whether to evaluating the AP for each class.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thrs (Sequence[float]): IoU threshold used for evaluating\n                recalls. If set to a list, the average recall of all IoUs will\n                also be computed. Default: 0.5.\n\n        Returns:\n            dict[str, float]: LVIS style metrics.\n        \"\"\"", "\n", "\n", "try", ":", "\n", "            ", "from", "lvis", "import", "LVISResults", ",", "LVISEval", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please follow config/lvis/README.md to '", "\n", "'install open-mmlab forked lvis first.'", ")", "\n", "", "assert", "isinstance", "(", "results", ",", "list", ")", ",", "'results must be a list'", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "self", ")", ",", "(", "\n", "'The length of results is not equal to the dataset len: {} != {}'", ".", "\n", "format", "(", "len", "(", "results", ")", ",", "len", "(", "self", ")", ")", ")", "\n", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'bbox'", ",", "'segm'", ",", "'proposal'", ",", "'proposal_fast'", "]", "\n", "for", "metric", "in", "metrics", ":", "\n", "            ", "if", "metric", "not", "in", "allowed_metrics", ":", "\n", "                ", "raise", "KeyError", "(", "'metric {} is not supported'", ".", "format", "(", "metric", ")", ")", "\n", "\n", "", "", "if", "jsonfile_prefix", "is", "None", ":", "\n", "            ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "jsonfile_prefix", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'results'", ")", "\n", "", "else", ":", "\n", "            ", "tmp_dir", "=", "None", "\n", "", "result_files", "=", "self", ".", "results2json", "(", "results", ",", "jsonfile_prefix", ")", "\n", "\n", "eval_results", "=", "{", "}", "\n", "# get original api", "\n", "lvis_gt", "=", "self", ".", "coco", "\n", "for", "metric", "in", "metrics", ":", "\n", "            ", "msg", "=", "'Evaluating {}...'", ".", "format", "(", "metric", ")", "\n", "if", "logger", "is", "None", ":", "\n", "                ", "msg", "=", "'\\n'", "+", "msg", "\n", "", "print_log", "(", "msg", ",", "logger", "=", "logger", ")", "\n", "\n", "if", "metric", "==", "'proposal_fast'", ":", "\n", "                ", "ar", "=", "self", ".", "fast_eval_recall", "(", "\n", "results", ",", "proposal_nums", ",", "iou_thrs", ",", "logger", "=", "'silent'", ")", "\n", "log_msg", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                    ", "eval_results", "[", "'AR@{}'", ".", "format", "(", "num", ")", "]", "=", "ar", "[", "i", "]", "\n", "log_msg", ".", "append", "(", "'\\nAR@{}\\t{:.4f}'", ".", "format", "(", "num", ",", "ar", "[", "i", "]", ")", ")", "\n", "", "log_msg", "=", "''", ".", "join", "(", "log_msg", ")", "\n", "print_log", "(", "log_msg", ",", "logger", "=", "logger", ")", "\n", "continue", "\n", "\n", "", "if", "metric", "not", "in", "result_files", ":", "\n", "                ", "raise", "KeyError", "(", "'{} is not in results'", ".", "format", "(", "metric", ")", ")", "\n", "", "try", ":", "\n", "                ", "lvis_dt", "=", "LVISResults", "(", "lvis_gt", ",", "result_files", "[", "metric", "]", ")", "\n", "", "except", "IndexError", ":", "\n", "                ", "print_log", "(", "\n", "'The testing results of the whole dataset is empty.'", ",", "\n", "logger", "=", "logger", ",", "\n", "level", "=", "logging", ".", "ERROR", ")", "\n", "break", "\n", "\n", "", "iou_type", "=", "'bbox'", "if", "metric", "==", "'proposal'", "else", "metric", "\n", "lvis_eval", "=", "LVISEval", "(", "lvis_gt", ",", "lvis_dt", ",", "iou_type", ")", "\n", "lvis_eval", ".", "params", ".", "imgIds", "=", "self", ".", "img_ids", "\n", "if", "metric", "==", "'proposal'", ":", "\n", "                ", "lvis_eval", ".", "params", ".", "useCats", "=", "0", "\n", "lvis_eval", ".", "params", ".", "maxDets", "=", "list", "(", "proposal_nums", ")", "\n", "lvis_eval", ".", "evaluate", "(", ")", "\n", "lvis_eval", ".", "accumulate", "(", ")", "\n", "lvis_eval", ".", "summarize", "(", ")", "\n", "for", "k", ",", "v", "in", "lvis_eval", ".", "get_results", "(", ")", ".", "items", "(", ")", ":", "\n", "                    ", "if", "k", ".", "startswith", "(", "'AR'", ")", ":", "\n", "                        ", "val", "=", "float", "(", "'{:.3f}'", ".", "format", "(", "float", "(", "v", ")", ")", ")", "\n", "eval_results", "[", "k", "]", "=", "val", "\n", "", "", "", "else", ":", "\n", "                ", "lvis_eval", ".", "evaluate", "(", ")", "\n", "lvis_eval", ".", "accumulate", "(", ")", "\n", "lvis_eval", ".", "summarize", "(", ")", "\n", "lvis_results", "=", "lvis_eval", ".", "get_results", "(", ")", "\n", "if", "classwise", ":", "# Compute per-category AP", "\n", "# Compute per-category AP", "\n", "# from https://github.com/facebookresearch/detectron2/", "\n", "                    ", "precisions", "=", "lvis_eval", ".", "eval", "[", "'precision'", "]", "\n", "# precision: (iou, recall, cls, area range, max dets)", "\n", "assert", "len", "(", "self", ".", "cat_ids", ")", "==", "precisions", ".", "shape", "[", "2", "]", "\n", "\n", "results_per_category", "=", "[", "]", "\n", "for", "idx", ",", "catId", "in", "enumerate", "(", "self", ".", "cat_ids", ")", ":", "\n", "# area range index 0: all area ranges", "\n", "# max dets index -1: typically 100 per image", "\n", "                        ", "nm", "=", "self", ".", "coco", ".", "load_cats", "(", "catId", ")", "[", "0", "]", "\n", "precision", "=", "precisions", "[", ":", ",", ":", ",", "idx", ",", "0", ",", "-", "1", "]", "\n", "precision", "=", "precision", "[", "precision", ">", "-", "1", "]", "\n", "if", "precision", ".", "size", ":", "\n", "                            ", "ap", "=", "np", ".", "mean", "(", "precision", ")", "\n", "", "else", ":", "\n", "                            ", "ap", "=", "float", "(", "'nan'", ")", "\n", "", "results_per_category", ".", "append", "(", "\n", "(", "f'{nm[\"name\"]}'", ",", "f'{float(ap):0.3f}'", ")", ")", "\n", "\n", "", "num_columns", "=", "min", "(", "6", ",", "len", "(", "results_per_category", ")", "*", "2", ")", "\n", "results_flatten", "=", "list", "(", "\n", "itertools", ".", "chain", "(", "*", "results_per_category", ")", ")", "\n", "headers", "=", "[", "'category'", ",", "'AP'", "]", "*", "(", "num_columns", "//", "2", ")", "\n", "results_2d", "=", "itertools", ".", "zip_longest", "(", "*", "[", "\n", "results_flatten", "[", "i", ":", ":", "num_columns", "]", "\n", "for", "i", "in", "range", "(", "num_columns", ")", "\n", "]", ")", "\n", "table_data", "=", "[", "headers", "]", "\n", "table_data", "+=", "[", "result", "for", "result", "in", "results_2d", "]", "\n", "table", "=", "AsciiTable", "(", "table_data", ")", "\n", "print_log", "(", "'\\n'", "+", "table", ".", "table", ",", "logger", "=", "logger", ")", "\n", "\n", "", "for", "k", ",", "v", "in", "lvis_results", ".", "items", "(", ")", ":", "\n", "                    ", "if", "k", ".", "startswith", "(", "'AP'", ")", ":", "\n", "                        ", "key", "=", "'{}_{}'", ".", "format", "(", "metric", ",", "k", ")", "\n", "val", "=", "float", "(", "'{:.3f}'", ".", "format", "(", "float", "(", "v", ")", ")", ")", "\n", "eval_results", "[", "key", "]", "=", "val", "\n", "", "", "ap_summary", "=", "' '", ".", "join", "(", "[", "\n", "'{}:{:.3f}'", ".", "format", "(", "k", ",", "float", "(", "v", ")", ")", "\n", "for", "k", ",", "v", "in", "lvis_results", ".", "items", "(", ")", "if", "k", ".", "startswith", "(", "'AP'", ")", "\n", "]", ")", "\n", "eval_results", "[", "'{}_mAP_copypaste'", ".", "format", "(", "metric", ")", "]", "=", "ap_summary", "\n", "", "lvis_eval", ".", "print_results", "(", ")", "\n", "", "if", "tmp_dir", "is", "not", "None", ":", "\n", "            ", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", "return", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.lvis.LVISV1Dataset.load_annotations": [[699, 720], ["LVIS", "lvis.LVISV1Dataset.coco.get_cat_ids", "lvis.LVISV1Dataset.coco.get_img_ids", "info[].replace", "data_infos.append", "ImportError", "enumerate", "lvis.LVISV1Dataset.coco.load_imgs"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "lvis", "import", "LVIS", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please follow config/lvis/README.md to '", "\n", "'install open-mmlab forked lvis first.'", ")", "\n", "", "self", ".", "coco", "=", "LVIS", "(", "ann_file", ")", "\n", "assert", "not", "self", ".", "custom_classes", ",", "'LVIS custom classes is not supported'", "\n", "self", ".", "cat_ids", "=", "self", ".", "coco", ".", "get_cat_ids", "(", ")", "\n", "self", ".", "cat2label", "=", "{", "cat_id", ":", "i", "for", "i", ",", "cat_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", "}", "\n", "self", ".", "img_ids", "=", "self", ".", "coco", ".", "get_img_ids", "(", ")", "\n", "data_infos", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "img_ids", ":", "\n", "            ", "info", "=", "self", ".", "coco", ".", "load_imgs", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "# coco_url is used in LVISv1 instead of file_name", "\n", "# e.g. http://images.cocodataset.org/train2017/000000391895.jpg", "\n", "# train/val split in specified in url", "\n", "info", "[", "'filename'", "]", "=", "info", "[", "'coco_url'", "]", ".", "replace", "(", "\n", "'http://images.cocodataset.org/'", ",", "''", ")", "\n", "data_infos", ".", "append", "(", "info", ")", "\n", "", "return", "data_infos", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.voc.VOCDataset.__init__": [[14, 22], ["xml_style.XMLDataset.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "VOCDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "if", "'VOC2007'", "in", "self", ".", "img_prefix", ":", "\n", "            ", "self", ".", "year", "=", "2007", "\n", "", "elif", "'VOC2012'", "in", "self", ".", "img_prefix", ":", "\n", "            ", "self", ".", "year", "=", "2012", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot infer dataset year from img_prefix'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.voc.VOCDataset.evaluate": [[23, 88], ["isinstance", "KeyError", "voc.VOCDataset.get_ann_info", "isinstance", "mmdet.core.eval_map", "len", "range", "isinstance", "mmdet.core.eval_recalls", "enumerate", "len", "enumerate", "mmdet.core.eval_recalls.mean", "enumerate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_ann_info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.eval_map", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.eval_recalls"], ["", "", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'mAP'", ",", "\n", "logger", "=", "None", ",", "\n", "proposal_nums", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "scale_ranges", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate in VOC protocol.\n\n        Args:\n            results (list[list | tuple]): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated. Options are\n                'mAP', 'recall'.\n            logger (logging.Logger | str, optional): Logger used for printing\n                related information during evaluation. Default: None.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thr (float | list[float]): IoU threshold. It must be a float\n                when evaluating mAP, and can be a list when evaluating recall.\n                Default: 0.5.\n            scale_ranges (list[tuple], optional): Scale ranges for evaluating\n                mAP. If not specified, all bounding boxes would be included in\n                evaluation. Default: None.\n\n        Returns:\n            dict[str, float]: AP/recall metrics.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "metric", ",", "str", ")", ":", "\n", "            ", "assert", "len", "(", "metric", ")", "==", "1", "\n", "metric", "=", "metric", "[", "0", "]", "\n", "", "allowed_metrics", "=", "[", "'mAP'", ",", "'recall'", "]", "\n", "if", "metric", "not", "in", "allowed_metrics", ":", "\n", "            ", "raise", "KeyError", "(", "f'metric {metric} is not supported'", ")", "\n", "", "annotations", "=", "[", "self", ".", "get_ann_info", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", "]", "\n", "eval_results", "=", "{", "}", "\n", "if", "metric", "==", "'mAP'", ":", "\n", "            ", "assert", "isinstance", "(", "iou_thr", ",", "float", ")", "\n", "if", "self", ".", "year", "==", "2007", ":", "\n", "                ", "ds_name", "=", "'voc07'", "\n", "", "else", ":", "\n", "                ", "ds_name", "=", "self", ".", "CLASSES", "\n", "", "mean_ap", ",", "_", "=", "eval_map", "(", "\n", "results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "iou_thr", "=", "iou_thr", ",", "\n", "dataset", "=", "ds_name", ",", "\n", "logger", "=", "logger", ")", "\n", "eval_results", "[", "'mAP'", "]", "=", "mean_ap", "\n", "", "elif", "metric", "==", "'recall'", ":", "\n", "            ", "gt_bboxes", "=", "[", "ann", "[", "'bboxes'", "]", "for", "ann", "in", "annotations", "]", "\n", "if", "isinstance", "(", "iou_thr", ",", "float", ")", ":", "\n", "                ", "iou_thr", "=", "[", "iou_thr", "]", "\n", "", "recalls", "=", "eval_recalls", "(", "\n", "gt_bboxes", ",", "results", ",", "proposal_nums", ",", "iou_thr", ",", "logger", "=", "logger", ")", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                ", "for", "j", ",", "iou", "in", "enumerate", "(", "iou_thr", ")", ":", "\n", "                    ", "eval_results", "[", "f'recall@{num}@{iou}'", "]", "=", "recalls", "[", "i", ",", "j", "]", "\n", "", "", "if", "recalls", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "                ", "ar", "=", "recalls", ".", "mean", "(", "axis", "=", "1", ")", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "                    ", "eval_results", "[", "f'AR@{num}'", "]", "=", "ar", "[", "i", "]", "\n", "", "", "", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.GroupSampler.__init__": [[12, 22], ["hasattr", "dataset.flag.astype", "numpy.bincount", "enumerate", "int", "numpy.ceil"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "samples_per_gpu", "=", "1", ")", ":", "\n", "        ", "assert", "hasattr", "(", "dataset", ",", "'flag'", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "flag", "=", "dataset", ".", "flag", ".", "astype", "(", "np", ".", "int64", ")", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "np", ".", "ceil", "(", "\n", "size", "/", "self", ".", "samples_per_gpu", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.GroupSampler.__iter__": [[23, 46], ["enumerate", "numpy.concatenate", "numpy.concatenate", "indices.astype().tolist.astype().tolist.astype().tolist", "iter", "numpy.random.shuffle", "numpy.concatenate", "indices.astype().tolist.astype().tolist.append", "len", "numpy.where", "len", "len", "numpy.random.permutation", "indices.astype().tolist.astype().tolist.astype", "int", "numpy.random.choice", "range", "numpy.ceil", "len"], "methods", ["None"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "np", ".", "random", ".", "shuffle", "(", "indice", ")", "\n", "num_extra", "=", "int", "(", "np", ".", "ceil", "(", "size", "/", "self", ".", "samples_per_gpu", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "-", "len", "(", "indice", ")", "\n", "indice", "=", "np", ".", "concatenate", "(", "\n", "[", "indice", ",", "np", ".", "random", ".", "choice", "(", "indice", ",", "num_extra", ")", "]", ")", "\n", "indices", ".", "append", "(", "indice", ")", "\n", "", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "[", "\n", "indices", "[", "i", "*", "self", ".", "samples_per_gpu", ":", "(", "i", "+", "1", ")", "*", "self", ".", "samples_per_gpu", "]", "\n", "for", "i", "in", "np", ".", "random", ".", "permutation", "(", "\n", "range", "(", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ")", ")", "\n", "]", "\n", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "indices", ".", "astype", "(", "np", ".", "int64", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.GroupSampler.__len__": [[47, 49], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.DistributedGroupSampler.__init__": [[69, 95], ["mmcv.runner.get_dist_info", "hasattr", "numpy.bincount", "enumerate", "int", "math.ceil"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ")", ":", "\n", "        ", "_rank", ",", "_num_replicas", "=", "get_dist_info", "(", ")", "\n", "if", "num_replicas", "is", "None", ":", "\n", "            ", "num_replicas", "=", "_num_replicas", "\n", "", "if", "rank", "is", "None", ":", "\n", "            ", "rank", "=", "_rank", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "\n", "assert", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", "\n", "self", ".", "flag", "=", "self", ".", "dataset", ".", "flag", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "\n", "math", ".", "ceil", "(", "self", ".", "group_sizes", "[", "i", "]", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "\n", "self", ".", "num_replicas", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.DistributedGroupSampler.__iter__": [[96, 135], ["torch.Generator", "torch.Generator.manual_seed", "enumerate", "iter", "len", "len", "indice[].tolist", "indice[].tolist.copy", "range", "indice[].tolist.extend", "indices.extend", "list", "range", "numpy.where", "len", "len", "indice[].tolist.extend", "torch.randperm", "int", "len", "list", "math.ceil", "torch.randperm", "int"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", ">", "0", ":", "\n", "                ", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "indice", "=", "indice", "[", "list", "(", "torch", ".", "randperm", "(", "int", "(", "size", ")", ",", "\n", "generator", "=", "g", ")", ")", "]", ".", "tolist", "(", ")", "\n", "extra", "=", "int", "(", "\n", "math", ".", "ceil", "(", "\n", "size", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "self", ".", "num_replicas", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "*", "self", ".", "num_replicas", "-", "len", "(", "indice", ")", "\n", "# pad indice", "\n", "tmp", "=", "indice", ".", "copy", "(", ")", "\n", "for", "_", "in", "range", "(", "extra", "//", "size", ")", ":", "\n", "                    ", "indice", ".", "extend", "(", "tmp", ")", "\n", "", "indice", ".", "extend", "(", "tmp", "[", ":", "extra", "%", "size", "]", ")", "\n", "indices", ".", "extend", "(", "indice", ")", "\n", "\n", "", "", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "indices", "=", "[", "\n", "indices", "[", "j", "]", "for", "i", "in", "list", "(", "\n", "torch", ".", "randperm", "(", "\n", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ",", "generator", "=", "g", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "*", "self", ".", "samples_per_gpu", ",", "(", "i", "+", "1", ")", "*", "\n", "self", ".", "samples_per_gpu", ")", "\n", "]", "\n", "\n", "# subsample", "\n", "offset", "=", "self", ".", "num_samples", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "offset", ":", "offset", "+", "self", ".", "num_samples", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.DistributedGroupSampler.__len__": [[136, 138], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.group_sampler.DistributedGroupSampler.set_epoch": [[139, 141], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.distributed_sampler.DistributedSampler.__init__": [[7, 10], ["torch.utils.data.DistributedSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "num_replicas", "=", "None", ",", "rank", "=", "None", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dataset", ",", "num_replicas", "=", "num_replicas", ",", "rank", "=", "rank", ")", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.distributed_sampler.DistributedSampler.__iter__": [[11, 29], ["iter", "torch.Generator", "torch.Generator.manual_seed", "torch.randperm().tolist", "torch.arange().tolist", "len", "len", "torch.randperm", "torch.arange", "len", "len", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "if", "self", ".", "shuffle", ":", "\n", "            ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "indices", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "dataset", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "indices", "=", "torch", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", ".", "tolist", "(", ")", "\n", "\n", "# add extra samples to make it evenly divisible", "\n", "", "indices", "+=", "indices", "[", ":", "(", "self", ".", "total_size", "-", "len", "(", "indices", ")", ")", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "# subsample", "\n", "indices", "=", "indices", "[", "self", ".", "rank", ":", "self", ".", "total_size", ":", "self", ".", "num_replicas", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.base_sampler.BaseSampler.__init__": [[11, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "num", "=", "num", "\n", "self", ".", "pos_fraction", "=", "pos_fraction", "\n", "self", ".", "neg_pos_ub", "=", "neg_pos_ub", "\n", "self", ".", "add_gt_as_proposals", "=", "add_gt_as_proposals", "\n", "self", ".", "pos_sampler", "=", "self", "\n", "self", ".", "neg_sampler", "=", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.base_sampler.BaseSampler._sample_pos": [[24, 28], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.base_sampler.BaseSampler._sample_neg": [[29, 33], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.base_sampler.BaseSampler.sample": [[34, 102], ["torch.cat.new_zeros", "int", "base_sampler.BaseSampler.pos_sampler._sample_pos", "pos_inds.unique.unique.unique", "pos_inds.unique.unique.numel", "base_sampler.BaseSampler.neg_sampler._sample_neg", "neg_inds.unique.unique.unique", "sampling_result.SamplingResult.SamplingResult", "len", "torch.cat", "assign_result.add_gt_", "torch.cat.new_ones", "torch.cat", "max", "int", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_pos", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_neg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.add_gt_"], ["", "def", "sample", "(", "self", ",", "\n", "assign_result", ",", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive and negative bboxes.\n\n        This is a simple implementation of bbox sampling given candidates,\n        assigning results and ground truth bboxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Bbox assigning results.\n            bboxes (Tensor): Boxes to be sampled from.\n            gt_bboxes (Tensor): Ground truth bboxes.\n            gt_labels (Tensor, optional): Class labels of ground truth bboxes.\n\n        Returns:\n            :obj:`SamplingResult`: Sampling result.\n\n        Example:\n            >>> from mmdet.core.bbox import RandomSampler\n            >>> from mmdet.core.bbox import AssignResult\n            >>> from mmdet.core.bbox.demodata import ensure_rng, random_boxes\n            >>> rng = ensure_rng(None)\n            >>> assign_result = AssignResult.random(rng=rng)\n            >>> bboxes = random_boxes(assign_result.num_preds, rng=rng)\n            >>> gt_bboxes = random_boxes(assign_result.num_gts, rng=rng)\n            >>> gt_labels = None\n            >>> self = RandomSampler(num=32, pos_fraction=0.5, neg_pos_ub=-1,\n            >>>                      add_gt_as_proposals=False)\n            >>> self = self.sample(assign_result, bboxes, gt_bboxes, gt_labels)\n        \"\"\"", "\n", "if", "len", "(", "bboxes", ".", "shape", ")", "<", "2", ":", "\n", "            ", "bboxes", "=", "bboxes", "[", "None", ",", ":", "]", "\n", "\n", "", "bboxes", "=", "bboxes", "[", ":", ",", ":", "4", "]", "\n", "\n", "gt_flags", "=", "bboxes", ".", "new_zeros", "(", "(", "bboxes", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "if", "self", ".", "add_gt_as_proposals", "and", "len", "(", "gt_bboxes", ")", ">", "0", ":", "\n", "            ", "if", "gt_labels", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'gt_labels must be given when add_gt_as_proposals is True'", ")", "\n", "", "bboxes", "=", "torch", ".", "cat", "(", "[", "gt_bboxes", ",", "bboxes", "]", ",", "dim", "=", "0", ")", "\n", "assign_result", ".", "add_gt_", "(", "gt_labels", ")", "\n", "gt_ones", "=", "bboxes", ".", "new_ones", "(", "gt_bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "gt_flags", "=", "torch", ".", "cat", "(", "[", "gt_ones", ",", "gt_flags", "]", ")", "\n", "\n", "", "num_expected_pos", "=", "int", "(", "self", ".", "num", "*", "self", ".", "pos_fraction", ")", "\n", "pos_inds", "=", "self", ".", "pos_sampler", ".", "_sample_pos", "(", "\n", "assign_result", ",", "num_expected_pos", ",", "bboxes", "=", "bboxes", ",", "**", "kwargs", ")", "\n", "# We found that sampled indices have duplicated items occasionally.", "\n", "# (may be a bug of PyTorch)", "\n", "pos_inds", "=", "pos_inds", ".", "unique", "(", ")", "\n", "num_sampled_pos", "=", "pos_inds", ".", "numel", "(", ")", "\n", "num_expected_neg", "=", "self", ".", "num", "-", "num_sampled_pos", "\n", "if", "self", ".", "neg_pos_ub", ">=", "0", ":", "\n", "            ", "_pos", "=", "max", "(", "1", ",", "num_sampled_pos", ")", "\n", "neg_upper_bound", "=", "int", "(", "self", ".", "neg_pos_ub", "*", "_pos", ")", "\n", "if", "num_expected_neg", ">", "neg_upper_bound", ":", "\n", "                ", "num_expected_neg", "=", "neg_upper_bound", "\n", "", "", "neg_inds", "=", "self", ".", "neg_sampler", ".", "_sample_neg", "(", "\n", "assign_result", ",", "num_expected_neg", ",", "bboxes", "=", "bboxes", ",", "**", "kwargs", ")", "\n", "neg_inds", "=", "neg_inds", ".", "unique", "(", ")", "\n", "\n", "sampling_result", "=", "SamplingResult", "(", "pos_inds", ",", "neg_inds", ",", "bboxes", ",", "gt_bboxes", ",", "\n", "assign_result", ",", "gt_flags", ")", "\n", "return", "sampling_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.score_hlr_sampler.ScoreHLRSampler.__init__": [[32, 60], ["base_sampler.BaseSampler.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "k", "=", "0.5", ",", "\n", "bias", "=", "0", ",", "\n", "score_thr", "=", "0.05", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "neg_pos_ub", ",", "add_gt_as_proposals", ")", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "bias", "=", "bias", "\n", "self", ".", "score_thr", "=", "score_thr", "\n", "self", ".", "iou_thr", "=", "iou_thr", "\n", "self", ".", "context", "=", "context", "\n", "# context of cascade detectors is a list, so distinguish them here.", "\n", "if", "not", "hasattr", "(", "context", ",", "'num_stages'", ")", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", "=", "context", ".", "bbox_roi_extractor", "\n", "self", ".", "bbox_head", "=", "context", ".", "bbox_head", "\n", "self", ".", "with_shared_head", "=", "context", ".", "with_shared_head", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "                ", "self", ".", "shared_head", "=", "context", ".", "shared_head", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", "=", "context", ".", "bbox_roi_extractor", "[", "\n", "context", ".", "current_stage", "]", "\n", "self", ".", "bbox_head", "=", "context", ".", "bbox_head", "[", "context", ".", "current_stage", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.score_hlr_sampler.ScoreHLRSampler.random_choice": [[61, 87], ["isinstance", "len", "torch.tensor", "torch.randperm", "rand_inds.cpu().numpy.cpu().numpy.cpu().numpy", "torch.tensor.numel", "torch.cuda.current_device", "rand_inds.cpu().numpy.cpu().numpy.cpu"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "random_choice", "(", "gallery", ",", "num", ")", ":", "\n", "        ", "\"\"\"Randomly select some elements from the gallery.\n\n        If `gallery` is a Tensor, the returned indices will be a Tensor;\n        If `gallery` is a ndarray or list, the returned indices will be a\n        ndarray.\n\n        Args:\n            gallery (Tensor | ndarray | list): indices pool.\n            num (int): expected sample num.\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "assert", "len", "(", "gallery", ")", ">=", "num", "\n", "\n", "is_tensor", "=", "isinstance", "(", "gallery", ",", "torch", ".", "Tensor", ")", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "gallery", "=", "torch", ".", "tensor", "(", "\n", "gallery", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "", "perm", "=", "torch", ".", "randperm", "(", "gallery", ".", "numel", "(", ")", ",", "device", "=", "gallery", ".", "device", ")", "[", ":", "num", "]", "\n", "rand_inds", "=", "gallery", "[", "perm", "]", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "rand_inds", "=", "rand_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "rand_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.score_hlr_sampler.ScoreHLRSampler._sample_pos": [[88, 95], ["torch.nonzero().flatten", "torch.nonzero().flatten.numel", "score_hlr_sampler.ScoreHLRSampler.random_choice", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Randomly sample some positive samples.\"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ")", ".", "flatten", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "random_choice", "(", "pos_inds", ",", "num_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.score_hlr_sampler.ScoreHLRSampler._sample_neg": [[96, 211], ["torch.nonzero().flatten", "torch.nonzero().flatten.size", "torch.no_grad", "transforms.bbox2roi", "score_hlr_sampler.ScoreHLRSampler.context._bbox_forward", "[].max", "valid_inds.size", "invalid_inds.size", "min", "min", "torch.nonzero", "score_hlr_sampler.ScoreHLRSampler.bbox_head.loss", "valid_bbox_pred.view.view.view", "score_hlr_sampler.ScoreHLRSampler.bbox_head.bbox_coder.decode", "torch.cat", "mmcv.ops.nms_match", "cls_score.new_zeros", "cls_score.new_zeros.sort", "imp_rank_inds.sort", "cls_score.new_ones", "max", "imp_weights.min", "cls_score.new_ones", "valid_bbox_pred.view.view.size", "g_score.new_tensor", "torch.cat", "ori_selected_loss.sum", "new_loss.sum", "torch.randperm", "torch.nonzero().flatten.new_full", "cls_score.new_ones", "cls_score.softmax", "range", "torch.randperm", "imp_rank[].float", "range", "g_score.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "", "def", "_sample_neg", "(", "self", ",", "\n", "assign_result", ",", "\n", "num_expected", ",", "\n", "bboxes", ",", "\n", "feats", "=", "None", ",", "\n", "img_meta", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\n\n        Score-HLR sampler is done in the following steps:\n        1. Take the maximum positive score prediction of each negative samples\n            as s_i.\n        2. Filter out negative samples whose s_i <= score_thr, the left samples\n            are called valid samples.\n        3. Use NMS-Match to divide valid samples into different groups,\n            samples in the same group will greatly overlap with each other\n        4. Rank the matched samples in two-steps to get Score-HLR.\n            (1) In the same group, rank samples with their scores.\n            (2) In the same score rank across different groups,\n                rank samples with their scores again.\n        5. Linearly map Score-HLR to the final label weights.\n\n        Args:\n            assign_result (:obj:`AssignResult`): result of assigner.\n            num_expected (int): Expected number of samples.\n            bboxes (Tensor): bbox to be sampled.\n            feats (Tensor): Features come from FPN.\n            img_meta (dict): Meta information dictionary.\n        \"\"\"", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ")", ".", "flatten", "(", ")", "\n", "num_neg", "=", "neg_inds", ".", "size", "(", "0", ")", "\n", "if", "num_neg", "==", "0", ":", "\n", "            ", "return", "neg_inds", ",", "None", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "neg_bboxes", "=", "bboxes", "[", "neg_inds", "]", "\n", "neg_rois", "=", "bbox2roi", "(", "[", "neg_bboxes", "]", ")", "\n", "bbox_result", "=", "self", ".", "context", ".", "_bbox_forward", "(", "feats", ",", "neg_rois", ")", "\n", "cls_score", ",", "bbox_pred", "=", "bbox_result", "[", "'cls_score'", "]", ",", "bbox_result", "[", "\n", "'bbox_pred'", "]", "\n", "\n", "ori_loss", "=", "self", ".", "bbox_head", ".", "loss", "(", "\n", "cls_score", "=", "cls_score", ",", "\n", "bbox_pred", "=", "None", ",", "\n", "rois", "=", "None", ",", "\n", "labels", "=", "neg_inds", ".", "new_full", "(", "(", "num_neg", ",", ")", ",", "\n", "self", ".", "bbox_head", ".", "num_classes", ")", ",", "\n", "label_weights", "=", "cls_score", ".", "new_ones", "(", "num_neg", ")", ",", "\n", "bbox_targets", "=", "None", ",", "\n", "bbox_weights", "=", "None", ",", "\n", "reduction_override", "=", "'none'", ")", "[", "'loss_cls'", "]", "\n", "\n", "# filter out samples with the max score lower than score_thr", "\n", "max_score", ",", "argmax_score", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "[", ":", ",", ":", "-", "1", "]", ".", "max", "(", "-", "1", ")", "\n", "valid_inds", "=", "(", "max_score", ">", "self", ".", "score_thr", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "invalid_inds", "=", "(", "max_score", "<=", "self", ".", "score_thr", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "num_valid", "=", "valid_inds", ".", "size", "(", "0", ")", "\n", "num_invalid", "=", "invalid_inds", ".", "size", "(", "0", ")", "\n", "\n", "num_expected", "=", "min", "(", "num_neg", ",", "num_expected", ")", "\n", "num_hlr", "=", "min", "(", "num_valid", ",", "num_expected", ")", "\n", "num_rand", "=", "num_expected", "-", "num_hlr", "\n", "if", "num_valid", ">", "0", ":", "\n", "                ", "valid_rois", "=", "neg_rois", "[", "valid_inds", "]", "\n", "valid_max_score", "=", "max_score", "[", "valid_inds", "]", "\n", "valid_argmax_score", "=", "argmax_score", "[", "valid_inds", "]", "\n", "valid_bbox_pred", "=", "bbox_pred", "[", "valid_inds", "]", "\n", "\n", "# valid_bbox_pred shape: [num_valid, #num_classes, 4]", "\n", "valid_bbox_pred", "=", "valid_bbox_pred", ".", "view", "(", "\n", "valid_bbox_pred", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "selected_bbox_pred", "=", "valid_bbox_pred", "[", "range", "(", "num_valid", ")", ",", "\n", "valid_argmax_score", "]", "\n", "pred_bboxes", "=", "self", ".", "bbox_head", ".", "bbox_coder", ".", "decode", "(", "\n", "valid_rois", "[", ":", ",", "1", ":", "]", ",", "selected_bbox_pred", ")", "\n", "pred_bboxes_with_score", "=", "torch", ".", "cat", "(", "\n", "[", "pred_bboxes", ",", "valid_max_score", "[", ":", ",", "None", "]", "]", ",", "-", "1", ")", "\n", "group", "=", "nms_match", "(", "pred_bboxes_with_score", ",", "self", ".", "iou_thr", ")", "\n", "\n", "# imp: importance", "\n", "imp", "=", "cls_score", ".", "new_zeros", "(", "num_valid", ")", "\n", "for", "g", "in", "group", ":", "\n", "                    ", "g_score", "=", "valid_max_score", "[", "g", "]", "\n", "# g_score has already sorted", "\n", "rank", "=", "g_score", ".", "new_tensor", "(", "range", "(", "g_score", ".", "size", "(", "0", ")", ")", ")", "\n", "imp", "[", "g", "]", "=", "num_valid", "-", "rank", "+", "g_score", "\n", "", "_", ",", "imp_rank_inds", "=", "imp", ".", "sort", "(", "descending", "=", "True", ")", "\n", "_", ",", "imp_rank", "=", "imp_rank_inds", ".", "sort", "(", ")", "\n", "hlr_inds", "=", "imp_rank_inds", "[", ":", "num_expected", "]", "\n", "\n", "if", "num_rand", ">", "0", ":", "\n", "                    ", "rand_inds", "=", "torch", ".", "randperm", "(", "num_invalid", ")", "[", ":", "num_rand", "]", "\n", "select_inds", "=", "torch", ".", "cat", "(", "\n", "[", "valid_inds", "[", "hlr_inds", "]", ",", "invalid_inds", "[", "rand_inds", "]", "]", ")", "\n", "", "else", ":", "\n", "                    ", "select_inds", "=", "valid_inds", "[", "hlr_inds", "]", "\n", "\n", "", "neg_label_weights", "=", "cls_score", ".", "new_ones", "(", "num_expected", ")", "\n", "\n", "up_bound", "=", "max", "(", "num_expected", ",", "num_valid", ")", "\n", "imp_weights", "=", "(", "up_bound", "-", "\n", "imp_rank", "[", "hlr_inds", "]", ".", "float", "(", ")", ")", "/", "up_bound", "\n", "neg_label_weights", "[", ":", "num_hlr", "]", "=", "imp_weights", "\n", "neg_label_weights", "[", "num_hlr", ":", "]", "=", "imp_weights", ".", "min", "(", ")", "\n", "neg_label_weights", "=", "(", "self", ".", "bias", "+", "\n", "(", "1", "-", "self", ".", "bias", ")", "*", "neg_label_weights", ")", ".", "pow", "(", "\n", "self", ".", "k", ")", "\n", "ori_selected_loss", "=", "ori_loss", "[", "select_inds", "]", "\n", "new_loss", "=", "ori_selected_loss", "*", "neg_label_weights", "\n", "norm_ratio", "=", "ori_selected_loss", ".", "sum", "(", ")", "/", "new_loss", ".", "sum", "(", ")", "\n", "neg_label_weights", "*=", "norm_ratio", "\n", "", "else", ":", "\n", "                ", "neg_label_weights", "=", "cls_score", ".", "new_ones", "(", "num_expected", ")", "\n", "select_inds", "=", "torch", ".", "randperm", "(", "num_neg", ")", "[", ":", "num_expected", "]", "\n", "\n", "", "return", "neg_inds", "[", "select_inds", "]", ",", "neg_label_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.score_hlr_sampler.ScoreHLRSampler.sample": [[212, 262], ["torch.cat.new_zeros", "int", "score_hlr_sampler.ScoreHLRSampler.pos_sampler._sample_pos", "score_hlr_sampler.ScoreHLRSampler.numel", "score_hlr_sampler.ScoreHLRSampler.neg_sampler._sample_neg", "torch.cat", "assign_result.add_gt_", "torch.cat.new_ones", "torch.cat", "max", "int", "sampling_result.SamplingResult"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_pos", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_neg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.add_gt_"], ["", "", "def", "sample", "(", "self", ",", "\n", "assign_result", ",", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "None", ",", "\n", "img_meta", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive and negative bboxes.\n\n        This is a simple implementation of bbox sampling given candidates,\n        assigning results and ground truth bboxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Bbox assigning results.\n            bboxes (Tensor): Boxes to be sampled from.\n            gt_bboxes (Tensor): Ground truth bboxes.\n            gt_labels (Tensor, optional): Class labels of ground truth bboxes.\n\n        Returns:\n            tuple[:obj:`SamplingResult`, Tensor]: Sampling result and negetive\n                label weights.\n        \"\"\"", "\n", "bboxes", "=", "bboxes", "[", ":", ",", ":", "4", "]", "\n", "\n", "gt_flags", "=", "bboxes", ".", "new_zeros", "(", "(", "bboxes", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "if", "self", ".", "add_gt_as_proposals", ":", "\n", "            ", "bboxes", "=", "torch", ".", "cat", "(", "[", "gt_bboxes", ",", "bboxes", "]", ",", "dim", "=", "0", ")", "\n", "assign_result", ".", "add_gt_", "(", "gt_labels", ")", "\n", "gt_ones", "=", "bboxes", ".", "new_ones", "(", "gt_bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "gt_flags", "=", "torch", ".", "cat", "(", "[", "gt_ones", ",", "gt_flags", "]", ")", "\n", "\n", "", "num_expected_pos", "=", "int", "(", "self", ".", "num", "*", "self", ".", "pos_fraction", ")", "\n", "pos_inds", "=", "self", ".", "pos_sampler", ".", "_sample_pos", "(", "\n", "assign_result", ",", "num_expected_pos", ",", "bboxes", "=", "bboxes", ",", "**", "kwargs", ")", "\n", "num_sampled_pos", "=", "pos_inds", ".", "numel", "(", ")", "\n", "num_expected_neg", "=", "self", ".", "num", "-", "num_sampled_pos", "\n", "if", "self", ".", "neg_pos_ub", ">=", "0", ":", "\n", "            ", "_pos", "=", "max", "(", "1", ",", "num_sampled_pos", ")", "\n", "neg_upper_bound", "=", "int", "(", "self", ".", "neg_pos_ub", "*", "_pos", ")", "\n", "if", "num_expected_neg", ">", "neg_upper_bound", ":", "\n", "                ", "num_expected_neg", "=", "neg_upper_bound", "\n", "", "", "neg_inds", ",", "neg_label_weights", "=", "self", ".", "neg_sampler", ".", "_sample_neg", "(", "\n", "assign_result", ",", "\n", "num_expected_neg", ",", "\n", "bboxes", ",", "\n", "img_meta", "=", "img_meta", ",", "\n", "**", "kwargs", ")", "\n", "\n", "return", "SamplingResult", "(", "pos_inds", ",", "neg_inds", ",", "bboxes", ",", "gt_bboxes", ",", "\n", "assign_result", ",", "gt_flags", ")", ",", "neg_label_weights", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.__init__": [[20, 30], ["base_sampler.BaseSampler.__init__", "demodata.ensure_rng", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "from", "mmdet", ".", "core", ".", "bbox", "import", "demodata", "\n", "super", "(", "RandomSampler", ",", "self", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "neg_pos_ub", ",", "\n", "add_gt_as_proposals", ")", "\n", "self", ".", "rng", "=", "demodata", ".", "ensure_rng", "(", "kwargs", ".", "get", "(", "'rng'", ",", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice": [[31, 56], ["isinstance", "len", "torch.tensor", "torch.randperm", "rand_inds.cpu().numpy.cpu().numpy.cpu().numpy", "torch.tensor.numel", "torch.cuda.current_device", "rand_inds.cpu().numpy.cpu().numpy.cpu"], "methods", ["None"], ["", "def", "random_choice", "(", "self", ",", "gallery", ",", "num", ")", ":", "\n", "        ", "\"\"\"Random select some elements from the gallery.\n\n        If `gallery` is a Tensor, the returned indices will be a Tensor;\n        If `gallery` is a ndarray or list, the returned indices will be a\n        ndarray.\n\n        Args:\n            gallery (Tensor | ndarray | list): indices pool.\n            num (int): expected sample num.\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "assert", "len", "(", "gallery", ")", ">=", "num", "\n", "\n", "is_tensor", "=", "isinstance", "(", "gallery", ",", "torch", ".", "Tensor", ")", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "gallery", "=", "torch", ".", "tensor", "(", "\n", "gallery", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "", "perm", "=", "torch", ".", "randperm", "(", "gallery", ".", "numel", "(", ")", ",", "device", "=", "gallery", ".", "device", ")", "[", ":", "num", "]", "\n", "rand_inds", "=", "gallery", "[", "perm", "]", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "rand_inds", "=", "rand_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "rand_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler._sample_pos": [[57, 66], ["torch.nonzero", "pos_inds.squeeze.squeeze.numel", "pos_inds.squeeze.squeeze.squeeze", "pos_inds.squeeze.squeeze.numel", "random_sampler.RandomSampler.random_choice"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Randomly sample some positive samples.\"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "pos_inds", "=", "pos_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "random_choice", "(", "pos_inds", ",", "num_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler._sample_neg": [[67, 76], ["torch.nonzero", "neg_inds.squeeze.squeeze.numel", "neg_inds.squeeze.squeeze.squeeze", "len", "random_sampler.RandomSampler.random_choice"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice"], ["", "", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Randomly sample some negative samples.\"\"\"", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "neg_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "neg_inds", "=", "neg_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "len", "(", "neg_inds", ")", "<=", "num_expected", ":", "\n", "            ", "return", "neg_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "random_choice", "(", "neg_inds", ",", "num_expected", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler.__init__": [[15, 31], ["base_sampler.BaseSampler.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "OHEMSampler", ",", "self", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "neg_pos_ub", ",", "\n", "add_gt_as_proposals", ")", "\n", "if", "not", "hasattr", "(", "context", ",", "'num_stages'", ")", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", "=", "context", ".", "bbox_roi_extractor", "\n", "self", ".", "bbox_head", "=", "context", ".", "bbox_head", "\n", "", "else", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", "=", "context", ".", "bbox_roi_extractor", "[", "\n", "context", ".", "current_stage", "]", "\n", "self", ".", "bbox_head", "=", "context", ".", "bbox_head", "[", "context", ".", "current_stage", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler.hard_mining": [[32, 49], ["torch.no_grad", "transforms.bbox2roi", "ohem_sampler.OHEMSampler.bbox_roi_extractor", "ohem_sampler.OHEMSampler.bbox_head", "loss.topk", "ohem_sampler.OHEMSampler.bbox_head.loss", "cls_score.new_ones", "cls_score.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "", "def", "hard_mining", "(", "self", ",", "inds", ",", "num_expected", ",", "bboxes", ",", "labels", ",", "feats", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "rois", "=", "bbox2roi", "(", "[", "bboxes", "]", ")", "\n", "bbox_feats", "=", "self", ".", "bbox_roi_extractor", "(", "\n", "feats", "[", ":", "self", ".", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "rois", ")", "\n", "cls_score", ",", "_", "=", "self", ".", "bbox_head", "(", "bbox_feats", ")", "\n", "loss", "=", "self", ".", "bbox_head", ".", "loss", "(", "\n", "cls_score", "=", "cls_score", ",", "\n", "bbox_pred", "=", "None", ",", "\n", "rois", "=", "rois", ",", "\n", "labels", "=", "labels", ",", "\n", "label_weights", "=", "cls_score", ".", "new_ones", "(", "cls_score", ".", "size", "(", "0", ")", ")", ",", "\n", "bbox_targets", "=", "None", ",", "\n", "bbox_weights", "=", "None", ",", "\n", "reduction_override", "=", "'none'", ")", "[", "'loss_cls'", "]", "\n", "_", ",", "topk_loss_inds", "=", "loss", ".", "topk", "(", "num_expected", ")", "\n", "", "return", "inds", "[", "topk_loss_inds", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler._sample_pos": [[50, 77], ["torch.nonzero", "pos_inds.squeeze.squeeze.numel", "pos_inds.squeeze.squeeze.squeeze", "pos_inds.squeeze.squeeze.numel", "ohem_sampler.OHEMSampler.hard_mining"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler.hard_mining"], ["", "def", "_sample_pos", "(", "self", ",", "\n", "assign_result", ",", "\n", "num_expected", ",", "\n", "bboxes", "=", "None", ",", "\n", "feats", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive boxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Assigned results\n            num_expected (int): Number of expected positive samples\n            bboxes (torch.Tensor, optional): Boxes. Defaults to None.\n            feats (list[torch.Tensor], optional): Multi-level features.\n                Defaults to None.\n\n        Returns:\n            torch.Tensor: Indices  of positive samples\n        \"\"\"", "\n", "# Sample some hard positive samples", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "pos_inds", "=", "pos_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "hard_mining", "(", "pos_inds", ",", "num_expected", ",", "bboxes", "[", "pos_inds", "]", ",", "\n", "assign_result", ".", "labels", "[", "pos_inds", "]", ",", "feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler._sample_neg": [[78, 107], ["torch.nonzero", "neg_inds.squeeze.squeeze.numel", "neg_inds.squeeze.squeeze.squeeze", "len", "assign_result.labels.new_empty().fill_", "ohem_sampler.OHEMSampler.hard_mining", "assign_result.labels.new_empty", "neg_inds.squeeze.squeeze.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.ohem_sampler.OHEMSampler.hard_mining"], ["", "", "def", "_sample_neg", "(", "self", ",", "\n", "assign_result", ",", "\n", "num_expected", ",", "\n", "bboxes", "=", "None", ",", "\n", "feats", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative boxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Assigned results\n            num_expected (int): Number of expected negative samples\n            bboxes (torch.Tensor, optional): Boxes. Defaults to None.\n            feats (list[torch.Tensor], optional): Multi-level features.\n                Defaults to None.\n\n        Returns:\n            torch.Tensor: Indices  of negative samples\n        \"\"\"", "\n", "# Sample some hard negative samples", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "neg_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "neg_inds", "=", "neg_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "len", "(", "neg_inds", ")", "<=", "num_expected", ":", "\n", "            ", "return", "neg_inds", "\n", "", "else", ":", "\n", "            ", "neg_labels", "=", "assign_result", ".", "labels", ".", "new_empty", "(", "\n", "neg_inds", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "return", "self", ".", "hard_mining", "(", "neg_inds", ",", "num_expected", ",", "bboxes", "[", "neg_inds", "]", ",", "\n", "neg_labels", ",", "feats", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.instance_balanced_pos_sampler.InstanceBalancedPosSampler._sample_pos": [[13, 56], ["torch.nonzero", "pos_inds.squeeze.squeeze.numel", "pos_inds.squeeze.squeeze.squeeze", "pos_inds.squeeze.squeeze.numel", "assign_result.gt_inds[].unique", "len", "int", "torch.cat", "torch.nonzero", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.append", "len", "numpy.array", "torch.from_numpy().to().long", "torch.cat", "round", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.numel", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.squeeze", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "len", "list", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "i.item", "torch.from_numpy().to", "float", "set", "set", "pos_inds.squeeze.squeeze.cpu", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive boxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): The assigned results of boxes.\n            num_expected (int): The number of expected positive samples\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "pos_inds", "=", "pos_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "unique_gt_inds", "=", "assign_result", ".", "gt_inds", "[", "pos_inds", "]", ".", "unique", "(", ")", "\n", "num_gts", "=", "len", "(", "unique_gt_inds", ")", "\n", "num_per_gt", "=", "int", "(", "round", "(", "num_expected", "/", "float", "(", "num_gts", ")", ")", "+", "1", ")", "\n", "sampled_inds", "=", "[", "]", "\n", "for", "i", "in", "unique_gt_inds", ":", "\n", "                ", "inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", "==", "i", ".", "item", "(", ")", ",", "as_tuple", "=", "False", ")", "\n", "if", "inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "                    ", "inds", "=", "inds", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "", "if", "len", "(", "inds", ")", ">", "num_per_gt", ":", "\n", "                    ", "inds", "=", "self", ".", "random_choice", "(", "inds", ",", "num_per_gt", ")", "\n", "", "sampled_inds", ".", "append", "(", "inds", ")", "\n", "", "sampled_inds", "=", "torch", ".", "cat", "(", "sampled_inds", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "                ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "\n", "list", "(", "set", "(", "pos_inds", ".", "cpu", "(", ")", ")", "-", "set", "(", "sampled_inds", ".", "cpu", "(", ")", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                    ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "extra_inds", "=", "torch", ".", "from_numpy", "(", "extra_inds", ")", ".", "to", "(", "\n", "assign_result", ".", "gt_inds", ".", "device", ")", ".", "long", "(", ")", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_inds", ",", "extra_inds", "]", ")", "\n", "", "elif", "len", "(", "sampled_inds", ")", ">", "num_expected", ":", "\n", "                ", "sampled_inds", "=", "self", ".", "random_choice", "(", "sampled_inds", ",", "num_expected", ")", "\n", "", "return", "sampled_inds", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.__init__": [[29, 45], ["random_sampler.RandomSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "floor_thr", "=", "-", "1", ",", "\n", "floor_fraction", "=", "0", ",", "\n", "num_bins", "=", "3", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "IoUBalancedNegSampler", ",", "self", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "\n", "**", "kwargs", ")", "\n", "assert", "floor_thr", ">=", "0", "or", "floor_thr", "==", "-", "1", "\n", "assert", "0", "<=", "floor_fraction", "<=", "1", "\n", "assert", "num_bins", ">=", "1", "\n", "\n", "self", ".", "floor_thr", "=", "floor_thr", "\n", "self", ".", "floor_fraction", "=", "floor_fraction", "\n", "self", ".", "num_bins", "=", "num_bins", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval": [[46, 87], ["max_overlaps.max", "int", "range", "numpy.concatenate", "set", "list", "numpy.concatenate.append", "len", "numpy.array", "numpy.concatenate", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.array", "len", "list", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.where", "numpy.logical_and", "set"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "sample_via_interval", "(", "self", ",", "max_overlaps", ",", "full_set", ",", "num_expected", ")", ":", "\n", "        ", "\"\"\"Sample according to the iou interval.\n\n        Args:\n            max_overlaps (torch.Tensor): IoU between bounding boxes and ground\n                truth boxes.\n            full_set (set(int)): A full set of indices of boxes\u3002\n            num_expected (int): Number of expected samples\u3002\n\n        Returns:\n            np.ndarray: Indices  of samples\n        \"\"\"", "\n", "max_iou", "=", "max_overlaps", ".", "max", "(", ")", "\n", "iou_interval", "=", "(", "max_iou", "-", "self", ".", "floor_thr", ")", "/", "self", ".", "num_bins", "\n", "per_num_expected", "=", "int", "(", "num_expected", "/", "self", ".", "num_bins", ")", "\n", "\n", "sampled_inds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_bins", ")", ":", "\n", "            ", "start_iou", "=", "self", ".", "floor_thr", "+", "i", "*", "iou_interval", "\n", "end_iou", "=", "self", ".", "floor_thr", "+", "(", "i", "+", "1", ")", "*", "iou_interval", "\n", "tmp_set", "=", "set", "(", "\n", "np", ".", "where", "(", "\n", "np", ".", "logical_and", "(", "max_overlaps", ">=", "start_iou", ",", "\n", "max_overlaps", "<", "end_iou", ")", ")", "[", "0", "]", ")", "\n", "tmp_inds", "=", "list", "(", "tmp_set", "&", "full_set", ")", "\n", "if", "len", "(", "tmp_inds", ")", ">", "per_num_expected", ":", "\n", "                ", "tmp_sampled_set", "=", "self", ".", "random_choice", "(", "tmp_inds", ",", "\n", "per_num_expected", ")", "\n", "", "else", ":", "\n", "                ", "tmp_sampled_set", "=", "np", ".", "array", "(", "tmp_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "sampled_inds", ".", "append", "(", "tmp_sampled_set", ")", "\n", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "sampled_inds", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "            ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "list", "(", "full_set", "-", "set", "(", "sampled_inds", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "[", "sampled_inds", ",", "extra_inds", "]", ")", "\n", "\n", "", "return", "sampled_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler._sample_neg": [[88, 158], ["torch.nonzero", "neg_inds.squeeze.squeeze.numel", "neg_inds.squeeze.squeeze.squeeze", "len", "assign_result.max_overlaps.cpu().numpy", "set", "list", "list", "int", "numpy.concatenate", "torch.from_numpy().long().to", "neg_inds.squeeze.squeeze.cpu().numpy", "set", "set", "len", "numpy.array", "len", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.array", "len", "numpy.array", "numpy.concatenate", "assign_result.max_overlaps.cpu", "set", "set", "set", "set", "iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "len", "list", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "torch.from_numpy().long", "neg_inds.squeeze.squeeze.cpu", "numpy.where", "numpy.where", "set", "numpy.logical_and", "numpy.where", "numpy.where", "numpy.where", "set", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative boxes.\n\n        Args:\n            assign_result (:obj:`AssignResult`): The assigned results of boxes.\n            num_expected (int): The number of expected negative samples\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "neg_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "neg_inds", "=", "neg_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "len", "(", "neg_inds", ")", "<=", "num_expected", ":", "\n", "            ", "return", "neg_inds", "\n", "", "else", ":", "\n", "            ", "max_overlaps", "=", "assign_result", ".", "max_overlaps", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# balance sampling for negative samples", "\n", "neg_set", "=", "set", "(", "neg_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "if", "self", ".", "floor_thr", ">", "0", ":", "\n", "                ", "floor_set", "=", "set", "(", "\n", "np", ".", "where", "(", "\n", "np", ".", "logical_and", "(", "max_overlaps", ">=", "0", ",", "\n", "max_overlaps", "<", "self", ".", "floor_thr", ")", ")", "[", "0", "]", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">=", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "", "elif", "self", ".", "floor_thr", "==", "0", ":", "\n", "                ", "floor_set", "=", "set", "(", "np", ".", "where", "(", "max_overlaps", "==", "0", ")", "[", "0", "]", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "floor_set", "=", "set", "(", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "# for sampling interval calculation", "\n", "self", ".", "floor_thr", "=", "0", "\n", "\n", "", "floor_neg_inds", "=", "list", "(", "floor_set", "&", "neg_set", ")", "\n", "iou_sampling_neg_inds", "=", "list", "(", "iou_sampling_set", "&", "neg_set", ")", "\n", "num_expected_iou_sampling", "=", "int", "(", "num_expected", "*", "\n", "(", "1", "-", "self", ".", "floor_fraction", ")", ")", "\n", "if", "len", "(", "iou_sampling_neg_inds", ")", ">", "num_expected_iou_sampling", ":", "\n", "                ", "if", "self", ".", "num_bins", ">=", "2", ":", "\n", "                    ", "iou_sampled_inds", "=", "self", ".", "sample_via_interval", "(", "\n", "max_overlaps", ",", "set", "(", "iou_sampling_neg_inds", ")", ",", "\n", "num_expected_iou_sampling", ")", "\n", "", "else", ":", "\n", "                    ", "iou_sampled_inds", "=", "self", ".", "random_choice", "(", "\n", "iou_sampling_neg_inds", ",", "num_expected_iou_sampling", ")", "\n", "", "", "else", ":", "\n", "                ", "iou_sampled_inds", "=", "np", ".", "array", "(", "\n", "iou_sampling_neg_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "num_expected_floor", "=", "num_expected", "-", "len", "(", "iou_sampled_inds", ")", "\n", "if", "len", "(", "floor_neg_inds", ")", ">", "num_expected_floor", ":", "\n", "                ", "sampled_floor_inds", "=", "self", ".", "random_choice", "(", "\n", "floor_neg_inds", ",", "num_expected_floor", ")", "\n", "", "else", ":", "\n", "                ", "sampled_floor_inds", "=", "np", ".", "array", "(", "floor_neg_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "\n", "(", "sampled_floor_inds", ",", "iou_sampled_inds", ")", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "                ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "list", "(", "neg_set", "-", "set", "(", "sampled_inds", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                    ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "(", "sampled_inds", ",", "extra_inds", ")", ")", "\n", "", "sampled_inds", "=", "torch", ".", "from_numpy", "(", "sampled_inds", ")", ".", "long", "(", ")", ".", "to", "(", "\n", "assign_result", ".", "gt_inds", ".", "device", ")", "\n", "return", "sampled_inds", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.combined_sampler.CombinedSampler.__init__": [[9, 13], ["base_sampler.BaseSampler.__init__", "builder.build_sampler", "builder.build_sampler"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "pos_sampler", ",", "neg_sampler", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "CombinedSampler", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "pos_sampler", "=", "build_sampler", "(", "pos_sampler", ",", "**", "kwargs", ")", "\n", "self", ".", "neg_sampler", "=", "build_sampler", "(", "neg_sampler", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.combined_sampler.CombinedSampler._sample_pos": [[14, 17], ["None"], "methods", ["None"], ["", "def", "_sample_pos", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.combined_sampler.CombinedSampler._sample_neg": [[18, 21], ["None"], "methods", ["None"], ["", "def", "_sample_neg", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.__init__": [[25, 50], ["gt_bboxes.view.view.numel", "torch.empty_like().view", "sampling_result.SamplingResult.pos_assigned_gt_inds.numel", "len", "gt_bboxes.view.view.view", "torch.empty_like"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pos_inds", ",", "neg_inds", ",", "bboxes", ",", "gt_bboxes", ",", "assign_result", ",", "\n", "gt_flags", ")", ":", "\n", "        ", "self", ".", "pos_inds", "=", "pos_inds", "\n", "self", ".", "neg_inds", "=", "neg_inds", "\n", "self", ".", "pos_bboxes", "=", "bboxes", "[", "pos_inds", "]", "\n", "self", ".", "neg_bboxes", "=", "bboxes", "[", "neg_inds", "]", "\n", "self", ".", "pos_is_gt", "=", "gt_flags", "[", "pos_inds", "]", "\n", "\n", "self", ".", "num_gts", "=", "gt_bboxes", ".", "shape", "[", "0", "]", "\n", "self", ".", "pos_assigned_gt_inds", "=", "assign_result", ".", "gt_inds", "[", "pos_inds", "]", "-", "1", "\n", "\n", "if", "gt_bboxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "# hack for index error case", "\n", "            ", "assert", "self", ".", "pos_assigned_gt_inds", ".", "numel", "(", ")", "==", "0", "\n", "self", ".", "pos_gt_bboxes", "=", "torch", ".", "empty_like", "(", "gt_bboxes", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "gt_bboxes", ".", "shape", ")", "<", "2", ":", "\n", "                ", "gt_bboxes", "=", "gt_bboxes", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "\n", "", "self", ".", "pos_gt_bboxes", "=", "gt_bboxes", "[", "self", ".", "pos_assigned_gt_inds", ",", ":", "]", "\n", "\n", "", "if", "assign_result", ".", "labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "pos_gt_labels", "=", "assign_result", ".", "labels", "[", "pos_inds", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "pos_gt_labels", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.bboxes": [[51, 55], ["torch.cat"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "bboxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: concatenated positive and negative boxes\"\"\"", "\n", "return", "torch", ".", "cat", "(", "[", "self", ".", "pos_bboxes", ",", "self", ".", "neg_bboxes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to": [[56, 70], ["_dict.items", "isinstance", "value.to"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "\"\"\"Change the device of the data inplace.\n\n        Example:\n            >>> self = SamplingResult.random()\n            >>> print(f'self = {self.to(None)}')\n            >>> # xdoctest: +REQUIRES(--gpu)\n            >>> print(f'self = {self.to(0)}')\n        \"\"\"", "\n", "_dict", "=", "self", ".", "__dict__", "\n", "for", "key", ",", "value", "in", "_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "_dict", "[", "key", "]", "=", "value", ".", "to", "(", "device", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.__nice__": [[71, 78], ["sampling_result.SamplingResult.info.copy", "sampling_result.SamplingResult.pop", "sampling_result.SamplingResult.pop", "sorted", "sampling_result.SamplingResult.items"], "methods", ["None"], ["", "def", "__nice__", "(", "self", ")", ":", "\n", "        ", "data", "=", "self", ".", "info", ".", "copy", "(", ")", "\n", "data", "[", "'pos_bboxes'", "]", "=", "data", ".", "pop", "(", "'pos_bboxes'", ")", ".", "shape", "\n", "data", "[", "'neg_bboxes'", "]", "=", "data", ".", "pop", "(", "'neg_bboxes'", ")", ".", "shape", "\n", "parts", "=", "[", "f\"'{k}': {v!r}\"", "for", "k", ",", "v", "in", "sorted", "(", "data", ".", "items", "(", ")", ")", "]", "\n", "body", "=", "'    '", "+", "',\\n    '", ".", "join", "(", "parts", ")", "\n", "return", "'{\\n'", "+", "body", "+", "'\\n}'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.info": [[79, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns a dictionary of info about the object.\"\"\"", "\n", "return", "{", "\n", "'pos_inds'", ":", "self", ".", "pos_inds", ",", "\n", "'neg_inds'", ":", "self", ".", "neg_inds", ",", "\n", "'pos_bboxes'", ":", "self", ".", "pos_bboxes", ",", "\n", "'neg_bboxes'", ":", "self", ".", "neg_bboxes", ",", "\n", "'pos_is_gt'", ":", "self", ".", "pos_is_gt", ",", "\n", "'num_gts'", ":", "self", ".", "num_gts", ",", "\n", "'pos_assigned_gt_inds'", ":", "self", ".", "pos_assigned_gt_inds", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.random": [[92, 153], ["demodata.ensure_rng", "AssignResult.random", "demodata.random_boxes", "demodata.random_boxes", "RandomSampler", "RandomSampler.sample", "demodata.ensure_rng.rand", "gt_bboxes.squeeze.squeeze.squeeze", "bboxes.squeeze.squeeze.squeeze"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.random_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.random_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "@", "classmethod", "\n", "def", "random", "(", "cls", ",", "rng", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            rng (None | int | numpy.random.RandomState): seed or state.\n            kwargs (keyword arguments):\n                - num_preds: number of predicted boxes\n                - num_gts: number of true boxes\n                - p_ignore (float): probability of a predicted box assinged to \\\n                    an ignored truth.\n                - p_assigned (float): probability of a predicted box not being \\\n                    assigned.\n                - p_use_label (float | bool): with labels or not.\n\n        Returns:\n            :obj:`SamplingResult`: Randomly generated sampling result.\n\n        Example:\n            >>> from mmdet.core.bbox.samplers.sampling_result import *  # NOQA\n            >>> self = SamplingResult.random()\n            >>> print(self.__dict__)\n        \"\"\"", "\n", "from", "mmdet", ".", "core", ".", "bbox", ".", "samplers", ".", "random_sampler", "import", "RandomSampler", "\n", "from", "mmdet", ".", "core", ".", "bbox", ".", "assigners", ".", "assign_result", "import", "AssignResult", "\n", "from", "mmdet", ".", "core", ".", "bbox", "import", "demodata", "\n", "rng", "=", "demodata", ".", "ensure_rng", "(", "rng", ")", "\n", "\n", "# make probabalistic?", "\n", "num", "=", "32", "\n", "pos_fraction", "=", "0.5", "\n", "neg_pos_ub", "=", "-", "1", "\n", "\n", "assign_result", "=", "AssignResult", ".", "random", "(", "rng", "=", "rng", ",", "**", "kwargs", ")", "\n", "\n", "# Note we could just compute an assignment", "\n", "bboxes", "=", "demodata", ".", "random_boxes", "(", "assign_result", ".", "num_preds", ",", "rng", "=", "rng", ")", "\n", "gt_bboxes", "=", "demodata", ".", "random_boxes", "(", "assign_result", ".", "num_gts", ",", "rng", "=", "rng", ")", "\n", "\n", "if", "rng", ".", "rand", "(", ")", ">", "0.2", ":", "\n", "# sometimes algorithms squeeze their data, be robust to that", "\n", "            ", "gt_bboxes", "=", "gt_bboxes", ".", "squeeze", "(", ")", "\n", "bboxes", "=", "bboxes", ".", "squeeze", "(", ")", "\n", "\n", "", "if", "assign_result", ".", "labels", "is", "None", ":", "\n", "            ", "gt_labels", "=", "None", "\n", "", "else", ":", "\n", "            ", "gt_labels", "=", "None", "# todo", "\n", "\n", "", "if", "gt_labels", "is", "None", ":", "\n", "            ", "add_gt_as_proposals", "=", "False", "\n", "", "else", ":", "\n", "            ", "add_gt_as_proposals", "=", "True", "# make probabalistic?", "\n", "\n", "", "sampler", "=", "RandomSampler", "(", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "neg_pos_ub", ",", "\n", "add_gt_as_proposals", "=", "add_gt_as_proposals", ",", "\n", "rng", "=", "rng", ")", "\n", "self", "=", "sampler", ".", "sample", "(", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.__init__": [[12, 14], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "add_gt_as_proposals", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "add_gt_as_proposals", "=", "add_gt_as_proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_pos": [[15, 18], ["None"], "methods", ["None"], ["", "def", "_sample_pos", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler._sample_neg": [[19, 22], ["None"], "methods", ["None"], ["", "def", "_sample_neg", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample": [[23, 53], ["torch.cat.new_zeros", "torch.nonzero().squeeze().unique", "torch.nonzero().squeeze().unique", "sampling_result.SamplingResult.SamplingResult", "torch.cat", "assign_result.add_gt_", "torch.cat.new_ones", "torch.cat", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.add_gt_"], ["", "def", "sample", "(", "self", ",", "\n", "assign_result", ",", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Directly returns the positive and negative indices  of samples.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Assigned results\n            bboxes (torch.Tensor): Bounding boxes\n            gt_bboxes (torch.Tensor): Ground truth boxes\n\n        Returns:\n            :obj:`SamplingResult`: sampler results\n        \"\"\"", "\n", "bboxes", "=", "bboxes", "[", ":", ",", ":", "4", "]", "\n", "gt_flags", "=", "bboxes", ".", "new_zeros", "(", "bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "if", "self", ".", "add_gt_as_proposals", ":", "\n", "            ", "bboxes", "=", "torch", ".", "cat", "(", "[", "gt_bboxes", ",", "bboxes", "]", ",", "dim", "=", "0", ")", "\n", "assign_result", ".", "add_gt_", "(", "gt_labels", ")", "\n", "gt_ones", "=", "bboxes", ".", "new_ones", "(", "gt_bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "gt_flags", "=", "torch", ".", "cat", "(", "[", "gt_ones", ",", "gt_flags", "]", ")", "\n", "", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "-", "1", ")", ".", "unique", "(", ")", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "-", "1", ")", ".", "unique", "(", ")", "\n", "sampling_result", "=", "SamplingResult", "(", "pos_inds", ",", "neg_inds", ",", "bboxes", ",", "gt_bboxes", ",", "\n", "assign_result", ",", "gt_flags", ")", "\n", "return", "sampling_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.__init__": [[57, 83], ["isinstance", "mmcv.is_list_of", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "img_scale", "=", "None", ",", "\n", "multiscale_mode", "=", "'range'", ",", "\n", "ratio_range", "=", "None", ",", "\n", "keep_ratio", "=", "True", ",", "\n", "backend", "=", "'cv2'", ")", ":", "\n", "        ", "if", "img_scale", "is", "None", ":", "\n", "            ", "self", ".", "img_scale", "=", "None", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "img_scale", ",", "list", ")", ":", "\n", "                ", "self", ".", "img_scale", "=", "img_scale", "\n", "", "else", ":", "\n", "                ", "self", ".", "img_scale", "=", "[", "img_scale", "]", "\n", "", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "img_scale", ",", "tuple", ")", "\n", "\n", "", "if", "ratio_range", "is", "not", "None", ":", "\n", "# mode 1: given a scale and a range of image ratio", "\n", "            ", "assert", "len", "(", "self", ".", "img_scale", ")", "==", "1", "\n", "", "else", ":", "\n", "# mode 2: given multiple scales or a range of scales", "\n", "            ", "assert", "multiscale_mode", "in", "[", "'value'", ",", "'range'", "]", "\n", "\n", "", "self", ".", "backend", "=", "backend", "\n", "self", ".", "multiscale_mode", "=", "multiscale_mode", "\n", "self", ".", "ratio_range", "=", "ratio_range", "\n", "self", ".", "keep_ratio", "=", "keep_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_select": [[84, 101], ["mmcv.is_list_of", "numpy.random.randint", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "random_select", "(", "img_scales", ")", ":", "\n", "        ", "\"\"\"Randomly select an img_scale from given candidates.\n\n        Args:\n            img_scales (list[tuple]): Images scales for selection.\n\n        Returns:\n            (tuple, int): Returns a tuple ``(img_scale, scale_dix)``, \\\n                where ``img_scale`` is the selected image scale and \\\n                ``scale_idx`` is the selected index in the given candidates.\n        \"\"\"", "\n", "\n", "assert", "mmcv", ".", "is_list_of", "(", "img_scales", ",", "tuple", ")", "\n", "scale_idx", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "img_scales", ")", ")", "\n", "img_scale", "=", "img_scales", "[", "scale_idx", "]", "\n", "return", "img_scale", ",", "scale_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_sample": [[102, 128], ["numpy.random.randint", "numpy.random.randint", "mmcv.is_list_of", "max", "min", "min", "min", "len", "max", "max"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "random_sample", "(", "img_scales", ")", ":", "\n", "        ", "\"\"\"Randomly sample an img_scale when ``multiscale_mode=='range'``.\n\n        Args:\n            img_scales (list[tuple]): Images scale range for sampling.\n                There must be two tuples in img_scales, which specify the lower\n                and uper bound of image scales.\n\n        Returns:\n            (tuple, None): Returns a tuple ``(img_scale, None)``, where \\\n                ``img_scale`` is sampled scale and None is just a placeholder \\\n                to be consistent with :func:`random_select`.\n        \"\"\"", "\n", "\n", "assert", "mmcv", ".", "is_list_of", "(", "img_scales", ",", "tuple", ")", "and", "len", "(", "img_scales", ")", "==", "2", "\n", "img_scale_long", "=", "[", "max", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "img_scale_short", "=", "[", "min", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "long_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_long", ")", ",", "\n", "max", "(", "img_scale_long", ")", "+", "1", ")", "\n", "short_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_short", ")", ",", "\n", "max", "(", "img_scale_short", ")", "+", "1", ")", "\n", "img_scale", "=", "(", "long_edge", ",", "short_edge", ")", "\n", "return", "img_scale", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_sample_ratio": [[129, 155], ["isinstance", "int", "int", "len", "numpy.random.random_sample"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_sample"], ["", "@", "staticmethod", "\n", "def", "random_sample_ratio", "(", "img_scale", ",", "ratio_range", ")", ":", "\n", "        ", "\"\"\"Randomly sample an img_scale when ``ratio_range`` is specified.\n\n        A ratio will be randomly sampled from the range specified by\n        ``ratio_range``. Then it would be multiplied with ``img_scale`` to\n        generate sampled scale.\n\n        Args:\n            img_scale (tuple): Images scale base to multiply with ratio.\n            ratio_range (tuple[float]): The minimum and maximum ratio to scale\n                the ``img_scale``.\n\n        Returns:\n            (tuple, None): Returns a tuple ``(scale, None)``, where \\\n                ``scale`` is sampled ratio multiplied with ``img_scale`` and \\\n                None is just a placeholder to be consistent with \\\n                :func:`random_select`.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_scale", ",", "tuple", ")", "and", "len", "(", "img_scale", ")", "==", "2", "\n", "min_ratio", ",", "max_ratio", "=", "ratio_range", "\n", "assert", "min_ratio", "<=", "max_ratio", "\n", "ratio", "=", "np", ".", "random", ".", "random_sample", "(", ")", "*", "(", "max_ratio", "-", "min_ratio", ")", "+", "min_ratio", "\n", "scale", "=", "int", "(", "img_scale", "[", "0", "]", "*", "ratio", ")", ",", "int", "(", "img_scale", "[", "1", "]", "*", "ratio", ")", "\n", "return", "scale", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._random_scale": [[156, 188], ["transforms.Resize.random_sample_ratio", "len", "transforms.Resize.random_sample", "transforms.Resize.random_select"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_sample_ratio", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.random_select"], ["", "def", "_random_scale", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Randomly sample an img_scale according to ``ratio_range`` and\n        ``multiscale_mode``.\n\n        If ``ratio_range`` is specified, a ratio will be sampled and be\n        multiplied with ``img_scale``.\n        If multiple scales are specified by ``img_scale``, a scale will be\n        sampled according to ``multiscale_mode``.\n        Otherwise, single scale will be used.\n\n        Args:\n            results (dict): Result dict from :obj:`dataset`.\n\n        Returns:\n            dict: Two new keys 'scale` and 'scale_idx` are added into \\\n                ``results``, which would be used by subsequent pipelines.\n        \"\"\"", "\n", "\n", "if", "self", ".", "ratio_range", "is", "not", "None", ":", "\n", "            ", "scale", ",", "scale_idx", "=", "self", ".", "random_sample_ratio", "(", "\n", "self", ".", "img_scale", "[", "0", "]", ",", "self", ".", "ratio_range", ")", "\n", "", "elif", "len", "(", "self", ".", "img_scale", ")", "==", "1", ":", "\n", "            ", "scale", ",", "scale_idx", "=", "self", ".", "img_scale", "[", "0", "]", ",", "0", "\n", "", "elif", "self", ".", "multiscale_mode", "==", "'range'", ":", "\n", "            ", "scale", ",", "scale_idx", "=", "self", ".", "random_sample", "(", "self", ".", "img_scale", ")", "\n", "", "elif", "self", ".", "multiscale_mode", "==", "'value'", ":", "\n", "            ", "scale", ",", "scale_idx", "=", "self", ".", "random_select", "(", "self", ".", "img_scale", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "results", "[", "'scale'", "]", "=", "scale", "\n", "results", "[", "'scale_idx'", "]", "=", "scale_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_img": [[189, 219], ["results.get", "numpy.array", "mmcv.imrescale", "mmcv.imresize"], "methods", ["None"], ["", "def", "_resize_img", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Resize images with ``results['scale']``.\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'img'", "]", ")", ":", "\n", "            ", "if", "self", ".", "keep_ratio", ":", "\n", "                ", "img", ",", "scale_factor", "=", "mmcv", ".", "imrescale", "(", "\n", "results", "[", "key", "]", ",", "\n", "results", "[", "'scale'", "]", ",", "\n", "return_scale", "=", "True", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "# the w_scale and h_scale has minor difference", "\n", "# a real fix should be done in the mmcv.imrescale in the future", "\n", "new_h", ",", "new_w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "h", ",", "w", "=", "results", "[", "key", "]", ".", "shape", "[", ":", "2", "]", "\n", "w_scale", "=", "new_w", "/", "w", "\n", "h_scale", "=", "new_h", "/", "h", "\n", "", "else", ":", "\n", "                ", "img", ",", "w_scale", ",", "h_scale", "=", "mmcv", ".", "imresize", "(", "\n", "results", "[", "key", "]", ",", "\n", "results", "[", "'scale'", "]", ",", "\n", "return_scale", "=", "True", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "", "results", "[", "key", "]", "=", "img", "\n", "\n", "scale_factor", "=", "np", ".", "array", "(", "[", "w_scale", ",", "h_scale", ",", "w_scale", ",", "h_scale", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "# in case that there is no padding", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "scale_factor", "\n", "results", "[", "'keep_ratio'", "]", "=", "self", ".", "keep_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_bboxes": [[220, 228], ["results.get", "numpy.clip", "numpy.clip"], "methods", ["None"], ["", "", "def", "_resize_bboxes", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Resize bounding boxes with ``results['scale_factor']``.\"\"\"", "\n", "img_shape", "=", "results", "[", "'img_shape'", "]", "\n", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "            ", "bboxes", "=", "results", "[", "key", "]", "*", "results", "[", "'scale_factor'", "]", "\n", "bboxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "0", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "1", "]", ")", "\n", "bboxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "1", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "0", "]", ")", "\n", "results", "[", "key", "]", "=", "bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_masks": [[229, 238], ["results.get", "results[].rescale", "results[].resize"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize"], ["", "", "def", "_resize_masks", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Resize masks with ``results['scale']``\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "results", "[", "key", "]", "is", "None", ":", "\n", "                ", "continue", "\n", "", "if", "self", ".", "keep_ratio", ":", "\n", "                ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "rescale", "(", "results", "[", "'scale'", "]", ")", "\n", "", "else", ":", "\n", "                ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "resize", "(", "results", "[", "'img_shape'", "]", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_seg": [[239, 255], ["results.get", "mmcv.imrescale", "mmcv.imresize"], "methods", ["None"], ["", "", "", "def", "_resize_seg", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Resize semantic segmentation map with ``results['scale']``.\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "self", ".", "keep_ratio", ":", "\n", "                ", "gt_seg", "=", "mmcv", ".", "imrescale", "(", "\n", "results", "[", "key", "]", ",", "\n", "results", "[", "'scale'", "]", ",", "\n", "interpolation", "=", "'nearest'", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "", "else", ":", "\n", "                ", "gt_seg", "=", "mmcv", ".", "imresize", "(", "\n", "results", "[", "key", "]", ",", "\n", "results", "[", "'scale'", "]", ",", "\n", "interpolation", "=", "'nearest'", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "", "results", "[", "'gt_semantic_seg'", "]", "=", "gt_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.__call__": [[256, 286], ["transforms.Resize._resize_img", "transforms.Resize._resize_bboxes", "transforms.Resize._resize_masks", "transforms.Resize._resize_seg", "isinstance", "tuple", "transforms.Resize._random_scale", "int"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_img", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._resize_seg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize._random_scale"], ["", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to resize images, bounding boxes, masks, semantic\n        segmentation map.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Resized results, 'img_shape', 'pad_shape', 'scale_factor', \\\n                'keep_ratio' keys are added into result dict.\n        \"\"\"", "\n", "\n", "if", "'scale'", "not", "in", "results", ":", "\n", "            ", "if", "'scale_factor'", "in", "results", ":", "\n", "                ", "img_shape", "=", "results", "[", "'img'", "]", ".", "shape", "[", ":", "2", "]", "\n", "scale_factor", "=", "results", "[", "'scale_factor'", "]", "\n", "assert", "isinstance", "(", "scale_factor", ",", "float", ")", "\n", "results", "[", "'scale'", "]", "=", "tuple", "(", "\n", "[", "int", "(", "x", "*", "scale_factor", ")", "for", "x", "in", "img_shape", "]", "[", ":", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_random_scale", "(", "results", ")", "\n", "", "", "else", ":", "\n", "            ", "assert", "'scale_factor'", "not", "in", "results", ",", "(", "\n", "'scale and scale_factor cannot be both set.'", ")", "\n", "\n", "", "self", ".", "_resize_img", "(", "results", ")", "\n", "self", ".", "_resize_bboxes", "(", "results", ")", "\n", "self", ".", "_resize_masks", "(", "results", ")", "\n", "self", ".", "_resize_seg", "(", "results", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Resize.__repr__": [[287, 294], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(img_scale={self.img_scale}, '", "\n", "repr_str", "+=", "f'multiscale_mode={self.multiscale_mode}, '", "\n", "repr_str", "+=", "f'ratio_range={self.ratio_range}, '", "\n", "repr_str", "+=", "f'keep_ratio={self.keep_ratio})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomFlip.__init__": [[310, 316], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "flip_ratio", "=", "None", ",", "direction", "=", "'horizontal'", ")", ":", "\n", "        ", "self", ".", "flip_ratio", "=", "flip_ratio", "\n", "self", ".", "direction", "=", "direction", "\n", "if", "flip_ratio", "is", "not", "None", ":", "\n", "            ", "assert", "flip_ratio", ">=", "0", "and", "flip_ratio", "<=", "1", "\n", "", "assert", "direction", "in", "[", "'horizontal'", ",", "'vertical'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomFlip.bbox_flip": [[317, 343], ["bboxes.copy", "ValueError"], "methods", ["None"], ["", "def", "bbox_flip", "(", "self", ",", "bboxes", ",", "img_shape", ",", "direction", ")", ":", "\n", "        ", "\"\"\"Flip bboxes horizontally.\n\n        Args:\n            bboxes (numpy.ndarray): Bounding boxes, shape (..., 4*k)\n            img_shape (tuple[int]): Image shape (height, width)\n            direction (str): Flip direction. Options are 'horizontal',\n                'vertical'.\n\n        Returns:\n            numpy.ndarray: Flipped bounding boxes.\n        \"\"\"", "\n", "\n", "assert", "bboxes", ".", "shape", "[", "-", "1", "]", "%", "4", "==", "0", "\n", "flipped", "=", "bboxes", ".", "copy", "(", ")", "\n", "if", "direction", "==", "'horizontal'", ":", "\n", "            ", "w", "=", "img_shape", "[", "1", "]", "\n", "flipped", "[", "...", ",", "0", ":", ":", "4", "]", "=", "w", "-", "bboxes", "[", "...", ",", "2", ":", ":", "4", "]", "\n", "flipped", "[", "...", ",", "2", ":", ":", "4", "]", "=", "w", "-", "bboxes", "[", "...", ",", "0", ":", ":", "4", "]", "\n", "", "elif", "direction", "==", "'vertical'", ":", "\n", "            ", "h", "=", "img_shape", "[", "0", "]", "\n", "flipped", "[", "...", ",", "1", ":", ":", "4", "]", "=", "h", "-", "bboxes", "[", "...", ",", "3", ":", ":", "4", "]", "\n", "flipped", "[", "...", ",", "3", ":", ":", "4", "]", "=", "h", "-", "bboxes", "[", "...", ",", "1", ":", ":", "4", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid flipping direction '{direction}'\"", ")", "\n", "", "return", "flipped", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomFlip.__call__": [[344, 380], ["results.get", "results.get", "results.get", "results.get", "mmcv.imflip", "transforms.RandomFlip.bbox_flip", "results[].flip", "mmcv.imflip", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to flip bounding boxes, masks, semantic segmentation\n        maps.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Flipped results, 'flip', 'flip_direction' keys are added \\\n                into result dict.\n        \"\"\"", "\n", "\n", "if", "'flip'", "not", "in", "results", ":", "\n", "            ", "flip", "=", "True", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "self", ".", "flip_ratio", "else", "False", "\n", "results", "[", "'flip'", "]", "=", "flip", "\n", "", "if", "'flip_direction'", "not", "in", "results", ":", "\n", "            ", "results", "[", "'flip_direction'", "]", "=", "self", ".", "direction", "\n", "", "if", "results", "[", "'flip'", "]", ":", "\n", "# flip image", "\n", "            ", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'img'", "]", ")", ":", "\n", "                ", "results", "[", "key", "]", "=", "mmcv", ".", "imflip", "(", "\n", "results", "[", "key", "]", ",", "direction", "=", "results", "[", "'flip_direction'", "]", ")", "\n", "# flip bboxes", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "                ", "results", "[", "key", "]", "=", "self", ".", "bbox_flip", "(", "results", "[", "key", "]", ",", "\n", "results", "[", "'img_shape'", "]", ",", "\n", "results", "[", "'flip_direction'", "]", ")", "\n", "# flip masks", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "                ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "flip", "(", "results", "[", "'flip_direction'", "]", ")", "\n", "\n", "# flip segs", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "                ", "results", "[", "key", "]", "=", "mmcv", ".", "imflip", "(", "\n", "results", "[", "key", "]", ",", "direction", "=", "results", "[", "'flip_direction'", "]", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomFlip.__repr__": [[381, 383], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(flip_ratio={self.flip_ratio})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad.__init__": [[399, 406], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", "=", "None", ",", "size_divisor", "=", "None", ",", "pad_val", "=", "0", ")", ":", "\n", "        ", "self", ".", "size", "=", "size", "\n", "self", ".", "size_divisor", "=", "size_divisor", "\n", "self", ".", "pad_val", "=", "pad_val", "\n", "# only one of size and size_divisor should be valid", "\n", "assert", "size", "is", "not", "None", "or", "size_divisor", "is", "not", "None", "\n", "assert", "size", "is", "None", "or", "size_divisor", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_img": [[407, 420], ["results.get", "mmcv.impad", "mmcv.impad_to_multiple"], "methods", ["None"], ["", "def", "_pad_img", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Pad images according to ``self.size``.\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'img'", "]", ")", ":", "\n", "            ", "if", "self", ".", "size", "is", "not", "None", ":", "\n", "                ", "padded_img", "=", "mmcv", ".", "impad", "(", "\n", "results", "[", "key", "]", ",", "shape", "=", "self", ".", "size", ",", "pad_val", "=", "self", ".", "pad_val", ")", "\n", "", "elif", "self", ".", "size_divisor", "is", "not", "None", ":", "\n", "                ", "padded_img", "=", "mmcv", ".", "impad_to_multiple", "(", "\n", "results", "[", "key", "]", ",", "self", ".", "size_divisor", ",", "pad_val", "=", "self", ".", "pad_val", ")", "\n", "", "results", "[", "key", "]", "=", "padded_img", "\n", "", "results", "[", "'pad_shape'", "]", "=", "padded_img", ".", "shape", "\n", "results", "[", "'pad_fixed_size'", "]", "=", "self", ".", "size", "\n", "results", "[", "'pad_size_divisor'", "]", "=", "self", ".", "size_divisor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_masks": [[421, 426], ["results.get", "results[].pad"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad"], ["", "def", "_pad_masks", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Pad masks according to ``results['pad_shape']``.\"\"\"", "\n", "pad_shape", "=", "results", "[", "'pad_shape'", "]", "[", ":", "2", "]", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "pad", "(", "pad_shape", ",", "pad_val", "=", "self", ".", "pad_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_seg": [[427, 433], ["results.get", "mmcv.impad"], "methods", ["None"], ["", "", "def", "_pad_seg", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Pad semantic segmentation map according to\n        ``results['pad_shape']``.\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "mmcv", ".", "impad", "(", "\n", "results", "[", "key", "]", ",", "shape", "=", "results", "[", "'pad_shape'", "]", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad.__call__": [[434, 447], ["transforms.Pad._pad_img", "transforms.Pad._pad_masks", "transforms.Pad._pad_seg"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_img", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad._pad_seg"], ["", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to pad images, masks, semantic segmentation maps.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Updated result dict.\n        \"\"\"", "\n", "self", ".", "_pad_img", "(", "results", ")", "\n", "self", ".", "_pad_masks", "(", "results", ")", "\n", "self", ".", "_pad_seg", "(", "results", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Pad.__repr__": [[448, 454], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(size={self.size}, '", "\n", "repr_str", "+=", "f'size_divisor={self.size_divisor}, '", "\n", "repr_str", "+=", "f'pad_val={self.pad_val})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Normalize.__init__": [[469, 473], ["numpy.array", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ",", "to_rgb", "=", "True", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "to_rgb", "=", "to_rgb", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Normalize.__call__": [[474, 490], ["results.get", "dict", "mmcv.imnormalize"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to normalize images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Normalized results, 'img_norm_cfg' key is added into\n                result dict.\n        \"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'img'", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "mmcv", ".", "imnormalize", "(", "results", "[", "key", "]", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "\n", "self", ".", "to_rgb", ")", "\n", "", "results", "[", "'img_norm_cfg'", "]", "=", "dict", "(", "\n", "mean", "=", "self", ".", "mean", ",", "std", "=", "self", ".", "std", ",", "to_rgb", "=", "self", ".", "to_rgb", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Normalize.__repr__": [[491, 495], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(mean={self.mean}, std={self.std}, to_rgb={self.to_rgb})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCrop.__init__": [[516, 528], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "crop_size", ",", "allow_negative_crop", "=", "False", ")", ":", "\n", "        ", "assert", "crop_size", "[", "0", "]", ">", "0", "and", "crop_size", "[", "1", "]", ">", "0", "\n", "self", ".", "crop_size", "=", "crop_size", "\n", "self", ".", "allow_negative_crop", "=", "allow_negative_crop", "\n", "# The key correspondence from bboxes to labels and masks.", "\n", "self", ".", "bbox2label", "=", "{", "\n", "'gt_bboxes'", ":", "'gt_labels'", ",", "\n", "'gt_bboxes_ignore'", ":", "'gt_labels_ignore'", "\n", "}", "\n", "self", ".", "bbox2mask", "=", "{", "\n", "'gt_bboxes'", ":", "'gt_masks'", ",", "\n", "'gt_bboxes_ignore'", ":", "'gt_masks_ignore'", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCrop.__call__": [[530, 590], ["results.get", "results.get", "results.get", "max", "max", "numpy.random.randint", "numpy.random.randint", "numpy.array", "numpy.clip", "numpy.clip", "transforms.RandomCrop.bbox2label.get", "transforms.RandomCrop.bbox2mask.get", "[].crop", "valid_inds.any", "numpy.asarray", "valid_inds.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to randomly crop images, bounding boxes, masks,\n        semantic segmentation maps.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Randomly cropped results, 'img_shape' key in result dict is\n                updated according to crop size.\n        \"\"\"", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'img'", "]", ")", ":", "\n", "            ", "img", "=", "results", "[", "key", "]", "\n", "margin_h", "=", "max", "(", "img", ".", "shape", "[", "0", "]", "-", "self", ".", "crop_size", "[", "0", "]", ",", "0", ")", "\n", "margin_w", "=", "max", "(", "img", ".", "shape", "[", "1", "]", "-", "self", ".", "crop_size", "[", "1", "]", ",", "0", ")", "\n", "offset_h", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "margin_h", "+", "1", ")", "\n", "offset_w", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "margin_w", "+", "1", ")", "\n", "crop_y1", ",", "crop_y2", "=", "offset_h", ",", "offset_h", "+", "self", ".", "crop_size", "[", "0", "]", "\n", "crop_x1", ",", "crop_x2", "=", "offset_w", ",", "offset_w", "+", "self", ".", "crop_size", "[", "1", "]", "\n", "\n", "# crop the image", "\n", "img", "=", "img", "[", "crop_y1", ":", "crop_y2", ",", "crop_x1", ":", "crop_x2", ",", "...", "]", "\n", "img_shape", "=", "img", ".", "shape", "\n", "results", "[", "key", "]", "=", "img", "\n", "", "results", "[", "'img_shape'", "]", "=", "img_shape", "\n", "\n", "# crop bboxes accordingly and clip to the image boundary", "\n", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "# e.g. gt_bboxes and gt_bboxes_ignore", "\n", "            ", "bbox_offset", "=", "np", ".", "array", "(", "[", "offset_w", ",", "offset_h", ",", "offset_w", ",", "offset_h", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "bboxes", "=", "results", "[", "key", "]", "-", "bbox_offset", "\n", "bboxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "0", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "1", "]", ")", "\n", "bboxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "1", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "0", "]", ")", "\n", "valid_inds", "=", "(", "bboxes", "[", ":", ",", "2", "]", ">", "bboxes", "[", ":", ",", "0", "]", ")", "&", "(", "\n", "bboxes", "[", ":", ",", "3", "]", ">", "bboxes", "[", ":", ",", "1", "]", ")", "\n", "# If the crop does not contain any gt-bbox area and", "\n", "# self.allow_negative_crop is False, skip this image.", "\n", "if", "(", "key", "==", "'gt_bboxes'", "and", "not", "valid_inds", ".", "any", "(", ")", "\n", "and", "not", "self", ".", "allow_negative_crop", ")", ":", "\n", "                ", "return", "None", "\n", "", "results", "[", "key", "]", "=", "bboxes", "[", "valid_inds", ",", ":", "]", "\n", "# label fields. e.g. gt_labels and gt_labels_ignore", "\n", "label_key", "=", "self", ".", "bbox2label", ".", "get", "(", "key", ")", "\n", "if", "label_key", "in", "results", ":", "\n", "                ", "results", "[", "label_key", "]", "=", "results", "[", "label_key", "]", "[", "valid_inds", "]", "\n", "\n", "# mask fields, e.g. gt_masks and gt_masks_ignore", "\n", "", "mask_key", "=", "self", ".", "bbox2mask", ".", "get", "(", "key", ")", "\n", "if", "mask_key", "in", "results", ":", "\n", "                ", "results", "[", "mask_key", "]", "=", "results", "[", "mask_key", "]", "[", "\n", "valid_inds", ".", "nonzero", "(", ")", "[", "0", "]", "]", ".", "crop", "(", "\n", "np", ".", "asarray", "(", "[", "crop_x1", ",", "crop_y1", ",", "crop_x2", ",", "crop_y2", "]", ")", ")", "\n", "\n", "# crop semantic seg", "\n", "", "", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", "[", "crop_y1", ":", "crop_y2", ",", "crop_x1", ":", "crop_x2", "]", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCrop.__repr__": [[591, 593], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(crop_size={self.crop_size})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.SegRescale.__init__": [[606, 609], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "scale_factor", "=", "1", ",", "backend", "=", "'cv2'", ")", ":", "\n", "        ", "self", ".", "scale_factor", "=", "scale_factor", "\n", "self", ".", "backend", "=", "backend", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.SegRescale.__call__": [[610, 628], ["results.get", "mmcv.imrescale"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to scale the semantic segmentation map.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with semantic segmentation map scaled.\n        \"\"\"", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "self", ".", "scale_factor", "!=", "1", ":", "\n", "                ", "results", "[", "key", "]", "=", "mmcv", ".", "imrescale", "(", "\n", "results", "[", "key", "]", ",", "\n", "self", ".", "scale_factor", ",", "\n", "interpolation", "=", "'nearest'", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.SegRescale.__repr__": [[629, 631], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(scale_factor={self.scale_factor})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.PhotoMetricDistortion.__init__": [[655, 664], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "brightness_delta", "=", "32", ",", "\n", "contrast_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "saturation_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "hue_delta", "=", "18", ")", ":", "\n", "        ", "self", ".", "brightness_delta", "=", "brightness_delta", "\n", "self", ".", "contrast_lower", ",", "self", ".", "contrast_upper", "=", "contrast_range", "\n", "self", ".", "saturation_lower", ",", "self", ".", "saturation_upper", "=", "saturation_range", "\n", "self", ".", "hue_delta", "=", "hue_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.PhotoMetricDistortion.__call__": [[665, 727], ["numpy.random.randint", "numpy.random.randint", "mmcv.bgr2hsv", "numpy.random.randint", "numpy.random.randint", "mmcv.hsv2bgr", "numpy.random.randint", "numpy.random.uniform", "numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.permutation"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to perform photometric distortion on images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with images distorted.\n        \"\"\"", "\n", "\n", "if", "'img_fields'", "in", "results", ":", "\n", "            ", "assert", "results", "[", "'img_fields'", "]", "==", "[", "'img'", "]", ",", "'Only single img_fields is allowed'", "\n", "", "img", "=", "results", "[", "'img'", "]", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "float32", ",", "'PhotoMetricDistortion needs the input image of dtype np.float32,'", "' please set \"to_float32=True\" in \"LoadImageFromFile\" pipeline'", "\n", "# random brightness", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "delta", "=", "random", ".", "uniform", "(", "-", "self", ".", "brightness_delta", ",", "\n", "self", ".", "brightness_delta", ")", "\n", "img", "+=", "delta", "\n", "\n", "# mode == 0 --> do random contrast first", "\n", "# mode == 1 --> do random contrast last", "\n", "", "mode", "=", "random", ".", "randint", "(", "2", ")", "\n", "if", "mode", "==", "1", ":", "\n", "            ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "img", "*=", "alpha", "\n", "\n", "# convert color from BGR to HSV", "\n", "", "", "img", "=", "mmcv", ".", "bgr2hsv", "(", "img", ")", "\n", "\n", "# random saturation", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "[", "...", ",", "1", "]", "*=", "random", ".", "uniform", "(", "self", ".", "saturation_lower", ",", "\n", "self", ".", "saturation_upper", ")", "\n", "\n", "# random hue", "\n", "", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "[", "...", ",", "0", "]", "+=", "random", ".", "uniform", "(", "-", "self", ".", "hue_delta", ",", "self", ".", "hue_delta", ")", "\n", "img", "[", "...", ",", "0", "]", "[", "img", "[", "...", ",", "0", "]", ">", "360", "]", "-=", "360", "\n", "img", "[", "...", ",", "0", "]", "[", "img", "[", "...", ",", "0", "]", "<", "0", "]", "+=", "360", "\n", "\n", "# convert color from HSV to BGR", "\n", "", "img", "=", "mmcv", ".", "hsv2bgr", "(", "img", ")", "\n", "\n", "# random contrast", "\n", "if", "mode", "==", "0", ":", "\n", "            ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "img", "*=", "alpha", "\n", "\n", "# randomly swap channels", "\n", "", "", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "=", "img", "[", "...", ",", "random", ".", "permutation", "(", "3", ")", "]", "\n", "\n", "", "results", "[", "'img'", "]", "=", "img", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.PhotoMetricDistortion.__repr__": [[728, 737], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(\\nbrightness_delta={self.brightness_delta},\\n'", "\n", "repr_str", "+=", "'contrast_range='", "\n", "repr_str", "+=", "f'{(self.contrast_lower, self.contrast_upper)},\\n'", "\n", "repr_str", "+=", "'saturation_range='", "\n", "repr_str", "+=", "f'{(self.saturation_lower, self.saturation_upper)},\\n'", "\n", "repr_str", "+=", "f'hue_delta={self.hue_delta})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Expand.__init__": [[753, 768], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "mean", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "to_rgb", "=", "True", ",", "\n", "ratio_range", "=", "(", "1", ",", "4", ")", ",", "\n", "seg_ignore_label", "=", "None", ",", "\n", "prob", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "to_rgb", "=", "to_rgb", "\n", "self", ".", "ratio_range", "=", "ratio_range", "\n", "if", "to_rgb", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "\n", "", "self", ".", "min_ratio", ",", "self", ".", "max_ratio", "=", "ratio_range", "\n", "self", ".", "seg_ignore_label", "=", "seg_ignore_label", "\n", "self", ".", "prob", "=", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Expand.__call__": [[769, 816], ["numpy.random.uniform", "numpy.full", "int", "int", "results.get", "results.get", "results.get", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "results[].expand", "numpy.full", "int", "int", "numpy.tile().astype", "int", "int", "int", "int", "numpy.tile"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to expand images, bounding boxes.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with images, bounding boxes expanded\n        \"\"\"", "\n", "\n", "if", "random", ".", "uniform", "(", "0", ",", "1", ")", ">", "self", ".", "prob", ":", "\n", "            ", "return", "results", "\n", "\n", "", "if", "'img_fields'", "in", "results", ":", "\n", "            ", "assert", "results", "[", "'img_fields'", "]", "==", "[", "'img'", "]", ",", "'Only single img_fields is allowed'", "\n", "", "img", "=", "results", "[", "'img'", "]", "\n", "\n", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "ratio", "=", "random", ".", "uniform", "(", "self", ".", "min_ratio", ",", "self", ".", "max_ratio", ")", "\n", "expand_img", "=", "np", ".", "full", "(", "(", "int", "(", "h", "*", "ratio", ")", ",", "int", "(", "w", "*", "ratio", ")", ",", "c", ")", ",", "\n", "self", ".", "mean", ",", "\n", "dtype", "=", "img", ".", "dtype", ")", "\n", "left", "=", "int", "(", "random", ".", "uniform", "(", "0", ",", "w", "*", "ratio", "-", "w", ")", ")", "\n", "top", "=", "int", "(", "random", ".", "uniform", "(", "0", ",", "h", "*", "ratio", "-", "h", ")", ")", "\n", "expand_img", "[", "top", ":", "top", "+", "h", ",", "left", ":", "left", "+", "w", "]", "=", "img", "\n", "\n", "results", "[", "'img'", "]", "=", "expand_img", "\n", "# expand bboxes", "\n", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", "+", "np", ".", "tile", "(", "\n", "(", "left", ",", "top", ")", ",", "2", ")", ".", "astype", "(", "results", "[", "key", "]", ".", "dtype", ")", "\n", "\n", "# expand masks", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "expand", "(", "\n", "int", "(", "h", "*", "ratio", ")", ",", "int", "(", "w", "*", "ratio", ")", ",", "top", ",", "left", ")", "\n", "\n", "# expand segs", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "            ", "gt_seg", "=", "results", "[", "key", "]", "\n", "expand_gt_seg", "=", "np", ".", "full", "(", "(", "int", "(", "h", "*", "ratio", ")", ",", "int", "(", "w", "*", "ratio", ")", ")", ",", "\n", "self", ".", "seg_ignore_label", ",", "\n", "dtype", "=", "gt_seg", ".", "dtype", ")", "\n", "expand_gt_seg", "[", "top", ":", "top", "+", "h", ",", "left", ":", "left", "+", "w", "]", "=", "gt_seg", "\n", "results", "[", "key", "]", "=", "expand_gt_seg", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Expand.__repr__": [[817, 823], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(mean={self.mean}, to_rgb={self.to_rgb}, '", "\n", "repr_str", "+=", "f'ratio_range={self.ratio_range}, '", "\n", "repr_str", "+=", "f'seg_ignore_label={self.seg_ignore_label})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.MinIoURandomCrop.__init__": [[843, 855], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_ious", "=", "(", "0.1", ",", "0.3", ",", "0.5", ",", "0.7", ",", "0.9", ")", ",", "min_crop_size", "=", "0.3", ")", ":", "\n", "# 1: return ori img", "\n", "        ", "self", ".", "min_ious", "=", "min_ious", "\n", "self", ".", "sample_mode", "=", "(", "1", ",", "*", "min_ious", ",", "0", ")", "\n", "self", ".", "min_crop_size", "=", "min_crop_size", "\n", "self", ".", "bbox2label", "=", "{", "\n", "'gt_bboxes'", ":", "'gt_labels'", ",", "\n", "'gt_bboxes_ignore'", ":", "'gt_labels_ignore'", "\n", "}", "\n", "self", ".", "bbox2mask", "=", "{", "\n", "'gt_bboxes'", ":", "'gt_masks'", ",", "\n", "'gt_bboxes_ignore'", ":", "'gt_masks_ignore'", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.MinIoURandomCrop.__call__": [[857, 949], ["numpy.concatenate", "numpy.random.choice", "range", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "mmdet.core.evaluation.bbox_overlaps.bbox_overlaps().reshape", "results.get", "len", "transforms.MinIoURandomCrop.__call__.is_center_of_bboxes_in_patch"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to crop images and bounding boxes with minimum IoU\n        constraint.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with images and bounding boxes cropped, \\\n                'img_shape' key is updated.\n        \"\"\"", "\n", "\n", "if", "'img_fields'", "in", "results", ":", "\n", "            ", "assert", "results", "[", "'img_fields'", "]", "==", "[", "'img'", "]", ",", "'Only single img_fields is allowed'", "\n", "", "img", "=", "results", "[", "'img'", "]", "\n", "assert", "'bbox_fields'", "in", "results", "\n", "boxes", "=", "[", "results", "[", "key", "]", "for", "key", "in", "results", "[", "'bbox_fields'", "]", "]", "\n", "boxes", "=", "np", ".", "concatenate", "(", "boxes", ",", "0", ")", "\n", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "while", "True", ":", "\n", "            ", "mode", "=", "random", ".", "choice", "(", "self", ".", "sample_mode", ")", "\n", "self", ".", "mode", "=", "mode", "\n", "if", "mode", "==", "1", ":", "\n", "                ", "return", "results", "\n", "\n", "", "min_iou", "=", "mode", "\n", "for", "i", "in", "range", "(", "50", ")", ":", "\n", "                ", "new_w", "=", "random", ".", "uniform", "(", "self", ".", "min_crop_size", "*", "w", ",", "w", ")", "\n", "new_h", "=", "random", ".", "uniform", "(", "self", ".", "min_crop_size", "*", "h", ",", "h", ")", "\n", "\n", "# h / w in [0.5, 2]", "\n", "if", "new_h", "/", "new_w", "<", "0.5", "or", "new_h", "/", "new_w", ">", "2", ":", "\n", "                    ", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "w", "-", "new_w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "h", "-", "new_h", ")", "\n", "\n", "patch", "=", "np", ".", "array", "(", "\n", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "new_w", ")", ",", "int", "(", "top", "+", "new_h", ")", ")", ")", "\n", "# Line or point crop is not allowed", "\n", "if", "patch", "[", "2", "]", "==", "patch", "[", "0", "]", "or", "patch", "[", "3", "]", "==", "patch", "[", "1", "]", ":", "\n", "                    ", "continue", "\n", "", "overlaps", "=", "bbox_overlaps", "(", "\n", "patch", ".", "reshape", "(", "-", "1", ",", "4", ")", ",", "boxes", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "if", "len", "(", "overlaps", ")", ">", "0", "and", "overlaps", ".", "min", "(", ")", "<", "min_iou", ":", "\n", "                    ", "continue", "\n", "\n", "# center of boxes should inside the crop img", "\n", "# only adjust boxes and instance masks when the gt is not empty", "\n", "", "if", "len", "(", "overlaps", ")", ">", "0", ":", "\n", "# adjust boxes", "\n", "                    ", "def", "is_center_of_bboxes_in_patch", "(", "boxes", ",", "patch", ")", ":", "\n", "                        ", "center", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "mask", "=", "(", "(", "center", "[", ":", ",", "0", "]", ">", "patch", "[", "0", "]", ")", "*", "\n", "(", "center", "[", ":", ",", "1", "]", ">", "patch", "[", "1", "]", ")", "*", "\n", "(", "center", "[", ":", ",", "0", "]", "<", "patch", "[", "2", "]", ")", "*", "\n", "(", "center", "[", ":", ",", "1", "]", "<", "patch", "[", "3", "]", ")", ")", "\n", "return", "mask", "\n", "\n", "", "mask", "=", "is_center_of_bboxes_in_patch", "(", "boxes", ",", "patch", ")", "\n", "if", "not", "mask", ".", "any", "(", ")", ":", "\n", "                        ", "continue", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "                        ", "boxes", "=", "results", "[", "key", "]", ".", "copy", "(", ")", "\n", "mask", "=", "is_center_of_bboxes_in_patch", "(", "boxes", ",", "patch", ")", "\n", "boxes", "=", "boxes", "[", "mask", "]", "\n", "boxes", "[", ":", ",", "2", ":", "]", "=", "boxes", "[", ":", ",", "2", ":", "]", ".", "clip", "(", "max", "=", "patch", "[", "2", ":", "]", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "=", "boxes", "[", ":", ",", ":", "2", "]", ".", "clip", "(", "min", "=", "patch", "[", ":", "2", "]", ")", "\n", "boxes", "-=", "np", ".", "tile", "(", "patch", "[", ":", "2", "]", ",", "2", ")", "\n", "\n", "results", "[", "key", "]", "=", "boxes", "\n", "# labels", "\n", "label_key", "=", "self", ".", "bbox2label", ".", "get", "(", "key", ")", "\n", "if", "label_key", "in", "results", ":", "\n", "                            ", "results", "[", "label_key", "]", "=", "results", "[", "label_key", "]", "[", "mask", "]", "\n", "\n", "# mask fields", "\n", "", "mask_key", "=", "self", ".", "bbox2mask", ".", "get", "(", "key", ")", "\n", "if", "mask_key", "in", "results", ":", "\n", "                            ", "results", "[", "mask_key", "]", "=", "results", "[", "mask_key", "]", "[", "\n", "mask", ".", "nonzero", "(", ")", "[", "0", "]", "]", ".", "crop", "(", "patch", ")", "\n", "# adjust the img no matter whether the gt is empty before crop", "\n", "", "", "", "img", "=", "img", "[", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "\n", "# seg fields", "\n", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "                    ", "results", "[", "key", "]", "=", "results", "[", "key", "]", "[", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "\n", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.MinIoURandomCrop.__repr__": [[950, 955], ["None"], "methods", ["None"], ["", "", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(min_ious={self.min_ious}, '", "\n", "repr_str", "+=", "f'min_crop_size={self.min_crop_size})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Corrupt.__init__": [[969, 972], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "corruption", ",", "severity", "=", "1", ")", ":", "\n", "        ", "self", ".", "corruption", "=", "corruption", "\n", "self", ".", "severity", "=", "severity", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Corrupt.__call__": [[973, 993], ["corrupt", "RuntimeError", "results[].astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to corrupt image.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with images corrupted.\n        \"\"\"", "\n", "\n", "if", "corrupt", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'imagecorruptions is not installed'", ")", "\n", "", "if", "'img_fields'", "in", "results", ":", "\n", "            ", "assert", "results", "[", "'img_fields'", "]", "==", "[", "'img'", "]", ",", "'Only single img_fields is allowed'", "\n", "", "results", "[", "'img'", "]", "=", "corrupt", "(", "\n", "results", "[", "'img'", "]", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "corruption_name", "=", "self", ".", "corruption", ",", "\n", "severity", "=", "self", ".", "severity", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Corrupt.__repr__": [[994, 999], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(corruption={self.corruption}, '", "\n", "repr_str", "+=", "f'severity={self.severity})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.__init__": [[1044, 1080], ["Compose", "RuntimeError", "isinstance", "transforms.Albu.albu_builder", "transforms.Albu.albu_builder", "transforms.Albu.keymap_to_albu.items"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.albu_builder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.albu_builder"], ["def", "__init__", "(", "self", ",", "\n", "transforms", ",", "\n", "bbox_params", "=", "None", ",", "\n", "keymap", "=", "None", ",", "\n", "update_pad_shape", "=", "False", ",", "\n", "skip_img_without_anno", "=", "False", ")", ":", "\n", "        ", "if", "Compose", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "'albumentations is not installed'", ")", "\n", "\n", "", "self", ".", "transforms", "=", "transforms", "\n", "self", ".", "filter_lost_elements", "=", "False", "\n", "self", ".", "update_pad_shape", "=", "update_pad_shape", "\n", "self", ".", "skip_img_without_anno", "=", "skip_img_without_anno", "\n", "\n", "# A simple workaround to remove masks without boxes", "\n", "if", "(", "isinstance", "(", "bbox_params", ",", "dict", ")", "and", "'label_fields'", "in", "bbox_params", "\n", "and", "'filter_lost_elements'", "in", "bbox_params", ")", ":", "\n", "            ", "self", ".", "filter_lost_elements", "=", "True", "\n", "self", ".", "origin_label_fields", "=", "bbox_params", "[", "'label_fields'", "]", "\n", "bbox_params", "[", "'label_fields'", "]", "=", "[", "'idx_mapper'", "]", "\n", "del", "bbox_params", "[", "'filter_lost_elements'", "]", "\n", "\n", "", "self", ".", "bbox_params", "=", "(", "\n", "self", ".", "albu_builder", "(", "bbox_params", ")", "if", "bbox_params", "else", "None", ")", "\n", "self", ".", "aug", "=", "Compose", "(", "[", "self", ".", "albu_builder", "(", "t", ")", "for", "t", "in", "self", ".", "transforms", "]", ",", "\n", "bbox_params", "=", "self", ".", "bbox_params", ")", "\n", "\n", "if", "not", "keymap", ":", "\n", "            ", "self", ".", "keymap_to_albu", "=", "{", "\n", "'img'", ":", "'image'", ",", "\n", "'gt_masks'", ":", "'masks'", ",", "\n", "'gt_bboxes'", ":", "'bboxes'", "\n", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "keymap_to_albu", "=", "keymap", "\n", "", "self", ".", "keymap_back", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "keymap_to_albu", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.albu_builder": [[1081, 1114], ["cfg.copy", "cfg.copy.pop", "mmcv.is_str", "getattr.", "isinstance", "getattr", "inspect.isclass", "RuntimeError", "TypeError", "transforms.Albu.albu_builder", "type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.albu_builder"], ["", "def", "albu_builder", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"Import a module from albumentations.\n\n        It inherits some of :func:`build_from_cfg` logic.\n\n        Args:\n            cfg (dict): Config dict. It should at least contain the key \"type\".\n\n        Returns:\n            obj: The constructed object.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "cfg", ",", "dict", ")", "and", "'type'", "in", "cfg", "\n", "args", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "obj_type", "=", "args", ".", "pop", "(", "'type'", ")", "\n", "if", "mmcv", ".", "is_str", "(", "obj_type", ")", ":", "\n", "            ", "if", "albumentations", "is", "None", ":", "\n", "                ", "raise", "RuntimeError", "(", "'albumentations is not installed'", ")", "\n", "", "obj_cls", "=", "getattr", "(", "albumentations", ",", "obj_type", ")", "\n", "", "elif", "inspect", ".", "isclass", "(", "obj_type", ")", ":", "\n", "            ", "obj_cls", "=", "obj_type", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'type must be a str or valid type, but got {type(obj_type)}'", ")", "\n", "\n", "", "if", "'transforms'", "in", "args", ":", "\n", "            ", "args", "[", "'transforms'", "]", "=", "[", "\n", "self", ".", "albu_builder", "(", "transform", ")", "\n", "for", "transform", "in", "args", "[", "'transforms'", "]", "\n", "]", "\n", "\n", "", "return", "obj_cls", "(", "**", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.mapper": [[1115, 1131], ["zip", "d.keys", "d.values", "keymap.get"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "mapper", "(", "d", ",", "keymap", ")", ":", "\n", "        ", "\"\"\"Dictionary mapper. Renames keys according to keymap provided.\n\n        Args:\n            d (dict): old dict\n            keymap (dict): {'old_key':'new_key'}\n        Returns:\n            dict: new dict.\n        \"\"\"", "\n", "\n", "updated_dict", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "zip", "(", "d", ".", "keys", "(", ")", ",", "d", ".", "values", "(", ")", ")", ":", "\n", "            ", "new_k", "=", "keymap", ".", "get", "(", "k", ",", "k", ")", "\n", "updated_dict", "[", "new_k", "]", "=", "d", "[", "k", "]", "\n", "", "return", "updated_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.__call__": [[1132, 1190], ["transforms.Albu.mapper", "transforms.Albu.aug", "transforms.Albu.mapper", "isinstance", "isinstance", "isinstance", "results[].reshape", "isinstance", "results[].astype", "numpy.arange", "NotImplementedError", "numpy.array", "numpy.array", "len", "numpy.array", "numpy.array", "ori_masks.__class__", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.mapper", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.mapper"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "# dict to albumentations format", "\n", "        ", "results", "=", "self", ".", "mapper", "(", "results", ",", "self", ".", "keymap_to_albu", ")", "\n", "# TODO: add bbox_fields", "\n", "if", "'bboxes'", "in", "results", ":", "\n", "# to list of boxes", "\n", "            ", "if", "isinstance", "(", "results", "[", "'bboxes'", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "results", "[", "'bboxes'", "]", "=", "[", "x", "for", "x", "in", "results", "[", "'bboxes'", "]", "]", "\n", "# add pseudo-field for filtration", "\n", "", "if", "self", ".", "filter_lost_elements", ":", "\n", "                ", "results", "[", "'idx_mapper'", "]", "=", "np", ".", "arange", "(", "len", "(", "results", "[", "'bboxes'", "]", ")", ")", "\n", "\n", "# TODO: Support mask structure in albu", "\n", "", "", "if", "'masks'", "in", "results", ":", "\n", "            ", "if", "isinstance", "(", "results", "[", "'masks'", "]", ",", "PolygonMasks", ")", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "'Albu only supports BitMap masks now'", ")", "\n", "", "ori_masks", "=", "results", "[", "'masks'", "]", "\n", "results", "[", "'masks'", "]", "=", "results", "[", "'masks'", "]", ".", "masks", "\n", "\n", "", "results", "=", "self", ".", "aug", "(", "**", "results", ")", "\n", "\n", "if", "'bboxes'", "in", "results", ":", "\n", "            ", "if", "isinstance", "(", "results", "[", "'bboxes'", "]", ",", "list", ")", ":", "\n", "                ", "results", "[", "'bboxes'", "]", "=", "np", ".", "array", "(", "\n", "results", "[", "'bboxes'", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "results", "[", "'bboxes'", "]", "=", "results", "[", "'bboxes'", "]", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n", "# filter label_fields", "\n", "if", "self", ".", "filter_lost_elements", ":", "\n", "\n", "                ", "for", "label", "in", "self", ".", "origin_label_fields", ":", "\n", "                    ", "results", "[", "label", "]", "=", "np", ".", "array", "(", "\n", "[", "results", "[", "label", "]", "[", "i", "]", "for", "i", "in", "results", "[", "'idx_mapper'", "]", "]", ")", "\n", "", "if", "'masks'", "in", "results", ":", "\n", "                    ", "results", "[", "'masks'", "]", "=", "np", ".", "array", "(", "\n", "[", "results", "[", "'masks'", "]", "[", "i", "]", "for", "i", "in", "results", "[", "'idx_mapper'", "]", "]", ")", "\n", "results", "[", "'masks'", "]", "=", "ori_masks", ".", "__class__", "(", "\n", "results", "[", "'masks'", "]", ",", "results", "[", "'image'", "]", ".", "shape", "[", "0", "]", ",", "\n", "results", "[", "'image'", "]", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "if", "(", "not", "len", "(", "results", "[", "'idx_mapper'", "]", ")", "\n", "and", "self", ".", "skip_img_without_anno", ")", ":", "\n", "                    ", "return", "None", "\n", "\n", "", "", "", "if", "'gt_labels'", "in", "results", ":", "\n", "            ", "if", "isinstance", "(", "results", "[", "'gt_labels'", "]", ",", "list", ")", ":", "\n", "                ", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "results", "[", "'gt_labels'", "]", ")", "\n", "", "results", "[", "'gt_labels'", "]", "=", "results", "[", "'gt_labels'", "]", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "# back to the original format", "\n", "", "results", "=", "self", ".", "mapper", "(", "results", ",", "self", ".", "keymap_back", ")", "\n", "\n", "# update final shape", "\n", "if", "self", ".", "update_pad_shape", ":", "\n", "            ", "results", "[", "'pad_shape'", "]", "=", "results", "[", "'img'", "]", ".", "shape", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.Albu.__repr__": [[1191, 1194], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "+", "f'(transforms={self.transforms})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad.__init__": [[1282, 1323], ["isinstance", "isinstance", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "crop_size", "=", "None", ",", "\n", "ratios", "=", "(", "0.9", ",", "1.0", ",", "1.1", ")", ",", "\n", "border", "=", "128", ",", "\n", "mean", "=", "None", ",", "\n", "std", "=", "None", ",", "\n", "to_rgb", "=", "None", ",", "\n", "test_mode", "=", "False", ",", "\n", "test_pad_mode", "=", "(", "'logical_or'", ",", "127", ")", ")", ":", "\n", "        ", "if", "test_mode", ":", "\n", "            ", "assert", "crop_size", "is", "None", ",", "'crop_size must be None in test mode'", "\n", "assert", "ratios", "is", "None", ",", "'ratios must be None in test mode'", "\n", "assert", "border", "is", "None", ",", "'border must be None in test mode'", "\n", "assert", "isinstance", "(", "test_pad_mode", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "test_pad_mode", "[", "0", "]", "in", "[", "'logical_or'", ",", "'size_divisor'", "]", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "crop_size", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "crop_size", "[", "0", "]", ">", "0", "and", "crop_size", "[", "1", "]", ">", "0", ",", "(", "\n", "'crop_size must > 0 in train mode'", ")", "\n", "assert", "isinstance", "(", "ratios", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "test_pad_mode", "is", "None", ",", "(", "\n", "'test_pad_mode must be None in train mode'", ")", "\n", "\n", "", "self", ".", "crop_size", "=", "crop_size", "\n", "self", ".", "ratios", "=", "ratios", "\n", "self", ".", "border", "=", "border", "\n", "# We do not set default value to mean, std and to_rgb because these", "\n", "# hyper-parameters are easy to forget but could affect the performance.", "\n", "# Please use the same setting as Normalize for performance assurance.", "\n", "assert", "mean", "is", "not", "None", "and", "std", "is", "not", "None", "and", "to_rgb", "is", "not", "None", "\n", "self", ".", "to_rgb", "=", "to_rgb", "\n", "self", ".", "input_mean", "=", "mean", "\n", "self", ".", "input_std", "=", "std", "\n", "if", "to_rgb", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "std", "=", "std", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "", "self", ".", "test_mode", "=", "test_mode", "\n", "self", ".", "test_pad_mode", "=", "test_pad_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._get_border": [[1324, 1342], ["pow", "numpy.ceil", "numpy.log2", "int", "numpy.ceil"], "methods", ["None"], ["", "def", "_get_border", "(", "self", ",", "border", ",", "size", ")", ":", "\n", "        ", "\"\"\"Get final border for the target size.\n\n        This function generates a ``final_border`` according to image's shape.\n        The area between ``final_border`` and ``size - final_border`` is the\n        ``center range``. We randomly choose center from the ``center range``\n        to avoid our random center is too close to original image's border.\n        Also ``center range`` should be larger than 0.\n\n        Args:\n            border (int): The initial border, default is 128.\n            size (int): The width or height of original image.\n        Returns:\n            int: The final border.\n        \"\"\"", "\n", "k", "=", "2", "*", "border", "/", "size", "\n", "i", "=", "pow", "(", "2", ",", "np", ".", "ceil", "(", "np", ".", "log2", "(", "np", ".", "ceil", "(", "k", ")", ")", ")", "+", "(", "k", "==", "int", "(", "k", ")", ")", ")", "\n", "return", "border", "//", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._filter_boxes": [[1343, 1358], ["None"], "methods", ["None"], ["", "def", "_filter_boxes", "(", "self", ",", "patch", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"Check whether the center of each box is in the patch.\n\n        Args:\n            patch (list[int]): The cropped area, [left, top, right, bottom].\n            boxes (numpy array, (N x 4)): Ground truth boxes.\n\n        Returns:\n            mask (numpy array, (N,)): Each box is inside or outside the patch.\n        \"\"\"", "\n", "center", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "mask", "=", "(", "center", "[", ":", ",", "0", "]", ">", "patch", "[", "0", "]", ")", "*", "(", "center", "[", ":", ",", "1", "]", ">", "patch", "[", "1", "]", ")", "*", "(", "\n", "center", "[", ":", ",", "0", "]", "<", "patch", "[", "2", "]", ")", "*", "(", "\n", "center", "[", ":", ",", "1", "]", "<", "patch", "[", "3", "]", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._crop_image_and_paste": [[1359, 1409], ["max", "min", "max", "min", "numpy.array", "numpy.zeros", "range", "slice", "slice", "numpy.array", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "_crop_image_and_paste", "(", "self", ",", "image", ",", "center", ",", "size", ")", ":", "\n", "        ", "\"\"\"Crop image with a given center and size, then paste the cropped\n        image to a blank image with two centers align.\n\n        This function is equivalent to generating a blank image with ``size``\n        as its shape. Then cover it on the original image with two centers (\n        the center of blank image and the random center of original image)\n        aligned. The overlap area is paste from the original image and the\n        outside area is filled with ``mean pixel``.\n\n        Args:\n            image (np array, H x W x C): Original image.\n            center (list[int]): Target crop center coord.\n            size (list[int]): Target crop size. [target_h, target_w]\n\n        Returns:\n            cropped_img (np array, target_h x target_w x C): Cropped image.\n            border (np array, 4): The distance of four border of\n                ``cropped_img`` to the original image area, [top, bottom,\n                left, right]\n            patch (list[int]): The cropped area, [left, top, right, bottom].\n        \"\"\"", "\n", "center_y", ",", "center_x", "=", "center", "\n", "target_h", ",", "target_w", "=", "size", "\n", "img_h", ",", "img_w", ",", "img_c", "=", "image", ".", "shape", "\n", "\n", "x0", "=", "max", "(", "0", ",", "center_x", "-", "target_w", "//", "2", ")", "\n", "x1", "=", "min", "(", "center_x", "+", "target_w", "//", "2", ",", "img_w", ")", "\n", "y0", "=", "max", "(", "0", ",", "center_y", "-", "target_h", "//", "2", ")", "\n", "y1", "=", "min", "(", "center_y", "+", "target_h", "//", "2", ",", "img_h", ")", "\n", "patch", "=", "np", ".", "array", "(", "(", "int", "(", "x0", ")", ",", "int", "(", "y0", ")", ",", "int", "(", "x1", ")", ",", "int", "(", "y1", ")", ")", ")", "\n", "\n", "left", ",", "right", "=", "center_x", "-", "x0", ",", "x1", "-", "center_x", "\n", "top", ",", "bottom", "=", "center_y", "-", "y0", ",", "y1", "-", "center_y", "\n", "\n", "cropped_center_y", ",", "cropped_center_x", "=", "target_h", "//", "2", ",", "target_w", "//", "2", "\n", "cropped_img", "=", "np", ".", "zeros", "(", "(", "target_h", ",", "target_w", ",", "img_c", ")", ",", "dtype", "=", "image", ".", "dtype", ")", "\n", "for", "i", "in", "range", "(", "img_c", ")", ":", "\n", "            ", "cropped_img", "[", ":", ",", ":", ",", "i", "]", "+=", "self", ".", "mean", "[", "i", "]", "\n", "", "y_slice", "=", "slice", "(", "cropped_center_y", "-", "top", ",", "cropped_center_y", "+", "bottom", ")", "\n", "x_slice", "=", "slice", "(", "cropped_center_x", "-", "left", ",", "cropped_center_x", "+", "right", ")", "\n", "cropped_img", "[", "y_slice", ",", "x_slice", ",", ":", "]", "=", "image", "[", "y0", ":", "y1", ",", "x0", ":", "x1", ",", ":", "]", "\n", "\n", "border", "=", "np", ".", "array", "(", "[", "\n", "cropped_center_y", "-", "top", ",", "cropped_center_y", "+", "bottom", ",", "\n", "cropped_center_x", "-", "left", ",", "cropped_center_x", "+", "right", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "return", "cropped_img", ",", "border", ",", "patch", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._train_aug": [[1410, 1476], ["numpy.random.choice", "int", "int", "transforms.RandomCenterCropPad._get_border", "transforms.RandomCenterCropPad._get_border", "range", "numpy.random.randint", "numpy.random.randint", "transforms.RandomCenterCropPad._crop_image_and_paste", "transforms.RandomCenterCropPad._filter_boxes", "results.get", "results.get", "transforms.RandomCenterCropPad._filter_boxes", "numpy.clip", "numpy.clip", "NotImplementedError", "transforms.RandomCenterCropPad.any", "len", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._get_border", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._get_border", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._crop_image_and_paste", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._filter_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._filter_boxes"], ["", "def", "_train_aug", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Random crop and around padding the original image.\n\n        Args:\n            results (dict): Image infomations in the augment pipeline.\n\n        Returns:\n            results (dict): The updated dict.\n        \"\"\"", "\n", "img", "=", "results", "[", "'img'", "]", "\n", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "boxes", "=", "results", "[", "'gt_bboxes'", "]", "\n", "while", "True", ":", "\n", "            ", "scale", "=", "random", ".", "choice", "(", "self", ".", "ratios", ")", "\n", "new_h", "=", "int", "(", "self", ".", "crop_size", "[", "0", "]", "*", "scale", ")", "\n", "new_w", "=", "int", "(", "self", ".", "crop_size", "[", "1", "]", "*", "scale", ")", "\n", "h_border", "=", "self", ".", "_get_border", "(", "self", ".", "border", ",", "h", ")", "\n", "w_border", "=", "self", ".", "_get_border", "(", "self", ".", "border", ",", "w", ")", "\n", "\n", "for", "i", "in", "range", "(", "50", ")", ":", "\n", "                ", "center_x", "=", "random", ".", "randint", "(", "low", "=", "w_border", ",", "high", "=", "w", "-", "w_border", ")", "\n", "center_y", "=", "random", ".", "randint", "(", "low", "=", "h_border", ",", "high", "=", "h", "-", "h_border", ")", "\n", "\n", "cropped_img", ",", "border", ",", "patch", "=", "self", ".", "_crop_image_and_paste", "(", "\n", "img", ",", "[", "center_y", ",", "center_x", "]", ",", "[", "new_h", ",", "new_w", "]", ")", "\n", "\n", "mask", "=", "self", ".", "_filter_boxes", "(", "patch", ",", "boxes", ")", "\n", "# if image do not have valid bbox, any crop patch is valid.", "\n", "if", "not", "mask", ".", "any", "(", ")", "and", "len", "(", "boxes", ")", ">", "0", ":", "\n", "                    ", "continue", "\n", "\n", "", "results", "[", "'img'", "]", "=", "cropped_img", "\n", "results", "[", "'img_shape'", "]", "=", "cropped_img", ".", "shape", "\n", "results", "[", "'pad_shape'", "]", "=", "cropped_img", ".", "shape", "\n", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "patch", "\n", "\n", "left_w", ",", "top_h", "=", "center_x", "-", "x0", ",", "center_y", "-", "y0", "\n", "cropped_center_x", ",", "cropped_center_y", "=", "new_w", "//", "2", ",", "new_h", "//", "2", "\n", "\n", "# crop bboxes accordingly and clip to the image boundary", "\n", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "                    ", "mask", "=", "self", ".", "_filter_boxes", "(", "patch", ",", "results", "[", "key", "]", ")", "\n", "bboxes", "=", "results", "[", "key", "]", "[", "mask", "]", "\n", "bboxes", "[", ":", ",", "0", ":", "4", ":", "2", "]", "+=", "cropped_center_x", "-", "left_w", "-", "x0", "\n", "bboxes", "[", ":", ",", "1", ":", "4", ":", "2", "]", "+=", "cropped_center_y", "-", "top_h", "-", "y0", "\n", "bboxes", "[", ":", ",", "0", ":", "4", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "0", ":", "4", ":", "2", "]", ",", "0", ",", "new_w", ")", "\n", "bboxes", "[", ":", ",", "1", ":", "4", ":", "2", "]", "=", "np", ".", "clip", "(", "bboxes", "[", ":", ",", "1", ":", "4", ":", "2", "]", ",", "0", ",", "new_h", ")", "\n", "keep", "=", "(", "bboxes", "[", ":", ",", "2", "]", ">", "bboxes", "[", ":", ",", "0", "]", ")", "&", "(", "\n", "bboxes", "[", ":", ",", "3", "]", ">", "bboxes", "[", ":", ",", "1", "]", ")", "\n", "bboxes", "=", "bboxes", "[", "keep", "]", "\n", "results", "[", "key", "]", "=", "bboxes", "\n", "if", "key", "in", "[", "'gt_bboxes'", "]", ":", "\n", "                        ", "if", "'gt_labels'", "in", "results", ":", "\n", "                            ", "labels", "=", "results", "[", "'gt_labels'", "]", "[", "mask", "]", "\n", "labels", "=", "labels", "[", "keep", "]", "\n", "results", "[", "'gt_labels'", "]", "=", "labels", "\n", "", "if", "'gt_masks'", "in", "results", ":", "\n", "                            ", "raise", "NotImplementedError", "(", "\n", "'RandomCenterCropPad only supports bbox.'", ")", "\n", "\n", "# crop semantic seg", "\n", "", "", "", "for", "key", "in", "results", ".", "get", "(", "'seg_fields'", ",", "[", "]", ")", ":", "\n", "                    ", "raise", "NotImplementedError", "(", "\n", "'RandomCenterCropPad only supports bbox.'", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._test_aug": [[1477, 1509], ["transforms.RandomCenterCropPad._crop_image_and_paste", "NotImplementedError", "int", "int", "numpy.ceil", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._crop_image_and_paste"], ["", "", "", "def", "_test_aug", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Around padding the original image without cropping.\n\n        The padding mode and value are from ``test_pad_mode``.\n\n        Args:\n            results (dict): Image infomations in the augment pipeline.\n\n        Returns:\n            results (dict): The updated dict.\n        \"\"\"", "\n", "img", "=", "results", "[", "'img'", "]", "\n", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "if", "self", ".", "test_pad_mode", "[", "0", "]", "in", "[", "'logical_or'", "]", ":", "\n", "            ", "target_h", "=", "h", "|", "self", ".", "test_pad_mode", "[", "1", "]", "\n", "target_w", "=", "w", "|", "self", ".", "test_pad_mode", "[", "1", "]", "\n", "", "elif", "self", ".", "test_pad_mode", "[", "0", "]", "in", "[", "'size_divisor'", "]", ":", "\n", "            ", "divisor", "=", "self", ".", "test_pad_mode", "[", "1", "]", "\n", "target_h", "=", "int", "(", "np", ".", "ceil", "(", "h", "/", "divisor", ")", ")", "*", "divisor", "\n", "target_w", "=", "int", "(", "np", ".", "ceil", "(", "w", "/", "divisor", ")", ")", "*", "divisor", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "'RandomCenterCropPad only support two testing pad mode:'", "\n", "'logical-or and size_divisor.'", ")", "\n", "\n", "", "cropped_img", ",", "border", ",", "_", "=", "self", ".", "_crop_image_and_paste", "(", "\n", "img", ",", "[", "h", "//", "2", ",", "w", "//", "2", "]", ",", "[", "target_h", ",", "target_w", "]", ")", "\n", "results", "[", "'img'", "]", "=", "cropped_img", "\n", "results", "[", "'pad_shape'", "]", "=", "cropped_img", ".", "shape", "\n", "results", "[", "'border'", "]", "=", "border", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad.__call__": [[1510, 1521], ["len", "transforms.RandomCenterCropPad._test_aug", "transforms.RandomCenterCropPad._train_aug"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._test_aug", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad._train_aug"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "float32", ",", "(", "\n", "'RandomCenterCropPad needs the input image of dtype np.float32,'", "\n", "' please set \"to_float32=True\" in \"LoadImageFromFile\" pipeline'", ")", "\n", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "assert", "c", "==", "len", "(", "self", ".", "mean", ")", "\n", "if", "self", ".", "test_mode", ":", "\n", "            ", "return", "self", ".", "_test_aug", "(", "results", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_train_aug", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.RandomCenterCropPad.__repr__": [[1522, 1533], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(crop_size={self.crop_size}, '", "\n", "repr_str", "+=", "f'ratios={self.ratios}, '", "\n", "repr_str", "+=", "f'border={self.border}, '", "\n", "repr_str", "+=", "f'mean={self.input_mean}, '", "\n", "repr_str", "+=", "f'std={self.input_std}, '", "\n", "repr_str", "+=", "f'to_rgb={self.to_rgb}, '", "\n", "repr_str", "+=", "f'test_mode={self.test_mode}, '", "\n", "repr_str", "+=", "f'test_pad_mode={self.test_pad_mode})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.CutOut.__init__": [[1559, 1579], ["isinstance", "isinstance", "isinstance", "isinstance", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "n_holes", ",", "\n", "cutout_shape", "=", "None", ",", "\n", "cutout_ratio", "=", "None", ",", "\n", "fill_in", "=", "(", "0", ",", "0", ",", "0", ")", ")", ":", "\n", "\n", "        ", "assert", "(", "cutout_shape", "is", "None", ")", "^", "(", "cutout_ratio", "is", "None", ")", ",", "'Either cutout_shape or cutout_ratio should be specified.'", "\n", "assert", "(", "isinstance", "(", "cutout_shape", ",", "(", "list", ",", "tuple", ")", ")", "\n", "or", "isinstance", "(", "cutout_ratio", ",", "(", "list", ",", "tuple", ")", ")", ")", "\n", "if", "isinstance", "(", "n_holes", ",", "tuple", ")", ":", "\n", "            ", "assert", "len", "(", "n_holes", ")", "==", "2", "and", "0", "<=", "n_holes", "[", "0", "]", "<", "n_holes", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "n_holes", "=", "(", "n_holes", ",", "n_holes", ")", "\n", "", "self", ".", "n_holes", "=", "n_holes", "\n", "self", ".", "fill_in", "=", "fill_in", "\n", "self", ".", "with_ratio", "=", "cutout_ratio", "is", "not", "None", "\n", "self", ".", "candidates", "=", "cutout_ratio", "if", "self", ".", "with_ratio", "else", "cutout_shape", "\n", "if", "not", "isinstance", "(", "self", ".", "candidates", ",", "list", ")", ":", "\n", "            ", "self", ".", "candidates", "=", "[", "self", ".", "candidates", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.CutOut.__call__": [[1580, 1599], ["numpy.random.randint", "range", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.clip", "numpy.clip", "len", "int", "int"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to drop some regions of image.\"\"\"", "\n", "h", ",", "w", ",", "c", "=", "results", "[", "'img'", "]", ".", "shape", "\n", "n_holes", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "n_holes", "[", "0", "]", ",", "self", ".", "n_holes", "[", "1", "]", "+", "1", ")", "\n", "for", "_", "in", "range", "(", "n_holes", ")", ":", "\n", "            ", "x1", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "w", ")", "\n", "y1", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "h", ")", "\n", "index", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "candidates", ")", ")", "\n", "if", "not", "self", ".", "with_ratio", ":", "\n", "                ", "cutout_w", ",", "cutout_h", "=", "self", ".", "candidates", "[", "index", "]", "\n", "", "else", ":", "\n", "                ", "cutout_w", "=", "int", "(", "self", ".", "candidates", "[", "index", "]", "[", "0", "]", "*", "w", ")", "\n", "cutout_h", "=", "int", "(", "self", ".", "candidates", "[", "index", "]", "[", "1", "]", "*", "h", ")", "\n", "\n", "", "x2", "=", "np", ".", "clip", "(", "x1", "+", "cutout_w", ",", "0", ",", "w", ")", "\n", "y2", "=", "np", ".", "clip", "(", "y1", "+", "cutout_h", ",", "0", ",", "h", ")", "\n", "results", "[", "'img'", "]", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", ":", "]", "=", "self", ".", "fill_in", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.transforms.CutOut.__repr__": [[1600, 1607], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(n_holes={self.n_holes}, '", "\n", "repr_str", "+=", "(", "f'cutout_ratio={self.candidates}, '", "if", "self", ".", "with_ratio", "\n", "else", "f'cutout_shape={self.candidates}, '", ")", "\n", "repr_str", "+=", "f'fill_in={self.fill_in})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost.__init__": [[15, 35], ["instaboost.InstaBoostConfig", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "action_candidate", "=", "(", "'normal'", ",", "'horizontal'", ",", "'skip'", ")", ",", "\n", "action_prob", "=", "(", "1", ",", "0", ",", "0", ")", ",", "\n", "scale", "=", "(", "0.8", ",", "1.2", ")", ",", "\n", "dx", "=", "15", ",", "\n", "dy", "=", "15", ",", "\n", "theta", "=", "(", "-", "1", ",", "1", ")", ",", "\n", "color_prob", "=", "0.5", ",", "\n", "hflag", "=", "False", ",", "\n", "aug_ratio", "=", "0.5", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "instaboostfast", "as", "instaboost", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\n", "'Please run \"pip install instaboostfast\" '", "\n", "'to install instaboostfast first for instaboost augmentation.'", ")", "\n", "", "self", ".", "cfg", "=", "instaboost", ".", "InstaBoostConfig", "(", "action_candidate", ",", "action_prob", ",", "\n", "scale", ",", "dx", ",", "dy", ",", "theta", ",", "\n", "color_prob", ",", "hflag", ")", "\n", "self", ".", "aug_ratio", "=", "aug_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost._load_anns": [[36, 57], ["len", "range", "anns.append"], "methods", ["None"], ["", "def", "_load_anns", "(", "self", ",", "results", ")", ":", "\n", "        ", "labels", "=", "results", "[", "'ann_info'", "]", "[", "'labels'", "]", "\n", "masks", "=", "results", "[", "'ann_info'", "]", "[", "'masks'", "]", "\n", "bboxes", "=", "results", "[", "'ann_info'", "]", "[", "'bboxes'", "]", "\n", "n", "=", "len", "(", "labels", ")", "\n", "\n", "anns", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "label", "=", "labels", "[", "i", "]", "\n", "bbox", "=", "bboxes", "[", "i", "]", "\n", "mask", "=", "masks", "[", "i", "]", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bbox", "\n", "# assert (x2 - x1) >= 1 and (y2 - y1) >= 1", "\n", "bbox", "=", "[", "x1", ",", "y1", ",", "x2", "-", "x1", ",", "y2", "-", "y1", "]", "\n", "anns", ".", "append", "(", "{", "\n", "'category_id'", ":", "label", ",", "\n", "'segmentation'", ":", "mask", ",", "\n", "'bbox'", ":", "bbox", "\n", "}", ")", "\n", "\n", "", "return", "anns", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost._parse_anns": [[58, 78], ["numpy.array", "numpy.array", "numpy.array.append", "numpy.array.append", "gt_masks_ann.append"], "methods", ["None"], ["", "def", "_parse_anns", "(", "self", ",", "results", ",", "anns", ",", "img", ")", ":", "\n", "        ", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_masks_ann", "=", "[", "]", "\n", "for", "ann", "in", "anns", ":", "\n", "            ", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "# TODO: more essential bug need to be fixed in instaboost", "\n", "if", "w", "<=", "0", "or", "h", "<=", "0", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", "\n", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_labels", ".", "append", "(", "ann", "[", "'category_id'", "]", ")", "\n", "gt_masks_ann", ".", "append", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "results", "[", "'ann_info'", "]", "[", "'labels'", "]", "=", "gt_labels", "\n", "results", "[", "'ann_info'", "]", "[", "'bboxes'", "]", "=", "gt_bboxes", "\n", "results", "[", "'ann_info'", "]", "[", "'masks'", "]", "=", "gt_masks_ann", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost.__call__": [[79, 94], ["instaboost.InstaBoost._load_anns", "numpy.random.choice", "instaboost.InstaBoost._parse_anns", "instaboost.get_new_data", "img.astype", "img.astype", "ImportError"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost._load_anns", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost._parse_anns"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "\n", "orig_type", "=", "img", ".", "dtype", "\n", "anns", "=", "self", ".", "_load_anns", "(", "results", ")", "\n", "if", "np", ".", "random", ".", "choice", "(", "[", "0", ",", "1", "]", ",", "p", "=", "[", "1", "-", "self", ".", "aug_ratio", ",", "self", ".", "aug_ratio", "]", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "import", "instaboostfast", "as", "instaboost", "\n", "", "except", "ImportError", ":", "\n", "                ", "raise", "ImportError", "(", "'Please run \"pip install instaboostfast\" '", "\n", "'to install instaboostfast first.'", ")", "\n", "", "anns", ",", "img", "=", "instaboost", ".", "get_new_data", "(", "\n", "anns", ",", "img", ".", "astype", "(", "np", ".", "uint8", ")", ",", "self", ".", "cfg", ",", "background", "=", "None", ")", "\n", "\n", "", "results", "=", "self", ".", "_parse_anns", "(", "results", ",", "anns", ",", "img", ".", "astype", "(", "orig_type", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.instaboost.InstaBoost.__repr__": [[95, 99], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(cfg={self.cfg}, aug_ratio={self.aug_ratio})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.auto_augment.AutoAugment.__init__": [[53, 66], ["copy.deepcopy", "isinstance", "compose.Compose", "len", "isinstance", "len", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "policies", ")", ":", "\n", "        ", "assert", "isinstance", "(", "policies", ",", "list", ")", "and", "len", "(", "policies", ")", ">", "0", ",", "'Policies must be a non-empty list.'", "\n", "for", "policy", "in", "policies", ":", "\n", "            ", "assert", "isinstance", "(", "policy", ",", "list", ")", "and", "len", "(", "policy", ")", ">", "0", ",", "'Each policy in policies must be a non-empty list.'", "\n", "for", "augment", "in", "policy", ":", "\n", "                ", "assert", "isinstance", "(", "augment", ",", "dict", ")", "and", "'type'", "in", "augment", ",", "'Each specific augmentation must be a dict with key'", "' \"type\".'", "\n", "\n", "", "", "self", ".", "policies", "=", "copy", ".", "deepcopy", "(", "policies", ")", "\n", "self", ".", "transforms", "=", "[", "Compose", "(", "policy", ")", "for", "policy", "in", "self", ".", "policies", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.auto_augment.AutoAugment.__call__": [[67, 70], ["numpy.random.choice", "numpy.random.choice."], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "transform", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "transforms", ")", "\n", "return", "transform", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.auto_augment.AutoAugment.__repr__": [[71, 73], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'{self.__class__.__name__}(policies={self.policies}'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.test_time_aug.MultiScaleFlipAug.__init__": [[52, 82], ["compose.Compose", "mmcv.is_list_of", "mmcv.is_list_of", "isinstance", "warnings.warn", "warnings.warn", "isinstance", "isinstance", "any"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "transforms", ",", "\n", "img_scale", "=", "None", ",", "\n", "scale_factor", "=", "None", ",", "\n", "flip", "=", "False", ",", "\n", "flip_direction", "=", "'horizontal'", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "Compose", "(", "transforms", ")", "\n", "assert", "(", "img_scale", "is", "None", ")", "^", "(", "scale_factor", "is", "None", ")", ",", "(", "\n", "'Must have but only one variable can be setted'", ")", "\n", "if", "img_scale", "is", "not", "None", ":", "\n", "            ", "self", ".", "img_scale", "=", "img_scale", "if", "isinstance", "(", "img_scale", ",", "\n", "list", ")", "else", "[", "img_scale", "]", "\n", "self", ".", "scale_key", "=", "'scale'", "\n", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "img_scale", ",", "tuple", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "img_scale", "=", "scale_factor", "if", "isinstance", "(", "\n", "scale_factor", ",", "list", ")", "else", "[", "scale_factor", "]", "\n", "self", ".", "scale_key", "=", "'scale_factor'", "\n", "\n", "", "self", ".", "flip", "=", "flip", "\n", "self", ".", "flip_direction", "=", "flip_direction", "if", "isinstance", "(", "\n", "flip_direction", ",", "list", ")", "else", "[", "flip_direction", "]", "\n", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "flip_direction", ",", "str", ")", "\n", "if", "not", "self", ".", "flip", "and", "self", ".", "flip_direction", "!=", "[", "'horizontal'", "]", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "'flip_direction has no effect when flip is set to False'", ")", "\n", "", "if", "(", "self", ".", "flip", "\n", "and", "not", "any", "(", "[", "t", "[", "'type'", "]", "==", "'RandomFlip'", "for", "t", "in", "transforms", "]", ")", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "'flip has no effect when RandomFlip is not in transforms'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.test_time_aug.MultiScaleFlipAug.__call__": [[83, 113], ["test_time_aug.MultiScaleFlipAug.items", "results.copy", "test_time_aug.MultiScaleFlipAug.transforms", "aug_data.append", "aug_data_dict[].append"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to apply test time augment transforms on results.\n\n        Args:\n            results (dict): Result dict contains the data to transform.\n\n        Returns:\n           dict[str: list]: The augmented data, where each value is wrapped\n               into a list.\n        \"\"\"", "\n", "\n", "aug_data", "=", "[", "]", "\n", "flip_args", "=", "[", "(", "False", ",", "None", ")", "]", "\n", "if", "self", ".", "flip", ":", "\n", "            ", "flip_args", "+=", "[", "(", "True", ",", "direction", ")", "\n", "for", "direction", "in", "self", ".", "flip_direction", "]", "\n", "", "for", "scale", "in", "self", ".", "img_scale", ":", "\n", "            ", "for", "flip", ",", "direction", "in", "flip_args", ":", "\n", "                ", "_results", "=", "results", ".", "copy", "(", ")", "\n", "_results", "[", "self", ".", "scale_key", "]", "=", "scale", "\n", "_results", "[", "'flip'", "]", "=", "flip", "\n", "_results", "[", "'flip_direction'", "]", "=", "direction", "\n", "data", "=", "self", ".", "transforms", "(", "_results", ")", "\n", "aug_data", ".", "append", "(", "data", ")", "\n", "# list of dict to dict of list", "\n", "", "", "aug_data_dict", "=", "{", "key", ":", "[", "]", "for", "key", "in", "aug_data", "[", "0", "]", "}", "\n", "for", "data", "in", "aug_data", ":", "\n", "            ", "for", "key", ",", "val", "in", "data", ".", "items", "(", ")", ":", "\n", "                ", "aug_data_dict", "[", "key", "]", ".", "append", "(", "val", ")", "\n", "", "", "return", "aug_data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.test_time_aug.MultiScaleFlipAug.__repr__": [[114, 120], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transforms={self.transforms}, '", "\n", "repr_str", "+=", "f'img_scale={self.img_scale}, flip={self.flip})'", "\n", "repr_str", "+=", "f'flip_direction={self.flip_direction}'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadImageFromFile.__init__": [[31, 39], ["dict", "file_client_args.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "to_float32", "=", "False", ",", "\n", "color_type", "=", "'color'", ",", "\n", "file_client_args", "=", "dict", "(", "backend", "=", "'disk'", ")", ")", ":", "\n", "        ", "self", ".", "to_float32", "=", "to_float32", "\n", "self", ".", "color_type", "=", "color_type", "\n", "self", ".", "file_client_args", "=", "file_client_args", ".", "copy", "(", ")", "\n", "self", ".", "file_client", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadImageFromFile.__call__": [[40, 71], ["loading.LoadImageFromFile.file_client.get", "mmcv.imfrombytes", "mmcv.FileClient", "os.join", "img.astype.astype.astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call functions to load image and get image meta information.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded image and meta information.\n        \"\"\"", "\n", "\n", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "mmcv", ".", "FileClient", "(", "**", "self", ".", "file_client_args", ")", "\n", "\n", "", "if", "results", "[", "'img_prefix'", "]", "is", "not", "None", ":", "\n", "            ", "filename", "=", "osp", ".", "join", "(", "results", "[", "'img_prefix'", "]", ",", "\n", "results", "[", "'img_info'", "]", "[", "'filename'", "]", ")", "\n", "", "else", ":", "\n", "            ", "filename", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "\n", "", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "filename", ")", "\n", "img", "=", "mmcv", ".", "imfrombytes", "(", "img_bytes", ",", "flag", "=", "self", ".", "color_type", ")", "\n", "if", "self", ".", "to_float32", ":", "\n", "            ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "results", "[", "'filename'", "]", "=", "filename", "\n", "results", "[", "'ori_filename'", "]", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadImageFromFile.__repr__": [[72, 78], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "(", "f'{self.__class__.__name__}('", "\n", "f'to_float32={self.to_float32}, '", "\n", "f\"color_type='{self.color_type}', \"", "\n", "f'file_client_args={self.file_client_args})'", ")", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadMultiChannelImageFromFiles.__init__": [[101, 109], ["dict", "file_client_args.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "to_float32", "=", "False", ",", "\n", "color_type", "=", "'unchanged'", ",", "\n", "file_client_args", "=", "dict", "(", "backend", "=", "'disk'", ")", ")", ":", "\n", "        ", "self", ".", "to_float32", "=", "to_float32", "\n", "self", ".", "color_type", "=", "color_type", "\n", "self", ".", "file_client_args", "=", "file_client_args", ".", "copy", "(", ")", "\n", "self", ".", "file_client", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadMultiChannelImageFromFiles.__call__": [[110, 154], ["numpy.stack", "dict", "mmcv.FileClient", "loading.LoadMultiChannelImageFromFiles.file_client.get", "img.astype.astype.append", "img.astype.astype.astype", "os.join", "mmcv.imfrombytes", "len", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call functions to load multiple images and get images meta\n        information.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded images and meta information.\n        \"\"\"", "\n", "\n", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "mmcv", ".", "FileClient", "(", "**", "self", ".", "file_client_args", ")", "\n", "\n", "", "if", "results", "[", "'img_prefix'", "]", "is", "not", "None", ":", "\n", "            ", "filename", "=", "[", "\n", "osp", ".", "join", "(", "results", "[", "'img_prefix'", "]", ",", "fname", ")", "\n", "for", "fname", "in", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "]", "\n", "", "else", ":", "\n", "            ", "filename", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "\n", "", "img", "=", "[", "]", "\n", "for", "name", "in", "filename", ":", "\n", "            ", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "name", ")", "\n", "img", ".", "append", "(", "mmcv", ".", "imfrombytes", "(", "img_bytes", ",", "flag", "=", "self", ".", "color_type", ")", ")", "\n", "", "img", "=", "np", ".", "stack", "(", "img", ",", "axis", "=", "-", "1", ")", "\n", "if", "self", ".", "to_float32", ":", "\n", "            ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "results", "[", "'filename'", "]", "=", "filename", "\n", "results", "[", "'ori_filename'", "]", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "num_channels", "=", "1", "if", "len", "(", "img", ".", "shape", ")", "<", "3", "else", "img", ".", "shape", "[", "2", "]", "\n", "results", "[", "'img_norm_cfg'", "]", "=", "dict", "(", "\n", "mean", "=", "np", ".", "zeros", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "std", "=", "np", ".", "ones", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "to_rgb", "=", "False", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadMultiChannelImageFromFiles.__repr__": [[155, 161], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "(", "f'{self.__class__.__name__}('", "\n", "f'to_float32={self.to_float32}, '", "\n", "f\"color_type='{self.color_type}', \"", "\n", "f'file_client_args={self.file_client_args})'", ")", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations.__init__": [[183, 199], ["dict", "file_client_args.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "with_bbox", "=", "True", ",", "\n", "with_label", "=", "True", ",", "\n", "with_mask", "=", "False", ",", "\n", "with_seg", "=", "False", ",", "\n", "map_seg_cats", "=", "True", ",", "\n", "poly2mask", "=", "True", ",", "\n", "file_client_args", "=", "dict", "(", "backend", "=", "'disk'", ")", ")", ":", "\n", "        ", "self", ".", "with_bbox", "=", "with_bbox", "\n", "self", ".", "with_label", "=", "with_label", "\n", "self", ".", "with_mask", "=", "with_mask", "\n", "self", ".", "with_seg", "=", "with_seg", "\n", "self", ".", "map_seg_cats", "=", "map_seg_cats", "\n", "self", ".", "poly2mask", "=", "poly2mask", "\n", "self", ".", "file_client_args", "=", "file_client_args", ".", "copy", "(", ")", "\n", "self", ".", "file_client", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_bboxes": [[200, 219], ["ann_info[].copy", "ann_info.get", "results[].append", "ann_info.get.copy", "results[].append"], "methods", ["None"], ["", "def", "_load_bboxes", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load bounding box annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded bounding box annotations.\n        \"\"\"", "\n", "\n", "ann_info", "=", "results", "[", "'ann_info'", "]", "\n", "results", "[", "'gt_bboxes'", "]", "=", "ann_info", "[", "'bboxes'", "]", ".", "copy", "(", ")", "\n", "\n", "gt_bboxes_ignore", "=", "ann_info", ".", "get", "(", "'bboxes_ignore'", ",", "None", ")", "\n", "if", "gt_bboxes_ignore", "is", "not", "None", ":", "\n", "            ", "results", "[", "'gt_bboxes_ignore'", "]", "=", "gt_bboxes_ignore", ".", "copy", "(", ")", "\n", "results", "[", "'bbox_fields'", "]", ".", "append", "(", "'gt_bboxes_ignore'", ")", "\n", "", "results", "[", "'bbox_fields'", "]", ".", "append", "(", "'gt_bboxes'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_labels": [[220, 232], ["[].copy"], "methods", ["None"], ["", "def", "_load_labels", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load label annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded label annotations.\n        \"\"\"", "\n", "\n", "results", "[", "'gt_labels'", "]", "=", "results", "[", "'ann_info'", "]", "[", "'labels'", "]", ".", "copy", "(", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._poly2mask": [[233, 259], ["isinstance", "pycocotools.decode", "pycocotools.frPyObjects", "pycocotools.merge", "isinstance", "pycocotools.frPyObjects"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_poly2mask", "(", "self", ",", "mask_ann", ",", "img_h", ",", "img_w", ")", ":", "\n", "        ", "\"\"\"Private function to convert masks represented with polygon to\n        bitmaps.\n\n        Args:\n            mask_ann (list | dict): Polygon mask annotation input.\n            img_h (int): The height of output mask.\n            img_w (int): The width of output mask.\n\n        Returns:\n            numpy.ndarray: The decode bitmap mask of shape (img_h, img_w).\n        \"\"\"", "\n", "\n", "if", "isinstance", "(", "mask_ann", ",", "list", ")", ":", "\n", "# polygon -- a single object might consist of multiple parts", "\n", "# we merge all parts into one mask rle code", "\n", "            ", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "mask_ann", ",", "img_h", ",", "img_w", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "isinstance", "(", "mask_ann", "[", "'counts'", "]", ",", "list", ")", ":", "\n", "# uncompressed RLE", "\n", "            ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "mask_ann", ",", "img_h", ",", "img_w", ")", "\n", "", "else", ":", "\n", "# rle", "\n", "            ", "rle", "=", "mask_ann", "\n", "", "mask", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations.process_polygons": [[260, 276], ["numpy.array", "valid_polygons.append", "len", "len"], "methods", ["None"], ["", "def", "process_polygons", "(", "self", ",", "polygons", ")", ":", "\n", "        ", "\"\"\"Convert polygons to list of ndarray and filter invalid polygons.\n\n        Args:\n            polygons (list[list]): Polygons of one instance.\n\n        Returns:\n            list[numpy.ndarray]: Processed polygons.\n        \"\"\"", "\n", "\n", "polygons", "=", "[", "np", ".", "array", "(", "p", ")", "for", "p", "in", "polygons", "]", "\n", "valid_polygons", "=", "[", "]", "\n", "for", "polygon", "in", "polygons", ":", "\n", "            ", "if", "len", "(", "polygon", ")", "%", "2", "==", "0", "and", "len", "(", "polygon", ")", ">=", "6", ":", "\n", "                ", "valid_polygons", ".", "append", "(", "polygon", ")", "\n", "", "", "return", "valid_polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_masks": [[277, 301], ["results[].append", "mmdet.core.BitmapMasks", "mmdet.core.PolygonMasks", "loading.LoadAnnotations._poly2mask", "loading.LoadAnnotations.process_polygons"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._poly2mask", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations.process_polygons"], ["", "def", "_load_masks", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load mask annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded mask annotations.\n                If ``self.poly2mask`` is set ``True``, `gt_mask` will contain\n                :obj:`PolygonMasks`. Otherwise, :obj:`BitmapMasks` is used.\n        \"\"\"", "\n", "\n", "h", ",", "w", "=", "results", "[", "'img_info'", "]", "[", "'height'", "]", ",", "results", "[", "'img_info'", "]", "[", "'width'", "]", "\n", "gt_masks", "=", "results", "[", "'ann_info'", "]", "[", "'masks'", "]", "\n", "if", "self", ".", "poly2mask", ":", "\n", "            ", "gt_masks", "=", "BitmapMasks", "(", "\n", "[", "self", ".", "_poly2mask", "(", "mask", ",", "h", ",", "w", ")", "for", "mask", "in", "gt_masks", "]", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "gt_masks", "=", "PolygonMasks", "(", "\n", "[", "self", ".", "process_polygons", "(", "polygons", ")", "for", "polygons", "in", "gt_masks", "]", ",", "h", ",", "\n", "w", ")", "\n", "", "results", "[", "'gt_masks'", "]", "=", "gt_masks", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "'gt_masks'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._map_seg_cats": [[302, 320], ["numpy.zeros", "seg2label.items", "len", "numpy.all", "numpy.array().reshape", "numpy.array"], "methods", ["None"], ["", "def", "_map_seg_cats", "(", "self", ",", "results", ")", ":", "\n", "        ", "if", "self", ".", "with_seg", "and", "self", ".", "map_seg_cats", ":", "\n", "            ", "gt_seg", "=", "results", "[", "'gt_semantic_seg'", "]", "\n", "shape", "=", "gt_seg", ".", "shape", "\n", "seg2label", "=", "results", "[", "'ann_info'", "]", "[", "'seg2label'", "]", "\n", "seg_labels", "=", "np", ".", "zeros", "(", "shape", "[", ":", "2", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "seg_cat", ",", "label", "in", "seg2label", ".", "items", "(", ")", ":", "\n", "                ", "if", "len", "(", "shape", ")", "==", "3", ":", "\n", "                    ", "m", "=", "np", ".", "all", "(", "\n", "gt_seg", "==", "np", ".", "array", "(", "seg_cat", ")", ".", "reshape", "(", "1", ",", "1", ",", "3", ")", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                    ", "m", "=", "gt_seg", "==", "seg_cat", "\n", "", "seg_labels", "[", "m", "]", "=", "label", "\n", "# add ignore label 255, and other labels are 0-based", "\n", "", "seg_labels", "+=", "255", "\n", "gt_seg", "=", "seg_labels", "\n", "results", "[", "'gt_semantic_seg'", "]", "=", "gt_seg", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_semantic_seg": [[321, 342], ["os.join", "loading.LoadAnnotations.file_client.get", "mmcv.imfrombytes().squeeze", "loading.LoadAnnotations._map_seg_cats", "results[].append", "mmcv.FileClient", "mmcv.imfrombytes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._map_seg_cats"], ["", "def", "_load_semantic_seg", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load semantic segmentation annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`dataset`.\n\n        Returns:\n            dict: The dict contains loaded semantic segmentation annotations.\n        \"\"\"", "\n", "\n", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "mmcv", ".", "FileClient", "(", "**", "self", ".", "file_client_args", ")", "\n", "\n", "", "filename", "=", "osp", ".", "join", "(", "results", "[", "'seg_prefix'", "]", ",", "\n", "results", "[", "'ann_info'", "]", "[", "'seg_map'", "]", ")", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "filename", ")", "\n", "results", "[", "'gt_semantic_seg'", "]", "=", "mmcv", ".", "imfrombytes", "(", "\n", "img_bytes", ",", "flag", "=", "'unchanged'", ")", ".", "squeeze", "(", ")", "\n", "results", "=", "self", ".", "_map_seg_cats", "(", "results", ")", "\n", "results", "[", "'seg_fields'", "]", ".", "append", "(", "'gt_semantic_seg'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations.__call__": [[343, 365], ["loading.LoadAnnotations._load_bboxes", "loading.LoadAnnotations._load_labels", "loading.LoadAnnotations._load_masks", "loading.LoadAnnotations._load_semantic_seg"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_labels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations._load_semantic_seg"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to load multiple types annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded bounding box, label, mask and\n                semantic segmentation annotations.\n        \"\"\"", "\n", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "results", "=", "self", ".", "_load_bboxes", "(", "results", ")", "\n", "if", "results", "is", "None", ":", "\n", "                ", "return", "None", "\n", "", "", "if", "self", ".", "with_label", ":", "\n", "            ", "results", "=", "self", ".", "_load_labels", "(", "results", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "results", "=", "self", ".", "_load_masks", "(", "results", ")", "\n", "", "if", "self", ".", "with_seg", ":", "\n", "            ", "results", "=", "self", ".", "_load_semantic_seg", "(", "results", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadAnnotations.__repr__": [[366, 375], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(with_bbox={self.with_bbox}, '", "\n", "repr_str", "+=", "f'with_label={self.with_label}, '", "\n", "repr_str", "+=", "f'with_mask={self.with_mask}, '", "\n", "repr_str", "+=", "f'with_seg={self.with_seg})'", "\n", "repr_str", "+=", "f'poly2mask={self.poly2mask})'", "\n", "repr_str", "+=", "f'poly2mask={self.file_client_args})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadProposals.__init__": [[388, 390], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_max_proposals", "=", "None", ")", ":", "\n", "        ", "self", ".", "num_max_proposals", "=", "num_max_proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadProposals.__call__": [[391, 416], ["results[].append", "AssertionError", "len", "numpy.array"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to load proposals from file.\n\n        Args:\n            results (dict): Result dict from :obj:`mmdet.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded proposal annotations.\n        \"\"\"", "\n", "\n", "proposals", "=", "results", "[", "'proposals'", "]", "\n", "if", "proposals", ".", "shape", "[", "1", "]", "not", "in", "(", "4", ",", "5", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "'proposals should have shapes (n, 4) or (n, 5), '", "\n", "f'but found {proposals.shape}'", ")", "\n", "", "proposals", "=", "proposals", "[", ":", ",", ":", "4", "]", "\n", "\n", "if", "self", ".", "num_max_proposals", "is", "not", "None", ":", "\n", "            ", "proposals", "=", "proposals", "[", ":", "self", ".", "num_max_proposals", "]", "\n", "\n", "", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "            ", "proposals", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "results", "[", "'proposals'", "]", "=", "proposals", "\n", "results", "[", "'bbox_fields'", "]", ".", "append", "(", "'proposals'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.loading.LoadProposals.__repr__": [[417, 420], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(num_max_proposals={self.num_max_proposals})'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToTensor.__init__": [[44, 46], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToTensor.__call__": [[47, 60], ["formating.to_tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert data in results to :obj:`torch.Tensor`.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data converted\n                to :obj:`torch.Tensor`.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "results", "[", "key", "]", "=", "to_tensor", "(", "results", "[", "key", "]", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToTensor.__repr__": [[61, 63], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ImageToTensor.__init__": [[77, 79], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ImageToTensor.__call__": [[80, 97], ["formating.to_tensor", "len", "numpy.expand_dims", "numpy.expand_dims.transpose"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert image in results to :obj:`torch.Tensor` and\n        transpose the channel order.\n\n        Args:\n            results (dict): Result dict contains the image data to convert.\n\n        Returns:\n            dict: The result dict contains the image converted\n                to :obj:`torch.Tensor` and transposed to (C, H, W) order.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "img", "=", "results", "[", "key", "]", "\n", "if", "len", "(", "img", ".", "shape", ")", "<", "3", ":", "\n", "                ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "-", "1", ")", "\n", "", "results", "[", "key", "]", "=", "to_tensor", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ImageToTensor.__repr__": [[98, 100], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Transpose.__init__": [[111, 114], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ",", "order", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "self", ".", "order", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Transpose.__call__": [[115, 128], ["results[].transpose"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to transpose the channel order of data in results.\n\n        Args:\n            results (dict): Result dict contains the data to transpose.\n\n        Returns:\n            dict: The result dict contains the data transposed to \\\n                ``self.order``.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "transpose", "(", "self", ".", "order", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Transpose.__repr__": [[129, 132], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys}, order={self.order})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToDataContainer.__init__": [[146, 150], ["dict", "dict", "dict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "fields", "=", "(", "dict", "(", "key", "=", "'img'", ",", "stack", "=", "True", ")", ",", "dict", "(", "key", "=", "'gt_bboxes'", ")", ",", "\n", "dict", "(", "key", "=", "'gt_labels'", ")", ")", ")", ":", "\n", "        ", "self", ".", "fields", "=", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToDataContainer.__call__": [[151, 168], ["field.copy.copy.copy", "field.copy.copy.pop", "mmcv.parallel.DataContainer"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert data in results to\n        :obj:`mmcv.DataContainer`.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data converted to \\\n                :obj:`mmcv.DataContainer`.\n        \"\"\"", "\n", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "field", "=", "field", ".", "copy", "(", ")", "\n", "key", "=", "field", ".", "pop", "(", "'key'", ")", "\n", "results", "[", "key", "]", "=", "DC", "(", "results", "[", "key", "]", ",", "**", "field", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.ToDataContainer.__repr__": [[169, 171], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(fields={self.fields})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.DefaultFormatBundle.__call__": [[191, 220], ["formating.DefaultFormatBundle._add_default_meta_keys", "numpy.ascontiguousarray", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "len", "numpy.expand_dims", "numpy.expand_dims.transpose", "formating.to_tensor", "formating.to_tensor", "formating.to_tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.DefaultFormatBundle._add_default_meta_keys", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to transform and format common fields in results.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data that is formatted with \\\n                default bundle.\n        \"\"\"", "\n", "\n", "if", "'img'", "in", "results", ":", "\n", "            ", "img", "=", "results", "[", "'img'", "]", "\n", "# add default meta keys", "\n", "results", "=", "self", ".", "_add_default_meta_keys", "(", "results", ")", "\n", "if", "len", "(", "img", ".", "shape", ")", "<", "3", ":", "\n", "                ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "-", "1", ")", "\n", "", "img", "=", "np", ".", "ascontiguousarray", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "results", "[", "'img'", "]", "=", "DC", "(", "to_tensor", "(", "img", ")", ",", "stack", "=", "True", ")", "\n", "", "for", "key", "in", "[", "'proposals'", ",", "'gt_bboxes'", ",", "'gt_bboxes_ignore'", ",", "'gt_labels'", "]", ":", "\n", "            ", "if", "key", "not", "in", "results", ":", "\n", "                ", "continue", "\n", "", "results", "[", "key", "]", "=", "DC", "(", "to_tensor", "(", "results", "[", "key", "]", ")", ")", "\n", "", "if", "'gt_masks'", "in", "results", ":", "\n", "            ", "results", "[", "'gt_masks'", "]", "=", "DC", "(", "results", "[", "'gt_masks'", "]", ",", "cpu_only", "=", "True", ")", "\n", "", "if", "'gt_semantic_seg'", "in", "results", ":", "\n", "            ", "results", "[", "'gt_semantic_seg'", "]", "=", "DC", "(", "\n", "to_tensor", "(", "results", "[", "'gt_semantic_seg'", "]", "[", "None", ",", "...", "]", ")", ",", "stack", "=", "True", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.DefaultFormatBundle._add_default_meta_keys": [[221, 245], ["results.setdefault", "results.setdefault", "results.setdefault", "dict", "len", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["", "def", "_add_default_meta_keys", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Add default meta keys.\n\n        We set default meta keys including `pad_shape`, `scale_factor` and\n        `img_norm_cfg` to avoid the case where no `Resize`, `Normalize` and\n        `Pad` are implemented during the whole pipeline.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            results (dict): Updated result dict contains the data to convert.\n        \"\"\"", "\n", "img", "=", "results", "[", "'img'", "]", "\n", "results", ".", "setdefault", "(", "'pad_shape'", ",", "img", ".", "shape", ")", "\n", "results", ".", "setdefault", "(", "'scale_factor'", ",", "1.0", ")", "\n", "num_channels", "=", "1", "if", "len", "(", "img", ".", "shape", ")", "<", "3", "else", "img", ".", "shape", "[", "2", "]", "\n", "results", ".", "setdefault", "(", "\n", "'img_norm_cfg'", ",", "\n", "dict", "(", "\n", "mean", "=", "np", ".", "zeros", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "std", "=", "np", ".", "ones", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "to_rgb", "=", "False", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.DefaultFormatBundle.__repr__": [[246, 248], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Collect.__init__": [[290, 297], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "keys", ",", "\n", "meta_keys", "=", "(", "'filename'", ",", "'ori_filename'", ",", "'ori_shape'", ",", "\n", "'img_shape'", ",", "'pad_shape'", ",", "'scale_factor'", ",", "'flip'", ",", "\n", "'flip_direction'", ",", "'img_norm_cfg'", ")", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "self", ".", "meta_keys", "=", "meta_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Collect.__call__": [[298, 320], ["mmcv.parallel.DataContainer"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to collect keys in results. The keys in ``meta_keys``\n        will be converted to :obj:mmcv.DataContainer.\n\n        Args:\n            results (dict): Result dict contains the data to collect.\n\n        Returns:\n            dict: The result dict contains the following keys\n\n                - keys in``self.keys``\n                - ``img_metas``\n        \"\"\"", "\n", "\n", "data", "=", "{", "}", "\n", "img_meta", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "meta_keys", ":", "\n", "            ", "img_meta", "[", "key", "]", "=", "results", "[", "key", "]", "\n", "", "data", "[", "'img_metas'", "]", "=", "DC", "(", "img_meta", ",", "cpu_only", "=", "True", ")", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "data", "[", "key", "]", "=", "results", "[", "key", "]", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.Collect.__repr__": [[321, 324], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys}, meta_keys={self.meta_keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.WrapFieldsToLists.__call__": [[347, 362], ["results.items"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to wrap fields into lists.\n\n        Args:\n            results (dict): Result dict contains the data to wrap.\n\n        Returns:\n            dict: The result dict where value of ``self.keys`` are wrapped \\\n                into list.\n        \"\"\"", "\n", "\n", "# Wrap dict fields into lists", "\n", "for", "key", ",", "val", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "[", "val", "]", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.WrapFieldsToLists.__repr__": [[363, 365], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'{self.__class__.__name__}()'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.formating.to_tensor": [[11, 34], ["isinstance", "isinstance", "torch.from_numpy", "isinstance", "torch.tensor", "isinstance", "mmcv.is_str", "torch.LongTensor", "isinstance", "torch.FloatTensor", "TypeError", "type"], "function", ["None"], ["def", "to_tensor", "(", "data", ")", ":", "\n", "    ", "\"\"\"Convert objects of various python types to :obj:`torch.Tensor`.\n\n    Supported types are: :class:`numpy.ndarray`, :class:`torch.Tensor`,\n    :class:`Sequence`, :class:`int` and :class:`float`.\n\n    Args:\n        data (torch.Tensor | numpy.ndarray | Sequence | int | float): Data to\n            be converted.\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "data", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "data", "\n", "", "elif", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "Sequence", ")", "and", "not", "mmcv", ".", "is_str", "(", "data", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "int", ")", ":", "\n", "        ", "return", "torch", ".", "LongTensor", "(", "[", "data", "]", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "float", ")", ":", "\n", "        ", "return", "torch", ".", "FloatTensor", "(", "[", "data", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'type {type(data)} cannot be converted to tensor.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.compose.Compose.__init__": [[17, 28], ["isinstance", "isinstance", "mmcv.utils.build_from_cfg", "compose.Compose.transforms.append", "callable", "compose.Compose.transforms.append", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "assert", "isinstance", "(", "transforms", ",", "collections", ".", "abc", ".", "Sequence", ")", "\n", "self", ".", "transforms", "=", "[", "]", "\n", "for", "transform", "in", "transforms", ":", "\n", "            ", "if", "isinstance", "(", "transform", ",", "dict", ")", ":", "\n", "                ", "transform", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "self", ".", "transforms", ".", "append", "(", "transform", ")", "\n", "", "elif", "callable", "(", "transform", ")", ":", "\n", "                ", "self", ".", "transforms", ".", "append", "(", "transform", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "'transform must be callable or a dict'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.compose.Compose.__call__": [[29, 44], ["t"], "methods", ["None"], ["", "", "", "def", "__call__", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Call function to apply transforms sequentially.\n\n        Args:\n            data (dict): A result dict contains the data to transform.\n\n        Returns:\n           dict: Transformed data.\n        \"\"\"", "\n", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "data", "=", "t", "(", "data", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "return", "None", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.pipelines.compose.Compose.__repr__": [[45, 52], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "format_string", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "format_string", "+=", "'\\n'", "\n", "format_string", "+=", "f'    {t}'", "\n", "", "format_string", "+=", "'\\n)'", "\n", "return", "format_string", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.LoadImage.__call__": [[53, 75], ["isinstance", "mmcv.imread"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to load images into results.\n\n        Args:\n            results (dict): A result dict contains the file name\n                of the image to be read.\n\n        Returns:\n            dict: ``results`` will be returned containing loaded image.\n        \"\"\"", "\n", "if", "isinstance", "(", "results", "[", "'img'", "]", ",", "str", ")", ":", "\n", "            ", "results", "[", "'filename'", "]", "=", "results", "[", "'img'", "]", "\n", "results", "[", "'ori_filename'", "]", "=", "results", "[", "'img'", "]", "\n", "", "else", ":", "\n", "            ", "results", "[", "'filename'", "]", "=", "None", "\n", "results", "[", "'ori_filename'", "]", "=", "None", "\n", "", "img", "=", "mmcv", ".", "imread", "(", "results", "[", "'img'", "]", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.init_detector": [[15, 48], ["isinstance", "mmdet.models.build_detector", "mmdet.models.build_detector.to", "mmdet.models.build_detector.eval", "mmcv.Config.fromfile", "mmcv.runner.load_checkpoint", "isinstance", "TypeError", "warnings.simplefilter", "warnings.warn", "mmdet.core.get_classes", "type"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.get_classes"], ["def", "init_detector", "(", "config", ",", "checkpoint", "=", "None", ",", "device", "=", "'cuda:0'", ")", ":", "\n", "    ", "\"\"\"Initialize a detector from config file.\n\n    Args:\n        config (str or :obj:`mmcv.Config`): Config file path or the config\n            object.\n        checkpoint (str, optional): Checkpoint path. If left as None, the model\n            will not load any weights.\n\n    Returns:\n        nn.Module: The constructed detector.\n    \"\"\"", "\n", "if", "isinstance", "(", "config", ",", "str", ")", ":", "\n", "        ", "config", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "config", ")", "\n", "", "elif", "not", "isinstance", "(", "config", ",", "mmcv", ".", "Config", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'config must be a filename or Config object, '", "\n", "f'but got {type(config)}'", ")", "\n", "", "config", ".", "model", ".", "pretrained", "=", "None", "\n", "model", "=", "build_detector", "(", "config", ".", "model", ",", "test_cfg", "=", "config", ".", "test_cfg", ")", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "map_loc", "=", "'cpu'", "if", "device", "==", "'cpu'", "else", "None", "\n", "checkpoint", "=", "load_checkpoint", "(", "model", ",", "checkpoint", ",", "map_location", "=", "map_loc", ")", "\n", "if", "'CLASSES'", "in", "checkpoint", "[", "'meta'", "]", ":", "\n", "            ", "model", ".", "CLASSES", "=", "checkpoint", "[", "'meta'", "]", "[", "'CLASSES'", "]", "\n", "", "else", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "warnings", ".", "warn", "(", "'Class names are not saved in the checkpoint\\'s '", "\n", "'meta data, use COCO classes by default.'", ")", "\n", "model", ".", "CLASSES", "=", "get_classes", "(", "'coco'", ")", "\n", "", "", "model", ".", "cfg", "=", "config", "# save the config in the model for convenience", "\n", "model", ".", "to", "(", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.inference_detector": [[77, 117], ["mmdet.datasets.pipelines.Compose", "dict", "mmdet.datasets.pipelines.Compose.", "mmcv.parallel.collate", "next", "next", "model.modules", "warnings.warn", "torch.no_grad", "model", "model.parameters", "inference.LoadImage", "model.parameters", "mmcv.parallel.scatter", "isinstance"], "function", ["None"], ["", "", "def", "inference_detector", "(", "model", ",", "img", ")", ":", "\n", "    ", "\"\"\"Inference image(s) with the detector.\n\n    Args:\n        model (nn.Module): The loaded detector.\n        imgs (str/ndarray or list[str/ndarray]): Either image files or loaded\n            images.\n\n    Returns:\n        If imgs is a str, a generator will be returned, otherwise return the\n        detection results directly.\n    \"\"\"", "\n", "cfg", "=", "model", ".", "cfg", "\n", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "# model device", "\n", "# build the data pipeline", "\n", "test_pipeline", "=", "[", "LoadImage", "(", ")", "]", "+", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "1", ":", "]", "\n", "test_pipeline", "=", "Compose", "(", "test_pipeline", ")", "\n", "# prepare data", "\n", "data", "=", "dict", "(", "img", "=", "img", ")", "\n", "data", "=", "test_pipeline", "(", "data", ")", "\n", "data", "=", "collate", "(", "[", "data", "]", ",", "samples_per_gpu", "=", "1", ")", "\n", "if", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "is_cuda", ":", "\n", "# scatter to specified GPU", "\n", "        ", "data", "=", "scatter", "(", "data", ",", "[", "device", "]", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "# Use torchvision ops for CPU mode instead", "\n", "        ", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "(", "RoIPool", ",", "RoIAlign", ")", ")", ":", "\n", "                ", "if", "not", "m", ".", "aligned", ":", "\n", "# aligned=False is not implemented on CPU", "\n", "# set use_torchvision on-the-fly", "\n", "                    ", "m", ".", "use_torchvision", "=", "True", "\n", "", "", "", "warnings", ".", "warn", "(", "'We set use_torchvision=True in CPU mode.'", ")", "\n", "# just get the actual data from DataContainer", "\n", "data", "[", "'img_metas'", "]", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "\n", "\n", "# forward the model", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.show_result_pyplot": [[147, 164], ["hasattr", "model.show_result", "matplotlib.figure", "matplotlib.imshow", "matplotlib.show", "mmcv.bgr2rgb"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result"], ["", "def", "show_result_pyplot", "(", "model", ",", "img", ",", "result", ",", "score_thr", "=", "0.3", ",", "fig_size", "=", "(", "15", ",", "10", ")", ")", ":", "\n", "    ", "\"\"\"Visualize the detection results on the image.\n\n    Args:\n        model (nn.Module): The loaded detector.\n        img (str or np.ndarray): Image filename or loaded image.\n        result (tuple[list] or list): The detection result, can be either\n            (bbox, segm) or just bbox.\n        score_thr (float): The threshold to visualize the bboxes and masks.\n        fig_size (tuple): Figure size of the pyplot figure.\n    \"\"\"", "\n", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "img", "=", "model", ".", "show_result", "(", "img", ",", "result", ",", "score_thr", "=", "score_thr", ",", "show", "=", "False", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "fig_size", ")", "\n", "plt", ".", "imshow", "(", "mmcv", ".", "bgr2rgb", "(", "img", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.train.set_random_seed": [[15, 32], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_random_seed", "(", "seed", ",", "deterministic", "=", "False", ")", ":", "\n", "    ", "\"\"\"Set random seed.\n\n    Args:\n        seed (int): Seed to be used.\n        deterministic (bool): Whether to set the deterministic option for\n            CUDNN backend, i.e., set `torch.backends.cudnn.deterministic`\n            to True and `torch.backends.cudnn.benchmark` to False.\n            Default: False.\n    \"\"\"", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "if", "deterministic", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.train.train_detector": [[34, 144], ["mmdet.utils.get_root_logger", "mmcv.runner.build_optimizer", "mmcv.runner.EpochBasedRunner", "cfg.get", "mmcv.runner.EpochBasedRunner.register_training_hooks", "cfg.get", "mmcv.runner.EpochBasedRunner.run", "isinstance", "mmdet.utils.get_root_logger.warning", "mmdet.datasets.build_dataloader", "cfg.get", "mmcv.parallel.MMDistributedDataParallel", "mmcv.parallel.MMDataParallel", "mmdet.core.Fp16OptimizerHook", "cfg.get", "mmcv.runner.EpochBasedRunner.register_hook", "mmdet.datasets.build_dataset", "mmdet.datasets.build_dataloader", "cfg.get", "mmcv.runner.EpochBasedRunner.register_hook", "isinstance", "mmcv.runner.EpochBasedRunner.resume", "mmdet.utils.get_root_logger.warning", "mmdet.utils.get_root_logger.warning", "len", "mmcv.parallel.MMDataParallel.cuda", "mmcv.parallel.MMDataParallel.cuda", "mmcv.runner.OptimizerHook", "mmcv.runner.DistSamplerSeedHook", "dict", "eval_hook", "isinstance", "hook_cfg.copy.copy", "hook_cfg.copy.pop", "mmcv.utils.build_from_cfg", "mmcv.runner.EpochBasedRunner.register_hook", "mmcv.runner.EpochBasedRunner.load_checkpoint", "type", "torch.cuda.current_device", "type"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader"], ["", "", "def", "train_detector", "(", "model", ",", "\n", "dataset", ",", "\n", "cfg", ",", "\n", "distributed", "=", "False", ",", "\n", "validate", "=", "False", ",", "\n", "timestamp", "=", "None", ",", "\n", "meta", "=", "None", ")", ":", "\n", "    ", "logger", "=", "get_root_logger", "(", "cfg", ".", "log_level", ")", "\n", "\n", "# prepare data loaders", "\n", "dataset", "=", "dataset", "if", "isinstance", "(", "dataset", ",", "(", "list", ",", "tuple", ")", ")", "else", "[", "dataset", "]", "\n", "if", "'imgs_per_gpu'", "in", "cfg", ".", "data", ":", "\n", "        ", "logger", ".", "warning", "(", "'\"imgs_per_gpu\" is deprecated in MMDet V2.0. '", "\n", "'Please use \"samples_per_gpu\" instead'", ")", "\n", "if", "'samples_per_gpu'", "in", "cfg", ".", "data", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "f'Got \"imgs_per_gpu\"={cfg.data.imgs_per_gpu} and '", "\n", "f'\"samples_per_gpu\"={cfg.data.samples_per_gpu}, \"imgs_per_gpu\"'", "\n", "f'={cfg.data.imgs_per_gpu} is used in this experiments'", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "'Automatically set \"samples_per_gpu\"=\"imgs_per_gpu\"='", "\n", "f'{cfg.data.imgs_per_gpu} in this experiments'", ")", "\n", "", "cfg", ".", "data", ".", "samples_per_gpu", "=", "cfg", ".", "data", ".", "imgs_per_gpu", "\n", "\n", "", "data_loaders", "=", "[", "\n", "build_dataloader", "(", "\n", "ds", ",", "\n", "cfg", ".", "data", ".", "samples_per_gpu", ",", "\n", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "# cfg.gpus will be ignored if distributed", "\n", "len", "(", "cfg", ".", "gpu_ids", ")", ",", "\n", "dist", "=", "distributed", ",", "\n", "seed", "=", "cfg", ".", "seed", ")", "for", "ds", "in", "dataset", "\n", "]", "\n", "\n", "# put model on gpus", "\n", "if", "distributed", ":", "\n", "        ", "find_unused_parameters", "=", "cfg", ".", "get", "(", "'find_unused_parameters'", ",", "False", ")", "\n", "# Sets the `find_unused_parameters` parameter in", "\n", "# torch.nn.parallel.DistributedDataParallel", "\n", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ",", "\n", "find_unused_parameters", "=", "find_unused_parameters", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "MMDataParallel", "(", "\n", "model", ".", "cuda", "(", "cfg", ".", "gpu_ids", "[", "0", "]", ")", ",", "device_ids", "=", "cfg", ".", "gpu_ids", ")", "\n", "\n", "# build runner", "\n", "", "optimizer", "=", "build_optimizer", "(", "model", ",", "cfg", ".", "optimizer", ")", "\n", "runner", "=", "EpochBasedRunner", "(", "\n", "model", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "work_dir", "=", "cfg", ".", "work_dir", ",", "\n", "logger", "=", "logger", ",", "\n", "meta", "=", "meta", ")", "\n", "# an ugly workaround to make .log and .log.json filenames the same", "\n", "runner", ".", "timestamp", "=", "timestamp", "\n", "\n", "# fp16 setting", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "        ", "optimizer_config", "=", "Fp16OptimizerHook", "(", "\n", "**", "cfg", ".", "optimizer_config", ",", "**", "fp16_cfg", ",", "distributed", "=", "distributed", ")", "\n", "", "elif", "distributed", "and", "'type'", "not", "in", "cfg", ".", "optimizer_config", ":", "\n", "        ", "optimizer_config", "=", "OptimizerHook", "(", "**", "cfg", ".", "optimizer_config", ")", "\n", "", "else", ":", "\n", "        ", "optimizer_config", "=", "cfg", ".", "optimizer_config", "\n", "\n", "# register hooks", "\n", "", "runner", ".", "register_training_hooks", "(", "cfg", ".", "lr_config", ",", "optimizer_config", ",", "\n", "cfg", ".", "checkpoint_config", ",", "cfg", ".", "log_config", ",", "\n", "cfg", ".", "get", "(", "'momentum_config'", ",", "None", ")", ")", "\n", "if", "distributed", ":", "\n", "        ", "runner", ".", "register_hook", "(", "DistSamplerSeedHook", "(", ")", ")", "\n", "\n", "# register eval hooks", "\n", "", "if", "validate", ":", "\n", "        ", "val_dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ",", "dict", "(", "test_mode", "=", "True", ")", ")", "\n", "val_dataloader", "=", "build_dataloader", "(", "\n", "val_dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "eval_cfg", "=", "cfg", ".", "get", "(", "'evaluation'", ",", "{", "}", ")", "\n", "eval_hook", "=", "DistEvalHook", "if", "distributed", "else", "EvalHook", "\n", "runner", ".", "register_hook", "(", "eval_hook", "(", "val_dataloader", ",", "cfg", "=", "cfg", ",", "**", "eval_cfg", ")", ")", "\n", "\n", "# user-defined hooks", "\n", "", "if", "cfg", ".", "get", "(", "'custom_hooks'", ",", "None", ")", ":", "\n", "        ", "custom_hooks", "=", "cfg", ".", "custom_hooks", "\n", "assert", "isinstance", "(", "custom_hooks", ",", "list", ")", ",", "f'custom_hooks expect list type, but got {type(custom_hooks)}'", "\n", "for", "hook_cfg", "in", "cfg", ".", "custom_hooks", ":", "\n", "            ", "assert", "isinstance", "(", "hook_cfg", ",", "dict", ")", ",", "'Each item in custom_hooks expects dict type, but got '", "f'{type(hook_cfg)}'", "\n", "hook_cfg", "=", "hook_cfg", ".", "copy", "(", ")", "\n", "priority", "=", "hook_cfg", ".", "pop", "(", "'priority'", ",", "'NORMAL'", ")", "\n", "hook", "=", "build_from_cfg", "(", "hook_cfg", ",", "HOOKS", ")", "\n", "runner", ".", "register_hook", "(", "hook", ",", "priority", "=", "priority", ")", "\n", "\n", "", "", "if", "cfg", ".", "resume_from", ":", "\n", "        ", "runner", ".", "resume", "(", "cfg", ".", "resume_from", ")", "\n", "", "elif", "cfg", ".", "load_from", ":", "\n", "        ", "runner", ".", "load_checkpoint", "(", "cfg", ".", "load_from", ")", "\n", "", "runner", ".", "run", "(", "data_loaders", ",", "cfg", ".", "workflow", ",", "cfg", ".", "total_epochs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.single_gpu_test": [[17, 60], ["model.eval", "mmcv.ProgressBar", "enumerate", "len", "len", "range", "results.append", "torch.no_grad", "torch.no_grad", "model", "mmdet.core.tensor2imgs", "zip", "mmcv.ProgressBar.update", "len", "len", "mmcv.imresize", "model.module.show_result", "test.encode_segms", "os.join"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.tensor2imgs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.encode_segms"], ["def", "single_gpu_test", "(", "model", ",", "\n", "data_loader", ",", "\n", "show", "=", "False", ",", "\n", "out_dir", "=", "None", ",", "\n", "show_score_thr", "=", "0.3", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "if", "show", "or", "out_dir", ":", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "\n", "for", "img", ",", "img_meta", "in", "zip", "(", "imgs", ",", "img_metas", ")", ":", "\n", "                ", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "\n", "ori_h", ",", "ori_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", ":", "-", "1", "]", "\n", "img_show", "=", "mmcv", ".", "imresize", "(", "img_show", ",", "(", "ori_w", ",", "ori_h", ")", ")", "\n", "\n", "if", "out_dir", ":", "\n", "                    ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "img_meta", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ",", "\n", "score_thr", "=", "show_score_thr", ")", "\n", "\n", "", "", "batch_size", "=", "len", "(", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", ")", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "results", ".", "append", "(", "encode_segms", "(", "[", "result", "]", ",", "dataset", ")", "[", "0", "]", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.multi_gpu_test": [[62, 106], ["model.eval", "mmcv.runner.get_dist_info", "time.sleep", "enumerate", "mmcv.ProgressBar", "collect_results_cpu.append", "test.collect_results_gpu", "test.collect_results_cpu", "len", "torch.no_grad", "torch.no_grad", "model", "range", "len", "len", "len", "len", "mmcv.ProgressBar.update", "test.encode_segms"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.collect_results_gpu", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.collect_results_cpu", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.encode_segms"], ["", "def", "multi_gpu_test", "(", "model", ",", "data_loader", ",", "tmpdir", "=", "None", ",", "gpu_collect", "=", "False", ")", ":", "\n", "    ", "\"\"\"Test model with multiple gpus.\n\n    This method tests model with multiple gpus and collects the results\n    under two different modes: gpu and cpu modes. By setting 'gpu_collect=True'\n    it encodes results to gpu tensors and use gpu communication for results\n    collection. On cpu mode it saves the results on different gpus to 'tmpdir'\n    and collects them by the rank 0 worker.\n\n    Args:\n        model (nn.Module): Model to be tested.\n        data_loader (nn.Dataloader): Pytorch data loader.\n        tmpdir (str): Path of directory to save the temporary results from\n            different gpus under cpu mode.\n        gpu_collect (bool): Option to use either gpu or cpu to collect results.\n\n    Returns:\n        list: The prediction results.\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "", "time", ".", "sleep", "(", "2", ")", "# This line can prevent deadlock problem in some cases.", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "batch_size", "=", "(", "\n", "len", "(", "data", "[", "'img_meta'", "]", ".", "data", ")", "\n", "if", "'img_meta'", "in", "data", "else", "len", "(", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", ")", ")", "\n", "for", "_", "in", "range", "(", "batch_size", "*", "world_size", ")", ":", "\n", "                ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "results", ".", "append", "(", "encode_segms", "(", "[", "result", "]", ",", "dataset", ")", "[", "0", "]", ")", "\n", "\n", "# collect results from all ranks", "\n", "", "if", "gpu_collect", ":", "\n", "        ", "results", "=", "collect_results_gpu", "(", "results", ",", "len", "(", "dataset", ")", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "collect_results_cpu", "(", "results", ",", "len", "(", "dataset", ")", ",", "tmpdir", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.encode_segms": [[107, 139], ["isinstance", "new_results.append", "mmdet.core.encode_mask_results", "len", "len", "len", "ValueError", "len", "mmcv.imresize", "numpy.unique", "ValueError", "stuff_segms[].append", "range", "pycocotools.encode", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.utils.encode_mask_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "encode_segms", "(", "results", ",", "dataset", ")", ":", "\n", "    ", "new_results", "=", "[", "]", "\n", "for", "result", "in", "results", ":", "\n", "# encode mask results", "\n", "        ", "if", "isinstance", "(", "result", ",", "tuple", ")", ":", "\n", "            ", "if", "len", "(", "result", ")", "==", "2", ":", "\n", "                ", "bbox_results", ",", "mask_results", "=", "result", "\n", "", "elif", "len", "(", "result", ")", "==", "3", ":", "\n", "                ", "bbox_results", ",", "mask_results", ",", "stuff_results", "=", "result", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong result.'", ")", "\n", "", "encoded_mask_results", "=", "encode_mask_results", "(", "mask_results", ")", "\n", "if", "len", "(", "result", ")", "==", "2", ":", "\n", "                ", "result", "=", "bbox_results", ",", "encoded_mask_results", "\n", "", "elif", "len", "(", "result", ")", "==", "3", ":", "\n", "                ", "stuff_segms", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "dataset", ".", "seg_ids", ")", ")", "]", "\n", "stuff_map", "=", "stuff_results", "[", "'stuff_map'", "]", "\n", "stuff_img_shape", "=", "stuff_results", "[", "'img_shape'", "]", "\n", "stuff_map", "=", "mmcv", ".", "imresize", "(", "stuff_map", ",", "stuff_img_shape", ",", "\n", "interpolation", "=", "'nearest'", ")", "\n", "unique_stuffs", "=", "np", ".", "unique", "(", "stuff_map", ")", "\n", "for", "j", "in", "unique_stuffs", ":", "\n", "                    ", "stuff_class_mask", "=", "(", "stuff_map", "==", "j", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "rle", "=", "mask_util", ".", "encode", "(", "\n", "np", ".", "array", "(", "stuff_class_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "\n", "order", "=", "'F'", ")", ")", "[", "0", "]", "\n", "stuff_segms", "[", "j", "]", ".", "append", "(", "rle", ")", "\n", "", "result", "=", "bbox_results", ",", "encoded_mask_results", ",", "stuff_segms", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong result.'", ")", "\n", "", "", "new_results", ".", "append", "(", "result", ")", "\n", "", "return", "new_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.collect_results_cpu": [[141, 181], ["mmcv.runner.get_dist_info", "mmcv.dump", "torch.barrier", "torch.full", "torch.full", "torch.broadcast", "torch.full.cpu().numpy().tobytes().decode().rstrip", "mmcv.mkdir_or_exist", "os.join", "range", "zip", "shutil.rmtree", "tempfile.mkdtemp", "torch.tensor", "torch.tensor", "os.join", "part_list.append", "ordered_results.extend", "bytearray", "torch.full.cpu().numpy().tobytes().decode", "mmcv.load", "list", "torch.tensor.encode", "len", "torch.full.cpu().numpy().tobytes", "torch.full.cpu().numpy", "torch.full.cpu"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "collect_results_cpu", "(", "result_part", ",", "size", ",", "tmpdir", "=", "None", ")", ":", "\n", "    ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "# create a tmp dir if it is not specified", "\n", "if", "tmpdir", "is", "None", ":", "\n", "        ", "MAX_LEN", "=", "512", "\n", "# 32 is whitespace", "\n", "dir_tensor", "=", "torch", ".", "full", "(", "(", "MAX_LEN", ",", ")", ",", "\n", "32", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "\n", "device", "=", "'cuda'", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "tmpdir", "=", "torch", ".", "tensor", "(", "\n", "bytearray", "(", "tmpdir", ".", "encode", "(", ")", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "dir_tensor", "[", ":", "len", "(", "tmpdir", ")", "]", "=", "tmpdir", "\n", "", "dist", ".", "broadcast", "(", "dir_tensor", ",", "0", ")", "\n", "tmpdir", "=", "dir_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", ".", "decode", "(", ")", ".", "rstrip", "(", ")", "\n", "", "else", ":", "\n", "        ", "mmcv", ".", "mkdir_or_exist", "(", "tmpdir", ")", "\n", "# dump the part result to the dir", "\n", "", "mmcv", ".", "dump", "(", "result_part", ",", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{rank}.pkl'", ")", ")", "\n", "dist", ".", "barrier", "(", ")", "\n", "# collect all parts", "\n", "if", "rank", "!=", "0", ":", "\n", "        ", "return", "None", "\n", "", "else", ":", "\n", "# load results of all parts from tmp dir", "\n", "        ", "part_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "part_file", "=", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{i}.pkl'", ")", "\n", "part_list", ".", "append", "(", "mmcv", ".", "load", "(", "part_file", ")", ")", "\n", "# sort the results", "\n", "", "ordered_results", "=", "[", "]", "\n", "for", "res", "in", "zip", "(", "*", "part_list", ")", ":", "\n", "            ", "ordered_results", ".", "extend", "(", "list", "(", "res", ")", ")", "\n", "# the dataloader may pad some samples", "\n", "", "ordered_results", "=", "ordered_results", "[", ":", "size", "]", "\n", "# remove tmp dir", "\n", "shutil", ".", "rmtree", "(", "tmpdir", ")", "\n", "return", "ordered_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.test.collect_results_gpu": [[183, 214], ["mmcv.runner.get_dist_info", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.all_gather", "torch.tensor().max", "torch.tensor().max", "torch.zeros", "torch.zeros", "torch.all_gather", "bytearray", "torch.tensor.clone", "torch.tensor.new_zeros", "zip", "zip", "pickle.dumps", "range", "torch.tensor", "torch.tensor", "range", "part_list.append", "ordered_results.extend", "pickle.loads", "list", "recv[].cpu().numpy().tobytes", "recv[].cpu().numpy", "recv[].cpu"], "function", ["None"], ["", "", "def", "collect_results_gpu", "(", "result_part", ",", "size", ")", ":", "\n", "    ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "# dump result part to tensor with pickle", "\n", "part_tensor", "=", "torch", ".", "tensor", "(", "\n", "bytearray", "(", "pickle", ".", "dumps", "(", "result_part", ")", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "# gather all result part tensor shape", "\n", "shape_tensor", "=", "torch", ".", "tensor", "(", "part_tensor", ".", "shape", ",", "device", "=", "'cuda'", ")", "\n", "shape_list", "=", "[", "shape_tensor", ".", "clone", "(", ")", "for", "_", "in", "range", "(", "world_size", ")", "]", "\n", "dist", ".", "all_gather", "(", "shape_list", ",", "shape_tensor", ")", "\n", "# padding result part tensor to max length", "\n", "shape_max", "=", "torch", ".", "tensor", "(", "shape_list", ")", ".", "max", "(", ")", "\n", "part_send", "=", "torch", ".", "zeros", "(", "shape_max", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "part_send", "[", ":", "shape_tensor", "[", "0", "]", "]", "=", "part_tensor", "\n", "part_recv_list", "=", "[", "\n", "part_tensor", ".", "new_zeros", "(", "shape_max", ")", "for", "_", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "# gather all result part", "\n", "dist", ".", "all_gather", "(", "part_recv_list", ",", "part_send", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "part_list", "=", "[", "]", "\n", "for", "recv", ",", "shape", "in", "zip", "(", "part_recv_list", ",", "shape_list", ")", ":", "\n", "            ", "part_list", ".", "append", "(", "\n", "pickle", ".", "loads", "(", "recv", "[", ":", "shape", "[", "0", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", ")", ")", "\n", "# sort the results", "\n", "", "ordered_results", "=", "[", "]", "\n", "for", "res", "in", "zip", "(", "*", "part_list", ")", ":", "\n", "            ", "ordered_results", ".", "extend", "(", "list", "(", "res", ")", ")", "\n", "# the dataloader may pad some samples", "\n", "", "ordered_results", "=", "ordered_results", "[", ":", "size", "]", "\n", "return", "ordered_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build": [[13, 33], ["isinstance", "torch.nn.Sequential", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg"], "function", ["None"], ["\n", "if", "platform", ".", "system", "(", ")", "!=", "'Windows'", ":", "\n", "# https://github.com/pytorch/pytorch/issues/973", "\n", "    ", "import", "resource", "\n", "rlimit", "=", "resource", ".", "getrlimit", "(", "resource", ".", "RLIMIT_NOFILE", ")", "\n", "hard_limit", "=", "rlimit", "[", "1", "]", "\n", "soft_limit", "=", "min", "(", "4096", ",", "hard_limit", ")", "\n", "resource", ".", "setrlimit", "(", "resource", ".", "RLIMIT_NOFILE", ",", "(", "soft_limit", ",", "hard_limit", ")", ")", "\n", "\n", "", "DATASETS", "=", "Registry", "(", "'dataset'", ")", "\n", "PIPELINES", "=", "Registry", "(", "'pipeline'", ")", "\n", "\n", "\n", "def", "_concat_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "from", ".", "dataset_wrappers", "import", "ConcatDataset", "\n", "ann_files", "=", "cfg", "[", "'ann_file'", "]", "\n", "img_prefixes", "=", "cfg", ".", "get", "(", "'img_prefix'", ",", "None", ")", "\n", "seg_prefixes", "=", "cfg", ".", "get", "(", "'seg_prefix'", ",", "None", ")", "\n", "proposal_files", "=", "cfg", ".", "get", "(", "'proposal_file'", ",", "None", ")", "\n", "\n", "datasets", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone": [[35, 38], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["for", "i", "in", "range", "(", "num_dset", ")", ":", "\n", "        ", "data_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "data_cfg", "[", "'ann_file'", "]", "=", "ann_files", "[", "i", "]", "\n", "if", "isinstance", "(", "img_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_neck": [[40, 43], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["", "if", "isinstance", "(", "seg_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'seg_prefix'", "]", "=", "seg_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "proposal_files", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'proposal_file'", "]", "=", "proposal_files", "[", "i", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor": [[45, 48], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["\n", "", "return", "ConcatDataset", "(", "datasets", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_shared_head": [[50, 53], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["    ", "from", ".", "dataset_wrappers", "import", "(", "ConcatDataset", ",", "RepeatDataset", ",", "\n", "ClassBalancedDataset", ")", "\n", "if", "isinstance", "(", "cfg", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "ConcatDataset", "(", "[", "build_dataset", "(", "c", ",", "default_args", ")", "for", "c", "in", "cfg", "]", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head": [[55, 58], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["        ", "dataset", "=", "RepeatDataset", "(", "\n", "build_dataset", "(", "cfg", "[", "'dataset'", "]", ",", "default_args", ")", ",", "cfg", "[", "'times'", "]", ")", "\n", "", "elif", "cfg", "[", "'type'", "]", "==", "'ClassBalancedDataset'", ":", "\n", "        ", "dataset", "=", "ClassBalancedDataset", "(", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss": [[60, 63], ["builder.build"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["", "elif", "isinstance", "(", "cfg", ".", "get", "(", "'ann_file'", ")", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "_concat_dataset", "(", "cfg", ",", "default_args", ")", "\n", "", "else", ":", "\n", "        ", "dataset", "=", "build_from_cfg", "(", "cfg", ",", "DATASETS", ",", "default_args", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector": [[65, 68], ["builder.build", "dict"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build"], ["", "return", "dataset", "\n", "\n", "\n", "", "def", "build_dataloader", "(", "dataset", ",", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nasfcos_fpn.NASFCOS_FPN.__init__": [[31, 114], ["torch.Module.__init__", "isinstance", "len", "torch.ModuleList", "torch.ModuleList", "range", "torch.ModuleDict", "torch.ModuleDict", "nasfcos_fpn.NASFCOS_FPN.__init__.build_concat_cell"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "start_level", "=", "1", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "NASFCOS_FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "num_outs", "=", "num_outs", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "\n", "if", "end_level", "==", "-", "1", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "self", ".", "num_ins", "\n", "assert", "num_outs", ">=", "self", ".", "num_ins", "-", "start_level", "\n", "", "else", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "end_level", "\n", "assert", "end_level", "<=", "len", "(", "in_channels", ")", "\n", "assert", "num_outs", "==", "end_level", "-", "start_level", "\n", "", "self", ".", "start_level", "=", "start_level", "\n", "self", ".", "end_level", "=", "end_level", "\n", "self", ".", "add_extra_convs", "=", "add_extra_convs", "\n", "\n", "self", ".", "adapt_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "adapt_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ",", "inplace", "=", "False", ")", ")", "\n", "self", ".", "adapt_convs", ".", "append", "(", "adapt_conv", ")", "\n", "\n", "# C2 is omitted according to the paper", "\n", "", "extra_levels", "=", "num_outs", "-", "self", ".", "backbone_end_level", "+", "self", ".", "start_level", "\n", "\n", "def", "build_concat_cell", "(", "with_input1_conv", ",", "with_input2_conv", ")", ":", "\n", "            ", "cell_conv_cfg", "=", "dict", "(", "\n", "kernel_size", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ",", "groups", "=", "out_channels", ")", "\n", "return", "ConcatCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "with_out_conv", "=", "True", ",", "\n", "out_conv_cfg", "=", "cell_conv_cfg", ",", "\n", "out_norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "out_conv_order", "=", "(", "'norm'", ",", "'act'", ",", "'conv'", ")", ",", "\n", "with_input1_conv", "=", "with_input1_conv", ",", "\n", "with_input2_conv", "=", "with_input2_conv", ",", "\n", "input_conv_cfg", "=", "conv_cfg", ",", "\n", "input_norm_cfg", "=", "norm_cfg", ",", "\n", "upsample_mode", "=", "'nearest'", ")", "\n", "\n", "# Denote c3=f0, c4=f1, c5=f2 for convince", "\n", "", "self", ".", "fpn", "=", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "fpn", "[", "'c22_1'", "]", "=", "build_concat_cell", "(", "True", ",", "True", ")", "\n", "self", ".", "fpn", "[", "'c22_2'", "]", "=", "build_concat_cell", "(", "True", ",", "True", ")", "\n", "self", ".", "fpn", "[", "'c32'", "]", "=", "build_concat_cell", "(", "True", ",", "False", ")", "\n", "self", ".", "fpn", "[", "'c02'", "]", "=", "build_concat_cell", "(", "True", ",", "False", ")", "\n", "self", ".", "fpn", "[", "'c42'", "]", "=", "build_concat_cell", "(", "True", ",", "True", ")", "\n", "self", ".", "fpn", "[", "'c36'", "]", "=", "build_concat_cell", "(", "True", ",", "True", ")", "\n", "self", ".", "fpn", "[", "'c61'", "]", "=", "build_concat_cell", "(", "True", ",", "True", ")", "# f9", "\n", "self", ".", "extra_downsamples", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "extra_levels", ")", ":", "\n", "            ", "extra_act_cfg", "=", "None", "if", "i", "==", "0", "else", "dict", "(", "type", "=", "'ReLU'", ",", "inplace", "=", "False", ")", "\n", "self", ".", "extra_downsamples", ".", "append", "(", "\n", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "act_cfg", "=", "extra_act_cfg", ",", "\n", "order", "=", "(", "'act'", ",", "'norm'", ",", "'conv'", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nasfcos_fpn.NASFCOS_FPN.forward": [[115, 148], ["enumerate", "zip", "tuple", "adapt_conv", "feats.append", "torch.interpolate", "torch.interpolate", "ret.append", "ret.append", "enumerate", "int", "int", "torch.interpolate", "torch.interpolate", "submodule", "feats1.size", "inputs[].size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "feats", "=", "[", "\n", "adapt_conv", "(", "inputs", "[", "i", "+", "self", ".", "start_level", "]", ")", "\n", "for", "i", ",", "adapt_conv", "in", "enumerate", "(", "self", ".", "adapt_convs", ")", "\n", "]", "\n", "\n", "for", "(", "i", ",", "module_name", ")", "in", "enumerate", "(", "self", ".", "fpn", ")", ":", "\n", "            ", "idx_1", ",", "idx_2", "=", "int", "(", "module_name", "[", "1", "]", ")", ",", "int", "(", "module_name", "[", "2", "]", ")", "\n", "res", "=", "self", ".", "fpn", "[", "module_name", "]", "(", "feats", "[", "idx_1", "]", ",", "feats", "[", "idx_2", "]", ")", "\n", "feats", ".", "append", "(", "res", ")", "\n", "\n", "", "ret", "=", "[", "]", "\n", "for", "(", "idx", ",", "input_idx", ")", "in", "zip", "(", "[", "9", ",", "8", ",", "7", "]", ",", "[", "1", ",", "2", ",", "3", "]", ")", ":", "# add P3, P4, P5", "\n", "            ", "feats1", ",", "feats2", "=", "feats", "[", "idx", "]", ",", "feats", "[", "5", "]", "\n", "feats2_resize", "=", "F", ".", "interpolate", "(", "\n", "feats2", ",", "\n", "size", "=", "feats1", ".", "size", "(", ")", "[", "2", ":", "]", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "False", ")", "\n", "\n", "feats_sum", "=", "feats1", "+", "feats2_resize", "\n", "ret", ".", "append", "(", "\n", "F", ".", "interpolate", "(", "\n", "feats_sum", ",", "\n", "size", "=", "inputs", "[", "input_idx", "]", ".", "size", "(", ")", "[", "2", ":", "]", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "False", ")", ")", "\n", "\n", "", "for", "submodule", "in", "self", ".", "extra_downsamples", ":", "\n", "            ", "ret", ".", "append", "(", "submodule", "(", "ret", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "return", "tuple", "(", "ret", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nasfcos_fpn.NASFCOS_FPN.init_weights": [[149, 162], ["nasfcos_fpn.NASFCOS_FPN.fpn.values", "hasattr", "nasfcos_fpn.NASFCOS_FPN.adapt_convs.modules", "nasfcos_fpn.NASFCOS_FPN.extra_downsamples.modules", "mmcv.cnn.caffe2_xavier_init", "isinstance", "mmcv.cnn.caffe2_xavier_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of module.\"\"\"", "\n", "for", "module", "in", "self", ".", "fpn", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "module", ",", "'conv_out'", ")", ":", "\n", "                ", "caffe2_xavier_init", "(", "module", ".", "out_conv", ".", "conv", ")", "\n", "\n", "", "", "for", "modules", "in", "[", "\n", "self", ".", "adapt_convs", ".", "modules", "(", ")", ",", "\n", "self", ".", "extra_downsamples", ".", "modules", "(", ")", "\n", "]", ":", "\n", "            ", "for", "module", "in", "modules", ":", "\n", "                ", "if", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "caffe2_xavier_init", "(", "module", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn.FPN.__init__": [[64, 156], ["dict", "torch.Module.__init__", "isinstance", "len", "upsample_cfg.copy", "isinstance", "isinstance", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "fpn.FPN.lateral_convs.append", "fpn.FPN.fpn_convs.append", "range", "len", "mmcv.cnn.ConvModule", "fpn.FPN.fpn_convs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "start_level", "=", "0", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "extra_convs_on_inputs", "=", "True", ",", "\n", "relu_before_extra_convs", "=", "False", ",", "\n", "no_norm_on_lateral", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ",", "\n", "upsample_cfg", "=", "dict", "(", "mode", "=", "'nearest'", ")", ")", ":", "\n", "        ", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "num_outs", "=", "num_outs", "\n", "self", ".", "relu_before_extra_convs", "=", "relu_before_extra_convs", "\n", "self", ".", "no_norm_on_lateral", "=", "no_norm_on_lateral", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "self", ".", "upsample_cfg", "=", "upsample_cfg", ".", "copy", "(", ")", "\n", "\n", "if", "end_level", "==", "-", "1", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "self", ".", "num_ins", "\n", "assert", "num_outs", ">=", "self", ".", "num_ins", "-", "start_level", "\n", "", "else", ":", "\n", "# if end_level < inputs, no extra level is allowed", "\n", "            ", "self", ".", "backbone_end_level", "=", "end_level", "\n", "assert", "end_level", "<=", "len", "(", "in_channels", ")", "\n", "assert", "num_outs", "==", "end_level", "-", "start_level", "\n", "", "self", ".", "start_level", "=", "start_level", "\n", "self", ".", "end_level", "=", "end_level", "\n", "self", ".", "add_extra_convs", "=", "add_extra_convs", "\n", "assert", "isinstance", "(", "add_extra_convs", ",", "(", "str", ",", "bool", ")", ")", "\n", "if", "isinstance", "(", "add_extra_convs", ",", "str", ")", ":", "\n", "# Extra_convs_source choices: 'on_input', 'on_lateral', 'on_output'", "\n", "            ", "assert", "add_extra_convs", "in", "(", "'on_input'", ",", "'on_lateral'", ",", "'on_output'", ")", "\n", "", "elif", "add_extra_convs", ":", "# True", "\n", "            ", "if", "extra_convs_on_inputs", ":", "\n", "# For compatibility with previous release", "\n", "# TODO: deprecate `extra_convs_on_inputs`", "\n", "                ", "self", ".", "add_extra_convs", "=", "'on_input'", "\n", "", "else", ":", "\n", "                ", "self", ".", "add_extra_convs", "=", "'on_output'", "\n", "\n", "", "", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "fpn_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", "if", "not", "self", ".", "no_norm_on_lateral", "else", "None", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "fpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "fpn_conv", ")", "\n", "\n", "# add extra conv layers (e.g., RetinaNet)", "\n", "", "extra_levels", "=", "num_outs", "-", "self", ".", "backbone_end_level", "+", "self", ".", "start_level", "\n", "if", "self", ".", "add_extra_convs", "and", "extra_levels", ">=", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "extra_levels", ")", ":", "\n", "                ", "if", "i", "==", "0", "and", "self", ".", "add_extra_convs", "==", "'on_input'", ":", "\n", "                    ", "in_channels", "=", "self", ".", "in_channels", "[", "self", ".", "backbone_end_level", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "in_channels", "=", "out_channels", "\n", "", "extra_fpn_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "extra_fpn_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn.FPN.init_weights": [[158, 163], ["fpn.FPN.modules", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["None"], ["", "", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of FPN module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn.FPN.forward": [[164, 217], ["mmdet.core.auto_fp16", "len", "range", "tuple", "len", "len", "lateral_conv", "len", "enumerate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "range", "range", "outs.append", "range", "outs.append", "torch.max_pool2d", "torch.max_pool2d", "outs.append", "outs.append", "torch.relu", "torch.relu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "", "", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "\n", "# build laterals", "\n", "laterals", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "+", "self", ".", "start_level", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "\n", "# build top-down path", "\n", "used_backbone_levels", "=", "len", "(", "laterals", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "# In some cases, fixing `scale factor` (e.g. 2) is preferred, but", "\n", "#  it cannot co-exist with `size` in `F.interpolate`.", "\n", "            ", "if", "'scale_factor'", "in", "self", ".", "upsample_cfg", ":", "\n", "                ", "laterals", "[", "i", "-", "1", "]", "+=", "F", ".", "interpolate", "(", "laterals", "[", "i", "]", ",", "\n", "**", "self", ".", "upsample_cfg", ")", "\n", "", "else", ":", "\n", "                ", "prev_shape", "=", "laterals", "[", "i", "-", "1", "]", ".", "shape", "[", "2", ":", "]", "\n", "laterals", "[", "i", "-", "1", "]", "+=", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "prev_shape", ",", "**", "self", ".", "upsample_cfg", ")", "\n", "\n", "# build outputs", "\n", "# part 1: from original levels", "\n", "", "", "outs", "=", "[", "\n", "self", ".", "fpn_convs", "[", "i", "]", "(", "laterals", "[", "i", "]", ")", "for", "i", "in", "range", "(", "used_backbone_levels", ")", "\n", "]", "\n", "# part 2: add extra levels", "\n", "if", "self", ".", "num_outs", ">", "len", "(", "outs", ")", ":", "\n", "# use max pool to get more levels on top of outputs", "\n", "# (e.g., Faster R-CNN, Mask R-CNN)", "\n", "            ", "if", "not", "self", ".", "add_extra_convs", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "num_outs", "-", "used_backbone_levels", ")", ":", "\n", "                    ", "outs", ".", "append", "(", "F", ".", "max_pool2d", "(", "outs", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "2", ")", ")", "\n", "# add conv layers on top of original feature maps (RetinaNet)", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "add_extra_convs", "==", "'on_input'", ":", "\n", "                    ", "extra_source", "=", "inputs", "[", "self", ".", "backbone_end_level", "-", "1", "]", "\n", "", "elif", "self", ".", "add_extra_convs", "==", "'on_lateral'", ":", "\n", "                    ", "extra_source", "=", "laterals", "[", "-", "1", "]", "\n", "", "elif", "self", ".", "add_extra_convs", "==", "'on_output'", ":", "\n", "                    ", "extra_source", "=", "outs", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "used_backbone_levels", "]", "(", "extra_source", ")", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "+", "1", ",", "self", ".", "num_outs", ")", ":", "\n", "                    ", "if", "self", ".", "relu_before_extra_convs", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "F", ".", "relu", "(", "outs", "[", "-", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "outs", "[", "-", "1", "]", ")", ")", "\n", "", "", "", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.hrfpn.HRFPN.__init__": [[30, 72], ["torch.Module.__init__", "isinstance", "len", "mmcv.cnn.ConvModule", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "sum", "hrfpn.HRFPN.fpn_convs.append", "mmcv.cnn.ConvModule"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", "=", "5", ",", "\n", "pooling_type", "=", "'AVG'", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "with_cp", "=", "False", ",", "\n", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "HRFPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "num_outs", "=", "num_outs", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "\n", "self", ".", "reduction_conv", "=", "ConvModule", "(", "\n", "sum", "(", "in_channels", ")", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "fpn_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_outs", ")", ":", "\n", "            ", "self", ".", "fpn_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "act_cfg", "=", "None", ")", ")", "\n", "\n", "", "if", "pooling_type", "==", "'MAX'", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "max_pool2d", "\n", "", "else", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "avg_pool2d", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.hrfpn.HRFPN.init_weights": [[73, 78], ["hrfpn.HRFPN.modules", "isinstance", "mmcv.cnn.caffe2_xavier_init"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "caffe2_xavier_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.hrfpn.HRFPN.forward": [[79, 103], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "range", "tuple", "len", "outs.append", "torch.utils.checkpoint.checkpoint", "torch.utils.checkpoint.checkpoint", "torch.utils.checkpoint.checkpoint", "hrfpn.HRFPN.reduction_conv", "outs.append", "outputs.append", "torch.interpolate", "torch.interpolate", "torch.interpolate", "hrfpn.HRFPN.pooling", "torch.utils.checkpoint.checkpoint", "torch.utils.checkpoint.checkpoint", "torch.utils.checkpoint.checkpoint"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "self", ".", "num_ins", "\n", "outs", "=", "[", "inputs", "[", "0", "]", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_ins", ")", ":", "\n", "            ", "outs", ".", "append", "(", "\n", "F", ".", "interpolate", "(", "inputs", "[", "i", "]", ",", "scale_factor", "=", "2", "**", "i", ",", "mode", "=", "'bilinear'", ")", ")", "\n", "", "out", "=", "torch", ".", "cat", "(", "outs", ",", "dim", "=", "1", ")", "\n", "if", "out", ".", "requires_grad", "and", "self", ".", "with_cp", ":", "\n", "            ", "out", "=", "checkpoint", "(", "self", ".", "reduction_conv", ",", "out", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "reduction_conv", "(", "out", ")", "\n", "", "outs", "=", "[", "out", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_outs", ")", ":", "\n", "            ", "outs", ".", "append", "(", "self", ".", "pooling", "(", "out", ",", "kernel_size", "=", "2", "**", "i", ",", "stride", "=", "2", "**", "i", ")", ")", "\n", "", "outputs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_outs", ")", ":", "\n", "            ", "if", "outs", "[", "i", "]", ".", "requires_grad", "and", "self", ".", "with_cp", ":", "\n", "                ", "tmp_out", "=", "checkpoint", "(", "self", ".", "fpn_convs", "[", "i", "]", ",", "outs", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "tmp_out", "=", "self", ".", "fpn_convs", "[", "i", "]", "(", "outs", "[", "i", "]", ")", "\n", "", "outputs", ".", "append", "(", "tmp_out", ")", "\n", "", "return", "tuple", "(", "outputs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.__init__": [[33, 200], ["dict", "torch.Module.__init__", "isinstance", "len", "upsample_cfg.copy", "fpn_carafe.FPN_CARAFE.upsample_cfg.get", "torch.ReLU", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "fpn_carafe.FPN_CARAFE.upsample_cfg.pop", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "fpn_carafe.FPN_CARAFE.lateral_convs.append", "fpn_carafe.FPN_CARAFE.fpn_convs.append", "range", "hasattr", "len", "fpn_carafe.FPN_CARAFE.upsample_cfg.copy", "mmcv.cnn.build_upsample_layer", "fpn_carafe.FPN_CARAFE.upsample_modules.append", "mmcv.cnn.ConvModule", "mmcv.cnn.build_upsample_layer", "mmcv.cnn.ConvModule", "fpn_carafe.FPN_CARAFE.upsample_modules.append", "fpn_carafe.FPN_CARAFE.fpn_convs.append", "fpn_carafe.FPN_CARAFE.lateral_convs.append", "fpn_carafe.FPN_CARAFE.update", "dict", "fpn_carafe.FPN_CARAFE.update", "dict", "fpn_carafe.FPN_CARAFE.update", "fpn_carafe.FPN_CARAFE.update", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "start_level", "=", "0", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ",", "\n", "order", "=", "(", "'conv'", ",", "'norm'", ",", "'act'", ")", ",", "\n", "upsample_cfg", "=", "dict", "(", "\n", "type", "=", "'carafe'", ",", "\n", "up_kernel", "=", "5", ",", "\n", "up_group", "=", "1", ",", "\n", "encoder_kernel", "=", "3", ",", "\n", "encoder_dilation", "=", "1", ")", ")", ":", "\n", "        ", "super", "(", "FPN_CARAFE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "num_outs", "=", "num_outs", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "with_bias", "=", "norm_cfg", "is", "None", "\n", "self", ".", "upsample_cfg", "=", "upsample_cfg", ".", "copy", "(", ")", "\n", "self", ".", "upsample", "=", "self", ".", "upsample_cfg", ".", "get", "(", "'type'", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "self", ".", "order", "=", "order", "\n", "assert", "order", "in", "[", "(", "'conv'", ",", "'norm'", ",", "'act'", ")", ",", "(", "'act'", ",", "'conv'", ",", "'norm'", ")", "]", "\n", "\n", "assert", "self", ".", "upsample", "in", "[", "\n", "'nearest'", ",", "'bilinear'", ",", "'deconv'", ",", "'pixel_shuffle'", ",", "'carafe'", ",", "None", "\n", "]", "\n", "if", "self", ".", "upsample", "in", "[", "'deconv'", ",", "'pixel_shuffle'", "]", ":", "\n", "            ", "assert", "hasattr", "(", "\n", "self", ".", "upsample_cfg", ",", "\n", "'upsample_kernel'", ")", "and", "self", ".", "upsample_cfg", ".", "upsample_kernel", ">", "0", "\n", "self", ".", "upsample_kernel", "=", "self", ".", "upsample_cfg", ".", "pop", "(", "'upsample_kernel'", ")", "\n", "\n", "", "if", "end_level", "==", "-", "1", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "self", ".", "num_ins", "\n", "assert", "num_outs", ">=", "self", ".", "num_ins", "-", "start_level", "\n", "", "else", ":", "\n", "# if end_level < inputs, no extra level is allowed", "\n", "            ", "self", ".", "backbone_end_level", "=", "end_level", "\n", "assert", "end_level", "<=", "len", "(", "in_channels", ")", "\n", "assert", "num_outs", "==", "end_level", "-", "start_level", "\n", "", "self", ".", "start_level", "=", "start_level", "\n", "self", ".", "end_level", "=", "end_level", "\n", "\n", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "fpn_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "upsample_modules", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "with_bias", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ",", "\n", "order", "=", "self", ".", "order", ")", "\n", "fpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "with_bias", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ",", "\n", "order", "=", "self", ".", "order", ")", "\n", "if", "i", "!=", "self", ".", "backbone_end_level", "-", "1", ":", "\n", "                ", "upsample_cfg_", "=", "self", ".", "upsample_cfg", ".", "copy", "(", ")", "\n", "if", "self", ".", "upsample", "==", "'deconv'", ":", "\n", "                    ", "upsample_cfg_", ".", "update", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "self", ".", "upsample_kernel", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "(", "self", ".", "upsample_kernel", "-", "1", ")", "//", "2", ",", "\n", "output_padding", "=", "(", "self", ".", "upsample_kernel", "-", "1", ")", "//", "2", ")", "\n", "", "elif", "self", ".", "upsample", "==", "'pixel_shuffle'", ":", "\n", "                    ", "upsample_cfg_", ".", "update", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "scale_factor", "=", "2", ",", "\n", "upsample_kernel", "=", "self", ".", "upsample_kernel", ")", "\n", "", "elif", "self", ".", "upsample", "==", "'carafe'", ":", "\n", "                    ", "upsample_cfg_", ".", "update", "(", "channels", "=", "out_channels", ",", "scale_factor", "=", "2", ")", "\n", "", "else", ":", "\n", "# suppress warnings", "\n", "                    ", "align_corners", "=", "(", "None", "\n", "if", "self", ".", "upsample", "==", "'nearest'", "else", "False", ")", "\n", "upsample_cfg_", ".", "update", "(", "\n", "scale_factor", "=", "2", ",", "\n", "mode", "=", "self", ".", "upsample", ",", "\n", "align_corners", "=", "align_corners", ")", "\n", "", "upsample_module", "=", "build_upsample_layer", "(", "upsample_cfg_", ")", "\n", "self", ".", "upsample_modules", ".", "append", "(", "upsample_module", ")", "\n", "", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "fpn_conv", ")", "\n", "\n", "# add extra conv layers (e.g., RetinaNet)", "\n", "", "extra_out_levels", "=", "(", "\n", "num_outs", "-", "self", ".", "backbone_end_level", "+", "self", ".", "start_level", ")", "\n", "if", "extra_out_levels", ">=", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "extra_out_levels", ")", ":", "\n", "                ", "in_channels", "=", "(", "\n", "self", ".", "in_channels", "[", "self", ".", "backbone_end_level", "-", "\n", "1", "]", "if", "i", "==", "0", "else", "out_channels", ")", "\n", "extra_l_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "with_bias", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ",", "\n", "order", "=", "self", ".", "order", ")", "\n", "if", "self", ".", "upsample", "==", "'deconv'", ":", "\n", "                    ", "upsampler_cfg_", "=", "dict", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "self", ".", "upsample_kernel", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "(", "self", ".", "upsample_kernel", "-", "1", ")", "//", "2", ",", "\n", "output_padding", "=", "(", "self", ".", "upsample_kernel", "-", "1", ")", "//", "2", ")", "\n", "", "elif", "self", ".", "upsample", "==", "'pixel_shuffle'", ":", "\n", "                    ", "upsampler_cfg_", "=", "dict", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "scale_factor", "=", "2", ",", "\n", "upsample_kernel", "=", "self", ".", "upsample_kernel", ")", "\n", "", "elif", "self", ".", "upsample", "==", "'carafe'", ":", "\n", "                    ", "upsampler_cfg_", "=", "dict", "(", "\n", "channels", "=", "out_channels", ",", "\n", "scale_factor", "=", "2", ",", "\n", "**", "self", ".", "upsample_cfg", ")", "\n", "", "else", ":", "\n", "# suppress warnings", "\n", "                    ", "align_corners", "=", "(", "None", "\n", "if", "self", ".", "upsample", "==", "'nearest'", "else", "False", ")", "\n", "upsampler_cfg_", "=", "dict", "(", "\n", "scale_factor", "=", "2", ",", "\n", "mode", "=", "self", ".", "upsample", ",", "\n", "align_corners", "=", "align_corners", ")", "\n", "", "upsampler_cfg_", "[", "'type'", "]", "=", "self", ".", "upsample", "\n", "upsample_module", "=", "build_upsample_layer", "(", "upsampler_cfg_", ")", "\n", "extra_fpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "with_bias", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ",", "\n", "order", "=", "self", ".", "order", ")", "\n", "self", ".", "upsample_modules", ".", "append", "(", "upsample_module", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "extra_fpn_conv", ")", "\n", "self", ".", "lateral_convs", ".", "append", "(", "extra_l_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.init_weights": [[202, 210], ["fpn_carafe.FPN_CARAFE.modules", "fpn_carafe.FPN_CARAFE.modules", "isinstance", "isinstance", "mmcv.cnn.xavier_init", "m.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ")", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "", "", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "CARAFEPack", ")", ":", "\n", "                ", "m", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.slice_as": [[211, 230], ["src.size", "dst.size", "src.size", "dst.size", "src.size", "dst.size", "src.size", "dst.size", "dst.size", "dst.size"], "methods", ["None"], ["", "", "", "def", "slice_as", "(", "self", ",", "src", ",", "dst", ")", ":", "\n", "        ", "\"\"\"Slice ``src`` as ``dst``\n\n        Note:\n            ``src`` should have the same or larger size than ``dst``.\n\n        Args:\n            src (torch.Tensor): Tensors to be sliced.\n            dst (torch.Tensor): ``src`` will be sliced to have the same\n                size as ``dst``.\n\n        Returns:\n            torch.Tensor: Sliced tensor.\n        \"\"\"", "\n", "assert", "(", "src", ".", "size", "(", "2", ")", ">=", "dst", ".", "size", "(", "2", ")", ")", "and", "(", "src", ".", "size", "(", "3", ")", ">=", "dst", ".", "size", "(", "3", ")", ")", "\n", "if", "src", ".", "size", "(", "2", ")", "==", "dst", ".", "size", "(", "2", ")", "and", "src", ".", "size", "(", "3", ")", "==", "dst", ".", "size", "(", "3", ")", ":", "\n", "            ", "return", "src", "\n", "", "else", ":", "\n", "            ", "return", "src", "[", ":", ",", ":", ",", ":", "dst", ".", "size", "(", "2", ")", ",", ":", "dst", ".", "size", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.tensor_add": [[231, 238], ["a.size", "b.size", "fpn_carafe.FPN_CARAFE.slice_as"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.slice_as"], ["", "", "def", "tensor_add", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "\"\"\"Add tensors ``a`` and ``b`` that might have different sizes.\"\"\"", "\n", "if", "a", ".", "size", "(", ")", "==", "b", ".", "size", "(", ")", ":", "\n", "            ", "c", "=", "a", "+", "b", "\n", "", "else", ":", "\n", "            ", "c", "=", "a", "+", "self", ".", "slice_as", "(", "b", ",", "a", ")", "\n", "", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.forward": [[239, 268], ["enumerate", "range", "len", "range", "tuple", "len", "len", "lateral_conv", "laterals.append", "fpn_carafe.FPN_CARAFE.tensor_add", "outs.append", "len", "min", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.fpn_carafe.FPN_CARAFE.tensor_add"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "\n", "# build laterals", "\n", "laterals", "=", "[", "]", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", ":", "\n", "            ", "if", "i", "<=", "self", ".", "backbone_end_level", "-", "self", ".", "start_level", ":", "\n", "                ", "input", "=", "inputs", "[", "min", "(", "i", "+", "self", ".", "start_level", ",", "len", "(", "inputs", ")", "-", "1", ")", "]", "\n", "", "else", ":", "\n", "                ", "input", "=", "laterals", "[", "-", "1", "]", "\n", "", "lateral", "=", "lateral_conv", "(", "input", ")", "\n", "laterals", ".", "append", "(", "lateral", ")", "\n", "\n", "# build top-down path", "\n", "", "for", "i", "in", "range", "(", "len", "(", "laterals", ")", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "if", "self", ".", "upsample", "is", "not", "None", ":", "\n", "                ", "upsample_feat", "=", "self", ".", "upsample_modules", "[", "i", "-", "1", "]", "(", "laterals", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "upsample_feat", "=", "laterals", "[", "i", "]", "\n", "", "laterals", "[", "i", "-", "1", "]", "=", "self", ".", "tensor_add", "(", "laterals", "[", "i", "-", "1", "]", ",", "upsample_feat", ")", "\n", "\n", "# build outputs", "\n", "", "num_conv_outs", "=", "len", "(", "self", ".", "fpn_convs", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_conv_outs", ")", ":", "\n", "            ", "out", "=", "self", ".", "fpn_convs", "[", "i", "]", "(", "laterals", "[", "i", "]", ")", "\n", "outs", ".", "append", "(", "out", ")", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nas_fpn.NASFPN.__init__": [[30, 122], ["torch.Module.__init__", "isinstance", "len", "torch.ModuleList", "range", "torch.ModuleList", "range", "torch.ModuleList", "range", "mmcv.cnn.ConvModule", "nas_fpn.NASFPN.lateral_convs.append", "mmcv.cnn.ConvModule", "nas_fpn.NASFPN.extra_downsamples.append", "torch.ModuleDict", "mmcv.ops.merge_cells.GlobalPoolingCell", "mmcv.ops.merge_cells.SumCell", "mmcv.ops.merge_cells.SumCell", "mmcv.ops.merge_cells.SumCell", "mmcv.ops.merge_cells.GlobalPoolingCell", "mmcv.ops.merge_cells.SumCell", "mmcv.ops.merge_cells.GlobalPoolingCell", "mmcv.ops.merge_cells.SumCell", "mmcv.ops.merge_cells.GlobalPoolingCell", "nas_fpn.NASFPN.fpn_stages.append", "len", "torch.Sequential", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "stack_times", ",", "\n", "start_level", "=", "0", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "norm_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "NASFPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "# num of input feature levels", "\n", "self", ".", "num_outs", "=", "num_outs", "# num of output feature levels", "\n", "self", ".", "stack_times", "=", "stack_times", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "\n", "if", "end_level", "==", "-", "1", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "self", ".", "num_ins", "\n", "assert", "num_outs", ">=", "self", ".", "num_ins", "-", "start_level", "\n", "", "else", ":", "\n", "# if end_level < inputs, no extra level is allowed", "\n", "            ", "self", ".", "backbone_end_level", "=", "end_level", "\n", "assert", "end_level", "<=", "len", "(", "in_channels", ")", "\n", "assert", "num_outs", "==", "end_level", "-", "start_level", "\n", "", "self", ".", "start_level", "=", "start_level", "\n", "self", ".", "end_level", "=", "end_level", "\n", "self", ".", "add_extra_convs", "=", "add_extra_convs", "\n", "\n", "# add lateral connections", "\n", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "\n", "# add extra downsample layers (stride-2 pooling or conv)", "\n", "", "extra_levels", "=", "num_outs", "-", "self", ".", "backbone_end_level", "+", "self", ".", "start_level", "\n", "self", ".", "extra_downsamples", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "extra_levels", ")", ":", "\n", "            ", "extra_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "out_channels", ",", "1", ",", "norm_cfg", "=", "norm_cfg", ",", "act_cfg", "=", "None", ")", "\n", "self", ".", "extra_downsamples", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "extra_conv", ",", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ")", ")", "\n", "\n", "# add NAS FPN connections", "\n", "", "self", ".", "fpn_stages", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "stack_times", ")", ":", "\n", "            ", "stage", "=", "nn", ".", "ModuleDict", "(", ")", "\n", "# gp(p6, p4) -> p4_1", "\n", "stage", "[", "'gp_64_4'", "]", "=", "GlobalPoolingCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# sum(p4_1, p4) -> p4_2", "\n", "stage", "[", "'sum_44_4'", "]", "=", "SumCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# sum(p4_2, p3) -> p3_out", "\n", "stage", "[", "'sum_43_3'", "]", "=", "SumCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# sum(p3_out, p4_2) -> p4_out", "\n", "stage", "[", "'sum_34_4'", "]", "=", "SumCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# sum(p5, gp(p4_out, p3_out)) -> p5_out", "\n", "stage", "[", "'gp_43_5'", "]", "=", "GlobalPoolingCell", "(", "with_out_conv", "=", "False", ")", "\n", "stage", "[", "'sum_55_5'", "]", "=", "SumCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# sum(p7, gp(p5_out, p4_2)) -> p7_out", "\n", "stage", "[", "'gp_54_7'", "]", "=", "GlobalPoolingCell", "(", "with_out_conv", "=", "False", ")", "\n", "stage", "[", "'sum_77_7'", "]", "=", "SumCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "# gp(p7_out, p5_out) -> p6_out", "\n", "stage", "[", "'gp_75_6'", "]", "=", "GlobalPoolingCell", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_norm_cfg", "=", "norm_cfg", ")", "\n", "self", ".", "fpn_stages", ".", "append", "(", "stage", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nas_fpn.NASFPN.init_weights": [[123, 128], ["nas_fpn.NASFPN.modules", "isinstance", "mmcv.cnn.caffe2_xavier_init"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "caffe2_xavier_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.nas_fpn.NASFPN.forward": [[129, 161], ["lateral_conv", "feats.append", "enumerate", "downsample"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "# build P3-P5", "\n", "feats", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "+", "self", ".", "start_level", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "# build P6-P7 on top of P5", "\n", "for", "downsample", "in", "self", ".", "extra_downsamples", ":", "\n", "            ", "feats", ".", "append", "(", "downsample", "(", "feats", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "p3", ",", "p4", ",", "p5", ",", "p6", ",", "p7", "=", "feats", "\n", "\n", "for", "stage", "in", "self", ".", "fpn_stages", ":", "\n", "# gp(p6, p4) -> p4_1", "\n", "            ", "p4_1", "=", "stage", "[", "'gp_64_4'", "]", "(", "p6", ",", "p4", ",", "out_size", "=", "p4", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# sum(p4_1, p4) -> p4_2", "\n", "p4_2", "=", "stage", "[", "'sum_44_4'", "]", "(", "p4_1", ",", "p4", ",", "out_size", "=", "p4", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# sum(p4_2, p3) -> p3_out", "\n", "p3", "=", "stage", "[", "'sum_43_3'", "]", "(", "p4_2", ",", "p3", ",", "out_size", "=", "p3", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# sum(p3_out, p4_2) -> p4_out", "\n", "p4", "=", "stage", "[", "'sum_34_4'", "]", "(", "p3", ",", "p4_2", ",", "out_size", "=", "p4", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# sum(p5, gp(p4_out, p3_out)) -> p5_out", "\n", "p5_tmp", "=", "stage", "[", "'gp_43_5'", "]", "(", "p4", ",", "p3", ",", "out_size", "=", "p5", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "p5", "=", "stage", "[", "'sum_55_5'", "]", "(", "p5", ",", "p5_tmp", ",", "out_size", "=", "p5", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# sum(p7, gp(p5_out, p4_2)) -> p7_out", "\n", "p7_tmp", "=", "stage", "[", "'gp_54_7'", "]", "(", "p5", ",", "p4_2", ",", "out_size", "=", "p7", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "p7", "=", "stage", "[", "'sum_77_7'", "]", "(", "p7", ",", "p7_tmp", ",", "out_size", "=", "p7", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "# gp(p7_out, p5_out) -> p6_out", "\n", "p6", "=", "stage", "[", "'gp_75_6'", "]", "(", "p7", ",", "p5", ",", "out_size", "=", "p6", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "", "return", "p3", ",", "p4", ",", "p5", ",", "p6", ",", "p7", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.bfp.BFP.__init__": [[31, 65], ["torch.Module.__init__", "mmcv.cnn.ConvModule", "mmcv.cnn.bricks.NonLocal2d"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "num_levels", ",", "\n", "refine_level", "=", "2", ",", "\n", "refine_type", "=", "None", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "BFP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "refine_type", "in", "[", "None", ",", "'conv'", ",", "'non_local'", "]", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_levels", "=", "num_levels", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "\n", "self", ".", "refine_level", "=", "refine_level", "\n", "self", ".", "refine_type", "=", "refine_type", "\n", "assert", "0", "<=", "self", ".", "refine_level", "<", "self", ".", "num_levels", "\n", "\n", "if", "self", ".", "refine_type", "==", "'conv'", ":", "\n", "            ", "self", ".", "refine", "=", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "in_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", "\n", "", "elif", "self", ".", "refine_type", "==", "'non_local'", ":", "\n", "            ", "self", ".", "refine", "=", "NonLocal2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "reduction", "=", "1", ",", "\n", "use_scale", "=", "False", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.bfp.BFP.init_weights": [[66, 71], ["bfp.BFP.modules", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of FPN module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.bfp.BFP.forward": [[72, 105], ["range", "range", "tuple", "len", "inputs[].size", "feats.append", "sum", "len", "bfp.BFP.refine", "outs.append", "torch.adaptive_max_pool2d", "torch.adaptive_max_pool2d", "torch.interpolate", "torch.interpolate", "inputs[].size", "torch.interpolate", "torch.interpolate", "torch.adaptive_max_pool2d", "torch.adaptive_max_pool2d"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "self", ".", "num_levels", "\n", "\n", "# step 1: gather multi-level features by resize and average", "\n", "feats", "=", "[", "]", "\n", "gather_size", "=", "inputs", "[", "self", ".", "refine_level", "]", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "if", "i", "<", "self", ".", "refine_level", ":", "\n", "                ", "gathered", "=", "F", ".", "adaptive_max_pool2d", "(", "\n", "inputs", "[", "i", "]", ",", "output_size", "=", "gather_size", ")", "\n", "", "else", ":", "\n", "                ", "gathered", "=", "F", ".", "interpolate", "(", "\n", "inputs", "[", "i", "]", ",", "size", "=", "gather_size", ",", "mode", "=", "'nearest'", ")", "\n", "", "feats", ".", "append", "(", "gathered", ")", "\n", "\n", "", "bsf", "=", "sum", "(", "feats", ")", "/", "len", "(", "feats", ")", "\n", "\n", "# step 2: refine gathered features", "\n", "if", "self", ".", "refine_type", "is", "not", "None", ":", "\n", "            ", "bsf", "=", "self", ".", "refine", "(", "bsf", ")", "\n", "\n", "# step 3: scatter refined features to multi-levels by a residual path", "\n", "", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "out_size", "=", "inputs", "[", "i", "]", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "if", "i", "<", "self", ".", "refine_level", ":", "\n", "                ", "residual", "=", "F", ".", "interpolate", "(", "bsf", ",", "size", "=", "out_size", ",", "mode", "=", "'nearest'", ")", "\n", "", "else", ":", "\n", "                ", "residual", "=", "F", ".", "adaptive_max_pool2d", "(", "bsf", ",", "output_size", "=", "out_size", ")", "\n", "", "outs", ".", "append", "(", "residual", "+", "inputs", "[", "i", "]", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.pafpn.PAFPN.__init__": [[39, 82], ["fpn.FPN.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "pafpn.PAFPN.downsample_convs.append", "pafpn.PAFPN.pafpn_convs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "start_level", "=", "0", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "extra_convs_on_inputs", "=", "True", ",", "\n", "relu_before_extra_convs", "=", "False", ",", "\n", "no_norm_on_lateral", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "PAFPN", ",", "\n", "self", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "num_outs", ",", "start_level", ",", "\n", "end_level", ",", "add_extra_convs", ",", "extra_convs_on_inputs", ",", "\n", "relu_before_extra_convs", ",", "no_norm_on_lateral", ",", "\n", "conv_cfg", ",", "norm_cfg", ",", "act_cfg", ")", "\n", "# add extra bottom up pathway", "\n", "self", ".", "downsample_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "pafpn_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", "+", "1", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "d_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "pafpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "self", ".", "downsample_convs", ".", "append", "(", "d_conv", ")", "\n", "self", ".", "pafpn_convs", ".", "append", "(", "pafpn_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.pafpn.PAFPN.forward": [[83, 138], ["mmdet.core.auto_fp16", "len", "range", "range", "outs.append", "outs.extend", "tuple", "len", "len", "lateral_conv", "torch.interpolate", "torch.interpolate", "len", "enumerate", "range", "range", "range", "range", "outs.append", "outs.append", "outs.append", "torch.max_pool2d", "torch.max_pool2d", "outs.append", "outs.append", "torch.relu", "torch.relu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "\n", "# build laterals", "\n", "laterals", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "+", "self", ".", "start_level", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "\n", "# build top-down path", "\n", "used_backbone_levels", "=", "len", "(", "laterals", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "prev_shape", "=", "laterals", "[", "i", "-", "1", "]", ".", "shape", "[", "2", ":", "]", "\n", "laterals", "[", "i", "-", "1", "]", "+=", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "prev_shape", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "# build outputs", "\n", "# part 1: from original levels", "\n", "", "inter_outs", "=", "[", "\n", "self", ".", "fpn_convs", "[", "i", "]", "(", "laterals", "[", "i", "]", ")", "for", "i", "in", "range", "(", "used_backbone_levels", ")", "\n", "]", "\n", "\n", "# part 2: add bottom-up path", "\n", "for", "i", "in", "range", "(", "0", ",", "used_backbone_levels", "-", "1", ")", ":", "\n", "            ", "inter_outs", "[", "i", "+", "1", "]", "+=", "self", ".", "downsample_convs", "[", "i", "]", "(", "inter_outs", "[", "i", "]", ")", "\n", "\n", "", "outs", "=", "[", "]", "\n", "outs", ".", "append", "(", "inter_outs", "[", "0", "]", ")", "\n", "outs", ".", "extend", "(", "[", "\n", "self", ".", "pafpn_convs", "[", "i", "-", "1", "]", "(", "inter_outs", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "used_backbone_levels", ")", "\n", "]", ")", "\n", "\n", "# part 3: add extra levels", "\n", "if", "self", ".", "num_outs", ">", "len", "(", "outs", ")", ":", "\n", "# use max pool to get more levels on top of outputs", "\n", "# (e.g., Faster R-CNN, Mask R-CNN)", "\n", "            ", "if", "not", "self", ".", "add_extra_convs", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "num_outs", "-", "used_backbone_levels", ")", ":", "\n", "                    ", "outs", ".", "append", "(", "F", ".", "max_pool2d", "(", "outs", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "2", ")", ")", "\n", "# add conv layers on top of original feature maps (RetinaNet)", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "extra_convs_on_inputs", ":", "\n", "                    ", "orig", "=", "inputs", "[", "self", ".", "backbone_end_level", "-", "1", "]", "\n", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "used_backbone_levels", "]", "(", "orig", ")", ")", "\n", "", "else", ":", "\n", "                    ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "used_backbone_levels", "]", "(", "outs", "[", "-", "1", "]", ")", ")", "\n", "", "for", "i", "in", "range", "(", "used_backbone_levels", "+", "1", ",", "self", ".", "num_outs", ")", ":", "\n", "                    ", "if", "self", ".", "relu_before_extra_convs", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "F", ".", "relu", "(", "outs", "[", "-", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "outs", "[", "-", "1", "]", ")", ")", "\n", "", "", "", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.ASPP.__init__": [[23, 41], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "rfp.ASPP.init_weights", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "rfp.ASPP.aspp.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "dilations", "=", "(", "1", ",", "3", ",", "6", ",", "1", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "dilations", "[", "-", "1", "]", "==", "1", "\n", "self", ".", "aspp", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "dilation", "in", "dilations", ":", "\n", "            ", "kernel_size", "=", "3", "if", "dilation", ">", "1", "else", "1", "\n", "padding", "=", "dilation", "if", "dilation", ">", "1", "else", "0", "\n", "conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "dilation", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "True", ")", "\n", "self", ".", "aspp", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "gap", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.ASPP.init_weights": [[42, 46], ["rfp.ASPP.modules", "isinstance", "mmcv.cnn.kaiming_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "kaiming_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.ASPP.forward": [[47, 56], ["rfp.ASPP.gap", "range", "out[].expand_as", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.relu_", "torch.relu_", "torch.relu_", "len"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "avg_x", "=", "self", ".", "gap", "(", "x", ")", "\n", "out", "=", "[", "]", "\n", "for", "aspp_idx", "in", "range", "(", "len", "(", "self", ".", "aspp", ")", ")", ":", "\n", "            ", "inp", "=", "avg_x", "if", "(", "aspp_idx", "==", "len", "(", "self", ".", "aspp", ")", "-", "1", ")", "else", "x", "\n", "out", ".", "append", "(", "F", ".", "relu_", "(", "self", ".", "aspp", "[", "aspp_idx", "]", "(", "inp", ")", ")", ")", "\n", "", "out", "[", "-", "1", "]", "=", "out", "[", "-", "1", "]", ".", "expand_as", "(", "out", "[", "-", "2", "]", ")", "\n", "out", "=", "torch", ".", "cat", "(", "out", ",", "dim", "=", "1", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.RFP.__init__": [[75, 96], ["fpn.FPN.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "rfp.ASPP", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "builder.build_backbone", "rfp.RFP.rfp_modules.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone"], ["def", "__init__", "(", "self", ",", "\n", "rfp_steps", ",", "\n", "rfp_backbone", ",", "\n", "aspp_out_channels", ",", "\n", "aspp_dilations", "=", "(", "1", ",", "3", ",", "6", ",", "1", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "rfp_steps", "=", "rfp_steps", "\n", "self", ".", "rfp_modules", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "rfp_idx", "in", "range", "(", "1", ",", "rfp_steps", ")", ":", "\n", "            ", "rfp_module", "=", "build_backbone", "(", "rfp_backbone", ")", "\n", "self", ".", "rfp_modules", ".", "append", "(", "rfp_module", ")", "\n", "", "self", ".", "rfp_aspp", "=", "ASPP", "(", "self", ".", "out_channels", ",", "aspp_out_channels", ",", "\n", "aspp_dilations", ")", "\n", "self", ".", "rfp_weight", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "out_channels", ",", "\n", "1", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.RFP.init_weights": [[97, 109], ["range", "mmcv.cnn.constant_init", "convs.modules", "rfp.RFP.rfp_modules[].init_weights", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "# Avoid using super().init_weights(), which may alter the default", "\n", "# initialization of the modules in self.rfp_modules that have missing", "\n", "# keys in the pretrained checkpoint.", "\n", "        ", "for", "convs", "in", "[", "self", ".", "lateral_convs", ",", "self", ".", "fpn_convs", "]", ":", "\n", "            ", "for", "m", "in", "convs", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "", "", "", "for", "rfp_idx", "in", "range", "(", "self", ".", "rfp_steps", "-", "1", ")", ":", "\n", "            ", "self", ".", "rfp_modules", "[", "rfp_idx", "]", ".", "init_weights", "(", "\n", "self", ".", "rfp_modules", "[", "rfp_idx", "]", ".", "pretrained", ")", "\n", "", "constant_init", "(", "self", ".", "rfp_weight", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.necks.rfp.RFP.forward": [[110, 129], ["list", "list.pop", "super().forward", "range", "len", "tuple", "rfp.RFP.rfp_modules[].rfp_forward", "super().forward", "range", "len", "list", "len", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "x_new.append", "rfp.RFP.rfp_weight", "rfp.RFP.rfp_aspp", "range", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.rfp_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "inputs", "=", "list", "(", "inputs", ")", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "+", "1", "# +1 for input image", "\n", "img", "=", "inputs", ".", "pop", "(", "0", ")", "\n", "# FPN forward", "\n", "x", "=", "super", "(", ")", ".", "forward", "(", "tuple", "(", "inputs", ")", ")", "\n", "for", "rfp_idx", "in", "range", "(", "self", ".", "rfp_steps", "-", "1", ")", ":", "\n", "            ", "rfp_feats", "=", "[", "x", "[", "0", "]", "]", "+", "list", "(", "\n", "self", ".", "rfp_aspp", "(", "x", "[", "i", "]", ")", "for", "i", "in", "range", "(", "1", ",", "len", "(", "x", ")", ")", ")", "\n", "x_idx", "=", "self", ".", "rfp_modules", "[", "rfp_idx", "]", ".", "rfp_forward", "(", "img", ",", "rfp_feats", ")", "\n", "# FPN forward", "\n", "x_idx", "=", "super", "(", ")", ".", "forward", "(", "x_idx", ")", "\n", "x_new", "=", "[", "]", "\n", "for", "ft_idx", "in", "range", "(", "len", "(", "x_idx", ")", ")", ":", "\n", "                ", "add_weight", "=", "torch", ".", "sigmoid", "(", "self", ".", "rfp_weight", "(", "x_idx", "[", "ft_idx", "]", ")", ")", "\n", "x_new", ".", "append", "(", "add_weight", "*", "x_idx", "[", "ft_idx", "]", "+", "\n", "(", "1", "-", "add_weight", ")", "*", "x", "[", "ft_idx", "]", ")", "\n", "", "x", "=", "x_new", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.__init__": [[82, 119], ["dict", "dict", "torch.Module.__init__", "hasattr", "loss_stuff.pop", "builder.build_loss", "stuff_head.StuffHead._init_layers", "int", "math.log2"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers"], ["def", "__init__", "(", "self", ",", "\n", "stuff_num_classes", ",", "\n", "in_channels", ",", "\n", "feat_channels", "=", "128", ",", "\n", "feat_indexes", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "\n", "feat_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ",", "\n", "out_stride", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ")", ",", "\n", "loss_stuff", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "ignore_index", "=", "255", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "upsample_method", "=", "'bilinear'", ")", ":", "\n", "        ", "super", "(", "StuffHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stuff_num_classes", "=", "stuff_num_classes", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "feat_channels", "=", "feat_channels", "\n", "self", ".", "feat_indexes", "=", "feat_indexes", "\n", "self", ".", "feat_strides", "=", "feat_strides", "\n", "self", ".", "out_stride", "=", "out_stride", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "# add ignore index for loss", "\n", "assert", "hasattr", "(", "loss_stuff", ",", "'ignore_index'", ")", "\n", "self", ".", "ignore_index", "=", "loss_stuff", ".", "pop", "(", "'ignore_index'", ")", "\n", "self", ".", "loss_stuff", "=", "build_loss", "(", "loss_stuff", ")", "\n", "self", ".", "upsample_method", "=", "upsample_method", "\n", "# fp16", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "num_ups", "=", "[", "int", "(", "math", ".", "log2", "(", "feat_stride", "//", "self", ".", "out_stride", ")", ")", "\n", "for", "feat_stride", "in", "self", ".", "feat_strides", "]", "\n", "self", ".", "num_lateral_convs", "=", "[", "num_up", "+", "1", "\n", "if", "num_up", "==", "0", "else", "num_up", "\n", "for", "num_up", "in", "self", ".", "num_ups", "]", "\n", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead._init_layers": [[120, 134], ["torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "zip", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Upsample", "torch.Upsample", "torch.Upsample", "stuff_head._make_stuff_lateral_layers", "stuff_head.StuffHead.lateral_convs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head._make_stuff_lateral_layers"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "# build lateral convs for stuff head", "\n", "        ", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "num_conv", ",", "num_up", "in", "zip", "(", "self", ".", "num_lateral_convs", ",", "self", ".", "num_ups", ")", ":", "\n", "            ", "lateral_conv", "=", "_make_stuff_lateral_layers", "(", "\n", "num_conv", ",", "num_up", ",", "self", ".", "in_channels", ",", "self", ".", "feat_channels", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "upsample_method", "=", "self", ".", "upsample_method", ")", "\n", "self", ".", "lateral_convs", ".", "append", "(", "lateral_conv", ")", "\n", "", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "stuff_num_classes", ",", "\n", "kernel_size", "=", "1", ")", "\n", "self", ".", "upsample", "=", "nn", ".", "Upsample", "(", "\n", "scale_factor", "=", "4", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.init_weights": [[135, 143], ["mmcv.cnn.kaiming_init", "m.modules", "isinstance", "mmcv.cnn.kaiming_init", "isinstance", "mmcv.cnn.constant_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "lateral_convs", ":", "\n", "            ", "for", "mm", "in", "m", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "mm", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "kaiming_init", "(", "mm", ")", "\n", "", "elif", "isinstance", "(", "mm", ",", "(", "nn", ".", "BatchNorm2d", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "                    ", "constant_init", "(", "mm", ",", "1", ")", "\n", "", "", "", "kaiming_init", "(", "self", ".", "conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.forward_single": [[144, 147], ["lateral_conv"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ",", "lateral_conv", ")", ":", "\n", "        ", "up_feat", "=", "lateral_conv", "(", "x", ")", "\n", "return", "up_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.forward": [[148, 156], ["sum", "stuff_head.StuffHead.conv", "stuff_head.StuffHead.upsample", "stuff_head.StuffHead.forward_single", "zip"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward_single"], ["", "def", "forward", "(", "self", ",", "feats", ",", "return_feats", "=", "False", ")", ":", "\n", "        ", "up_feats", "=", "[", "self", ".", "forward_single", "(", "feats", "[", "idx", "]", ",", "lateral_conv", ")", "\n", "for", "idx", ",", "lateral_conv", "in", "zip", "(", "self", ".", "feat_indexes", ",", "\n", "self", ".", "lateral_convs", ")", "]", "\n", "feat_outs", "=", "sum", "(", "up_feats", ")", "\n", "score_maps", "=", "self", ".", "conv", "(", "feat_outs", ")", "\n", "score_maps", "=", "self", ".", "upsample", "(", "score_maps", ")", "\n", "return", "score_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.loss": [[157, 172], ["mmdet.core.force_fp32", "stuff_map_targets.new_zeros", "max", "stuff_head.StuffHead.loss_stuff", "dict", "stuff_map_targets.size", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "stuff_map_targets.squeeze().long", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "stuff_map_targets.squeeze", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'score_maps'", ",", ")", ")", "\n", "def", "loss", "(", "self", ",", "score_maps", ",", "stuff_map_targets", ",", "img_metas", ")", ":", "\n", "        ", "valid_h", ",", "valid_w", ",", "_", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "\n", "stuff_weights", "=", "stuff_map_targets", ".", "new_zeros", "(", "stuff_map_targets", ".", "size", "(", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ")", "\n", "stuff_weights", "[", "...", ",", ":", "valid_h", ",", ":", "valid_w", "]", "=", "1.", "\n", "valid_num_samples", "=", "max", "(", "\n", "torch", ".", "sum", "(", "stuff_weights", ">", "0", ")", ".", "float", "(", ")", ".", "item", "(", ")", ",", "1.", ")", "\n", "# loss stuff", "\n", "loss_stuff", "=", "self", ".", "loss_stuff", "(", "score_maps", ",", "\n", "stuff_map_targets", ".", "squeeze", "(", "1", ")", ".", "long", "(", ")", ",", "\n", "stuff_weights", ",", "\n", "avg_factor", "=", "valid_num_samples", ",", "\n", "ignore_index", "=", "self", ".", "ignore_index", ")", "\n", "return", "dict", "(", "loss_stuff", "=", "loss_stuff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.get_stuff_map": [[173, 205], ["mmdet.core.force_fp32", "isinstance", "isinstance", "range", "score_maps.argmax().cpu().numpy", "stuff_map[].astype", "stuff_segms.append", "dict", "score_maps.argmax().cpu", "score_maps.argmax"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'score_maps'", ",", ")", ")", "\n", "def", "get_stuff_map", "(", "self", ",", "score_maps", ",", "img_metas", ",", "rescale", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get the predicted stuff semantic segmentation masks.\n\n        Args:\n            score_maps (Tensor or ndarray): shape (n, #class, h, w). For\n                single-scale testing, `score_maps` is the direct output of\n                model, whose type is Tensor, while for multi-scale testing,\n                it will be converted to numpy array outside of this method.\n            img_metas (list[dict]): the information for images\n            rescale (bool): rescale to original shape or not.\n        Returns:\n            list[list]: encoded stuff mask\n        \"\"\"", "\n", "if", "isinstance", "(", "score_maps", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "stuff_map", "=", "score_maps", ".", "argmax", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "stuff_map", "=", "score_maps", "\n", "", "assert", "isinstance", "(", "stuff_map", ",", "np", ".", "ndarray", ")", "\n", "\n", "num_imgs", "=", "stuff_map", ".", "shape", "[", "0", "]", "\n", "stuff_segms", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "img_meta", "=", "img_metas", "[", "i", "]", "\n", "img_h", ",", "img_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", ":", "2", "]", "\n", "valid_h", ",", "valid_w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "stuffs", "=", "stuff_map", "[", "i", ",", "...", "]", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "stuffs", "=", "stuffs", "[", ":", "valid_h", ",", ":", "valid_w", "]", "\n", "stuff_segms", ".", "append", "(", "\n", "dict", "(", "stuff_map", "=", "stuffs", ",", "img_shape", "=", "(", "img_w", ",", "img_h", ")", ")", ")", "\n", "", "return", "stuff_segms", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.get_stuff_map_aug": [[206, 265], ["mmdet.core.force_fp32", "isinstance", "len", "range", "len", "score_maps[].new_zeros", "range", "torch.sum.argmax().cpu().numpy", "torch.sum.argmax().cpu().numpy", "torch.sum.argmax().cpu().numpy", "torch.sum.argmax().cpu().numpy.astype", "stuff_segms.append", "torch.interpolate.squeeze", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "score_maps[].new_zeros.new_tensor", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "dict", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "score_maps[].new_zeros.new_tensor.reshape", "score_maps[].new_zeros.new_tensor.sum", "torch.sum.argmax().cpu", "torch.sum.argmax().cpu", "torch.sum.argmax().cpu", "torch.interpolate.unsqueeze", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.sum.argmax", "torch.sum.argmax", "torch.sum.argmax", "torch.interpolate.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'score_maps'", ",", ")", ")", "\n", "def", "get_stuff_map_aug", "(", "self", ",", "\n", "score_maps", ",", "\n", "img_metas", ",", "\n", "rescale", "=", "True", ",", "\n", "weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get the predicted stuff semantic segmentation masks.\n\n        Args:\n            score_maps (list[Tensor or ndarray]): each element with the shape\n                (n, #class, h, w). For single-scale testing, `score_maps` is\n                the direct output of model, whose type is Tensor, while for\n                multi-scale testing, it will be converted to numpy array\n                outside of this method.\n            img_metas (list[list[dict]]): the information for images\n            rescale (bool): rescale to original shape or not.\n            weights (list or Tensor): weights to re-weight the stuff map.\n        Returns:\n            list[list]: encoded stuff mask\n        \"\"\"", "\n", "assert", "isinstance", "(", "score_maps", ",", "list", ")", "\n", "num_scales", "=", "len", "(", "score_maps", ")", "\n", "num_imgs", "=", "score_maps", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "assert", "num_scales", "==", "len", "(", "img_metas", ")", "\n", "stuff_segms", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "score_map_img_size", "=", "(", "num_scales", ",", "score_maps", "[", "0", "]", ".", "shape", "[", "1", "]", ",", ")", "+", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'ori_shape'", "]", "[", ":", "2", "]", "\n", "score_map_img", "=", "score_maps", "[", "0", "]", ".", "new_zeros", "(", "size", "=", "score_map_img_size", ")", "\n", "for", "s", "in", "range", "(", "num_scales", ")", ":", "\n", "                ", "img_meta", "=", "img_metas", "[", "s", "]", "[", "i", "]", "\n", "img_h", ",", "img_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", ":", "2", "]", "\n", "valid_h", ",", "valid_w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "flip", "=", "img_meta", "[", "'flip'", "]", "\n", "score_map_img_scale", "=", "score_maps", "[", "s", "]", "[", "i", "]", "\n", "score_map_img_scale", "=", "score_map_img_scale", "[", "\n", "...", ",", ":", "valid_h", ",", ":", "valid_w", "]", "\n", "if", "rescale", ":", "\n", "                    ", "score_map_img_scale", "=", "F", ".", "interpolate", "(", "\n", "score_map_img_scale", ".", "unsqueeze", "(", "0", ")", ",", "size", "=", "(", "img_h", ",", "img_w", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "", "if", "flip", ":", "\n", "                    ", "inv_idx", "=", "torch", ".", "arange", "(", "\n", "score_map_img_scale", ".", "size", "(", "-", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "score_map_img_scale", "=", "score_map_img_scale", "[", "...", ",", "inv_idx", "]", "\n", "", "score_map_img", "[", "s", ",", "...", "]", "=", "score_map_img_scale", ".", "squeeze", "(", "0", ")", "\n", "", "if", "weights", "is", "None", ":", "\n", "                ", "score_map_img_avg", "=", "torch", ".", "mean", "(", "score_map_img", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                ", "weights", "=", "score_map_img", ".", "new_tensor", "(", "weights", ")", "\n", "weights", "=", "weights", ".", "reshape", "(", "num_scales", ",", "1", ",", "1", ",", "1", ")", "/", "weights", ".", "sum", "(", ")", "\n", "score_map_img_avg", "=", "torch", ".", "sum", "(", "weights", "*", "score_map_img", ",", "dim", "=", "0", ")", "\n", "", "stuff_map", "=", "score_map_img_avg", ".", "argmax", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "stuffs", "=", "stuff_map", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "stuff_segms", ".", "append", "(", "\n", "dict", "(", "stuff_map", "=", "stuffs", ",", "img_shape", "=", "(", "img_w", ",", "img_h", ")", ")", ")", "\n", "", "return", "stuff_segms", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head._make_stuff_lateral_layers": [[13, 65], ["dict", "torch.Sequential", "lateral_conv.append", "range", "mmcv.cnn.ConvModule", "lateral_conv.append", "lateral_conv.append", "mmcv.cnn.ConvModule", "torch.Upsample"], "function", ["None"], ["def", "_make_stuff_lateral_layers", "(", "num_conv", ",", "\n", "num_upsample", ",", "\n", "in_channels", ",", "\n", "feat_channels", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ")", ",", "\n", "upsample_method", "=", "'bilinear'", ")", ":", "\n", "    ", "\"\"\"Tool function to make stuff lateral layers.\n\n    There are two situation:\n        1. the feature map does not need to upsample, only a 3x3 conv is needed\n        2. the feature map needs to upsample, each time we upsample 2x,\n           we use a combine of 3x3 conv + GN + ReLU + Bilinear Upsample 2x.\n\n    Args:\n        num_conv (int): number of conv layers needed in the lateral layer.\n        num_upsample (int): number of upsample times needed in the lateral\n            layer.\n        in_channels (int): number of channels of input.\n        feat_channels (int): number of channels of feature maps.\n        conv_cfg (dict, optional): conv layer config.\n        norm_cfg (dict, optional): norm layer config, we use `GN`.\n    \"\"\"", "\n", "lateral_conv", "=", "[", "]", "\n", "if", "num_conv", "==", "1", "and", "num_upsample", "==", "0", ":", "\n", "        ", "lateral_conv", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "num_conv", "==", "num_upsample", ",", "'each upsampling stage consist of: '", "'3x3 conv + GN + ReLU + 2x bilinea upsample.'", "\n", "for", "i", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "in_chns", "=", "in_channels", "if", "i", "==", "0", "else", "feat_channels", "\n", "lateral_conv", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_chns", ",", "\n", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", ")", "\n", "lateral_conv", ".", "append", "(", "nn", ".", "Upsample", "(", "\n", "scale_factor", "=", "2", ",", "mode", "=", "upsample_method", ",", "align_corners", "=", "True", ")", ")", "\n", "", "", "return", "nn", ".", "Sequential", "(", "*", "lateral_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.nasfcos.NASFCOS.__init__": [[12, 21], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "NASFCOS", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.__init__": [[18, 21], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "BaseDetector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.with_neck": [[22, 26], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_neck", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a neck\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'neck'", ")", "and", "self", ".", "neck", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.with_shared_head": [[29, 33], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_shared_head", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a shared head in the RoI Head\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'roi_head'", ")", "and", "self", ".", "roi_head", ".", "with_shared_head", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.with_bbox": [[34, 39], ["hasattr", "hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_bbox", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a bbox head\"\"\"", "\n", "return", "(", "(", "hasattr", "(", "self", ",", "'roi_head'", ")", "and", "self", ".", "roi_head", ".", "with_bbox", ")", "\n", "or", "(", "hasattr", "(", "self", ",", "'bbox_head'", ")", "and", "self", ".", "bbox_head", "is", "not", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.with_mask": [[40, 45], ["hasattr", "hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a mask head\"\"\"", "\n", "return", "(", "(", "hasattr", "(", "self", ",", "'roi_head'", ")", "and", "self", ".", "roi_head", ".", "with_mask", ")", "\n", "or", "(", "hasattr", "(", "self", ",", "'mask_head'", ")", "and", "self", ".", "mask_head", "is", "not", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feat": [[46, 50], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "\"\"\"Extract features from images.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feats": [[51, 63], ["isinstance", "base.BaseDetector.extract_feat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat"], ["", "def", "extract_feats", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "\"\"\"Extract features from multiple images.\n\n        Args:\n            imgs (list[torch.Tensor]): A list of images. The images are\n                augmented from the same image but in different ways.\n\n        Returns:\n            list[torch.Tensor]: Features of different images\n        \"\"\"", "\n", "assert", "isinstance", "(", "imgs", ",", "list", ")", "\n", "return", "[", "self", ".", "extract_feat", "(", "img", ")", "for", "img", "in", "imgs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.forward_train": [[64, 78], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward_train", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (list[Tensor]): List of tensors of shape (1, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and my also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys, see\n                :class:`mmdet.datasets.pipelines.Collect`.\n            kwargs (keyword arguments): Specific to concrete implementation.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.simple_test": [[82, 85], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.aug_test": [[86, 90], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.init_weights": [[91, 101], ["mmdet.utils.get_root_logger", "mmcv.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in detector.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "print_log", "(", "f'load model from: {pretrained}'", ",", "logger", "=", "logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.forward_test": [[120, 155], ["len", "imgs[].size", "len", "ValueError", "base.BaseDetector.simple_test", "base.BaseDetector.aug_test", "isinstance", "TypeError", "len", "len", "type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.simple_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.aug_test"], ["", "", "def", "forward_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            imgs (List[Tensor]): the outer list indicates test-time\n                augmentations and inner Tensor should have a shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (List[List[dict]]): the outer list indicates test-time\n                augs (multiscale, flip, etc.) and the inner list indicates\n                images in a batch.\n        \"\"\"", "\n", "for", "var", ",", "name", "in", "[", "(", "imgs", ",", "'imgs'", ")", ",", "(", "img_metas", ",", "'img_metas'", ")", "]", ":", "\n", "            ", "if", "not", "isinstance", "(", "var", ",", "list", ")", ":", "\n", "                ", "raise", "TypeError", "(", "f'{name} must be a list, but got {type(var)}'", ")", "\n", "\n", "", "", "num_augs", "=", "len", "(", "imgs", ")", "\n", "if", "num_augs", "!=", "len", "(", "img_metas", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f'num of augmentations ({len(imgs)}) '", "\n", "f'!= num of image meta ({len(img_metas)})'", ")", "\n", "# TODO: remove the restriction of samples_per_gpu == 1 when prepared", "\n", "", "samples_per_gpu", "=", "imgs", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "assert", "samples_per_gpu", "==", "1", "\n", "\n", "if", "num_augs", "==", "1", ":", "\n", "# proposals (List[List[Tensor]]): the outer list indicates", "\n", "# test-time augs (multiscale, flip, etc.) and the inner list", "\n", "# indicates images in a batch.", "\n", "# The Tensor should have a shape Px4, where P is the number of", "\n", "# proposals.", "\n", "            ", "if", "'proposals'", "in", "kwargs", ":", "\n", "                ", "kwargs", "[", "'proposals'", "]", "=", "kwargs", "[", "'proposals'", "]", "[", "0", "]", "\n", "", "return", "self", ".", "simple_test", "(", "imgs", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# TODO: support test augmentation for predefined proposals", "\n", "            ", "assert", "'proposals'", "not", "in", "kwargs", "\n", "return", "self", ".", "aug_test", "(", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.forward": [[156, 171], ["mmdet.core.auto_fp16", "base.BaseDetector.forward_train", "base.BaseDetector.forward_test"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fast_rcnn.FastRCNN.forward_test"], ["", "", "@", "auto_fp16", "(", "apply_to", "=", "(", "'img'", ",", ")", ")", "\n", "def", "forward", "(", "self", ",", "img", ",", "img_metas", ",", "return_loss", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Calls either :func:`forward_train` or :func:`forward_test` depending\n        on whether ``return_loss`` is ``True``.\n\n        Note this setting will change the expected inputs. When\n        ``return_loss=True``, img and img_meta are single-nested (i.e. Tensor\n        and List[dict]), and when ``resturn_loss=False``, img and img_meta\n        should be double nested (i.e.  List[Tensor], List[List[dict]]), with\n        the outer list indicating test time augmentations.\n        \"\"\"", "\n", "if", "return_loss", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "forward_test", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses": [[172, 206], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.data.clone.item", "loss_value.data.clone.data.clone.mean", "isinstance", "torch.is_available", "torch.is_available", "torch.is_available", "torch.is_initialized", "torch.is_initialized", "torch.is_initialized", "loss_value.data.clone.data.clone.data.clone", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.data.clone.div_", "torch.get_world_size", "torch.get_world_size", "torch.get_world_size", "_loss.mean"], "methods", ["None"], ["", "", "def", "_parse_losses", "(", "self", ",", "losses", ")", ":", "\n", "        ", "\"\"\"Parse the raw outputs (losses) of the network.\n\n        Args:\n            losses (dict): Raw output of the network, which usually contain\n                losses and other necessary infomation.\n\n        Returns:\n            tuple[Tensor, dict]: (loss, log_vars), loss is the loss tensor \\\n                which may be a weighted sum of all losses, log_vars contains \\\n                all the variables to be sent to the logger.\n        \"\"\"", "\n", "log_vars", "=", "OrderedDict", "(", ")", "\n", "for", "loss_name", ",", "loss_value", "in", "losses", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "loss_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "mean", "(", ")", "\n", "", "elif", "isinstance", "(", "loss_value", ",", "list", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "sum", "(", "_loss", ".", "mean", "(", ")", "for", "_loss", "in", "loss_value", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "f'{loss_name} is not a tensor or list of tensors'", ")", "\n", "\n", "", "", "loss", "=", "sum", "(", "_value", "for", "_key", ",", "_value", "in", "log_vars", ".", "items", "(", ")", "\n", "if", "'loss'", "in", "_key", ")", "\n", "\n", "log_vars", "[", "'loss'", "]", "=", "loss", "\n", "for", "loss_name", ",", "loss_value", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "# reduce loss when distributed training", "\n", "            ", "if", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ":", "\n", "                ", "loss_value", "=", "loss_value", ".", "data", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "loss_value", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ")", "\n", "", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "item", "(", ")", "\n", "\n", "", "return", "loss", ",", "log_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.train_step": [[207, 241], ["base.BaseDetector.", "base.BaseDetector._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses"], ["", "def", "train_step", "(", "self", ",", "data", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"The iteration step during training.\n\n        This method defines an iteration step during training, except for the\n        back propagation and optimizer updating, which are done in an optimizer\n        hook. Note that in some complicated cases or models, the whole process\n        including back propagation and optimizer updating is also defined in\n        this method, such as GAN.\n\n        Args:\n            data (dict): The output of dataloader.\n            optimizer (:obj:`torch.optim.Optimizer` | dict): The optimizer of\n                runner is passed to ``train_step()``. This argument is unused\n                and reserved.\n\n        Returns:\n            dict: It should contain at least 3 keys: ``loss``, ``log_vars``, \\\n                ``num_samples``.\n\n                - ``loss`` is a tensor for back propagation, which can be a \\\n                weighted sum of multiple losses.\n                - ``log_vars`` contains all the variables to be sent to the\n                logger.\n                - ``num_samples`` indicates the batch size (when the model is \\\n                DDP, it means the batch size on each GPU), which is used for \\\n                averaging the logs.\n        \"\"\"", "\n", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "\n", "outputs", "=", "dict", "(", "\n", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "num_samples", "=", "len", "(", "data", "[", "'img_metas'", "]", ")", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.val_step": [[242, 256], ["base.BaseDetector.", "base.BaseDetector._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses"], ["", "def", "val_step", "(", "self", ",", "data", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"The iteration step during validation.\n\n        This method shares the same signature as :func:`train_step`, but used\n        during val epochs. Note that the evaluation after training epochs is\n        not implemented with this method, but an evaluation hook.\n        \"\"\"", "\n", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "\n", "outputs", "=", "dict", "(", "\n", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "num_samples", "=", "len", "(", "data", "[", "'img_metas'", "]", ")", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.show_result": [[257, 341], ["mmcv.imread", "img.copy.copy.copy", "isinstance", "numpy.vstack", "numpy.concatenate", "mmcv.imshow_det_bboxes", "isinstance", "numpy.full", "mmcv.concat_list", "numpy.random.seed", "enumerate", "len", "numpy.where", "numpy.random.randint", "int", "range", "max"], "methods", ["None"], ["", "def", "show_result", "(", "self", ",", "\n", "img", ",", "\n", "result", ",", "\n", "score_thr", "=", "0.3", ",", "\n", "bbox_color", "=", "'green'", ",", "\n", "text_color", "=", "'green'", ",", "\n", "thickness", "=", "1", ",", "\n", "font_scale", "=", "0.5", ",", "\n", "win_name", "=", "''", ",", "\n", "show", "=", "False", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "        ", "\"\"\"Draw `result` over `img`.\n\n        Args:\n            img (str or Tensor): The image to be displayed.\n            result (Tensor or tuple): The results to draw over `img`\n                bbox_result or (bbox_result, segm_result).\n            score_thr (float, optional): Minimum score of bboxes to be shown.\n                Default: 0.3.\n            bbox_color (str or tuple or :obj:`Color`): Color of bbox lines.\n            text_color (str or tuple or :obj:`Color`): Color of texts.\n            thickness (int): Thickness of lines.\n            font_scale (float): Font scales of texts.\n            win_name (str): The window name.\n            wait_time (int): Value of waitKey param.\n                Default: 0.\n            show (bool): Whether to show the image.\n                Default: False.\n            out_file (str or None): The filename to write the image.\n                Default: None.\n\n        Returns:\n            img (Tensor): Only if not `show` or `out_file`\n        \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "if", "isinstance", "(", "result", ",", "tuple", ")", ":", "\n", "            ", "bbox_result", ",", "segm_result", "=", "result", "\n", "if", "isinstance", "(", "segm_result", ",", "tuple", ")", ":", "\n", "                ", "segm_result", "=", "segm_result", "[", "0", "]", "# ms rcnn", "\n", "", "", "else", ":", "\n", "            ", "bbox_result", ",", "segm_result", "=", "result", ",", "None", "\n", "", "bboxes", "=", "np", ".", "vstack", "(", "bbox_result", ")", "\n", "labels", "=", "[", "\n", "np", ".", "full", "(", "bbox", ".", "shape", "[", "0", "]", ",", "i", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", ",", "bbox", "in", "enumerate", "(", "bbox_result", ")", "\n", "]", "\n", "labels", "=", "np", ".", "concatenate", "(", "labels", ")", "\n", "# draw segmentation masks", "\n", "if", "segm_result", "is", "not", "None", "and", "len", "(", "labels", ")", ">", "0", ":", "# non empty", "\n", "            ", "segms", "=", "mmcv", ".", "concat_list", "(", "segm_result", ")", "\n", "inds", "=", "np", ".", "where", "(", "bboxes", "[", ":", ",", "-", "1", "]", ">", "score_thr", ")", "[", "0", "]", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "color_masks", "=", "[", "\n", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "(", "1", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "_", "in", "range", "(", "max", "(", "labels", ")", "+", "1", ")", "\n", "]", "\n", "for", "i", "in", "inds", ":", "\n", "                ", "i", "=", "int", "(", "i", ")", "\n", "color_mask", "=", "color_masks", "[", "labels", "[", "i", "]", "]", "\n", "mask", "=", "segms", "[", "i", "]", "\n", "img", "[", "mask", "]", "=", "img", "[", "mask", "]", "*", "0.5", "+", "color_mask", "*", "0.5", "\n", "# if out_file specified, do not show image in window", "\n", "", "", "if", "out_file", "is", "not", "None", ":", "\n", "            ", "show", "=", "False", "\n", "# draw bounding boxes", "\n", "", "mmcv", ".", "imshow_det_bboxes", "(", "\n", "img", ",", "\n", "bboxes", ",", "\n", "labels", ",", "\n", "class_names", "=", "self", ".", "CLASSES", ",", "\n", "score_thr", "=", "score_thr", ",", "\n", "bbox_color", "=", "bbox_color", ",", "\n", "text_color", "=", "text_color", ",", "\n", "thickness", "=", "thickness", ",", "\n", "font_scale", "=", "font_scale", ",", "\n", "win_name", "=", "win_name", ",", "\n", "show", "=", "show", ",", "\n", "wait_time", "=", "wait_time", ",", "\n", "out_file", "=", "out_file", ")", "\n", "\n", "if", "not", "(", "show", "or", "out_file", ")", ":", "\n", "            ", "return", "img", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.__init__": [[12, 29], ["base.BaseDetector.__init__", "builder.build_backbone", "rpn_head.update", "rpn_head.update", "builder.build_head", "rpn.RPN.init_weights", "builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_neck"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "rpn_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "RPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "if", "neck", "is", "not", "None", "else", "None", "\n", "rpn_train_cfg", "=", "train_cfg", ".", "rpn", "if", "train_cfg", "is", "not", "None", "else", "None", "\n", "rpn_head", ".", "update", "(", "train_cfg", "=", "rpn_train_cfg", ")", "\n", "rpn_head", ".", "update", "(", "test_cfg", "=", "test_cfg", ".", "rpn", ")", "\n", "self", ".", "rpn_head", "=", "build_head", "(", "rpn_head", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.init_weights": [[30, 42], ["super().init_weights", "rpn.RPN.backbone.init_weights", "rpn.RPN.rpn_head.init_weights", "rpn.RPN.neck.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in detector.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "RPN", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "self", ".", "neck", ".", "init_weights", "(", ")", "\n", "", "self", ".", "rpn_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.extract_feat": [[43, 57], ["rpn.RPN.backbone", "rpn.RPN.neck"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Extract features.\n\n        Args:\n            img (torch.Tensor): Image tensor with shape (n, c, h ,w).\n\n        Returns:\n            list[torch.Tensor]: Multi-level features that may have\n                different resolutions.\n        \"\"\"", "\n", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "x", "=", "self", ".", "neck", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.forward_dummy": [[58, 63], ["rpn.RPN.extract_feat", "rpn.RPN.rpn_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat"], ["", "def", "forward_dummy", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Dummy forward function.\"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "rpn_outs", "=", "self", ".", "rpn_head", "(", "x", ")", "\n", "return", "rpn_outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.forward_train": [[64, 93], ["rpn.RPN.train_cfg.rpn.get", "rpn.RPN.extract_feat", "rpn.RPN.rpn_head.forward_train", "mmdet.core.tensor2imgs"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.tensor2imgs"], ["", "def", "forward_train", "(", "self", ",", "\n", "img", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "None", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n            gt_bboxes (list[Tensor]): Each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_bboxes_ignore (None | list[Tensor]): Specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "if", "self", ".", "train_cfg", ".", "rpn", ".", "get", "(", "'debug'", ",", "False", ")", ":", "\n", "            ", "self", ".", "rpn_head", ".", "debug_imgs", "=", "tensor2imgs", "(", "img", ")", "\n", "\n", "", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "losses", "=", "self", ".", "rpn_head", ".", "forward_train", "(", "x", ",", "img_metas", ",", "gt_bboxes", ",", "None", ",", "\n", "gt_bboxes_ignore", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.simple_test": [[94, 114], ["rpn.RPN.extract_feat", "rpn.RPN.rpn_head.simple_test_rpn", "proposal_list[].cpu().numpy", "zip", "proposals.new_tensor", "proposal_list[].cpu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.simple_test_rpn"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function without test time augmentation.\n\n        Args:\n            imgs (list[torch.Tensor]): List of multiple images\n            img_metas (list[dict]): List of image information.\n            rescale (bool, optional): Whether to rescale the results.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: proposals\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "proposal_list", "=", "self", ".", "rpn_head", ".", "simple_test_rpn", "(", "x", ",", "img_metas", ")", "\n", "if", "rescale", ":", "\n", "            ", "for", "proposals", ",", "meta", "in", "zip", "(", "proposal_list", ",", "img_metas", ")", ":", "\n", "                ", "proposals", "[", ":", ",", ":", "4", "]", "/=", "proposals", ".", "new_tensor", "(", "meta", "[", "'scale_factor'", "]", ")", "\n", "\n", "# TODO: remove this restriction", "\n", "", "", "return", "proposal_list", "[", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.aug_test": [[115, 140], ["rpn.RPN.rpn_head.aug_test_rpn", "proposal_list[].cpu().numpy", "rpn.RPN.extract_feats", "zip", "mmdet.core.bbox_mapping", "proposal_list[].cpu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.aug_test_rpn", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (list[torch.Tensor]): List of multiple images\n            img_metas (list[dict]): List of image information.\n            rescale (bool, optional): Whether to rescale the results.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: proposals\n        \"\"\"", "\n", "proposal_list", "=", "self", ".", "rpn_head", ".", "aug_test_rpn", "(", "\n", "self", ".", "extract_feats", "(", "imgs", ")", ",", "img_metas", ")", "\n", "if", "not", "rescale", ":", "\n", "            ", "for", "proposals", ",", "img_meta", "in", "zip", "(", "proposal_list", ",", "img_metas", "[", "0", "]", ")", ":", "\n", "                ", "img_shape", "=", "img_meta", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "'flip_direction'", "]", "\n", "proposals", "[", ":", ",", ":", "4", "]", "=", "bbox_mapping", "(", "proposals", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "\n", "flip_direction", ")", "\n", "# TODO: remove this restriction", "\n", "", "", "return", "proposal_list", "[", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.rpn.RPN.show_result": [[141, 155], ["mmdet.core.tensor2imgs", "zip", "len", "len", "mmcv.imshow_bboxes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.tensor2imgs"], ["", "def", "show_result", "(", "self", ",", "data", ",", "result", ",", "dataset", "=", "None", ",", "top_k", "=", "20", ")", ":", "\n", "        ", "\"\"\"Show RPN proposals on the image.\n\n        Although we assume batch size is 1, this method supports arbitrary\n        batch size.\n        \"\"\"", "\n", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "for", "img", ",", "img_meta", "in", "zip", "(", "imgs", ",", "img_metas", ")", ":", "\n", "            ", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "mmcv", ".", "imshow_bboxes", "(", "img_show", ",", "result", ",", "top_k", "=", "top_k", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.retinanet.RetinaNet.__init__": [[9, 18], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "RetinaNet", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fast_rcnn.FastRCNN.__init__": [[9, 23], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "FastRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fast_rcnn.FastRCNN.forward_test": [[24, 56], ["len", "imgs[].size", "len", "ValueError", "fast_rcnn.FastRCNN.simple_test", "isinstance", "TypeError", "len", "len", "type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.simple_test"], ["", "def", "forward_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "proposals", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            imgs (List[Tensor]): the outer list indicates test-time\n                augmentations and inner Tensor should have a shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (List[List[dict]]): the outer list indicates test-time\n                augs (multiscale, flip, etc.) and the inner list indicates\n                images in a batch.\n            proposals (List[List[Tensor]]): the outer list indicates test-time\n                augs (multiscale, flip, etc.) and the inner list indicates\n                images in a batch. The Tensor should have a shape Px4, where\n                P is the number of proposals.\n        \"\"\"", "\n", "for", "var", ",", "name", "in", "[", "(", "imgs", ",", "'imgs'", ")", ",", "(", "img_metas", ",", "'img_metas'", ")", "]", ":", "\n", "            ", "if", "not", "isinstance", "(", "var", ",", "list", ")", ":", "\n", "                ", "raise", "TypeError", "(", "f'{name} must be a list, but got {type(var)}'", ")", "\n", "\n", "", "", "num_augs", "=", "len", "(", "imgs", ")", "\n", "if", "num_augs", "!=", "len", "(", "img_metas", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f'num of augmentations ({len(imgs)}) '", "\n", "f'!= num of image meta ({len(img_metas)})'", ")", "\n", "# TODO: remove the restriction of samples_per_gpu == 1 when prepared", "\n", "", "samples_per_gpu", "=", "imgs", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "assert", "samples_per_gpu", "==", "1", "\n", "\n", "if", "num_augs", "==", "1", ":", "\n", "            ", "return", "self", ".", "simple_test", "(", "imgs", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "proposals", "[", "0", "]", ",", "\n", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# TODO: support test-time augmentation", "\n", "            ", "assert", "NotImplementedError", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fovea.FOVEA.__init__": [[9, 18], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "FOVEA", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cornernet.CornerNet.__init__": [[16, 25], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "CornerNet", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cornernet.CornerNet.merge_aug_results": [[26, 59], ["zip", "torch.cat", "torch.cat", "mmdet.core.bbox_mapping_back", "recovered_bboxes.append", "aug_labels.append", "cornernet.CornerNet.bbox_head._bboxes_nms", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping_back", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._bboxes_nms"], ["", "def", "merge_aug_results", "(", "self", ",", "aug_results", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Merge augmented detection bboxes and score.\n\n        Args:\n            aug_results (list[list[Tensor]]): Det_bboxes and det_labels of each\n                image.\n            img_metas (list[list[dict]]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n\n        Returns:\n            tuple: (bboxes, labels)\n        \"\"\"", "\n", "recovered_bboxes", ",", "aug_labels", "=", "[", "]", ",", "[", "]", "\n", "for", "bboxes_labels", ",", "img_info", "in", "zip", "(", "aug_results", ",", "img_metas", ")", ":", "\n", "            ", "img_shape", "=", "img_info", "[", "0", "]", "[", "'img_shape'", "]", "# using shape before padding", "\n", "scale_factor", "=", "img_info", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_info", "[", "0", "]", "[", "'flip'", "]", "\n", "bboxes", ",", "labels", "=", "bboxes_labels", "\n", "bboxes", ",", "scores", "=", "bboxes", "[", ":", ",", ":", "4", "]", ",", "bboxes", "[", ":", ",", "-", "1", ":", "]", "\n", "bboxes", "=", "bbox_mapping_back", "(", "bboxes", ",", "img_shape", ",", "scale_factor", ",", "flip", ")", "\n", "recovered_bboxes", ".", "append", "(", "torch", ".", "cat", "(", "[", "bboxes", ",", "scores", "]", ",", "dim", "=", "-", "1", ")", ")", "\n", "aug_labels", ".", "append", "(", "labels", ")", "\n", "\n", "", "bboxes", "=", "torch", ".", "cat", "(", "recovered_bboxes", ",", "dim", "=", "0", ")", "\n", "labels", "=", "torch", ".", "cat", "(", "aug_labels", ")", "\n", "\n", "if", "bboxes", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "out_bboxes", ",", "out_labels", "=", "self", ".", "bbox_head", ".", "_bboxes_nms", "(", "\n", "bboxes", ",", "labels", ",", "self", ".", "bbox_head", ".", "test_cfg", ")", "\n", "", "else", ":", "\n", "            ", "out_bboxes", ",", "out_labels", "=", "bboxes", ",", "labels", "\n", "\n", "", "return", "out_bboxes", ",", "out_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cornernet.CornerNet.aug_test": [[60, 94], ["list", "zip", "cornernet.CornerNet.merge_aug_results", "mmdet.core.bbox2result", "range", "torch.cat", "cornernet.CornerNet.extract_feat", "cornernet.CornerNet.bbox_head", "cornernet.CornerNet.bbox_head.get_bboxes", "aug_results.append", "aug_results.append", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.reppoints_detector.RepPointsDetector.merge_aug_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Augment testing of CornerNet.\n\n        Args:\n            imgs (list[Tensor]): Augmented images.\n            img_metas (list[list[dict]]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n\n        Note:\n            ``imgs`` must including flipped image pairs.\n\n        Returns:\n            bbox_results (tuple[np.ndarry]): Detection result of each class.\n        \"\"\"", "\n", "img_inds", "=", "list", "(", "range", "(", "len", "(", "imgs", ")", ")", ")", "\n", "\n", "assert", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'flip'", "]", "+", "img_metas", "[", "1", "]", "[", "0", "]", "[", "'flip'", "]", ",", "(", "\n", "'aug test must have flipped image pair'", ")", "\n", "aug_results", "=", "[", "]", "\n", "for", "ind", ",", "flip_ind", "in", "zip", "(", "img_inds", "[", "0", ":", ":", "2", "]", ",", "img_inds", "[", "1", ":", ":", "2", "]", ")", ":", "\n", "            ", "img_pair", "=", "torch", ".", "cat", "(", "[", "imgs", "[", "ind", "]", ",", "imgs", "[", "flip_ind", "]", "]", ")", "\n", "x", "=", "self", ".", "extract_feat", "(", "img_pair", ")", "\n", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_list", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "\n", "*", "outs", ",", "[", "img_metas", "[", "ind", "]", ",", "img_metas", "[", "flip_ind", "]", "]", ",", "False", ",", "False", ")", "\n", "aug_results", ".", "append", "(", "bbox_list", "[", "0", "]", ")", "\n", "aug_results", ".", "append", "(", "bbox_list", "[", "1", "]", ")", "\n", "\n", "", "bboxes", ",", "labels", "=", "self", ".", "merge_aug_results", "(", "aug_results", ",", "img_metas", ")", "\n", "bbox_results", "=", "bbox2result", "(", "bboxes", ",", "labels", ",", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "\n", "return", "bbox_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.atss.ATSS.__init__": [[9, 18], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "ATSS", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.htc.HybridTaskCascade.__init__": [[9, 11], ["cascade_rcnn.CascadeRCNN.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "HybridTaskCascade", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.htc.HybridTaskCascade.with_semantic": [[12, 16], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_semantic", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a semantic head\"\"\"", "\n", "return", "self", ".", "roi_head", ".", "with_semantic", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.__init__": [[17, 49], ["base.BaseDetector.__init__", "builder.build_backbone", "two_stage.TwoStageDetector.init_weights", "builder.build_neck", "rpn_head.copy", "rpn_head.copy.update", "builder.build_head", "roi_head.update", "roi_head.update", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_neck", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "rpn_head", "=", "None", ",", "\n", "roi_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "TwoStageDetector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "\n", "if", "neck", "is", "not", "None", ":", "\n", "            ", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "\n", "", "if", "rpn_head", "is", "not", "None", ":", "\n", "            ", "rpn_train_cfg", "=", "train_cfg", ".", "rpn", "if", "train_cfg", "is", "not", "None", "else", "None", "\n", "rpn_head_", "=", "rpn_head", ".", "copy", "(", ")", "\n", "rpn_head_", ".", "update", "(", "train_cfg", "=", "rpn_train_cfg", ",", "test_cfg", "=", "test_cfg", ".", "rpn", ")", "\n", "self", ".", "rpn_head", "=", "build_head", "(", "rpn_head_", ")", "\n", "\n", "", "if", "roi_head", "is", "not", "None", ":", "\n", "# update train and test cfg here for now", "\n", "# TODO: refactor assigner & sampler", "\n", "            ", "rcnn_train_cfg", "=", "train_cfg", ".", "rcnn", "if", "train_cfg", "is", "not", "None", "else", "None", "\n", "roi_head", ".", "update", "(", "train_cfg", "=", "rcnn_train_cfg", ")", "\n", "roi_head", ".", "update", "(", "test_cfg", "=", "test_cfg", ".", "rcnn", ")", "\n", "self", ".", "roi_head", "=", "build_head", "(", "roi_head", ")", "\n", "\n", "", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.with_rpn": [[50, 54], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_rpn", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has RPN\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'rpn_head'", ")", "and", "self", ".", "rpn_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.with_roi_head": [[55, 59], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_roi_head", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the detector has a RoI head\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'roi_head'", ")", "and", "self", ".", "roi_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.init_weights": [[60, 79], ["super().init_weights", "two_stage.TwoStageDetector.backbone.init_weights", "isinstance", "two_stage.TwoStageDetector.rpn_head.init_weights", "two_stage.TwoStageDetector.roi_head.init_weights", "two_stage.TwoStageDetector.neck.init_weights", "m.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in detector.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "TwoStageDetector", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "neck", ",", "nn", ".", "Sequential", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "neck", ":", "\n", "                    ", "m", ".", "init_weights", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "neck", ".", "init_weights", "(", ")", "\n", "", "", "if", "self", ".", "with_rpn", ":", "\n", "            ", "self", ".", "rpn_head", ".", "init_weights", "(", ")", "\n", "", "if", "self", ".", "with_roi_head", ":", "\n", "            ", "self", ".", "roi_head", ".", "init_weights", "(", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.extract_feat": [[80, 86], ["two_stage.TwoStageDetector.backbone", "two_stage.TwoStageDetector.neck"], "methods", ["None"], ["", "", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Directly extract features from the backbone+neck.\"\"\"", "\n", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "x", "=", "self", ".", "neck", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.forward_dummy": [[87, 104], ["two_stage.TwoStageDetector.extract_feat", "torch.randn().to", "torch.randn().to", "torch.randn().to", "torch.randn().to", "two_stage.TwoStageDetector.roi_head.forward_dummy", "two_stage.TwoStageDetector.rpn_head", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.forward_dummy"], ["", "def", "forward_dummy", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Used for computing network flops.\n\n        See `mmdetection/tools/get_flops.py`\n        \"\"\"", "\n", "outs", "=", "(", ")", "\n", "# backbone", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "# rpn", "\n", "if", "self", ".", "with_rpn", ":", "\n", "            ", "rpn_outs", "=", "self", ".", "rpn_head", "(", "x", ")", "\n", "outs", "=", "outs", "+", "(", "rpn_outs", ",", ")", "\n", "", "proposals", "=", "torch", ".", "randn", "(", "1000", ",", "4", ")", ".", "to", "(", "img", ".", "device", ")", "\n", "# roi_head", "\n", "roi_outs", "=", "self", ".", "roi_head", ".", "forward_dummy", "(", "x", ",", "proposals", ")", "\n", "outs", "=", "outs", "+", "(", "roi_outs", ",", ")", "\n", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.forward_train": [[105, 168], ["two_stage.TwoStageDetector.extract_feat", "dict", "two_stage.TwoStageDetector.roi_head.forward_train", "dict.update", "two_stage.TwoStageDetector.train_cfg.get", "two_stage.TwoStageDetector.rpn_head.forward_train", "dict.update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train"], ["", "def", "forward_train", "(", "self", ",", "\n", "img", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ",", "\n", "proposals", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (Tensor): of shape (N, C, H, W) encoding input images.\n                Typically these should be mean centered and std scaled.\n\n            img_metas (list[dict]): list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n\n            gt_labels (list[Tensor]): class indices corresponding to each box\n\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n            gt_masks (None | Tensor) : true segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n            proposals : override rpn proposals with custom proposals. Use when\n                `with_rpn` is False.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "losses", "=", "dict", "(", ")", "\n", "\n", "# RPN forward and loss", "\n", "if", "self", ".", "with_rpn", ":", "\n", "            ", "proposal_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'rpn_proposal'", ",", "\n", "self", ".", "test_cfg", ".", "rpn", ")", "\n", "rpn_losses", ",", "proposal_list", "=", "self", ".", "rpn_head", ".", "forward_train", "(", "\n", "x", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "None", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "proposal_cfg", "=", "proposal_cfg", ")", "\n", "losses", ".", "update", "(", "rpn_losses", ")", "\n", "", "else", ":", "\n", "            ", "proposal_list", "=", "proposals", "\n", "\n", "", "roi_losses", "=", "self", ".", "roi_head", ".", "forward_train", "(", "x", ",", "img_metas", ",", "proposal_list", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "gt_bboxes_ignore", ",", "gt_masks", ",", "\n", "**", "kwargs", ")", "\n", "losses", ".", "update", "(", "roi_losses", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.simple_test": [[187, 200], ["two_stage.TwoStageDetector.extract_feat", "two_stage.TwoStageDetector.roi_head.simple_test", "two_stage.TwoStageDetector.rpn_head.simple_test_rpn"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.simple_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.simple_test_rpn"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "proposals", "=", "None", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "assert", "self", ".", "with_bbox", ",", "'Bbox head must be implemented.'", "\n", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "if", "proposals", "is", "None", ":", "\n", "            ", "proposal_list", "=", "self", ".", "rpn_head", ".", "simple_test_rpn", "(", "x", ",", "img_metas", ")", "\n", "", "else", ":", "\n", "            ", "proposal_list", "=", "proposals", "\n", "\n", "", "return", "self", ".", "roi_head", ".", "simple_test", "(", "\n", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "rescale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.two_stage.TwoStageDetector.aug_test": [[201, 212], ["two_stage.TwoStageDetector.extract_feats", "two_stage.TwoStageDetector.rpn_head.aug_test_rpn", "two_stage.TwoStageDetector.roi_head.aug_test"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.aug_test_rpn", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.aug_test"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test with augmentations.\n\n        If rescale is False, then returned bboxes and masks will fit the scale\n        of imgs[0].\n        \"\"\"", "\n", "# recompute feats to save memory", "\n", "x", "=", "self", ".", "extract_feats", "(", "imgs", ")", "\n", "proposal_list", "=", "self", ".", "rpn_head", ".", "aug_test_rpn", "(", "x", ",", "img_metas", ")", "\n", "return", "self", ".", "roi_head", ".", "aug_test", "(", "\n", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "rescale", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.__init__": [[17, 34], ["base.BaseDetector.__init__", "builder.build_backbone", "bbox_head.update", "bbox_head.update", "builder.build_head", "single_stage.SingleStageDetector.init_weights", "builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_neck"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "SingleStageDetector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "if", "neck", "is", "not", "None", ":", "\n", "            ", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "", "bbox_head", ".", "update", "(", "train_cfg", "=", "train_cfg", ")", "\n", "bbox_head", ".", "update", "(", "test_cfg", "=", "test_cfg", ")", "\n", "self", ".", "bbox_head", "=", "build_head", "(", "bbox_head", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.init_weights": [[35, 51], ["super().init_weights", "single_stage.SingleStageDetector.backbone.init_weights", "single_stage.SingleStageDetector.bbox_head.init_weights", "isinstance", "single_stage.SingleStageDetector.neck.init_weights", "m.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in detector.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "SingleStageDetector", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "neck", ",", "nn", ".", "Sequential", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "neck", ":", "\n", "                    ", "m", ".", "init_weights", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "neck", ".", "init_weights", "(", ")", "\n", "", "", "self", ".", "bbox_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.extract_feat": [[52, 58], ["single_stage.SingleStageDetector.backbone", "single_stage.SingleStageDetector.neck"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Directly extract features from the backbone+neck.\"\"\"", "\n", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "x", "=", "self", ".", "neck", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.forward_dummy": [[59, 67], ["single_stage.SingleStageDetector.extract_feat", "single_stage.SingleStageDetector.bbox_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat"], ["", "def", "forward_dummy", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Used for computing network flops.\n\n        See `mmdetection/tools/get_flops.py`\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.forward_train": [[68, 96], ["single_stage.SingleStageDetector.extract_feat", "single_stage.SingleStageDetector.bbox_head.forward_train"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train"], ["", "def", "forward_train", "(", "self", ",", "\n", "img", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n            gt_bboxes (list[Tensor]): Each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): Class indices corresponding to each box\n            gt_bboxes_ignore (None | list[Tensor]): Specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "losses", "=", "self", ".", "bbox_head", ".", "forward_train", "(", "x", ",", "img_metas", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "gt_bboxes_ignore", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.simple_test": [[97, 122], ["single_stage.SingleStageDetector.extract_feat", "single_stage.SingleStageDetector.bbox_head", "single_stage.SingleStageDetector.bbox_head.get_bboxes", "torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export", "mmdet.core.bbox2result"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function without test time augmentation.\n\n        Args:\n            imgs (list[torch.Tensor]): List of multiple images\n            img_metas (list[dict]): List of image information.\n            rescale (bool, optional): Whether to rescale the results.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: proposals\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_list", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "\n", "*", "outs", ",", "img_metas", ",", "rescale", "=", "rescale", ")", "\n", "# skip post-processing when exporting to ONNX", "\n", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "            ", "return", "bbox_list", "\n", "\n", "", "bbox_results", "=", "[", "\n", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "for", "det_bboxes", ",", "det_labels", "in", "bbox_list", "\n", "]", "\n", "return", "bbox_results", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.single_stage.SingleStageDetector.aug_test": [[123, 126], ["None"], "methods", ["None"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.reppoints_detector.RepPointsDetector.__init__": [[16, 26], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "RepPointsDetector", ",", "\n", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "test_cfg", ",", "\n", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.reppoints_detector.RepPointsDetector.merge_aug_results": [[27, 53], ["zip", "torch.cat", "mmdet.core.bbox_mapping_back", "recovered_bboxes.append", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping_back"], ["", "def", "merge_aug_results", "(", "self", ",", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Merge augmented detection bboxes and scores.\n\n        Args:\n            aug_bboxes (list[Tensor]): shape (n, 4*#class)\n            aug_scores (list[Tensor] or None): shape (n, #class)\n            img_shapes (list[Tensor]): shape (3, ).\n\n        Returns:\n            tuple: (bboxes, scores)\n        \"\"\"", "\n", "recovered_bboxes", "=", "[", "]", "\n", "for", "bboxes", ",", "img_info", "in", "zip", "(", "aug_bboxes", ",", "img_metas", ")", ":", "\n", "            ", "img_shape", "=", "img_info", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_info", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_info", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_info", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "bboxes", "=", "bbox_mapping_back", "(", "bboxes", ",", "img_shape", ",", "scale_factor", ",", "flip", ",", "\n", "flip_direction", ")", "\n", "recovered_bboxes", ".", "append", "(", "bboxes", ")", "\n", "", "bboxes", "=", "torch", ".", "cat", "(", "recovered_bboxes", ",", "dim", "=", "0", ")", "\n", "if", "aug_scores", "is", "None", ":", "\n", "            ", "return", "bboxes", "\n", "", "else", ":", "\n", "            ", "scores", "=", "torch", ".", "cat", "(", "aug_scores", ",", "dim", "=", "0", ")", "\n", "return", "bboxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.reppoints_detector.RepPointsDetector.aug_test": [[54, 100], ["reppoints_detector.RepPointsDetector.extract_feats", "zip", "reppoints_detector.RepPointsDetector.merge_aug_results", "mmdet.core.multiclass_nms", "mmdet.core.bbox2result", "reppoints_detector.RepPointsDetector.bbox_head", "aug_bboxes.append", "aug_scores.append", "det_bboxes.clone", "det_bboxes.new_tensor", "reppoints_detector.RepPointsDetector.bbox_head.get_bboxes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.reppoints_detector.RepPointsDetector.merge_aug_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (list[Tensor]): the outer list indicates test-time\n                augmentations and inner Tensor should have a shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[list[dict]]): the outer list indicates test-time\n                augs (multiscale, flip, etc.) and the inner list indicates\n                images in a batch. each dict has image information.\n            rescale (bool, optional): Whether to rescale the results.\n                Defaults to False.\n\n        Returns:\n            list[ndarray]: bbox results of each class\n        \"\"\"", "\n", "# recompute feats to save memory", "\n", "feats", "=", "self", ".", "extract_feats", "(", "imgs", ")", "\n", "\n", "aug_bboxes", "=", "[", "]", "\n", "aug_scores", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "feats", ",", "img_metas", ")", ":", "\n", "# only one image in the batch", "\n", "            ", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_inputs", "=", "outs", "+", "(", "img_meta", ",", "self", ".", "test_cfg", ",", "False", ",", "False", ")", "\n", "det_bboxes", ",", "det_scores", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "*", "bbox_inputs", ")", "[", "0", "]", "\n", "aug_bboxes", ".", "append", "(", "det_bboxes", ")", "\n", "aug_scores", ".", "append", "(", "det_scores", ")", "\n", "\n", "# after merging, bboxes will be rescaled to the original image size", "\n", "", "merged_bboxes", ",", "merged_scores", "=", "self", ".", "merge_aug_results", "(", "\n", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "merged_bboxes", ",", "merged_scores", ",", "\n", "self", ".", "test_cfg", ".", "score_thr", ",", "\n", "self", ".", "test_cfg", ".", "nms", ",", "\n", "self", ".", "test_cfg", ".", "max_per_img", ")", "\n", "\n", "if", "rescale", ":", "\n", "            ", "_det_bboxes", "=", "det_bboxes", "\n", "", "else", ":", "\n", "            ", "_det_bboxes", "=", "det_bboxes", ".", "clone", "(", ")", "\n", "_det_bboxes", "[", ":", ",", ":", "4", "]", "*=", "det_bboxes", ".", "new_tensor", "(", "\n", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'scale_factor'", "]", ")", "\n", "", "bbox_results", "=", "bbox2result", "(", "_det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "return", "bbox_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.faster_rcnn.FasterRCNN.__init__": [[9, 25], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "FasterRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fcos.FCOS.__init__": [[9, 18], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "FCOS", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.fsaf.FSAF.__init__": [[9, 18], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "FSAF", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.mask_scoring_rcnn.MaskScoringRCNN.__init__": [[12, 28], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "MaskScoringRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.__init__": [[17, 46], ["base.BaseDetector.__init__", "builder.build_backbone", "spatialflow.SpatialFlow.init_weights", "builder.build_neck", "bbox_head.update", "builder.build_head", "builder.build_roi_extractor", "builder.build_head", "builder.build_head", "bbox_head.update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_backbone", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_neck", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "mask_roi_extractor", "=", "None", ",", "\n", "mask_head", "=", "None", ",", "\n", "stuff_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "SpatialFlow", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "if", "neck", "is", "not", "None", ":", "\n", "            ", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "", "if", "bbox_head", "is", "not", "None", ":", "\n", "            ", "if", "train_cfg", "is", "not", "None", ":", "\n", "                ", "bbox_head", ".", "update", "(", "train_cfg", "=", "train_cfg", ".", "single_stage", ")", "\n", "", "bbox_head", ".", "update", "(", "test_cfg", "=", "test_cfg", ".", "single_stage", ")", "\n", "self", ".", "bbox_head", "=", "build_head", "(", "bbox_head", ")", "\n", "", "if", "mask_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "mask_roi_extractor", "=", "build_roi_extractor", "(", "\n", "mask_roi_extractor", ")", "\n", "self", ".", "mask_head", "=", "build_head", "(", "mask_head", ")", "\n", "", "if", "stuff_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "stuff_head", "=", "build_head", "(", "stuff_head", ")", "\n", "\n", "", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.with_stuff": [[47, 50], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_stuff", "(", "self", ")", ":", "\n", "        ", "return", "hasattr", "(", "self", ",", "'stuff_head'", ")", "and", "self", ".", "stuff_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.init_weights": [[51, 67], ["super().init_weights", "spatialflow.SpatialFlow.backbone.init_weights", "isinstance", "spatialflow.SpatialFlow.bbox_head.init_weights", "spatialflow.SpatialFlow.mask_roi_extractor.init_weights", "spatialflow.SpatialFlow.mask_head.init_weights", "spatialflow.SpatialFlow.stuff_head.init_weights", "spatialflow.SpatialFlow.neck.init_weights", "m.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "SpatialFlow", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "neck", ",", "nn", ".", "Sequential", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "neck", ":", "\n", "                    ", "m", ".", "init_weights", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "neck", ".", "init_weights", "(", ")", "\n", "", "", "if", "self", ".", "with_bbox", ":", "\n", "            ", "self", ".", "bbox_head", ".", "init_weights", "(", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "self", ".", "mask_roi_extractor", ".", "init_weights", "(", ")", "\n", "self", ".", "mask_head", ".", "init_weights", "(", ")", "\n", "", "if", "self", ".", "with_stuff", ":", "\n", "            ", "self", ".", "stuff_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat": [[68, 73], ["spatialflow.SpatialFlow.backbone", "spatialflow.SpatialFlow.neck"], "methods", ["None"], ["", "", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "if", "self", ".", "with_neck", ":", "\n", "            ", "x", "=", "self", ".", "neck", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.forward_train": [[74, 156], ["spatialflow.SpatialFlow.extract_feat", "dict", "spatialflow.SpatialFlow.bbox_head", "spatialflow.SpatialFlow.bbox_head.loss", "dict.update", "spatialflow.SpatialFlow.bbox_head.get_bboxes", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "img.size", "range", "mmdet.core.bbox2roi", "spatialflow.SpatialFlow.mask_roi_extractor", "spatialflow.SpatialFlow.mask_head", "spatialflow.SpatialFlow.mask_head.get_targets", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "spatialflow.SpatialFlow.mask_head.loss", "dict.update", "spatialflow.SpatialFlow.stuff_head", "spatialflow.SpatialFlow.stuff_head.loss", "dict.update", "single_stage_bboxes_list.append", "mmdet.core.build_assigner.assign", "mmdet.core.build_sampler.sample", "sampling_results.append", "range", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "forward_train", "(", "self", ",", "\n", "img", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ",", "\n", "gt_semantic_seg", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "losses", "=", "dict", "(", ")", "\n", "\n", "# bbox head forward and loss", "\n", "bbox_outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_loss_inputs", "=", "bbox_outs", "[", ":", "2", "]", "+", "(", "\n", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ")", "\n", "bbox_losses", "=", "self", ".", "bbox_head", ".", "loss", "(", "\n", "*", "bbox_loss_inputs", ",", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "losses", ".", "update", "(", "bbox_losses", ")", "\n", "\n", "# mask", "\n", "# get det bboxes for each image after nms", "\n", "bbox_inputs", "=", "bbox_outs", "[", ":", "2", "]", "+", "(", "\n", "img_metas", ",", "self", ".", "train_cfg", ".", "single_stage_nms", ")", "\n", "bbox_list", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "*", "bbox_inputs", ")", "\n", "single_stage_bboxes_list", "=", "[", "]", "\n", "for", "bbox", ",", "labels", "in", "bbox_list", ":", "\n", "            ", "single_stage_bboxes_list", ".", "append", "(", "bbox", "[", ":", ",", ":", "4", "]", ")", "\n", "\n", "# assign the bboxes and labels for mask", "\n", "", "mask_assigner", "=", "build_assigner", "(", "\n", "self", ".", "train_cfg", ".", "single_stage_mask", ".", "assigner", ")", "\n", "mask_sampler", "=", "build_sampler", "(", "\n", "self", ".", "train_cfg", ".", "single_stage_mask", ".", "sampler", ",", "context", "=", "self", ")", "\n", "num_imgs", "=", "img", ".", "size", "(", "0", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "sampling_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assign_result", "=", "mask_assigner", ".", "assign", "(", "\n", "single_stage_bboxes_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_bboxes_ignore", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ")", "\n", "sampling_result", "=", "mask_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "single_stage_bboxes_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "i", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "\n", "# get all rois", "\n", "", "pos_rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "\n", "# mask subnet", "\n", "mask_roi_feats", "=", "bbox_outs", "[", "-", "1", "]", "\n", "\n", "# mask head forward and loss", "\n", "mask_feats", "=", "self", ".", "mask_roi_extractor", "(", "\n", "mask_roi_feats", "[", ":", "self", ".", "mask_roi_extractor", ".", "num_inputs", "]", ",", "pos_rois", ")", "\n", "mask_pred", "=", "self", ".", "mask_head", "(", "mask_feats", ")", "\n", "\n", "mask_targets", "=", "self", ".", "mask_head", ".", "get_targets", "(", "\n", "sampling_results", ",", "gt_masks", ",", "self", ".", "train_cfg", ".", "single_stage_mask", ")", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "\n", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "loss_mask", "=", "self", ".", "mask_head", ".", "loss", "(", "mask_pred", ",", "mask_targets", ",", "\n", "pos_labels", ")", "\n", "losses", ".", "update", "(", "loss_mask", ")", "\n", "\n", "# stuff head", "\n", "# stuff subnet", "\n", "stuff_head_inputs", "=", "bbox_outs", "[", "-", "2", "]", "\n", "\n", "stuff_outs", "=", "self", ".", "stuff_head", "(", "\n", "stuff_head_inputs", "[", ":", "len", "(", "self", ".", "stuff_head", ".", "feat_strides", ")", "]", ")", "\n", "loss_stuff", "=", "self", ".", "stuff_head", ".", "loss", "(", "\n", "stuff_outs", ",", "gt_semantic_seg", ",", "img_metas", ")", "\n", "losses", ".", "update", "(", "loss_stuff", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.simple_test": [[157, 223], ["spatialflow.SpatialFlow.extract_feat", "spatialflow.SpatialFlow.bbox_head", "spatialflow.SpatialFlow.bbox_head.get_bboxes", "zip", "mmdet.core.bbox2roi", "spatialflow.SpatialFlow.mask_roi_extractor", "enumerate", "spatialflow.SpatialFlow.stuff_head", "spatialflow.SpatialFlow.stuff_head.get_stuff_map", "zip", "mmdet.core.bbox2result", "_bboxes.append", "spatialflow.SpatialFlow.new_zeros", "spatialflow.SpatialFlow.mask_head", "spatialflow.SpatialFlow.mask_head.get_seg_masks", "segm_results.append", "bbox_segm_stuff_results.append", "isinstance", "det_bboxes.new_tensor", "spatialflow.SpatialFlow.size", "spatialflow.SpatialFlow.size", "len", "spatialflow.SpatialFlow.size", "spatialflow.SpatialFlow.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.extract_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.get_stuff_map", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_meta", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "bbox_outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_inputs", "=", "bbox_outs", "[", ":", "2", "]", "+", "(", "\n", "img_meta", ",", "self", ".", "test_cfg", ".", "single_stage", ",", "rescale", ")", "\n", "det_results", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "*", "bbox_inputs", ")", "\n", "bbox_results", "=", "[", "\n", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "for", "det_bboxes", ",", "det_labels", "in", "det_results", "\n", "]", "\n", "\n", "# mask subnet", "\n", "mask_roi_feats", "=", "bbox_outs", "[", "-", "1", "]", "\n", "# det_bboxes is rescaled to the original image size, we need to", "\n", "# rescale it back to the testing scale to obtain RoIs.", "\n", "_bboxes", "=", "[", "]", "\n", "for", "results", ",", "meta", "in", "zip", "(", "det_results", ",", "img_meta", ")", ":", "\n", "            ", "det_bboxes", ",", "_", "=", "results", "\n", "scale_factor", "=", "meta", "[", "'scale_factor'", "]", "\n", "if", "rescale", "and", "isinstance", "(", "scale_factor", ",", "(", "float", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "                ", "scale_factor", "=", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "# refer to `bbox_nms.py` for details that we add a zeros bboxes", "\n", "# tensor to handle the situation that there is no `det_bboxes`", "\n", "", "_det_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "scale_factor", "if", "rescale", "else", "det_bboxes", ")", "\n", "_bboxes", ".", "append", "(", "_det_bboxes", ")", "\n", "\n", "", "mask_rois", "=", "bbox2roi", "(", "_bboxes", ")", "\n", "mask_feats", "=", "self", ".", "mask_roi_extractor", "(", "\n", "mask_roi_feats", "[", ":", "len", "(", "self", ".", "mask_roi_extractor", ".", "featmap_strides", ")", "]", ",", "\n", "mask_rois", ")", "\n", "# some times rois is an empty tensor", "\n", "if", "mask_feats", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "mask_pred", "=", "mask_feats", ".", "new_zeros", "(", "\n", "mask_feats", ".", "size", "(", "0", ")", ",", "mask_feats", ".", "size", "(", "1", ")", ",", "\n", "2", "*", "mask_feats", ".", "size", "(", "2", ")", ",", "2", "*", "mask_feats", ".", "size", "(", "3", ")", ")", "\n", "", "else", ":", "\n", "            ", "mask_pred", "=", "self", ".", "mask_head", "(", "mask_feats", ")", "\n", "", "segm_results", "=", "[", "]", "\n", "for", "img_id", ",", "meta", "in", "enumerate", "(", "img_meta", ")", ":", "\n", "            ", "idx_img", "=", "mask_rois", "[", ":", ",", "0", "]", "==", "img_id", "\n", "mask_pred_img", "=", "mask_pred", "[", "idx_img", "]", "\n", "_bboxes_img", "=", "_bboxes", "[", "img_id", "]", "\n", "det_bboxes_img", ",", "det_labels_img", "=", "det_results", "[", "img_id", "]", "\n", "ori_shape", "=", "meta", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "meta", "[", "'scale_factor'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "mask_pred_img", ",", "_bboxes_img", ",", "det_labels_img", ",", "\n", "self", ".", "test_cfg", ".", "single_stage_mask", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "segm_results", ".", "append", "(", "segm_result", ")", "\n", "\n", "# stuff subnet", "\n", "", "stuff_head_inputs", "=", "bbox_outs", "[", "-", "2", "]", "\n", "\n", "stuff_outs", "=", "self", ".", "stuff_head", "(", "stuff_head_inputs", ")", "\n", "stuff_results", "=", "self", ".", "stuff_head", ".", "get_stuff_map", "(", "\n", "stuff_outs", ",", "img_meta", ",", "rescale", "=", "rescale", ")", "\n", "\n", "bbox_segm_stuff_results", "=", "[", "]", "\n", "for", "bbox_result", ",", "segm_result", ",", "stuff_result", "in", "zip", "(", "\n", "bbox_results", ",", "segm_results", ",", "stuff_results", ")", ":", "\n", "            ", "bbox_segm_stuff_results", ".", "append", "(", "\n", "(", "bbox_result", ",", "segm_result", ",", "stuff_result", ")", ")", "\n", "", "return", "bbox_segm_stuff_results", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.spatialflow.SpatialFlow.aug_test": [[225, 333], ["single_stage_cfg.update", "len", "zip", "range", "zip", "len", "zip", "zip", "spatialflow.SpatialFlow.stuff_head.get_stuff_map_aug", "zip", "dict", "spatialflow.SpatialFlow.extract_feats", "spatialflow.SpatialFlow.bbox_head", "spatialflow.SpatialFlow.bbox_head.get_bboxes", "mask_roi_feats.append", "spatialflow.SpatialFlow.stuff_head", "stuff_outs.append", "enumerate", "range", "aug_img_metas.append", "mmdet.core.merge_aug_bboxes", "mmdet.core.multiclass_nms", "det_results.append", "mmdet.core.bbox2result", "zip", "mmdet.core.bbox2roi", "spatialflow.SpatialFlow.mask_roi_extractor", "spatialflow.SpatialFlow.mask_head", "enumerate", "mmdet.core.merge_aug_masks", "spatialflow.SpatialFlow.mask_head.get_seg_masks", "segm_results.append", "bbox_segm_stuff_results.append", "range", "range", "aug_bboxes[].append", "aug_scores[].append", "len", "aug_img_meta.append", "range", "mmdet.core.bbox_mapping", "scaled_det_results.append", "mask_pred_img.sigmoid().cpu().numpy", "aug_masks[].append", "len", "mask_pred_img.sigmoid().cpu", "mask_pred_img.sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.stuff_heads.stuff_head.StuffHead.get_stuff_map_aug", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector.extract_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test with augmentation.\"\"\"", "\n", "single_stage_cfg", "=", "self", ".", "test_cfg", ".", "single_stage", "\n", "single_stage_cfg", ".", "update", "(", "dict", "(", "aug_test", "=", "True", ")", ")", "\n", "imgs_per_gpu", "=", "len", "(", "img_metas", "[", "0", "]", ")", "\n", "aug_bboxes", "=", "[", "[", "]", "for", "_", "in", "range", "(", "imgs_per_gpu", ")", "]", "\n", "aug_scores", "=", "[", "[", "]", "for", "_", "in", "range", "(", "imgs_per_gpu", ")", "]", "\n", "mask_roi_feats", "=", "[", "]", "\n", "stuff_outs", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "self", ".", "extract_feats", "(", "imgs", ")", ",", "img_metas", ")", ":", "\n", "            ", "bbox_outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "bbox_inputs", "=", "bbox_outs", "[", ":", "2", "]", "+", "(", "img_meta", ",", "single_stage_cfg", ",", "False", ")", "\n", "results_list", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "*", "bbox_inputs", ")", "\n", "\n", "# mask subnet", "\n", "mask_roi_feats", ".", "append", "(", "bbox_outs", "[", "-", "1", "]", ")", "\n", "\n", "# stuff subnet", "\n", "stuff_head_inputs", "=", "bbox_outs", "[", "-", "2", "]", "\n", "stuff_out", "=", "self", ".", "stuff_head", "(", "stuff_head_inputs", ")", "\n", "stuff_outs", ".", "append", "(", "stuff_out", ")", "\n", "\n", "for", "i", ",", "results", "in", "enumerate", "(", "results_list", ")", ":", "\n", "                ", "mlvl_bboxes", ",", "mlvl_scores", "=", "results", "\n", "aug_bboxes", "[", "i", "]", ".", "append", "(", "mlvl_bboxes", ")", "\n", "aug_scores", "[", "i", "]", ".", "append", "(", "mlvl_scores", ")", "\n", "\n", "", "", "aug_img_metas", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "imgs_per_gpu", ")", ":", "\n", "            ", "aug_img_meta", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "                ", "aug_img_meta", ".", "append", "(", "img_metas", "[", "j", "]", "[", "i", "]", ")", "\n", "", "aug_img_metas", ".", "append", "(", "aug_img_meta", ")", "\n", "\n", "", "det_results", "=", "[", "]", "\n", "for", "aug_bbox", ",", "aug_score", ",", "aug_img_meta", "in", "zip", "(", "\n", "aug_bboxes", ",", "aug_scores", ",", "aug_img_metas", ")", ":", "\n", "            ", "merged_bboxes", ",", "merged_scores", "=", "merge_aug_bboxes", "(", "\n", "aug_bbox", ",", "aug_score", ",", "aug_img_meta", ",", "single_stage_cfg", ",", "\n", "return_mean", "=", "False", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "\n", "merged_bboxes", ",", "merged_scores", ",", "single_stage_cfg", ".", "score_thr", ",", "\n", "single_stage_cfg", ".", "nms", ",", "single_stage_cfg", ".", "max_per_img", ")", "\n", "det_results", ".", "append", "(", "(", "det_bboxes", ",", "det_labels", ")", ")", "\n", "\n", "", "bbox_results", "=", "[", "\n", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "for", "det_bboxes", ",", "det_labels", "in", "det_results", "\n", "]", "\n", "\n", "\n", "# mask", "\n", "imgs_per_gpu", "=", "len", "(", "img_metas", "[", "0", "]", ")", "\n", "aug_masks", "=", "[", "[", "]", "for", "_", "in", "range", "(", "imgs_per_gpu", ")", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "mask_roi_feats", ",", "img_metas", ")", ":", "\n", "# we should rescale the det bboxes outside `simple_test_mask`", "\n", "# because there are `flip` for aug test setting, while in the", "\n", "# simple test setting, just have the scale", "\n", "            ", "scaled_det_results", "=", "[", "]", "\n", "for", "results", ",", "meta", "in", "zip", "(", "det_results", ",", "img_meta", ")", ":", "\n", "                ", "det_bboxes", ",", "_", "=", "results", "\n", "img_shape", "=", "meta", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "meta", "[", "'scale_factor'", "]", "\n", "flip", "=", "meta", "[", "'flip'", "]", "\n", "scaled_det_bboxes", "=", "bbox_mapping", "(", "det_bboxes", "[", ":", ",", ":", "4", "]", ",", "\n", "img_shape", ",", "scale_factor", ",", "flip", ")", "\n", "scaled_det_results", ".", "append", "(", "scaled_det_bboxes", ")", "\n", "", "mask_rois", "=", "bbox2roi", "(", "scaled_det_results", ")", "\n", "mask_feats", "=", "self", ".", "mask_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "self", ".", "mask_roi_extractor", ".", "featmap_strides", ")", "]", ",", "\n", "mask_rois", ")", "\n", "mask_pred", "=", "self", ".", "mask_head", "(", "mask_feats", ")", "\n", "for", "img_id", ",", "meta", "in", "enumerate", "(", "img_meta", ")", ":", "\n", "                ", "idx_img", "=", "mask_rois", "[", ":", ",", "0", "]", "==", "img_id", "\n", "mask_pred_img", "=", "mask_pred", "[", "idx_img", "]", "\n", "# convert to numpy array to save memory", "\n", "mask_pred_img_np", "=", "mask_pred_img", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "aug_masks", "[", "img_id", "]", ".", "append", "(", "mask_pred_img_np", ")", "\n", "\n", "", "", "segm_results", "=", "[", "]", "\n", "for", "det_result", ",", "aug_mask", ",", "aug_img_meta", "in", "zip", "(", "\n", "det_results", ",", "aug_masks", ",", "aug_img_metas", ")", ":", "\n", "            ", "det_bboxes", ",", "det_labels", "=", "det_result", "\n", "merged_masks", "=", "merge_aug_masks", "(", "aug_mask", ",", "aug_img_meta", ",", "\n", "self", ".", "test_cfg", ".", "single_stage_mask", ")", "\n", "# perform `get_seg_masks` here for `merged_masks`", "\n", "# `ori_shape` for all augmented images are the same here", "\n", "ori_shape", "=", "aug_img_meta", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "self", ".", "test_cfg", ".", "single_stage_mask", ",", "\n", "ori_shape", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "rescale", "=", "False", ")", "\n", "segm_results", ".", "append", "(", "segm_result", ")", "\n", "\n", "# stuff", "\n", "", "stuff_results", "=", "self", ".", "stuff_head", ".", "get_stuff_map_aug", "(", "\n", "stuff_outs", ",", "img_metas", ",", "rescale", "=", "rescale", ")", "\n", "\n", "bbox_segm_stuff_results", "=", "[", "]", "\n", "for", "bbox_result", ",", "segm_result", ",", "stuff_result", "in", "zip", "(", "\n", "bbox_results", ",", "segm_results", ",", "stuff_results", ")", ":", "\n", "            ", "bbox_segm_stuff_results", ".", "append", "(", "\n", "(", "bbox_result", ",", "segm_result", ",", "stuff_result", ")", ")", "\n", "", "return", "bbox_segm_stuff_results", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.gfl.GFL.__init__": [[8, 17], ["single_stage.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "GFL", ",", "self", ")", ".", "__init__", "(", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "\n", "test_cfg", ",", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.mask_rcnn.MaskRCNN.__init__": [[9, 25], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "MaskRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.point_rend.PointRend.__init__": [[14, 30], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "PointRend", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.grid_rcnn.GridRCNN.__init__": [[14, 30], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "GridRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.__init__": [[10, 26], ["two_stage.TwoStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "rpn_head", "=", "None", ",", "\n", "roi_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "CascadeRCNN", ",", "self", ")", ".", "__init__", "(", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result": [[27, 38], ["super().show_result", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result"], ["", "def", "show_result", "(", "self", ",", "data", ",", "result", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Show prediction results of the detector.\"\"\"", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "ms_bbox_result", ",", "ms_segm_result", "=", "result", "\n", "if", "isinstance", "(", "ms_bbox_result", ",", "dict", ")", ":", "\n", "                ", "result", "=", "(", "ms_bbox_result", "[", "'ensemble'", "]", ",", "\n", "ms_segm_result", "[", "'ensemble'", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "result", ",", "dict", ")", ":", "\n", "                ", "result", "=", "result", "[", "'ensemble'", "]", "\n", "", "", "return", "super", "(", "CascadeRCNN", ",", "self", ")", ".", "show_result", "(", "data", ",", "result", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.__init__": [[11, 32], ["torch.Module.__init__", "base_roi_head.BaseRoIHead.init_assigner_sampler", "builder.build_shared_head", "base_roi_head.BaseRoIHead.init_bbox_head", "base_roi_head.BaseRoIHead.init_mask_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_assigner_sampler", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_shared_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_bbox_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_mask_head"], ["def", "__init__", "(", "self", ",", "\n", "bbox_roi_extractor", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "mask_roi_extractor", "=", "None", ",", "\n", "mask_head", "=", "None", ",", "\n", "shared_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "BaseRoIHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "if", "shared_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "shared_head", "=", "build_shared_head", "(", "shared_head", ")", "\n", "\n", "", "if", "bbox_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox_head", "(", "bbox_roi_extractor", ",", "bbox_head", ")", "\n", "\n", "", "if", "mask_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_mask_head", "(", "mask_roi_extractor", ",", "mask_head", ")", "\n", "\n", "", "self", ".", "init_assigner_sampler", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.with_bbox": [[33, 37], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_bbox", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the RoI head contains a `bbox_head`\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'bbox_head'", ")", "and", "self", ".", "bbox_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.with_mask": [[38, 42], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the RoI head contains a `mask_head`\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'mask_head'", ")", "and", "self", ".", "mask_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.with_shared_head": [[43, 47], ["hasattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "with_shared_head", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the RoI head contains a `shared_head`\"\"\"", "\n", "return", "hasattr", "(", "self", ",", "'shared_head'", ")", "and", "self", ".", "shared_head", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.init_weights": [[48, 57], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.init_bbox_head": [[58, 62], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "init_bbox_head", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize ``bbox_head``\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.init_mask_head": [[63, 67], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "init_mask_head", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize ``mask_head``\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.init_assigner_sampler": [[68, 72], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "init_assigner_sampler", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize assigner and sampler.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.forward_train": [[73, 85], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_meta", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function during training.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.simple_test": [[90, 99], ["None"], "methods", ["None"], ["", "def", "simple_test", "(", "self", ",", "\n", "x", ",", "\n", "proposal_list", ",", "\n", "img_meta", ",", "\n", "proposals", "=", "None", ",", "\n", "rescale", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.base_roi_head.BaseRoIHead.aug_test": [[100, 107], ["None"], "methods", ["None"], ["", "def", "aug_test", "(", "self", ",", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test with augmentations.\n\n        If rescale is False, then returned bboxes and masks will fit the scale\n        of imgs[0].\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.__init__": [[17, 39], ["cascade_roi_head.CascadeRoIHead.__init__", "builder.build_roi_extractor", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["def", "__init__", "(", "self", ",", "\n", "num_stages", ",", "\n", "stage_loss_weights", ",", "\n", "semantic_roi_extractor", "=", "None", ",", "\n", "semantic_head", "=", "None", ",", "\n", "semantic_fusion", "=", "(", "'bbox'", ",", "'mask'", ")", ",", "\n", "interleaved", "=", "True", ",", "\n", "mask_info_flow", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "HybridTaskCascadeRoIHead", ",", "\n", "self", ")", ".", "__init__", "(", "num_stages", ",", "stage_loss_weights", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "with_bbox", "and", "self", ".", "with_mask", "\n", "assert", "not", "self", ".", "with_shared_head", "# shared head is not supported", "\n", "\n", "if", "semantic_head", "is", "not", "None", ":", "\n", "            ", "self", ".", "semantic_roi_extractor", "=", "build_roi_extractor", "(", "\n", "semantic_roi_extractor", ")", "\n", "self", ".", "semantic_head", "=", "build_head", "(", "semantic_head", ")", "\n", "\n", "", "self", ".", "semantic_fusion", "=", "semantic_fusion", "\n", "self", ".", "interleaved", "=", "interleaved", "\n", "self", ".", "mask_info_flow", "=", "mask_info_flow", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.init_weights": [[40, 50], ["super().init_weights", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "HybridTaskCascadeRoIHead", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "if", "self", ".", "with_semantic", ":", "\n", "            ", "self", ".", "semantic_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.with_semantic": [[51, 58], ["hasattr"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "with_semantic", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: whether the head has semantic head\"\"\"", "\n", "if", "hasattr", "(", "self", ",", "'semantic_head'", ")", "and", "self", ".", "semantic_head", "is", "not", "None", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.forward_dummy": [[59, 93], ["mmdet.core.bbox2roi", "range", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head", "htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward", "mask_roi_extractor", "range", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "mask_head", "mask_head", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward"], ["", "", "def", "forward_dummy", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"Dummy forward function.\"\"\"", "\n", "outs", "=", "(", ")", "\n", "# semantic head", "\n", "if", "self", ".", "with_semantic", ":", "\n", "            ", "_", ",", "semantic_feat", "=", "self", ".", "semantic_head", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "semantic_feat", "=", "None", "\n", "# bbox heads", "\n", "", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "\n", "i", ",", "x", ",", "rois", ",", "semantic_feat", "=", "semantic_feat", ")", "\n", "outs", "=", "outs", "+", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ")", "\n", "# mask heads", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_rois", "=", "rois", "[", ":", "100", "]", "\n", "mask_roi_extractor", "=", "self", ".", "mask_roi_extractor", "[", "-", "1", "]", "\n", "mask_feats", "=", "mask_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "mask_roi_extractor", ".", "featmap_strides", ")", "]", ",", "mask_rois", ")", "\n", "if", "self", ".", "with_semantic", "and", "'mask'", "in", "self", ".", "semantic_fusion", ":", "\n", "                ", "mask_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "\n", "[", "semantic_feat", "]", ",", "mask_rois", ")", "\n", "mask_feats", "+=", "mask_semantic_feat", "\n", "", "last_feat", "=", "None", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                ", "mask_head", "=", "self", ".", "mask_head", "[", "i", "]", "\n", "if", "self", ".", "mask_info_flow", ":", "\n", "                    ", "mask_pred", ",", "last_feat", "=", "mask_head", "(", "mask_feats", ",", "last_feat", ")", "\n", "", "else", ":", "\n", "                    ", "mask_pred", "=", "mask_head", "(", "mask_feats", ")", "\n", "", "outs", "=", "outs", "+", "(", "mask_pred", ",", ")", "\n", "", "", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward_train": [[94, 120], ["mmdet.core.bbox2roi", "htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward", "bbox_head.get_targets", "bbox_head.loss", "htc_roi_head.HybridTaskCascadeRoIHead.update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "\n", "stage", ",", "\n", "x", ",", "\n", "sampling_results", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "rcnn_train_cfg", ",", "\n", "semantic_feat", "=", "None", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for box head in training.\"\"\"", "\n", "bbox_head", "=", "self", ".", "bbox_head", "[", "stage", "]", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "\n", "stage", ",", "x", ",", "rois", ",", "semantic_feat", "=", "semantic_feat", ")", "\n", "\n", "bbox_targets", "=", "bbox_head", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "rcnn_train_cfg", ")", "\n", "loss_bbox", "=", "bbox_head", ".", "loss", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "rois", ",", "\n", "*", "bbox_targets", ")", "\n", "\n", "bbox_results", ".", "update", "(", "\n", "loss_bbox", "=", "loss_bbox", ",", "\n", "rois", "=", "rois", ",", "\n", "bbox_targets", "=", "bbox_targets", ",", "\n", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead._mask_forward_train": [[121, 165], ["mmdet.core.bbox2roi", "mask_roi_extractor", "mask_head.get_targets", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_head.loss", "dict", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "range", "mask_head", "mask_head", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_mask_forward_train", "(", "self", ",", "\n", "stage", ",", "\n", "x", ",", "\n", "sampling_results", ",", "\n", "gt_masks", ",", "\n", "rcnn_train_cfg", ",", "\n", "semantic_feat", "=", "None", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for mask head in\n        training.\"\"\"", "\n", "mask_roi_extractor", "=", "self", ".", "mask_roi_extractor", "[", "stage", "]", "\n", "mask_head", "=", "self", ".", "mask_head", "[", "stage", "]", "\n", "pos_rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "mask_feats", "=", "mask_roi_extractor", "(", "x", "[", ":", "mask_roi_extractor", ".", "num_inputs", "]", ",", "\n", "pos_rois", ")", "\n", "\n", "# semantic feature fusion", "\n", "# element-wise sum for original features and pooled semantic features", "\n", "if", "self", ".", "with_semantic", "and", "'mask'", "in", "self", ".", "semantic_fusion", ":", "\n", "            ", "mask_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "[", "semantic_feat", "]", ",", "\n", "pos_rois", ")", "\n", "if", "mask_semantic_feat", ".", "shape", "[", "-", "2", ":", "]", "!=", "mask_feats", ".", "shape", "[", "-", "2", ":", "]", ":", "\n", "                ", "mask_semantic_feat", "=", "F", ".", "adaptive_avg_pool2d", "(", "\n", "mask_semantic_feat", ",", "mask_feats", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "", "mask_feats", "+=", "mask_semantic_feat", "\n", "\n", "# mask information flow", "\n", "# forward all previous mask heads to obtain last_feat, and fuse it", "\n", "# with the normal mask feature", "\n", "", "if", "self", ".", "mask_info_flow", ":", "\n", "            ", "last_feat", "=", "None", "\n", "for", "i", "in", "range", "(", "stage", ")", ":", "\n", "                ", "last_feat", "=", "self", ".", "mask_head", "[", "i", "]", "(", "\n", "mask_feats", ",", "last_feat", ",", "return_logits", "=", "False", ")", "\n", "", "mask_pred", "=", "mask_head", "(", "mask_feats", ",", "last_feat", ",", "return_feat", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "mask_pred", "=", "mask_head", "(", "mask_feats", ",", "return_feat", "=", "False", ")", "\n", "\n", "", "mask_targets", "=", "mask_head", ".", "get_targets", "(", "sampling_results", ",", "gt_masks", ",", "\n", "rcnn_train_cfg", ")", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "loss_mask", "=", "mask_head", ".", "loss", "(", "mask_pred", ",", "mask_targets", ",", "pos_labels", ")", "\n", "\n", "mask_results", "=", "dict", "(", "loss_mask", "=", "loss_mask", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward": [[166, 183], ["bbox_roi_extractor", "bbox_head", "dict", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "len"], "methods", ["None"], ["", "def", "_bbox_forward", "(", "self", ",", "stage", ",", "x", ",", "rois", ",", "semantic_feat", "=", "None", ")", ":", "\n", "        ", "\"\"\"Box head forward function used in both training and testing.\"\"\"", "\n", "bbox_roi_extractor", "=", "self", ".", "bbox_roi_extractor", "[", "stage", "]", "\n", "bbox_head", "=", "self", ".", "bbox_head", "[", "stage", "]", "\n", "bbox_feats", "=", "bbox_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "bbox_roi_extractor", ".", "featmap_strides", ")", "]", ",", "rois", ")", "\n", "if", "self", ".", "with_semantic", "and", "'bbox'", "in", "self", ".", "semantic_fusion", ":", "\n", "            ", "bbox_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "[", "semantic_feat", "]", ",", "\n", "rois", ")", "\n", "if", "bbox_semantic_feat", ".", "shape", "[", "-", "2", ":", "]", "!=", "bbox_feats", ".", "shape", "[", "-", "2", ":", "]", ":", "\n", "                ", "bbox_semantic_feat", "=", "F", ".", "adaptive_avg_pool2d", "(", "\n", "bbox_semantic_feat", ",", "bbox_feats", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "", "bbox_feats", "+=", "bbox_semantic_feat", "\n", "", "cls_score", ",", "bbox_pred", "=", "bbox_head", "(", "bbox_feats", ")", "\n", "\n", "bbox_results", "=", "dict", "(", "cls_score", "=", "cls_score", ",", "bbox_pred", "=", "bbox_pred", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead._mask_forward_test": [[184, 212], ["mmdet.core.bbox2roi", "mask_roi_extractor", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "range", "mask_head", "mask_head", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi"], ["", "def", "_mask_forward_test", "(", "self", ",", "stage", ",", "x", ",", "bboxes", ",", "semantic_feat", "=", "None", ")", ":", "\n", "        ", "\"\"\"Mask head forward function for testing.\"\"\"", "\n", "mask_roi_extractor", "=", "self", ".", "mask_roi_extractor", "[", "stage", "]", "\n", "mask_head", "=", "self", ".", "mask_head", "[", "stage", "]", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "bboxes", "]", ")", "\n", "mask_feats", "=", "mask_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "mask_roi_extractor", ".", "featmap_strides", ")", "]", ",", "mask_rois", ")", "\n", "if", "self", ".", "with_semantic", "and", "'mask'", "in", "self", ".", "semantic_fusion", ":", "\n", "            ", "mask_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "[", "semantic_feat", "]", ",", "\n", "mask_rois", ")", "\n", "if", "mask_semantic_feat", ".", "shape", "[", "-", "2", ":", "]", "!=", "mask_feats", ".", "shape", "[", "-", "2", ":", "]", ":", "\n", "                ", "mask_semantic_feat", "=", "F", ".", "adaptive_avg_pool2d", "(", "\n", "mask_semantic_feat", ",", "mask_feats", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "", "mask_feats", "+=", "mask_semantic_feat", "\n", "", "if", "self", ".", "mask_info_flow", ":", "\n", "            ", "last_feat", "=", "None", "\n", "last_pred", "=", "None", "\n", "for", "i", "in", "range", "(", "stage", ")", ":", "\n", "                ", "mask_pred", ",", "last_feat", "=", "self", ".", "mask_head", "[", "i", "]", "(", "mask_feats", ",", "last_feat", ")", "\n", "if", "last_pred", "is", "not", "None", ":", "\n", "                    ", "mask_pred", "=", "mask_pred", "+", "last_pred", "\n", "", "last_pred", "=", "mask_pred", "\n", "", "mask_pred", "=", "mask_head", "(", "mask_feats", ",", "last_feat", ",", "return_feat", "=", "False", ")", "\n", "if", "last_pred", "is", "not", "None", ":", "\n", "                ", "mask_pred", "=", "mask_pred", "+", "last_pred", "\n", "", "", "else", ":", "\n", "            ", "mask_pred", "=", "mask_head", "(", "mask_feats", ")", "\n", "", "return", "mask_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.forward_train": [[213, 337], ["dict", "range", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head.loss", "len", "range", "htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward_train", "bbox_results[].items", "bbox_assigner.assign", "bbox_sampler.sample", "sampling_results.append", "htc_roi_head.HybridTaskCascadeRoIHead._mask_forward_train", "mask_results[].items", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "htc_roi_head.HybridTaskCascadeRoIHead.bbox_head[].refine_bboxes", "range", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "htc_roi_head.HybridTaskCascadeRoIHead.bbox_head[].refine_bboxes", "range", "bbox_assigner.assign", "bbox_sampler.sample", "sampling_results.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.refine_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.refine_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ",", "\n", "gt_semantic_seg", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): list of multi-level img features.\n\n            img_metas (list[dict]): list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n\n            proposal_list (list[Tensors]): list of region proposals.\n\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n\n            gt_labels (list[Tensor]): class indices corresponding to each box\n\n            gt_bboxes_ignore (None, list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n            gt_masks (None, Tensor) : true segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n            gt_semantic_seg (None, list[Tensor]): semantic segmentation masks\n                used if the architecture supports semantic segmentation task.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "# semantic segmentation part", "\n", "# 2 outputs: segmentation prediction and embedded features", "\n", "losses", "=", "dict", "(", ")", "\n", "if", "self", ".", "with_semantic", ":", "\n", "            ", "semantic_pred", ",", "semantic_feat", "=", "self", ".", "semantic_head", "(", "x", ")", "\n", "loss_seg", "=", "self", ".", "semantic_head", ".", "loss", "(", "semantic_pred", ",", "gt_semantic_seg", ")", "\n", "losses", "[", "'loss_semantic_seg'", "]", "=", "loss_seg", "\n", "", "else", ":", "\n", "            ", "semantic_feat", "=", "None", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "self", ".", "current_stage", "=", "i", "\n", "rcnn_train_cfg", "=", "self", ".", "train_cfg", "[", "i", "]", "\n", "lw", "=", "self", ".", "stage_loss_weights", "[", "i", "]", "\n", "\n", "# assign gts and sample proposals", "\n", "sampling_results", "=", "[", "]", "\n", "bbox_assigner", "=", "self", ".", "bbox_assigner", "[", "i", "]", "\n", "bbox_sampler", "=", "self", ".", "bbox_sampler", "[", "i", "]", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "", "for", "j", "in", "range", "(", "num_imgs", ")", ":", "\n", "                ", "assign_result", "=", "bbox_assigner", ".", "assign", "(", "proposal_list", "[", "j", "]", ",", "\n", "gt_bboxes", "[", "j", "]", ",", "\n", "gt_bboxes_ignore", "[", "j", "]", ",", "\n", "gt_labels", "[", "j", "]", ")", "\n", "sampling_result", "=", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "j", "]", ",", "\n", "gt_bboxes", "[", "j", "]", ",", "\n", "gt_labels", "[", "j", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "j", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "\n", "# bbox head forward and loss", "\n", "", "bbox_results", "=", "self", ".", "_bbox_forward_train", "(", "\n", "i", ",", "x", ",", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "rcnn_train_cfg", ",", "semantic_feat", ")", "\n", "roi_labels", "=", "bbox_results", "[", "'bbox_targets'", "]", "[", "0", "]", "\n", "\n", "for", "name", ",", "value", "in", "bbox_results", "[", "'loss_bbox'", "]", ".", "items", "(", ")", ":", "\n", "                ", "losses", "[", "f's{i}.{name}'", "]", "=", "(", "\n", "value", "*", "lw", "if", "'loss'", "in", "name", "else", "value", ")", "\n", "\n", "# mask head forward and loss", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "# interleaved execution: use regressed bboxes by the box branch", "\n", "# to train the mask branch", "\n", "                ", "if", "self", ".", "interleaved", ":", "\n", "                    ", "pos_is_gts", "=", "[", "res", ".", "pos_is_gt", "for", "res", "in", "sampling_results", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "proposal_list", "=", "self", ".", "bbox_head", "[", "i", "]", ".", "refine_bboxes", "(", "\n", "bbox_results", "[", "'rois'", "]", ",", "roi_labels", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "pos_is_gts", ",", "img_metas", ")", "\n", "# re-assign and sample 512 RoIs from 512 RoIs", "\n", "sampling_results", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "num_imgs", ")", ":", "\n", "                            ", "assign_result", "=", "bbox_assigner", ".", "assign", "(", "\n", "proposal_list", "[", "j", "]", ",", "gt_bboxes", "[", "j", "]", ",", "\n", "gt_bboxes_ignore", "[", "j", "]", ",", "gt_labels", "[", "j", "]", ")", "\n", "sampling_result", "=", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "j", "]", ",", "\n", "gt_bboxes", "[", "j", "]", ",", "\n", "gt_labels", "[", "j", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "j", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "", "", "", "mask_results", "=", "self", ".", "_mask_forward_train", "(", "\n", "i", ",", "x", ",", "sampling_results", ",", "gt_masks", ",", "rcnn_train_cfg", ",", "\n", "semantic_feat", ")", "\n", "for", "name", ",", "value", "in", "mask_results", "[", "'loss_mask'", "]", ".", "items", "(", ")", ":", "\n", "                    ", "losses", "[", "f's{i}.{name}'", "]", "=", "(", "\n", "value", "*", "lw", "if", "'loss'", "in", "name", "else", "value", ")", "\n", "\n", "# refine bboxes (same as Cascade R-CNN)", "\n", "", "", "if", "i", "<", "self", ".", "num_stages", "-", "1", "and", "not", "self", ".", "interleaved", ":", "\n", "                ", "pos_is_gts", "=", "[", "res", ".", "pos_is_gt", "for", "res", "in", "sampling_results", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "proposal_list", "=", "self", ".", "bbox_head", "[", "i", "]", ".", "refine_bboxes", "(", "\n", "bbox_results", "[", "'rois'", "]", ",", "roi_labels", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "pos_is_gts", ",", "img_metas", ")", "\n", "\n", "", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.simple_test": [[338, 421], ["mmdet.core.bbox2roi", "range", "htc_roi_head.HybridTaskCascadeRoIHead.bbox_head[].get_bboxes", "mmdet.core.bbox2result", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head", "htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward", "ms_scores.append", "sum", "float", "bbox_results[].argmax", "bbox_head.regress_by_class", "len", "mmdet.core.bbox2roi", "mask_roi_extractor", "range", "mmdet.core.merge_aug_masks", "htc_roi_head.HybridTaskCascadeRoIHead.mask_head[].get_seg_masks", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "aug_masks.append", "range", "det_bboxes.new_tensor", "mask_head", "mask_head", "mask_head.sigmoid().cpu().numpy", "len", "mask_head.sigmoid().cpu", "mask_head.sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks"], ["", "def", "simple_test", "(", "self", ",", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "if", "self", ".", "with_semantic", ":", "\n", "            ", "_", ",", "semantic_feat", "=", "self", ".", "semantic_head", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "semantic_feat", "=", "None", "\n", "\n", "", "img_shape", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "\n", "# \"ms\" in variable names means multi-stage", "\n", "ms_bbox_result", "=", "{", "}", "\n", "ms_segm_result", "=", "{", "}", "\n", "ms_scores", "=", "[", "]", "\n", "rcnn_test_cfg", "=", "self", ".", "test_cfg", "\n", "\n", "rois", "=", "bbox2roi", "(", "proposal_list", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "bbox_head", "=", "self", ".", "bbox_head", "[", "i", "]", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "\n", "i", ",", "x", ",", "rois", ",", "semantic_feat", "=", "semantic_feat", ")", "\n", "ms_scores", ".", "append", "(", "bbox_results", "[", "'cls_score'", "]", ")", "\n", "\n", "if", "i", "<", "self", ".", "num_stages", "-", "1", ":", "\n", "                ", "bbox_label", "=", "bbox_results", "[", "'cls_score'", "]", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "rois", "=", "bbox_head", ".", "regress_by_class", "(", "rois", ",", "bbox_label", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_metas", "[", "0", "]", ")", "\n", "\n", "", "", "cls_score", "=", "sum", "(", "ms_scores", ")", "/", "float", "(", "len", "(", "ms_scores", ")", ")", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "cls_score", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "rescale", ",", "\n", "cfg", "=", "rcnn_test_cfg", ")", "\n", "bbox_result", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "num_classes", ")", "\n", "ms_bbox_result", "[", "'ensemble'", "]", "=", "bbox_result", "\n", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "mask_classes", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "num_classes", "\n", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "mask_classes", ")", "]", "\n", "", "else", ":", "\n", "                ", "_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "if", "rescale", "else", "det_bboxes", ")", "\n", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "aug_masks", "=", "[", "]", "\n", "mask_roi_extractor", "=", "self", ".", "mask_roi_extractor", "[", "-", "1", "]", "\n", "mask_feats", "=", "mask_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "mask_roi_extractor", ".", "featmap_strides", ")", "]", ",", "mask_rois", ")", "\n", "if", "self", ".", "with_semantic", "and", "'mask'", "in", "self", ".", "semantic_fusion", ":", "\n", "                    ", "mask_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "\n", "[", "semantic_feat", "]", ",", "mask_rois", ")", "\n", "mask_feats", "+=", "mask_semantic_feat", "\n", "", "last_feat", "=", "None", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                    ", "mask_head", "=", "self", ".", "mask_head", "[", "i", "]", "\n", "if", "self", ".", "mask_info_flow", ":", "\n", "                        ", "mask_pred", ",", "last_feat", "=", "mask_head", "(", "mask_feats", ",", "last_feat", ")", "\n", "", "else", ":", "\n", "                        ", "mask_pred", "=", "mask_head", "(", "mask_feats", ")", "\n", "", "aug_masks", ".", "append", "(", "mask_pred", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "\n", "[", "img_metas", "]", "*", "self", ".", "num_stages", ",", "\n", "self", ".", "test_cfg", ")", "\n", "segm_result", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "_bboxes", ",", "det_labels", ",", "rcnn_test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "", "ms_segm_result", "[", "'ensemble'", "]", "=", "segm_result", "\n", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "results", "=", "(", "ms_bbox_result", "[", "'ensemble'", "]", ",", "ms_segm_result", "[", "'ensemble'", "]", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "ms_bbox_result", "[", "'ensemble'", "]", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.htc_roi_head.HybridTaskCascadeRoIHead.aug_test": [[422, 540], ["zip", "mmdet.core.merge_aug_bboxes", "mmdet.core.multiclass_nms", "mmdet.core.bbox2result", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "range", "htc_roi_head.HybridTaskCascadeRoIHead.bbox_head[].get_bboxes", "aug_bboxes.append", "aug_scores.append", "len", "htc_roi_head.HybridTaskCascadeRoIHead._bbox_forward", "ms_scores.append", "sum", "float", "zip", "mmdet.core.merge_aug_masks", "htc_roi_head.HybridTaskCascadeRoIHead.mask_head[].get_seg_masks", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_head", "bbox_results[].argmax", "bbox_head.regress_by_class", "len", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "range", "range", "htc_roi_head.HybridTaskCascadeRoIHead.semantic_roi_extractor", "aug_masks.append", "aug_img_metas.append", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "mask_head", "mask_head", "mask_head.sigmoid().cpu().numpy", "len", "mask_head.sigmoid().cpu", "mask_head.sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi"], ["", "def", "aug_test", "(", "self", ",", "img_feats", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test with augmentations.\n\n        If rescale is False, then returned bboxes and masks will fit the scale\n        of imgs[0].\n        \"\"\"", "\n", "if", "self", ".", "with_semantic", ":", "\n", "            ", "semantic_feats", "=", "[", "\n", "self", ".", "semantic_head", "(", "feat", ")", "[", "1", "]", "for", "feat", "in", "img_feats", "\n", "]", "\n", "", "else", ":", "\n", "            ", "semantic_feats", "=", "[", "None", "]", "*", "len", "(", "img_metas", ")", "\n", "\n", "", "rcnn_test_cfg", "=", "self", ".", "test_cfg", "\n", "aug_bboxes", "=", "[", "]", "\n", "aug_scores", "=", "[", "]", "\n", "for", "x", ",", "img_meta", ",", "semantic", "in", "zip", "(", "img_feats", ",", "img_metas", ",", "semantic_feats", ")", ":", "\n", "# only one image in the batch", "\n", "            ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "\n", "proposals", "=", "bbox_mapping", "(", "proposal_list", "[", "0", "]", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "# \"ms\" in variable names means multi-stage", "\n", "ms_scores", "=", "[", "]", "\n", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                ", "bbox_head", "=", "self", ".", "bbox_head", "[", "i", "]", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "\n", "i", ",", "x", ",", "rois", ",", "semantic_feat", "=", "semantic", ")", "\n", "ms_scores", ".", "append", "(", "bbox_results", "[", "'cls_score'", "]", ")", "\n", "\n", "if", "i", "<", "self", ".", "num_stages", "-", "1", ":", "\n", "                    ", "bbox_label", "=", "bbox_results", "[", "'cls_score'", "]", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "rois", "=", "bbox_head", ".", "regress_by_class", "(", "\n", "rois", ",", "bbox_label", ",", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_meta", "[", "0", "]", ")", "\n", "\n", "", "", "cls_score", "=", "sum", "(", "ms_scores", ")", "/", "float", "(", "len", "(", "ms_scores", ")", ")", "\n", "bboxes", ",", "scores", "=", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "cls_score", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "False", ",", "\n", "cfg", "=", "None", ")", "\n", "aug_bboxes", ".", "append", "(", "bboxes", ")", "\n", "aug_scores", ".", "append", "(", "scores", ")", "\n", "\n", "# after merging, bboxes will be rescaled to the original image size", "\n", "", "merged_bboxes", ",", "merged_scores", "=", "merge_aug_bboxes", "(", "\n", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ",", "rcnn_test_cfg", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "merged_bboxes", ",", "merged_scores", ",", "\n", "rcnn_test_cfg", ".", "score_thr", ",", "\n", "rcnn_test_cfg", ".", "nms", ",", "\n", "rcnn_test_cfg", ".", "max_per_img", ")", "\n", "\n", "bbox_result", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "num_classes", ")", "\n", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "segm_result", "=", "[", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "mask_head", "[", "-", "1", "]", ".", "num_classes", "-", "\n", "1", ")", "]", "\n", "", "else", ":", "\n", "                ", "aug_masks", "=", "[", "]", "\n", "aug_img_metas", "=", "[", "]", "\n", "for", "x", ",", "img_meta", ",", "semantic", "in", "zip", "(", "img_feats", ",", "img_metas", ",", "\n", "semantic_feats", ")", ":", "\n", "                    ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "_bboxes", "=", "bbox_mapping", "(", "det_bboxes", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_feats", "=", "self", ".", "mask_roi_extractor", "[", "-", "1", "]", "(", "\n", "x", "[", ":", "len", "(", "self", ".", "mask_roi_extractor", "[", "-", "1", "]", ".", "featmap_strides", ")", "]", ",", "\n", "mask_rois", ")", "\n", "if", "self", ".", "with_semantic", ":", "\n", "                        ", "semantic_feat", "=", "semantic", "\n", "mask_semantic_feat", "=", "self", ".", "semantic_roi_extractor", "(", "\n", "[", "semantic_feat", "]", ",", "mask_rois", ")", "\n", "if", "mask_semantic_feat", ".", "shape", "[", "-", "2", ":", "]", "!=", "mask_feats", ".", "shape", "[", "\n", "-", "2", ":", "]", ":", "\n", "                            ", "mask_semantic_feat", "=", "F", ".", "adaptive_avg_pool2d", "(", "\n", "mask_semantic_feat", ",", "mask_feats", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "", "mask_feats", "+=", "mask_semantic_feat", "\n", "", "last_feat", "=", "None", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                        ", "mask_head", "=", "self", ".", "mask_head", "[", "i", "]", "\n", "if", "self", ".", "mask_info_flow", ":", "\n", "                            ", "mask_pred", ",", "last_feat", "=", "mask_head", "(", "\n", "mask_feats", ",", "last_feat", ")", "\n", "", "else", ":", "\n", "                            ", "mask_pred", "=", "mask_head", "(", "mask_feats", ")", "\n", "", "aug_masks", ".", "append", "(", "mask_pred", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "aug_img_metas", ".", "append", "(", "img_meta", ")", "\n", "", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "aug_img_metas", ",", "\n", "self", ".", "test_cfg", ")", "\n", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "rcnn_test_cfg", ",", "\n", "ori_shape", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "rescale", "=", "False", ")", "\n", "", "return", "bbox_result", ",", "segm_result", "\n", "", "else", ":", "\n", "            ", "return", "bbox_result", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.__init__": [[17, 21], ["standard_roi_head.StandardRoIHead.__init__", "point_rend_roi_head.PointRendRoIHead.init_point_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.init_point_head"], ["def", "__init__", "(", "self", ",", "point_head", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "with_bbox", "and", "self", ".", "with_mask", "\n", "self", ".", "init_point_head", "(", "point_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.init_point_head": [[22, 25], ["builder.build_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["", "def", "init_point_head", "(", "self", ",", "point_head", ")", ":", "\n", "        ", "\"\"\"Initialize ``point_head``\"\"\"", "\n", "self", ".", "point_head", "=", "builder", ".", "build_head", "(", "point_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.init_weights": [[26, 34], ["super().init_weights", "point_rend_roi_head.PointRendRoIHead.point_head.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n        \"\"\"", "\n", "super", "(", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "point_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_forward_train": [[35, 49], ["super()._mask_forward_train", "point_rend_roi_head.PointRendRoIHead._mask_point_forward_train", "mask_results[].update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_point_forward_train"], ["", "def", "_mask_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "bbox_feats", ",", "gt_masks", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for mask head and point head\n        in training.\"\"\"", "\n", "mask_results", "=", "super", "(", ")", ".", "_mask_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "bbox_feats", ",", "gt_masks", ",", "\n", "img_metas", ")", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "not", "None", ":", "\n", "            ", "loss_point", "=", "self", ".", "_mask_point_forward_train", "(", "\n", "x", ",", "sampling_results", ",", "mask_results", "[", "'mask_pred'", "]", ",", "gt_masks", ",", "\n", "img_metas", ")", "\n", "mask_results", "[", "'loss_mask'", "]", ".", "update", "(", "loss_point", ")", "\n", "\n", "", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_point_forward_train": [[50, 70], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "point_rend_roi_head.PointRendRoIHead.point_head.get_roi_rel_points_train", "mmdet.core.bbox2roi", "point_rend_roi_head.PointRendRoIHead._get_fine_grained_point_feats", "mmcv.ops.point_sample", "point_rend_roi_head.PointRendRoIHead.point_head", "point_rend_roi_head.PointRendRoIHead.point_head.get_targets", "point_rend_roi_head.PointRendRoIHead.point_head.loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.get_roi_rel_points_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._get_fine_grained_point_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_mask_point_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "mask_pred", ",", "\n", "gt_masks", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for point head in\n        training.\"\"\"", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "rel_roi_points", "=", "self", ".", "point_head", ".", "get_roi_rel_points_train", "(", "\n", "mask_pred", ",", "pos_labels", ",", "cfg", "=", "self", ".", "train_cfg", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "\n", "fine_grained_point_feats", "=", "self", ".", "_get_fine_grained_point_feats", "(", "\n", "x", ",", "rois", ",", "rel_roi_points", ",", "img_metas", ")", "\n", "coarse_point_feats", "=", "point_sample", "(", "mask_pred", ",", "rel_roi_points", ")", "\n", "mask_point_pred", "=", "self", ".", "point_head", "(", "fine_grained_point_feats", ",", "\n", "coarse_point_feats", ")", "\n", "mask_point_target", "=", "self", ".", "point_head", ".", "get_targets", "(", "\n", "rois", ",", "rel_roi_points", ",", "sampling_results", ",", "gt_masks", ",", "self", ".", "train_cfg", ")", "\n", "loss_mask_point", "=", "self", ".", "point_head", ".", "loss", "(", "mask_point_pred", ",", "\n", "mask_point_target", ",", "pos_labels", ")", "\n", "\n", "return", "loss_mask_point", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._get_fine_grained_point_feats": [[71, 95], ["len", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "fine_grained_feats.append", "float", "feats[].unsqueeze", "inds.any", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "rois[].long", "mmcv.ops.rel_roi_point_to_rel_img_point().unsqueeze", "mmcv.ops.point_sample", "point_feat.squeeze().transpose.squeeze().transpose.squeeze().transpose", "point_feats.append", "mmcv.ops.rel_roi_point_to_rel_img_point", "point_feat.squeeze().transpose.squeeze().transpose.squeeze"], "methods", ["None"], ["", "def", "_get_fine_grained_point_feats", "(", "self", ",", "x", ",", "rois", ",", "rel_roi_points", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Sample fine grained feats from each level feature map and\n        concatenate them together.\"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "fine_grained_feats", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "self", ".", "mask_roi_extractor", ".", "num_inputs", ")", ":", "\n", "            ", "feats", "=", "x", "[", "idx", "]", "\n", "spatial_scale", "=", "1.", "/", "float", "(", "\n", "self", ".", "mask_roi_extractor", ".", "featmap_strides", "[", "idx", "]", ")", "\n", "point_feats", "=", "[", "]", "\n", "for", "batch_ind", "in", "range", "(", "num_imgs", ")", ":", "\n", "# unravel batch dim", "\n", "                ", "feat", "=", "feats", "[", "batch_ind", "]", ".", "unsqueeze", "(", "0", ")", "\n", "inds", "=", "(", "rois", "[", ":", ",", "0", "]", ".", "long", "(", ")", "==", "batch_ind", ")", "\n", "if", "inds", ".", "any", "(", ")", ":", "\n", "                    ", "rel_img_points", "=", "rel_roi_point_to_rel_img_point", "(", "\n", "rois", "[", "inds", "]", ",", "rel_roi_points", "[", "inds", "]", ",", "feat", ".", "shape", "[", "2", ":", "]", ",", "\n", "spatial_scale", ")", ".", "unsqueeze", "(", "0", ")", "\n", "point_feat", "=", "point_sample", "(", "feat", ",", "rel_img_points", ")", "\n", "point_feat", "=", "point_feat", ".", "squeeze", "(", "0", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "point_feats", ".", "append", "(", "point_feat", ")", "\n", "", "", "fine_grained_feats", ".", "append", "(", "torch", ".", "cat", "(", "point_feats", ",", "dim", "=", "0", ")", ")", "\n", "", "return", "torch", ".", "cat", "(", "fine_grained_feats", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_point_forward_test": [[96, 133], ["mask_pred.clone", "range", "torch.interpolate", "torch.interpolate", "point_rend_roi_head.PointRendRoIHead.point_head.get_roi_rel_points_test", "point_rend_roi_head.PointRendRoIHead._get_fine_grained_point_feats", "mmcv.ops.point_sample", "point_rend_roi_head.PointRendRoIHead.point_head", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "refined_mask_pred.view.view.reshape", "refined_mask_pred.view.view.scatter_", "refined_mask_pred.view.view.view", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.get_roi_rel_points_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._get_fine_grained_point_feats", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "_mask_point_forward_test", "(", "self", ",", "x", ",", "rois", ",", "label_pred", ",", "mask_pred", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Mask refining process with point head in testing.\"\"\"", "\n", "refined_mask_pred", "=", "mask_pred", ".", "clone", "(", ")", "\n", "for", "subdivision_step", "in", "range", "(", "self", ".", "test_cfg", ".", "subdivision_steps", ")", ":", "\n", "            ", "refined_mask_pred", "=", "F", ".", "interpolate", "(", "\n", "refined_mask_pred", ",", "\n", "scale_factor", "=", "self", ".", "test_cfg", ".", "scale_factor", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "False", ")", "\n", "# If `subdivision_num_points` is larger or equal to the", "\n", "# resolution of the next step, then we can skip this step", "\n", "num_rois", ",", "channels", ",", "mask_height", ",", "mask_width", "=", "refined_mask_pred", ".", "shape", "\n", "if", "(", "self", ".", "test_cfg", ".", "subdivision_num_points", ">=", "\n", "self", ".", "test_cfg", ".", "scale_factor", "**", "2", "*", "mask_height", "*", "mask_width", "\n", "and", "\n", "subdivision_step", "<", "self", ".", "test_cfg", ".", "subdivision_steps", "-", "1", ")", ":", "\n", "                ", "continue", "\n", "", "point_indices", ",", "rel_roi_points", "=", "self", ".", "point_head", ".", "get_roi_rel_points_test", "(", "\n", "refined_mask_pred", ",", "label_pred", ",", "cfg", "=", "self", ".", "test_cfg", ")", "\n", "fine_grained_point_feats", "=", "self", ".", "_get_fine_grained_point_feats", "(", "\n", "x", ",", "rois", ",", "rel_roi_points", ",", "img_metas", ")", "\n", "coarse_point_feats", "=", "point_sample", "(", "mask_pred", ",", "rel_roi_points", ")", "\n", "mask_point_pred", "=", "self", ".", "point_head", "(", "fine_grained_point_feats", ",", "\n", "coarse_point_feats", ")", "\n", "\n", "point_indices", "=", "point_indices", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "channels", ",", "-", "1", ")", "\n", "refined_mask_pred", "=", "refined_mask_pred", ".", "reshape", "(", "\n", "num_rois", ",", "channels", ",", "mask_height", "*", "mask_width", ")", "\n", "refined_mask_pred", "=", "refined_mask_pred", ".", "scatter_", "(", "\n", "2", ",", "point_indices", ",", "mask_point_pred", ")", "\n", "refined_mask_pred", "=", "refined_mask_pred", ".", "view", "(", "num_rois", ",", "channels", ",", "\n", "mask_height", ",", "mask_width", ")", "\n", "\n", "", "return", "refined_mask_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.simple_test_mask": [[134, 161], ["mmdet.core.bbox2roi", "point_rend_roi_head.PointRendRoIHead._mask_forward", "point_rend_roi_head.PointRendRoIHead._mask_point_forward_test", "point_rend_roi_head.PointRendRoIHead.mask_head.get_seg_masks", "det_bboxes.new_tensor", "range", "isinstance"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_point_forward_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks"], ["", "def", "simple_test_mask", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Obtain mask prediction without augmentation.\"\"\"", "\n", "# image shape of the first image in the batch (only one)", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "# if det_bboxes is rescaled to the original image size, we need to", "\n", "# rescale it back to the testing scale to obtain RoIs.", "\n", "            ", "if", "rescale", "and", "not", "isinstance", "(", "scale_factor", ",", "float", ")", ":", "\n", "                ", "scale_factor", "=", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "scale_factor", "if", "rescale", "else", "det_bboxes", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "mask_results", "[", "'mask_pred'", "]", "=", "self", ".", "_mask_point_forward_test", "(", "\n", "x", ",", "mask_rois", ",", "det_labels", ",", "mask_results", "[", "'mask_pred'", "]", ",", "img_metas", ")", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ",", "_bboxes", ",", "det_labels", ",", "self", ".", "test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "", "return", "segm_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead.aug_test_mask": [[162, 194], ["zip", "mmdet.core.merge_aug_masks", "point_rend_roi_head.PointRendRoIHead.mask_head.get_seg_masks", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "point_rend_roi_head.PointRendRoIHead._mask_forward", "point_rend_roi_head.PointRendRoIHead._mask_point_forward_test", "aug_masks.append", "range", "mask_results[].sigmoid().cpu().numpy", "mask_results[].sigmoid().cpu", "mask_results[].sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.point_rend_roi_head.PointRendRoIHead._mask_point_forward_test"], ["", "def", "aug_test_mask", "(", "self", ",", "feats", ",", "img_metas", ",", "det_bboxes", ",", "det_labels", ")", ":", "\n", "        ", "\"\"\"Test for mask head with test time augmentation.\"\"\"", "\n", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "            ", "aug_masks", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "feats", ",", "img_metas", ")", ":", "\n", "                ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "_bboxes", "=", "bbox_mapping", "(", "det_bboxes", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "mask_results", "[", "'mask_pred'", "]", "=", "self", ".", "_mask_point_forward_test", "(", "\n", "x", ",", "mask_rois", ",", "det_labels", ",", "mask_results", "[", "'mask_pred'", "]", ",", "\n", "img_metas", ")", "\n", "# convert to numpy array to save memory", "\n", "aug_masks", ".", "append", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "img_metas", ",", "self", ".", "test_cfg", ")", "\n", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "self", ".", "test_cfg", ",", "\n", "ori_shape", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "rescale", "=", "False", ")", "\n", "", "return", "segm_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead.__init__": [[15, 25], ["standard_roi_head.StandardRoIHead.__init__", "builder.build_head", "builder.build_roi_extractor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor"], ["def", "__init__", "(", "self", ",", "grid_roi_extractor", ",", "grid_head", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "grid_head", "is", "not", "None", "\n", "super", "(", "GridRoIHead", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "if", "grid_roi_extractor", "is", "not", "None", ":", "\n", "            ", "self", ".", "grid_roi_extractor", "=", "build_roi_extractor", "(", "grid_roi_extractor", ")", "\n", "self", ".", "share_roi_extractor", "=", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "share_roi_extractor", "=", "True", "\n", "self", ".", "grid_roi_extractor", "=", "self", ".", "bbox_roi_extractor", "\n", "", "self", ".", "grid_head", "=", "build_head", "(", "grid_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead.init_weights": [[26, 37], ["super().init_weights", "grid_roi_head.GridRoIHead.grid_head.init_weights", "grid_roi_head.GridRoIHead.grid_roi_extractor.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "GridRoIHead", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "grid_head", ".", "init_weights", "(", ")", "\n", "if", "not", "self", ".", "share_roi_extractor", ":", "\n", "            ", "self", ".", "grid_roi_extractor", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead._random_jitter": [[38, 62], ["zip", "bboxes.new_empty().uniform_", "torch.cat", "new_bboxes[].clamp_", "new_bboxes[].clamp_", "bboxes.new_empty"], "methods", ["None"], ["", "", "def", "_random_jitter", "(", "self", ",", "sampling_results", ",", "img_metas", ",", "amplitude", "=", "0.15", ")", ":", "\n", "        ", "\"\"\"Ramdom jitter positive proposals for training.\"\"\"", "\n", "for", "sampling_result", ",", "img_meta", "in", "zip", "(", "sampling_results", ",", "img_metas", ")", ":", "\n", "            ", "bboxes", "=", "sampling_result", ".", "pos_bboxes", "\n", "random_offsets", "=", "bboxes", ".", "new_empty", "(", "bboxes", ".", "shape", "[", "0", "]", ",", "4", ")", ".", "uniform_", "(", "\n", "-", "amplitude", ",", "amplitude", ")", "\n", "# before jittering", "\n", "cxcy", "=", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", "\n", "wh", "=", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "-", "bboxes", "[", ":", ",", ":", "2", "]", ")", ".", "abs", "(", ")", "\n", "# after jittering", "\n", "new_cxcy", "=", "cxcy", "+", "wh", "*", "random_offsets", "[", ":", ",", ":", "2", "]", "\n", "new_wh", "=", "wh", "*", "(", "1", "+", "random_offsets", "[", ":", ",", "2", ":", "]", ")", "\n", "# xywh to xyxy", "\n", "new_x1y1", "=", "(", "new_cxcy", "-", "new_wh", "/", "2", ")", "\n", "new_x2y2", "=", "(", "new_cxcy", "+", "new_wh", "/", "2", ")", "\n", "new_bboxes", "=", "torch", ".", "cat", "(", "[", "new_x1y1", ",", "new_x2y2", "]", ",", "dim", "=", "1", ")", "\n", "# clip bboxes", "\n", "max_shape", "=", "img_meta", "[", "'img_shape'", "]", "\n", "if", "max_shape", "is", "not", "None", ":", "\n", "                ", "new_bboxes", "[", ":", ",", "0", ":", ":", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", "-", "1", ")", "\n", "new_bboxes", "[", ":", ",", "1", ":", ":", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", "-", "1", ")", "\n", "\n", "", "sampling_result", ".", "pos_bboxes", "=", "new_bboxes", "\n", "", "return", "sampling_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead.forward_dummy": [[63, 88], ["mmdet.core.bbox2roi", "grid_roi_head.GridRoIHead.grid_roi_extractor", "grid_roi_head.GridRoIHead.grid_head", "grid_roi_head.GridRoIHead._bbox_forward", "grid_roi_head.GridRoIHead.shared_head", "grid_roi_head.GridRoIHead._mask_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "def", "forward_dummy", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"Dummy forward function.\"\"\"", "\n", "# bbox head", "\n", "outs", "=", "(", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "outs", "=", "outs", "+", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ")", "\n", "\n", "# grid head", "\n", "", "grid_rois", "=", "rois", "[", ":", "100", "]", "\n", "grid_feats", "=", "self", ".", "grid_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "grid_roi_extractor", ".", "num_inputs", "]", ",", "grid_rois", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "grid_feats", "=", "self", ".", "shared_head", "(", "grid_feats", ")", "\n", "", "grid_pred", "=", "self", ".", "grid_head", "(", "grid_feats", ")", "\n", "outs", "=", "outs", "+", "(", "grid_pred", ",", ")", "\n", "\n", "# mask head", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_rois", "=", "rois", "[", ":", "100", "]", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "outs", "=", "outs", "+", "(", "mask_results", "[", "'mask_pred'", "]", ",", ")", "\n", "", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead._bbox_forward_train": [[89, 126], ["super()._bbox_forward_train", "grid_roi_head.GridRoIHead._random_jitter", "mmdet.core.bbox2roi", "grid_roi_head.GridRoIHead.grid_roi_extractor", "grid_roi_head.GridRoIHead.train_cfg.get", "grid_roi_head.GridRoIHead.grid_head", "grid_roi_head.GridRoIHead.grid_head.get_targets", "grid_roi_head.GridRoIHead.grid_head.loss", "bbox_results[].update", "grid_roi_head.GridRoIHead.shared_head", "torch.randperm", "min"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead._random_jitter", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for box head in training.\"\"\"", "\n", "bbox_results", "=", "super", "(", "GridRoIHead", ",", "\n", "self", ")", ".", "_bbox_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", "\n", "\n", "# Grid head forward and loss", "\n", "sampling_results", "=", "self", ".", "_random_jitter", "(", "sampling_results", ",", "img_metas", ")", "\n", "pos_rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "\n", "# GN in head does not support zero shape input", "\n", "if", "pos_rois", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "bbox_results", "\n", "\n", "", "grid_feats", "=", "self", ".", "grid_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "grid_roi_extractor", ".", "num_inputs", "]", ",", "pos_rois", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "grid_feats", "=", "self", ".", "shared_head", "(", "grid_feats", ")", "\n", "# Accelerate training", "\n", "", "max_sample_num_grid", "=", "self", ".", "train_cfg", ".", "get", "(", "'max_num_grid'", ",", "192", ")", "\n", "sample_idx", "=", "torch", ".", "randperm", "(", "\n", "grid_feats", ".", "shape", "[", "0", "]", ")", "[", ":", "min", "(", "grid_feats", ".", "shape", "[", "0", "]", ",", "max_sample_num_grid", "\n", ")", "]", "\n", "grid_feats", "=", "grid_feats", "[", "sample_idx", "]", "\n", "\n", "grid_pred", "=", "self", ".", "grid_head", "(", "grid_feats", ")", "\n", "\n", "grid_targets", "=", "self", ".", "grid_head", ".", "get_targets", "(", "sampling_results", ",", "\n", "self", ".", "train_cfg", ")", "\n", "grid_targets", "=", "grid_targets", "[", "sample_idx", "]", "\n", "\n", "loss_grid", "=", "self", ".", "grid_head", ".", "loss", "(", "grid_pred", ",", "grid_targets", ")", "\n", "\n", "bbox_results", "[", "'loss_bbox'", "]", ".", "update", "(", "loss_grid", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.grid_roi_head.GridRoIHead.simple_test": [[127, 165], ["grid_roi_head.GridRoIHead.simple_test_bboxes", "mmdet.core.bbox2roi", "mmdet.core.bbox2result", "grid_roi_head.GridRoIHead.grid_roi_extractor", "grid_roi_head.GridRoIHead.grid_head", "grid_roi_head.GridRoIHead.grid_head.get_bboxes", "torch.Tensor", "grid_roi_head.GridRoIHead.simple_test_mask", "isinstance", "torch.Tensor.new_tensor", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.BBoxTestMixin.simple_test_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.MaskTestMixin.simple_test_mask"], ["", "def", "simple_test", "(", "self", ",", "\n", "x", ",", "\n", "proposal_list", ",", "\n", "img_metas", ",", "\n", "proposals", "=", "None", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "assert", "self", ".", "with_bbox", ",", "'Bbox head must be implemented.'", "\n", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "simple_test_bboxes", "(", "\n", "x", ",", "img_metas", ",", "proposal_list", ",", "self", ".", "test_cfg", ",", "rescale", "=", "False", ")", "\n", "# pack rois into bboxes", "\n", "grid_rois", "=", "bbox2roi", "(", "[", "det_bboxes", "[", ":", ",", ":", "4", "]", "]", ")", "\n", "if", "grid_rois", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "grid_feats", "=", "self", ".", "grid_roi_extractor", "(", "\n", "x", "[", ":", "len", "(", "self", ".", "grid_roi_extractor", ".", "featmap_strides", ")", "]", ",", "grid_rois", ")", "\n", "self", ".", "grid_head", ".", "test_mode", "=", "True", "\n", "grid_pred", "=", "self", ".", "grid_head", "(", "grid_feats", ")", "\n", "det_bboxes", "=", "self", ".", "grid_head", ".", "get_bboxes", "(", "det_bboxes", ",", "\n", "grid_pred", "[", "'fused'", "]", ",", "\n", "img_metas", ")", "\n", "if", "rescale", ":", "\n", "                ", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "if", "not", "isinstance", "(", "scale_factor", ",", "(", "float", ",", "torch", ".", "Tensor", ")", ")", ":", "\n", "                    ", "scale_factor", "=", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "det_bboxes", "[", ":", ",", ":", "4", "]", "/=", "scale_factor", "\n", "", "", "else", ":", "\n", "            ", "det_bboxes", "=", "torch", ".", "Tensor", "(", "[", "]", ")", "\n", "\n", "", "bbox_results", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "\n", "if", "not", "self", ".", "with_mask", ":", "\n", "            ", "return", "bbox_results", "\n", "", "else", ":", "\n", "            ", "segm_results", "=", "self", ".", "simple_test_mask", "(", "\n", "x", ",", "img_metas", ",", "det_bboxes", ",", "det_labels", ",", "rescale", "=", "rescale", ")", "\n", "return", "bbox_results", ",", "segm_results", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.dynamic_roi_head.DynamicRoIHead.__init__": [[14, 21], ["standard_roi_head.StandardRoIHead.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DynamicRoIHead", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "isinstance", "(", "self", ".", "bbox_head", ".", "loss_bbox", ",", "SmoothL1Loss", ")", "\n", "# the IoU history of the past `update_iter_interval` iterations", "\n", "self", ".", "iou_history", "=", "[", "]", "\n", "# the beta history of the past `update_iter_interval` iterations", "\n", "self", ".", "beta_history", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.dynamic_roi_head.DynamicRoIHead.forward_train": [[22, 107], ["dict", "len", "range", "numpy.mean", "dynamic_roi_head.DynamicRoIHead.iou_history.append", "dynamic_roi_head.DynamicRoIHead._bbox_forward_train", "dict.update", "dynamic_roi_head.DynamicRoIHead._mask_forward_train", "dynamic_roi_head.DynamicRoIHead.update_hyperparameters", "dynamic_roi_head.DynamicRoIHead.bbox_assigner.assign", "dynamic_roi_head.DynamicRoIHead.bbox_sampler.sample", "min", "torch.topk", "numpy.mean.append", "sampling_results.append", "dict.update", "len", "len", "ious[].item", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.dynamic_roi_head.DynamicRoIHead.update_hyperparameters", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function for training.\n\n        Args:\n            x (list[Tensor]): list of multi-level img features.\n\n            img_metas (list[dict]): list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n\n            proposals (list[Tensors]): list of region proposals.\n\n            gt_bboxes (list[Tensor]): each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n\n            gt_labels (list[Tensor]): class indices corresponding to each box\n\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n            gt_masks (None | Tensor) : true segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "# assign gts and sample proposals", "\n", "if", "self", ".", "with_bbox", "or", "self", ".", "with_mask", ":", "\n", "            ", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "sampling_results", "=", "[", "]", "\n", "cur_iou", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "                ", "assign_result", "=", "self", ".", "bbox_assigner", ".", "assign", "(", "\n", "proposal_list", "[", "i", "]", ",", "gt_bboxes", "[", "i", "]", ",", "gt_bboxes_ignore", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ")", "\n", "sampling_result", "=", "self", ".", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "i", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "# record the `iou_topk`-th largest IoU in an image", "\n", "iou_topk", "=", "min", "(", "self", ".", "train_cfg", ".", "dynamic_rcnn", ".", "iou_topk", ",", "\n", "len", "(", "assign_result", ".", "max_overlaps", ")", ")", "\n", "ious", ",", "_", "=", "torch", ".", "topk", "(", "assign_result", ".", "max_overlaps", ",", "iou_topk", ")", "\n", "cur_iou", ".", "append", "(", "ious", "[", "-", "1", "]", ".", "item", "(", ")", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "# average the current IoUs over images", "\n", "", "cur_iou", "=", "np", ".", "mean", "(", "cur_iou", ")", "\n", "self", ".", "iou_history", ".", "append", "(", "cur_iou", ")", "\n", "\n", "", "losses", "=", "dict", "(", ")", "\n", "# bbox head forward and loss", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", "\n", "losses", ".", "update", "(", "bbox_results", "[", "'loss_bbox'", "]", ")", "\n", "\n", "# mask head forward and loss", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_results", "=", "self", ".", "_mask_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "bbox_results", "[", "'bbox_feats'", "]", ",", "\n", "gt_masks", ",", "img_metas", ")", "\n", "# TODO: Support empty tensor input. #2280", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "not", "None", ":", "\n", "                ", "losses", ".", "update", "(", "mask_results", "[", "'loss_mask'", "]", ")", "\n", "\n", "# update IoU threshold and SmoothL1 beta", "\n", "", "", "update_iter_interval", "=", "self", ".", "train_cfg", ".", "dynamic_rcnn", ".", "update_iter_interval", "\n", "if", "len", "(", "self", ".", "iou_history", ")", "%", "update_iter_interval", "==", "0", ":", "\n", "            ", "new_iou_thr", ",", "new_beta", "=", "self", ".", "update_hyperparameters", "(", ")", "\n", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.dynamic_roi_head.DynamicRoIHead._bbox_forward_train": [[108, 132], ["len", "mmdet.core.bbox2roi", "dynamic_roi_head.DynamicRoIHead._bbox_forward", "dynamic_roi_head.DynamicRoIHead.bbox_head.get_targets", "[].nonzero().squeeze", "len", "[].abs().mean", "min", "[].item", "dynamic_roi_head.DynamicRoIHead.beta_history.append", "dynamic_roi_head.DynamicRoIHead.bbox_head.loss", "dynamic_roi_head.DynamicRoIHead.update", "[].nonzero", "[].abs", "torch.kthvalue"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", ":", "\n", "        ", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "\n", "bbox_targets", "=", "self", ".", "bbox_head", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "self", ".", "train_cfg", ")", "\n", "# record the `beta_topk`-th smallest target", "\n", "# `bbox_targets[2]` and `bbox_targets[3]` stand for bbox_targets", "\n", "# and bbox_weights, respectively", "\n", "pos_inds", "=", "bbox_targets", "[", "3", "]", "[", ":", ",", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "num_pos", "=", "len", "(", "pos_inds", ")", "\n", "cur_target", "=", "bbox_targets", "[", "2", "]", "[", "pos_inds", ",", ":", "2", "]", ".", "abs", "(", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "beta_topk", "=", "min", "(", "self", ".", "train_cfg", ".", "dynamic_rcnn", ".", "beta_topk", "*", "num_imgs", ",", "\n", "num_pos", ")", "\n", "cur_target", "=", "torch", ".", "kthvalue", "(", "cur_target", ",", "beta_topk", ")", "[", "0", "]", ".", "item", "(", ")", "\n", "self", ".", "beta_history", ".", "append", "(", "cur_target", ")", "\n", "loss_bbox", "=", "self", ".", "bbox_head", ".", "loss", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "rois", ",", "\n", "*", "bbox_targets", ")", "\n", "\n", "bbox_results", ".", "update", "(", "loss_bbox", "=", "loss_bbox", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.dynamic_roi_head.DynamicRoIHead.update_hyperparameters": [[133, 151], ["max", "min", "numpy.mean", "numpy.median"], "methods", ["None"], ["", "def", "update_hyperparameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update hyperparameters like IoU thresholds for assigner and beta for\n        SmoothL1 loss based on the training statistics.\n\n        Returns:\n            tuple[float]: the updated ``iou_thr`` and ``beta``.\n        \"\"\"", "\n", "new_iou_thr", "=", "max", "(", "self", ".", "train_cfg", ".", "dynamic_rcnn", ".", "initial_iou", ",", "\n", "np", ".", "mean", "(", "self", ".", "iou_history", ")", ")", "\n", "self", ".", "iou_history", "=", "[", "]", "\n", "self", ".", "bbox_assigner", ".", "pos_iou_thr", "=", "new_iou_thr", "\n", "self", ".", "bbox_assigner", ".", "neg_iou_thr", "=", "new_iou_thr", "\n", "self", ".", "bbox_assigner", ".", "min_pos_iou", "=", "new_iou_thr", "\n", "new_beta", "=", "min", "(", "self", ".", "train_cfg", ".", "dynamic_rcnn", ".", "initial_beta", ",", "\n", "np", ".", "median", "(", "self", ".", "beta_history", ")", ")", "\n", "self", ".", "beta_history", "=", "[", "]", "\n", "self", ".", "bbox_head", ".", "loss_bbox", ".", "beta", "=", "new_beta", "\n", "return", "new_iou_thr", ",", "new_beta", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.pisa_roi_head.PISARoIHead.forward_train": [[12, 87], ["dict", "len", "range", "pisa_roi_head.PISARoIHead._bbox_forward_train", "dict.update", "pisa_roi_head.PISARoIHead._mask_forward_train", "pisa_roi_head.PISARoIHead.bbox_assigner.assign", "pisa_roi_head.PISARoIHead.bbox_sampler.sample", "isinstance", "sampling_results.append", "neg_label_weights.append", "dict.update", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function for training.\n\n        Args:\n            x (list[Tensor]): List of multi-level img features.\n            img_metas (list[dict]): List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n            proposals (list[Tensors]): List of region proposals.\n            gt_bboxes (list[Tensor]): Each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): Class indices corresponding to each box\n            gt_bboxes_ignore (list[Tensor], optional): Specify which bounding\n                boxes can be ignored when computing the loss.\n            gt_masks (None | Tensor) : True segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "# assign gts and sample proposals", "\n", "if", "self", ".", "with_bbox", "or", "self", ".", "with_mask", ":", "\n", "            ", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "sampling_results", "=", "[", "]", "\n", "neg_label_weights", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "                ", "assign_result", "=", "self", ".", "bbox_assigner", ".", "assign", "(", "\n", "proposal_list", "[", "i", "]", ",", "gt_bboxes", "[", "i", "]", ",", "gt_bboxes_ignore", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ")", "\n", "sampling_result", "=", "self", ".", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "i", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "# neg label weight is obtained by sampling when using ISR-N", "\n", "neg_label_weight", "=", "None", "\n", "if", "isinstance", "(", "sampling_result", ",", "tuple", ")", ":", "\n", "                    ", "sampling_result", ",", "neg_label_weight", "=", "sampling_result", "\n", "", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "neg_label_weights", ".", "append", "(", "neg_label_weight", ")", "\n", "\n", "", "", "losses", "=", "dict", "(", ")", "\n", "# bbox head forward and loss", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward_train", "(", "\n", "x", ",", "\n", "sampling_results", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "neg_label_weights", "=", "neg_label_weights", ")", "\n", "losses", ".", "update", "(", "bbox_results", "[", "'loss_bbox'", "]", ")", "\n", "\n", "# mask head forward and loss", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_results", "=", "self", ".", "_mask_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "bbox_results", "[", "'bbox_feats'", "]", ",", "\n", "gt_masks", ",", "img_metas", ")", "\n", "# TODO: Support empty tensor input. #2280", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "not", "None", ":", "\n", "                ", "losses", ".", "update", "(", "mask_results", "[", "'loss_mask'", "]", ")", "\n", "\n", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.pisa_roi_head.PISARoIHead._bbox_forward": [[88, 100], ["pisa_roi_head.PISARoIHead.bbox_roi_extractor", "pisa_roi_head.PISARoIHead.bbox_head", "dict", "pisa_roi_head.PISARoIHead.shared_head"], "methods", ["None"], ["", "def", "_bbox_forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "\"\"\"Box forward function used in both training and testing.\"\"\"", "\n", "# TODO: a more flexible way to decide which feature maps to use", "\n", "bbox_feats", "=", "self", ".", "bbox_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "rois", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "bbox_feats", "=", "self", ".", "shared_head", "(", "bbox_feats", ")", "\n", "", "cls_score", ",", "bbox_pred", "=", "self", ".", "bbox_head", "(", "bbox_feats", ")", "\n", "\n", "bbox_results", "=", "dict", "(", "\n", "cls_score", "=", "cls_score", ",", "bbox_pred", "=", "bbox_pred", ",", "bbox_feats", "=", "bbox_feats", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.pisa_roi_head.PISARoIHead._bbox_forward_train": [[101, 162], ["mmdet.core.bbox2roi", "pisa_roi_head.PISARoIHead._bbox_forward", "pisa_roi_head.PISARoIHead.bbox_head.get_targets", "pisa_roi_head.PISARoIHead.train_cfg.get", "pisa_roi_head.PISARoIHead.bbox_head.loss", "pisa_roi_head.PISARoIHead.train_cfg.get", "pisa_roi_head.PISARoIHead.update", "range", "losses.pisa_loss.isr_p", "losses.pisa_loss.carl_loss", "pisa_roi_head.PISARoIHead.update", "len", "sampling_results[].pos_inds.size", "sampling_results[].neg_inds.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.isr_p", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.carl_loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "\n", "x", ",", "\n", "sampling_results", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "neg_label_weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for box head in training.\"\"\"", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "\n", "bbox_targets", "=", "self", ".", "bbox_head", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "self", ".", "train_cfg", ")", "\n", "\n", "# neg_label_weights obtained by sampler is image-wise, mapping back to", "\n", "# the corresponding location in label weights", "\n", "if", "neg_label_weights", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "label_weights", "=", "bbox_targets", "[", "1", "]", "\n", "cur_num_rois", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "sampling_results", ")", ")", ":", "\n", "                ", "num_pos", "=", "sampling_results", "[", "i", "]", ".", "pos_inds", ".", "size", "(", "0", ")", "\n", "num_neg", "=", "sampling_results", "[", "i", "]", ".", "neg_inds", ".", "size", "(", "0", ")", "\n", "label_weights", "[", "cur_num_rois", "+", "num_pos", ":", "cur_num_rois", "+", "num_pos", "+", "\n", "num_neg", "]", "=", "neg_label_weights", "[", "i", "]", "\n", "cur_num_rois", "+=", "num_pos", "+", "num_neg", "\n", "\n", "", "", "cls_score", "=", "bbox_results", "[", "'cls_score'", "]", "\n", "bbox_pred", "=", "bbox_results", "[", "'bbox_pred'", "]", "\n", "\n", "# Apply ISR-P", "\n", "isr_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'isr'", ",", "None", ")", "\n", "if", "isr_cfg", "is", "not", "None", ":", "\n", "            ", "bbox_targets", "=", "isr_p", "(", "\n", "cls_score", ",", "\n", "bbox_pred", ",", "\n", "bbox_targets", ",", "\n", "rois", ",", "\n", "sampling_results", ",", "\n", "self", ".", "bbox_head", ".", "loss_cls", ",", "\n", "self", ".", "bbox_head", ".", "bbox_coder", ",", "\n", "**", "isr_cfg", ",", "\n", "num_class", "=", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "", "loss_bbox", "=", "self", ".", "bbox_head", ".", "loss", "(", "cls_score", ",", "bbox_pred", ",", "rois", ",", "\n", "*", "bbox_targets", ")", "\n", "\n", "# Add CARL Loss", "\n", "carl_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'carl'", ",", "None", ")", "\n", "if", "carl_cfg", "is", "not", "None", ":", "\n", "            ", "loss_carl", "=", "carl_loss", "(", "\n", "cls_score", ",", "\n", "bbox_targets", "[", "0", "]", ",", "\n", "bbox_pred", ",", "\n", "bbox_targets", "[", "2", "]", ",", "\n", "self", ".", "bbox_head", ".", "loss_bbox", ",", "\n", "**", "carl_cfg", ",", "\n", "num_class", "=", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "loss_bbox", ".", "update", "(", "loss_carl", ")", "\n", "\n", "", "bbox_results", ".", "update", "(", "loss_bbox", "=", "loss_bbox", ")", "\n", "return", "bbox_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.init_assigner_sampler": [[13, 21], ["mmdet.core.build_assigner", "mmdet.core.build_sampler"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "init_assigner_sampler", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize assigner and sampler.\"\"\"", "\n", "self", ".", "bbox_assigner", "=", "None", "\n", "self", ".", "bbox_sampler", "=", "None", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "bbox_assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "self", ".", "bbox_sampler", "=", "build_sampler", "(", "\n", "self", ".", "train_cfg", ".", "sampler", ",", "context", "=", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.init_bbox_head": [[22, 26], ["builder.build_roi_extractor", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["", "", "def", "init_bbox_head", "(", "self", ",", "bbox_roi_extractor", ",", "bbox_head", ")", ":", "\n", "        ", "\"\"\"Initialize ``bbox_head``\"\"\"", "\n", "self", ".", "bbox_roi_extractor", "=", "build_roi_extractor", "(", "bbox_roi_extractor", ")", "\n", "self", ".", "bbox_head", "=", "build_head", "(", "bbox_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.init_mask_head": [[27, 36], ["builder.build_head", "builder.build_roi_extractor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor"], ["", "def", "init_mask_head", "(", "self", ",", "mask_roi_extractor", ",", "mask_head", ")", ":", "\n", "        ", "\"\"\"Initialize ``mask_head``\"\"\"", "\n", "if", "mask_roi_extractor", "is", "not", "None", ":", "\n", "            ", "self", ".", "mask_roi_extractor", "=", "build_roi_extractor", "(", "mask_roi_extractor", ")", "\n", "self", ".", "share_roi_extractor", "=", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "share_roi_extractor", "=", "True", "\n", "self", ".", "mask_roi_extractor", "=", "self", ".", "bbox_roi_extractor", "\n", "", "self", ".", "mask_head", "=", "build_head", "(", "mask_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.init_weights": [[37, 53], ["standard_roi_head.StandardRoIHead.shared_head.init_weights", "standard_roi_head.StandardRoIHead.bbox_roi_extractor.init_weights", "standard_roi_head.StandardRoIHead.bbox_head.init_weights", "standard_roi_head.StandardRoIHead.mask_head.init_weights", "standard_roi_head.StandardRoIHead.mask_roi_extractor.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "self", ".", "shared_head", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "", "if", "self", ".", "with_bbox", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", ".", "init_weights", "(", ")", "\n", "self", ".", "bbox_head", ".", "init_weights", "(", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "self", ".", "mask_head", ".", "init_weights", "(", ")", "\n", "if", "not", "self", ".", "share_roi_extractor", ":", "\n", "                ", "self", ".", "mask_roi_extractor", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.forward_dummy": [[54, 69], ["mmdet.core.bbox2roi", "standard_roi_head.StandardRoIHead._bbox_forward", "standard_roi_head.StandardRoIHead._mask_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "", "", "def", "forward_dummy", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"Dummy forward function.\"\"\"", "\n", "# bbox head", "\n", "outs", "=", "(", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "outs", "=", "outs", "+", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ")", "\n", "# mask head", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_rois", "=", "rois", "[", ":", "100", "]", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "outs", "=", "outs", "+", "(", "mask_results", "[", "'mask_pred'", "]", ",", ")", "\n", "", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.forward_train": [[70, 134], ["dict", "len", "range", "standard_roi_head.StandardRoIHead._bbox_forward_train", "dict.update", "standard_roi_head.StandardRoIHead._mask_forward_train", "standard_roi_head.StandardRoIHead.bbox_assigner.assign", "standard_roi_head.StandardRoIHead.bbox_sampler.sample", "sampling_results.append", "dict.update", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): list of multi-level img features.\n            img_metas (list[dict]): list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n            proposals (list[Tensors]): list of region proposals.\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n            gt_masks (None | Tensor) : true segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "# assign gts and sample proposals", "\n", "if", "self", ".", "with_bbox", "or", "self", ".", "with_mask", ":", "\n", "            ", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "sampling_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "                ", "assign_result", "=", "self", ".", "bbox_assigner", ".", "assign", "(", "\n", "proposal_list", "[", "i", "]", ",", "gt_bboxes", "[", "i", "]", ",", "gt_bboxes_ignore", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ")", "\n", "sampling_result", "=", "self", ".", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "i", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "\n", "", "", "losses", "=", "dict", "(", ")", "\n", "# bbox head forward and loss", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", "\n", "losses", ".", "update", "(", "bbox_results", "[", "'loss_bbox'", "]", ")", "\n", "\n", "# mask head forward and loss", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_results", "=", "self", ".", "_mask_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "bbox_results", "[", "'bbox_feats'", "]", ",", "\n", "gt_masks", ",", "img_metas", ")", "\n", "# TODO: Support empty tensor input. #2280", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "not", "None", ":", "\n", "                ", "losses", ".", "update", "(", "mask_results", "[", "'loss_mask'", "]", ")", "\n", "\n", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead._bbox_forward": [[135, 147], ["standard_roi_head.StandardRoIHead.bbox_roi_extractor", "standard_roi_head.StandardRoIHead.bbox_head", "dict", "standard_roi_head.StandardRoIHead.shared_head"], "methods", ["None"], ["", "def", "_bbox_forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "\"\"\"Box head forward function used in both training and testing.\"\"\"", "\n", "# TODO: a more flexible way to decide which feature maps to use", "\n", "bbox_feats", "=", "self", ".", "bbox_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "rois", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "bbox_feats", "=", "self", ".", "shared_head", "(", "bbox_feats", ")", "\n", "", "cls_score", ",", "bbox_pred", "=", "self", ".", "bbox_head", "(", "bbox_feats", ")", "\n", "\n", "bbox_results", "=", "dict", "(", "\n", "cls_score", "=", "cls_score", ",", "bbox_pred", "=", "bbox_pred", ",", "bbox_feats", "=", "bbox_feats", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead._bbox_forward_train": [[148, 162], ["mmdet.core.bbox2roi", "standard_roi_head.StandardRoIHead._bbox_forward", "standard_roi_head.StandardRoIHead.bbox_head.get_targets", "standard_roi_head.StandardRoIHead.bbox_head.loss", "standard_roi_head.StandardRoIHead.update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for box head in training.\"\"\"", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "\n", "bbox_targets", "=", "self", ".", "bbox_head", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "self", ".", "train_cfg", ")", "\n", "loss_bbox", "=", "self", ".", "bbox_head", ".", "loss", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "rois", ",", "\n", "*", "bbox_targets", ")", "\n", "\n", "bbox_results", ".", "update", "(", "loss_bbox", "=", "loss_bbox", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead._mask_forward_train": [[163, 200], ["standard_roi_head.StandardRoIHead.mask_head.get_targets", "torch.cat", "standard_roi_head.StandardRoIHead.mask_head.loss", "standard_roi_head.StandardRoIHead.update", "mmdet.core.bbox2roi", "standard_roi_head.StandardRoIHead._mask_forward", "torch.cat", "standard_roi_head.StandardRoIHead._mask_forward", "dict", "torch.cat.append", "torch.cat.append", "dict", "torch.ones", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "def", "_mask_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "bbox_feats", ",", "gt_masks", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for mask head in\n        training.\"\"\"", "\n", "if", "not", "self", ".", "share_roi_extractor", ":", "\n", "            ", "pos_rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "if", "pos_rois", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "return", "dict", "(", "loss_mask", "=", "None", ")", "\n", "", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "pos_rois", ")", "\n", "", "else", ":", "\n", "            ", "pos_inds", "=", "[", "]", "\n", "device", "=", "bbox_feats", ".", "device", "\n", "for", "res", "in", "sampling_results", ":", "\n", "                ", "pos_inds", ".", "append", "(", "\n", "torch", ".", "ones", "(", "\n", "res", ".", "pos_bboxes", ".", "shape", "[", "0", "]", ",", "\n", "device", "=", "device", ",", "\n", "dtype", "=", "torch", ".", "uint8", ")", ")", "\n", "pos_inds", ".", "append", "(", "\n", "torch", ".", "zeros", "(", "\n", "res", ".", "neg_bboxes", ".", "shape", "[", "0", "]", ",", "\n", "device", "=", "device", ",", "\n", "dtype", "=", "torch", ".", "uint8", ")", ")", "\n", "", "pos_inds", "=", "torch", ".", "cat", "(", "pos_inds", ")", "\n", "if", "pos_inds", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "return", "dict", "(", "loss_mask", "=", "None", ")", "\n", "", "mask_results", "=", "self", ".", "_mask_forward", "(", "\n", "x", ",", "pos_inds", "=", "pos_inds", ",", "bbox_feats", "=", "bbox_feats", ")", "\n", "\n", "", "mask_targets", "=", "self", ".", "mask_head", ".", "get_targets", "(", "sampling_results", ",", "gt_masks", ",", "\n", "self", ".", "train_cfg", ")", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "loss_mask", "=", "self", ".", "mask_head", ".", "loss", "(", "mask_results", "[", "'mask_pred'", "]", ",", "\n", "mask_targets", ",", "pos_labels", ")", "\n", "\n", "mask_results", ".", "update", "(", "loss_mask", "=", "loss_mask", ",", "mask_targets", "=", "mask_targets", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead._mask_forward": [[201, 217], ["standard_roi_head.StandardRoIHead.mask_head", "dict", "standard_roi_head.StandardRoIHead.mask_roi_extractor", "standard_roi_head.StandardRoIHead.shared_head"], "methods", ["None"], ["", "def", "_mask_forward", "(", "self", ",", "x", ",", "rois", "=", "None", ",", "pos_inds", "=", "None", ",", "bbox_feats", "=", "None", ")", ":", "\n", "        ", "\"\"\"Mask head forward function used in both training and testing.\"\"\"", "\n", "assert", "(", "(", "rois", "is", "not", "None", ")", "^", "\n", "(", "pos_inds", "is", "not", "None", "and", "bbox_feats", "is", "not", "None", ")", ")", "\n", "if", "rois", "is", "not", "None", ":", "\n", "            ", "mask_feats", "=", "self", ".", "mask_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "mask_roi_extractor", ".", "num_inputs", "]", ",", "rois", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "                ", "mask_feats", "=", "self", ".", "shared_head", "(", "mask_feats", ")", "\n", "", "", "else", ":", "\n", "            ", "assert", "bbox_feats", "is", "not", "None", "\n", "mask_feats", "=", "bbox_feats", "[", "pos_inds", "]", "\n", "\n", "", "mask_pred", "=", "self", ".", "mask_head", "(", "mask_feats", ")", "\n", "mask_results", "=", "dict", "(", "mask_pred", "=", "mask_pred", ",", "mask_feats", "=", "mask_feats", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.simple_test": [[243, 263], ["standard_roi_head.StandardRoIHead.simple_test_bboxes", "mmdet.core.bbox2result", "standard_roi_head.StandardRoIHead.simple_test_mask"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.BBoxTestMixin.simple_test_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.MaskTestMixin.simple_test_mask"], ["", "", "def", "simple_test", "(", "self", ",", "\n", "x", ",", "\n", "proposal_list", ",", "\n", "img_metas", ",", "\n", "proposals", "=", "None", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "assert", "self", ".", "with_bbox", ",", "'Bbox head must be implemented.'", "\n", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "simple_test_bboxes", "(", "\n", "x", ",", "img_metas", ",", "proposal_list", ",", "self", ".", "test_cfg", ",", "rescale", "=", "rescale", ")", "\n", "bbox_results", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "\n", "if", "not", "self", ".", "with_mask", ":", "\n", "            ", "return", "bbox_results", "\n", "", "else", ":", "\n", "            ", "segm_results", "=", "self", ".", "simple_test_mask", "(", "\n", "x", ",", "img_metas", ",", "det_bboxes", ",", "det_labels", ",", "rescale", "=", "rescale", ")", "\n", "return", "bbox_results", ",", "segm_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.standard_roi_head.StandardRoIHead.aug_test": [[264, 291], ["standard_roi_head.StandardRoIHead.aug_test_bboxes", "mmdet.core.bbox2result", "det_bboxes.clone", "det_bboxes.new_tensor", "standard_roi_head.StandardRoIHead.aug_test_mask"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.BBoxTestMixin.aug_test_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.MaskTestMixin.aug_test_mask"], ["", "", "def", "aug_test", "(", "self", ",", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test with augmentations.\n\n        If rescale is False, then returned bboxes and masks will fit the scale\n        of imgs[0].\n        \"\"\"", "\n", "# recompute feats to save memory", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "aug_test_bboxes", "(", "x", ",", "img_metas", ",", "\n", "proposal_list", ",", "\n", "self", ".", "test_cfg", ")", "\n", "\n", "if", "rescale", ":", "\n", "            ", "_det_bboxes", "=", "det_bboxes", "\n", "", "else", ":", "\n", "            ", "_det_bboxes", "=", "det_bboxes", ".", "clone", "(", ")", "\n", "_det_bboxes", "[", ":", ",", ":", "4", "]", "*=", "det_bboxes", ".", "new_tensor", "(", "\n", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'scale_factor'", "]", ")", "\n", "", "bbox_results", "=", "bbox2result", "(", "_det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", ".", "num_classes", ")", "\n", "\n", "# det_bboxes always keep the original scale", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "segm_results", "=", "self", ".", "aug_test_mask", "(", "x", ",", "img_metas", ",", "det_bboxes", ",", "\n", "det_labels", ")", "\n", "return", "bbox_results", ",", "segm_results", "\n", "", "else", ":", "\n", "            ", "return", "bbox_results", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.mask_scoring_roi_head.MaskScoringRoIHead.__init__": [[15, 19], ["standard_roi_head.StandardRoIHead.__init__", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["def", "__init__", "(", "self", ",", "mask_iou_head", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "mask_iou_head", "is", "not", "None", "\n", "super", "(", "MaskScoringRoIHead", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "mask_iou_head", "=", "build_head", "(", "mask_iou_head", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.mask_scoring_roi_head.MaskScoringRoIHead.init_weights": [[20, 29], ["super().init_weights", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "super", "(", "MaskScoringRoIHead", ",", "self", ")", ".", "init_weights", "(", "pretrained", ")", "\n", "self", ".", "mask_iou_head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.mask_scoring_roi_head.MaskScoringRoIHead._mask_forward_train": [[30, 57], ["torch.cat", "super()._mask_forward_train", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head.get_targets", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head.loss", "mask_results[].update", "range", "range", "mask_results[].size", "mask_scoring_roi_head.MaskScoringRoIHead.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_mask_forward_train", "(", "self", ",", "x", ",", "sampling_results", ",", "bbox_feats", ",", "gt_masks", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for Mask head in\n        training.\"\"\"", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "mask_results", "=", "super", "(", "MaskScoringRoIHead", ",", "\n", "self", ")", ".", "_mask_forward_train", "(", "x", ",", "sampling_results", ",", "\n", "bbox_feats", ",", "gt_masks", ",", "\n", "img_metas", ")", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "None", ":", "\n", "            ", "return", "mask_results", "\n", "\n", "# mask iou head forward and loss", "\n", "", "pos_mask_pred", "=", "mask_results", "[", "'mask_pred'", "]", "[", "\n", "range", "(", "mask_results", "[", "'mask_pred'", "]", ".", "size", "(", "0", ")", ")", ",", "pos_labels", "]", "\n", "mask_iou_pred", "=", "self", ".", "mask_iou_head", "(", "mask_results", "[", "'mask_feats'", "]", ",", "\n", "pos_mask_pred", ")", "\n", "pos_mask_iou_pred", "=", "mask_iou_pred", "[", "range", "(", "mask_iou_pred", ".", "size", "(", "0", ")", ")", ",", "\n", "pos_labels", "]", "\n", "\n", "mask_iou_targets", "=", "self", ".", "mask_iou_head", ".", "get_targets", "(", "\n", "sampling_results", ",", "gt_masks", ",", "pos_mask_pred", ",", "\n", "mask_results", "[", "'mask_targets'", "]", ",", "self", ".", "train_cfg", ")", "\n", "loss_mask_iou", "=", "self", ".", "mask_iou_head", ".", "loss", "(", "pos_mask_iou_pred", ",", "\n", "mask_iou_targets", ")", "\n", "mask_results", "[", "'loss_mask'", "]", ".", "update", "(", "loss_mask_iou", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.mask_scoring_roi_head.MaskScoringRoIHead.simple_test_mask": [[58, 91], ["mmdet.core.bbox2roi", "mask_scoring_roi_head.MaskScoringRoIHead._mask_forward", "mask_scoring_roi_head.MaskScoringRoIHead.mask_head.get_seg_masks", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head", "mask_scoring_roi_head.MaskScoringRoIHead.mask_iou_head.get_mask_scores", "range", "range", "det_bboxes.new_tensor", "range", "det_labels.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.get_mask_scores"], ["", "def", "simple_test_mask", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Obtain mask prediction without augmentation.\"\"\"", "\n", "# image shape of the first image in the batch (only one)", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "\n", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "mask_scores", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "# if det_bboxes is rescaled to the original image size, we need to", "\n", "# rescale it back to the testing scale to obtain RoIs.", "\n", "            ", "_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "\n", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "if", "rescale", "else", "det_bboxes", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ",", "_bboxes", ",", "det_labels", ",", "self", ".", "test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "# get mask scores with mask iou head", "\n", "mask_iou_pred", "=", "self", ".", "mask_iou_head", "(", "\n", "mask_results", "[", "'mask_feats'", "]", ",", "\n", "mask_results", "[", "'mask_pred'", "]", "[", "range", "(", "det_labels", ".", "size", "(", "0", ")", ")", ",", "\n", "det_labels", "]", ")", "\n", "mask_scores", "=", "self", ".", "mask_iou_head", ".", "get_mask_scores", "(", "\n", "mask_iou_pred", ",", "det_bboxes", ",", "det_labels", ")", "\n", "", "return", "segm_result", ",", "mask_scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.double_roi_head.DoubleHeadRoIHead.__init__": [[12, 15], ["standard_roi_head.StandardRoIHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "reg_roi_scale_factor", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DoubleHeadRoIHead", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "reg_roi_scale_factor", "=", "reg_roi_scale_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.double_roi_head.DoubleHeadRoIHead._bbox_forward": [[16, 34], ["double_roi_head.DoubleHeadRoIHead.bbox_roi_extractor", "double_roi_head.DoubleHeadRoIHead.bbox_roi_extractor", "double_roi_head.DoubleHeadRoIHead.bbox_head", "dict", "double_roi_head.DoubleHeadRoIHead.shared_head", "double_roi_head.DoubleHeadRoIHead.shared_head"], "methods", ["None"], ["", "def", "_bbox_forward", "(", "self", ",", "x", ",", "rois", ")", ":", "\n", "        ", "\"\"\"Box head forward function used in both training and testing time.\"\"\"", "\n", "bbox_cls_feats", "=", "self", ".", "bbox_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "rois", ")", "\n", "bbox_reg_feats", "=", "self", ".", "bbox_roi_extractor", "(", "\n", "x", "[", ":", "self", ".", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "\n", "rois", ",", "\n", "roi_scale_factor", "=", "self", ".", "reg_roi_scale_factor", ")", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "bbox_cls_feats", "=", "self", ".", "shared_head", "(", "bbox_cls_feats", ")", "\n", "bbox_reg_feats", "=", "self", ".", "shared_head", "(", "bbox_reg_feats", ")", "\n", "", "cls_score", ",", "bbox_pred", "=", "self", ".", "bbox_head", "(", "bbox_cls_feats", ",", "bbox_reg_feats", ")", "\n", "\n", "bbox_results", "=", "dict", "(", "\n", "cls_score", "=", "cls_score", ",", "\n", "bbox_pred", "=", "bbox_pred", ",", "\n", "bbox_feats", "=", "bbox_cls_feats", ")", "\n", "return", "bbox_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.BBoxTestMixin.simple_test_bboxes": [[52, 72], ["mmdet.core.bbox2roi", "test_mixins.BBoxTestMixin._bbox_forward", "test_mixins.BBoxTestMixin.bbox_head.get_bboxes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "", "def", "simple_test_bboxes", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposals", ",", "\n", "rcnn_test_cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test only det bboxes without augmentation.\"\"\"", "\n", "rois", "=", "bbox2roi", "(", "proposals", ")", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "img_shape", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "rescale", ",", "\n", "cfg", "=", "rcnn_test_cfg", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.BBoxTestMixin.aug_test_bboxes": [[73, 107], ["zip", "mmdet.core.merge_aug_bboxes", "mmdet.core.multiclass_nms", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "test_mixins.BBoxTestMixin._bbox_forward", "test_mixins.BBoxTestMixin.bbox_head.get_bboxes", "aug_bboxes.append", "aug_scores.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "def", "aug_test_bboxes", "(", "self", ",", "feats", ",", "img_metas", ",", "proposal_list", ",", "rcnn_test_cfg", ")", ":", "\n", "        ", "\"\"\"Test det bboxes with test time augmentation.\"\"\"", "\n", "aug_bboxes", "=", "[", "]", "\n", "aug_scores", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "feats", ",", "img_metas", ")", ":", "\n", "# only one image in the batch", "\n", "            ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "# TODO more flexible", "\n", "proposals", "=", "bbox_mapping", "(", "proposal_list", "[", "0", "]", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "# recompute feature maps to save GPU memory", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "x", ",", "rois", ")", "\n", "bboxes", ",", "scores", "=", "self", ".", "bbox_head", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "False", ",", "\n", "cfg", "=", "None", ")", "\n", "aug_bboxes", ".", "append", "(", "bboxes", ")", "\n", "aug_scores", ".", "append", "(", "scores", ")", "\n", "# after merging, bboxes will be rescaled to the original image size", "\n", "", "merged_bboxes", ",", "merged_scores", "=", "merge_aug_bboxes", "(", "\n", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ",", "rcnn_test_cfg", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "merged_bboxes", ",", "merged_scores", ",", "\n", "rcnn_test_cfg", ".", "score_thr", ",", "\n", "rcnn_test_cfg", ".", "nms", ",", "\n", "rcnn_test_cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.MaskTestMixin.simple_test_mask": [[151, 177], ["mmdet.core.bbox2roi", "test_mixins.MaskTestMixin._mask_forward", "test_mixins.MaskTestMixin.mask_head.get_seg_masks", "torch.from_numpy().to", "range", "isinstance", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "", "def", "simple_test_mask", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Simple test for mask head without augmentation.\"\"\"", "\n", "# image shape of the first image in the batch (only one)", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "# if det_bboxes is rescaled to the original image size, we need to", "\n", "# rescale it back to the testing scale to obtain RoIs.", "\n", "            ", "if", "rescale", "and", "not", "isinstance", "(", "scale_factor", ",", "float", ")", ":", "\n", "                ", "scale_factor", "=", "torch", ".", "from_numpy", "(", "scale_factor", ")", ".", "to", "(", "\n", "det_bboxes", ".", "device", ")", "\n", "", "_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "scale_factor", "if", "rescale", "else", "det_bboxes", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ",", "_bboxes", ",", "det_labels", ",", "self", ".", "test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "", "return", "segm_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.test_mixins.MaskTestMixin.aug_test_mask": [[178, 208], ["zip", "mmdet.core.merge_aug_masks", "test_mixins.MaskTestMixin.mask_head.get_seg_masks", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "test_mixins.MaskTestMixin._mask_forward", "aug_masks.append", "range", "mask_results[].sigmoid().cpu().numpy", "mask_results[].sigmoid().cpu", "mask_results[].sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "def", "aug_test_mask", "(", "self", ",", "feats", ",", "img_metas", ",", "det_bboxes", ",", "det_labels", ")", ":", "\n", "        ", "\"\"\"Test for mask head with test time augmentation.\"\"\"", "\n", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "mask_head", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "            ", "aug_masks", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "feats", ",", "img_metas", ")", ":", "\n", "                ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "_bboxes", "=", "bbox_mapping", "(", "det_bboxes", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "mask_results", "=", "self", ".", "_mask_forward", "(", "x", ",", "mask_rois", ")", "\n", "# convert to numpy array to save memory", "\n", "aug_masks", ".", "append", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "img_metas", ",", "self", ".", "test_cfg", ")", "\n", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "self", ".", "test_cfg", ",", "\n", "ori_shape", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "rescale", "=", "False", ")", "\n", "", "return", "segm_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.__init__": [[19, 43], ["base_roi_head.BaseRoIHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_stages", ",", "\n", "stage_loss_weights", ",", "\n", "bbox_roi_extractor", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "mask_roi_extractor", "=", "None", ",", "\n", "mask_head", "=", "None", ",", "\n", "shared_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ":", "\n", "        ", "assert", "bbox_roi_extractor", "is", "not", "None", "\n", "assert", "bbox_head", "is", "not", "None", "\n", "assert", "shared_head", "is", "None", ",", "'Shared head is not supported in Cascade RCNN anymore'", "\n", "self", ".", "num_stages", "=", "num_stages", "\n", "self", ".", "stage_loss_weights", "=", "stage_loss_weights", "\n", "super", "(", "CascadeRoIHead", ",", "self", ")", ".", "__init__", "(", "\n", "bbox_roi_extractor", "=", "bbox_roi_extractor", ",", "\n", "bbox_head", "=", "bbox_head", ",", "\n", "mask_roi_extractor", "=", "mask_roi_extractor", ",", "\n", "mask_head", "=", "mask_head", ",", "\n", "shared_head", "=", "shared_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_bbox_head": [[44, 63], ["torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "zip", "isinstance", "isinstance", "len", "len", "cascade_roi_head.CascadeRoIHead.bbox_roi_extractor.append", "cascade_roi_head.CascadeRoIHead.bbox_head.append", "builder.build_roi_extractor", "builder.build_head", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head"], ["", "def", "init_bbox_head", "(", "self", ",", "bbox_roi_extractor", ",", "bbox_head", ")", ":", "\n", "        ", "\"\"\"Initialize box head and box roi extractor.\n\n        Args:\n            bbox_roi_extractor (dict): Config of box roi extractor.\n            bbox_head (dict): Config of box in box head.\n        \"\"\"", "\n", "self", ".", "bbox_roi_extractor", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "bbox_head", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "not", "isinstance", "(", "bbox_roi_extractor", ",", "list", ")", ":", "\n", "            ", "bbox_roi_extractor", "=", "[", "\n", "bbox_roi_extractor", "for", "_", "in", "range", "(", "self", ".", "num_stages", ")", "\n", "]", "\n", "", "if", "not", "isinstance", "(", "bbox_head", ",", "list", ")", ":", "\n", "            ", "bbox_head", "=", "[", "bbox_head", "for", "_", "in", "range", "(", "self", ".", "num_stages", ")", "]", "\n", "", "assert", "len", "(", "bbox_roi_extractor", ")", "==", "len", "(", "bbox_head", ")", "==", "self", ".", "num_stages", "\n", "for", "roi_extractor", ",", "head", "in", "zip", "(", "bbox_roi_extractor", ",", "bbox_head", ")", ":", "\n", "            ", "self", ".", "bbox_roi_extractor", ".", "append", "(", "build_roi_extractor", "(", "roi_extractor", ")", ")", "\n", "self", ".", "bbox_head", ".", "append", "(", "build_head", "(", "head", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_mask_head": [[64, 91], ["torch.ModuleList", "torch.ModuleList", "isinstance", "len", "cascade_roi_head.CascadeRoIHead.mask_head.append", "torch.ModuleList", "torch.ModuleList", "builder.build_head", "isinstance", "len", "cascade_roi_head.CascadeRoIHead.mask_roi_extractor.append", "range", "builder.build_roi_extractor", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_roi_extractor"], ["", "", "def", "init_mask_head", "(", "self", ",", "mask_roi_extractor", ",", "mask_head", ")", ":", "\n", "        ", "\"\"\"Initialize mask head and mask roi extractor.\n\n        Args:\n            mask_roi_extractor (dict): Config of mask roi extractor.\n            mask_head (dict): Config of mask in mask head.\n        \"\"\"", "\n", "self", ".", "mask_head", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "not", "isinstance", "(", "mask_head", ",", "list", ")", ":", "\n", "            ", "mask_head", "=", "[", "mask_head", "for", "_", "in", "range", "(", "self", ".", "num_stages", ")", "]", "\n", "", "assert", "len", "(", "mask_head", ")", "==", "self", ".", "num_stages", "\n", "for", "head", "in", "mask_head", ":", "\n", "            ", "self", ".", "mask_head", ".", "append", "(", "build_head", "(", "head", ")", ")", "\n", "", "if", "mask_roi_extractor", "is", "not", "None", ":", "\n", "            ", "self", ".", "share_roi_extractor", "=", "False", "\n", "self", ".", "mask_roi_extractor", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "not", "isinstance", "(", "mask_roi_extractor", ",", "list", ")", ":", "\n", "                ", "mask_roi_extractor", "=", "[", "\n", "mask_roi_extractor", "for", "_", "in", "range", "(", "self", ".", "num_stages", ")", "\n", "]", "\n", "", "assert", "len", "(", "mask_roi_extractor", ")", "==", "self", ".", "num_stages", "\n", "for", "roi_extractor", "in", "mask_roi_extractor", ":", "\n", "                ", "self", ".", "mask_roi_extractor", ".", "append", "(", "\n", "build_roi_extractor", "(", "roi_extractor", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "share_roi_extractor", "=", "True", "\n", "self", ".", "mask_roi_extractor", "=", "self", ".", "bbox_roi_extractor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_assigner_sampler": [[92, 101], ["cascade_roi_head.CascadeRoIHead.bbox_assigner.append", "cascade_roi_head.CascadeRoIHead.bbox_sampler.append", "mmdet.core.build_assigner", "mmdet.core.build_sampler"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["", "", "def", "init_assigner_sampler", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize assigner and sampler for each stage.\"\"\"", "\n", "self", ".", "bbox_assigner", "=", "[", "]", "\n", "self", ".", "bbox_sampler", "=", "[", "]", "\n", "if", "self", ".", "train_cfg", "is", "not", "None", ":", "\n", "            ", "for", "rcnn_train_cfg", "in", "self", ".", "train_cfg", ":", "\n", "                ", "self", ".", "bbox_assigner", ".", "append", "(", "\n", "build_assigner", "(", "rcnn_train_cfg", ".", "assigner", ")", ")", "\n", "self", ".", "bbox_sampler", ".", "append", "(", "build_sampler", "(", "rcnn_train_cfg", ".", "sampler", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.init_weights": [[102, 119], ["range", "cascade_roi_head.CascadeRoIHead.shared_head.init_weights", "cascade_roi_head.CascadeRoIHead.bbox_roi_extractor[].init_weights", "cascade_roi_head.CascadeRoIHead.bbox_head[].init_weights", "cascade_roi_head.CascadeRoIHead.mask_head[].init_weights", "cascade_roi_head.CascadeRoIHead.mask_roi_extractor[].init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "", "", "def", "init_weights", "(", "self", ",", "pretrained", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in head.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "self", ".", "with_shared_head", ":", "\n", "            ", "self", ".", "shared_head", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "if", "self", ".", "with_bbox", ":", "\n", "                ", "self", ".", "bbox_roi_extractor", "[", "i", "]", ".", "init_weights", "(", ")", "\n", "self", ".", "bbox_head", "[", "i", "]", ".", "init_weights", "(", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "                ", "if", "not", "self", ".", "share_roi_extractor", ":", "\n", "                    ", "self", ".", "mask_roi_extractor", "[", "i", "]", ".", "init_weights", "(", ")", "\n", "", "self", ".", "mask_head", "[", "i", "]", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.forward_dummy": [[120, 137], ["mmdet.core.bbox2roi", "range", "range", "cascade_roi_head.CascadeRoIHead._bbox_forward", "cascade_roi_head.CascadeRoIHead._mask_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "", "", "def", "forward_dummy", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"Dummy forward function.\"\"\"", "\n", "# bbox head", "\n", "outs", "=", "(", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "if", "self", ".", "with_bbox", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "i", ",", "x", ",", "rois", ")", "\n", "outs", "=", "outs", "+", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ")", "\n", "# mask heads", "\n", "", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "mask_rois", "=", "rois", "[", ":", "100", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                ", "mask_results", "=", "self", ".", "_mask_forward", "(", "i", ",", "x", ",", "mask_rois", ")", "\n", "outs", "=", "outs", "+", "(", "mask_results", "[", "'mask_pred'", "]", ",", ")", "\n", "", "", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward": [[138, 150], ["bbox_roi_extractor", "bbox_head", "dict"], "methods", ["None"], ["", "def", "_bbox_forward", "(", "self", ",", "stage", ",", "x", ",", "rois", ")", ":", "\n", "        ", "\"\"\"Box head forward function used in both training and testing.\"\"\"", "\n", "bbox_roi_extractor", "=", "self", ".", "bbox_roi_extractor", "[", "stage", "]", "\n", "bbox_head", "=", "self", ".", "bbox_head", "[", "stage", "]", "\n", "bbox_feats", "=", "bbox_roi_extractor", "(", "x", "[", ":", "bbox_roi_extractor", ".", "num_inputs", "]", ",", "\n", "rois", ")", "\n", "# do not support caffe_c4 model anymore", "\n", "cls_score", ",", "bbox_pred", "=", "bbox_head", "(", "bbox_feats", ")", "\n", "\n", "bbox_results", "=", "dict", "(", "\n", "cls_score", "=", "cls_score", ",", "bbox_pred", "=", "bbox_pred", ",", "bbox_feats", "=", "bbox_feats", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train": [[151, 165], ["mmdet.core.bbox2roi", "cascade_roi_head.CascadeRoIHead._bbox_forward", "cascade_roi_head.CascadeRoIHead.bbox_head[].get_targets", "cascade_roi_head.CascadeRoIHead.bbox_head[].loss", "cascade_roi_head.CascadeRoIHead.update"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_bbox_forward_train", "(", "self", ",", "stage", ",", "x", ",", "sampling_results", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "rcnn_train_cfg", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for box head in training.\"\"\"", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "stage", ",", "x", ",", "rois", ")", "\n", "bbox_targets", "=", "self", ".", "bbox_head", "[", "stage", "]", ".", "get_targets", "(", "\n", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "rcnn_train_cfg", ")", "\n", "loss_bbox", "=", "self", ".", "bbox_head", "[", "stage", "]", ".", "loss", "(", "bbox_results", "[", "'cls_score'", "]", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "rois", ",", "\n", "*", "bbox_targets", ")", "\n", "\n", "bbox_results", ".", "update", "(", "\n", "loss_bbox", "=", "loss_bbox", ",", "rois", "=", "rois", ",", "bbox_targets", "=", "bbox_targets", ")", "\n", "return", "bbox_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward": [[166, 177], ["mask_roi_extractor", "mask_head", "dict"], "methods", ["None"], ["", "def", "_mask_forward", "(", "self", ",", "stage", ",", "x", ",", "rois", ")", ":", "\n", "        ", "\"\"\"Mask head forward function used in both training and testing.\"\"\"", "\n", "mask_roi_extractor", "=", "self", ".", "mask_roi_extractor", "[", "stage", "]", "\n", "mask_head", "=", "self", ".", "mask_head", "[", "stage", "]", "\n", "mask_feats", "=", "mask_roi_extractor", "(", "x", "[", ":", "mask_roi_extractor", ".", "num_inputs", "]", ",", "\n", "rois", ")", "\n", "# do not support caffe_c4 model anymore", "\n", "mask_pred", "=", "mask_head", "(", "mask_feats", ")", "\n", "\n", "mask_results", "=", "dict", "(", "mask_pred", "=", "mask_pred", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train": [[178, 202], ["mmdet.core.bbox2roi", "cascade_roi_head.CascadeRoIHead._mask_forward", "cascade_roi_head.CascadeRoIHead.mask_head[].get_targets", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "cascade_roi_head.CascadeRoIHead.mask_head[].loss", "cascade_roi_head.CascadeRoIHead.update", "len", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "_mask_forward_train", "(", "self", ",", "\n", "stage", ",", "\n", "x", ",", "\n", "sampling_results", ",", "\n", "gt_masks", ",", "\n", "rcnn_train_cfg", ",", "\n", "bbox_feats", "=", "None", ")", ":", "\n", "        ", "\"\"\"Run forward function and calculate loss for mask head in\n        training.\"\"\"", "\n", "pos_rois", "=", "bbox2roi", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "if", "len", "(", "pos_rois", ")", "==", "0", ":", "\n", "# If there are no predicted and/or truth boxes, then we cannot", "\n", "# compute head / mask losses", "\n", "            ", "return", "dict", "(", "loss_mask", "=", "None", ")", "\n", "", "mask_results", "=", "self", ".", "_mask_forward", "(", "stage", ",", "x", ",", "pos_rois", ")", "\n", "\n", "mask_targets", "=", "self", ".", "mask_head", "[", "stage", "]", ".", "get_targets", "(", "\n", "sampling_results", ",", "gt_masks", ",", "rcnn_train_cfg", ")", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "loss_mask", "=", "self", ".", "mask_head", "[", "stage", "]", ".", "loss", "(", "mask_results", "[", "'mask_pred'", "]", ",", "\n", "mask_targets", ",", "pos_labels", ")", "\n", "\n", "mask_results", ".", "update", "(", "loss_mask", "=", "loss_mask", ")", "\n", "return", "mask_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.forward_train": [[203, 293], ["dict", "range", "cascade_roi_head.CascadeRoIHead._bbox_forward_train", "bbox_results[].items", "len", "range", "cascade_roi_head.CascadeRoIHead._mask_forward_train", "bbox_assigner.assign", "bbox_sampler.sample", "sampling_results.append", "mask_results[].items", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.where", "torch.where", "torch.where", "torch.where", "cascade_roi_head.CascadeRoIHead.bbox_head[].refine_bboxes", "[].argmax", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.refine_bboxes"], ["", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "proposal_list", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): list of multi-level img features.\n            img_metas (list[dict]): list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                `mmdet/datasets/pipelines/formatting.py:Collect`.\n            proposals (list[Tensors]): list of region proposals.\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n            gt_masks (None | Tensor) : true segmentation masks for each box\n                used if the architecture supports a segmentation task.\n\n        Returns:\n            dict[str, Tensor]: a dictionary of loss components\n        \"\"\"", "\n", "losses", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "self", ".", "current_stage", "=", "i", "\n", "rcnn_train_cfg", "=", "self", ".", "train_cfg", "[", "i", "]", "\n", "lw", "=", "self", ".", "stage_loss_weights", "[", "i", "]", "\n", "\n", "# assign gts and sample proposals", "\n", "sampling_results", "=", "[", "]", "\n", "if", "self", ".", "with_bbox", "or", "self", ".", "with_mask", ":", "\n", "                ", "bbox_assigner", "=", "self", ".", "bbox_assigner", "[", "i", "]", "\n", "bbox_sampler", "=", "self", ".", "bbox_sampler", "[", "i", "]", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "if", "gt_bboxes_ignore", "is", "None", ":", "\n", "                    ", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "", "for", "j", "in", "range", "(", "num_imgs", ")", ":", "\n", "                    ", "assign_result", "=", "bbox_assigner", ".", "assign", "(", "\n", "proposal_list", "[", "j", "]", ",", "gt_bboxes", "[", "j", "]", ",", "gt_bboxes_ignore", "[", "j", "]", ",", "\n", "gt_labels", "[", "j", "]", ")", "\n", "sampling_result", "=", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "j", "]", ",", "\n", "gt_bboxes", "[", "j", "]", ",", "\n", "gt_labels", "[", "j", "]", ",", "\n", "feats", "=", "[", "lvl_feat", "[", "j", "]", "[", "None", "]", "for", "lvl_feat", "in", "x", "]", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "\n", "# bbox head forward and loss", "\n", "", "", "bbox_results", "=", "self", ".", "_bbox_forward_train", "(", "i", ",", "x", ",", "sampling_results", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "rcnn_train_cfg", ")", "\n", "\n", "for", "name", ",", "value", "in", "bbox_results", "[", "'loss_bbox'", "]", ".", "items", "(", ")", ":", "\n", "                ", "losses", "[", "f's{i}.{name}'", "]", "=", "(", "\n", "value", "*", "lw", "if", "'loss'", "in", "name", "else", "value", ")", "\n", "\n", "# mask head forward and loss", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "                ", "mask_results", "=", "self", ".", "_mask_forward_train", "(", "\n", "i", ",", "x", ",", "sampling_results", ",", "gt_masks", ",", "rcnn_train_cfg", ",", "\n", "bbox_results", "[", "'bbox_feats'", "]", ")", "\n", "# TODO: Support empty tensor input. #2280", "\n", "if", "mask_results", "[", "'loss_mask'", "]", "is", "not", "None", ":", "\n", "                    ", "for", "name", ",", "value", "in", "mask_results", "[", "'loss_mask'", "]", ".", "items", "(", ")", ":", "\n", "                        ", "losses", "[", "f's{i}.{name}'", "]", "=", "(", "\n", "value", "*", "lw", "if", "'loss'", "in", "name", "else", "value", ")", "\n", "\n", "# refine bboxes", "\n", "", "", "", "if", "i", "<", "self", ".", "num_stages", "-", "1", ":", "\n", "                ", "pos_is_gts", "=", "[", "res", ".", "pos_is_gt", "for", "res", "in", "sampling_results", "]", "\n", "# bbox_targets is a tuple", "\n", "roi_labels", "=", "bbox_results", "[", "'bbox_targets'", "]", "[", "0", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "roi_labels", "=", "torch", ".", "where", "(", "\n", "roi_labels", "==", "self", ".", "bbox_head", "[", "i", "]", ".", "num_classes", ",", "\n", "bbox_results", "[", "'cls_score'", "]", "[", ":", ",", ":", "-", "1", "]", ".", "argmax", "(", "1", ")", ",", "\n", "roi_labels", ")", "\n", "proposal_list", "=", "self", ".", "bbox_head", "[", "i", "]", ".", "refine_bboxes", "(", "\n", "bbox_results", "[", "'rois'", "]", ",", "roi_labels", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "pos_is_gts", ",", "img_metas", ")", "\n", "\n", "", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.simple_test": [[294, 359], ["mmdet.core.bbox2roi", "range", "cascade_roi_head.CascadeRoIHead.bbox_head[].get_bboxes", "mmdet.core.bbox2result", "cascade_roi_head.CascadeRoIHead._bbox_forward", "ms_scores.append", "sum", "[].argmax", "cascade_roi_head.CascadeRoIHead.bbox_head[].regress_by_class", "mmdet.core.bbox2roi", "range", "mmdet.core.merge_aug_masks", "cascade_roi_head.CascadeRoIHead.mask_head[].get_seg_masks", "cascade_roi_head.CascadeRoIHead._mask_forward", "aug_masks.append", "range", "det_bboxes.new_tensor", "mask_results[].sigmoid().cpu().numpy", "mask_results[].sigmoid().cpu", "mask_results[].sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "def", "simple_test", "(", "self", ",", "x", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\"\"\"", "\n", "assert", "self", ".", "with_bbox", ",", "'Bbox head must be implemented.'", "\n", "img_shape", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "\n", "# \"ms\" in variable names means multi-stage", "\n", "ms_bbox_result", "=", "{", "}", "\n", "ms_segm_result", "=", "{", "}", "\n", "ms_scores", "=", "[", "]", "\n", "rcnn_test_cfg", "=", "self", ".", "test_cfg", "\n", "\n", "rois", "=", "bbox2roi", "(", "proposal_list", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "i", ",", "x", ",", "rois", ")", "\n", "ms_scores", ".", "append", "(", "bbox_results", "[", "'cls_score'", "]", ")", "\n", "\n", "if", "i", "<", "self", ".", "num_stages", "-", "1", ":", "\n", "                ", "bbox_label", "=", "bbox_results", "[", "'cls_score'", "]", "[", ":", ",", ":", "-", "1", "]", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "rois", "=", "self", ".", "bbox_head", "[", "i", "]", ".", "regress_by_class", "(", "\n", "rois", ",", "bbox_label", ",", "bbox_results", "[", "'bbox_pred'", "]", ",", "img_metas", "[", "0", "]", ")", "\n", "\n", "", "", "cls_score", "=", "sum", "(", "ms_scores", ")", "/", "self", ".", "num_stages", "\n", "det_bboxes", ",", "det_labels", "=", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "cls_score", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "rescale", ",", "\n", "cfg", "=", "rcnn_test_cfg", ")", "\n", "bbox_result", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "num_classes", ")", "\n", "ms_bbox_result", "[", "'ensemble'", "]", "=", "bbox_result", "\n", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "mask_classes", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "num_classes", "\n", "segm_result", "=", "[", "[", "]", "for", "_", "in", "range", "(", "mask_classes", ")", "]", "\n", "", "else", ":", "\n", "                ", "_bboxes", "=", "(", "\n", "det_bboxes", "[", ":", ",", ":", "4", "]", "*", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "if", "rescale", "else", "det_bboxes", ")", "\n", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "aug_masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                    ", "mask_results", "=", "self", ".", "_mask_forward", "(", "i", ",", "x", ",", "mask_rois", ")", "\n", "aug_masks", ".", "append", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "\n", "[", "img_metas", "]", "*", "self", ".", "num_stages", ",", "\n", "self", ".", "test_cfg", ")", "\n", "segm_result", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "_bboxes", ",", "det_labels", ",", "rcnn_test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", "\n", "", "ms_segm_result", "[", "'ensemble'", "]", "=", "segm_result", "\n", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "results", "=", "(", "ms_bbox_result", "[", "'ensemble'", "]", ",", "ms_segm_result", "[", "'ensemble'", "]", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "ms_bbox_result", "[", "'ensemble'", "]", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead.aug_test": [[360, 451], ["zip", "mmdet.core.merge_aug_bboxes", "mmdet.core.multiclass_nms", "mmdet.core.bbox2result", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "range", "cascade_roi_head.CascadeRoIHead.bbox_head[].get_bboxes", "aug_bboxes.append", "aug_scores.append", "cascade_roi_head.CascadeRoIHead._bbox_forward", "ms_scores.append", "sum", "float", "zip", "mmdet.core.merge_aug_masks", "cascade_roi_head.CascadeRoIHead.mask_head[].get_seg_masks", "[].argmax", "cascade_roi_head.CascadeRoIHead.bbox_head[].regress_by_class", "len", "mmdet.core.bbox_mapping", "mmdet.core.bbox2roi", "range", "range", "cascade_roi_head.CascadeRoIHead._mask_forward", "aug_masks.append", "aug_img_metas.append", "mask_results[].sigmoid().cpu().numpy", "mask_results[].sigmoid().cpu", "mask_results[].sigmoid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._bbox_forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_heads.cascade_roi_head.CascadeRoIHead._mask_forward"], ["", "def", "aug_test", "(", "self", ",", "features", ",", "proposal_list", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test with augmentations.\n\n        If rescale is False, then returned bboxes and masks will fit the scale\n        of imgs[0].\n        \"\"\"", "\n", "rcnn_test_cfg", "=", "self", ".", "test_cfg", "\n", "aug_bboxes", "=", "[", "]", "\n", "aug_scores", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "features", ",", "img_metas", ")", ":", "\n", "# only one image in the batch", "\n", "            ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "\n", "proposals", "=", "bbox_mapping", "(", "proposal_list", "[", "0", "]", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "# \"ms\" in variable names means multi-stage", "\n", "ms_scores", "=", "[", "]", "\n", "\n", "rois", "=", "bbox2roi", "(", "[", "proposals", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                ", "bbox_results", "=", "self", ".", "_bbox_forward", "(", "i", ",", "x", ",", "rois", ")", "\n", "ms_scores", ".", "append", "(", "bbox_results", "[", "'cls_score'", "]", ")", "\n", "\n", "if", "i", "<", "self", ".", "num_stages", "-", "1", ":", "\n", "                    ", "bbox_label", "=", "bbox_results", "[", "'cls_score'", "]", "[", ":", ",", ":", "-", "1", "]", ".", "argmax", "(", "\n", "dim", "=", "1", ")", "\n", "rois", "=", "self", ".", "bbox_head", "[", "i", "]", ".", "regress_by_class", "(", "\n", "rois", ",", "bbox_label", ",", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_meta", "[", "0", "]", ")", "\n", "\n", "", "", "cls_score", "=", "sum", "(", "ms_scores", ")", "/", "float", "(", "len", "(", "ms_scores", ")", ")", "\n", "bboxes", ",", "scores", "=", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "get_bboxes", "(", "\n", "rois", ",", "\n", "cls_score", ",", "\n", "bbox_results", "[", "'bbox_pred'", "]", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "False", ",", "\n", "cfg", "=", "None", ")", "\n", "aug_bboxes", ".", "append", "(", "bboxes", ")", "\n", "aug_scores", ".", "append", "(", "scores", ")", "\n", "\n", "# after merging, bboxes will be rescaled to the original image size", "\n", "", "merged_bboxes", ",", "merged_scores", "=", "merge_aug_bboxes", "(", "\n", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ",", "rcnn_test_cfg", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "merged_bboxes", ",", "merged_scores", ",", "\n", "rcnn_test_cfg", ".", "score_thr", ",", "\n", "rcnn_test_cfg", ".", "nms", ",", "\n", "rcnn_test_cfg", ".", "max_per_img", ")", "\n", "\n", "bbox_result", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "\n", "self", ".", "bbox_head", "[", "-", "1", "]", ".", "num_classes", ")", "\n", "\n", "if", "self", ".", "with_mask", ":", "\n", "            ", "if", "det_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "segm_result", "=", "[", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "mask_head", "[", "-", "1", "]", ".", "num_classes", ")", "]", "\n", "", "else", ":", "\n", "                ", "aug_masks", "=", "[", "]", "\n", "aug_img_metas", "=", "[", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "features", ",", "img_metas", ")", ":", "\n", "                    ", "img_shape", "=", "img_meta", "[", "0", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_meta", "[", "0", "]", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_meta", "[", "0", "]", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_meta", "[", "0", "]", "[", "'flip_direction'", "]", "\n", "_bboxes", "=", "bbox_mapping", "(", "det_bboxes", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "flip_direction", ")", "\n", "mask_rois", "=", "bbox2roi", "(", "[", "_bboxes", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "                        ", "mask_results", "=", "self", ".", "_mask_forward", "(", "i", ",", "x", ",", "mask_rois", ")", "\n", "aug_masks", ".", "append", "(", "\n", "mask_results", "[", "'mask_pred'", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "aug_img_metas", ".", "append", "(", "img_meta", ")", "\n", "", "", "merged_masks", "=", "merge_aug_masks", "(", "aug_masks", ",", "aug_img_metas", ",", "\n", "self", ".", "test_cfg", ")", "\n", "\n", "ori_shape", "=", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'ori_shape'", "]", "\n", "segm_result", "=", "self", ".", "mask_head", "[", "-", "1", "]", ".", "get_seg_masks", "(", "\n", "merged_masks", ",", "\n", "det_bboxes", ",", "\n", "det_labels", ",", "\n", "rcnn_test_cfg", ",", "\n", "ori_shape", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "rescale", "=", "False", ")", "\n", "", "return", "bbox_result", ",", "segm_result", "\n", "", "else", ":", "\n", "            ", "return", "bbox_result", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.__init__": [[19, 64], ["dict", "torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "range", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.ModuleList", "torch.ModuleList", "range", "mmcv.ops.Linear", "torch.ReLU", "torch.ReLU", "mmcv.ops.MaxPool2d", "mmdet.models.builder.build_loss", "maskiou_head.MaskIoUHead.convs.append", "maskiou_head.MaskIoUHead.fcs.append", "mmcv.ops.Conv2d", "mmcv.ops.Linear"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "num_convs", "=", "4", ",", "\n", "num_fcs", "=", "2", ",", "\n", "roi_feat_size", "=", "14", ",", "\n", "in_channels", "=", "256", ",", "\n", "conv_out_channels", "=", "256", ",", "\n", "fc_out_channels", "=", "1024", ",", "\n", "num_classes", "=", "80", ",", "\n", "loss_iou", "=", "dict", "(", "type", "=", "'MSELoss'", ",", "loss_weight", "=", "0.5", ")", ")", ":", "\n", "        ", "super", "(", "MaskIoUHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv_out_channels", "=", "conv_out_channels", "\n", "self", ".", "fc_out_channels", "=", "fc_out_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "# concatenation of mask feature and mask prediction", "\n", "                ", "in_channels", "=", "self", ".", "in_channels", "+", "1", "\n", "", "else", ":", "\n", "                ", "in_channels", "=", "self", ".", "conv_out_channels", "\n", "", "stride", "=", "2", "if", "i", "==", "num_convs", "-", "1", "else", "1", "\n", "self", ".", "convs", ".", "append", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ")", ")", "\n", "\n", "", "roi_feat_size", "=", "_pair", "(", "roi_feat_size", ")", "\n", "pooled_area", "=", "(", "roi_feat_size", "[", "0", "]", "//", "2", ")", "*", "(", "roi_feat_size", "[", "1", "]", "//", "2", ")", "\n", "self", ".", "fcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "num_fcs", ")", ":", "\n", "            ", "in_channels", "=", "(", "\n", "self", ".", "conv_out_channels", "*", "\n", "pooled_area", "if", "i", "==", "0", "else", "self", ".", "fc_out_channels", ")", "\n", "self", ".", "fcs", ".", "append", "(", "Linear", "(", "in_channels", ",", "self", ".", "fc_out_channels", ")", ")", "\n", "\n", "", "self", ".", "fc_mask_iou", "=", "Linear", "(", "self", ".", "fc_out_channels", ",", "self", ".", "num_classes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "max_pool", "=", "MaxPool2d", "(", "2", ",", "2", ")", "\n", "self", ".", "loss_iou", "=", "build_loss", "(", "loss_iou", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.init_weights": [[65, 76], ["mmcv.cnn.normal_init", "mmcv.cnn.kaiming_init", "mmcv.cnn.kaiming_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "kaiming_init", "(", "conv", ")", "\n", "", "for", "fc", "in", "self", ".", "fcs", ":", "\n", "            ", "kaiming_init", "(", "\n", "fc", ",", "\n", "a", "=", "1", ",", "\n", "mode", "=", "'fan_in'", ",", "\n", "nonlinearity", "=", "'leaky_relu'", ",", "\n", "distribution", "=", "'uniform'", ")", "\n", "", "normal_init", "(", "self", ".", "fc_mask_iou", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.forward": [[77, 90], ["mask_pred.sigmoid.sigmoid.sigmoid", "maskiou_head.MaskIoUHead.max_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "maskiou_head.MaskIoUHead.flatten", "maskiou_head.MaskIoUHead.fc_mask_iou", "mask_pred.sigmoid.sigmoid.unsqueeze", "maskiou_head.MaskIoUHead.relu", "maskiou_head.MaskIoUHead.relu", "conv", "fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "mask_feat", ",", "mask_pred", ")", ":", "\n", "        ", "mask_pred", "=", "mask_pred", ".", "sigmoid", "(", ")", "\n", "mask_pred_pooled", "=", "self", ".", "max_pool", "(", "mask_pred", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "(", "mask_feat", ",", "mask_pred_pooled", ")", ",", "1", ")", "\n", "\n", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "x", "=", "self", ".", "relu", "(", "conv", "(", "x", ")", ")", "\n", "", "x", "=", "x", ".", "flatten", "(", "1", ")", "\n", "for", "fc", "in", "self", ".", "fcs", ":", "\n", "            ", "x", "=", "self", ".", "relu", "(", "fc", "(", "x", ")", ")", "\n", "", "mask_iou", "=", "self", ".", "fc_mask_iou", "(", "x", ")", "\n", "return", "mask_iou", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.loss": [[91, 100], ["mmdet.core.force_fp32", "dict", "pos_inds.sum", "maskiou_head.MaskIoUHead.loss_iou", "mask_iou_pred.sum"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'mask_iou_pred'", ",", ")", ")", "\n", "def", "loss", "(", "self", ",", "mask_iou_pred", ",", "mask_iou_targets", ")", ":", "\n", "        ", "pos_inds", "=", "mask_iou_targets", ">", "0", "\n", "if", "pos_inds", ".", "sum", "(", ")", ">", "0", ":", "\n", "            ", "loss_mask_iou", "=", "self", ".", "loss_iou", "(", "mask_iou_pred", "[", "pos_inds", "]", ",", "\n", "mask_iou_targets", "[", "pos_inds", "]", ")", "\n", "", "else", ":", "\n", "            ", "loss_mask_iou", "=", "mask_iou_pred", ".", "sum", "(", ")", "*", "0", "\n", "", "return", "dict", "(", "loss_mask_iou", "=", "loss_mask_iou", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.get_targets": [[101, 150], ["mmdet.core.force_fp32", "map", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_pred.sum", "list", "mask_targets.size", "torch.cat.size", "torch.cat.size", "mask_targets.sum"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'mask_pred'", ",", ")", ")", "\n", "def", "get_targets", "(", "self", ",", "sampling_results", ",", "gt_masks", ",", "mask_pred", ",", "mask_targets", ",", "\n", "rcnn_train_cfg", ")", ":", "\n", "        ", "\"\"\"Compute target of mask IoU.\n\n        Mask IoU target is the IoU of the predicted mask (inside a bbox) and\n        the gt mask of corresponding gt mask (the whole instance).\n        The intersection area is computed inside the bbox, and the gt mask area\n        is computed with two steps, firstly we compute the gt area inside the\n        bbox, then divide it by the area ratio of gt area inside the bbox and\n        the gt area of the whole instance.\n\n        Args:\n            sampling_results (list[:obj:`SamplingResult`]): sampling results.\n            gt_masks (BitmapMask | PolygonMask): Gt masks (the whole instance)\n                of each image, with the same shape of the input image.\n            mask_pred (Tensor): Predicted masks of each positive proposal,\n                shape (num_pos, h, w).\n            mask_targets (Tensor): Gt mask of each positive proposal,\n                binary map of the shape (num_pos, h, w).\n            rcnn_train_cfg (dict): Training config for R-CNN part.\n\n        Returns:\n            Tensor: mask iou target (length == num positive).\n        \"\"\"", "\n", "pos_proposals", "=", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", "\n", "pos_assigned_gt_inds", "=", "[", "\n", "res", ".", "pos_assigned_gt_inds", "for", "res", "in", "sampling_results", "\n", "]", "\n", "\n", "# compute the area ratio of gt areas inside the proposals and", "\n", "# the whole instance", "\n", "area_ratios", "=", "map", "(", "self", ".", "_get_area_ratio", ",", "pos_proposals", ",", "\n", "pos_assigned_gt_inds", ",", "gt_masks", ")", "\n", "area_ratios", "=", "torch", ".", "cat", "(", "list", "(", "area_ratios", ")", ")", "\n", "assert", "mask_targets", ".", "size", "(", "0", ")", "==", "area_ratios", ".", "size", "(", "0", ")", "\n", "\n", "mask_pred", "=", "(", "mask_pred", ">", "rcnn_train_cfg", ".", "mask_thr_binary", ")", ".", "float", "(", ")", "\n", "mask_pred_areas", "=", "mask_pred", ".", "sum", "(", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "\n", "# mask_pred and mask_targets are binary maps", "\n", "overlap_areas", "=", "(", "mask_pred", "*", "mask_targets", ")", ".", "sum", "(", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "\n", "# compute the mask area of the whole instance", "\n", "gt_full_areas", "=", "mask_targets", ".", "sum", "(", "(", "-", "1", ",", "-", "2", ")", ")", "/", "(", "area_ratios", "+", "1e-7", ")", "\n", "\n", "mask_iou_targets", "=", "overlap_areas", "/", "(", "\n", "mask_pred_areas", "+", "gt_full_areas", "-", "overlap_areas", ")", "\n", "return", "mask_iou_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead._get_area_ratio": [[151, 176], ["pos_proposals.size", "pos_proposals.cpu().numpy", "pos_assigned_gt_inds.cpu().numpy.cpu().numpy.cpu().numpy", "range", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "pos_proposals.new_zeros", "proposals_np[].astype", "gt_mask.crop", "pos_proposals.new_zeros.append", "pos_proposals.cpu", "pos_assigned_gt_inds.cpu().numpy.cpu().numpy.cpu", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.stack"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop"], ["", "def", "_get_area_ratio", "(", "self", ",", "pos_proposals", ",", "pos_assigned_gt_inds", ",", "gt_masks", ")", ":", "\n", "        ", "\"\"\"Compute area ratio of the gt mask inside the proposal and the gt\n        mask of the corresponding instance.\"\"\"", "\n", "num_pos", "=", "pos_proposals", ".", "size", "(", "0", ")", "\n", "if", "num_pos", ">", "0", ":", "\n", "            ", "area_ratios", "=", "[", "]", "\n", "proposals_np", "=", "pos_proposals", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pos_assigned_gt_inds", "=", "pos_assigned_gt_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# compute mask areas of gt instances (batch processing for speedup)", "\n", "gt_instance_mask_area", "=", "gt_masks", ".", "areas", "\n", "for", "i", "in", "range", "(", "num_pos", ")", ":", "\n", "                ", "gt_mask", "=", "gt_masks", "[", "pos_assigned_gt_inds", "[", "i", "]", "]", "\n", "\n", "# crop the gt mask inside the proposal", "\n", "bbox", "=", "proposals_np", "[", "i", ",", ":", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "gt_mask_in_proposal", "=", "gt_mask", ".", "crop", "(", "bbox", ")", "\n", "\n", "ratio", "=", "gt_mask_in_proposal", ".", "areas", "[", "0", "]", "/", "(", "\n", "gt_instance_mask_area", "[", "pos_assigned_gt_inds", "[", "i", "]", "]", "+", "1e-7", ")", "\n", "area_ratios", ".", "append", "(", "ratio", ")", "\n", "", "area_ratios", "=", "torch", ".", "from_numpy", "(", "np", ".", "stack", "(", "area_ratios", ")", ")", ".", "float", "(", ")", ".", "to", "(", "\n", "pos_proposals", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "area_ratios", "=", "pos_proposals", ".", "new_zeros", "(", "(", "0", ",", ")", ")", "\n", "", "return", "area_ratios", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.maskiou_head.MaskIoUHead.get_mask_scores": [[177, 188], ["mmdet.core.force_fp32", "range", "mask_scores.cpu().numpy.cpu().numpy.cpu().numpy", "det_labels.cpu().numpy.cpu().numpy.cpu().numpy", "det_labels.cpu().numpy.cpu().numpy.size", "mask_scores.cpu().numpy.cpu().numpy.cpu", "det_labels.cpu().numpy.cpu().numpy.cpu", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'mask_iou_pred'", ",", ")", ")", "\n", "def", "get_mask_scores", "(", "self", ",", "mask_iou_pred", ",", "det_bboxes", ",", "det_labels", ")", ":", "\n", "        ", "\"\"\"Get the mask scores.\n\n        mask_score = bbox_score * mask_iou\n        \"\"\"", "\n", "inds", "=", "range", "(", "det_labels", ".", "size", "(", "0", ")", ")", "\n", "mask_scores", "=", "mask_iou_pred", "[", "inds", ",", "det_labels", "]", "*", "det_bboxes", "[", "inds", ",", "-", "1", "]", "\n", "mask_scores", "=", "mask_scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "det_labels", "=", "det_labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "return", "[", "mask_scores", "[", "det_labels", "==", "i", "]", "for", "i", "in", "range", "(", "self", ".", "num_classes", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.__init__": [[13, 140], ["dict", "dict", "torch.Module.__init__", "int", "grid_head.GridHead.calc_sub_regions", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "range", "sum", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "mmdet.models.builder.build_loss", "isinstance", "numpy.sqrt", "ValueError", "isinstance", "ValueError", "grid_head.GridHead.convs.append", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "grid_head.GridHead.forder_trans.append", "grid_head.GridHead.sorder_trans.append", "mmcv.cnn.ConvModule", "grid_head.GridHead.neighbor_points.append", "len", "len", "torch.ModuleList.append", "torch.ModuleList.append", "neighbors.append", "neighbors.append", "neighbors.append", "neighbors.append", "tuple", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.calc_sub_regions", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["    ", "def", "__init__", "(", "self", ",", "\n", "grid_points", "=", "9", ",", "\n", "num_convs", "=", "8", ",", "\n", "roi_feat_size", "=", "14", ",", "\n", "in_channels", "=", "256", ",", "\n", "conv_kernel_size", "=", "3", ",", "\n", "point_feat_channels", "=", "64", ",", "\n", "deconv_kernel_size", "=", "4", ",", "\n", "class_agnostic", "=", "False", ",", "\n", "loss_grid", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "15", ")", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "36", ")", ")", ":", "\n", "        ", "super", "(", "GridHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "grid_points", "=", "grid_points", "\n", "self", ".", "num_convs", "=", "num_convs", "\n", "self", ".", "roi_feat_size", "=", "roi_feat_size", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv_kernel_size", "=", "conv_kernel_size", "\n", "self", ".", "point_feat_channels", "=", "point_feat_channels", "\n", "self", ".", "conv_out_channels", "=", "self", ".", "point_feat_channels", "*", "self", ".", "grid_points", "\n", "self", ".", "class_agnostic", "=", "class_agnostic", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "if", "isinstance", "(", "norm_cfg", ",", "dict", ")", "and", "norm_cfg", "[", "'type'", "]", "==", "'GN'", ":", "\n", "            ", "assert", "self", ".", "conv_out_channels", "%", "norm_cfg", "[", "'num_groups'", "]", "==", "0", "\n", "\n", "", "assert", "self", ".", "grid_points", ">=", "4", "\n", "self", ".", "grid_size", "=", "int", "(", "np", ".", "sqrt", "(", "self", ".", "grid_points", ")", ")", "\n", "if", "self", ".", "grid_size", "*", "self", ".", "grid_size", "!=", "self", ".", "grid_points", ":", "\n", "            ", "raise", "ValueError", "(", "'grid_points must be a square number'", ")", "\n", "\n", "# the predicted heatmap is half of whole_map_size", "\n", "", "if", "not", "isinstance", "(", "self", ".", "roi_feat_size", ",", "int", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Only square RoIs are supporeted in Grid R-CNN'", ")", "\n", "", "self", ".", "whole_map_size", "=", "self", ".", "roi_feat_size", "*", "4", "\n", "\n", "# compute point-wise sub-regions", "\n", "self", ".", "sub_regions", "=", "self", ".", "calc_sub_regions", "(", ")", "\n", "\n", "self", ".", "convs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_convs", ")", ":", "\n", "            ", "in_channels", "=", "(", "\n", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "conv_out_channels", ")", "\n", "stride", "=", "2", "if", "i", "==", "0", "else", "1", "\n", "padding", "=", "(", "self", ".", "conv_kernel_size", "-", "1", ")", "//", "2", "\n", "self", ".", "convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "self", ".", "conv_kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "True", ")", ")", "\n", "", "self", ".", "convs", "=", "nn", ".", "Sequential", "(", "*", "self", ".", "convs", ")", "\n", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "\n", "self", ".", "conv_out_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "kernel_size", "=", "deconv_kernel_size", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "(", "deconv_kernel_size", "-", "2", ")", "//", "2", ",", "\n", "groups", "=", "grid_points", ")", "\n", "self", ".", "norm1", "=", "nn", ".", "GroupNorm", "(", "grid_points", ",", "self", ".", "conv_out_channels", ")", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "\n", "self", ".", "conv_out_channels", ",", "\n", "grid_points", ",", "\n", "kernel_size", "=", "deconv_kernel_size", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "(", "deconv_kernel_size", "-", "2", ")", "//", "2", ",", "\n", "groups", "=", "grid_points", ")", "\n", "\n", "# find the 4-neighbor of each grid point", "\n", "self", ".", "neighbor_points", "=", "[", "]", "\n", "grid_size", "=", "self", ".", "grid_size", "\n", "for", "i", "in", "range", "(", "grid_size", ")", ":", "# i-th column", "\n", "            ", "for", "j", "in", "range", "(", "grid_size", ")", ":", "# j-th row", "\n", "                ", "neighbors", "=", "[", "]", "\n", "if", "i", ">", "0", ":", "# left: (i - 1, j)", "\n", "                    ", "neighbors", ".", "append", "(", "(", "i", "-", "1", ")", "*", "grid_size", "+", "j", ")", "\n", "", "if", "j", ">", "0", ":", "# up: (i, j - 1)", "\n", "                    ", "neighbors", ".", "append", "(", "i", "*", "grid_size", "+", "j", "-", "1", ")", "\n", "", "if", "j", "<", "grid_size", "-", "1", ":", "# down: (i, j + 1)", "\n", "                    ", "neighbors", ".", "append", "(", "i", "*", "grid_size", "+", "j", "+", "1", ")", "\n", "", "if", "i", "<", "grid_size", "-", "1", ":", "# right: (i + 1, j)", "\n", "                    ", "neighbors", ".", "append", "(", "(", "i", "+", "1", ")", "*", "grid_size", "+", "j", ")", "\n", "", "self", ".", "neighbor_points", ".", "append", "(", "tuple", "(", "neighbors", ")", ")", "\n", "# total edges in the grid", "\n", "", "", "self", ".", "num_edges", "=", "sum", "(", "[", "len", "(", "p", ")", "for", "p", "in", "self", ".", "neighbor_points", "]", ")", "\n", "\n", "self", ".", "forder_trans", "=", "nn", ".", "ModuleList", "(", ")", "# first-order feature transition", "\n", "self", ".", "sorder_trans", "=", "nn", ".", "ModuleList", "(", ")", "# second-order feature transition", "\n", "for", "neighbors", "in", "self", ".", "neighbor_points", ":", "\n", "            ", "fo_trans", "=", "nn", ".", "ModuleList", "(", ")", "\n", "so_trans", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "len", "(", "neighbors", ")", ")", ":", "\n", "# each transition module consists of a 5x5 depth-wise conv and", "\n", "# 1x1 conv.", "\n", "                ", "fo_trans", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "\n", "5", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "2", ",", "\n", "groups", "=", "self", ".", "point_feat_channels", ")", ",", "\n", "nn", ".", "Conv2d", "(", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "1", ")", ")", ")", "\n", "so_trans", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "\n", "5", ",", "\n", "1", ",", "\n", "2", ",", "\n", "groups", "=", "self", ".", "point_feat_channels", ")", ",", "\n", "nn", ".", "Conv2d", "(", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "1", ")", ")", ")", "\n", "", "self", ".", "forder_trans", ".", "append", "(", "fo_trans", ")", "\n", "self", ".", "sorder_trans", ".", "append", "(", "so_trans", ")", "\n", "\n", "", "self", ".", "loss_grid", "=", "build_loss", "(", "loss_grid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.init_weights": [[141, 150], ["grid_head.GridHead.modules", "grid_head.GridHead.modules", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "isinstance", "isinstance", "isinstance", "mmcv.cnn.kaiming_init", "mmcv.cnn.normal_init", "numpy.log"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "# TODO: compare mode = \"fan_in\" or \"fan_out\"", "\n", "                ", "kaiming_init", "(", "m", ")", "\n", "", "", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "normal_init", "(", "m", ",", "std", "=", "0.001", ")", "\n", "", "", "nn", ".", "init", ".", "constant_", "(", "self", ".", "deconv2", ".", "bias", ",", "-", "np", ".", "log", "(", "0.99", "/", "0.01", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.forward": [[151, 188], ["grid_head.GridHead.convs", "enumerate", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "grid_head.GridHead.deconv1", "torch.relu", "torch.relu", "torch.relu", "grid_head.GridHead.deconv2", "dict", "enumerate", "enumerate", "grid_head.GridHead.norm1", "grid_head.GridHead.deconv1", "torch.relu", "torch.relu", "torch.relu", "grid_head.GridHead.deconv2", "range", "range", "grid_head.GridHead.norm1"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "shape", "[", "-", "1", "]", "==", "x", ".", "shape", "[", "-", "2", "]", "==", "self", ".", "roi_feat_size", "\n", "# RoI feature transformation, downsample 2x", "\n", "x", "=", "self", ".", "convs", "(", "x", ")", "\n", "\n", "c", "=", "self", ".", "point_feat_channels", "\n", "# first-order fusion", "\n", "x_fo", "=", "[", "None", "for", "_", "in", "range", "(", "self", ".", "grid_points", ")", "]", "\n", "for", "i", ",", "points", "in", "enumerate", "(", "self", ".", "neighbor_points", ")", ":", "\n", "            ", "x_fo", "[", "i", "]", "=", "x", "[", ":", ",", "i", "*", "c", ":", "(", "i", "+", "1", ")", "*", "c", "]", "\n", "for", "j", ",", "point_idx", "in", "enumerate", "(", "points", ")", ":", "\n", "                ", "x_fo", "[", "i", "]", "=", "x_fo", "[", "i", "]", "+", "self", ".", "forder_trans", "[", "i", "]", "[", "j", "]", "(", "\n", "x", "[", ":", ",", "point_idx", "*", "c", ":", "(", "point_idx", "+", "1", ")", "*", "c", "]", ")", "\n", "\n", "# second-order fusion", "\n", "", "", "x_so", "=", "[", "None", "for", "_", "in", "range", "(", "self", ".", "grid_points", ")", "]", "\n", "for", "i", ",", "points", "in", "enumerate", "(", "self", ".", "neighbor_points", ")", ":", "\n", "            ", "x_so", "[", "i", "]", "=", "x", "[", ":", ",", "i", "*", "c", ":", "(", "i", "+", "1", ")", "*", "c", "]", "\n", "for", "j", ",", "point_idx", "in", "enumerate", "(", "points", ")", ":", "\n", "                ", "x_so", "[", "i", "]", "=", "x_so", "[", "i", "]", "+", "self", ".", "sorder_trans", "[", "i", "]", "[", "j", "]", "(", "x_fo", "[", "point_idx", "]", ")", "\n", "\n", "# predicted heatmap with fused features", "\n", "", "", "x2", "=", "torch", ".", "cat", "(", "x_so", ",", "dim", "=", "1", ")", "\n", "x2", "=", "self", ".", "deconv1", "(", "x2", ")", "\n", "x2", "=", "F", ".", "relu", "(", "self", ".", "norm1", "(", "x2", ")", ",", "inplace", "=", "True", ")", "\n", "heatmap", "=", "self", ".", "deconv2", "(", "x2", ")", "\n", "\n", "# predicted heatmap with original features (applicable during training)", "\n", "if", "self", ".", "training", ":", "\n", "            ", "x1", "=", "x", "\n", "x1", "=", "self", ".", "deconv1", "(", "x1", ")", "\n", "x1", "=", "F", ".", "relu", "(", "self", ".", "norm1", "(", "x1", ")", ",", "inplace", "=", "True", ")", "\n", "heatmap_unfused", "=", "self", ".", "deconv2", "(", "x1", ")", "\n", "", "else", ":", "\n", "            ", "heatmap_unfused", "=", "heatmap", "\n", "\n", "", "return", "dict", "(", "fused", "=", "heatmap", ",", "unfused", "=", "heatmap_unfused", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.calc_sub_regions": [[189, 219], ["range", "sub_regions.append", "max", "max", "int", "int"], "methods", ["None"], ["", "def", "calc_sub_regions", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute point specific representation regions.\n\n        See Grid R-CNN Plus (https://arxiv.org/abs/1906.05688) for details.\n        \"\"\"", "\n", "# to make it consistent with the original implementation, half_size", "\n", "# is computed as 2 * quarter_size, which is smaller", "\n", "half_size", "=", "self", ".", "whole_map_size", "//", "4", "*", "2", "\n", "sub_regions", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "grid_points", ")", ":", "\n", "            ", "x_idx", "=", "i", "//", "self", ".", "grid_size", "\n", "y_idx", "=", "i", "%", "self", ".", "grid_size", "\n", "if", "x_idx", "==", "0", ":", "\n", "                ", "sub_x1", "=", "0", "\n", "", "elif", "x_idx", "==", "self", ".", "grid_size", "-", "1", ":", "\n", "                ", "sub_x1", "=", "half_size", "\n", "", "else", ":", "\n", "                ", "ratio", "=", "x_idx", "/", "(", "self", ".", "grid_size", "-", "1", ")", "-", "0.25", "\n", "sub_x1", "=", "max", "(", "int", "(", "ratio", "*", "self", ".", "whole_map_size", ")", ",", "0", ")", "\n", "\n", "", "if", "y_idx", "==", "0", ":", "\n", "                ", "sub_y1", "=", "0", "\n", "", "elif", "y_idx", "==", "self", ".", "grid_size", "-", "1", ":", "\n", "                ", "sub_y1", "=", "half_size", "\n", "", "else", ":", "\n", "                ", "ratio", "=", "y_idx", "/", "(", "self", ".", "grid_size", "-", "1", ")", "-", "0.25", "\n", "sub_y1", "=", "max", "(", "int", "(", "ratio", "*", "self", ".", "whole_map_size", ")", ",", "0", ")", "\n", "", "sub_regions", ".", "append", "(", "\n", "(", "sub_x1", ",", "sub_y1", ",", "sub_x1", "+", "half_size", ",", "sub_y1", "+", "half_size", ")", ")", "\n", "", "return", "sub_regions", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.get_targets": [[220, 287], ["torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "range", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "sub_targets.to.to.to", "factors.append", "range", "sub_targets.to.to.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "int", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "def", "get_targets", "(", "self", ",", "sampling_results", ",", "rcnn_train_cfg", ")", ":", "\n", "# mix all samples (across images) together.", "\n", "        ", "pos_bboxes", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", ",", "\n", "dim", "=", "0", ")", ".", "cpu", "(", ")", "\n", "pos_gt_bboxes", "=", "torch", ".", "cat", "(", "\n", "[", "res", ".", "pos_gt_bboxes", "for", "res", "in", "sampling_results", "]", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", "\n", "assert", "pos_bboxes", ".", "shape", "==", "pos_gt_bboxes", ".", "shape", "\n", "\n", "# expand pos_bboxes to 2x of original size", "\n", "x1", "=", "pos_bboxes", "[", ":", ",", "0", "]", "-", "(", "pos_bboxes", "[", ":", ",", "2", "]", "-", "pos_bboxes", "[", ":", ",", "0", "]", ")", "/", "2", "\n", "y1", "=", "pos_bboxes", "[", ":", ",", "1", "]", "-", "(", "pos_bboxes", "[", ":", ",", "3", "]", "-", "pos_bboxes", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "x2", "=", "pos_bboxes", "[", ":", ",", "2", "]", "+", "(", "pos_bboxes", "[", ":", ",", "2", "]", "-", "pos_bboxes", "[", ":", ",", "0", "]", ")", "/", "2", "\n", "y2", "=", "pos_bboxes", "[", ":", ",", "3", "]", "+", "(", "pos_bboxes", "[", ":", ",", "3", "]", "-", "pos_bboxes", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "pos_bboxes", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "dim", "=", "-", "1", ")", "\n", "pos_bbox_ws", "=", "(", "pos_bboxes", "[", ":", ",", "2", "]", "-", "pos_bboxes", "[", ":", ",", "0", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "pos_bbox_hs", "=", "(", "pos_bboxes", "[", ":", ",", "3", "]", "-", "pos_bboxes", "[", ":", ",", "1", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "num_rois", "=", "pos_bboxes", ".", "shape", "[", "0", "]", "\n", "map_size", "=", "self", ".", "whole_map_size", "\n", "# this is not the final target shape", "\n", "targets", "=", "torch", ".", "zeros", "(", "(", "num_rois", ",", "self", ".", "grid_points", ",", "map_size", ",", "map_size", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "# pre-compute interpolation factors for all grid points.", "\n", "# the first item is the factor of x-dim, and the second is y-dim.", "\n", "# for a 9-point grid, factors are like (1, 0), (0.5, 0.5), (0, 1)", "\n", "factors", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "grid_points", ")", ":", "\n", "            ", "x_idx", "=", "j", "//", "self", ".", "grid_size", "\n", "y_idx", "=", "j", "%", "self", ".", "grid_size", "\n", "factors", ".", "append", "(", "(", "1", "-", "x_idx", "/", "(", "self", ".", "grid_size", "-", "1", ")", ",", "\n", "1", "-", "y_idx", "/", "(", "self", ".", "grid_size", "-", "1", ")", ")", ")", "\n", "\n", "", "radius", "=", "rcnn_train_cfg", ".", "pos_radius", "\n", "radius2", "=", "radius", "**", "2", "\n", "for", "i", "in", "range", "(", "num_rois", ")", ":", "\n", "# ignore small bboxes", "\n", "            ", "if", "(", "pos_bbox_ws", "[", "i", "]", "<=", "self", ".", "grid_size", "\n", "or", "pos_bbox_hs", "[", "i", "]", "<=", "self", ".", "grid_size", ")", ":", "\n", "                ", "continue", "\n", "# for each grid point, mark a small circle as positive", "\n", "", "for", "j", "in", "range", "(", "self", ".", "grid_points", ")", ":", "\n", "                ", "factor_x", ",", "factor_y", "=", "factors", "[", "j", "]", "\n", "gridpoint_x", "=", "factor_x", "*", "pos_gt_bboxes", "[", "i", ",", "0", "]", "+", "(", "\n", "1", "-", "factor_x", ")", "*", "pos_gt_bboxes", "[", "i", ",", "2", "]", "\n", "gridpoint_y", "=", "factor_y", "*", "pos_gt_bboxes", "[", "i", ",", "1", "]", "+", "(", "\n", "1", "-", "factor_y", ")", "*", "pos_gt_bboxes", "[", "i", ",", "3", "]", "\n", "\n", "cx", "=", "int", "(", "(", "gridpoint_x", "-", "pos_bboxes", "[", "i", ",", "0", "]", ")", "/", "pos_bbox_ws", "[", "i", "]", "*", "\n", "map_size", ")", "\n", "cy", "=", "int", "(", "(", "gridpoint_y", "-", "pos_bboxes", "[", "i", ",", "1", "]", ")", "/", "pos_bbox_hs", "[", "i", "]", "*", "\n", "map_size", ")", "\n", "\n", "for", "x", "in", "range", "(", "cx", "-", "radius", ",", "cx", "+", "radius", "+", "1", ")", ":", "\n", "                    ", "for", "y", "in", "range", "(", "cy", "-", "radius", ",", "cy", "+", "radius", "+", "1", ")", ":", "\n", "                        ", "if", "x", ">=", "0", "and", "x", "<", "map_size", "and", "y", ">=", "0", "and", "y", "<", "map_size", ":", "\n", "                            ", "if", "(", "x", "-", "cx", ")", "**", "2", "+", "(", "y", "-", "cy", ")", "**", "2", "<=", "radius2", ":", "\n", "                                ", "targets", "[", "i", ",", "j", ",", "y", ",", "x", "]", "=", "1", "\n", "# reduce the target heatmap size by a half", "\n", "# proposed in Grid R-CNN Plus (https://arxiv.org/abs/1906.05688).", "\n", "", "", "", "", "", "", "sub_targets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "grid_points", ")", ":", "\n", "            ", "sub_x1", ",", "sub_y1", ",", "sub_x2", ",", "sub_y2", "=", "self", ".", "sub_regions", "[", "i", "]", "\n", "sub_targets", ".", "append", "(", "targets", "[", ":", ",", "[", "i", "]", ",", "sub_y1", ":", "sub_y2", ",", "sub_x1", ":", "sub_x2", "]", ")", "\n", "", "sub_targets", "=", "torch", ".", "cat", "(", "sub_targets", ",", "dim", "=", "1", ")", "\n", "sub_targets", "=", "sub_targets", ".", "to", "(", "sampling_results", "[", "0", "]", ".", "pos_bboxes", ".", "device", ")", "\n", "return", "sub_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.loss": [[288, 293], ["grid_head.GridHead.loss_grid", "grid_head.GridHead.loss_grid", "dict"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "grid_pred", ",", "grid_targets", ")", ":", "\n", "        ", "loss_fused", "=", "self", ".", "loss_grid", "(", "grid_pred", "[", "'fused'", "]", ",", "grid_targets", ")", "\n", "loss_unfused", "=", "self", ".", "loss_grid", "(", "grid_pred", "[", "'unfused'", "]", ",", "grid_targets", ")", "\n", "loss_grid", "=", "loss_fused", "+", "loss_unfused", "\n", "return", "dict", "(", "loss_grid", "=", "loss_grid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.grid_head.GridHead.get_bboxes": [[294, 360], ["det_bboxes.cpu.cpu.cpu", "grid_pred.view.view.sigmoid().cpu", "grid_pred.view.view.view", "grid_pred.view.view.max", "range", "tuple", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bbox_res[].clamp_", "bbox_res[].clamp_", "map", "pred_scores[].sum", "pred_scores[].sum", "pred_scores[].sum", "pred_scores[].sum", "grid_pred.view.view.sigmoid", "range", "range", "range", "range", "x.view", "xs.float", "ys.float"], "methods", ["None"], ["", "def", "get_bboxes", "(", "self", ",", "det_bboxes", ",", "grid_pred", ",", "img_metas", ")", ":", "\n", "# TODO: refactoring", "\n", "        ", "assert", "det_bboxes", ".", "shape", "[", "0", "]", "==", "grid_pred", ".", "shape", "[", "0", "]", "\n", "det_bboxes", "=", "det_bboxes", ".", "cpu", "(", ")", "\n", "cls_scores", "=", "det_bboxes", "[", ":", ",", "[", "4", "]", "]", "\n", "det_bboxes", "=", "det_bboxes", "[", ":", ",", ":", "4", "]", "\n", "grid_pred", "=", "grid_pred", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", "\n", "\n", "R", ",", "c", ",", "h", ",", "w", "=", "grid_pred", ".", "shape", "\n", "half_size", "=", "self", ".", "whole_map_size", "//", "4", "*", "2", "\n", "assert", "h", "==", "w", "==", "half_size", "\n", "assert", "c", "==", "self", ".", "grid_points", "\n", "\n", "# find the point with max scores in the half-sized heatmap", "\n", "grid_pred", "=", "grid_pred", ".", "view", "(", "R", "*", "c", ",", "h", "*", "w", ")", "\n", "pred_scores", ",", "pred_position", "=", "grid_pred", ".", "max", "(", "dim", "=", "1", ")", "\n", "xs", "=", "pred_position", "%", "w", "\n", "ys", "=", "pred_position", "//", "w", "\n", "\n", "# get the position in the whole heatmap instead of half-sized heatmap", "\n", "for", "i", "in", "range", "(", "self", ".", "grid_points", ")", ":", "\n", "            ", "xs", "[", "i", ":", ":", "self", ".", "grid_points", "]", "+=", "self", ".", "sub_regions", "[", "i", "]", "[", "0", "]", "\n", "ys", "[", "i", ":", ":", "self", ".", "grid_points", "]", "+=", "self", ".", "sub_regions", "[", "i", "]", "[", "1", "]", "\n", "\n", "# reshape to (num_rois, grid_points)", "\n", "", "pred_scores", ",", "xs", ",", "ys", "=", "tuple", "(", "\n", "map", "(", "lambda", "x", ":", "x", ".", "view", "(", "R", ",", "c", ")", ",", "[", "pred_scores", ",", "xs", ",", "ys", "]", ")", ")", "\n", "\n", "# get expanded pos_bboxes", "\n", "widths", "=", "(", "det_bboxes", "[", ":", ",", "2", "]", "-", "det_bboxes", "[", ":", ",", "0", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "heights", "=", "(", "det_bboxes", "[", ":", ",", "3", "]", "-", "det_bboxes", "[", ":", ",", "1", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "x1", "=", "(", "det_bboxes", "[", ":", ",", "0", ",", "None", "]", "-", "widths", "/", "2", ")", "\n", "y1", "=", "(", "det_bboxes", "[", ":", ",", "1", ",", "None", "]", "-", "heights", "/", "2", ")", "\n", "# map the grid point to the absolute coordinates", "\n", "abs_xs", "=", "(", "xs", ".", "float", "(", ")", "+", "0.5", ")", "/", "w", "*", "widths", "+", "x1", "\n", "abs_ys", "=", "(", "ys", ".", "float", "(", ")", "+", "0.5", ")", "/", "h", "*", "heights", "+", "y1", "\n", "\n", "# get the grid points indices that fall on the bbox boundaries", "\n", "x1_inds", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "grid_size", ")", "]", "\n", "y1_inds", "=", "[", "i", "*", "self", ".", "grid_size", "for", "i", "in", "range", "(", "self", ".", "grid_size", ")", "]", "\n", "x2_inds", "=", "[", "\n", "self", ".", "grid_points", "-", "self", ".", "grid_size", "+", "i", "\n", "for", "i", "in", "range", "(", "self", ".", "grid_size", ")", "\n", "]", "\n", "y2_inds", "=", "[", "(", "i", "+", "1", ")", "*", "self", ".", "grid_size", "-", "1", "for", "i", "in", "range", "(", "self", ".", "grid_size", ")", "]", "\n", "\n", "# voting of all grid points on some boundary", "\n", "bboxes_x1", "=", "(", "abs_xs", "[", ":", ",", "x1_inds", "]", "*", "pred_scores", "[", ":", ",", "x1_inds", "]", ")", ".", "sum", "(", "\n", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "/", "(", "\n", "pred_scores", "[", ":", ",", "x1_inds", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "bboxes_y1", "=", "(", "abs_ys", "[", ":", ",", "y1_inds", "]", "*", "pred_scores", "[", ":", ",", "y1_inds", "]", ")", ".", "sum", "(", "\n", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "/", "(", "\n", "pred_scores", "[", ":", ",", "y1_inds", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "bboxes_x2", "=", "(", "abs_xs", "[", ":", ",", "x2_inds", "]", "*", "pred_scores", "[", ":", ",", "x2_inds", "]", ")", ".", "sum", "(", "\n", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "/", "(", "\n", "pred_scores", "[", ":", ",", "x2_inds", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "bboxes_y2", "=", "(", "abs_ys", "[", ":", ",", "y2_inds", "]", "*", "pred_scores", "[", ":", ",", "y2_inds", "]", ")", ".", "sum", "(", "\n", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "/", "(", "\n", "pred_scores", "[", ":", ",", "y2_inds", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "\n", "bbox_res", "=", "torch", ".", "cat", "(", "\n", "[", "bboxes_x1", ",", "bboxes_y1", ",", "bboxes_x2", ",", "bboxes_y2", ",", "cls_scores", "]", ",", "dim", "=", "1", ")", "\n", "bbox_res", "[", ":", ",", "[", "0", ",", "2", "]", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "[", "1", "]", ")", "\n", "bbox_res", "[", ":", ",", "[", "1", ",", "3", "]", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "img_metas", "[", "0", "]", "[", "'img_shape'", "]", "[", "0", "]", ")", "\n", "\n", "return", "bbox_res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.__init__": [[37, 79], ["dict", "dict", "dict", "torch.Module.__init__", "mmdet.models.builder.build_loss", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv1d", "torch.Conv1d", "mmcv.cnn.ConvModule", "mask_point_head.MaskPointHead.fcs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "num_fcs", "=", "3", ",", "\n", "in_channels", "=", "256", ",", "\n", "fc_channels", "=", "256", ",", "\n", "class_agnostic", "=", "False", ",", "\n", "coarse_pred_each_layer", "=", "True", ",", "\n", "conv_cfg", "=", "dict", "(", "type", "=", "'Conv1d'", ")", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "loss_point", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_mask", "=", "True", ",", "loss_weight", "=", "1.0", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_fcs", "=", "num_fcs", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "fc_channles", "=", "fc_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "class_agnostic", "=", "class_agnostic", "\n", "self", ".", "coarse_pred_each_layer", "=", "coarse_pred_each_layer", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "loss_point", "=", "build_loss", "(", "loss_point", ")", "\n", "\n", "fc_in_channels", "=", "in_channels", "+", "num_classes", "\n", "self", ".", "fcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "num_fcs", ")", ":", "\n", "            ", "fc", "=", "ConvModule", "(", "\n", "fc_in_channels", ",", "\n", "fc_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", "\n", "self", ".", "fcs", ".", "append", "(", "fc", ")", "\n", "fc_in_channels", "=", "fc_channels", "\n", "fc_in_channels", "+=", "num_classes", "if", "self", ".", "coarse_pred_each_layer", "else", "0", "\n", "\n", "", "out_channels", "=", "1", "if", "self", ".", "class_agnostic", "else", "self", ".", "num_classes", "\n", "self", ".", "fc_logits", "=", "nn", ".", "Conv1d", "(", "\n", "fc_in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.init_weights": [[80, 84], ["mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize last classification layer of MaskPointHead, conv layers\n        are already initialized by ConvModule.\"\"\"", "\n", "normal_init", "(", "self", ".", "fc_logits", ",", "std", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.forward": [[85, 105], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_point_head.MaskPointHead.fc_logits", "fc", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "fine_grained_feats", ",", "coarse_feats", ")", ":", "\n", "        ", "\"\"\"Classify each point base on fine grained and coarse feats.\n\n        Args:\n            fine_grained_feats (Tensor): Fine grained feature sampled from FPN,\n                shape (num_rois, in_channels, num_points).\n            coarse_feats (Tensor): Coarse feature sampled from CoarseMaskHead,\n                shape (num_rois, num_classes, num_points).\n\n        Returns:\n            Tensor: Point classification results,\n                shape (num_rois, num_class, num_points).\n        \"\"\"", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "fine_grained_feats", ",", "coarse_feats", "]", ",", "dim", "=", "1", ")", "\n", "for", "fc", "in", "self", ".", "fcs", ":", "\n", "            ", "x", "=", "fc", "(", "x", ")", "\n", "if", "self", ".", "coarse_pred_each_layer", ":", "\n", "                ", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "coarse_feats", ")", ",", "dim", "=", "1", ")", "\n", "", "", "return", "self", ".", "fc_logits", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.get_targets": [[106, 145], ["len", "range", "map", "list", "rois_list.append", "rel_roi_points_list.append", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range"], "methods", ["None"], ["", "def", "get_targets", "(", "self", ",", "rois", ",", "rel_roi_points", ",", "sampling_results", ",", "gt_masks", ",", "\n", "cfg", ")", ":", "\n", "        ", "\"\"\"Get training targets of MaskPointHead for all images.\n\n        Args:\n            rois (Tensor): Region of Interest, shape (num_rois, 5).\n            rel_roi_points: Points coordinates relative to RoI, shape\n                (num_rois, num_points, 2).\n            sampling_results (:obj:`SamplingResult`): Sampling result after\n                sampling and assignment.\n            gt_masks (Tensor) : Ground truth segmentation masks of\n                corresponding boxes, shape (num_rois, height, width).\n            cfg (dict): Training cfg.\n\n        Returns:\n            Tensor: Point target, shape (num_rois, num_points).\n        \"\"\"", "\n", "\n", "num_imgs", "=", "len", "(", "sampling_results", ")", "\n", "rois_list", "=", "[", "]", "\n", "rel_roi_points_list", "=", "[", "]", "\n", "for", "batch_ind", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "inds", "=", "(", "rois", "[", ":", ",", "0", "]", "==", "batch_ind", ")", "\n", "rois_list", ".", "append", "(", "rois", "[", "inds", "]", ")", "\n", "rel_roi_points_list", ".", "append", "(", "rel_roi_points", "[", "inds", "]", ")", "\n", "", "pos_assigned_gt_inds_list", "=", "[", "\n", "res", ".", "pos_assigned_gt_inds", "for", "res", "in", "sampling_results", "\n", "]", "\n", "cfg_list", "=", "[", "cfg", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "point_targets", "=", "map", "(", "self", ".", "_get_target_single", ",", "rois_list", ",", "\n", "rel_roi_points_list", ",", "pos_assigned_gt_inds_list", ",", "\n", "gt_masks", ",", "cfg_list", ")", "\n", "point_targets", "=", "list", "(", "point_targets", ")", "\n", "\n", "if", "len", "(", "point_targets", ")", ">", "0", ":", "\n", "            ", "point_targets", "=", "torch", ".", "cat", "(", "point_targets", ")", "\n", "\n", "", "return", "point_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead._get_target_single": [[146, 163], ["rois.size", "gt_masks.to_tensor().index_select", "gt_masks_th.unsqueeze.unsqueeze.unsqueeze", "mmcv.ops.rel_roi_point_to_rel_img_point", "mmcv.ops.point_sample().squeeze", "rois.new_zeros", "gt_masks.to_tensor", "mmcv.ops.point_sample"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor"], ["", "def", "_get_target_single", "(", "self", ",", "rois", ",", "rel_roi_points", ",", "pos_assigned_gt_inds", ",", "\n", "gt_masks", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"Get training target of MaskPointHead for each image.\"\"\"", "\n", "num_pos", "=", "rois", ".", "size", "(", "0", ")", "\n", "num_points", "=", "cfg", ".", "num_points", "\n", "if", "num_pos", ">", "0", ":", "\n", "            ", "gt_masks_th", "=", "(", "\n", "gt_masks", ".", "to_tensor", "(", "rois", ".", "dtype", ",", "rois", ".", "device", ")", ".", "index_select", "(", "\n", "0", ",", "pos_assigned_gt_inds", ")", ")", "\n", "gt_masks_th", "=", "gt_masks_th", ".", "unsqueeze", "(", "1", ")", "\n", "rel_img_points", "=", "rel_roi_point_to_rel_img_point", "(", "\n", "rois", ",", "rel_roi_points", ",", "gt_masks_th", ".", "shape", "[", "2", ":", "]", ")", "\n", "point_targets", "=", "point_sample", "(", "gt_masks_th", ",", "\n", "rel_img_points", ")", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "point_targets", "=", "rois", ".", "new_zeros", "(", "(", "0", ",", "num_points", ")", ")", "\n", "", "return", "point_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.loss": [[164, 186], ["dict", "mask_point_head.MaskPointHead.loss_point", "mask_point_head.MaskPointHead.loss_point", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "point_pred", ",", "point_targets", ",", "labels", ")", ":", "\n", "        ", "\"\"\"Calculate loss for MaskPointHead.\n\n        Args:\n            point_pred (Tensor): Point predication result, shape\n                (num_rois, num_classes, num_points).\n            point_targets (Tensor): Point targets, shape (num_roi, num_points).\n            labels (Tensor): Class label of corresponding boxes,\n                shape (num_rois, )\n\n        Returns:\n            dict[str, Tensor]: a dictionary of point loss components\n        \"\"\"", "\n", "\n", "loss", "=", "dict", "(", ")", "\n", "if", "self", ".", "class_agnostic", ":", "\n", "            ", "loss_point", "=", "self", ".", "loss_point", "(", "point_pred", ",", "point_targets", ",", "\n", "torch", ".", "zeros_like", "(", "labels", ")", ")", "\n", "", "else", ":", "\n", "            ", "loss_point", "=", "self", ".", "loss_point", "(", "point_pred", ",", "point_targets", ",", "labels", ")", "\n", "", "loss", "[", "'loss_point'", "]", "=", "loss_point", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead._get_uncertainty": [[187, 211], ["mask_pred.clone", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "mask_pred[].unsqueeze", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "_get_uncertainty", "(", "self", ",", "mask_pred", ",", "labels", ")", ":", "\n", "        ", "\"\"\"Estimate uncertainty based on pred logits.\n\n        We estimate uncertainty as L1 distance between 0.0 and the logits\n        prediction in 'mask_pred' for the foreground class in `classes`.\n\n        Args:\n            mask_pred (Tensor): mask predication logits, shape (num_rois,\n                num_classes, mask_height, mask_width).\n\n            labels (list[Tensor]): Either predicted or ground truth label for\n                each predicted mask, of length num_rois.\n\n        Returns:\n            scores (Tensor): Uncertainty scores with the most uncertain\n                locations having the highest uncertainty score,\n                shape (num_rois, 1, mask_height, mask_width)\n        \"\"\"", "\n", "if", "mask_pred", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "            ", "gt_class_logits", "=", "mask_pred", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "inds", "=", "torch", ".", "arange", "(", "mask_pred", ".", "shape", "[", "0", "]", ",", "device", "=", "mask_pred", ".", "device", ")", "\n", "gt_class_logits", "=", "mask_pred", "[", "inds", ",", "labels", "]", ".", "unsqueeze", "(", "1", ")", "\n", "", "return", "-", "torch", ".", "abs", "(", "gt_class_logits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.get_roi_rel_points_train": [[212, 266], ["int", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "mmcv.ops.point_sample", "mask_point_head.MaskPointHead._get_uncertainty", "int", "[].view", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.view", "torch.cat.view", "idx.view"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead._get_uncertainty"], ["", "def", "get_roi_rel_points_train", "(", "self", ",", "mask_pred", ",", "labels", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"Get ``num_points`` most uncertain points with random points during\n        train.\n\n        Sample points in [0, 1] x [0, 1] coordinate space based on their\n        uncertainty. The uncertainties are calculated for each point using\n        '_get_uncertainty()' function that takes point's logit prediction as\n        input.\n\n        Args:\n            mask_pred (Tensor): A tensor of shape (num_rois, num_classes,\n                mask_height, mask_width) for class-specific or class-agnostic\n                prediction.\n            labels (list): The ground truth class for each instance.\n            cfg (dict): Training config of point head.\n\n        Returns:\n            point_coords (Tensor): A tensor of shape (num_rois, num_points, 2)\n                that contains the coordinates sampled points.\n        \"\"\"", "\n", "num_points", "=", "cfg", ".", "num_points", "\n", "oversample_ratio", "=", "cfg", ".", "oversample_ratio", "\n", "importance_sample_ratio", "=", "cfg", ".", "importance_sample_ratio", "\n", "assert", "oversample_ratio", ">=", "1", "\n", "assert", "0", "<=", "importance_sample_ratio", "<=", "1", "\n", "batch_size", "=", "mask_pred", ".", "shape", "[", "0", "]", "\n", "num_sampled", "=", "int", "(", "num_points", "*", "oversample_ratio", ")", "\n", "point_coords", "=", "torch", ".", "rand", "(", "\n", "batch_size", ",", "num_sampled", ",", "2", ",", "device", "=", "mask_pred", ".", "device", ")", "\n", "point_logits", "=", "point_sample", "(", "mask_pred", ",", "point_coords", ")", "\n", "# It is crucial to calculate uncertainty based on the sampled", "\n", "# prediction value for the points. Calculating uncertainties of the", "\n", "# coarse predictions first and sampling them for points leads to", "\n", "# incorrect results.  To illustrate this: assume uncertainty func(", "\n", "# logits)=-abs(logits), a sampled point between two coarse", "\n", "# predictions with -1 and 1 logits has 0 logits, and therefore 0", "\n", "# uncertainty value. However, if we calculate uncertainties for the", "\n", "# coarse predictions first, both will have -1 uncertainty,", "\n", "# and sampled point will get -1 uncertainty.", "\n", "point_uncertainties", "=", "self", ".", "_get_uncertainty", "(", "point_logits", ",", "labels", ")", "\n", "num_uncertain_points", "=", "int", "(", "importance_sample_ratio", "*", "num_points", ")", "\n", "num_random_points", "=", "num_points", "-", "num_uncertain_points", "\n", "idx", "=", "torch", ".", "topk", "(", "\n", "point_uncertainties", "[", ":", ",", "0", ",", ":", "]", ",", "k", "=", "num_uncertain_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "shift", "=", "num_sampled", "*", "torch", ".", "arange", "(", "\n", "batch_size", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "mask_pred", ".", "device", ")", "\n", "idx", "+=", "shift", "[", ":", ",", "None", "]", "\n", "point_coords", "=", "point_coords", ".", "view", "(", "-", "1", ",", "2", ")", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "\n", "batch_size", ",", "num_uncertain_points", ",", "2", ")", "\n", "if", "num_random_points", ">", "0", ":", "\n", "            ", "rand_roi_coords", "=", "torch", ".", "rand", "(", "\n", "batch_size", ",", "num_random_points", ",", "2", ",", "device", "=", "mask_pred", ".", "device", ")", "\n", "point_coords", "=", "torch", ".", "cat", "(", "(", "point_coords", ",", "rand_roi_coords", ")", ",", "dim", "=", "1", ")", "\n", "", "return", "point_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead.get_roi_rel_points_test": [[267, 301], ["mask_point_head.MaskPointHead._get_uncertainty", "uncertainty_map.view.view.view", "min", "uncertainty_map.view.view.new_zeros", "uncertainty_map.view.view.topk"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.mask_point_head.MaskPointHead._get_uncertainty"], ["", "def", "get_roi_rel_points_test", "(", "self", ",", "mask_pred", ",", "pred_label", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"Get ``num_points`` most uncertain points during test.\n\n        Args:\n            mask_pred (Tensor): A tensor of shape (num_rois, num_classes,\n                mask_height, mask_width) for class-specific or class-agnostic\n                prediction.\n            pred_label (list): The predication class for each instance.\n            cfg (dict): Testing config of point head.\n\n        Returns:\n            point_indices (Tensor): A tensor of shape (num_rois, num_points)\n                that contains indices from [0, mask_height x mask_width) of the\n                most uncertain points.\n            point_coords (Tensor): A tensor of shape (num_rois, num_points, 2)\n                that contains [0, 1] x [0, 1] normalized coordinates of the\n                most uncertain points from the [mask_height, mask_width] grid .\n        \"\"\"", "\n", "num_points", "=", "cfg", ".", "subdivision_num_points", "\n", "uncertainty_map", "=", "self", ".", "_get_uncertainty", "(", "mask_pred", ",", "pred_label", ")", "\n", "num_rois", ",", "_", ",", "mask_height", ",", "mask_width", "=", "uncertainty_map", ".", "shape", "\n", "h_step", "=", "1.0", "/", "mask_height", "\n", "w_step", "=", "1.0", "/", "mask_width", "\n", "\n", "uncertainty_map", "=", "uncertainty_map", ".", "view", "(", "num_rois", ",", "\n", "mask_height", "*", "mask_width", ")", "\n", "num_points", "=", "min", "(", "mask_height", "*", "mask_width", ",", "num_points", ")", "\n", "point_indices", "=", "uncertainty_map", ".", "topk", "(", "num_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "point_coords", "=", "uncertainty_map", ".", "new_zeros", "(", "num_rois", ",", "num_points", ",", "2", ")", "\n", "point_coords", "[", ":", ",", ":", ",", "0", "]", "=", "w_step", "/", "2.0", "+", "(", "point_indices", "%", "\n", "mask_width", ")", ".", "float", "(", ")", "*", "w_step", "\n", "point_coords", "[", ":", ",", ":", ",", "1", "]", "=", "h_step", "/", "2.0", "+", "(", "point_indices", "//", "\n", "mask_width", ")", ".", "float", "(", ")", "*", "h_step", "\n", "return", "point_indices", ",", "point_coords", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fused_semantic_head.FusedSemanticHead.__init__": [[26, 81], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "range", "torch.ModuleList", "torch.ModuleList", "range", "mmcv.cnn.ConvModule", "torch.Conv2d", "torch.Conv2d", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "fused_semantic_head.FusedSemanticHead.lateral_convs.append", "fused_semantic_head.FusedSemanticHead.convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_ins", ",", "\n", "fusion_level", ",", "\n", "num_convs", "=", "4", ",", "\n", "in_channels", "=", "256", ",", "\n", "conv_out_channels", "=", "256", ",", "\n", "num_classes", "=", "183", ",", "\n", "ignore_label", "=", "255", ",", "\n", "loss_weight", "=", "0.2", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "FusedSemanticHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_ins", "=", "num_ins", "\n", "self", ".", "fusion_level", "=", "fusion_level", "\n", "self", ".", "num_convs", "=", "num_convs", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv_out_channels", "=", "conv_out_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_ins", ")", ":", "\n", "            ", "self", ".", "lateral_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "in_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "inplace", "=", "False", ")", ")", "\n", "\n", "", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_convs", ")", ":", "\n", "            ", "in_channels", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "conv_out_channels", "\n", "self", ".", "convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "conv_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "self", ".", "conv_embedding", "=", "ConvModule", "(", "\n", "conv_out_channels", ",", "\n", "conv_out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", "\n", "self", ".", "conv_logits", "=", "nn", ".", "Conv2d", "(", "conv_out_channels", ",", "self", ".", "num_classes", ",", "1", ")", "\n", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "ignore_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fused_semantic_head.FusedSemanticHead.init_weights": [[82, 84], ["mmcv.cnn.kaiming_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "kaiming_init", "(", "self", ".", "conv_logits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fused_semantic_head.FusedSemanticHead.forward": [[85, 101], ["mmdet.core.auto_fp16", "tuple", "enumerate", "range", "fused_semantic_head.FusedSemanticHead.conv_logits", "fused_semantic_head.FusedSemanticHead.conv_embedding", "torch.interpolate", "torch.interpolate"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "x", "=", "self", ".", "lateral_convs", "[", "self", ".", "fusion_level", "]", "(", "feats", "[", "self", ".", "fusion_level", "]", ")", "\n", "fused_size", "=", "tuple", "(", "x", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "for", "i", ",", "feat", "in", "enumerate", "(", "feats", ")", ":", "\n", "            ", "if", "i", "!=", "self", ".", "fusion_level", ":", "\n", "                ", "feat", "=", "F", ".", "interpolate", "(", "\n", "feat", ",", "size", "=", "fused_size", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "x", "+=", "self", ".", "lateral_convs", "[", "i", "]", "(", "feat", ")", "\n", "\n", "", "", "for", "i", "in", "range", "(", "self", ".", "num_convs", ")", ":", "\n", "            ", "x", "=", "self", ".", "convs", "[", "i", "]", "(", "x", ")", "\n", "\n", "", "mask_pred", "=", "self", ".", "conv_logits", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_embedding", "(", "x", ")", "\n", "return", "mask_pred", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fused_semantic_head.FusedSemanticHead.loss": [[102, 108], ["mmdet.core.force_fp32", "labels.squeeze().long.squeeze().long.squeeze().long", "fused_semantic_head.FusedSemanticHead.criterion", "labels.squeeze().long.squeeze().long.squeeze"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'mask_pred'", ",", ")", ")", "\n", "def", "loss", "(", "self", ",", "mask_pred", ",", "labels", ")", ":", "\n", "        ", "labels", "=", "labels", ".", "squeeze", "(", "1", ")", ".", "long", "(", ")", "\n", "loss_semantic_seg", "=", "self", ".", "criterion", "(", "mask_pred", ",", "labels", ")", "\n", "loss_semantic_seg", "*=", "self", ".", "loss_weight", "\n", "return", "loss_semantic_seg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.__init__": [[22, 105], ["dict", "dict", "torch.Module.__init__", "upsample_cfg.copy", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "fcn_mask_head.FCNMaskHead.upsample_cfg.get", "fcn_mask_head.FCNMaskHead.upsample_cfg.pop", "mmdet.models.builder.build_loss", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "fcn_mask_head.FCNMaskHead.upsample_cfg.copy", "mmcv.ops.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "ValueError", "fcn_mask_head.FCNMaskHead.convs.append", "mmcv.cnn.ConvModule", "fcn_mask_head.FCNMaskHead.update", "mmcv.cnn.build_upsample_layer", "fcn_mask_head.FCNMaskHead.update", "mmcv.cnn.build_upsample_layer", "fcn_mask_head.FCNMaskHead.update", "mmcv.cnn.build_upsample_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["    ", "def", "__init__", "(", "self", ",", "\n", "num_convs", "=", "4", ",", "\n", "roi_feat_size", "=", "14", ",", "\n", "in_channels", "=", "256", ",", "\n", "conv_kernel_size", "=", "3", ",", "\n", "conv_out_channels", "=", "256", ",", "\n", "num_classes", "=", "80", ",", "\n", "class_agnostic", "=", "False", ",", "\n", "upsample_cfg", "=", "dict", "(", "type", "=", "'deconv'", ",", "scale_factor", "=", "2", ")", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "loss_mask", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_mask", "=", "True", ",", "loss_weight", "=", "1.0", ")", ")", ":", "\n", "        ", "super", "(", "FCNMaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "upsample_cfg", "=", "upsample_cfg", ".", "copy", "(", ")", "\n", "if", "self", ".", "upsample_cfg", "[", "'type'", "]", "not", "in", "[", "\n", "None", ",", "'deconv'", ",", "'nearest'", ",", "'bilinear'", ",", "'carafe'", "\n", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f'Invalid upsample method {self.upsample_cfg[\"type\"]}, '", "\n", "'accepted methods are \"deconv\", \"nearest\", \"bilinear\", '", "\n", "'\"carafe\"'", ")", "\n", "", "self", ".", "num_convs", "=", "num_convs", "\n", "# WARN: roi_feat_size is reserved and not used", "\n", "self", ".", "roi_feat_size", "=", "_pair", "(", "roi_feat_size", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv_kernel_size", "=", "conv_kernel_size", "\n", "self", ".", "conv_out_channels", "=", "conv_out_channels", "\n", "self", ".", "upsample_method", "=", "self", ".", "upsample_cfg", ".", "get", "(", "'type'", ")", "\n", "self", ".", "scale_factor", "=", "self", ".", "upsample_cfg", ".", "pop", "(", "'scale_factor'", ",", "None", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "class_agnostic", "=", "class_agnostic", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "self", ".", "loss_mask", "=", "build_loss", "(", "loss_mask", ")", "\n", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_convs", ")", ":", "\n", "            ", "in_channels", "=", "(", "\n", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "conv_out_channels", ")", "\n", "padding", "=", "(", "self", ".", "conv_kernel_size", "-", "1", ")", "//", "2", "\n", "self", ".", "convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "self", ".", "conv_kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", ")", "\n", "", "upsample_in_channels", "=", "(", "\n", "self", ".", "conv_out_channels", "if", "self", ".", "num_convs", ">", "0", "else", "in_channels", ")", "\n", "upsample_cfg_", "=", "self", ".", "upsample_cfg", ".", "copy", "(", ")", "\n", "if", "self", ".", "upsample_method", "is", "None", ":", "\n", "            ", "self", ".", "upsample", "=", "None", "\n", "", "elif", "self", ".", "upsample_method", "==", "'deconv'", ":", "\n", "            ", "upsample_cfg_", ".", "update", "(", "\n", "in_channels", "=", "upsample_in_channels", ",", "\n", "out_channels", "=", "self", ".", "conv_out_channels", ",", "\n", "kernel_size", "=", "self", ".", "scale_factor", ",", "\n", "stride", "=", "self", ".", "scale_factor", ")", "\n", "self", ".", "upsample", "=", "build_upsample_layer", "(", "upsample_cfg_", ")", "\n", "", "elif", "self", ".", "upsample_method", "==", "'carafe'", ":", "\n", "            ", "upsample_cfg_", ".", "update", "(", "\n", "channels", "=", "upsample_in_channels", ",", "scale_factor", "=", "self", ".", "scale_factor", ")", "\n", "self", ".", "upsample", "=", "build_upsample_layer", "(", "upsample_cfg_", ")", "\n", "", "else", ":", "\n", "# suppress warnings", "\n", "            ", "align_corners", "=", "(", "None", "\n", "if", "self", ".", "upsample_method", "==", "'nearest'", "else", "False", ")", "\n", "upsample_cfg_", ".", "update", "(", "\n", "scale_factor", "=", "self", ".", "scale_factor", ",", "\n", "mode", "=", "self", ".", "upsample_method", ",", "\n", "align_corners", "=", "align_corners", ")", "\n", "self", ".", "upsample", "=", "build_upsample_layer", "(", "upsample_cfg_", ")", "\n", "\n", "", "out_channels", "=", "1", "if", "self", ".", "class_agnostic", "else", "self", ".", "num_classes", "\n", "logits_in_channel", "=", "(", "\n", "self", ".", "conv_out_channels", "\n", "if", "self", ".", "upsample_method", "==", "'deconv'", "else", "upsample_in_channels", ")", "\n", "self", ".", "conv_logits", "=", "Conv2d", "(", "logits_in_channel", ",", "out_channels", ",", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "debug_imgs", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.init_weights": [[106, 116], ["isinstance", "m.init_weights", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "[", "self", ".", "upsample", ",", "self", ".", "conv_logits", "]", ":", "\n", "            ", "if", "m", "is", "None", ":", "\n", "                ", "continue", "\n", "", "elif", "isinstance", "(", "m", ",", "CARAFEPack", ")", ":", "\n", "                ", "m", ".", "init_weights", "(", ")", "\n", "", "else", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.forward": [[117, 127], ["mmdet.core.auto_fp16", "fcn_mask_head.FCNMaskHead.conv_logits", "conv", "fcn_mask_head.FCNMaskHead.upsample", "fcn_mask_head.FCNMaskHead.relu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "", "", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "x", "=", "conv", "(", "x", ")", "\n", "", "if", "self", ".", "upsample", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "upsample", "(", "x", ")", "\n", "if", "self", ".", "upsample_method", "==", "'deconv'", ":", "\n", "                ", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "", "", "mask_pred", "=", "self", ".", "conv_logits", "(", "x", ")", "\n", "return", "mask_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_targets": [[128, 136], ["mmdet.core.mask_target"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.mask_target.mask_target"], ["", "def", "get_targets", "(", "self", ",", "sampling_results", ",", "gt_masks", ",", "rcnn_train_cfg", ")", ":", "\n", "        ", "pos_proposals", "=", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", "\n", "pos_assigned_gt_inds", "=", "[", "\n", "res", ".", "pos_assigned_gt_inds", "for", "res", "in", "sampling_results", "\n", "]", "\n", "mask_targets", "=", "mask_target", "(", "pos_proposals", ",", "pos_assigned_gt_inds", ",", "\n", "gt_masks", ",", "rcnn_train_cfg", ")", "\n", "return", "mask_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.loss": [[137, 150], ["mmdet.core.force_fp32", "dict", "mask_pred.size", "mask_pred.sum", "fcn_mask_head.FCNMaskHead.loss_mask", "fcn_mask_head.FCNMaskHead.loss_mask", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'mask_pred'", ",", ")", ")", "\n", "def", "loss", "(", "self", ",", "mask_pred", ",", "mask_targets", ",", "labels", ")", ":", "\n", "        ", "loss", "=", "dict", "(", ")", "\n", "if", "mask_pred", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "loss_mask", "=", "mask_pred", ".", "sum", "(", ")", "*", "0", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "class_agnostic", ":", "\n", "                ", "loss_mask", "=", "self", ".", "loss_mask", "(", "mask_pred", ",", "mask_targets", ",", "\n", "torch", ".", "zeros_like", "(", "labels", ")", ")", "\n", "", "else", ":", "\n", "                ", "loss_mask", "=", "self", ".", "loss_mask", "(", "mask_pred", ",", "mask_targets", ",", "labels", ")", "\n", "", "", "loss", "[", "'loss_mask'", "]", "=", "loss_mask", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head.FCNMaskHead.get_seg_masks": [[151, 240], ["isinstance", "len", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "det_bboxes.new_tensor.sigmoid", "det_bboxes.new_tensor", "len", "numpy.round().astype", "numpy.round().astype", "isinstance", "bboxes.new_tensor", "int", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "fcn_mask_head._do_paste_mask", "cls_segms[].append", "range", "numpy.ceil", "im_mask[].cpu().numpy", "numpy.round", "numpy.round", "im_mask[].cpu", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head._do_paste_mask"], ["", "def", "get_seg_masks", "(", "self", ",", "mask_pred", ",", "det_bboxes", ",", "det_labels", ",", "rcnn_test_cfg", ",", "\n", "ori_shape", ",", "scale_factor", ",", "rescale", ")", ":", "\n", "        ", "\"\"\"Get segmentation masks from mask_pred and bboxes.\n\n        Args:\n            mask_pred (Tensor or ndarray): shape (n, #class, h, w).\n                For single-scale testing, mask_pred is the direct output of\n                model, whose type is Tensor, while for multi-scale testing,\n                it will be converted to numpy array outside of this method.\n            det_bboxes (Tensor): shape (n, 4/5)\n            det_labels (Tensor): shape (n, )\n            img_shape (Tensor): shape (3, )\n            rcnn_test_cfg (dict): rcnn testing config\n            ori_shape: original image size\n\n        Returns:\n            list[list]: encoded masks\n        \"\"\"", "\n", "if", "isinstance", "(", "mask_pred", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "mask_pred", "=", "mask_pred", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "mask_pred", "=", "det_bboxes", ".", "new_tensor", "(", "mask_pred", ")", "\n", "\n", "", "device", "=", "mask_pred", ".", "device", "\n", "cls_segms", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "num_classes", ")", "\n", "]", "# BG is not included in num_classes", "\n", "if", "len", "(", "mask_pred", ")", "==", "0", ":", "\n", "            ", "return", "cls_segms", "\n", "", "bboxes", "=", "det_bboxes", "[", ":", ",", ":", "4", "]", "\n", "labels", "=", "det_labels", "\n", "\n", "if", "rescale", ":", "\n", "            ", "img_h", ",", "img_w", "=", "ori_shape", "[", ":", "2", "]", "\n", "", "else", ":", "\n", "            ", "img_h", "=", "np", ".", "round", "(", "ori_shape", "[", "0", "]", "*", "scale_factor", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "img_w", "=", "np", ".", "round", "(", "ori_shape", "[", "1", "]", "*", "scale_factor", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "scale_factor", "=", "1.0", "\n", "\n", "", "if", "not", "isinstance", "(", "scale_factor", ",", "(", "float", ",", "torch", ".", "Tensor", ")", ")", ":", "\n", "            ", "scale_factor", "=", "bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "bboxes", "=", "bboxes", "/", "scale_factor", "\n", "\n", "N", "=", "len", "(", "mask_pred", ")", "\n", "# The actual implementation split the input into chunks,", "\n", "# and paste them chunk by chunk.", "\n", "if", "device", ".", "type", "==", "'cpu'", ":", "\n", "# CPU is most efficient when they are pasted one by one with", "\n", "# skip_empty=True, so that it performs minimal number of", "\n", "# operations.", "\n", "            ", "num_chunks", "=", "N", "\n", "", "else", ":", "\n", "# GPU benefits from parallelism for larger chunks,", "\n", "# but may have memory issue", "\n", "            ", "num_chunks", "=", "int", "(", "\n", "np", ".", "ceil", "(", "N", "*", "img_h", "*", "img_w", "*", "BYTES_PER_FLOAT", "/", "GPU_MEM_LIMIT", ")", ")", "\n", "assert", "(", "num_chunks", "<=", "\n", "N", ")", ",", "'Default GPU_MEM_LIMIT is too small; try increasing it'", "\n", "", "chunks", "=", "torch", ".", "chunk", "(", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", ",", "num_chunks", ")", "\n", "\n", "threshold", "=", "rcnn_test_cfg", ".", "mask_thr_binary", "\n", "im_mask", "=", "torch", ".", "zeros", "(", "\n", "N", ",", "\n", "img_h", ",", "\n", "img_w", ",", "\n", "device", "=", "device", ",", "\n", "dtype", "=", "torch", ".", "bool", "if", "threshold", ">=", "0", "else", "torch", ".", "uint8", ")", "\n", "\n", "if", "not", "self", ".", "class_agnostic", ":", "\n", "            ", "mask_pred", "=", "mask_pred", "[", "range", "(", "N", ")", ",", "labels", "]", "[", ":", ",", "None", "]", "\n", "\n", "", "for", "inds", "in", "chunks", ":", "\n", "            ", "masks_chunk", ",", "spatial_inds", "=", "_do_paste_mask", "(", "\n", "mask_pred", "[", "inds", "]", ",", "\n", "bboxes", "[", "inds", "]", ",", "\n", "img_h", ",", "\n", "img_w", ",", "\n", "skip_empty", "=", "device", ".", "type", "==", "'cpu'", ")", "\n", "\n", "if", "threshold", ">=", "0", ":", "\n", "                ", "masks_chunk", "=", "(", "masks_chunk", ">=", "threshold", ")", ".", "to", "(", "dtype", "=", "torch", ".", "bool", ")", "\n", "", "else", ":", "\n", "# for visualization and debugging", "\n", "                ", "masks_chunk", "=", "(", "masks_chunk", "*", "255", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "im_mask", "[", "(", "inds", ",", ")", "+", "spatial_inds", "]", "=", "masks_chunk", "\n", "\n", "", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "cls_segms", "[", "labels", "[", "i", "]", "]", ".", "append", "(", "im_mask", "[", "i", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "return", "cls_segms", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.fcn_mask_head._do_paste_mask": [[242, 311], ["torch.split", "torch.split", "torch.split", "torch.isinf().any", "torch.isinf().any", "torch.isinf().any", "torch.isinf().any", "torch.isinf().any", "torch.isinf().any", "img_x[].expand", "img_y[].expand", "torch.stack", "torch.stack", "torch.stack", "torch.grid_sample", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "img_y.size", "img_x.size", "img_y.size", "img_x.size", "masks.to", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "slice", "slice", "boxes[].max().ceil", "boxes[].max().ceil", "boxes.min().values.floor", "boxes[].max", "boxes[].max", "boxes.min"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "", "def", "_do_paste_mask", "(", "masks", ",", "boxes", ",", "img_h", ",", "img_w", ",", "skip_empty", "=", "True", ")", ":", "\n", "    ", "\"\"\"Paste instance masks acoording to boxes.\n\n    This implementation is modified from\n    https://github.com/facebookresearch/detectron2/\n\n    Args:\n        masks (Tensor): N, 1, H, W\n        boxes (Tensor): N, 4\n        img_h (int): Height of the image to be pasted.\n        img_w (int): Width of the image to be pasted.\n        skip_empty (bool): Only paste masks within the region that\n            tightly bound all boxes, and returns the results this region only.\n            An important optimization for CPU.\n\n    Returns:\n        tuple: (Tensor, tuple). The first item is mask tensor, the second one\n            is the slice object.\n        If skip_empty == False, the whole image will be pasted. It will\n            return a mask of shape (N, img_h, img_w) and an empty tuple.\n        If skip_empty == True, only area around the mask will be pasted.\n            A mask of shape (N, h', w') and its start and end coordinates\n            in the original image will be returned.\n    \"\"\"", "\n", "# On GPU, paste all masks together (up to chunk size)", "\n", "# by using the entire image to sample the masks", "\n", "# Compared to pasting them one by one,", "\n", "# this has more operations but is faster on COCO-scale dataset.", "\n", "device", "=", "masks", ".", "device", "\n", "if", "skip_empty", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "torch", ".", "clamp", "(", "\n", "boxes", ".", "min", "(", "dim", "=", "0", ")", ".", "values", ".", "floor", "(", ")", "[", ":", "2", "]", "-", "1", ",", "\n", "min", "=", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "x1_int", "=", "torch", ".", "clamp", "(", "\n", "boxes", "[", ":", ",", "2", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_w", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "y1_int", "=", "torch", ".", "clamp", "(", "\n", "boxes", "[", ":", ",", "3", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_h", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "0", ",", "0", "\n", "x1_int", ",", "y1_int", "=", "img_w", ",", "img_h", "\n", "", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "torch", ".", "split", "(", "boxes", ",", "1", ",", "dim", "=", "1", ")", "# each is Nx1", "\n", "\n", "N", "=", "masks", ".", "shape", "[", "0", "]", "\n", "\n", "img_y", "=", "torch", ".", "arange", "(", "\n", "y0_int", ",", "y1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_x", "=", "torch", ".", "arange", "(", "\n", "x0_int", ",", "x1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_y", "=", "(", "img_y", "-", "y0", ")", "/", "(", "y1", "-", "y0", ")", "*", "2", "-", "1", "\n", "img_x", "=", "(", "img_x", "-", "x0", ")", "/", "(", "x1", "-", "x0", ")", "*", "2", "-", "1", "\n", "# img_x, img_y have shapes (N, w), (N, h)", "\n", "if", "torch", ".", "isinf", "(", "img_x", ")", ".", "any", "(", ")", ":", "\n", "        ", "inds", "=", "torch", ".", "where", "(", "torch", ".", "isinf", "(", "img_x", ")", ")", "\n", "img_x", "[", "inds", "]", "=", "0", "\n", "", "if", "torch", ".", "isinf", "(", "img_y", ")", ".", "any", "(", ")", ":", "\n", "        ", "inds", "=", "torch", ".", "where", "(", "torch", ".", "isinf", "(", "img_y", ")", ")", "\n", "img_y", "[", "inds", "]", "=", "0", "\n", "\n", "", "gx", "=", "img_x", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "gy", "=", "img_y", "[", ":", ",", ":", ",", "None", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "grid", "=", "torch", ".", "stack", "(", "[", "gx", ",", "gy", "]", ",", "dim", "=", "3", ")", "\n", "\n", "img_masks", "=", "F", ".", "grid_sample", "(", "\n", "masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "grid", ",", "align_corners", "=", "False", ")", "\n", "\n", "if", "skip_empty", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", "slice", "(", "y0_int", ",", "y1_int", ")", ",", "slice", "(", "x0_int", ",", "x1_int", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.htc_mask_head.HTCMaskHead.__init__": [[10, 20], ["fcn_mask_head.FCNMaskHead.__init__", "mmcv.cnn.ConvModule"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "with_conv_res", "=", "True", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "HTCMaskHead", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "with_conv_res", "=", "with_conv_res", "\n", "if", "self", ".", "with_conv_res", ":", "\n", "            ", "self", ".", "conv_res", "=", "ConvModule", "(", "\n", "self", ".", "conv_out_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.htc_mask_head.HTCMaskHead.init_weights": [[21, 25], ["super().init_weights", "htc_mask_head.HTCMaskHead.conv_res.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "super", "(", "HTCMaskHead", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "if", "self", ".", "with_conv_res", ":", "\n", "            ", "self", ".", "conv_res", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.htc_mask_head.HTCMaskHead.forward": [[26, 44], ["htc_mask_head.HTCMaskHead.conv_res", "conv", "htc_mask_head.HTCMaskHead.upsample", "htc_mask_head.HTCMaskHead.conv_logits", "outs.append", "outs.append", "htc_mask_head.HTCMaskHead.relu", "len"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "res_feat", "=", "None", ",", "return_logits", "=", "True", ",", "return_feat", "=", "True", ")", ":", "\n", "        ", "if", "res_feat", "is", "not", "None", ":", "\n", "            ", "assert", "self", ".", "with_conv_res", "\n", "res_feat", "=", "self", ".", "conv_res", "(", "res_feat", ")", "\n", "x", "=", "x", "+", "res_feat", "\n", "", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "x", "=", "conv", "(", "x", ")", "\n", "", "res_feat", "=", "x", "\n", "outs", "=", "[", "]", "\n", "if", "return_logits", ":", "\n", "            ", "x", "=", "self", ".", "upsample", "(", "x", ")", "\n", "if", "self", ".", "upsample_method", "==", "'deconv'", ":", "\n", "                ", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "", "mask_pred", "=", "self", ".", "conv_logits", "(", "x", ")", "\n", "outs", ".", "append", "(", "mask_pred", ")", "\n", "", "if", "return_feat", ":", "\n", "            ", "outs", ".", "append", "(", "res_feat", ")", "\n", "", "return", "outs", "if", "len", "(", "outs", ")", ">", "1", "else", "outs", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.coarse_mask_head.CoarseMaskHead.__init__": [[25, 71], ["fcn_mask_head.FCNMaskHead.__init__", "delattr", "torch.ModuleList", "range", "torch.Linear", "mmcv.cnn.ConvModule", "coarse_mask_head.CoarseMaskHead.fcs.append", "dict", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_convs", "=", "0", ",", "\n", "num_fcs", "=", "2", ",", "\n", "fc_out_channels", "=", "1024", ",", "\n", "downsample_factor", "=", "2", ",", "\n", "*", "arg", ",", "\n", "**", "kwarg", ")", ":", "\n", "        ", "super", "(", "CoarseMaskHead", ",", "self", ")", ".", "__init__", "(", "\n", "*", "arg", ",", "num_convs", "=", "num_convs", ",", "upsample_cfg", "=", "dict", "(", "type", "=", "None", ")", ",", "**", "kwarg", ")", "\n", "self", ".", "num_fcs", "=", "num_fcs", "\n", "assert", "self", ".", "num_fcs", ">", "0", "\n", "self", ".", "fc_out_channels", "=", "fc_out_channels", "\n", "self", ".", "downsample_factor", "=", "downsample_factor", "\n", "assert", "self", ".", "downsample_factor", ">=", "1", "\n", "# remove conv_logit", "\n", "delattr", "(", "self", ",", "'conv_logits'", ")", "\n", "\n", "if", "downsample_factor", ">", "1", ":", "\n", "            ", "downsample_in_channels", "=", "(", "\n", "self", ".", "conv_out_channels", "\n", "if", "self", ".", "num_convs", ">", "0", "else", "self", ".", "in_channels", ")", "\n", "self", ".", "downsample_conv", "=", "ConvModule", "(", "\n", "downsample_in_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "kernel_size", "=", "downsample_factor", ",", "\n", "stride", "=", "downsample_factor", ",", "\n", "padding", "=", "0", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "downsample_conv", "=", "None", "\n", "\n", "", "self", ".", "output_size", "=", "(", "self", ".", "roi_feat_size", "[", "0", "]", "//", "downsample_factor", ",", "\n", "self", ".", "roi_feat_size", "[", "1", "]", "//", "downsample_factor", ")", "\n", "self", ".", "output_area", "=", "self", ".", "output_size", "[", "0", "]", "*", "self", ".", "output_size", "[", "1", "]", "\n", "\n", "last_layer_dim", "=", "self", ".", "conv_out_channels", "*", "self", ".", "output_area", "\n", "\n", "self", ".", "fcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "num_fcs", ")", ":", "\n", "            ", "fc_in_channels", "=", "(", "\n", "last_layer_dim", "if", "i", "==", "0", "else", "self", ".", "fc_out_channels", ")", "\n", "self", ".", "fcs", ".", "append", "(", "nn", ".", "Linear", "(", "fc_in_channels", ",", "self", ".", "fc_out_channels", ")", ")", "\n", "", "last_layer_dim", "=", "self", ".", "fc_out_channels", "\n", "output_channels", "=", "self", ".", "num_classes", "*", "self", ".", "output_area", "\n", "self", ".", "fc_logits", "=", "nn", ".", "Linear", "(", "last_layer_dim", ",", "output_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.coarse_mask_head.CoarseMaskHead.init_weights": [[72, 77], ["coarse_mask_head.CoarseMaskHead.fcs.modules", "mmcv.cnn.constant_init", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "fcs", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "xavier_init", "(", "m", ")", "\n", "", "", "constant_init", "(", "self", ".", "fc_logits", ",", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask_heads.coarse_mask_head.CoarseMaskHead.forward": [[78, 92], ["mmdet.core.auto_fp16", "coarse_mask_head.CoarseMaskHead.flatten", "coarse_mask_head.CoarseMaskHead.fc_logits().view", "conv", "coarse_mask_head.CoarseMaskHead.downsample_conv", "coarse_mask_head.CoarseMaskHead.relu", "coarse_mask_head.CoarseMaskHead.size", "fc", "coarse_mask_head.CoarseMaskHead.fc_logits"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "x", "=", "conv", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "downsample_conv", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "downsample_conv", "(", "x", ")", "\n", "\n", "", "x", "=", "x", ".", "flatten", "(", "1", ")", "\n", "for", "fc", "in", "self", ".", "fcs", ":", "\n", "            ", "x", "=", "self", ".", "relu", "(", "fc", "(", "x", ")", ")", "\n", "", "mask_pred", "=", "self", ".", "fc_logits", "(", "x", ")", ".", "view", "(", "\n", "x", ".", "size", "(", "0", ")", ",", "self", ".", "num_classes", ",", "*", "self", ".", "output_size", ")", "\n", "return", "mask_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.shared_heads.res_layer.ResLayer.__init__": [[15, 47], ["dict", "torch.Module.__init__", "mmdet.models.utils.ResLayer", "mmdet.models.utils.ResLayer.ResLayer.add_module"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["\n", "\n", "def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "1", ",", "\n", "avg_down", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "downsample_first", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "block", "=", "block", "\n", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "[", "]", "\n", "conv_stride", "=", "stride", "\n", "if", "avg_down", "and", "stride", "!=", "1", ":", "\n", "                ", "conv_stride", "=", "1", "\n", "downsample", ".", "append", "(", "\n", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "stride", ",", "\n", "stride", "=", "stride", ",", "\n", "ceil_mode", "=", "True", ",", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.shared_heads.res_layer.ResLayer.init_weights": [[48, 66], ["isinstance", "mmdet.utils.get_root_logger", "mmcv.runner.load_checkpoint", "res_layer.ResLayer.modules", "TypeError", "isinstance", "mmcv.cnn.kaiming_init", "isinstance", "mmcv.cnn.constant_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger"], ["count_include_pad", "=", "False", ")", ")", "\n", "", "downsample", ".", "extend", "(", "[", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "conv_stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", "\n", "]", ")", "\n", "downsample", "=", "nn", ".", "Sequential", "(", "*", "downsample", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "if", "downsample_first", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.shared_heads.res_layer.ResLayer.forward": [[67, 72], ["mmdet.core.auto_fp16", "getattr", "getattr."], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.shared_heads.res_layer.ResLayer.train": [[73, 79], ["super().train", "res_layer.ResLayer.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train"], ["for", "_", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "                ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead.__init__": [[20, 84], ["bbox_head.BBoxHead.__init__", "convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch", "convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch", "convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch", "torch.ReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch"], ["def", "__init__", "(", "self", ",", "\n", "num_shared_convs", "=", "0", ",", "\n", "num_shared_fcs", "=", "0", ",", "\n", "num_cls_convs", "=", "0", ",", "\n", "num_cls_fcs", "=", "0", ",", "\n", "num_reg_convs", "=", "0", ",", "\n", "num_reg_fcs", "=", "0", ",", "\n", "conv_out_channels", "=", "256", ",", "\n", "fc_out_channels", "=", "1024", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ConvFCBBoxHead", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "assert", "(", "num_shared_convs", "+", "num_shared_fcs", "+", "num_cls_convs", "+", "\n", "num_cls_fcs", "+", "num_reg_convs", "+", "num_reg_fcs", ">", "0", ")", "\n", "if", "num_cls_convs", ">", "0", "or", "num_reg_convs", ">", "0", ":", "\n", "            ", "assert", "num_shared_fcs", "==", "0", "\n", "", "if", "not", "self", ".", "with_cls", ":", "\n", "            ", "assert", "num_cls_convs", "==", "0", "and", "num_cls_fcs", "==", "0", "\n", "", "if", "not", "self", ".", "with_reg", ":", "\n", "            ", "assert", "num_reg_convs", "==", "0", "and", "num_reg_fcs", "==", "0", "\n", "", "self", ".", "num_shared_convs", "=", "num_shared_convs", "\n", "self", ".", "num_shared_fcs", "=", "num_shared_fcs", "\n", "self", ".", "num_cls_convs", "=", "num_cls_convs", "\n", "self", ".", "num_cls_fcs", "=", "num_cls_fcs", "\n", "self", ".", "num_reg_convs", "=", "num_reg_convs", "\n", "self", ".", "num_reg_fcs", "=", "num_reg_fcs", "\n", "self", ".", "conv_out_channels", "=", "conv_out_channels", "\n", "self", ".", "fc_out_channels", "=", "fc_out_channels", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "\n", "# add shared convs and fcs", "\n", "self", ".", "shared_convs", ",", "self", ".", "shared_fcs", ",", "last_layer_dim", "=", "self", ".", "_add_conv_fc_branch", "(", "\n", "self", ".", "num_shared_convs", ",", "self", ".", "num_shared_fcs", ",", "self", ".", "in_channels", ",", "\n", "True", ")", "\n", "self", ".", "shared_out_channels", "=", "last_layer_dim", "\n", "\n", "# add cls specific branch", "\n", "self", ".", "cls_convs", ",", "self", ".", "cls_fcs", ",", "self", ".", "cls_last_dim", "=", "self", ".", "_add_conv_fc_branch", "(", "\n", "self", ".", "num_cls_convs", ",", "self", ".", "num_cls_fcs", ",", "self", ".", "shared_out_channels", ")", "\n", "\n", "# add reg specific branch", "\n", "self", ".", "reg_convs", ",", "self", ".", "reg_fcs", ",", "self", ".", "reg_last_dim", "=", "self", ".", "_add_conv_fc_branch", "(", "\n", "self", ".", "num_reg_convs", ",", "self", ".", "num_reg_fcs", ",", "self", ".", "shared_out_channels", ")", "\n", "\n", "if", "self", ".", "num_shared_fcs", "==", "0", "and", "not", "self", ".", "with_avg_pool", ":", "\n", "            ", "if", "self", ".", "num_cls_fcs", "==", "0", ":", "\n", "                ", "self", ".", "cls_last_dim", "*=", "self", ".", "roi_feat_area", "\n", "", "if", "self", ".", "num_reg_fcs", "==", "0", ":", "\n", "                ", "self", ".", "reg_last_dim", "*=", "self", ".", "roi_feat_area", "\n", "\n", "", "", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "# reconstruct fc_cls and fc_reg since input channels are changed", "\n", "if", "self", ".", "with_cls", ":", "\n", "            ", "self", ".", "fc_cls", "=", "nn", ".", "Linear", "(", "self", ".", "cls_last_dim", ",", "self", ".", "num_classes", "+", "1", ")", "\n", "", "if", "self", ".", "with_reg", ":", "\n", "            ", "out_dim_reg", "=", "(", "4", "if", "self", ".", "reg_class_agnostic", "else", "4", "*", "\n", "self", ".", "num_classes", ")", "\n", "self", ".", "fc_reg", "=", "nn", ".", "Linear", "(", "self", ".", "reg_last_dim", ",", "out_dim_reg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead._add_conv_fc_branch": [[85, 125], ["torch.ModuleList", "torch.ModuleList", "range", "range", "torch.ModuleList.append", "torch.ModuleList.append", "mmcv.cnn.ConvModule", "torch.Linear"], "methods", ["None"], ["", "", "def", "_add_conv_fc_branch", "(", "self", ",", "\n", "num_branch_convs", ",", "\n", "num_branch_fcs", ",", "\n", "in_channels", ",", "\n", "is_shared", "=", "False", ")", ":", "\n", "        ", "\"\"\"Add shared or separable branch.\n\n        convs -> avg pool (optional) -> fcs\n        \"\"\"", "\n", "last_layer_dim", "=", "in_channels", "\n", "# add branch specific conv layers", "\n", "branch_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "num_branch_convs", ">", "0", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_branch_convs", ")", ":", "\n", "                ", "conv_in_channels", "=", "(", "\n", "last_layer_dim", "if", "i", "==", "0", "else", "self", ".", "conv_out_channels", ")", "\n", "branch_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "conv_in_channels", ",", "\n", "self", ".", "conv_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "last_layer_dim", "=", "self", ".", "conv_out_channels", "\n", "# add branch specific fc layers", "\n", "", "branch_fcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "num_branch_fcs", ">", "0", ":", "\n", "# for shared branch, only consider self.with_avg_pool", "\n", "# for separated branches, also consider self.num_shared_fcs", "\n", "            ", "if", "(", "is_shared", "\n", "or", "self", ".", "num_shared_fcs", "==", "0", ")", "and", "not", "self", ".", "with_avg_pool", ":", "\n", "                ", "last_layer_dim", "*=", "self", ".", "roi_feat_area", "\n", "", "for", "i", "in", "range", "(", "num_branch_fcs", ")", ":", "\n", "                ", "fc_in_channels", "=", "(", "\n", "last_layer_dim", "if", "i", "==", "0", "else", "self", ".", "fc_out_channels", ")", "\n", "branch_fcs", ".", "append", "(", "\n", "nn", ".", "Linear", "(", "fc_in_channels", ",", "self", ".", "fc_out_channels", ")", ")", "\n", "", "last_layer_dim", "=", "self", ".", "fc_out_channels", "\n", "", "return", "branch_convs", ",", "branch_fcs", ",", "last_layer_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead.init_weights": [[126, 134], ["super().init_weights", "module_list.modules", "isinstance", "torch.init.xavier_uniform_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "super", "(", "ConvFCBBoxHead", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "# conv layers are already initialized by ConvModule", "\n", "for", "module_list", "in", "[", "self", ".", "shared_fcs", ",", "self", ".", "cls_fcs", ",", "self", ".", "reg_fcs", "]", ":", "\n", "            ", "for", "m", "in", "module_list", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.ConvFCBBoxHead.forward": [[135, 174], ["convfc_bbox_head.ConvFCBBoxHead.flatten", "conv", "convfc_bbox_head.ConvFCBBoxHead.dim", "convfc_bbox_head.ConvFCBBoxHead.flatten", "convfc_bbox_head.ConvFCBBoxHead.relu", "conv", "convfc_bbox_head.ConvFCBBoxHead.dim", "convfc_bbox_head.ConvFCBBoxHead.flatten", "convfc_bbox_head.ConvFCBBoxHead.relu", "convfc_bbox_head.ConvFCBBoxHead.fc_cls", "convfc_bbox_head.ConvFCBBoxHead.fc_reg", "conv", "convfc_bbox_head.ConvFCBBoxHead.avg_pool", "convfc_bbox_head.ConvFCBBoxHead.relu", "convfc_bbox_head.ConvFCBBoxHead.avg_pool", "fc", "convfc_bbox_head.ConvFCBBoxHead.avg_pool", "fc", "fc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# shared part", "\n", "        ", "if", "self", ".", "num_shared_convs", ">", "0", ":", "\n", "            ", "for", "conv", "in", "self", ".", "shared_convs", ":", "\n", "                ", "x", "=", "conv", "(", "x", ")", "\n", "\n", "", "", "if", "self", ".", "num_shared_fcs", ">", "0", ":", "\n", "            ", "if", "self", ".", "with_avg_pool", ":", "\n", "                ", "x", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "\n", "", "x", "=", "x", ".", "flatten", "(", "1", ")", "\n", "\n", "for", "fc", "in", "self", ".", "shared_fcs", ":", "\n", "                ", "x", "=", "self", ".", "relu", "(", "fc", "(", "x", ")", ")", "\n", "# separate branches", "\n", "", "", "x_cls", "=", "x", "\n", "x_reg", "=", "x", "\n", "\n", "for", "conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "x_cls", "=", "conv", "(", "x_cls", ")", "\n", "", "if", "x_cls", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "if", "self", ".", "with_avg_pool", ":", "\n", "                ", "x_cls", "=", "self", ".", "avg_pool", "(", "x_cls", ")", "\n", "", "x_cls", "=", "x_cls", ".", "flatten", "(", "1", ")", "\n", "", "for", "fc", "in", "self", ".", "cls_fcs", ":", "\n", "            ", "x_cls", "=", "self", ".", "relu", "(", "fc", "(", "x_cls", ")", ")", "\n", "\n", "", "for", "conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "x_reg", "=", "conv", "(", "x_reg", ")", "\n", "", "if", "x_reg", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "if", "self", ".", "with_avg_pool", ":", "\n", "                ", "x_reg", "=", "self", ".", "avg_pool", "(", "x_reg", ")", "\n", "", "x_reg", "=", "x_reg", ".", "flatten", "(", "1", ")", "\n", "", "for", "fc", "in", "self", ".", "reg_fcs", ":", "\n", "            ", "x_reg", "=", "self", ".", "relu", "(", "fc", "(", "x_reg", ")", ")", "\n", "\n", "", "cls_score", "=", "self", ".", "fc_cls", "(", "x_cls", ")", "if", "self", ".", "with_cls", "else", "None", "\n", "bbox_pred", "=", "self", ".", "fc_reg", "(", "x_reg", ")", "if", "self", ".", "with_reg", "else", "None", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.Shared2FCBBoxHead.__init__": [[179, 190], ["convfc_bbox_head.ConvFCBBoxHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "fc_out_channels", "=", "1024", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Shared2FCBBoxHead", ",", "self", ")", ".", "__init__", "(", "\n", "num_shared_convs", "=", "0", ",", "\n", "num_shared_fcs", "=", "2", ",", "\n", "num_cls_convs", "=", "0", ",", "\n", "num_cls_fcs", "=", "0", ",", "\n", "num_reg_convs", "=", "0", ",", "\n", "num_reg_fcs", "=", "0", ",", "\n", "fc_out_channels", "=", "fc_out_channels", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.convfc_bbox_head.Shared4Conv1FCBBoxHead.__init__": [[195, 206], ["convfc_bbox_head.ConvFCBBoxHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "fc_out_channels", "=", "1024", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Shared4Conv1FCBBoxHead", ",", "self", ")", ".", "__init__", "(", "\n", "num_shared_convs", "=", "4", ",", "\n", "num_shared_fcs", "=", "1", ",", "\n", "num_cls_convs", "=", "0", ",", "\n", "num_cls_fcs", "=", "0", ",", "\n", "num_reg_convs", "=", "0", ",", "\n", "num_reg_fcs", "=", "0", ",", "\n", "fc_out_channels", "=", "fc_out_channels", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.__init__": [[17, 65], ["dict", "dict", "dict", "torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "mmdet.core.build_bbox_coder", "mmdet.models.builder.build_loss", "mmdet.models.builder.build_loss", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "with_avg_pool", "=", "False", ",", "\n", "with_cls", "=", "True", ",", "\n", "with_reg", "=", "True", ",", "\n", "roi_feat_size", "=", "7", ",", "\n", "in_channels", "=", "256", ",", "\n", "num_classes", "=", "80", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", "0.", ",", "0.", ",", "0.", ",", "0.", "]", ",", "\n", "target_stds", "=", "[", "0.1", ",", "0.1", ",", "0.2", ",", "0.2", "]", ")", ",", "\n", "reg_class_agnostic", "=", "False", ",", "\n", "reg_decoded_bbox", "=", "False", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "False", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "\n", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", ",", "loss_weight", "=", "1.0", ")", ")", ":", "\n", "        ", "super", "(", "BBoxHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "with_cls", "or", "with_reg", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "self", ".", "with_cls", "=", "with_cls", "\n", "self", ".", "with_reg", "=", "with_reg", "\n", "self", ".", "roi_feat_size", "=", "_pair", "(", "roi_feat_size", ")", "\n", "self", ".", "roi_feat_area", "=", "self", ".", "roi_feat_size", "[", "0", "]", "*", "self", ".", "roi_feat_size", "[", "1", "]", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "reg_class_agnostic", "=", "reg_class_agnostic", "\n", "self", ".", "reg_decoded_bbox", "=", "reg_decoded_bbox", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "bbox_coder", "=", "build_bbox_coder", "(", "bbox_coder", ")", "\n", "self", ".", "loss_cls", "=", "build_loss", "(", "loss_cls", ")", "\n", "self", ".", "loss_bbox", "=", "build_loss", "(", "loss_bbox", ")", "\n", "\n", "in_channels", "=", "self", ".", "in_channels", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "self", ".", "avg_pool", "=", "nn", ".", "AvgPool2d", "(", "self", ".", "roi_feat_size", ")", "\n", "", "else", ":", "\n", "            ", "in_channels", "*=", "self", ".", "roi_feat_area", "\n", "", "if", "self", ".", "with_cls", ":", "\n", "# need to add background class", "\n", "            ", "self", ".", "fc_cls", "=", "nn", ".", "Linear", "(", "in_channels", ",", "num_classes", "+", "1", ")", "\n", "", "if", "self", ".", "with_reg", ":", "\n", "            ", "out_dim_reg", "=", "4", "if", "reg_class_agnostic", "else", "4", "*", "num_classes", "\n", "self", ".", "fc_reg", "=", "nn", ".", "Linear", "(", "in_channels", ",", "out_dim_reg", ")", "\n", "", "self", ".", "debug_imgs", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.init_weights": [[66, 74], ["torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "# conv layers are already initialized by ConvModule", "\n", "        ", "if", "self", ".", "with_cls", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "fc_cls", ".", "weight", ",", "0", ",", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "fc_cls", ".", "bias", ",", "0", ")", "\n", "", "if", "self", ".", "with_reg", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "fc_reg", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "fc_reg", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.forward": [[75, 83], ["mmdet.core.auto_fp16", "bbox_head.BBoxHead.view", "bbox_head.BBoxHead.avg_pool", "bbox_head.BBoxHead.size", "bbox_head.BBoxHead.fc_cls", "bbox_head.BBoxHead.fc_reg"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "cls_score", "=", "self", ".", "fc_cls", "(", "x", ")", "if", "self", ".", "with_cls", "else", "None", "\n", "bbox_pred", "=", "self", ".", "fc_reg", "(", "x", ")", "if", "self", ".", "with_reg", "else", "None", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead._get_target_single": [[84, 114], ["pos_bboxes.size", "neg_bboxes.size", "pos_bboxes.new_full", "pos_bboxes.new_zeros", "pos_bboxes.new_zeros", "pos_bboxes.new_zeros", "bbox_head.BBoxHead.bbox_coder.encode"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "_get_target_single", "(", "self", ",", "pos_bboxes", ",", "neg_bboxes", ",", "pos_gt_bboxes", ",", "\n", "pos_gt_labels", ",", "cfg", ")", ":", "\n", "        ", "num_pos", "=", "pos_bboxes", ".", "size", "(", "0", ")", "\n", "num_neg", "=", "neg_bboxes", ".", "size", "(", "0", ")", "\n", "num_samples", "=", "num_pos", "+", "num_neg", "\n", "\n", "# original implementation uses new_zeros since BG are set to be 0", "\n", "# now use empty & fill because BG cat_id = num_classes,", "\n", "# FG cat_id = [0, num_classes-1]", "\n", "labels", "=", "pos_bboxes", ".", "new_full", "(", "(", "num_samples", ",", ")", ",", "\n", "self", ".", "num_classes", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "pos_bboxes", ".", "new_zeros", "(", "num_samples", ")", "\n", "bbox_targets", "=", "pos_bboxes", ".", "new_zeros", "(", "num_samples", ",", "4", ")", "\n", "bbox_weights", "=", "pos_bboxes", ".", "new_zeros", "(", "num_samples", ",", "4", ")", "\n", "if", "num_pos", ">", "0", ":", "\n", "            ", "labels", "[", ":", "num_pos", "]", "=", "pos_gt_labels", "\n", "pos_weight", "=", "1.0", "if", "cfg", ".", "pos_weight", "<=", "0", "else", "cfg", ".", "pos_weight", "\n", "label_weights", "[", ":", "num_pos", "]", "=", "pos_weight", "\n", "if", "not", "self", ".", "reg_decoded_bbox", ":", "\n", "                ", "pos_bbox_targets", "=", "self", ".", "bbox_coder", ".", "encode", "(", "\n", "pos_bboxes", ",", "pos_gt_bboxes", ")", "\n", "", "else", ":", "\n", "                ", "pos_bbox_targets", "=", "pos_gt_bboxes", "\n", "", "bbox_targets", "[", ":", "num_pos", ",", ":", "]", "=", "pos_bbox_targets", "\n", "bbox_weights", "[", ":", "num_pos", ",", ":", "]", "=", "1", "\n", "", "if", "num_neg", ">", "0", ":", "\n", "            ", "label_weights", "[", "-", "num_neg", ":", "]", "=", "1.0", "\n", "\n", "", "return", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.get_targets": [[115, 139], ["mmdet.core.multi_apply", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "get_targets", "(", "self", ",", "\n", "sampling_results", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "rcnn_train_cfg", ",", "\n", "concat", "=", "True", ")", ":", "\n", "        ", "pos_bboxes_list", "=", "[", "res", ".", "pos_bboxes", "for", "res", "in", "sampling_results", "]", "\n", "neg_bboxes_list", "=", "[", "res", ".", "neg_bboxes", "for", "res", "in", "sampling_results", "]", "\n", "pos_gt_bboxes_list", "=", "[", "res", ".", "pos_gt_bboxes", "for", "res", "in", "sampling_results", "]", "\n", "pos_gt_labels_list", "=", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", "\n", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "=", "multi_apply", "(", "\n", "self", ".", "_get_target_single", ",", "\n", "pos_bboxes_list", ",", "\n", "neg_bboxes_list", ",", "\n", "pos_gt_bboxes_list", ",", "\n", "pos_gt_labels_list", ",", "\n", "cfg", "=", "rcnn_train_cfg", ")", "\n", "\n", "if", "concat", ":", "\n", "            ", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "0", ")", "\n", "label_weights", "=", "torch", ".", "cat", "(", "label_weights", ",", "0", ")", "\n", "bbox_targets", "=", "torch", ".", "cat", "(", "bbox_targets", ",", "0", ")", "\n", "bbox_weights", "=", "torch", ".", "cat", "(", "bbox_weights", ",", "0", ")", "\n", "", "return", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.loss": [[140, 186], ["mmdet.core.force_fp32", "dict", "max", "pos_inds.any", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "torch.sum().float().item", "cls_score.numel", "bbox_head.BBoxHead.loss_cls", "mmdet.models.losses.accuracy", "bbox_head.BBoxHead.loss_bbox", "bbox_head.BBoxHead.bbox_coder.decode", "bbox_head.BBoxHead.sum", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "bbox_head.BBoxHead.view", "bbox_head.BBoxHead.view", "bbox_targets.size", "bbox_head.BBoxHead.size", "pos_inds.type", "bbox_head.BBoxHead.size", "pos_inds.type", "pos_inds.type", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "pos_inds.type", "pos_inds.type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.accuracy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_score'", ",", "'bbox_pred'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_score", ",", "\n", "bbox_pred", ",", "\n", "rois", ",", "\n", "labels", ",", "\n", "label_weights", ",", "\n", "bbox_targets", ",", "\n", "bbox_weights", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "losses", "=", "dict", "(", ")", "\n", "if", "cls_score", "is", "not", "None", ":", "\n", "            ", "avg_factor", "=", "max", "(", "torch", ".", "sum", "(", "label_weights", ">", "0", ")", ".", "float", "(", ")", ".", "item", "(", ")", ",", "1.", ")", "\n", "if", "cls_score", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "losses", "[", "'loss_cls'", "]", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "\n", "labels", ",", "\n", "label_weights", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "reduction_override", "=", "reduction_override", ")", "\n", "losses", "[", "'acc'", "]", "=", "accuracy", "(", "cls_score", ",", "labels", ")", "\n", "", "", "if", "bbox_pred", "is", "not", "None", ":", "\n", "            ", "bg_class_ind", "=", "self", ".", "num_classes", "\n", "# 0~self.num_classes-1 are FG, self.num_classes is BG", "\n", "pos_inds", "=", "(", "labels", ">=", "0", ")", "&", "(", "labels", "<", "bg_class_ind", ")", "\n", "# do not perform bounding box regression for BG anymore.", "\n", "if", "pos_inds", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "reg_decoded_bbox", ":", "\n", "                    ", "bbox_pred", "=", "self", ".", "bbox_coder", ".", "decode", "(", "rois", "[", ":", ",", "1", ":", "]", ",", "bbox_pred", ")", "\n", "", "if", "self", ".", "reg_class_agnostic", ":", "\n", "                    ", "pos_bbox_pred", "=", "bbox_pred", ".", "view", "(", "\n", "bbox_pred", ".", "size", "(", "0", ")", ",", "4", ")", "[", "pos_inds", ".", "type", "(", "torch", ".", "bool", ")", "]", "\n", "", "else", ":", "\n", "                    ", "pos_bbox_pred", "=", "bbox_pred", ".", "view", "(", "\n", "bbox_pred", ".", "size", "(", "0", ")", ",", "-", "1", ",", "\n", "4", ")", "[", "pos_inds", ".", "type", "(", "torch", ".", "bool", ")", ",", "\n", "labels", "[", "pos_inds", ".", "type", "(", "torch", ".", "bool", ")", "]", "]", "\n", "", "losses", "[", "'loss_bbox'", "]", "=", "self", ".", "loss_bbox", "(", "\n", "pos_bbox_pred", ",", "\n", "bbox_targets", "[", "pos_inds", ".", "type", "(", "torch", ".", "bool", ")", "]", ",", "\n", "bbox_weights", "[", "pos_inds", ".", "type", "(", "torch", ".", "bool", ")", "]", ",", "\n", "avg_factor", "=", "bbox_targets", ".", "size", "(", "0", ")", ",", "\n", "reduction_override", "=", "reduction_override", ")", "\n", "", "else", ":", "\n", "                ", "losses", "[", "'loss_bbox'", "]", "=", "bbox_pred", ".", "sum", "(", ")", "*", "0", "\n", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.get_bboxes": [[187, 225], ["mmdet.core.force_fp32", "isinstance", "torch.softmax", "torch.softmax", "torch.softmax", "bbox_head.BBoxHead.bbox_coder.decode", "rois[].clone", "isinstance", "mmdet.core.multiclass_nms", "sum", "float", "bboxes[].clamp_", "bboxes[].clamp_", "rois[].clone.size", "rois[].clone.new_tensor", "len", "rois[].clone.size", "rois[].clone.view", "rois[].clone.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_score'", ",", "'bbox_pred'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "rois", ",", "\n", "cls_score", ",", "\n", "bbox_pred", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "rescale", "=", "False", ",", "\n", "cfg", "=", "None", ")", ":", "\n", "        ", "if", "isinstance", "(", "cls_score", ",", "list", ")", ":", "\n", "            ", "cls_score", "=", "sum", "(", "cls_score", ")", "/", "float", "(", "len", "(", "cls_score", ")", ")", "\n", "", "scores", "=", "F", ".", "softmax", "(", "cls_score", ",", "dim", "=", "1", ")", "if", "cls_score", "is", "not", "None", "else", "None", "\n", "\n", "if", "bbox_pred", "is", "not", "None", ":", "\n", "            ", "bboxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "rois", "[", ":", ",", "1", ":", "]", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "", "else", ":", "\n", "            ", "bboxes", "=", "rois", "[", ":", ",", "1", ":", "]", ".", "clone", "(", ")", "\n", "if", "img_shape", "is", "not", "None", ":", "\n", "                ", "bboxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "1", "]", ")", "\n", "bboxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "0", "]", ")", "\n", "\n", "", "", "if", "rescale", "and", "bboxes", ".", "size", "(", "0", ")", ">", "0", ":", "\n", "            ", "if", "isinstance", "(", "scale_factor", ",", "float", ")", ":", "\n", "                ", "bboxes", "/=", "scale_factor", "\n", "", "else", ":", "\n", "                ", "scale_factor", "=", "bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "bboxes", "=", "(", "bboxes", ".", "view", "(", "bboxes", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "/", "\n", "scale_factor", ")", ".", "view", "(", "bboxes", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "", "", "if", "cfg", "is", "None", ":", "\n", "            ", "return", "bboxes", ",", "scores", "\n", "", "else", ":", "\n", "            ", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "bboxes", ",", "scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.refine_bboxes": [[226, 304], ["mmdet.core.force_fp32", "rois[].long().unique", "range", "rois[].long().unique.numel", "len", "len", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze.numel", "torch.nonzero().squeeze.numel", "torch.nonzero().squeeze.numel", "bbox_head.BBoxHead.regress_by_class", "pos_is_gts_.new_ones", "bboxes_list.append", "rois[].long", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "len", "pos_is_gts_.new_ones.type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class"], ["", "", "@", "force_fp32", "(", "apply_to", "=", "(", "'bbox_preds'", ",", ")", ")", "\n", "def", "refine_bboxes", "(", "self", ",", "rois", ",", "labels", ",", "bbox_preds", ",", "pos_is_gts", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Refine bboxes during training.\n\n        Args:\n            rois (Tensor): Shape (n*bs, 5), where n is image number per GPU,\n                and bs is the sampled RoIs per image. The first column is\n                the image id and the next 4 columns are x1, y1, x2, y2.\n            labels (Tensor): Shape (n*bs, ).\n            bbox_preds (Tensor): Shape (n*bs, 4) or (n*bs, 4*#class).\n            pos_is_gts (list[Tensor]): Flags indicating if each positive bbox\n                is a gt bbox.\n            img_metas (list[dict]): Meta info of each image.\n\n        Returns:\n            list[Tensor]: Refined bboxes of each image in a mini-batch.\n\n        Example:\n            >>> # xdoctest: +REQUIRES(module:kwarray)\n            >>> import kwarray\n            >>> import numpy as np\n            >>> from mmdet.core.bbox.demodata import random_boxes\n            >>> self = BBoxHead(reg_class_agnostic=True)\n            >>> n_roi = 2\n            >>> n_img = 4\n            >>> scale = 512\n            >>> rng = np.random.RandomState(0)\n            >>> img_metas = [{'img_shape': (scale, scale)}\n            ...              for _ in range(n_img)]\n            >>> # Create rois in the expected format\n            >>> roi_boxes = random_boxes(n_roi, scale=scale, rng=rng)\n            >>> img_ids = torch.randint(0, n_img, (n_roi,))\n            >>> img_ids = img_ids.float()\n            >>> rois = torch.cat([img_ids[:, None], roi_boxes], dim=1)\n            >>> # Create other args\n            >>> labels = torch.randint(0, 2, (n_roi,)).long()\n            >>> bbox_preds = random_boxes(n_roi, scale=scale, rng=rng)\n            >>> # For each image, pretend random positive boxes are gts\n            >>> is_label_pos = (labels.numpy() > 0).astype(np.int)\n            >>> lbl_per_img = kwarray.group_items(is_label_pos,\n            ...                                   img_ids.numpy())\n            >>> pos_per_img = [sum(lbl_per_img.get(gid, []))\n            ...                for gid in range(n_img)]\n            >>> pos_is_gts = [\n            >>>     torch.randint(0, 2, (npos,)).byte().sort(\n            >>>         descending=True)[0]\n            >>>     for npos in pos_per_img\n            >>> ]\n            >>> bboxes_list = self.refine_bboxes(rois, labels, bbox_preds,\n            >>>                    pos_is_gts, img_metas)\n            >>> print(bboxes_list)\n        \"\"\"", "\n", "img_ids", "=", "rois", "[", ":", ",", "0", "]", ".", "long", "(", ")", ".", "unique", "(", "sorted", "=", "True", ")", "\n", "assert", "img_ids", ".", "numel", "(", ")", "<=", "len", "(", "img_metas", ")", "\n", "\n", "bboxes_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "inds", "=", "torch", ".", "nonzero", "(", "\n", "rois", "[", ":", ",", "0", "]", "==", "i", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "num_rois", "=", "inds", ".", "numel", "(", ")", "\n", "\n", "bboxes_", "=", "rois", "[", "inds", ",", "1", ":", "]", "\n", "label_", "=", "labels", "[", "inds", "]", "\n", "bbox_pred_", "=", "bbox_preds", "[", "inds", "]", "\n", "img_meta_", "=", "img_metas", "[", "i", "]", "\n", "pos_is_gts_", "=", "pos_is_gts", "[", "i", "]", "\n", "\n", "bboxes", "=", "self", ".", "regress_by_class", "(", "bboxes_", ",", "label_", ",", "bbox_pred_", ",", "\n", "img_meta_", ")", "\n", "\n", "# filter gt bboxes", "\n", "pos_keep", "=", "1", "-", "pos_is_gts_", "\n", "keep_inds", "=", "pos_is_gts_", ".", "new_ones", "(", "num_rois", ")", "\n", "keep_inds", "[", ":", "len", "(", "pos_is_gts_", ")", "]", "=", "pos_keep", "\n", "\n", "bboxes_list", ".", "append", "(", "bboxes", "[", "keep_inds", ".", "type", "(", "torch", ".", "bool", ")", "]", ")", "\n", "\n", "", "return", "bboxes_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.regress_by_class": [[305, 335], ["mmdet.core.force_fp32", "repr", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather.size", "torch.gather.size", "torch.gather.size", "rois.size", "bbox_head.BBoxHead.bbox_coder.decode", "bbox_head.BBoxHead.bbox_coder.decode", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "rois.size", "rois.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'bbox_pred'", ",", ")", ")", "\n", "def", "regress_by_class", "(", "self", ",", "rois", ",", "label", ",", "bbox_pred", ",", "img_meta", ")", ":", "\n", "        ", "\"\"\"Regress the bbox for the predicted class. Used in Cascade R-CNN.\n\n        Args:\n            rois (Tensor): shape (n, 4) or (n, 5)\n            label (Tensor): shape (n, )\n            bbox_pred (Tensor): shape (n, 4*(#class)) or (n, 4)\n            img_meta (dict): Image meta info.\n\n        Returns:\n            Tensor: Regressed bboxes, the same shape as input rois.\n        \"\"\"", "\n", "assert", "rois", ".", "size", "(", "1", ")", "==", "4", "or", "rois", ".", "size", "(", "1", ")", "==", "5", ",", "repr", "(", "rois", ".", "shape", ")", "\n", "\n", "if", "not", "self", ".", "reg_class_agnostic", ":", "\n", "            ", "label", "=", "label", "*", "4", "\n", "inds", "=", "torch", ".", "stack", "(", "(", "label", ",", "label", "+", "1", ",", "label", "+", "2", ",", "label", "+", "3", ")", ",", "1", ")", "\n", "bbox_pred", "=", "torch", ".", "gather", "(", "bbox_pred", ",", "1", ",", "inds", ")", "\n", "", "assert", "bbox_pred", ".", "size", "(", "1", ")", "==", "4", "\n", "\n", "if", "rois", ".", "size", "(", "1", ")", "==", "4", ":", "\n", "            ", "new_rois", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "rois", ",", "bbox_pred", ",", "max_shape", "=", "img_meta", "[", "'img_shape'", "]", ")", "\n", "", "else", ":", "\n", "            ", "bboxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "rois", "[", ":", ",", "1", ":", "]", ",", "bbox_pred", ",", "max_shape", "=", "img_meta", "[", "'img_shape'", "]", ")", "\n", "new_rois", "=", "torch", ".", "cat", "(", "(", "rois", "[", ":", ",", "[", "0", "]", "]", ",", "bboxes", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "return", "new_rois", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.BasicResBlock.__init__": [[22, 57], ["dict", "torch.Module.__init__", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", ":", "\n", "        ", "super", "(", "BasicResBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# main path", "\n", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "in_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "# identity path", "\n", "self", ".", "conv_identity", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.BasicResBlock.forward": [[58, 69], ["double_bbox_head.BasicResBlock.conv1", "double_bbox_head.BasicResBlock.conv2", "double_bbox_head.BasicResBlock.conv_identity", "double_bbox_head.BasicResBlock.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "\n", "identity", "=", "self", ".", "conv_identity", "(", "identity", ")", "\n", "out", "=", "x", "+", "identity", "\n", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead.__init__": [[86, 120], ["dict", "kwargs.setdefault", "bbox_head.BBoxHead.__init__", "double_bbox_head.BasicResBlock", "double_bbox_head.DoubleConvFCBBoxHead._add_conv_branch", "double_bbox_head.DoubleConvFCBBoxHead._add_fc_branch", "torch.Linear", "torch.Linear", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead._add_conv_branch", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead._add_fc_branch"], ["def", "__init__", "(", "self", ",", "\n", "num_convs", "=", "0", ",", "\n", "num_fcs", "=", "0", ",", "\n", "conv_out_channels", "=", "1024", ",", "\n", "fc_out_channels", "=", "1024", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'with_avg_pool'", ",", "True", ")", "\n", "super", "(", "DoubleConvFCBBoxHead", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "self", ".", "with_avg_pool", "\n", "assert", "num_convs", ">", "0", "\n", "assert", "num_fcs", ">", "0", "\n", "self", ".", "num_convs", "=", "num_convs", "\n", "self", ".", "num_fcs", "=", "num_fcs", "\n", "self", ".", "conv_out_channels", "=", "conv_out_channels", "\n", "self", ".", "fc_out_channels", "=", "fc_out_channels", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "\n", "# increase the channel of input features", "\n", "self", ".", "res_block", "=", "BasicResBlock", "(", "self", ".", "in_channels", ",", "\n", "self", ".", "conv_out_channels", ")", "\n", "\n", "# add conv heads", "\n", "self", ".", "conv_branch", "=", "self", ".", "_add_conv_branch", "(", ")", "\n", "# add fc heads", "\n", "self", ".", "fc_branch", "=", "self", ".", "_add_fc_branch", "(", ")", "\n", "\n", "out_dim_reg", "=", "4", "if", "self", ".", "reg_class_agnostic", "else", "4", "*", "self", ".", "num_classes", "\n", "self", ".", "fc_reg", "=", "nn", ".", "Linear", "(", "self", ".", "conv_out_channels", ",", "out_dim_reg", ")", "\n", "\n", "self", ".", "fc_cls", "=", "nn", ".", "Linear", "(", "self", ".", "fc_out_channels", ",", "self", ".", "num_classes", "+", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead._add_conv_branch": [[121, 132], ["torch.ModuleList", "range", "torch.ModuleList.append", "mmdet.models.backbones.resnet.Bottleneck"], "methods", ["None"], ["", "def", "_add_conv_branch", "(", "self", ")", ":", "\n", "        ", "\"\"\"Add the fc branch which consists of a sequential of conv layers.\"\"\"", "\n", "branch_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_convs", ")", ":", "\n", "            ", "branch_convs", ".", "append", "(", "\n", "Bottleneck", "(", "\n", "inplanes", "=", "self", ".", "conv_out_channels", ",", "\n", "planes", "=", "self", ".", "conv_out_channels", "//", "4", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "return", "branch_convs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead._add_fc_branch": [[133, 142], ["torch.ModuleList", "range", "torch.ModuleList.append", "torch.Linear"], "methods", ["None"], ["", "def", "_add_fc_branch", "(", "self", ")", ":", "\n", "        ", "\"\"\"Add the fc branch which consists of a sequential of fc layers.\"\"\"", "\n", "branch_fcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_fcs", ")", ":", "\n", "            ", "fc_in_channels", "=", "(", "\n", "self", ".", "in_channels", "*", "\n", "self", ".", "roi_feat_area", "if", "i", "==", "0", "else", "self", ".", "fc_out_channels", ")", "\n", "branch_fcs", ".", "append", "(", "nn", ".", "Linear", "(", "fc_in_channels", ",", "self", ".", "fc_out_channels", ")", ")", "\n", "", "return", "branch_fcs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead.init_weights": [[143, 151], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "double_bbox_head.DoubleConvFCBBoxHead.fc_branch.modules", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "# conv layers are already initialized by ConvModule", "\n", "        ", "normal_init", "(", "self", ".", "fc_cls", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "fc_reg", ",", "std", "=", "0.001", ")", "\n", "\n", "for", "m", "in", "self", ".", "fc_branch", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.double_bbox_head.DoubleConvFCBBoxHead.forward": [[152, 173], ["double_bbox_head.DoubleConvFCBBoxHead.res_block", "double_bbox_head.DoubleConvFCBBoxHead.view", "double_bbox_head.DoubleConvFCBBoxHead.fc_reg", "x_cls.view", "double_bbox_head.DoubleConvFCBBoxHead.fc_cls", "conv", "double_bbox_head.DoubleConvFCBBoxHead.avg_pool", "double_bbox_head.DoubleConvFCBBoxHead.size", "x_cls.size", "double_bbox_head.DoubleConvFCBBoxHead.relu", "fc"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x_cls", ",", "x_reg", ")", ":", "\n", "# conv head", "\n", "        ", "x_conv", "=", "self", ".", "res_block", "(", "x_reg", ")", "\n", "\n", "for", "conv", "in", "self", ".", "conv_branch", ":", "\n", "            ", "x_conv", "=", "conv", "(", "x_conv", ")", "\n", "\n", "", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x_conv", "=", "self", ".", "avg_pool", "(", "x_conv", ")", "\n", "\n", "", "x_conv", "=", "x_conv", ".", "view", "(", "x_conv", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "bbox_pred", "=", "self", ".", "fc_reg", "(", "x_conv", ")", "\n", "\n", "# fc head", "\n", "x_fc", "=", "x_cls", ".", "view", "(", "x_cls", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "for", "fc", "in", "self", ".", "fc_branch", ":", "\n", "            ", "x_fc", "=", "self", ".", "relu", "(", "fc", "(", "x_fc", ")", ")", "\n", "\n", "", "cls_score", "=", "self", ".", "fc_cls", "(", "x_fc", ")", "\n", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.__init__": [[17, 23], ["torch.Module.__init__", "base_roi_extractor.BaseRoIExtractor.build_roi_layers"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.build_roi_layers"], ["def", "__init__", "(", "self", ",", "roi_layer", ",", "out_channels", ",", "featmap_strides", ")", ":", "\n", "        ", "super", "(", "BaseRoIExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "roi_layers", "=", "self", ".", "build_roi_layers", "(", "roi_layer", ",", "featmap_strides", ")", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "featmap_strides", "=", "featmap_strides", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.num_inputs": [[24, 28], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_inputs", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: Number of input feature maps.\"\"\"", "\n", "return", "len", "(", "self", ".", "featmap_strides", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.init_weights": [[29, 31], ["None"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.build_roi_layers": [[32, 56], ["layer_cfg.copy", "layer_cfg.copy.pop", "hasattr", "getattr", "torch.ModuleList", "torch.ModuleList", "getattr."], "methods", ["None"], ["", "def", "build_roi_layers", "(", "self", ",", "layer_cfg", ",", "featmap_strides", ")", ":", "\n", "        ", "\"\"\"Build RoI operator to extract feature from each level feature map.\n\n        Args:\n            layer_cfg (dict): Dictionary to construct and config RoI layer\n                operation. Options are modules under ``mmcv/ops`` such as\n                ``RoIAlign``.\n            featmap_strides (int): The stride of input feature map w.r.t to the\n                original image size, which would be used to scale RoI\n                coordinate (original image coordinate system) to feature\n                coordinate system.\n\n        Returns:\n            nn.ModuleList: The RoI extractor modules for each level feature\n                map.\n        \"\"\"", "\n", "\n", "cfg", "=", "layer_cfg", ".", "copy", "(", ")", "\n", "layer_type", "=", "cfg", ".", "pop", "(", "'type'", ")", "\n", "assert", "hasattr", "(", "ops", ",", "layer_type", ")", "\n", "layer_cls", "=", "getattr", "(", "ops", ",", "layer_type", ")", "\n", "roi_layers", "=", "nn", ".", "ModuleList", "(", "\n", "[", "layer_cls", "(", "spatial_scale", "=", "1", "/", "s", ",", "**", "cfg", ")", "for", "s", "in", "featmap_strides", "]", ")", "\n", "return", "roi_layers", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.roi_rescale": [[57, 80], ["torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["", "def", "roi_rescale", "(", "self", ",", "rois", ",", "scale_factor", ")", ":", "\n", "        ", "\"\"\"Scale RoI coordinates by scale factor.\n\n        Args:\n            rois (torch.Tensor): RoI (Region of Interest), shape (n, 5)\n            scale_factor (float): Scale factor that RoI will be multiplied by.\n\n        Returns:\n            torch.Tensor: Scaled RoI.\n        \"\"\"", "\n", "\n", "cx", "=", "(", "rois", "[", ":", ",", "1", "]", "+", "rois", "[", ":", ",", "3", "]", ")", "*", "0.5", "\n", "cy", "=", "(", "rois", "[", ":", ",", "2", "]", "+", "rois", "[", ":", ",", "4", "]", ")", "*", "0.5", "\n", "w", "=", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", "\n", "h", "=", "rois", "[", ":", ",", "4", "]", "-", "rois", "[", ":", ",", "2", "]", "\n", "new_w", "=", "w", "*", "scale_factor", "\n", "new_h", "=", "h", "*", "scale_factor", "\n", "x1", "=", "cx", "-", "new_w", "*", "0.5", "\n", "x2", "=", "cx", "+", "new_w", "*", "0.5", "\n", "y1", "=", "cy", "-", "new_h", "*", "0.5", "\n", "y2", "=", "cy", "+", "new_h", "*", "0.5", "\n", "new_rois", "=", "torch", ".", "stack", "(", "(", "rois", "[", ":", ",", "0", "]", ",", "x1", ",", "y1", ",", "x2", ",", "y2", ")", ",", "dim", "=", "-", "1", ")", "\n", "return", "new_rois", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.forward": [[81, 84], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward", "(", "self", ",", "feats", ",", "rois", ",", "roi_scale_factor", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.single_level_roi_extractor.SingleRoIExtractor.__init__": [[23, 31], ["base_roi_extractor.BaseRoIExtractor.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "roi_layer", ",", "\n", "out_channels", ",", "\n", "featmap_strides", ",", "\n", "finest_scale", "=", "56", ")", ":", "\n", "        ", "super", "(", "SingleRoIExtractor", ",", "self", ")", ".", "__init__", "(", "roi_layer", ",", "out_channels", ",", "\n", "featmap_strides", ")", "\n", "self", ".", "finest_scale", "=", "finest_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.single_level_roi_extractor.SingleRoIExtractor.map_roi_levels": [[32, 52], ["torch.sqrt", "torch.floor", "target_lvls.clamp().long.clamp().long.clamp().long", "torch.log2", "target_lvls.clamp().long.clamp().long.clamp"], "methods", ["None"], ["", "def", "map_roi_levels", "(", "self", ",", "rois", ",", "num_levels", ")", ":", "\n", "        ", "\"\"\"Map rois to corresponding feature levels by scales.\n\n        - scale < finest_scale * 2: level 0\n        - finest_scale * 2 <= scale < finest_scale * 4: level 1\n        - finest_scale * 4 <= scale < finest_scale * 8: level 2\n        - scale >= finest_scale * 8: level 3\n\n        Args:\n            rois (Tensor): Input RoIs, shape (k, 5).\n            num_levels (int): Total level number.\n\n        Returns:\n            Tensor: Level index (0-based) of each RoI, shape (k, )\n        \"\"\"", "\n", "scale", "=", "torch", ".", "sqrt", "(", "\n", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", "*", "(", "rois", "[", ":", ",", "4", "]", "-", "rois", "[", ":", ",", "2", "]", ")", ")", "\n", "target_lvls", "=", "torch", ".", "floor", "(", "torch", ".", "log2", "(", "scale", "/", "self", ".", "finest_scale", "+", "1e-6", ")", ")", "\n", "target_lvls", "=", "target_lvls", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "num_levels", "-", "1", ")", ".", "long", "(", ")", "\n", "return", "target_lvls", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.single_level_roi_extractor.SingleRoIExtractor.forward": [[53, 81], ["mmdet.core.force_fp32", "len", "feats[].new_zeros", "single_level_roi_extractor.SingleRoIExtractor.map_roi_levels", "range", "single_level_roi_extractor.SingleRoIExtractor.size", "single_level_roi_extractor.SingleRoIExtractor.roi_rescale", "inds.any", "len", "sum", "x.view", "single_level_roi_extractor.SingleRoIExtractor.parameters"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.single_level_roi_extractor.SingleRoIExtractor.map_roi_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.roi_rescale"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'feats'", ",", ")", ",", "out_fp16", "=", "True", ")", "\n", "def", "forward", "(", "self", ",", "feats", ",", "rois", ",", "roi_scale_factor", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "out_size", "=", "self", ".", "roi_layers", "[", "0", "]", ".", "output_size", "\n", "num_levels", "=", "len", "(", "feats", ")", "\n", "roi_feats", "=", "feats", "[", "0", "]", ".", "new_zeros", "(", "\n", "rois", ".", "size", "(", "0", ")", ",", "self", ".", "out_channels", ",", "*", "out_size", ")", "\n", "# TODO: remove this when parrots supports", "\n", "if", "torch", ".", "__version__", "==", "'parrots'", ":", "\n", "            ", "roi_feats", ".", "requires_grad", "=", "True", "\n", "\n", "", "if", "num_levels", "==", "1", ":", "\n", "            ", "if", "len", "(", "rois", ")", "==", "0", ":", "\n", "                ", "return", "roi_feats", "\n", "", "return", "self", ".", "roi_layers", "[", "0", "]", "(", "feats", "[", "0", "]", ",", "rois", ")", "\n", "\n", "", "target_lvls", "=", "self", ".", "map_roi_levels", "(", "rois", ",", "num_levels", ")", "\n", "if", "roi_scale_factor", "is", "not", "None", ":", "\n", "            ", "rois", "=", "self", ".", "roi_rescale", "(", "rois", ",", "roi_scale_factor", ")", "\n", "", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "inds", "=", "target_lvls", "==", "i", "\n", "if", "inds", ".", "any", "(", ")", ":", "\n", "                ", "rois_", "=", "rois", "[", "inds", ",", ":", "]", "\n", "roi_feats_t", "=", "self", ".", "roi_layers", "[", "i", "]", "(", "feats", "[", "i", "]", ",", "rois_", ")", "\n", "roi_feats", "[", "inds", "]", "=", "roi_feats_t", "\n", "", "else", ":", "\n", "                ", "roi_feats", "+=", "sum", "(", "x", ".", "view", "(", "-", "1", ")", "[", "0", "]", "for", "x", "in", "self", ".", "parameters", "(", ")", ")", "*", "0.", "\n", "", "", "return", "roi_feats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.generic_roi_extractor.GenericRoIExtractor.__init__": [[24, 41], ["base_roi_extractor.BaseRoIExtractor.__init__", "mmcv.cnn.bricks.build_plugin_layer", "mmcv.cnn.bricks.build_plugin_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "aggregation", "=", "'sum'", ",", "\n", "pre_cfg", "=", "None", ",", "\n", "post_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "GenericRoIExtractor", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "assert", "aggregation", "in", "[", "'sum'", ",", "'concat'", "]", "\n", "\n", "self", ".", "aggregation", "=", "aggregation", "\n", "self", ".", "with_post", "=", "post_cfg", "is", "not", "None", "\n", "self", ".", "with_pre", "=", "pre_cfg", "is", "not", "None", "\n", "# build pre/post processing modules", "\n", "if", "self", ".", "with_post", ":", "\n", "            ", "self", ".", "post_module", "=", "build_plugin_layer", "(", "post_cfg", ",", "'_post_module'", ")", "[", "1", "]", "\n", "", "if", "self", ".", "with_pre", ":", "\n", "            ", "self", ".", "pre_module", "=", "build_plugin_layer", "(", "pre_cfg", ",", "'_pre_module'", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.generic_roi_extractor.GenericRoIExtractor.forward": [[42, 84], ["mmdet.core.force_fp32", "len", "feats[].new_zeros", "range", "len", "generic_roi_extractor.GenericRoIExtractor.size", "generic_roi_extractor.GenericRoIExtractor.roi_rescale", "generic_roi_extractor.GenericRoIExtractor.post_module", "generic_roi_extractor.GenericRoIExtractor.size", "generic_roi_extractor.GenericRoIExtractor.pre_module"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.roi_extractors.base_roi_extractor.BaseRoIExtractor.roi_rescale"], ["", "", "@", "force_fp32", "(", "apply_to", "=", "(", "'feats'", ",", ")", ",", "out_fp16", "=", "True", ")", "\n", "def", "forward", "(", "self", ",", "feats", ",", "rois", ",", "roi_scale_factor", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "if", "len", "(", "feats", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "roi_layers", "[", "0", "]", "(", "feats", "[", "0", "]", ",", "rois", ")", "\n", "\n", "", "out_size", "=", "self", ".", "roi_layers", "[", "0", "]", ".", "output_size", "\n", "num_levels", "=", "len", "(", "feats", ")", "\n", "roi_feats", "=", "feats", "[", "0", "]", ".", "new_zeros", "(", "\n", "rois", ".", "size", "(", "0", ")", ",", "self", ".", "out_channels", ",", "*", "out_size", ")", "\n", "\n", "# some times rois is an empty tensor", "\n", "if", "roi_feats", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "roi_feats", "\n", "\n", "", "if", "roi_scale_factor", "is", "not", "None", ":", "\n", "            ", "rois", "=", "self", ".", "roi_rescale", "(", "rois", ",", "roi_scale_factor", ")", "\n", "\n", "# mark the starting channels for concat mode", "\n", "", "start_channels", "=", "0", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "roi_feats_t", "=", "self", ".", "roi_layers", "[", "i", "]", "(", "feats", "[", "i", "]", ",", "rois", ")", "\n", "end_channels", "=", "start_channels", "+", "roi_feats_t", ".", "size", "(", "1", ")", "\n", "if", "self", ".", "with_pre", ":", "\n", "# apply pre-processing to a RoI extracted from each layer", "\n", "                ", "roi_feats_t", "=", "self", ".", "pre_module", "(", "roi_feats_t", ")", "\n", "", "if", "self", ".", "aggregation", "==", "'sum'", ":", "\n", "# and sum them all", "\n", "                ", "roi_feats", "+=", "roi_feats_t", "\n", "", "else", ":", "\n", "# and concat them along channel dimension", "\n", "                ", "roi_feats", "[", ":", ",", "start_channels", ":", "end_channels", "]", "=", "roi_feats_t", "\n", "# update channels starting position", "\n", "", "start_channels", "=", "end_channels", "\n", "# check if concat channels match at the end", "\n", "", "if", "self", ".", "aggregation", "==", "'concat'", ":", "\n", "            ", "assert", "start_channels", "==", "self", ".", "out_channels", "\n", "\n", "", "if", "self", ".", "with_post", ":", "\n", "# apply post-processing before return the result", "\n", "            ", "roi_feats", "=", "self", ".", "post_module", "(", "roi_feats", ")", "\n", "", "return", "roi_feats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_retina_head.GARetinaHead.__init__": [[13, 24], ["guided_anchor_head.GuidedAnchorHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "super", "(", "GARetinaHead", ",", "self", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_retina_head.GARetinaHead._init_layers": [[25, 71], ["torch.ReLU", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv2d", "torch.Conv2d", "guided_anchor_head.FeatureAdaption", "guided_anchor_head.FeatureAdaption", "mmcv.ops.MaskedConv2d", "mmcv.ops.MaskedConv2d", "ga_retina_head.GARetinaHead.cls_convs.append", "ga_retina_head.GARetinaHead.reg_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "\n", "", "self", ".", "conv_loc", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_shape", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "2", ",", "\n", "1", ")", "\n", "self", ".", "feature_adaption_cls", "=", "FeatureAdaption", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "self", ".", "deform_groups", ")", "\n", "self", ".", "feature_adaption_reg", "=", "FeatureAdaption", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "self", ".", "deform_groups", ")", "\n", "self", ".", "retina_cls", "=", "MaskedConv2d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "retina_reg", "=", "MaskedConv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_retina_head.GARetinaHead.init_weights": [[72, 87], ["ga_retina_head.GARetinaHead.feature_adaption_cls.init_weights", "ga_retina_head.GARetinaHead.feature_adaption_reg.init_weights", "mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the layer.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "\n", "", "self", ".", "feature_adaption_cls", ".", "init_weights", "(", ")", "\n", "self", ".", "feature_adaption_reg", ".", "init_weights", "(", ")", "\n", "\n", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_loc", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "conv_shape", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "retina_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_retina_head.GARetinaHead.forward_single": [[88, 110], ["ga_retina_head.GARetinaHead.conv_loc", "ga_retina_head.GARetinaHead.conv_shape", "ga_retina_head.GARetinaHead.feature_adaption_cls", "ga_retina_head.GARetinaHead.feature_adaption_reg", "ga_retina_head.GARetinaHead.retina_cls", "ga_retina_head.GARetinaHead.retina_reg", "cls_conv", "reg_conv", "ga_retina_head.GARetinaHead.sigmoid"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature map of a single scale level.\"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "\n", "", "loc_pred", "=", "self", ".", "conv_loc", "(", "cls_feat", ")", "\n", "shape_pred", "=", "self", ".", "conv_shape", "(", "reg_feat", ")", "\n", "\n", "cls_feat", "=", "self", ".", "feature_adaption_cls", "(", "cls_feat", ",", "shape_pred", ")", "\n", "reg_feat", "=", "self", ".", "feature_adaption_reg", "(", "reg_feat", ",", "shape_pred", ")", "\n", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "mask", "=", "loc_pred", ".", "sigmoid", "(", ")", "[", "0", "]", ">=", "self", ".", "loc_filter_thr", "\n", "", "else", ":", "\n", "            ", "mask", "=", "None", "\n", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ",", "mask", ")", "\n", "bbox_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ",", "mask", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "shape_pred", ",", "loc_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.pisa_retinanet_head.PISARetinaHead.loss": [[20, 154], ["mmdet.core.force_fp32", "pisa_retinanet_head.PISARetinaHead.get_anchors", "pisa_retinanet_head.PISARetinaHead.get_targets", "range", "mmdet.core.images_to_levels", "len", "torch.cat().reshape", "torch.cat().view", "torch.cat().reshape", "torch.cat().reshape", "torch.cat().reshape", "torch.cat().reshape", "torch.cat().reshape", "pisa_retinanet_head.PISARetinaHead.train_cfg.get", "pisa_retinanet_head.PISARetinaHead.loss_cls", "pisa_retinanet_head.PISARetinaHead.loss_bbox", "dict", "pisa_retinanet_head.PISARetinaHead.train_cfg.get", "len", "anchors.size", "len", "concat_anchor_list.append", "cls_score.permute().reshape", "flatten_cls_scores[].size", "bbox_pred.permute().reshape", "flatten_bbox_preds[].size", "losses.carl_loss", "dict.update", "featmap.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.no_grad", "losses.isr_p", "cls_score.permute", "bbox_pred.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.carl_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.isr_p"], ["@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): Ground truth bboxes of each image\n                with shape (num_obj, 4).\n            gt_labels (list[Tensor]): Ground truth labels of each image\n                with shape (num_obj, 4).\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (list[Tensor]): Ignored gt bboxes of each image.\n                Default: None.\n\n        Returns:\n            dict: Loss dict, comprise classification loss, regression loss and\n                carl loss.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ",", "\n", "return_sampling_results", "=", "True", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ",", "sampling_results_list", ")", "=", "cls_reg_targets", "\n", "num_total_samples", "=", "(", "\n", "num_total_pos", "+", "num_total_neg", "if", "self", ".", "sampling", "else", "num_total_pos", ")", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors and flags to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "anchor_list", ")", ")", ":", "\n", "            ", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "", "all_anchor_list", "=", "images_to_levels", "(", "concat_anchor_list", ",", "\n", "num_level_anchors", ")", "\n", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "flatten_cls_scores", "=", "[", "\n", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "num_imgs", ",", "-", "1", ",", "label_channels", ")", "\n", "for", "cls_score", "in", "cls_scores", "\n", "]", "\n", "flatten_cls_scores", "=", "torch", ".", "cat", "(", "\n", "flatten_cls_scores", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "\n", "flatten_cls_scores", "[", "0", "]", ".", "size", "(", "-", "1", ")", ")", "\n", "flatten_bbox_preds", "=", "[", "\n", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "num_imgs", ",", "-", "1", ",", "4", ")", "\n", "for", "bbox_pred", "in", "bbox_preds", "\n", "]", "\n", "flatten_bbox_preds", "=", "torch", ".", "cat", "(", "\n", "flatten_bbox_preds", ",", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "flatten_bbox_preds", "[", "0", "]", ".", "size", "(", "-", "1", ")", ")", "\n", "flatten_labels", "=", "torch", ".", "cat", "(", "labels_list", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "flatten_label_weights", "=", "torch", ".", "cat", "(", "\n", "label_weights_list", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "flatten_anchors", "=", "torch", ".", "cat", "(", "all_anchor_list", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "flatten_bbox_targets", "=", "torch", ".", "cat", "(", "\n", "bbox_targets_list", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "flatten_bbox_weights", "=", "torch", ".", "cat", "(", "\n", "bbox_weights_list", ",", "dim", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n", "# Apply ISR-P", "\n", "isr_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'isr'", ",", "None", ")", "\n", "if", "isr_cfg", "is", "not", "None", ":", "\n", "            ", "all_targets", "=", "(", "flatten_labels", ",", "flatten_label_weights", ",", "\n", "flatten_bbox_targets", ",", "flatten_bbox_weights", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "all_targets", "=", "isr_p", "(", "\n", "flatten_cls_scores", ",", "\n", "flatten_bbox_preds", ",", "\n", "all_targets", ",", "\n", "flatten_anchors", ",", "\n", "sampling_results_list", ",", "\n", "bbox_coder", "=", "self", ".", "bbox_coder", ",", "\n", "loss_cls", "=", "self", ".", "loss_cls", ",", "\n", "num_class", "=", "self", ".", "num_classes", ",", "\n", "**", "self", ".", "train_cfg", ".", "isr", ")", "\n", "", "(", "flatten_labels", ",", "flatten_label_weights", ",", "flatten_bbox_targets", ",", "\n", "flatten_bbox_weights", ")", "=", "all_targets", "\n", "\n", "# For convenience we compute loss once instead separating by fpn level,", "\n", "# so that we don't need to separate the weights by level again.", "\n", "# The result should be the same", "\n", "", "losses_cls", "=", "self", ".", "loss_cls", "(", "\n", "flatten_cls_scores", ",", "\n", "flatten_labels", ",", "\n", "flatten_label_weights", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "losses_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "flatten_bbox_preds", ",", "\n", "flatten_bbox_targets", ",", "\n", "flatten_bbox_weights", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "loss_dict", "=", "dict", "(", "loss_cls", "=", "losses_cls", ",", "loss_bbox", "=", "losses_bbox", ")", "\n", "\n", "# CARL Loss", "\n", "carl_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'carl'", ",", "None", ")", "\n", "if", "carl_cfg", "is", "not", "None", ":", "\n", "            ", "loss_carl", "=", "carl_loss", "(", "\n", "flatten_cls_scores", ",", "\n", "flatten_labels", ",", "\n", "flatten_bbox_preds", ",", "\n", "flatten_bbox_targets", ",", "\n", "self", ".", "loss_bbox", ",", "\n", "**", "self", ".", "train_cfg", ".", "carl", ",", "\n", "avg_factor", "=", "num_total_pos", ",", "\n", "sigmoid", "=", "True", ",", "\n", "num_class", "=", "self", ".", "num_classes", ")", "\n", "loss_dict", ".", "update", "(", "loss_carl", ")", "\n", "\n", "", "return", "loss_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.__init__": [[9, 11], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "BaseDenseHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.loss": [[12, 16], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "loss", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.get_bboxes": [[17, 21], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_bboxes", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train": [[22, 60], ["base_dense_head.BaseDenseHead.", "base_dense_head.BaseDenseHead.loss", "base_dense_head.BaseDenseHead.get_bboxes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "def", "forward_train", "(", "self", ",", "\n", "x", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "None", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "proposal_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): Features from FPN.\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes (Tensor): Ground truth bboxes of the image,\n                shape (num_gts, 4).\n            gt_labels (Tensor): Ground truth labels of each box,\n                shape (num_gts,).\n            gt_bboxes_ignore (Tensor): Ground truth bboxes to be\n                ignored, shape (num_ignored_gts, 4).\n            proposal_cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used\n\n        Returns:\n            tuple:\n                losses: (dict[str, Tensor]): A dictionary of loss components.\n                proposal_list (list[Tensor]): Proposals of each image.\n        \"\"\"", "\n", "outs", "=", "self", "(", "x", ")", "\n", "if", "gt_labels", "is", "None", ":", "\n", "            ", "loss_inputs", "=", "outs", "+", "(", "gt_bboxes", ",", "img_metas", ")", "\n", "", "else", ":", "\n", "            ", "loss_inputs", "=", "outs", "+", "(", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ")", "\n", "", "losses", "=", "self", ".", "loss", "(", "*", "loss_inputs", ",", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "if", "proposal_cfg", "is", "None", ":", "\n", "            ", "return", "losses", "\n", "", "else", ":", "\n", "            ", "proposal_list", "=", "self", ".", "get_bboxes", "(", "*", "outs", ",", "img_metas", ",", "cfg", "=", "proposal_cfg", ")", "\n", "return", "losses", ",", "proposal_list", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FeatureAlign.__init__": [[15, 31], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "mmcv.ops.DeformConv2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "4", ")", ":", "\n", "        ", "super", "(", "FeatureAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "offset_channels", "=", "kernel_size", "*", "kernel_size", "*", "2", "\n", "self", ".", "conv_offset", "=", "nn", ".", "Conv2d", "(", "\n", "4", ",", "deform_groups", "*", "offset_channels", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv_adaption", "=", "DeformConv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "(", "kernel_size", "-", "1", ")", "//", "2", ",", "\n", "deform_groups", "=", "deform_groups", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FeatureAlign.init_weights": [[32, 35], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "normal_init", "(", "self", ".", "conv_offset", ",", "std", "=", "0.1", ")", "\n", "normal_init", "(", "self", ".", "conv_adaption", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FeatureAlign.forward": [[36, 40], ["fovea_head.FeatureAlign.conv_offset", "fovea_head.FeatureAlign.relu", "fovea_head.FeatureAlign.conv_adaption"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "shape", ")", ":", "\n", "        ", "offset", "=", "self", ".", "conv_offset", "(", "shape", ")", "\n", "x", "=", "self", ".", "relu", "(", "self", ".", "conv_adaption", "(", "x", ",", "offset", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.__init__": [[48, 64], ["anchor_free_head.AnchorFreeHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "base_edge_list", "=", "(", "16", ",", "32", ",", "64", ",", "128", ",", "256", ")", ",", "\n", "scale_ranges", "=", "(", "(", "8", ",", "32", ")", ",", "(", "16", ",", "64", ")", ",", "(", "32", ",", "128", ")", ",", "(", "64", ",", "256", ")", ",", "(", "128", ",", "\n", "512", ")", ")", ",", "\n", "sigma", "=", "0.4", ",", "\n", "with_deform", "=", "False", ",", "\n", "deform_groups", "=", "4", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "base_edge_list", "=", "base_edge_list", "\n", "self", ".", "scale_ranges", "=", "scale_ranges", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "with_deform", "=", "with_deform", "\n", "self", ".", "deform_groups", "=", "deform_groups", "\n", "super", "(", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead._init_layers": [[65, 104], ["super()._init_reg_convs", "torch.Conv2d", "torch.Conv2d", "super()._init_cls_convs", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "fovea_head.FoveaHead.cls_convs.append", "fovea_head.FoveaHead.cls_convs.append", "fovea_head.FeatureAlign", "torch.Conv2d", "torch.Conv2d", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "int"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_reg_convs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_cls_convs"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "# box branch", "\n", "        ", "super", "(", ")", ".", "_init_reg_convs", "(", ")", "\n", "self", ".", "conv_reg", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n", "# cls branch", "\n", "if", "not", "self", ".", "with_deform", ":", "\n", "            ", "super", "(", ")", ".", "_init_cls_convs", "(", ")", "\n", "self", ".", "conv_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "cls_out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "(", "self", ".", "feat_channels", "*", "4", ")", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "norm_cfg", "is", "None", ")", ")", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "(", "self", ".", "feat_channels", "*", "4", ")", ",", "(", "self", ".", "feat_channels", "*", "4", ")", ",", "\n", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "norm_cfg", "is", "None", ")", ")", "\n", "self", ".", "feature_adaption", "=", "FeatureAlign", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "self", ".", "deform_groups", ")", "\n", "self", ".", "conv_cls", "=", "nn", ".", "Conv2d", "(", "\n", "int", "(", "self", ".", "feat_channels", "*", "4", ")", ",", "\n", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.init_weights": [[105, 109], ["super().init_weights", "fovea_head.FoveaHead.feature_adaption.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "init_weights", "(", ")", "\n", "if", "self", ".", "with_deform", ":", "\n", "            ", "self", ".", "feature_adaption", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.forward_single": [[110, 122], ["fovea_head.FoveaHead.conv_reg", "fovea_head.FoveaHead.conv_cls", "reg_layer", "fovea_head.FoveaHead.feature_adaption", "cls_layer", "fovea_head.FoveaHead.exp"], "methods", ["None"], ["", "", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "reg_layer", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_layer", "(", "reg_feat", ")", "\n", "", "bbox_pred", "=", "self", ".", "conv_reg", "(", "reg_feat", ")", "\n", "if", "self", ".", "with_deform", ":", "\n", "            ", "cls_feat", "=", "self", ".", "feature_adaption", "(", "cls_feat", ",", "bbox_pred", ".", "exp", "(", ")", ")", "\n", "", "for", "cls_layer", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_layer", "(", "cls_feat", ")", "\n", "", "cls_score", "=", "self", ".", "conv_cls", "(", "cls_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead._get_points_single": [[123, 126], ["super()._get_points_single"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._get_points_single"], ["", "def", "_get_points_single", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "y", ",", "x", "=", "super", "(", ")", ".", "_get_points_single", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "y", "+", "0.5", ",", "x", "+", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.loss": [[127, 177], ["fovea_head.FoveaHead.get_points", "cls_scores[].size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fovea_head.FoveaHead.get_targets", "len", "fovea_head.FoveaHead.loss_cls", "dict", "len", "len", "cls_score.permute().reshape", "bbox_pred.permute().reshape", "fovea_head.FoveaHead.loss_bbox", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "featmap.size", "pos_bbox_targets.new_zeros", "cls_score.permute", "bbox_pred.permute", "pos_bbox_targets.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bbox_list", ",", "\n", "gt_label_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "\n", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "points", "=", "self", ".", "get_points", "(", "featmap_sizes", ",", "bbox_preds", "[", "0", "]", ".", "dtype", ",", "\n", "bbox_preds", "[", "0", "]", ".", "device", ")", "\n", "num_imgs", "=", "cls_scores", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "flatten_cls_scores", "=", "[", "\n", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "for", "cls_score", "in", "cls_scores", "\n", "]", "\n", "flatten_bbox_preds", "=", "[", "\n", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "for", "bbox_pred", "in", "bbox_preds", "\n", "]", "\n", "flatten_cls_scores", "=", "torch", ".", "cat", "(", "flatten_cls_scores", ")", "\n", "flatten_bbox_preds", "=", "torch", ".", "cat", "(", "flatten_bbox_preds", ")", "\n", "flatten_labels", ",", "flatten_bbox_targets", "=", "self", ".", "get_targets", "(", "\n", "gt_bbox_list", ",", "gt_label_list", ",", "featmap_sizes", ",", "points", ")", "\n", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "pos_inds", "=", "(", "\n", "(", "flatten_labels", ">=", "0", ")", "\n", "&", "(", "flatten_labels", "<", "self", ".", "background_label", ")", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "num_pos", "=", "len", "(", "pos_inds", ")", "\n", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "flatten_cls_scores", ",", "flatten_labels", ",", "avg_factor", "=", "num_pos", "+", "num_imgs", ")", "\n", "if", "num_pos", ">", "0", ":", "\n", "            ", "pos_bbox_preds", "=", "flatten_bbox_preds", "[", "pos_inds", "]", "\n", "pos_bbox_targets", "=", "flatten_bbox_targets", "[", "pos_inds", "]", "\n", "pos_weights", "=", "pos_bbox_targets", ".", "new_zeros", "(", "\n", "pos_bbox_targets", ".", "size", "(", ")", ")", "+", "1.0", "\n", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "pos_bbox_preds", ",", "\n", "pos_bbox_targets", ",", "\n", "pos_weights", ",", "\n", "avg_factor", "=", "num_pos", ")", "\n", "", "else", ":", "\n", "            ", "loss_bbox", "=", "torch", ".", "tensor", "(", "\n", "0", ",", "\n", "dtype", "=", "flatten_bbox_preds", ".", "dtype", ",", "\n", "device", "=", "flatten_bbox_preds", ".", "device", ")", "\n", "", "return", "dict", "(", "loss_cls", "=", "loss_cls", ",", "loss_bbox", "=", "loss_bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.get_targets": [[178, 199], ["mmdet.core.multi_apply", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "zip", "zip", "labels_level_img.flatten", "bbox_targets_level_img.reshape"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "get_targets", "(", "self", ",", "gt_bbox_list", ",", "gt_label_list", ",", "featmap_sizes", ",", "points", ")", ":", "\n", "        ", "label_list", ",", "bbox_target_list", "=", "multi_apply", "(", "\n", "self", ".", "_get_target_single", ",", "\n", "gt_bbox_list", ",", "\n", "gt_label_list", ",", "\n", "featmap_size_list", "=", "featmap_sizes", ",", "\n", "point_list", "=", "points", ")", "\n", "flatten_labels", "=", "[", "\n", "torch", ".", "cat", "(", "[", "\n", "labels_level_img", ".", "flatten", "(", ")", "for", "labels_level_img", "in", "labels_level", "\n", "]", ")", "for", "labels_level", "in", "zip", "(", "*", "label_list", ")", "\n", "]", "\n", "flatten_bbox_targets", "=", "[", "\n", "torch", ".", "cat", "(", "[", "\n", "bbox_targets_level_img", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "for", "bbox_targets_level_img", "in", "bbox_targets_level", "\n", "]", ")", "for", "bbox_targets_level", "in", "zip", "(", "*", "bbox_target_list", ")", "\n", "]", "\n", "flatten_labels", "=", "torch", ".", "cat", "(", "flatten_labels", ")", "\n", "flatten_bbox_targets", "=", "torch", ".", "cat", "(", "flatten_bbox_targets", ")", "\n", "return", "flatten_labels", ",", "flatten_bbox_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead._get_target_single": [[200, 260], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "zip", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.ceil().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "torch.floor().long().clamp", "zip", "bbox_targets.clamp.clamp.clamp", "label_list.append", "bbox_target_list.append", "gt_labels_raw.new_zeros", "gt_bboxes_raw.new", "len", "label_list.append", "bbox_target_list.append", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.floor().long", "torch.floor().long", "torch.floor().long", "torch.floor().long", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.floor().long", "torch.floor().long", "torch.floor().long", "torch.floor().long", "torch.ceil", "torch.ceil", "torch.ceil", "torch.ceil", "torch.floor", "torch.floor", "torch.floor", "torch.floor", "torch.ceil", "torch.ceil", "torch.ceil", "torch.ceil", "torch.floor", "torch.floor", "torch.floor", "torch.floor"], "methods", ["None"], ["", "def", "_get_target_single", "(", "self", ",", "\n", "gt_bboxes_raw", ",", "\n", "gt_labels_raw", ",", "\n", "featmap_size_list", "=", "None", ",", "\n", "point_list", "=", "None", ")", ":", "\n", "\n", "        ", "gt_areas", "=", "torch", ".", "sqrt", "(", "(", "gt_bboxes_raw", "[", ":", ",", "2", "]", "-", "gt_bboxes_raw", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "gt_bboxes_raw", "[", ":", ",", "3", "]", "-", "gt_bboxes_raw", "[", ":", ",", "1", "]", ")", ")", "\n", "label_list", "=", "[", "]", "\n", "bbox_target_list", "=", "[", "]", "\n", "# for each pyramid, find the cls and box target", "\n", "for", "base_len", ",", "(", "lower_bound", ",", "upper_bound", ")", ",", "stride", ",", "featmap_size", ",", "(", "y", ",", "x", ")", "in", "zip", "(", "self", ".", "base_edge_list", ",", "self", ".", "scale_ranges", ",", "\n", "self", ".", "strides", ",", "featmap_size_list", ",", "point_list", ")", ":", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "            ", "labels", "=", "gt_labels_raw", ".", "new_zeros", "(", "featmap_size", ")", "+", "self", ".", "num_classes", "\n", "bbox_targets", "=", "gt_bboxes_raw", ".", "new", "(", "featmap_size", "[", "0", "]", ",", "featmap_size", "[", "1", "]", ",", "\n", "4", ")", "+", "1", "\n", "# scale assignment", "\n", "hit_indices", "=", "(", "(", "gt_areas", ">=", "lower_bound", ")", "&", "\n", "(", "gt_areas", "<=", "upper_bound", ")", ")", ".", "nonzero", "(", ")", ".", "flatten", "(", ")", "\n", "if", "len", "(", "hit_indices", ")", "==", "0", ":", "\n", "                ", "label_list", ".", "append", "(", "labels", ")", "\n", "bbox_target_list", ".", "append", "(", "torch", ".", "log", "(", "bbox_targets", ")", ")", "\n", "continue", "\n", "", "_", ",", "hit_index_order", "=", "torch", ".", "sort", "(", "-", "gt_areas", "[", "hit_indices", "]", ")", "\n", "hit_indices", "=", "hit_indices", "[", "hit_index_order", "]", "\n", "gt_bboxes", "=", "gt_bboxes_raw", "[", "hit_indices", ",", ":", "]", "/", "stride", "\n", "gt_labels", "=", "gt_labels_raw", "[", "hit_indices", "]", "\n", "half_w", "=", "0.5", "*", "(", "gt_bboxes", "[", ":", ",", "2", "]", "-", "gt_bboxes", "[", ":", ",", "0", "]", ")", "\n", "half_h", "=", "0.5", "*", "(", "gt_bboxes", "[", ":", ",", "3", "]", "-", "gt_bboxes", "[", ":", ",", "1", "]", ")", "\n", "# valid fovea area: left, right, top, down", "\n", "pos_left", "=", "torch", ".", "ceil", "(", "\n", "gt_bboxes", "[", ":", ",", "0", "]", "+", "(", "1", "-", "self", ".", "sigma", ")", "*", "half_w", "-", "0.5", ")", ".", "long", "(", ")", ".", "clamp", "(", "0", ",", "featmap_size", "[", "1", "]", "-", "1", ")", "\n", "pos_right", "=", "torch", ".", "floor", "(", "\n", "gt_bboxes", "[", ":", ",", "0", "]", "+", "(", "1", "+", "self", ".", "sigma", ")", "*", "half_w", "-", "0.5", ")", ".", "long", "(", ")", ".", "clamp", "(", "0", ",", "featmap_size", "[", "1", "]", "-", "1", ")", "\n", "pos_top", "=", "torch", ".", "ceil", "(", "\n", "gt_bboxes", "[", ":", ",", "1", "]", "+", "(", "1", "-", "self", ".", "sigma", ")", "*", "half_h", "-", "0.5", ")", ".", "long", "(", ")", ".", "clamp", "(", "0", ",", "featmap_size", "[", "0", "]", "-", "1", ")", "\n", "pos_down", "=", "torch", ".", "floor", "(", "\n", "gt_bboxes", "[", ":", ",", "1", "]", "+", "(", "1", "+", "self", ".", "sigma", ")", "*", "half_h", "-", "0.5", ")", ".", "long", "(", ")", ".", "clamp", "(", "0", ",", "featmap_size", "[", "0", "]", "-", "1", ")", "\n", "for", "px1", ",", "py1", ",", "px2", ",", "py2", ",", "label", ",", "(", "gt_x1", ",", "gt_y1", ",", "gt_x2", ",", "gt_y2", ")", "in", "zip", "(", "pos_left", ",", "pos_top", ",", "pos_right", ",", "pos_down", ",", "gt_labels", ",", "\n", "gt_bboxes_raw", "[", "hit_indices", ",", ":", "]", ")", ":", "\n", "                ", "labels", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", "]", "=", "label", "\n", "bbox_targets", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", ",", "0", "]", "=", "(", "stride", "*", "x", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", "]", "-", "gt_x1", ")", "/", "base_len", "\n", "bbox_targets", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", ",", "1", "]", "=", "(", "stride", "*", "y", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", "]", "-", "gt_y1", ")", "/", "base_len", "\n", "bbox_targets", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", ",", "2", "]", "=", "(", "gt_x2", "-", "stride", "*", "x", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", "]", ")", "/", "base_len", "\n", "bbox_targets", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", ",", "3", "]", "=", "(", "gt_y2", "-", "stride", "*", "y", "[", "py1", ":", "py2", "+", "1", ",", "px1", ":", "px2", "+", "1", "]", ")", "/", "base_len", "\n", "", "bbox_targets", "=", "bbox_targets", ".", "clamp", "(", "min", "=", "1.", "/", "16", ",", "max", "=", "16.", ")", "\n", "label_list", ".", "append", "(", "labels", ")", "\n", "bbox_target_list", ".", "append", "(", "torch", ".", "log", "(", "bbox_targets", ")", ")", "\n", "", "return", "label_list", ",", "bbox_target_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead.get_bboxes": [[261, 291], ["len", "fovea_head.FoveaHead.get_points", "range", "len", "len", "len", "fovea_head.FoveaHead._get_bboxes_single", "result_list.append", "featmap.size", "[].detach", "[].detach", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "None", ")", ":", "\n", "        ", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "points", "=", "self", ".", "get_points", "(", "\n", "featmap_sizes", ",", "\n", "bbox_preds", "[", "0", "]", ".", "dtype", ",", "\n", "bbox_preds", "[", "0", "]", ".", "device", ",", "\n", "flatten", "=", "True", ")", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "det_bboxes", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "\n", "bbox_pred_list", ",", "featmap_sizes", ",", "\n", "points", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ")", "\n", "result_list", ".", "append", "(", "det_bboxes", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fovea_head.FoveaHead._get_bboxes_single": [[292, 343], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "len", "len", "len", "cls_score.permute().reshape().sigmoid", "bbox_pred.permute().reshape().exp.permute().reshape().exp.permute().reshape().exp", "cfg.get", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "cls_score.permute().reshape().sigmoid.max", "max_scores.topk", "cls_score.size", "bbox_pred.permute().reshape().exp.permute().reshape().exp.size", "cls_score.permute().reshape", "bbox_pred.permute().reshape().exp.permute().reshape().exp.permute().reshape", "cls_score.permute", "bbox_pred.permute().reshape().exp.permute().reshape().exp.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "featmap_sizes", ",", "\n", "point_list", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "point_list", ")", "\n", "det_bboxes", "=", "[", "]", "\n", "det_scores", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "featmap_size", ",", "stride", ",", "base_len", ",", "(", "y", ",", "x", ")", "in", "zip", "(", "cls_scores", ",", "bbox_preds", ",", "featmap_sizes", ",", "self", ".", "strides", ",", "\n", "self", ".", "base_edge_list", ",", "point_list", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "scores", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "\n", "-", "1", ",", "self", ".", "cls_out_channels", ")", ".", "sigmoid", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ".", "exp", "(", ")", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "(", "nms_pre", ">", "0", ")", "and", "(", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ")", ":", "\n", "                ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "y", "=", "y", "[", "topk_inds", "]", "\n", "x", "=", "x", "[", "topk_inds", "]", "\n", "", "x1", "=", "(", "stride", "*", "x", "-", "base_len", "*", "bbox_pred", "[", ":", ",", "0", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "1", "]", "-", "1", ")", "\n", "y1", "=", "(", "stride", "*", "y", "-", "base_len", "*", "bbox_pred", "[", ":", ",", "1", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "0", "]", "-", "1", ")", "\n", "x2", "=", "(", "stride", "*", "x", "+", "base_len", "*", "bbox_pred", "[", ":", ",", "2", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "1", "]", "-", "1", ")", "\n", "y2", "=", "(", "stride", "*", "y", "+", "base_len", "*", "bbox_pred", "[", ":", ",", "3", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "0", "]", "-", "1", ")", "\n", "bboxes", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "-", "1", ")", "\n", "det_bboxes", ".", "append", "(", "bboxes", ")", "\n", "det_scores", ".", "append", "(", "scores", ")", "\n", "", "det_bboxes", "=", "torch", ".", "cat", "(", "det_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "det_bboxes", "/=", "det_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "det_scores", "=", "torch", ".", "cat", "(", "det_scores", ")", "\n", "padding", "=", "det_scores", ".", "new_zeros", "(", "det_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "det_scores", "=", "torch", ".", "cat", "(", "[", "det_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "det_bboxes", ",", "det_scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.simple_test_rpn": [[25, 39], ["rpn_test_mixin.RPNTestMixin.", "rpn_test_mixin.RPNTestMixin.get_bboxes"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes"], ["", "", "def", "simple_test_rpn", "(", "self", ",", "x", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Test without augmentation.\n\n        Args:\n            x (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n            img_metas (list[dict]): Meta info of each image.\n\n        Returns:\n            list[Tensor]: Proposals of each image.\n        \"\"\"", "\n", "rpn_outs", "=", "self", "(", "x", ")", "\n", "proposal_list", "=", "self", ".", "get_bboxes", "(", "*", "rpn_outs", ",", "img_metas", ")", "\n", "return", "proposal_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.aug_test_rpn": [[40, 61], ["len", "zip", "range", "rpn_test_mixin.RPNTestMixin.simple_test_rpn", "enumerate", "range", "aug_img_metas.append", "mmdet.core.merge_aug_proposals", "range", "aug_proposals[].append", "len", "aug_img_meta.append", "zip"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_test_mixin.RPNTestMixin.simple_test_rpn", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_proposals"], ["", "def", "aug_test_rpn", "(", "self", ",", "feats", ",", "img_metas", ")", ":", "\n", "        ", "samples_per_gpu", "=", "len", "(", "img_metas", "[", "0", "]", ")", "\n", "aug_proposals", "=", "[", "[", "]", "for", "_", "in", "range", "(", "samples_per_gpu", ")", "]", "\n", "for", "x", ",", "img_meta", "in", "zip", "(", "feats", ",", "img_metas", ")", ":", "\n", "            ", "proposal_list", "=", "self", ".", "simple_test_rpn", "(", "x", ",", "img_meta", ")", "\n", "for", "i", ",", "proposals", "in", "enumerate", "(", "proposal_list", ")", ":", "\n", "                ", "aug_proposals", "[", "i", "]", ".", "append", "(", "proposals", ")", "\n", "# reorganize the order of 'img_metas' to match the dimensions", "\n", "# of 'aug_proposals'", "\n", "", "", "aug_img_metas", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "samples_per_gpu", ")", ":", "\n", "            ", "aug_img_meta", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "                ", "aug_img_meta", ".", "append", "(", "img_metas", "[", "j", "]", "[", "i", "]", ")", "\n", "", "aug_img_metas", ".", "append", "(", "aug_img_meta", ")", "\n", "# after merging, proposals will be rescaled to the original image size", "\n", "", "merged_proposals", "=", "[", "\n", "merge_aug_proposals", "(", "proposals", ",", "aug_img_meta", ",", "self", ".", "test_cfg", ")", "\n", "for", "proposals", ",", "aug_img_meta", "in", "zip", "(", "aug_proposals", ",", "aug_img_metas", ")", "\n", "]", "\n", "return", "merged_proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ssd_head.SSDHead.__init__": [[33, 97], ["dict", "dict", "anchor_head.AnchorHead.__init__", "mmdet.core.build_anchor_generator", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "mmdet.core.build_bbox_coder", "len", "reg_convs.append", "cls_convs.append", "mmdet.core.build_assigner", "dict", "mmdet.core.build_sampler", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "80", ",", "\n", "in_channels", "=", "(", "512", ",", "1024", ",", "512", ",", "256", ",", "256", ",", "256", ")", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'SSDAnchorGenerator'", ",", "\n", "scale_major", "=", "False", ",", "\n", "input_size", "=", "300", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "100", ",", "300", "]", ",", "\n", "ratios", "=", "(", "[", "2", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", "]", ",", "[", "2", "]", ")", ",", "\n", "basesize_ratio_range", "=", "(", "0.1", ",", "0.9", ")", ")", ",", "\n", "background_label", "=", "None", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", ".0", ",", ".0", ",", ".0", ",", ".0", "]", ",", "\n", "target_stds", "=", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", ")", ",", "\n", "reg_decoded_bbox", "=", "False", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "AnchorHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "# add background class", "\n", "self", ".", "anchor_generator", "=", "build_anchor_generator", "(", "anchor_generator", ")", "\n", "num_anchors", "=", "self", ".", "anchor_generator", ".", "num_base_anchors", "\n", "\n", "reg_convs", "=", "[", "]", "\n", "cls_convs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "in_channels", ")", ")", ":", "\n", "            ", "reg_convs", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "num_anchors", "[", "i", "]", "*", "4", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ")", ")", "\n", "cls_convs", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "num_anchors", "[", "i", "]", "*", "(", "num_classes", "+", "1", ")", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ")", ")", "\n", "", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", "reg_convs", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", "cls_convs", ")", "\n", "\n", "self", ".", "background_label", "=", "(", "\n", "num_classes", "if", "background_label", "is", "None", "else", "background_label", ")", "\n", "# background_label should be either 0 or num_classes", "\n", "assert", "(", "self", ".", "background_label", "==", "0", "\n", "or", "self", ".", "background_label", "==", "num_classes", ")", "\n", "\n", "self", ".", "bbox_coder", "=", "build_bbox_coder", "(", "bbox_coder", ")", "\n", "self", ".", "reg_decoded_bbox", "=", "reg_decoded_bbox", "\n", "self", ".", "use_sigmoid_cls", "=", "False", "\n", "self", ".", "cls_focal_loss", "=", "False", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "# set sampling=False for archor_target", "\n", "self", ".", "sampling", "=", "False", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# SSD sampling=False so use PseudoSampler", "\n", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "", "self", ".", "fp16_enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ssd_head.SSDHead.init_weights": [[98, 103], ["ssd_head.SSDHead.modules", "isinstance", "mmcv.cnn.xavier_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ",", "bias", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ssd_head.SSDHead.forward": [[104, 127], ["zip", "cls_scores.append", "bbox_preds.append", "cls_conv", "reg_conv"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple:\n                cls_scores (list[Tensor]): Classification scores for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * num_classes.\n                bbox_preds (list[Tensor]): Box energies / deltas for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * 4.\n        \"\"\"", "\n", "cls_scores", "=", "[", "]", "\n", "bbox_preds", "=", "[", "]", "\n", "for", "feat", ",", "reg_conv", ",", "cls_conv", "in", "zip", "(", "feats", ",", "self", ".", "reg_convs", ",", "\n", "self", ".", "cls_convs", ")", ":", "\n", "            ", "cls_scores", ".", "append", "(", "cls_conv", "(", "feat", ")", ")", "\n", "bbox_preds", ".", "append", "(", "reg_conv", "(", "feat", ")", ")", "\n", "", "return", "cls_scores", ",", "bbox_preds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ssd_head.SSDHead.loss_single": [[128, 181], ["pos_inds.size", "loss_cls_all[].topk", "loss_cls_all[].sum", "topk_loss_cls_neg.sum", "losses.smooth_l1_loss", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "neg_inds.size", "neg_inds.size", "ssd_head.SSDHead.bbox_coder.decode"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.smooth_l1_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "loss_single", "(", "self", ",", "cls_score", ",", "bbox_pred", ",", "anchor", ",", "labels", ",", "label_weights", ",", "\n", "bbox_targets", ",", "bbox_weights", ",", "num_total_samples", ")", ":", "\n", "        ", "\"\"\"Compute loss of a single image.\n\n        Args:\n            cls_score (Tensor): Box scores for eachimage\n                Has shape (num_total_anchors, num_classes).\n            bbox_pred (Tensor): Box energies / deltas for each image\n                level with shape (num_total_anchors, 4).\n            anchors (Tensor): Box reference for each scale level with shape\n                (num_total_anchors, 4).\n            labels (Tensor): Labels of each anchors with shape\n                (num_total_anchors,).\n            label_weights (Tensor): Label weights of each anchor with shape\n                (num_total_anchors,)\n            bbox_targets (Tensor): BBox regression targets of each anchor wight\n                shape (num_total_anchors, 4).\n            bbox_weights (Tensor): BBox regression loss weights of each anchor\n                with shape (num_total_anchors, 4).\n            num_total_samples (int): If sampling, num total samples equal to\n                the number of total anchors; Otherwise, it is the number of\n                positive anchors.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "\n", "loss_cls_all", "=", "F", ".", "cross_entropy", "(", "\n", "cls_score", ",", "labels", ",", "reduction", "=", "'none'", ")", "*", "label_weights", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "pos_inds", "=", "(", "(", "labels", ">=", "0", ")", "&", "\n", "(", "labels", "<", "self", ".", "background_label", ")", ")", ".", "nonzero", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "neg_inds", "=", "(", "labels", "==", "self", ".", "background_label", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "num_pos_samples", "=", "pos_inds", ".", "size", "(", "0", ")", "\n", "num_neg_samples", "=", "self", ".", "train_cfg", ".", "neg_pos_ratio", "*", "num_pos_samples", "\n", "if", "num_neg_samples", ">", "neg_inds", ".", "size", "(", "0", ")", ":", "\n", "            ", "num_neg_samples", "=", "neg_inds", ".", "size", "(", "0", ")", "\n", "", "topk_loss_cls_neg", ",", "_", "=", "loss_cls_all", "[", "neg_inds", "]", ".", "topk", "(", "num_neg_samples", ")", "\n", "loss_cls_pos", "=", "loss_cls_all", "[", "pos_inds", "]", ".", "sum", "(", ")", "\n", "loss_cls_neg", "=", "topk_loss_cls_neg", ".", "sum", "(", ")", "\n", "loss_cls", "=", "(", "loss_cls_pos", "+", "loss_cls_neg", ")", "/", "num_total_samples", "\n", "\n", "if", "self", ".", "reg_decoded_bbox", ":", "\n", "            ", "bbox_pred", "=", "self", ".", "bbox_coder", ".", "decode", "(", "anchor", ",", "bbox_pred", ")", "\n", "\n", "", "loss_bbox", "=", "smooth_l1_loss", "(", "\n", "bbox_pred", ",", "\n", "bbox_targets", ",", "\n", "bbox_weights", ",", "\n", "beta", "=", "self", ".", "train_cfg", ".", "smoothl1_beta", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "return", "loss_cls", "[", "None", "]", ",", "loss_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ssd_head.SSDHead.loss": [[182, 267], ["ssd_head.SSDHead.get_anchors", "ssd_head.SSDHead.get_targets", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "range", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "torch.isfinite().all().item", "mmdet.core.multi_apply", "dict", "len", "all_anchors.append", "featmap.size", "s.permute().reshape", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "b.permute().reshape", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "torch.isfinite().all", "s.permute", "b.permute", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "False", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "\n", "num_images", "=", "len", "(", "img_metas", ")", "\n", "all_cls_scores", "=", "torch", ".", "cat", "(", "[", "\n", "s", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "\n", "num_images", ",", "-", "1", ",", "self", ".", "cls_out_channels", ")", "for", "s", "in", "cls_scores", "\n", "]", ",", "1", ")", "\n", "all_labels", "=", "torch", ".", "cat", "(", "labels_list", ",", "-", "1", ")", ".", "view", "(", "num_images", ",", "-", "1", ")", "\n", "all_label_weights", "=", "torch", ".", "cat", "(", "label_weights_list", ",", "\n", "-", "1", ")", ".", "view", "(", "num_images", ",", "-", "1", ")", "\n", "all_bbox_preds", "=", "torch", ".", "cat", "(", "[", "\n", "b", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "for", "b", "in", "bbox_preds", "\n", "]", ",", "-", "2", ")", "\n", "all_bbox_targets", "=", "torch", ".", "cat", "(", "bbox_targets_list", ",", "\n", "-", "2", ")", ".", "view", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "all_bbox_weights", "=", "torch", ".", "cat", "(", "bbox_weights_list", ",", "\n", "-", "2", ")", ".", "view", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "\n", "# concat all level anchors to a single tensor", "\n", "all_anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "all_anchors", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "\n", "# check NaN and Inf", "\n", "", "assert", "torch", ".", "isfinite", "(", "all_cls_scores", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "'classification scores become infinite or NaN!'", "\n", "assert", "torch", ".", "isfinite", "(", "all_bbox_preds", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "'bbox predications become infinite or NaN!'", "\n", "\n", "losses_cls", ",", "losses_bbox", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "all_cls_scores", ",", "\n", "all_bbox_preds", ",", "\n", "all_anchors", ",", "\n", "all_labels", ",", "\n", "all_label_weights", ",", "\n", "all_bbox_targets", ",", "\n", "all_bbox_weights", ",", "\n", "num_total_samples", "=", "num_total_pos", ")", "\n", "return", "dict", "(", "loss_cls", "=", "losses_cls", ",", "loss_bbox", "=", "losses_bbox", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.FeatureAdaption.__init__": [[28, 44], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "mmcv.ops.DeformConv2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "4", ")", ":", "\n", "        ", "super", "(", "FeatureAdaption", ",", "self", ")", ".", "__init__", "(", ")", "\n", "offset_channels", "=", "kernel_size", "*", "kernel_size", "*", "2", "\n", "self", ".", "conv_offset", "=", "nn", ".", "Conv2d", "(", "\n", "2", ",", "deform_groups", "*", "offset_channels", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv_adaption", "=", "DeformConv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "(", "kernel_size", "-", "1", ")", "//", "2", ",", "\n", "deform_groups", "=", "deform_groups", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.FeatureAdaption.init_weights": [[45, 48], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "normal_init", "(", "self", ".", "conv_offset", ",", "std", "=", "0.1", ")", "\n", "normal_init", "(", "self", ".", "conv_adaption", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.FeatureAdaption.forward": [[49, 53], ["guided_anchor_head.FeatureAdaption.conv_offset", "guided_anchor_head.FeatureAdaption.relu", "shape.detach", "guided_anchor_head.FeatureAdaption.conv_adaption"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "shape", ")", ":", "\n", "        ", "offset", "=", "self", ".", "conv_offset", "(", "shape", ".", "detach", "(", ")", ")", "\n", "x", "=", "self", ".", "relu", "(", "self", ".", "conv_adaption", "(", "x", ",", "offset", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.__init__": [[89, 203], ["dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "anchor_head.AnchorHead.__init__", "mmdet.core.build_anchor_generator", "mmdet.core.build_anchor_generator", "loss_cls.get", "mmdet.core.build_bbox_coder", "mmdet.core.build_bbox_coder", "builder.build_loss", "builder.build_loss", "builder.build_loss", "builder.build_loss", "guided_anchor_head.GuidedAnchorHead._init_layers", "hasattr", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "hasattr", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "feat_channels", "=", "256", ",", "\n", "approx_anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "8", ",", "\n", "scales_per_octave", "=", "3", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", ",", "64", "]", ")", ",", "\n", "square_anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "ratios", "=", "[", "1.0", "]", ",", "\n", "scales", "=", "[", "8", "]", ",", "\n", "strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", ",", "64", "]", ")", ",", "\n", "anchor_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", ".0", ",", ".0", ",", ".0", ",", ".0", "]", ",", "\n", "target_stds", "=", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", "\n", ")", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", ".0", ",", ".0", ",", ".0", ",", ".0", "]", ",", "\n", "target_stds", "=", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", "\n", ")", ",", "\n", "reg_decoded_bbox", "=", "False", ",", "\n", "deform_groups", "=", "4", ",", "\n", "loc_filter_thr", "=", "0.01", ",", "\n", "background_label", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "loss_loc", "=", "dict", "(", "\n", "type", "=", "'FocalLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_shape", "=", "dict", "(", "type", "=", "'BoundedIoULoss'", ",", "beta", "=", "0.2", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_sigmoid", "=", "True", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", ",", "\n", "loss_weight", "=", "1.0", ")", ")", ":", "# yapf: disable", "\n", "        ", "super", "(", "AnchorHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "feat_channels", "=", "feat_channels", "\n", "self", ".", "deform_groups", "=", "deform_groups", "\n", "self", ".", "loc_filter_thr", "=", "loc_filter_thr", "\n", "\n", "# build approx_anchor_generator and square_anchor_generator", "\n", "assert", "(", "approx_anchor_generator", "[", "'octave_base_scale'", "]", "==", "\n", "square_anchor_generator", "[", "'scales'", "]", "[", "0", "]", ")", "\n", "assert", "(", "approx_anchor_generator", "[", "'strides'", "]", "==", "\n", "square_anchor_generator", "[", "'strides'", "]", ")", "\n", "self", ".", "approx_anchor_generator", "=", "build_anchor_generator", "(", "\n", "approx_anchor_generator", ")", "\n", "self", ".", "square_anchor_generator", "=", "build_anchor_generator", "(", "\n", "square_anchor_generator", ")", "\n", "self", ".", "approxs_per_octave", "=", "self", ".", "approx_anchor_generator", ".", "num_base_anchors", "[", "0", "]", "\n", "\n", "self", ".", "reg_decoded_bbox", "=", "reg_decoded_bbox", "\n", "\n", "self", ".", "background_label", "=", "(", "\n", "num_classes", "if", "background_label", "is", "None", "else", "background_label", ")", "\n", "# background_label should be either 0 or num_classes", "\n", "assert", "(", "self", ".", "background_label", "==", "0", "\n", "or", "self", ".", "background_label", "==", "num_classes", ")", "\n", "\n", "# one anchor per location", "\n", "self", ".", "num_anchors", "=", "1", "\n", "self", ".", "use_sigmoid_cls", "=", "loss_cls", ".", "get", "(", "'use_sigmoid'", ",", "False", ")", "\n", "self", ".", "loc_focal_loss", "=", "loss_loc", "[", "'type'", "]", "in", "[", "'FocalLoss'", "]", "\n", "self", ".", "sampling", "=", "loss_cls", "[", "'type'", "]", "not", "in", "[", "'FocalLoss'", "]", "\n", "self", ".", "ga_sampling", "=", "train_cfg", "is", "not", "None", "and", "hasattr", "(", "\n", "train_cfg", ",", "'ga_sampler'", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "self", ".", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "self", ".", "num_classes", "+", "1", "\n", "\n", "# build bbox_coder", "\n", "", "self", ".", "anchor_coder", "=", "build_bbox_coder", "(", "anchor_coder", ")", "\n", "self", ".", "bbox_coder", "=", "build_bbox_coder", "(", "bbox_coder", ")", "\n", "\n", "# build losses", "\n", "self", ".", "loss_loc", "=", "build_loss", "(", "loss_loc", ")", "\n", "self", ".", "loss_shape", "=", "build_loss", "(", "loss_shape", ")", "\n", "self", ".", "loss_cls", "=", "build_loss", "(", "loss_cls", ")", "\n", "self", ".", "loss_bbox", "=", "build_loss", "(", "loss_bbox", ")", "\n", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# use PseudoSampler when sampling is False", "\n", "if", "self", ".", "sampling", "and", "hasattr", "(", "self", ".", "train_cfg", ",", "'sampler'", ")", ":", "\n", "                ", "sampler_cfg", "=", "self", ".", "train_cfg", ".", "sampler", "\n", "", "else", ":", "\n", "                ", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "\n", "self", ".", "ga_assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "ga_assigner", ")", "\n", "if", "self", ".", "ga_sampling", ":", "\n", "                ", "ga_sampler_cfg", "=", "self", ".", "train_cfg", ".", "ga_sampler", "\n", "", "else", ":", "\n", "                ", "ga_sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "", "self", ".", "ga_sampler", "=", "build_sampler", "(", "ga_sampler_cfg", ",", "context", "=", "self", ")", "\n", "\n", "", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead._init_layers": [[204, 218], ["torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "guided_anchor_head.FeatureAdaption", "mmcv.ops.MaskedConv2d", "mmcv.ops.MaskedConv2d"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv_loc", "=", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_shape", "=", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "self", ".", "num_anchors", "*", "2", ",", "1", ")", "\n", "self", ".", "feature_adaption", "=", "FeatureAdaption", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "deform_groups", "=", "self", ".", "deform_groups", ")", "\n", "self", ".", "conv_cls", "=", "MaskedConv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "1", ")", "\n", "self", ".", "conv_reg", "=", "MaskedConv2d", "(", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "\n", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.init_weights": [[219, 228], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "guided_anchor_head.GuidedAnchorHead.feature_adaption.init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "normal_init", "(", "self", ".", "conv_cls", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_reg", ",", "std", "=", "0.01", ")", "\n", "\n", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_loc", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "conv_shape", ",", "std", "=", "0.01", ")", "\n", "\n", "self", ".", "feature_adaption", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.forward_single": [[229, 241], ["guided_anchor_head.GuidedAnchorHead.conv_loc", "guided_anchor_head.GuidedAnchorHead.conv_shape", "guided_anchor_head.GuidedAnchorHead.feature_adaption", "guided_anchor_head.GuidedAnchorHead.conv_cls", "guided_anchor_head.GuidedAnchorHead.conv_reg", "guided_anchor_head.GuidedAnchorHead.sigmoid"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "loc_pred", "=", "self", ".", "conv_loc", "(", "x", ")", "\n", "shape_pred", "=", "self", ".", "conv_shape", "(", "x", ")", "\n", "x", "=", "self", ".", "feature_adaption", "(", "x", ",", "shape_pred", ")", "\n", "# masked conv is only used during inference for speed-up", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "mask", "=", "loc_pred", ".", "sigmoid", "(", ")", "[", "0", "]", ">=", "self", ".", "loc_filter_thr", "\n", "", "else", ":", "\n", "            ", "mask", "=", "None", "\n", "", "cls_score", "=", "self", ".", "conv_cls", "(", "x", ",", "mask", ")", "\n", "bbox_pred", "=", "self", ".", "conv_reg", "(", "x", ",", "mask", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "shape_pred", ",", "loc_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.forward": [[242, 244], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.get_sampled_approxs": [[245, 294], ["len", "guided_anchor_head.GuidedAnchorHead.approx_anchor_generator.grid_anchors", "enumerate", "guided_anchor_head.GuidedAnchorHead.approx_anchor_generator.valid_flags", "enumerate", "inside_flag_list.append", "range", "range", "multi_level_flags.append", "mmdet.core.anchor_inside_flags", "inside_flags_list.append", "torch.stack().sum", "torch.stack().sum", "torch.stack().sum", "torch.stack().sum", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags"], ["", "def", "get_sampled_approxs", "(", "self", ",", "featmap_sizes", ",", "img_metas", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Get sampled approxs and inside flags according to feature map sizes.\n\n        Args:\n            featmap_sizes (list[tuple]): Multi-level feature map sizes.\n            img_metas (list[dict]): Image meta info.\n            device (torch.device | str): device for returned tensors\n\n        Returns:\n            tuple: approxes of each image, inside flags of each image\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "\n", "# since feature map sizes of all images are the same, we only compute", "\n", "# approxes for one time", "\n", "multi_level_approxs", "=", "self", ".", "approx_anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", "=", "device", ")", "\n", "approxs_list", "=", "[", "multi_level_approxs", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "# for each image, we compute inside flags of multi level approxes", "\n", "inside_flag_list", "=", "[", "]", "\n", "for", "img_id", ",", "img_meta", "in", "enumerate", "(", "img_metas", ")", ":", "\n", "            ", "multi_level_flags", "=", "[", "]", "\n", "multi_level_approxs", "=", "approxs_list", "[", "img_id", "]", "\n", "\n", "# obtain valid flags for each approx first", "\n", "multi_level_approx_flags", "=", "self", ".", "approx_anchor_generator", ".", "valid_flags", "(", "featmap_sizes", ",", "\n", "img_meta", "[", "'pad_shape'", "]", ",", "\n", "device", "=", "device", ")", "\n", "\n", "for", "i", ",", "flags", "in", "enumerate", "(", "multi_level_approx_flags", ")", ":", "\n", "                ", "approxs", "=", "multi_level_approxs", "[", "i", "]", "\n", "inside_flags_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "approxs_per_octave", ")", ":", "\n", "                    ", "split_valid_flags", "=", "flags", "[", "i", ":", ":", "self", ".", "approxs_per_octave", "]", "\n", "split_approxs", "=", "approxs", "[", "i", ":", ":", "self", ".", "approxs_per_octave", ",", ":", "]", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "\n", "split_approxs", ",", "split_valid_flags", ",", "\n", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "inside_flags_list", ".", "append", "(", "inside_flags", ")", "\n", "# inside_flag for a position is true if any anchor in this", "\n", "# position is true", "\n", "", "inside_flags", "=", "(", "\n", "torch", ".", "stack", "(", "inside_flags_list", ",", "0", ")", ".", "sum", "(", "dim", "=", "0", ")", ">", "0", ")", "\n", "multi_level_flags", ".", "append", "(", "inside_flags", ")", "\n", "", "inside_flag_list", ".", "append", "(", "multi_level_flags", ")", "\n", "", "return", "approxs_list", ",", "inside_flag_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.get_anchors": [[295, 345], ["len", "len", "guided_anchor_head.GuidedAnchorHead.square_anchor_generator.grid_anchors", "enumerate", "range", "guided_anchors_list.append", "loc_mask_list.append", "range", "guided_anchor_head.GuidedAnchorHead._get_guided_anchors_single", "multi_level_guided_anchors.append", "multi_level_loc_mask.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead._get_guided_anchors_single"], ["", "def", "get_anchors", "(", "self", ",", "\n", "featmap_sizes", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "img_metas", ",", "\n", "use_loc_filter", "=", "False", ",", "\n", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Get squares according to feature map sizes and guided anchors.\n\n        Args:\n            featmap_sizes (list[tuple]): Multi-level feature map sizes.\n            shape_preds (list[tensor]): Multi-level shape predictions.\n            loc_preds (list[tensor]): Multi-level location predictions.\n            img_metas (list[dict]): Image meta info.\n            use_loc_filter (bool): Use loc filter or not.\n            device (torch.device | str): device for returned tensors\n\n        Returns:\n            tuple: square approxs of each image, guided anchors of each image,\n                loc masks of each image\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "num_levels", "=", "len", "(", "featmap_sizes", ")", "\n", "\n", "# since feature map sizes of all images are the same, we only compute", "\n", "# squares for one time", "\n", "multi_level_squares", "=", "self", ".", "square_anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", "=", "device", ")", "\n", "squares_list", "=", "[", "multi_level_squares", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "# for each image, we compute multi level guided anchors", "\n", "guided_anchors_list", "=", "[", "]", "\n", "loc_mask_list", "=", "[", "]", "\n", "for", "img_id", ",", "img_meta", "in", "enumerate", "(", "img_metas", ")", ":", "\n", "            ", "multi_level_guided_anchors", "=", "[", "]", "\n", "multi_level_loc_mask", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "                ", "squares", "=", "squares_list", "[", "img_id", "]", "[", "i", "]", "\n", "shape_pred", "=", "shape_preds", "[", "i", "]", "[", "img_id", "]", "\n", "loc_pred", "=", "loc_preds", "[", "i", "]", "[", "img_id", "]", "\n", "guided_anchors", ",", "loc_mask", "=", "self", ".", "_get_guided_anchors_single", "(", "\n", "squares", ",", "\n", "shape_pred", ",", "\n", "loc_pred", ",", "\n", "use_loc_filter", "=", "use_loc_filter", ")", "\n", "multi_level_guided_anchors", ".", "append", "(", "guided_anchors", ")", "\n", "multi_level_loc_mask", ".", "append", "(", "loc_mask", ")", "\n", "", "guided_anchors_list", ".", "append", "(", "multi_level_guided_anchors", ")", "\n", "loc_mask_list", ".", "append", "(", "multi_level_loc_mask", ")", "\n", "", "return", "squares_list", ",", "guided_anchors_list", ",", "loc_mask_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead._get_guided_anchors_single": [[346, 379], ["loc_pred.sigmoid().detach.sigmoid().detach.sigmoid().detach", "loc_mask.permute().expand", "mask.contiguous().view.contiguous().view.contiguous().view", "anchor_deltas.new_full", "guided_anchor_head.GuidedAnchorHead.anchor_coder.decode", "shape_pred.permute().contiguous().view().detach", "squares.size", "loc_pred.sigmoid().detach.sigmoid().detach.sigmoid", "loc_mask.permute", "mask.contiguous().view.contiguous().view.contiguous", "shape_pred.permute().contiguous().view", "shape_pred.permute().contiguous", "shape_pred.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_get_guided_anchors_single", "(", "self", ",", "\n", "squares", ",", "\n", "shape_pred", ",", "\n", "loc_pred", ",", "\n", "use_loc_filter", "=", "False", ")", ":", "\n", "        ", "\"\"\"Get guided anchors and loc masks for a single level.\n\n        Args:\n            square (tensor): Squares of a single level.\n            shape_pred (tensor): Shape predections of a single level.\n            loc_pred (tensor): Loc predections of a single level.\n            use_loc_filter (list[tensor]): Use loc filter or not.\n\n        Returns:\n            tuple: guided anchors, location masks\n        \"\"\"", "\n", "# calculate location filtering mask", "\n", "loc_pred", "=", "loc_pred", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", "\n", "if", "use_loc_filter", ":", "\n", "            ", "loc_mask", "=", "loc_pred", ">=", "self", ".", "loc_filter_thr", "\n", "", "else", ":", "\n", "            ", "loc_mask", "=", "loc_pred", ">=", "0.0", "\n", "", "mask", "=", "loc_mask", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "self", ".", "num_anchors", ")", "\n", "mask", "=", "mask", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "# calculate guided anchors", "\n", "squares", "=", "squares", "[", "mask", "]", "\n", "anchor_deltas", "=", "shape_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "-", "1", ",", "2", ")", ".", "detach", "(", ")", "[", "mask", "]", "\n", "bbox_deltas", "=", "anchor_deltas", ".", "new_full", "(", "squares", ".", "size", "(", ")", ",", "0", ")", "\n", "bbox_deltas", "[", ":", ",", "2", ":", "]", "=", "anchor_deltas", "\n", "guided_anchors", "=", "self", ".", "anchor_coder", ".", "decode", "(", "\n", "squares", ",", "bbox_deltas", ",", "wh_ratio_clip", "=", "1e-6", ")", "\n", "return", "guided_anchors", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.ga_loc_targets": [[380, 481], ["len", "len", "range", "range", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "all_loc_targets.append", "all_loc_weights.append", "all_ignore_map.append", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt.new_full", "torch.sqrt.new_full", "torch.floor", "torch.floor", "torch.floor", "torch.floor", "target_lvls.clamp().long.clamp().long.clamp().long", "range", "sum", "float", "gt_bboxes.size", "target_lvls[].item", "mmdet.core.calc_region", "mmdet.core.calc_region", "target_lvls.clamp().long.clamp().long.clamp", "mmdet.core.calc_region", "mmdet.core.calc_region", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "t.size", "t.size", "t.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.calc_region", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.calc_region", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.calc_region", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.calc_region"], ["", "def", "ga_loc_targets", "(", "self", ",", "gt_bboxes_list", ",", "featmap_sizes", ")", ":", "\n", "        ", "\"\"\"Compute location targets for guided anchoring.\n\n        Each feature map is divided into positive, negative and ignore regions.\n        - positive regions: target 1, weight 1\n        - ignore regions: target 0, weight 0\n        - negative regions: target 0, weight 0.1\n\n        Args:\n            gt_bboxes_list (list[Tensor]): Gt bboxes of each image.\n            featmap_sizes (list[tuple]): Multi level sizes of each feature\n                maps.\n\n        Returns:\n            tuple\n        \"\"\"", "\n", "anchor_scale", "=", "self", ".", "approx_anchor_generator", ".", "octave_base_scale", "\n", "anchor_strides", "=", "self", ".", "approx_anchor_generator", ".", "strides", "\n", "# Currently only supports same stride in x and y direction.", "\n", "for", "stride", "in", "anchor_strides", ":", "\n", "            ", "assert", "(", "stride", "[", "0", "]", "==", "stride", "[", "1", "]", ")", "\n", "", "anchor_strides", "=", "[", "stride", "[", "0", "]", "for", "stride", "in", "anchor_strides", "]", "\n", "\n", "center_ratio", "=", "self", ".", "train_cfg", ".", "center_ratio", "\n", "ignore_ratio", "=", "self", ".", "train_cfg", ".", "ignore_ratio", "\n", "img_per_gpu", "=", "len", "(", "gt_bboxes_list", ")", "\n", "num_lvls", "=", "len", "(", "featmap_sizes", ")", "\n", "r1", "=", "(", "1", "-", "center_ratio", ")", "/", "2", "\n", "r2", "=", "(", "1", "-", "ignore_ratio", ")", "/", "2", "\n", "all_loc_targets", "=", "[", "]", "\n", "all_loc_weights", "=", "[", "]", "\n", "all_ignore_map", "=", "[", "]", "\n", "for", "lvl_id", "in", "range", "(", "num_lvls", ")", ":", "\n", "            ", "h", ",", "w", "=", "featmap_sizes", "[", "lvl_id", "]", "\n", "loc_targets", "=", "torch", ".", "zeros", "(", "\n", "img_per_gpu", ",", "\n", "1", ",", "\n", "h", ",", "\n", "w", ",", "\n", "device", "=", "gt_bboxes_list", "[", "0", "]", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "loc_weights", "=", "torch", ".", "full_like", "(", "loc_targets", ",", "-", "1", ")", "\n", "ignore_map", "=", "torch", ".", "zeros_like", "(", "loc_targets", ")", "\n", "all_loc_targets", ".", "append", "(", "loc_targets", ")", "\n", "all_loc_weights", ".", "append", "(", "loc_weights", ")", "\n", "all_ignore_map", ".", "append", "(", "ignore_map", ")", "\n", "", "for", "img_id", "in", "range", "(", "img_per_gpu", ")", ":", "\n", "            ", "gt_bboxes", "=", "gt_bboxes_list", "[", "img_id", "]", "\n", "scale", "=", "torch", ".", "sqrt", "(", "(", "gt_bboxes", "[", ":", ",", "2", "]", "-", "gt_bboxes", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "gt_bboxes", "[", ":", ",", "3", "]", "-", "gt_bboxes", "[", ":", ",", "1", "]", ")", ")", "\n", "min_anchor_size", "=", "scale", ".", "new_full", "(", "\n", "(", "1", ",", ")", ",", "float", "(", "anchor_scale", "*", "anchor_strides", "[", "0", "]", ")", ")", "\n", "# assign gt bboxes to different feature levels w.r.t. their scales", "\n", "target_lvls", "=", "torch", ".", "floor", "(", "\n", "torch", ".", "log2", "(", "scale", ")", "-", "torch", ".", "log2", "(", "min_anchor_size", ")", "+", "0.5", ")", "\n", "target_lvls", "=", "target_lvls", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "num_lvls", "-", "1", ")", ".", "long", "(", ")", "\n", "for", "gt_id", "in", "range", "(", "gt_bboxes", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "lvl", "=", "target_lvls", "[", "gt_id", "]", ".", "item", "(", ")", "\n", "# rescaled to corresponding feature map", "\n", "gt_", "=", "gt_bboxes", "[", "gt_id", ",", ":", "4", "]", "/", "anchor_strides", "[", "lvl", "]", "\n", "# calculate ignore regions", "\n", "ignore_x1", ",", "ignore_y1", ",", "ignore_x2", ",", "ignore_y2", "=", "calc_region", "(", "\n", "gt_", ",", "r2", ",", "featmap_sizes", "[", "lvl", "]", ")", "\n", "# calculate positive (center) regions", "\n", "ctr_x1", ",", "ctr_y1", ",", "ctr_x2", ",", "ctr_y2", "=", "calc_region", "(", "\n", "gt_", ",", "r1", ",", "featmap_sizes", "[", "lvl", "]", ")", "\n", "all_loc_targets", "[", "lvl", "]", "[", "img_id", ",", "0", ",", "ctr_y1", ":", "ctr_y2", "+", "1", ",", "\n", "ctr_x1", ":", "ctr_x2", "+", "1", "]", "=", "1", "\n", "all_loc_weights", "[", "lvl", "]", "[", "img_id", ",", "0", ",", "ignore_y1", ":", "ignore_y2", "+", "1", ",", "\n", "ignore_x1", ":", "ignore_x2", "+", "1", "]", "=", "0", "\n", "all_loc_weights", "[", "lvl", "]", "[", "img_id", ",", "0", ",", "ctr_y1", ":", "ctr_y2", "+", "1", ",", "\n", "ctr_x1", ":", "ctr_x2", "+", "1", "]", "=", "1", "\n", "# calculate ignore map on nearby low level feature", "\n", "if", "lvl", ">", "0", ":", "\n", "                    ", "d_lvl", "=", "lvl", "-", "1", "\n", "# rescaled to corresponding feature map", "\n", "gt_", "=", "gt_bboxes", "[", "gt_id", ",", ":", "4", "]", "/", "anchor_strides", "[", "d_lvl", "]", "\n", "ignore_x1", ",", "ignore_y1", ",", "ignore_x2", ",", "ignore_y2", "=", "calc_region", "(", "\n", "gt_", ",", "r2", ",", "featmap_sizes", "[", "d_lvl", "]", ")", "\n", "all_ignore_map", "[", "d_lvl", "]", "[", "img_id", ",", "0", ",", "ignore_y1", ":", "ignore_y2", "+", "1", ",", "\n", "ignore_x1", ":", "ignore_x2", "+", "1", "]", "=", "1", "\n", "# calculate ignore map on nearby high level feature", "\n", "", "if", "lvl", "<", "num_lvls", "-", "1", ":", "\n", "                    ", "u_lvl", "=", "lvl", "+", "1", "\n", "# rescaled to corresponding feature map", "\n", "gt_", "=", "gt_bboxes", "[", "gt_id", ",", ":", "4", "]", "/", "anchor_strides", "[", "u_lvl", "]", "\n", "ignore_x1", ",", "ignore_y1", ",", "ignore_x2", ",", "ignore_y2", "=", "calc_region", "(", "\n", "gt_", ",", "r2", ",", "featmap_sizes", "[", "u_lvl", "]", ")", "\n", "all_ignore_map", "[", "u_lvl", "]", "[", "img_id", ",", "0", ",", "ignore_y1", ":", "ignore_y2", "+", "1", ",", "\n", "ignore_x1", ":", "ignore_x2", "+", "1", "]", "=", "1", "\n", "", "", "", "for", "lvl_id", "in", "range", "(", "num_lvls", ")", ":", "\n", "# ignore negative regions w.r.t. ignore map", "\n", "            ", "all_loc_weights", "[", "lvl_id", "]", "[", "(", "all_loc_weights", "[", "lvl_id", "]", "<", "0", ")", "\n", "&", "(", "all_ignore_map", "[", "lvl_id", "]", ">", "0", ")", "]", "=", "0", "\n", "# set negative regions with weight 0.1", "\n", "all_loc_weights", "[", "lvl_id", "]", "[", "all_loc_weights", "[", "lvl_id", "]", "<", "0", "]", "=", "0.1", "\n", "# loc average factor to balance loss", "\n", "", "loc_avg_factor", "=", "sum", "(", "\n", "[", "t", ".", "size", "(", "0", ")", "*", "t", ".", "size", "(", "-", "1", ")", "*", "t", ".", "size", "(", "-", "2", ")", "\n", "for", "t", "in", "all_loc_targets", "]", ")", "/", "200", "\n", "return", "all_loc_targets", ",", "all_loc_weights", ",", "loc_avg_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead._ga_shape_target_single": [[482, 544], ["inside_flags[].expand().reshape", "guided_anchor_head.GuidedAnchorHead.ga_assigner.assign", "guided_anchor_head.GuidedAnchorHead.ga_sampler.sample", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "inside_flags.any", "len", "flat_squares.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "inside_flags[].expand"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "_ga_shape_target_single", "(", "self", ",", "\n", "flat_approxs", ",", "\n", "inside_flags", ",", "\n", "flat_squares", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "img_meta", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute guided anchoring targets.\n\n        This function returns sampled anchors and gt bboxes directly\n        rather than calculates regression targets.\n\n        Args:\n            flat_approxs (Tensor): flat approxs of a single image,\n                shape (n, 4)\n            inside_flags (Tensor): inside flags of a single image,\n                shape (n, ).\n            flat_squares (Tensor): flat squares of a single image,\n                shape (approxs_per_octave * n, 4)\n            gt_bboxes (Tensor): Ground truth bboxes of a single image.\n            img_meta (dict): Meta info of a single image.\n            approxs_per_octave (int): number of approxs per octave\n            cfg (dict): RPN train configs.\n            unmap_outputs (bool): unmap outputs or not.\n\n        Returns:\n            tuple\n        \"\"\"", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "5", "\n", "# assign gt and sample anchors", "\n", "", "expand_inside_flags", "=", "inside_flags", "[", ":", ",", "None", "]", ".", "expand", "(", "\n", "-", "1", ",", "self", ".", "approxs_per_octave", ")", ".", "reshape", "(", "-", "1", ")", "\n", "approxs", "=", "flat_approxs", "[", "expand_inside_flags", ",", ":", "]", "\n", "squares", "=", "flat_squares", "[", "inside_flags", ",", ":", "]", "\n", "\n", "assign_result", "=", "self", ".", "ga_assigner", ".", "assign", "(", "approxs", ",", "squares", ",", "\n", "self", ".", "approxs_per_octave", ",", "\n", "gt_bboxes", ",", "gt_bboxes_ignore", ")", "\n", "sampling_result", "=", "self", ".", "ga_sampler", ".", "sample", "(", "assign_result", ",", "squares", ",", "\n", "gt_bboxes", ")", "\n", "\n", "bbox_anchors", "=", "torch", ".", "zeros_like", "(", "squares", ")", "\n", "bbox_gts", "=", "torch", ".", "zeros_like", "(", "squares", ")", "\n", "bbox_weights", "=", "torch", ".", "zeros_like", "(", "squares", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "bbox_anchors", "[", "pos_inds", ",", ":", "]", "=", "sampling_result", ".", "pos_bboxes", "\n", "bbox_gts", "[", "pos_inds", ",", ":", "]", "=", "sampling_result", ".", "pos_gt_bboxes", "\n", "bbox_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "\n", "# map up to original set of anchors", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_squares", ".", "size", "(", "0", ")", "\n", "bbox_anchors", "=", "unmap", "(", "bbox_anchors", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_gts", "=", "unmap", "(", "bbox_gts", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_weights", "=", "unmap", "(", "bbox_weights", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "\n", "", "return", "(", "bbox_anchors", ",", "bbox_gts", ",", "bbox_weights", ",", "pos_inds", ",", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.ga_shape_targets": [[545, 610], ["len", "range", "mmdet.core.multi_apply", "any", "sum", "sum", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "len", "len", "len", "squares.size", "inside_flag_flat_list.append", "approx_flat_list.append", "square_flat_list.append", "len", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "max", "max", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels"], ["", "def", "ga_shape_targets", "(", "self", ",", "\n", "approx_list", ",", "\n", "inside_flag_list", ",", "\n", "square_list", ",", "\n", "gt_bboxes_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "None", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute guided anchoring targets.\n\n        Args:\n            approx_list (list[list]): Multi level approxs of each image.\n            inside_flag_list (list[list]): Multi level inside flags of each\n                image.\n            square_list (list[list]): Multi level squares of each image.\n            gt_bboxes_list (list[Tensor]): Ground truth bboxes of each image.\n            img_metas (list[dict]): Meta info of each image.\n            gt_bboxes_ignore_list (list[Tensor]): ignore list of gt bboxes.\n            unmap_outputs (bool): unmap outputs or not.\n\n        Returns:\n            tuple\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "assert", "len", "(", "approx_list", ")", "==", "len", "(", "inside_flag_list", ")", "==", "len", "(", "\n", "square_list", ")", "==", "num_imgs", "\n", "# anchor number of multi levels", "\n", "num_level_squares", "=", "[", "squares", ".", "size", "(", "0", ")", "for", "squares", "in", "square_list", "[", "0", "]", "]", "\n", "# concat all level anchors and flags to a single tensor", "\n", "inside_flag_flat_list", "=", "[", "]", "\n", "approx_flat_list", "=", "[", "]", "\n", "square_flat_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assert", "len", "(", "square_list", "[", "i", "]", ")", "==", "len", "(", "inside_flag_list", "[", "i", "]", ")", "\n", "inside_flag_flat_list", ".", "append", "(", "torch", ".", "cat", "(", "inside_flag_list", "[", "i", "]", ")", ")", "\n", "approx_flat_list", ".", "append", "(", "torch", ".", "cat", "(", "approx_list", "[", "i", "]", ")", ")", "\n", "square_flat_list", ".", "append", "(", "torch", ".", "cat", "(", "square_list", "[", "i", "]", ")", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_bboxes_ignore_list", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "(", "all_bbox_anchors", ",", "all_bbox_gts", ",", "all_bbox_weights", ",", "pos_inds_list", ",", "\n", "neg_inds_list", ")", "=", "multi_apply", "(", "\n", "self", ".", "_ga_shape_target_single", ",", "\n", "approx_flat_list", ",", "\n", "inside_flag_flat_list", ",", "\n", "square_flat_list", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_bboxes_ignore_list", ",", "\n", "img_metas", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "# no valid anchors", "\n", "if", "any", "(", "[", "bbox_anchors", "is", "None", "for", "bbox_anchors", "in", "all_bbox_anchors", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled anchors of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "# split targets to a list w.r.t. multiple levels", "\n", "bbox_anchors_list", "=", "images_to_levels", "(", "all_bbox_anchors", ",", "\n", "num_level_squares", ")", "\n", "bbox_gts_list", "=", "images_to_levels", "(", "all_bbox_gts", ",", "num_level_squares", ")", "\n", "bbox_weights_list", "=", "images_to_levels", "(", "all_bbox_weights", ",", "\n", "num_level_squares", ")", "\n", "return", "(", "bbox_anchors_list", ",", "bbox_gts_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.loss_shape_single": [[611, 634], ["shape_pred.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "bbox_anchors.contiguous().view.contiguous().view.contiguous().view", "bbox_gts.contiguous().view.contiguous().view.contiguous().view", "anchor_weights.contiguous().view.contiguous().view.contiguous().view", "bbox_anchors.contiguous().view.contiguous().view.new_full", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "guided_anchor_head.GuidedAnchorHead.anchor_coder.decode", "guided_anchor_head.GuidedAnchorHead.loss_shape", "bbox_anchors.contiguous().view.contiguous().view.size", "shape_pred.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "bbox_anchors.contiguous().view.contiguous().view.contiguous", "bbox_gts.contiguous().view.contiguous().view.contiguous", "anchor_weights.contiguous().view.contiguous().view.contiguous", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "shape_pred.permute().contiguous().view.permute().contiguous().view.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "loss_shape_single", "(", "self", ",", "shape_pred", ",", "bbox_anchors", ",", "bbox_gts", ",", "\n", "anchor_weights", ",", "anchor_total_num", ")", ":", "\n", "        ", "shape_pred", "=", "shape_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "bbox_anchors", "=", "bbox_anchors", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "bbox_gts", "=", "bbox_gts", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "anchor_weights", "=", "anchor_weights", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "bbox_deltas", "=", "bbox_anchors", ".", "new_full", "(", "bbox_anchors", ".", "size", "(", ")", ",", "0", ")", "\n", "bbox_deltas", "[", ":", ",", "2", ":", "]", "+=", "shape_pred", "\n", "# filter out negative samples to speed-up weighted_bounded_iou_loss", "\n", "inds", "=", "torch", ".", "nonzero", "(", "\n", "anchor_weights", "[", ":", ",", "0", "]", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "1", ")", "\n", "bbox_deltas_", "=", "bbox_deltas", "[", "inds", "]", "\n", "bbox_anchors_", "=", "bbox_anchors", "[", "inds", "]", "\n", "bbox_gts_", "=", "bbox_gts", "[", "inds", "]", "\n", "anchor_weights_", "=", "anchor_weights", "[", "inds", "]", "\n", "pred_anchors_", "=", "self", ".", "anchor_coder", ".", "decode", "(", "\n", "bbox_anchors_", ",", "bbox_deltas_", ",", "wh_ratio_clip", "=", "1e-6", ")", "\n", "loss_shape", "=", "self", ".", "loss_shape", "(", "\n", "pred_anchors_", ",", "\n", "bbox_gts_", ",", "\n", "anchor_weights_", ",", "\n", "avg_factor", "=", "anchor_total_num", ")", "\n", "return", "loss_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.loss_loc_single": [[635, 643], ["guided_anchor_head.GuidedAnchorHead.loss_loc", "loc_pred.reshape", "loc_target.reshape().long", "loc_weight.reshape", "loc_target.reshape"], "methods", ["None"], ["", "def", "loss_loc_single", "(", "self", ",", "loc_pred", ",", "loc_target", ",", "loc_weight", ",", "\n", "loc_avg_factor", ")", ":", "\n", "        ", "loss_loc", "=", "self", ".", "loss_loc", "(", "\n", "loc_pred", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "loc_target", ".", "reshape", "(", "-", "1", ")", ".", "long", "(", ")", ",", "\n", "loc_weight", ".", "reshape", "(", "-", "1", ")", ",", "\n", "avg_factor", "=", "loc_avg_factor", ")", "\n", "return", "loss_loc", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.loss": [[644, 749], ["mmdet.core.force_fp32", "guided_anchor_head.GuidedAnchorHead.ga_loc_targets", "guided_anchor_head.GuidedAnchorHead.get_sampled_approxs", "guided_anchor_head.GuidedAnchorHead.get_anchors", "guided_anchor_head.GuidedAnchorHead.ga_shape_targets", "guided_anchor_head.GuidedAnchorHead.get_targets", "range", "mmdet.core.images_to_levels", "mmdet.core.multi_apply", "range", "range", "dict", "len", "anchors.size", "len", "concat_anchor_list.append", "len", "guided_anchor_head.GuidedAnchorHead.loss_loc_single", "losses_loc.append", "len", "guided_anchor_head.GuidedAnchorHead.loss_shape_single", "losses_shape.append", "featmap.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.ga_loc_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.get_sampled_approxs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.ga_shape_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.loss_loc_single", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.loss_shape_single"], ["", "@", "force_fp32", "(", "\n", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'shape_preds'", ",", "'loc_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "approx_anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "# get loc targets", "\n", "loc_targets", ",", "loc_weights", ",", "loc_avg_factor", "=", "self", ".", "ga_loc_targets", "(", "\n", "gt_bboxes", ",", "featmap_sizes", ")", "\n", "\n", "# get sampled approxes", "\n", "approxs_list", ",", "inside_flag_list", "=", "self", ".", "get_sampled_approxs", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "# get squares and guided anchors", "\n", "squares_list", ",", "guided_anchors_list", ",", "_", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "shape_preds", ",", "loc_preds", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "\n", "# get shape targets", "\n", "shape_targets", "=", "self", ".", "ga_shape_targets", "(", "approxs_list", ",", "inside_flag_list", ",", "\n", "squares_list", ",", "gt_bboxes", ",", "\n", "img_metas", ")", "\n", "if", "shape_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "bbox_anchors_list", ",", "bbox_gts_list", ",", "anchor_weights_list", ",", "anchor_fg_num", ",", "\n", "anchor_bg_num", ")", "=", "shape_targets", "\n", "anchor_total_num", "=", "(", "\n", "anchor_fg_num", "if", "not", "self", ".", "ga_sampling", "else", "anchor_fg_num", "+", "\n", "anchor_bg_num", ")", "\n", "\n", "# get anchor targets", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "guided_anchors_list", ",", "\n", "inside_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "num_total_samples", "=", "(", "\n", "num_total_pos", "+", "num_total_neg", "if", "self", ".", "sampling", "else", "num_total_pos", ")", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "\n", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "guided_anchors_list", "[", "0", "]", "\n", "]", "\n", "# concat all level anchors to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "guided_anchors_list", ")", ")", ":", "\n", "            ", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "guided_anchors_list", "[", "i", "]", ")", ")", "\n", "", "all_anchor_list", "=", "images_to_levels", "(", "concat_anchor_list", ",", "\n", "num_level_anchors", ")", "\n", "\n", "# get classification and bbox regression losses", "\n", "losses_cls", ",", "losses_bbox", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "all_anchor_list", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "\n", "# get anchor location loss", "\n", "losses_loc", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "loc_preds", ")", ")", ":", "\n", "            ", "loss_loc", "=", "self", ".", "loss_loc_single", "(", "\n", "loc_preds", "[", "i", "]", ",", "\n", "loc_targets", "[", "i", "]", ",", "\n", "loc_weights", "[", "i", "]", ",", "\n", "loc_avg_factor", "=", "loc_avg_factor", ")", "\n", "losses_loc", ".", "append", "(", "loss_loc", ")", "\n", "\n", "# get anchor shape loss", "\n", "", "losses_shape", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "shape_preds", ")", ")", ":", "\n", "            ", "loss_shape", "=", "self", ".", "loss_shape_single", "(", "\n", "shape_preds", "[", "i", "]", ",", "\n", "bbox_anchors_list", "[", "i", "]", ",", "\n", "bbox_gts_list", "[", "i", "]", ",", "\n", "anchor_weights_list", "[", "i", "]", ",", "\n", "anchor_total_num", "=", "anchor_total_num", ")", "\n", "losses_shape", ".", "append", "(", "loss_shape", ")", "\n", "\n", "", "return", "dict", "(", "\n", "loss_cls", "=", "losses_cls", ",", "\n", "loss_bbox", "=", "losses_bbox", ",", "\n", "loss_shape", "=", "losses_shape", ",", "\n", "loss_loc", "=", "losses_loc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead.get_bboxes": [[750, 795], ["mmdet.core.force_fp32", "len", "guided_anchor_head.GuidedAnchorHead.get_anchors", "range", "len", "len", "len", "len", "len", "guided_anchor_head.GuidedAnchorHead._get_bboxes_single", "result_list.append", "featmap.size", "[].detach", "[].detach", "[].detach", "[].detach", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "@", "force_fp32", "(", "\n", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'shape_preds'", ",", "'loc_preds'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "shape_preds", ")", "==", "len", "(", "\n", "loc_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "# get guided anchors", "\n", "_", ",", "guided_anchors", ",", "loc_masks", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "img_metas", ",", "\n", "use_loc_filter", "=", "not", "self", ".", "training", ",", "\n", "device", "=", "device", ")", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "guided_anchor_list", "=", "[", "\n", "guided_anchors", "[", "img_id", "]", "[", "i", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "loc_mask_list", "=", "[", "\n", "loc_masks", "[", "img_id", "]", "[", "i", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "proposals", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "bbox_pred_list", ",", "\n", "guided_anchor_list", ",", "\n", "loc_mask_list", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ")", "\n", "result_list", ".", "append", "(", "proposals", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.guided_anchor_head.GuidedAnchorHead._get_bboxes_single": [[796, 865], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "len", "len", "len", "cls_score.permute().reshape.permute().reshape.permute().reshape", "bbox_pred.unsqueeze.unsqueeze.permute().reshape", "cfg.get", "guided_anchor_head.GuidedAnchorHead.bbox_coder.decode", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask.sum", "cls_score.permute().reshape.permute().reshape.sigmoid", "cls_score.permute().reshape.permute().reshape.softmax", "scores.unsqueeze.unsqueeze.dim", "anchors.unsqueeze.unsqueeze.unsqueeze", "scores.unsqueeze.unsqueeze.unsqueeze", "bbox_pred.unsqueeze.unsqueeze.unsqueeze", "max_scores.topk", "cls_score.permute().reshape.permute().reshape.size", "bbox_pred.unsqueeze.unsqueeze.size", "cls_score.permute().reshape.permute().reshape.permute", "bbox_pred.unsqueeze.unsqueeze.permute", "scores.unsqueeze.unsqueeze.max", "scores[].max"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "mlvl_anchors", ",", "\n", "mlvl_masks", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "mlvl_anchors", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "anchors", ",", "mask", "in", "zip", "(", "cls_scores", ",", "bbox_preds", ",", "\n", "mlvl_anchors", ",", "\n", "mlvl_masks", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "# if no location is kept, end.", "\n", "if", "mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# reshape scores and bbox_pred", "\n", "", "cls_score", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "\n", "0", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "scores", "=", "cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "scores", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "\n", "", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "# filter scores, bbox_pred w.r.t. mask.", "\n", "# anchors are filtered in get_anchors() beforehand.", "\n", "scores", "=", "scores", "[", "mask", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "mask", ",", ":", "]", "\n", "if", "scores", ".", "dim", "(", ")", "==", "0", ":", "\n", "                ", "anchors", "=", "anchors", ".", "unsqueeze", "(", "0", ")", "\n", "scores", "=", "scores", ".", "unsqueeze", "(", "0", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "unsqueeze", "(", "0", ")", "\n", "# filter anchors, bbox_pred, scores w.r.t. scores", "\n", "", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "                ", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                    ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "                    ", "max_scores", ",", "_", "=", "scores", "[", ":", ",", ":", "-", "1", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "", "bboxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "anchors", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "            ", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "# multi class NMS", "\n", "", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "mlvl_bboxes", ",", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead.__init__": [[35, 81], ["dict", "isinstance", "isinstance", "isinstance", "isinstance", "anchor_head.AnchorHead.__init__", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "stacked_mask_convs", "=", "1", ",", "\n", "stacked_stuff_convs", "=", "4", ",", "\n", "dcn_cls_convs_idx", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "\n", "dcn_reg_convs_idx", "=", "None", ",", "\n", "dcn_mask_convs_idx", "=", "[", "0", "]", ",", "\n", "dcn_stuff_convs_idx", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "4", ",", "\n", "scales_per_octave", "=", "3", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "# mask and stuff sub-networks", "\n", "self", ".", "stacked_mask_convs", "=", "stacked_mask_convs", "\n", "self", ".", "stacked_stuff_convs", "=", "stacked_stuff_convs", "\n", "# deformable convs", "\n", "self", ".", "dcn_cls_convs_idx", "=", "dcn_cls_convs_idx", "if", "dcn_cls_convs_idx", "is", "not", "None", "else", "[", "]", "\n", "self", ".", "dcn_reg_convs_idx", "=", "dcn_reg_convs_idx", "if", "dcn_reg_convs_idx", "is", "not", "None", "else", "[", "]", "\n", "self", ".", "dcn_mask_convs_idx", "=", "dcn_mask_convs_idx", "if", "dcn_mask_convs_idx", "is", "not", "None", "else", "[", "]", "\n", "self", ".", "dcn_stuff_convs_idx", "=", "dcn_stuff_convs_idx", "if", "dcn_stuff_convs_idx", "is", "not", "None", "else", "[", "]", "\n", "assert", "isinstance", "(", "self", ".", "dcn_cls_convs_idx", ",", "list", ")", "\n", "assert", "isinstance", "(", "self", ".", "dcn_reg_convs_idx", ",", "list", ")", "\n", "assert", "isinstance", "(", "self", ".", "dcn_mask_convs_idx", ",", "list", ")", "\n", "assert", "isinstance", "(", "self", ".", "dcn_stuff_convs_idx", ",", "list", ")", "\n", "self", ".", "with_cls_dcn", "=", "len", "(", "self", ".", "dcn_cls_convs_idx", ")", ">", "0", "\n", "self", ".", "with_reg_dcn", "=", "len", "(", "self", ".", "dcn_reg_convs_idx", ")", ">", "0", "\n", "self", ".", "with_mask_dcn", "=", "len", "(", "self", ".", "dcn_mask_convs_idx", ")", ">", "0", "\n", "self", ".", "with_stuff_dcn", "=", "len", "(", "self", ".", "dcn_stuff_convs_idx", ")", ">", "0", "\n", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "super", "(", "SpatialFlowHead", ",", "self", ")", ".", "__init__", "(", "\n", "num_classes", ",", "in_channels", ",", "\n", "anchor_generator", "=", "anchor_generator", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead._init_layers": [[82, 227], ["torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "range", "range", "range", "range", "range", "min", "range", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "spatialflow_head.SpatialFlowHead.cls_convs.append", "spatialflow_head.SpatialFlowHead.reg_convs.append", "spatialflow_head.SpatialFlowHead.mask_convs.append", "spatialflow_head.SpatialFlowHead.stuff_convs.append", "spatialflow_head.SpatialFlowHead.cls_spatial_flow_convs.append", "spatialflow_head.SpatialFlowHead.mask_spatial_flow_convs.append", "spatialflow_head.SpatialFlowHead.stuff_spatial_flow_convs.append", "spatialflow_head.SpatialFlowHead.stuff_mask_flow_convs.append", "dict", "mmcv.cnn.ConvModule", "dict", "mmcv.cnn.ConvModule", "dict", "mmcv.cnn.ConvModule", "dict", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "mask_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "stuff_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "cls_spatial_flow_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "mask_spatial_flow_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "stuff_spatial_flow_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "stuff_mask_flow_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "# cls and reg sub-networks", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "# cls sub-net", "\n", "if", "self", ".", "with_cls_dcn", "and", "i", "in", "self", ".", "dcn_cls_convs_idx", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'ModulatedDeformConv'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "# reg sub-net", "\n", "if", "self", ".", "with_reg_dcn", "and", "i", "in", "self", ".", "dcn_reg_convs_idx", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'ModulatedDeformConvPack'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "\n", "# mask sub-net", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_mask_convs", ")", ":", "\n", "            ", "if", "self", ".", "with_mask_dcn", "and", "i", "in", "self", ".", "dcn_mask_convs_idx", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'ModulatedDeformConv'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "mask_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "\n", "# stuff sub-net", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_stuff_convs", ")", ":", "\n", "            ", "if", "self", ".", "with_stuff_dcn", "and", "i", "in", "self", ".", "dcn_stuff_convs_idx", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'ModulatedDeformConv'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "stuff_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "\n", "# information flows", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "if", "self", ".", "with_cls_dcn", "and", "i", "in", "self", ".", "dcn_cls_convs_idx", ":", "\n", "                ", "out_channels", "=", "3", "*", "9", "\n", "", "else", ":", "\n", "                ", "out_channels", "=", "self", ".", "feat_channels", "\n", "", "self", ".", "cls_spatial_flow_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_mask_convs", ")", ":", "\n", "            ", "if", "self", ".", "with_mask_dcn", "and", "i", "in", "self", ".", "dcn_mask_convs_idx", ":", "\n", "                ", "out_channels", "=", "3", "*", "9", "\n", "", "else", ":", "\n", "                ", "out_channels", "=", "self", ".", "feat_channels", "\n", "", "self", ".", "mask_spatial_flow_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_stuff_convs", ")", ":", "\n", "            ", "if", "self", ".", "with_stuff_dcn", "and", "i", "in", "self", ".", "dcn_stuff_convs_idx", ":", "\n", "                ", "out_channels", "=", "3", "*", "9", "\n", "", "else", ":", "\n", "                ", "out_channels", "=", "self", ".", "feat_channels", "\n", "", "self", ".", "stuff_spatial_flow_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", ")", "\n", "\n", "", "stuff_mask_flow_stacked_convs", "=", "min", "(", "self", ".", "stacked_mask_convs", ",", "\n", "self", ".", "stacked_stuff_convs", ")", "\n", "for", "i", "in", "range", "(", "stuff_mask_flow_stacked_convs", ")", ":", "\n", "            ", "self", ".", "stuff_mask_flow_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", ")", "\n", "\n", "# retina cls and reg", "\n", "", "self", ".", "retina_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "retina_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead.init_weights": [[228, 248], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "mask_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "stuff_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "cls_spatial_flow_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "mask_spatial_flow_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "stuff_spatial_flow_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "stuff_mask_flow_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "retina_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead.forward_single_bbox": [[249, 270], ["zip", "spatialflow_head.SpatialFlowHead.retina_cls", "spatialflow_head.SpatialFlowHead.retina_reg", "range", "reg_conv", "cls_spatial_flow_conv", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "cls_conv", "cls_conv", "cls_spatial_flow_conv"], "methods", ["None"], ["", "def", "forward_single_bbox", "(", "self", ",", "x", ")", ":", "\n", "        ", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "i", ",", "cls_conv", ",", "reg_conv", ",", "cls_spatial_flow_conv", "in", "zip", "(", "\n", "range", "(", "self", ".", "stacked_convs", ")", ",", "self", ".", "cls_convs", ",", "self", ".", "reg_convs", ",", "\n", "self", ".", "cls_spatial_flow_convs", ")", ":", "\n", "# reg subnet", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "\n", "# cls subnet", "\n", "if", "self", ".", "with_cls_dcn", "and", "i", "in", "self", ".", "dcn_cls_convs_idx", ":", "\n", "                ", "out", "=", "cls_spatial_flow_conv", "(", "cls_feat", "+", "reg_feat", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "cls_feat", "=", "cls_conv", "(", "cls_feat", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "                ", "cls_feat", "=", "cls_conv", "(", "cls_feat", "+", "cls_spatial_flow_conv", "(", "reg_feat", ")", ")", "\n", "", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ")", "\n", "bbox_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead.forward_single_bbox_stuff": [[271, 331], ["zip", "spatialflow_head.SpatialFlowHead.retina_cls", "spatialflow_head.SpatialFlowHead.retina_reg", "range", "reg_conv", "cls_spatial_flow_conv", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "cls_conv", "cls_conv", "stuff_spatial_flow_conv", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "stuff_conv", "stuff_conv", "mask_spatial_flow_conv", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "mask_conv", "mask_conv", "cls_spatial_flow_conv", "stuff_spatial_flow_conv", "stuff_mask_flow_conv", "stuff_mask_flow_conv", "mask_spatial_flow_conv"], "methods", ["None"], ["", "def", "forward_single_bbox_stuff", "(", "self", ",", "x", ")", ":", "\n", "        ", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "mask_feat", "=", "x", "\n", "stuff_feat", "=", "x", "\n", "for", "i", ",", "cls_conv", ",", "reg_conv", ",", "cls_spatial_flow_conv", "in", "zip", "(", "\n", "range", "(", "self", ".", "stacked_convs", ")", ",", "self", ".", "cls_convs", ",", "self", ".", "reg_convs", ",", "\n", "self", ".", "cls_spatial_flow_convs", ")", ":", "\n", "# reg subnet", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "\n", "# cls subnet", "\n", "if", "self", ".", "with_cls_dcn", "and", "i", "in", "self", ".", "dcn_cls_convs_idx", ":", "\n", "                ", "out", "=", "cls_spatial_flow_conv", "(", "cls_feat", "+", "reg_feat", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "cls_feat", "=", "cls_conv", "(", "cls_feat", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "                ", "cls_feat", "=", "cls_conv", "(", "cls_feat", "+", "cls_spatial_flow_conv", "(", "reg_feat", ")", ")", "\n", "\n", "# stuff subnet", "\n", "", "stuff_conv", "=", "self", ".", "stuff_convs", "[", "i", "]", "\n", "stuff_spatial_flow_conv", "=", "self", ".", "stuff_spatial_flow_convs", "[", "i", "]", "\n", "\n", "if", "self", ".", "with_stuff_dcn", "and", "i", "in", "self", ".", "dcn_stuff_convs_idx", ":", "\n", "                ", "out", "=", "stuff_spatial_flow_conv", "(", "stuff_feat", "+", "reg_feat", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "stuff_feat", "=", "stuff_conv", "(", "stuff_feat", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "                ", "stuff_feat", "=", "stuff_conv", "(", "stuff_feat", "+", "\n", "stuff_spatial_flow_conv", "(", "reg_feat", ")", ")", "\n", "\n", "# mask subnet", "\n", "", "mask_idx", "=", "self", ".", "stacked_convs", "-", "i", "-", "1", "\n", "if", "mask_idx", "==", "0", ":", "\n", "# NOTE: one only conv in mask sub-net", "\n", "                ", "mask_conv", "=", "self", ".", "mask_convs", "[", "0", "]", "\n", "mask_spatial_flow_conv", "=", "self", ".", "mask_spatial_flow_convs", "[", "0", "]", "\n", "stuff_mask_flow_conv", "=", "self", ".", "stuff_mask_flow_convs", "[", "0", "]", "\n", "\n", "if", "self", ".", "with_mask_dcn", "and", "mask_idx", "in", "self", ".", "dcn_mask_convs_idx", ":", "\n", "                    ", "out", "=", "mask_spatial_flow_conv", "(", "mask_feat", "+", "reg_feat", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "mask_feat", "=", "mask_feat", "+", "stuff_mask_flow_conv", "(", "\n", "stuff_feat", ")", "\n", "mask_feat", "=", "mask_conv", "(", "mask_feat", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "                    ", "mask_feat", "=", "mask_feat", "+", "stuff_mask_flow_conv", "(", "\n", "stuff_feat", ")", "\n", "mask_feat", "=", "mask_conv", "(", "mask_feat", "+", "\n", "mask_spatial_flow_conv", "(", "reg_feat", ")", ")", "\n", "", "", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ")", "\n", "bbox_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "stuff_feat", ",", "mask_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.spatialflow_head.SpatialFlowHead.forward": [[332, 348], ["mmdet.core.multi_apply", "cls_score_list.extend", "bbox_pred_list.extend", "mmdet.core.multi_apply", "cls_score_list.extend", "bbox_pred_list.extend", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "cls_score_list", "=", "[", "]", "\n", "bbox_pred_list", "=", "[", "]", "\n", "(", "cls_score_list1", ",", "bbox_pred_list1", ",", "stuff_feat_list", ",", "\n", "mask_feats_list", ")", "=", "multi_apply", "(", "\n", "self", ".", "forward_single_bbox_stuff", ",", "feats", "[", ":", "3", "]", ")", "\n", "cls_score_list", ".", "extend", "(", "cls_score_list1", ")", "\n", "bbox_pred_list", ".", "extend", "(", "bbox_pred_list1", ")", "\n", "\n", "cls_score_list2", ",", "bbox_pred_list2", "=", "multi_apply", "(", "\n", "self", ".", "forward_single_bbox", ",", "feats", "[", "3", ":", "]", ")", "\n", "cls_score_list", ".", "extend", "(", "cls_score_list2", ")", "\n", "bbox_pred_list", ".", "extend", "(", "bbox_pred_list2", ")", "\n", "\n", "return", "(", "cls_score_list", ",", "bbox_pred_list", ",", "\n", "tuple", "(", "stuff_feat_list", ")", ",", "tuple", "(", "mask_feats_list", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.pisa_ssd_head.PISASSDHead.loss": [[13, 140], ["pisa_ssd_head.PISASSDHead.get_anchors", "pisa_ssd_head.PISASSDHead.get_targets", "len", "torch.cat", "torch.cat().view", "torch.cat().view", "torch.cat", "torch.cat().view", "torch.cat().view", "range", "pisa_ssd_head.PISASSDHead.train_cfg.get", "pisa_ssd_head.PISASSDHead.train_cfg.get", "torch.isfinite().all().item", "torch.isfinite().all().item", "mmdet.core.multi_apply", "dict", "len", "all_anchors.append", "new_labels.view.view", "new_label_weights.view.view", "new_bbox_targets.view.view", "new_bbox_weights.view.view", "losses.isr_p", "new_labels.view", "new_label_weights.view", "new_bbox_targets.view", "new_bbox_weights.view", "losses.carl_loss", "dict.update", "featmap.size", "s.permute().reshape", "torch.cat", "torch.cat", "b.permute().reshape", "torch.cat", "torch.cat", "torch.cat", "torch.cat.view", "torch.cat.view", "torch.cat", "torch.cat.view", "torch.cat.view", "losses.SmoothL1Loss", "torch.isfinite().all", "torch.isfinite().all", "torch.cat.size", "losses.CrossEntropyLoss", "torch.cat.size", "s.permute", "b.permute", "torch.isfinite", "torch.isfinite"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.isr_p", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.carl_loss"], ["    ", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): Ground truth bboxes of each image\n                with shape (num_obj, 4).\n            gt_labels (list[Tensor]): Ground truth labels of each image\n                with shape (num_obj, 4).\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (list[Tensor]): Ignored gt bboxes of each image.\n                Default: None.\n\n        Returns:\n            dict: Loss dict, comprise classification loss regression loss and\n                carl loss.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "False", ",", "\n", "return_sampling_results", "=", "True", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ",", "sampling_results_list", ")", "=", "cls_reg_targets", "\n", "\n", "num_images", "=", "len", "(", "img_metas", ")", "\n", "all_cls_scores", "=", "torch", ".", "cat", "(", "[", "\n", "s", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "\n", "num_images", ",", "-", "1", ",", "self", ".", "cls_out_channels", ")", "for", "s", "in", "cls_scores", "\n", "]", ",", "1", ")", "\n", "all_labels", "=", "torch", ".", "cat", "(", "labels_list", ",", "-", "1", ")", ".", "view", "(", "num_images", ",", "-", "1", ")", "\n", "all_label_weights", "=", "torch", ".", "cat", "(", "label_weights_list", ",", "\n", "-", "1", ")", ".", "view", "(", "num_images", ",", "-", "1", ")", "\n", "all_bbox_preds", "=", "torch", ".", "cat", "(", "[", "\n", "b", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "for", "b", "in", "bbox_preds", "\n", "]", ",", "-", "2", ")", "\n", "all_bbox_targets", "=", "torch", ".", "cat", "(", "bbox_targets_list", ",", "\n", "-", "2", ")", ".", "view", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "all_bbox_weights", "=", "torch", ".", "cat", "(", "bbox_weights_list", ",", "\n", "-", "2", ")", ".", "view", "(", "num_images", ",", "-", "1", ",", "4", ")", "\n", "\n", "# concat all level anchors to a single tensor", "\n", "all_anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "all_anchors", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "\n", "", "isr_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'isr'", ",", "None", ")", "\n", "all_targets", "=", "(", "all_labels", ".", "view", "(", "-", "1", ")", ",", "all_label_weights", ".", "view", "(", "-", "1", ")", ",", "\n", "all_bbox_targets", ".", "view", "(", "-", "1", ",", "\n", "4", ")", ",", "all_bbox_weights", ".", "view", "(", "-", "1", ",", "4", ")", ")", "\n", "# apply ISR-P", "\n", "if", "isr_cfg", "is", "not", "None", ":", "\n", "            ", "all_targets", "=", "isr_p", "(", "\n", "all_cls_scores", ".", "view", "(", "-", "1", ",", "all_cls_scores", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "all_bbox_preds", ".", "view", "(", "-", "1", ",", "4", ")", ",", "\n", "all_targets", ",", "\n", "torch", ".", "cat", "(", "all_anchors", ")", ",", "\n", "sampling_results_list", ",", "\n", "loss_cls", "=", "CrossEntropyLoss", "(", ")", ",", "\n", "bbox_coder", "=", "self", ".", "bbox_coder", ",", "\n", "**", "self", ".", "train_cfg", ".", "isr", ",", "\n", "num_class", "=", "self", ".", "num_classes", ")", "\n", "(", "new_labels", ",", "new_label_weights", ",", "new_bbox_targets", ",", "\n", "new_bbox_weights", ")", "=", "all_targets", "\n", "all_labels", "=", "new_labels", ".", "view", "(", "all_labels", ".", "shape", ")", "\n", "all_label_weights", "=", "new_label_weights", ".", "view", "(", "all_label_weights", ".", "shape", ")", "\n", "all_bbox_targets", "=", "new_bbox_targets", ".", "view", "(", "all_bbox_targets", ".", "shape", ")", "\n", "all_bbox_weights", "=", "new_bbox_weights", ".", "view", "(", "all_bbox_weights", ".", "shape", ")", "\n", "\n", "# add CARL loss", "\n", "", "carl_loss_cfg", "=", "self", ".", "train_cfg", ".", "get", "(", "'carl'", ",", "None", ")", "\n", "if", "carl_loss_cfg", "is", "not", "None", ":", "\n", "            ", "loss_carl", "=", "carl_loss", "(", "\n", "all_cls_scores", ".", "view", "(", "-", "1", ",", "all_cls_scores", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "all_targets", "[", "0", "]", ",", "\n", "all_bbox_preds", ".", "view", "(", "-", "1", ",", "4", ")", ",", "\n", "all_targets", "[", "2", "]", ",", "\n", "SmoothL1Loss", "(", "beta", "=", "1.", ")", ",", "\n", "**", "self", ".", "train_cfg", ".", "carl", ",", "\n", "avg_factor", "=", "num_total_pos", ",", "\n", "num_class", "=", "self", ".", "num_classes", ")", "\n", "\n", "# check NaN and Inf", "\n", "", "assert", "torch", ".", "isfinite", "(", "all_cls_scores", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "'classification scores become infinite or NaN!'", "\n", "assert", "torch", ".", "isfinite", "(", "all_bbox_preds", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "'bbox predications become infinite or NaN!'", "\n", "\n", "losses_cls", ",", "losses_bbox", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "all_cls_scores", ",", "\n", "all_bbox_preds", ",", "\n", "all_anchors", ",", "\n", "all_labels", ",", "\n", "all_label_weights", ",", "\n", "all_bbox_targets", ",", "\n", "all_bbox_weights", ",", "\n", "num_total_samples", "=", "num_total_pos", ")", "\n", "loss_dict", "=", "dict", "(", "loss_cls", "=", "losses_cls", ",", "loss_bbox", "=", "losses_bbox", ")", "\n", "if", "carl_loss_cfg", "is", "not", "None", ":", "\n", "            ", "loss_dict", ".", "update", "(", "loss_carl", ")", "\n", "", "return", "loss_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_sepbn_head.RetinaSepBNHead.__init__": [[17, 31], ["anchor_head.AnchorHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "num_ins", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "num_ins", "=", "num_ins", "\n", "super", "(", "RetinaSepBNHead", ",", "self", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_sepbn_head.RetinaSepBNHead._init_layers": [[32, 73], ["torch.ReLU", "torch.ModuleList", "torch.ModuleList", "range", "range", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "range", "retina_sepbn_head.RetinaSepBNHead.cls_convs.append", "retina_sepbn_head.RetinaSepBNHead.reg_convs.append", "range", "torch.ModuleList.append", "torch.ModuleList.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_ins", ")", ":", "\n", "            ", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "                ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "self", ".", "cls_convs", ".", "append", "(", "cls_convs", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "reg_convs", ")", "\n", "", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "1", ",", "self", ".", "num_ins", ")", ":", "\n", "                ", "self", ".", "cls_convs", "[", "j", "]", "[", "i", "]", ".", "conv", "=", "self", ".", "cls_convs", "[", "0", "]", "[", "i", "]", ".", "conv", "\n", "self", ".", "reg_convs", "[", "j", "]", "[", "i", "]", ".", "conv", "=", "self", ".", "reg_convs", "[", "0", "]", "[", "i", "]", ".", "conv", "\n", "", "", "self", ".", "retina_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "retina_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_sepbn_head.RetinaSepBNHead.init_weights": [[74, 83], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", "[", "0", "]", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", "[", "0", "]", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "retina_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_sepbn_head.RetinaSepBNHead.forward": [[84, 114], ["enumerate", "retina_sepbn_head.RetinaSepBNHead.retina_cls", "retina_sepbn_head.RetinaSepBNHead.retina_reg", "cls_scores.append", "bbox_preds.append", "cls_conv", "reg_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: Usually a tuple of classification scores and bbox prediction\n                cls_scores (list[Tensor]): Classification scores for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * num_classes.\n                bbox_preds (list[Tensor]): Box energies / deltas for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * 4.\n        \"\"\"", "\n", "cls_scores", "=", "[", "]", "\n", "bbox_preds", "=", "[", "]", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "feats", ")", ":", "\n", "            ", "cls_feat", "=", "feats", "[", "i", "]", "\n", "reg_feat", "=", "feats", "[", "i", "]", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", "[", "i", "]", ":", "\n", "                ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", "[", "i", "]", ":", "\n", "                ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ")", "\n", "bbox_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ")", "\n", "cls_scores", ".", "append", "(", "cls_score", ")", "\n", "bbox_preds", ".", "append", "(", "bbox_pred", ")", "\n", "", "return", "cls_scores", ",", "bbox_preds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.__init__": [[40, 43], ["retina_head.RetinaHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "score_threshold", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "score_threshold", "=", "score_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.forward_single": [[44, 60], ["super().forward_single", "fsaf_head.FSAFHead.relu"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward_single"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature map of a single scale level.\n\n        Args:\n            x (Tensor): Feature map of a single scale level.\n\n        Returns:\n            tuple (Tensor):\n                cls_score (Tensor): Box scores for each scale level\n                    Has shape (N, num_points * num_classes, H, W).\n                bbox_pred (Tensor): Box energies / deltas for each scale\n                    level with shape (N, num_points * 4, H, W).\n        \"\"\"", "\n", "cls_score", ",", "bbox_pred", "=", "super", "(", ")", ".", "forward_single", "(", "x", ")", "\n", "# relu: TBLR encoder only accepts positive bbox_pred", "\n", "return", "cls_score", ",", "self", ".", "relu", "(", "bbox_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.init_weights": [[61, 67], ["super().init_weights", "mmcv.cnn.normal_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "super", "(", "FSAFHead", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "# The positive bias in self.retina_reg conv is to prevent predicted \\", "\n", "#  bbox with 0 area", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ",", "bias", "=", "0.25", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead._get_targets_single": [[68, 171], ["mmdet.core.anchor_inside_flags", "fsaf_head.FSAFHead.assigner.assign", "fsaf_head.FSAFHead.sampler.sample", "torch.zeros_like", "torch.zeros_like", "anchors.new_full", "anchors.new_zeros", "anchors.new_full", "fsaf_head.FSAFHead.get_extra_property", "mmdet.core.anchor_inside_flags.any", "len", "len", "fsaf_head.FSAFHead.get_extra_property.numel", "flat_anchors.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "fsaf_head.FSAFHead.bbox_coder.encode", "len", "int", "mmdet.core.anchor_inside_flags.type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.get_extra_property", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "_get_targets_single", "(", "self", ",", "\n", "flat_anchors", ",", "\n", "valid_flags", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "gt_labels", ",", "\n", "img_meta", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for anchors in a\n        single image.\n\n        Most of the codes are the same with the base class\n          :obj: `AnchorHead`, except that it also collects and returns\n          the matched gt index in the image (from 0 to num_gt-1). If the\n          anchor bbox is not matched to any gt, the corresponding value in\n          pos_gt_inds is -1.\n        \"\"\"", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "\n", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# Assign gt and sample anchors", "\n", "", "anchors", "=", "flat_anchors", "[", "inside_flags", ".", "type", "(", "torch", ".", "bool", ")", ",", ":", "]", "\n", "assign_result", "=", "self", ".", "assigner", ".", "assign", "(", "\n", "anchors", ",", "gt_bboxes", ",", "gt_bboxes_ignore", ",", "\n", "None", "if", "self", ".", "sampling", "else", "gt_labels", ")", "\n", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "anchors", ",", "\n", "gt_bboxes", ")", "\n", "\n", "num_valid_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "bbox_targets", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "bbox_weights", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "labels", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "anchors", ".", "new_zeros", "(", "(", "num_valid_anchors", ",", "label_channels", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ")", "\n", "pos_gt_inds", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "if", "not", "self", ".", "reg_decoded_bbox", ":", "\n", "                ", "pos_bbox_targets", "=", "self", ".", "bbox_coder", ".", "encode", "(", "\n", "sampling_result", ".", "pos_bboxes", ",", "sampling_result", ".", "pos_gt_bboxes", ")", "\n", "", "else", ":", "\n", "                ", "pos_bbox_targets", "=", "sampling_result", ".", "pos_gt_bboxes", "\n", "", "bbox_targets", "[", "pos_inds", ",", ":", "]", "=", "pos_bbox_targets", "\n", "bbox_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "# The assigned gt_index for each anchor. (0-based)", "\n", "pos_gt_inds", "[", "pos_inds", "]", "=", "sampling_result", ".", "pos_assigned_gt_inds", "\n", "if", "gt_labels", "is", "None", ":", "\n", "# only rpn gives gt_labels as None, this time FG is 1", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "self", ".", "train_cfg", ".", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "self", ".", "train_cfg", ".", "pos_weight", "\n", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# shadowed_labels is a tensor composed of tuples", "\n", "#  (anchor_inds, class_label) that indicate those anchors lying in the", "\n", "#  outer region of a gt or overlapped by another gt with a smaller", "\n", "#  area.", "\n", "#", "\n", "# Therefore, only the shadowed labels are ignored for loss calculation.", "\n", "# the key `shadowed_labels` is defined in :obj:`CenterRegionAssigner`", "\n", "", "shadowed_labels", "=", "assign_result", ".", "get_extra_property", "(", "'shadowed_labels'", ")", "\n", "if", "shadowed_labels", "is", "not", "None", "and", "shadowed_labels", ".", "numel", "(", ")", ":", "\n", "            ", "if", "len", "(", "shadowed_labels", ".", "shape", ")", "==", "2", ":", "\n", "                ", "idx_", ",", "label_", "=", "shadowed_labels", "[", ":", ",", "0", "]", ",", "shadowed_labels", "[", ":", ",", "1", "]", "\n", "assert", "(", "labels", "[", "idx_", "]", "!=", "label_", ")", ".", "all", "(", ")", ",", "'One label cannot be both positive and ignored'", "\n", "# If background_label is 0. Then all labels increase by 1", "\n", "label_", "+=", "int", "(", "self", ".", "background_label", "==", "0", ")", "\n", "label_weights", "[", "idx_", ",", "label_", "]", "=", "0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "shadowed_labels", "]", "=", "0", "\n", "\n", "# map up to original set of anchors", "\n", "", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_anchors", ".", "size", "(", "0", ")", "\n", "labels", "=", "unmap", "(", "labels", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "bbox_targets", "=", "unmap", "(", "bbox_targets", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_weights", "=", "unmap", "(", "bbox_weights", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "pos_gt_inds", "=", "unmap", "(", "\n", "pos_gt_inds", ",", "num_total_anchors", ",", "inside_flags", ",", "fill", "=", "-", "1", ")", "\n", "\n", "", "return", "(", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", ",", "pos_inds", ",", "\n", "neg_inds", ",", "sampling_result", ",", "pos_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.loss": [[172, 301], ["mmdet.core.force_fp32", "range", "len", "fsaf_head.FSAFHead.get_anchors", "fsaf_head.FSAFHead.get_targets", "numpy.array", "range", "mmdet.core.images_to_levels", "mmdet.core.multi_apply", "list", "enumerate", "sum", "torch.arange", "mmdet.core.multi_apply", "torch.cat().sum().float", "fsaf_head.FSAFHead.calculate_pos_recall", "range", "dict", "len", "bbox_preds[].clamp", "len", "list", "anchors.size", "len", "concat_anchor_list.append", "numpy.cumsum", "range", "assign.flatten", "labels_list[].flatten", "map", "torch.no_grad", "mmdet.core.multi_apply", "torch.stack", "list", "len", "featmap.size", "map", "torch.cat", "int", "torch.stack.numel", "torch.stack.new_empty", "torch.stack.min", "range", "torch.cat().sum", "float", "len", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.calculate_pos_recall", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute loss of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_points * num_classes, H, W).\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_points * 4, H, W).\n            gt_bboxes (list[Tensor]): each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "bbox_preds", ")", ")", ":", "# loop over fpn level", "\n", "# avoid 0 area of the predicted bbox", "\n", "            ", "bbox_preds", "[", "i", "]", "=", "bbox_preds", "[", "i", "]", ".", "clamp", "(", "min", "=", "1e-4", ")", "\n", "# TODO: It may directly use the base-class loss function.", "\n", "", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "batch_size", "=", "len", "(", "gt_bboxes", ")", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ",", "\n", "pos_assigned_gt_inds_list", ")", "=", "cls_reg_targets", "\n", "\n", "num_gts", "=", "np", ".", "array", "(", "list", "(", "map", "(", "len", ",", "gt_labels", ")", ")", ")", "\n", "num_total_samples", "=", "(", "\n", "num_total_pos", "+", "num_total_neg", "if", "self", ".", "sampling", "else", "num_total_pos", ")", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors and flags to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "anchor_list", ")", ")", ":", "\n", "            ", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "", "all_anchor_list", "=", "images_to_levels", "(", "concat_anchor_list", ",", "\n", "num_level_anchors", ")", "\n", "losses_cls", ",", "losses_bbox", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "all_anchor_list", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "\n", "# `pos_assigned_gt_inds_list` (length: fpn_levels) stores the assigned", "\n", "# gt index of each anchor bbox in each fpn level.", "\n", "cum_num_gts", "=", "list", "(", "np", ".", "cumsum", "(", "num_gts", ")", ")", "# length of batch_size", "\n", "for", "i", ",", "assign", "in", "enumerate", "(", "pos_assigned_gt_inds_list", ")", ":", "\n", "# loop over fpn levels", "\n", "            ", "for", "j", "in", "range", "(", "1", ",", "batch_size", ")", ":", "\n", "# loop over batch size", "\n", "# Convert gt indices in each img to those in the batch", "\n", "                ", "assign", "[", "j", "]", "[", "assign", "[", "j", "]", ">=", "0", "]", "+=", "int", "(", "cum_num_gts", "[", "j", "-", "1", "]", ")", "\n", "", "pos_assigned_gt_inds_list", "[", "i", "]", "=", "assign", ".", "flatten", "(", ")", "\n", "labels_list", "[", "i", "]", "=", "labels_list", "[", "i", "]", ".", "flatten", "(", ")", "\n", "", "num_gts", "=", "sum", "(", "map", "(", "len", ",", "gt_labels", ")", ")", "# total number of gt in the batch", "\n", "# The unique label index of each gt in the batch", "\n", "label_sequence", "=", "torch", ".", "arange", "(", "num_gts", ",", "device", "=", "device", ")", "\n", "# Collect the average loss of each gt in each level", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "loss_levels", ",", "=", "multi_apply", "(", "\n", "self", ".", "collect_loss_level_single", ",", "\n", "losses_cls", ",", "\n", "losses_bbox", ",", "\n", "pos_assigned_gt_inds_list", ",", "\n", "labels_seq", "=", "label_sequence", ")", "\n", "# Shape: (fpn_levels, num_gts). Loss of each gt at each fpn level", "\n", "loss_levels", "=", "torch", ".", "stack", "(", "loss_levels", ",", "dim", "=", "0", ")", "\n", "# Locate the best fpn level for loss back-propagation", "\n", "if", "loss_levels", ".", "numel", "(", ")", "==", "0", ":", "# zero gt", "\n", "                ", "argmin", "=", "loss_levels", ".", "new_empty", "(", "(", "num_gts", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "argmin", "=", "loss_levels", ".", "min", "(", "dim", "=", "0", ")", "\n", "\n", "# Reweight the loss of each (anchor, label) pair, so that only those", "\n", "#  at the best gt level are back-propagated.", "\n", "", "", "losses_cls", ",", "losses_bbox", ",", "pos_inds", "=", "multi_apply", "(", "\n", "self", ".", "reweight_loss_single", ",", "\n", "losses_cls", ",", "\n", "losses_bbox", ",", "\n", "pos_assigned_gt_inds_list", ",", "\n", "labels_list", ",", "\n", "list", "(", "range", "(", "len", "(", "losses_cls", ")", ")", ")", ",", "\n", "min_levels", "=", "argmin", ")", "\n", "num_pos", "=", "torch", ".", "cat", "(", "pos_inds", ",", "0", ")", ".", "sum", "(", ")", ".", "float", "(", ")", "\n", "pos_recall", "=", "self", ".", "calculate_pos_recall", "(", "cls_scores", ",", "labels_list", ",", "\n", "pos_inds", ")", "\n", "\n", "if", "num_pos", "==", "0", ":", "# No gt", "\n", "            ", "avg_factor", "=", "num_pos", "+", "float", "(", "num_total_neg", ")", "\n", "", "else", ":", "\n", "            ", "avg_factor", "=", "num_pos", "\n", "", "for", "i", "in", "range", "(", "len", "(", "losses_cls", ")", ")", ":", "\n", "            ", "losses_cls", "[", "i", "]", "/=", "avg_factor", "\n", "losses_bbox", "[", "i", "]", "/=", "avg_factor", "\n", "", "return", "dict", "(", "\n", "loss_cls", "=", "losses_cls", ",", "\n", "loss_bbox", "=", "losses_bbox", ",", "\n", "num_pos", "=", "num_pos", "/", "batch_size", ",", "\n", "pos_recall", "=", "pos_recall", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.calculate_pos_recall": [[302, 335], ["torch.no_grad", "torch.cat", "torch.cat", "losses.accuracy.accuracy", "scores.softmax.softmax.sigmoid", "scores.softmax.softmax.softmax", "cls.permute().reshape", "zip", "label.reshape", "zip", "cls.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.accuracy"], ["", "def", "calculate_pos_recall", "(", "self", ",", "cls_scores", ",", "labels_list", ",", "pos_inds", ")", ":", "\n", "        ", "\"\"\"Calculate positive recall with score threshold.\n\n        Args:\n            cls_scores (list[Tensor]): Classification scores at all fpn levels.\n                Each tensor is in shape (N, num_classes * num_anchors, H, W)\n            labels_list (list[Tensor]): The label that each anchor is assigned\n                to. Shape (N * H * W * num_anchors, )\n            pos_inds (list[Tensor]): List of bool tensors indicating whether\n                the anchor is assigned to a positive label.\n                Shape (N * H * W * num_anchors, )\n\n        Returns:\n            Tensor: A single float number indicating the positive recall.\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "num_class", "=", "self", ".", "num_classes", "\n", "scores", "=", "[", "\n", "cls", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "num_class", ")", "[", "pos", "]", "\n", "for", "cls", ",", "pos", "in", "zip", "(", "cls_scores", ",", "pos_inds", ")", "\n", "]", "\n", "labels", "=", "[", "\n", "label", ".", "reshape", "(", "-", "1", ")", "[", "pos", "]", "\n", "for", "label", ",", "pos", "in", "zip", "(", "labels_list", ",", "pos_inds", ")", "\n", "]", "\n", "scores", "=", "torch", ".", "cat", "(", "scores", ",", "dim", "=", "0", ")", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "dim", "=", "0", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "scores", "=", "scores", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "scores", "=", "scores", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "\n", "", "return", "accuracy", "(", "scores", ",", "labels", ",", "thresh", "=", "self", ".", "score_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.collect_loss_level_single": [[336, 366], ["loss.new_full", "enumerate", "len", "reg_loss.sum.sum.sum", "len", "cls_loss.sum.sum.sum", "loss.size", "assigned_gt_inds.size", "match.any", "loss[].mean"], "methods", ["None"], ["", "", "def", "collect_loss_level_single", "(", "self", ",", "cls_loss", ",", "reg_loss", ",", "assigned_gt_inds", ",", "\n", "labels_seq", ")", ":", "\n", "        ", "\"\"\"Get the average loss in each FPN level w.r.t. each gt label.\n\n        Args:\n            cls_loss (Tensor): Classification loss of each feature map pixel,\n              shape (num_anchor, num_class)\n            reg_loss (Tensor): Regression loss of each feature map pixel,\n              shape (num_anchor, 4)\n            assigned_gt_inds (Tensor): It indicates which gt the prior is\n              assigned to (0-based, -1: no assignment). shape (num_anchor),\n            labels_seq: The rank of labels. shape (num_gt)\n\n        Returns:\n            shape: (num_gt), average loss of each gt in this level\n        \"\"\"", "\n", "if", "len", "(", "reg_loss", ".", "shape", ")", "==", "2", ":", "# iou loss has shape (num_prior, 4)", "\n", "            ", "reg_loss", "=", "reg_loss", ".", "sum", "(", "dim", "=", "-", "1", ")", "# sum loss in tblr dims", "\n", "", "if", "len", "(", "cls_loss", ".", "shape", ")", "==", "2", ":", "\n", "            ", "cls_loss", "=", "cls_loss", ".", "sum", "(", "dim", "=", "-", "1", ")", "# sum loss in class dims", "\n", "", "loss", "=", "cls_loss", "+", "reg_loss", "\n", "assert", "loss", ".", "size", "(", "0", ")", "==", "assigned_gt_inds", ".", "size", "(", "0", ")", "\n", "# Default loss value is 1e6 for a layer where no anchor is positive", "\n", "#  to ensure it will not be chosen to back-propagate gradient", "\n", "losses_", "=", "loss", ".", "new_full", "(", "labels_seq", ".", "shape", ",", "1e6", ")", "\n", "for", "i", ",", "l", "in", "enumerate", "(", "labels_seq", ")", ":", "\n", "            ", "match", "=", "assigned_gt_inds", "==", "l", "\n", "if", "match", ".", "any", "(", ")", ":", "\n", "                ", "losses_", "[", "i", "]", "=", "loss", "[", "match", "]", ".", "mean", "(", ")", "\n", "", "", "return", "losses_", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fsaf_head.FSAFHead.reweight_loss_single": [[367, 419], ["torch.ones_like", "torch.ones_like", "torch.nonzero().flatten", "pos_flags.any", "losses.utils.weight_reduce_loss", "losses.utils.weight_reduce_loss", "neg_indices.numel", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss"], ["", "def", "reweight_loss_single", "(", "self", ",", "cls_loss", ",", "reg_loss", ",", "assigned_gt_inds", ",", "\n", "labels", ",", "level", ",", "min_levels", ")", ":", "\n", "        ", "\"\"\"Reweight loss values at each level.\n\n        Reassign loss values at each level by masking those where the\n        pre-calculated loss is too large. Then return the reduced losses.\n\n        Args:\n            cls_loss (Tensor): Element-wise classification loss.\n              Shape: (num_anchors, num_classes)\n            reg_loss (Tensor): Element-wise regression loss.\n              Shape: (num_anchors, 4)\n            assigned_gt_inds (Tensor): The gt indices that each anchor bbox\n              is assigned to. -1 denotes a negative anchor, otherwise it is the\n              gt index (0-based). Shape: (num_anchors, ),\n            labels (Tensor): Label assigned to anchors. Shape: (num_anchors, ).\n            level (int): The current level index in the pyramid\n              (0-4 for RetinaNet)\n            min_levels (Tensor): The best-matching level for each gt.\n              Shape: (num_gts, ),\n\n        Returns:\n            tuple:\n                - cls_loss: Reduced corrected classification loss. Scalar.\n                - reg_loss: Reduced corrected regression loss. Scalar.\n                - pos_flags (Tensor): Corrected bool tensor indicating the\n                  final postive anchors. Shape: (num_anchors, ).\n        \"\"\"", "\n", "loc_weight", "=", "torch", ".", "ones_like", "(", "reg_loss", ")", "\n", "cls_weight", "=", "torch", ".", "ones_like", "(", "cls_loss", ")", "\n", "pos_flags", "=", "assigned_gt_inds", ">=", "0", "# positive pixel flag", "\n", "pos_indices", "=", "torch", ".", "nonzero", "(", "pos_flags", ",", "as_tuple", "=", "False", ")", ".", "flatten", "(", ")", "\n", "\n", "if", "pos_flags", ".", "any", "(", ")", ":", "# pos pixels exist", "\n", "            ", "pos_assigned_gt_inds", "=", "assigned_gt_inds", "[", "pos_flags", "]", "\n", "zeroing_indices", "=", "(", "min_levels", "[", "pos_assigned_gt_inds", "]", "!=", "level", ")", "\n", "neg_indices", "=", "pos_indices", "[", "zeroing_indices", "]", "\n", "\n", "if", "neg_indices", ".", "numel", "(", ")", ":", "\n", "                ", "pos_flags", "[", "neg_indices", "]", "=", "0", "\n", "loc_weight", "[", "neg_indices", "]", "=", "0", "\n", "# Only the weight corresponding to the label is", "\n", "#  zeroed out if not selected", "\n", "zeroing_labels", "=", "labels", "[", "neg_indices", "]", "\n", "assert", "(", "zeroing_labels", ">=", "0", ")", ".", "all", "(", ")", "\n", "cls_weight", "[", "neg_indices", ",", "zeroing_labels", "]", "=", "0", "\n", "\n", "# Weighted loss for both cls and reg loss", "\n", "", "", "cls_loss", "=", "weight_reduce_loss", "(", "cls_loss", ",", "cls_weight", ",", "reduction", "=", "'sum'", ")", "\n", "reg_loss", "=", "weight_reduce_loss", "(", "reg_loss", ",", "loc_weight", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "return", "cls_loss", ",", "reg_loss", ",", "pos_flags", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.__init__": [[56, 91], ["dict", "dict", "dict", "dict", "anchor_free_head.AnchorFreeHead.__init__", "builder.build_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "regress_ranges", "=", "(", "(", "-", "1", ",", "64", ")", ",", "(", "64", ",", "128", ")", ",", "(", "128", ",", "256", ")", ",", "(", "256", ",", "512", ")", ",", "\n", "(", "512", ",", "INF", ")", ")", ",", "\n", "center_sampling", "=", "False", ",", "\n", "center_sample_radius", "=", "1.5", ",", "\n", "norm_on_bbox", "=", "False", ",", "\n", "centerness_on_reg", "=", "False", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'FocalLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "type", "=", "'IoULoss'", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_centerness", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ",", "requires_grad", "=", "True", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "regress_ranges", "=", "regress_ranges", "\n", "self", ".", "center_sampling", "=", "center_sampling", "\n", "self", ".", "center_sample_radius", "=", "center_sample_radius", "\n", "self", ".", "norm_on_bbox", "=", "norm_on_bbox", "\n", "self", ".", "centerness_on_reg", "=", "centerness_on_reg", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "loss_cls", "=", "loss_cls", ",", "\n", "loss_bbox", "=", "loss_bbox", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "loss_centerness", "=", "build_loss", "(", "loss_centerness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead._init_layers": [[92, 97], ["super()._init_layers", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "mmcv.cnn.Scale"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "super", "(", ")", ".", "_init_layers", "(", ")", "\n", "self", ".", "conv_centerness", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "1", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "scales", "=", "nn", ".", "ModuleList", "(", "[", "Scale", "(", "1.0", ")", "for", "_", "in", "self", ".", "strides", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.init_weights": [[98, 102], ["super().init_weights", "mmcv.cnn.normal_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "super", "(", ")", ".", "init_weights", "(", ")", "\n", "normal_init", "(", "self", ".", "conv_centerness", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.forward": [[103, 123], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple:\n                cls_scores (list[Tensor]): Box scores for each scale level, \\\n                    each is a 4D-tensor, the channel number is \\\n                    num_points * num_classes.\n                bbox_preds (list[Tensor]): Box energies / deltas for each \\\n                    scale level, each is a 4D-tensor, the channel number is \\\n                    num_points * 4.\n                centernesses (list[Tensor]): Centerss for each scale level, \\\n                    each is a 4D-tensor, the channel number is num_points * 1.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ",", "self", ".", "scales", ",", "\n", "self", ".", "strides", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.forward_single": [[124, 154], ["super().forward_single", "scale().float", "fcos_head.FCOSHead.conv_centerness", "fcos_head.FCOSHead.conv_centerness", "torch.relu", "torch.relu", "torch.relu", "bbox_pred.exp.exp.exp", "scale"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward_single"], ["", "def", "forward_single", "(", "self", ",", "x", ",", "scale", ",", "stride", ")", ":", "\n", "        ", "\"\"\"Forward features of a single scale levle.\n\n        Args:\n            x (Tensor): FPN feature maps of the specified stride.\n            scale (:obj: `mmcv.cnn.Scale`): Learnable scale module to resize\n                the bbox prediction.\n            stride (int): The corresponding stride for feature maps, only\n                used to normalize the bbox prediction when self.norm_on_bbox\n                is True.\n\n        Returns:\n            tuple: scores for each class, bbox predictions and centerness \\\n                predictions of input feature maps.\n        \"\"\"", "\n", "cls_score", ",", "bbox_pred", ",", "cls_feat", ",", "reg_feat", "=", "super", "(", ")", ".", "forward_single", "(", "x", ")", "\n", "if", "self", ".", "centerness_on_reg", ":", "\n", "            ", "centerness", "=", "self", ".", "conv_centerness", "(", "reg_feat", ")", "\n", "", "else", ":", "\n", "            ", "centerness", "=", "self", ".", "conv_centerness", "(", "cls_feat", ")", "\n", "# scale the bbox_pred of different level", "\n", "# float to avoid overflow when enabling FP16", "\n", "", "bbox_pred", "=", "scale", "(", "bbox_pred", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "norm_on_bbox", ":", "\n", "            ", "bbox_pred", "=", "F", ".", "relu", "(", "bbox_pred", ")", "\n", "if", "not", "self", ".", "training", ":", "\n", "                ", "bbox_pred", "*=", "stride", "\n", "", "", "else", ":", "\n", "            ", "bbox_pred", "=", "bbox_pred", ".", "exp", "(", ")", "\n", "", "return", "cls_score", ",", "bbox_pred", ",", "centerness", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.loss": [[155, 251], ["mmdet.core.force_fp32", "fcos_head.FCOSHead.get_points", "fcos_head.FCOSHead.get_targets", "cls_scores[].size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "fcos_head.FCOSHead.loss_cls", "dict", "len", "len", "len", "cls_score.permute().reshape", "bbox_pred.permute().reshape", "centerness.permute().reshape", "fcos_head.FCOSHead.centerness_target", "mmdet.core.distance2bbox", "mmdet.core.distance2bbox", "fcos_head.FCOSHead.loss_bbox", "fcos_head.FCOSHead.loss_centerness", "pos_bbox_preds.sum", "pos_centerness.sum", "featmap.size", "points.repeat", "cls_score.permute", "bbox_pred.permute", "centerness.permute", "fcos_head.FCOSHead.sum"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.centerness_target", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'centernesses'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute loss of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level,\n                each is a 4D-tensor, the channel number is\n                num_points * num_classes.\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level, each is a 4D-tensor, the channel number is\n                num_points * 4.\n            centernesses (list[Tensor]): Centerss for each scale level, each\n                is a 4D-tensor, the channel number is num_points * 1.\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "centernesses", ")", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "all_level_points", "=", "self", ".", "get_points", "(", "featmap_sizes", ",", "bbox_preds", "[", "0", "]", ".", "dtype", ",", "\n", "bbox_preds", "[", "0", "]", ".", "device", ")", "\n", "labels", ",", "bbox_targets", "=", "self", ".", "get_targets", "(", "all_level_points", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", "\n", "\n", "num_imgs", "=", "cls_scores", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "# flatten cls_scores, bbox_preds and centerness", "\n", "flatten_cls_scores", "=", "[", "\n", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "for", "cls_score", "in", "cls_scores", "\n", "]", "\n", "flatten_bbox_preds", "=", "[", "\n", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "for", "bbox_pred", "in", "bbox_preds", "\n", "]", "\n", "flatten_centerness", "=", "[", "\n", "centerness", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "for", "centerness", "in", "centernesses", "\n", "]", "\n", "flatten_cls_scores", "=", "torch", ".", "cat", "(", "flatten_cls_scores", ")", "\n", "flatten_bbox_preds", "=", "torch", ".", "cat", "(", "flatten_bbox_preds", ")", "\n", "flatten_centerness", "=", "torch", ".", "cat", "(", "flatten_centerness", ")", "\n", "flatten_labels", "=", "torch", ".", "cat", "(", "labels", ")", "\n", "flatten_bbox_targets", "=", "torch", ".", "cat", "(", "bbox_targets", ")", "\n", "# repeat points to align with bbox_preds", "\n", "flatten_points", "=", "torch", ".", "cat", "(", "\n", "[", "points", ".", "repeat", "(", "num_imgs", ",", "1", ")", "for", "points", "in", "all_level_points", "]", ")", "\n", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "bg_class_ind", "=", "self", ".", "num_classes", "\n", "pos_inds", "=", "(", "(", "flatten_labels", ">=", "0", ")", "\n", "&", "(", "flatten_labels", "<", "bg_class_ind", ")", ")", ".", "nonzero", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "num_pos", "=", "len", "(", "pos_inds", ")", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "flatten_cls_scores", ",", "flatten_labels", ",", "\n", "avg_factor", "=", "num_pos", "+", "num_imgs", ")", "# avoid num_pos is 0", "\n", "\n", "pos_bbox_preds", "=", "flatten_bbox_preds", "[", "pos_inds", "]", "\n", "pos_centerness", "=", "flatten_centerness", "[", "pos_inds", "]", "\n", "\n", "if", "num_pos", ">", "0", ":", "\n", "            ", "pos_bbox_targets", "=", "flatten_bbox_targets", "[", "pos_inds", "]", "\n", "pos_centerness_targets", "=", "self", ".", "centerness_target", "(", "pos_bbox_targets", ")", "\n", "pos_points", "=", "flatten_points", "[", "pos_inds", "]", "\n", "pos_decoded_bbox_preds", "=", "distance2bbox", "(", "pos_points", ",", "pos_bbox_preds", ")", "\n", "pos_decoded_target_preds", "=", "distance2bbox", "(", "pos_points", ",", "\n", "pos_bbox_targets", ")", "\n", "# centerness weighted iou loss", "\n", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "pos_decoded_bbox_preds", ",", "\n", "pos_decoded_target_preds", ",", "\n", "weight", "=", "pos_centerness_targets", ",", "\n", "avg_factor", "=", "pos_centerness_targets", ".", "sum", "(", ")", ")", "\n", "loss_centerness", "=", "self", ".", "loss_centerness", "(", "pos_centerness", ",", "\n", "pos_centerness_targets", ")", "\n", "", "else", ":", "\n", "            ", "loss_bbox", "=", "pos_bbox_preds", ".", "sum", "(", ")", "\n", "loss_centerness", "=", "pos_centerness", ".", "sum", "(", ")", "\n", "\n", "", "return", "dict", "(", "\n", "loss_cls", "=", "loss_cls", ",", "\n", "loss_bbox", "=", "loss_bbox", ",", "\n", "loss_centerness", "=", "loss_centerness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.get_bboxes": [[252, 309], ["mmdet.core.force_fp32", "len", "fcos_head.FCOSHead.get_points", "range", "len", "len", "len", "fcos_head.FCOSHead._get_bboxes_single", "result_list.append", "featmap.size", "[].detach", "[].detach", "[].detach", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'centernesses'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "None", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_points * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_points * 4, H, W)\n            centernesses (list[Tensor]): Centerness for each scale level with\n                shape (N, num_points * 1, H, W)\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used\n            rescale (bool): If True, return boxes in original image space\n\n        Returns:\n            list[tuple[Tensor, Tensor]]: Each item in result_list is 2-tuple. \\\n                The first item is an (n, 5) tensor, where the first 4 columns \\\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the \\\n                5-th column is a score between 0 and 1. The second item is a \\\n                (n,) tensor where each item is the predicted class label of \\\n                the corresponding box.\n        \"\"\"", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "mlvl_points", "=", "self", ".", "get_points", "(", "featmap_sizes", ",", "bbox_preds", "[", "0", "]", ".", "dtype", ",", "\n", "bbox_preds", "[", "0", "]", ".", "device", ")", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "centerness_pred_list", "=", "[", "\n", "centernesses", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "det_bboxes", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "\n", "bbox_pred_list", ",", "\n", "centerness_pred_list", ",", "\n", "mlvl_points", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ")", "\n", "result_list", ".", "append", "(", "det_bboxes", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead._get_bboxes_single": [[310, 385], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "len", "len", "len", "cls_score.permute().reshape().sigmoid", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute().reshape().sigmoid", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "cfg.get", "mmdet.core.distance2bbox", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_tensor", "max_scores.topk", "cls_score.size", "bbox_pred.permute().reshape.permute().reshape.size", "cls_score.permute().reshape", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute", "cls_score.permute", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "mlvl_points", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for a single scale level\n                Has shape (num_points * num_classes, H, W).\n            bbox_preds (list[Tensor]): Box energies / deltas for a single scale\n                level with shape (num_points * 4, H, W).\n            centernesses (list[Tensor]): Centerness for a single scale level\n                with shape (num_points * 4, H, W).\n            mlvl_points (list[Tensor]): Box reference for a single scale level\n                with shape (num_total_points, 4).\n            img_shape (tuple[int]): Shape of the input image,\n                (height, width, 3).\n            scale_factor (ndarray): Scale factor of the image arrange as\n                (w_scale, h_scale, w_scale, h_scale).\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used.\n            rescale (bool): If True, return boxes in original image space.\n\n        Returns:\n            Tensor: Labeled boxes in shape (n, 5), where the first 4 columns \\\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the \\\n                5-th column is a score between 0 and 1.\n        \"\"\"", "\n", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "mlvl_points", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "mlvl_centerness", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "centerness", ",", "points", "in", "zip", "(", "\n", "cls_scores", ",", "bbox_preds", ",", "centernesses", ",", "mlvl_points", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "scores", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "\n", "-", "1", ",", "self", ".", "cls_out_channels", ")", ".", "sigmoid", "(", ")", "\n", "centerness", "=", "centerness", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ")", ".", "sigmoid", "(", ")", "\n", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "                ", "max_scores", ",", "_", "=", "(", "scores", "*", "centerness", "[", ":", ",", "None", "]", ")", ".", "max", "(", "dim", "=", "1", ")", "\n", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "points", "=", "points", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "centerness", "=", "centerness", "[", "topk_inds", "]", "\n", "", "bboxes", "=", "distance2bbox", "(", "points", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "mlvl_centerness", ".", "append", "(", "centerness", ")", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "mlvl_centerness", "=", "torch", ".", "cat", "(", "mlvl_centerness", ")", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "\n", "mlvl_bboxes", ",", "\n", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "\n", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ",", "\n", "score_factors", "=", "mlvl_centerness", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead._get_points_single": [[386, 397], ["super()._get_points_single", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "x.reshape", "y.reshape"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._get_points_single"], ["", "def", "_get_points_single", "(", "self", ",", "\n", "featmap_size", ",", "\n", "stride", ",", "\n", "dtype", ",", "\n", "device", ",", "\n", "flatten", "=", "False", ")", ":", "\n", "        ", "\"\"\"Get points according to feature map sizes.\"\"\"", "\n", "y", ",", "x", "=", "super", "(", ")", ".", "_get_points_single", "(", "featmap_size", ",", "stride", ",", "dtype", ",", "device", ")", "\n", "points", "=", "torch", ".", "stack", "(", "(", "x", ".", "reshape", "(", "-", "1", ")", "*", "stride", ",", "y", ".", "reshape", "(", "-", "1", ")", "*", "stride", ")", ",", "\n", "dim", "=", "-", "1", ")", "+", "stride", "//", "2", "\n", "return", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.get_targets": [[398, 458], ["len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multi_apply", "range", "len", "len", "[].expand_as", "center.size", "labels.split", "torch.cat.split", "torch.cat.split", "torch.cat.split", "concat_lvl_labels.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "concat_lvl_bbox_targets.append", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "points[].new_tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "get_targets", "(", "self", ",", "points", ",", "gt_bboxes_list", ",", "gt_labels_list", ")", ":", "\n", "        ", "\"\"\"Compute regression, classification and centerss targets for points\n        in multiple images.\n\n        Args:\n            points (list[Tensor]): Points of each fpn level, each has shape\n                (num_points, 2).\n            gt_bboxes_list (list[Tensor]): Ground truth bboxes of each image,\n                each has shape (num_gt, 4).\n            gt_labels_list (list[Tensor]): Ground truth labels of each box,\n                each has shape (num_gt,).\n\n        Returns:\n            tuple:\n                concat_lvl_labels (list[Tensor]): Labels of each level. \\\n                concat_lvl_bbox_targets (list[Tensor]): BBox targets of each \\\n                    level.\n        \"\"\"", "\n", "assert", "len", "(", "points", ")", "==", "len", "(", "self", ".", "regress_ranges", ")", "\n", "num_levels", "=", "len", "(", "points", ")", "\n", "# expand regress ranges to align with points", "\n", "expanded_regress_ranges", "=", "[", "\n", "points", "[", "i", "]", ".", "new_tensor", "(", "self", ".", "regress_ranges", "[", "i", "]", ")", "[", "None", "]", ".", "expand_as", "(", "\n", "points", "[", "i", "]", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "# concat all levels points and regress ranges", "\n", "concat_regress_ranges", "=", "torch", ".", "cat", "(", "expanded_regress_ranges", ",", "dim", "=", "0", ")", "\n", "concat_points", "=", "torch", ".", "cat", "(", "points", ",", "dim", "=", "0", ")", "\n", "\n", "# the number of points per img, per lvl", "\n", "num_points", "=", "[", "center", ".", "size", "(", "0", ")", "for", "center", "in", "points", "]", "\n", "\n", "# get labels and bbox_targets of each image", "\n", "labels_list", ",", "bbox_targets_list", "=", "multi_apply", "(", "\n", "self", ".", "_get_target_single", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_labels_list", ",", "\n", "points", "=", "concat_points", ",", "\n", "regress_ranges", "=", "concat_regress_ranges", ",", "\n", "num_points_per_lvl", "=", "num_points", ")", "\n", "\n", "# split to per img, per level", "\n", "labels_list", "=", "[", "labels", ".", "split", "(", "num_points", ",", "0", ")", "for", "labels", "in", "labels_list", "]", "\n", "bbox_targets_list", "=", "[", "\n", "bbox_targets", ".", "split", "(", "num_points", ",", "0", ")", "\n", "for", "bbox_targets", "in", "bbox_targets_list", "\n", "]", "\n", "\n", "# concat per level image", "\n", "concat_lvl_labels", "=", "[", "]", "\n", "concat_lvl_bbox_targets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "concat_lvl_labels", ".", "append", "(", "\n", "torch", ".", "cat", "(", "[", "labels", "[", "i", "]", "for", "labels", "in", "labels_list", "]", ")", ")", "\n", "bbox_targets", "=", "torch", ".", "cat", "(", "\n", "[", "bbox_targets", "[", "i", "]", "for", "bbox_targets", "in", "bbox_targets_list", "]", ")", "\n", "if", "self", ".", "norm_on_bbox", ":", "\n", "                ", "bbox_targets", "=", "bbox_targets", "/", "self", ".", "strides", "[", "i", "]", "\n", "", "concat_lvl_bbox_targets", ".", "append", "(", "bbox_targets", ")", "\n", "", "return", "concat_lvl_labels", ",", "concat_lvl_bbox_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead._get_target_single": [[459, 542], ["points.size", "gt_labels.size", "areas[].repeat", "regress_ranges[].expand", "gt_bboxes[].expand", "xs[].expand", "ys[].expand", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "areas[].repeat.min", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "center_xs.new_zeros", "enumerate", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack.max", "torch.stack.max", "torch.stack.max", "gt_labels.new_full", "gt_bboxes[].expand.new_zeros", "torch.stack.min", "torch.stack.min", "torch.stack.min", "torch.stack.min", "torch.stack.min", "torch.stack.min", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "_get_target_single", "(", "self", ",", "gt_bboxes", ",", "gt_labels", ",", "points", ",", "regress_ranges", ",", "\n", "num_points_per_lvl", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for a single image.\"\"\"", "\n", "num_points", "=", "points", ".", "size", "(", "0", ")", "\n", "num_gts", "=", "gt_labels", ".", "size", "(", "0", ")", "\n", "if", "num_gts", "==", "0", ":", "\n", "            ", "return", "gt_labels", ".", "new_full", "(", "(", "num_points", ",", ")", ",", "self", ".", "background_label", ")", ",", "gt_bboxes", ".", "new_zeros", "(", "(", "num_points", ",", "4", ")", ")", "\n", "\n", "", "areas", "=", "(", "gt_bboxes", "[", ":", ",", "2", "]", "-", "gt_bboxes", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "gt_bboxes", "[", ":", ",", "3", "]", "-", "gt_bboxes", "[", ":", ",", "1", "]", ")", "\n", "# TODO: figure out why these two are different", "\n", "# areas = areas[None].expand(num_points, num_gts)", "\n", "areas", "=", "areas", "[", "None", "]", ".", "repeat", "(", "num_points", ",", "1", ")", "\n", "regress_ranges", "=", "regress_ranges", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "\n", "num_points", ",", "num_gts", ",", "2", ")", "\n", "gt_bboxes", "=", "gt_bboxes", "[", "None", "]", ".", "expand", "(", "num_points", ",", "num_gts", ",", "4", ")", "\n", "xs", ",", "ys", "=", "points", "[", ":", ",", "0", "]", ",", "points", "[", ":", ",", "1", "]", "\n", "xs", "=", "xs", "[", ":", ",", "None", "]", ".", "expand", "(", "num_points", ",", "num_gts", ")", "\n", "ys", "=", "ys", "[", ":", ",", "None", "]", ".", "expand", "(", "num_points", ",", "num_gts", ")", "\n", "\n", "left", "=", "xs", "-", "gt_bboxes", "[", "...", ",", "0", "]", "\n", "right", "=", "gt_bboxes", "[", "...", ",", "2", "]", "-", "xs", "\n", "top", "=", "ys", "-", "gt_bboxes", "[", "...", ",", "1", "]", "\n", "bottom", "=", "gt_bboxes", "[", "...", ",", "3", "]", "-", "ys", "\n", "bbox_targets", "=", "torch", ".", "stack", "(", "(", "left", ",", "top", ",", "right", ",", "bottom", ")", ",", "-", "1", ")", "\n", "\n", "if", "self", ".", "center_sampling", ":", "\n", "# condition1: inside a `center bbox`", "\n", "            ", "radius", "=", "self", ".", "center_sample_radius", "\n", "center_xs", "=", "(", "gt_bboxes", "[", "...", ",", "0", "]", "+", "gt_bboxes", "[", "...", ",", "2", "]", ")", "/", "2", "\n", "center_ys", "=", "(", "gt_bboxes", "[", "...", ",", "1", "]", "+", "gt_bboxes", "[", "...", ",", "3", "]", ")", "/", "2", "\n", "center_gts", "=", "torch", ".", "zeros_like", "(", "gt_bboxes", ")", "\n", "stride", "=", "center_xs", ".", "new_zeros", "(", "center_xs", ".", "shape", ")", "\n", "\n", "# project the points on current lvl back to the `original` sizes", "\n", "lvl_begin", "=", "0", "\n", "for", "lvl_idx", ",", "num_points_lvl", "in", "enumerate", "(", "num_points_per_lvl", ")", ":", "\n", "                ", "lvl_end", "=", "lvl_begin", "+", "num_points_lvl", "\n", "stride", "[", "lvl_begin", ":", "lvl_end", "]", "=", "self", ".", "strides", "[", "lvl_idx", "]", "*", "radius", "\n", "lvl_begin", "=", "lvl_end", "\n", "\n", "", "x_mins", "=", "center_xs", "-", "stride", "\n", "y_mins", "=", "center_ys", "-", "stride", "\n", "x_maxs", "=", "center_xs", "+", "stride", "\n", "y_maxs", "=", "center_ys", "+", "stride", "\n", "center_gts", "[", "...", ",", "0", "]", "=", "torch", ".", "where", "(", "x_mins", ">", "gt_bboxes", "[", "...", ",", "0", "]", ",", "\n", "x_mins", ",", "gt_bboxes", "[", "...", ",", "0", "]", ")", "\n", "center_gts", "[", "...", ",", "1", "]", "=", "torch", ".", "where", "(", "y_mins", ">", "gt_bboxes", "[", "...", ",", "1", "]", ",", "\n", "y_mins", ",", "gt_bboxes", "[", "...", ",", "1", "]", ")", "\n", "center_gts", "[", "...", ",", "2", "]", "=", "torch", ".", "where", "(", "x_maxs", ">", "gt_bboxes", "[", "...", ",", "2", "]", ",", "\n", "gt_bboxes", "[", "...", ",", "2", "]", ",", "x_maxs", ")", "\n", "center_gts", "[", "...", ",", "3", "]", "=", "torch", ".", "where", "(", "y_maxs", ">", "gt_bboxes", "[", "...", ",", "3", "]", ",", "\n", "gt_bboxes", "[", "...", ",", "3", "]", ",", "y_maxs", ")", "\n", "\n", "cb_dist_left", "=", "xs", "-", "center_gts", "[", "...", ",", "0", "]", "\n", "cb_dist_right", "=", "center_gts", "[", "...", ",", "2", "]", "-", "xs", "\n", "cb_dist_top", "=", "ys", "-", "center_gts", "[", "...", ",", "1", "]", "\n", "cb_dist_bottom", "=", "center_gts", "[", "...", ",", "3", "]", "-", "ys", "\n", "center_bbox", "=", "torch", ".", "stack", "(", "\n", "(", "cb_dist_left", ",", "cb_dist_top", ",", "cb_dist_right", ",", "cb_dist_bottom", ")", ",", "-", "1", ")", "\n", "inside_gt_bbox_mask", "=", "center_bbox", ".", "min", "(", "-", "1", ")", "[", "0", "]", ">", "0", "\n", "", "else", ":", "\n", "# condition1: inside a gt bbox", "\n", "            ", "inside_gt_bbox_mask", "=", "bbox_targets", ".", "min", "(", "-", "1", ")", "[", "0", "]", ">", "0", "\n", "\n", "# condition2: limit the regression range for each location", "\n", "", "max_regress_distance", "=", "bbox_targets", ".", "max", "(", "-", "1", ")", "[", "0", "]", "\n", "inside_regress_range", "=", "(", "\n", "(", "max_regress_distance", ">=", "regress_ranges", "[", "...", ",", "0", "]", ")", "\n", "&", "(", "max_regress_distance", "<=", "regress_ranges", "[", "...", ",", "1", "]", ")", ")", "\n", "\n", "# if there are still more than one objects for a location,", "\n", "# we choose the one with minimal area", "\n", "areas", "[", "inside_gt_bbox_mask", "==", "0", "]", "=", "INF", "\n", "areas", "[", "inside_regress_range", "==", "0", "]", "=", "INF", "\n", "min_area", ",", "min_area_inds", "=", "areas", ".", "min", "(", "dim", "=", "1", ")", "\n", "\n", "labels", "=", "gt_labels", "[", "min_area_inds", "]", "\n", "labels", "[", "min_area", "==", "INF", "]", "=", "self", ".", "background_label", "# set as BG", "\n", "bbox_targets", "=", "bbox_targets", "[", "range", "(", "num_points", ")", ",", "min_area_inds", "]", "\n", "\n", "return", "labels", ",", "bbox_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.fcos_head.FCOSHead.centerness_target": [[543, 560], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "left_right.min", "left_right.max", "top_bottom.min", "top_bottom.max"], "methods", ["None"], ["", "def", "centerness_target", "(", "self", ",", "pos_bbox_targets", ")", ":", "\n", "        ", "\"\"\"Compute centerness targets.\n\n        Args:\n            pos_bbox_targets (Tensor): BBox targets of positive bboxes in shape\n                (num_pos, 4)\n\n        Returns:\n            Tensor: Centerness target.\n        \"\"\"", "\n", "# only calculate pos centerness targets, otherwise there may be nan", "\n", "left_right", "=", "pos_bbox_targets", "[", ":", ",", "[", "0", ",", "2", "]", "]", "\n", "top_bottom", "=", "pos_bbox_targets", "[", ":", ",", "[", "1", ",", "3", "]", "]", "\n", "centerness_targets", "=", "(", "\n", "left_right", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "left_right", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "*", "(", "\n", "top_bottom", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "top_bottom", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "\n", "return", "torch", ".", "sqrt", "(", "centerness_targets", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.__init__": [[32, 55], ["dict", "dict", "anchor_head.AnchorHead.__init__", "builder.build_loss", "mmdet.core.build_assigner", "dict", "mmdet.core.build_sampler"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ",", "requires_grad", "=", "True", ")", ",", "\n", "loss_centerness", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "super", "(", "ATSSHead", ",", "self", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "sampling", "=", "False", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# SSD sampling=False so use PseudoSampler", "\n", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "", "self", ".", "loss_centerness", "=", "build_loss", "(", "loss_centerness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead._init_layers": [[56, 92], ["torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "atss_head.ATSSHead.cls_convs.append", "atss_head.ATSSHead.reg_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.Scale"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "self", ".", "atss_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "atss_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "atss_centerness", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "1", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "scales", "=", "nn", ".", "ModuleList", "(", "\n", "[", "Scale", "(", "1.0", ")", "for", "_", "in", "self", ".", "anchor_generator", ".", "strides", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.init_weights": [[93, 103], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "atss_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "atss_reg", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "atss_centerness", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.forward": [[104, 121], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: Usually a tuple of classification scores and bbox prediction\n                cls_scores (list[Tensor]): Classification scores for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * num_classes.\n                bbox_preds (list[Tensor]): Box energies / deltas for all scale\n                    levels, each is a 4D-tensor, the channels number is\n                    num_anchors * 4.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ",", "self", ".", "scales", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.forward_single": [[122, 150], ["atss_head.ATSSHead.atss_cls", "scale().float", "atss_head.ATSSHead.atss_centerness", "cls_conv", "reg_conv", "scale", "atss_head.ATSSHead.atss_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ",", "scale", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n            scale (:obj: `mmcv.cnn.Scale`): Learnable scale module to resize\n                the bbox prediction.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls scores for a single scale level\n                    the channels number is num_anchors * num_classes.\n                bbox_pred (Tensor): Box energies / deltas for a single scale\n                    level, the channels number is num_anchors * 4.\n                centerness (Tensor): Centerness for a single scale level, the\n                    channel number is (N, num_anchors * 1, H, W).\n        \"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "", "cls_score", "=", "self", ".", "atss_cls", "(", "cls_feat", ")", "\n", "# we just follow atss, not apply exp in bbox_pred", "\n", "bbox_pred", "=", "scale", "(", "self", ".", "atss_reg", "(", "reg_feat", ")", ")", ".", "float", "(", ")", "\n", "centerness", "=", "self", ".", "atss_centerness", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "centerness", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.loss_single": [[151, 225], ["anchors.reshape.reshape.reshape", "cls_score.permute().reshape().contiguous.permute().reshape().contiguous.permute().reshape().contiguous", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "centerness.permute().reshape.permute().reshape.permute().reshape", "bbox_targets.reshape.reshape.reshape", "labels.reshape.reshape.reshape", "label_weights.reshape.reshape.reshape", "atss_head.ATSSHead.loss_cls", "len", "atss_head.ATSSHead.centerness_target", "atss_head.ATSSHead.bbox_coder.decode", "atss_head.ATSSHead.bbox_coder.decode", "atss_head.ATSSHead.loss_bbox", "atss_head.ATSSHead.loss_centerness", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda.sum", "torch.tensor().cuda.sum", "torch.tensor().cuda.sum", "cls_score.permute().reshape().contiguous.permute().reshape().contiguous.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute", "centerness.permute().reshape.permute().reshape.permute", "bbox_pred.permute().reshape.permute().reshape.sum", "centerness.permute().reshape.permute().reshape.sum", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "cls_score.permute().reshape().contiguous.permute().reshape().contiguous.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.centerness_target", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "loss_single", "(", "self", ",", "anchors", ",", "cls_score", ",", "bbox_pred", ",", "centerness", ",", "labels", ",", "\n", "label_weights", ",", "bbox_targets", ",", "num_total_samples", ")", ":", "\n", "        ", "\"\"\"Compute loss of a single scale level.\n\n        Args:\n            cls_score (Tensor): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W).\n            bbox_pred (Tensor): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W).\n            anchors (Tensor): Box reference for each scale level with shape\n                (N, num_total_anchors, 4).\n            labels (Tensor): Labels of each anchors with shape\n                (N, num_total_anchors).\n            label_weights (Tensor): Label weights of each anchor with shape\n                (N, num_total_anchors)\n            bbox_targets (Tensor): BBox regression targets of each anchor wight\n                shape (N, num_total_anchors, 4).\n            num_total_samples (int): Number os positive samples that is\n                reduced over all GPUs.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "\n", "anchors", "=", "anchors", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "\n", "-", "1", ",", "self", ".", "cls_out_channels", ")", ".", "contiguous", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "centerness", "=", "centerness", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "bbox_targets", "=", "bbox_targets", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "labels", "=", "labels", ".", "reshape", "(", "-", "1", ")", "\n", "label_weights", "=", "label_weights", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# classification loss", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "labels", ",", "label_weights", ",", "avg_factor", "=", "num_total_samples", ")", "\n", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "bg_class_ind", "=", "self", ".", "num_classes", "\n", "pos_inds", "=", "(", "(", "labels", ">=", "0", ")", "\n", "&", "(", "labels", "<", "bg_class_ind", ")", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "pos_bbox_targets", "=", "bbox_targets", "[", "pos_inds", "]", "\n", "pos_bbox_pred", "=", "bbox_pred", "[", "pos_inds", "]", "\n", "pos_anchors", "=", "anchors", "[", "pos_inds", "]", "\n", "pos_centerness", "=", "centerness", "[", "pos_inds", "]", "\n", "\n", "centerness_targets", "=", "self", ".", "centerness_target", "(", "\n", "pos_anchors", ",", "pos_bbox_targets", ")", "\n", "pos_decode_bbox_pred", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "pos_anchors", ",", "pos_bbox_pred", ")", "\n", "pos_decode_bbox_targets", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "pos_anchors", ",", "pos_bbox_targets", ")", "\n", "\n", "# regression loss", "\n", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "pos_decode_bbox_pred", ",", "\n", "pos_decode_bbox_targets", ",", "\n", "weight", "=", "centerness_targets", ",", "\n", "avg_factor", "=", "1.0", ")", "\n", "\n", "# centerness loss", "\n", "loss_centerness", "=", "self", ".", "loss_centerness", "(", "\n", "pos_centerness", ",", "\n", "centerness_targets", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "\n", "", "else", ":", "\n", "            ", "loss_bbox", "=", "bbox_pred", ".", "sum", "(", ")", "*", "0", "\n", "loss_centerness", "=", "centerness", ".", "sum", "(", ")", "*", "0", "\n", "centerness_targets", "=", "torch", ".", "tensor", "(", "0", ")", ".", "cuda", "(", ")", "\n", "\n", "", "return", "loss_cls", ",", "loss_bbox", ",", "loss_centerness", ",", "centerness_targets", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.loss": [[226, 300], ["mmdet.core.force_fp32", "atss_head.ATSSHead.get_anchors", "atss_head.ATSSHead.get_targets", "reduce_mean().item", "max", "mmdet.core.multi_apply", "sum", "reduce_mean().item", "list", "dict", "len", "map", "featmap.size", "atss_head.reduce_mean", "atss_head.reduce_mean", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.reduce_mean", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.reduce_mean"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'centernesses'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            centernesses (list[Tensor]): Centerness for each scale\n                level with shape (N, num_anchors * 1, H, W)\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (list[Tensor] | None): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "(", "anchor_list", ",", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "\n", "num_total_samples", "=", "reduce_mean", "(", "\n", "torch", ".", "tensor", "(", "num_total_pos", ")", ".", "cuda", "(", ")", ")", ".", "item", "(", ")", "\n", "num_total_samples", "=", "max", "(", "num_total_samples", ",", "1.0", ")", "\n", "\n", "losses_cls", ",", "losses_bbox", ",", "loss_centerness", ",", "bbox_avg_factor", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "anchor_list", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "\n", "bbox_avg_factor", "=", "sum", "(", "bbox_avg_factor", ")", "\n", "bbox_avg_factor", "=", "reduce_mean", "(", "bbox_avg_factor", ")", ".", "item", "(", ")", "\n", "losses_bbox", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", "/", "bbox_avg_factor", ",", "losses_bbox", ")", ")", "\n", "return", "dict", "(", "\n", "loss_cls", "=", "losses_cls", ",", "\n", "loss_bbox", "=", "losses_bbox", ",", "\n", "loss_centerness", "=", "loss_centerness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.centerness_target": [[301, 318], ["atss_head.ATSSHead.bbox_coder.decode", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan().any", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.stack.min", "torch.stack.min", "torch.stack.min", "torch.stack.max", "torch.stack.max", "torch.stack.max", "torch.stack.min", "torch.stack.min", "torch.stack.min", "torch.stack.max", "torch.stack.max", "torch.stack.max"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "centerness_target", "(", "self", ",", "anchors", ",", "bbox_targets", ")", ":", "\n", "# only calculate pos centerness targets, otherwise there may be nan", "\n", "        ", "gts", "=", "self", ".", "bbox_coder", ".", "decode", "(", "anchors", ",", "bbox_targets", ")", "\n", "anchors_cx", "=", "(", "anchors", "[", ":", ",", "2", "]", "+", "anchors", "[", ":", ",", "0", "]", ")", "/", "2", "\n", "anchors_cy", "=", "(", "anchors", "[", ":", ",", "3", "]", "+", "anchors", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "l_", "=", "anchors_cx", "-", "gts", "[", ":", ",", "0", "]", "\n", "t_", "=", "anchors_cy", "-", "gts", "[", ":", ",", "1", "]", "\n", "r_", "=", "gts", "[", ":", ",", "2", "]", "-", "anchors_cx", "\n", "b_", "=", "gts", "[", ":", ",", "3", "]", "-", "anchors_cy", "\n", "\n", "left_right", "=", "torch", ".", "stack", "(", "[", "l_", ",", "r_", "]", ",", "dim", "=", "1", ")", "\n", "top_bottom", "=", "torch", ".", "stack", "(", "[", "t_", ",", "b_", "]", ",", "dim", "=", "1", ")", "\n", "centerness", "=", "torch", ".", "sqrt", "(", "\n", "(", "left_right", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "left_right", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "*", "\n", "(", "top_bottom", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "top_bottom", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", ")", "\n", "assert", "not", "torch", ".", "isnan", "(", "centerness", ")", ".", "any", "(", ")", "\n", "return", "centerness", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.get_bboxes": [[319, 378], ["mmdet.core.force_fp32", "len", "atss_head.ATSSHead.anchor_generator.grid_anchors", "range", "len", "len", "len", "atss_head.ATSSHead._get_bboxes_single", "result_list.append", "range", "[].detach", "[].detach", "[].detach", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ",", "'centernesses'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            centernesses (list[Tensor]): Centerness for each scale\n                level with shape (N, num_anchors * 1, H, W)\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used. Default: None.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n\n        Returns:\n            list[tuple[Tensor, Tensor]]: Each item in result_list is 2-tuple.\n                The first item is an (n, 5) tensor, where the first 4 columns\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the\n                5-th column is a score between 0 and 1. The second item is a\n                (n,) tensor where each item is the predicted class label of the\n                corresponding box.\n        \"\"\"", "\n", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "featmap_sizes", "=", "[", "cls_scores", "[", "i", "]", ".", "shape", "[", "-", "2", ":", "]", "for", "i", "in", "range", "(", "num_levels", ")", "]", "\n", "mlvl_anchors", "=", "self", ".", "anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", "=", "device", ")", "\n", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "centerness_pred_list", "=", "[", "\n", "centernesses", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "proposals", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "bbox_pred_list", ",", "\n", "centerness_pred_list", ",", "\n", "mlvl_anchors", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ")", "\n", "result_list", ".", "append", "(", "proposals", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead._get_bboxes_single": [[379, 465], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "len", "len", "len", "cls_score.permute().reshape().sigmoid", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute().reshape().sigmoid", "cfg.get", "atss_head.ATSSHead.bbox_coder.decode", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_tensor", "max_scores.topk", "cls_score.size", "bbox_pred.permute().reshape.permute().reshape.size", "cls_score.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute().reshape", "cls_score.permute", "centerness.permute().reshape().sigmoid.permute().reshape().sigmoid.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "centernesses", ",", "\n", "mlvl_anchors", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into labeled boxes.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for a single scale level\n                Has shape (num_anchors * num_classes, H, W).\n            bbox_preds (list[Tensor]): Box energies / deltas for a single\n                scale level with shape (num_anchors * 4, H, W).\n            centernesses (list[Tensor]): Centerness for a single scale level\n                Has shape (num_anchors * 1, H, W).\n            mlvl_anchors (list[Tensor]): Box reference for a single scale level\n                with shape (num_total_anchors, 4).\n            img_shape (tuple[int]): Shape of the input image,\n                (height, width, 3).\n            scale_factor (ndarray): Scale factor of the image arange as\n                (w_scale, h_scale, w_scale, h_scale).\n            cfg (mmcv.Config | None): Test / postprocessing configuration,\n                if None, test_cfg would be used.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n\n        Returns:\n            tuple(Tensor):\n                det_bboxes (Tensor): BBox predictions in shape (n, 5), where\n                    the first 4 columns are bounding box positions\n                    (tl_x, tl_y, br_x, br_y) and the 5-th column is a score\n                    between 0 and 1.\n                det_labels (Tensor): A (n,) tensor where each item is the\n                    predicted class label of the corresponding box.\n        \"\"\"", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "mlvl_anchors", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "mlvl_centerness", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "centerness", ",", "anchors", "in", "zip", "(", "\n", "cls_scores", ",", "bbox_preds", ",", "centernesses", ",", "mlvl_anchors", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "\n", "scores", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "\n", "-", "1", ",", "self", ".", "cls_out_channels", ")", ".", "sigmoid", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "centerness", "=", "centerness", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ")", ".", "sigmoid", "(", ")", "\n", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "                ", "max_scores", ",", "_", "=", "(", "scores", "*", "centerness", "[", ":", ",", "None", "]", ")", ".", "max", "(", "dim", "=", "1", ")", "\n", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "centerness", "=", "centerness", "[", "topk_inds", "]", "\n", "\n", "", "bboxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "anchors", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "mlvl_centerness", ".", "append", "(", "centerness", ")", "\n", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "mlvl_centerness", "=", "torch", ".", "cat", "(", "mlvl_centerness", ")", "\n", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "\n", "mlvl_bboxes", ",", "\n", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "\n", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ",", "\n", "score_factors", "=", "mlvl_centerness", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.get_targets": [[466, 529], ["len", "range", "mmdet.core.multi_apply", "any", "sum", "sum", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "len", "len", "anchors.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "max", "max", "range", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels"], ["", "def", "get_targets", "(", "self", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "None", ",", "\n", "gt_labels_list", "=", "None", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get targets for ATSS head.\n\n        This method is almost the same as `AnchorHead.get_targets()`. Besides\n        returning the targets as the parent method does, it also returns the\n        anchors as the first element of the returned tuple.\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "assert", "len", "(", "anchor_list", ")", "==", "len", "(", "valid_flag_list", ")", "==", "num_imgs", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "num_level_anchors_list", "=", "[", "num_level_anchors", "]", "*", "num_imgs", "\n", "\n", "# concat all level anchors and flags to a single tensor", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assert", "len", "(", "anchor_list", "[", "i", "]", ")", "==", "len", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "anchor_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", "\n", "valid_flag_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_bboxes_ignore_list", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "if", "gt_labels_list", "is", "None", ":", "\n", "            ", "gt_labels_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "(", "all_anchors", ",", "all_labels", ",", "all_label_weights", ",", "all_bbox_targets", ",", "\n", "all_bbox_weights", ",", "pos_inds_list", ",", "neg_inds_list", ")", "=", "multi_apply", "(", "\n", "self", ".", "_get_target_single", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "num_level_anchors_list", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_bboxes_ignore_list", ",", "\n", "gt_labels_list", ",", "\n", "img_metas", ",", "\n", "label_channels", "=", "label_channels", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "# no valid anchors", "\n", "if", "any", "(", "[", "labels", "is", "None", "for", "labels", "in", "all_labels", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled anchors of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "# split targets to a list w.r.t. multiple levels", "\n", "anchors_list", "=", "images_to_levels", "(", "all_anchors", ",", "num_level_anchors", ")", "\n", "labels_list", "=", "images_to_levels", "(", "all_labels", ",", "num_level_anchors", ")", "\n", "label_weights_list", "=", "images_to_levels", "(", "all_label_weights", ",", "\n", "num_level_anchors", ")", "\n", "bbox_targets_list", "=", "images_to_levels", "(", "all_bbox_targets", ",", "\n", "num_level_anchors", ")", "\n", "bbox_weights_list", "=", "images_to_levels", "(", "all_bbox_weights", ",", "\n", "num_level_anchors", ")", "\n", "return", "(", "anchors_list", ",", "labels_list", ",", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "bbox_weights_list", ",", "num_total_pos", ",", "\n", "num_total_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead._get_target_single": [[530, 633], ["mmdet.core.anchor_inside_flags", "atss_head.ATSSHead.get_num_level_anchors_inside", "atss_head.ATSSHead.assigner.assign", "atss_head.ATSSHead.sampler.sample", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "mmdet.core.unmap.new_full", "mmdet.core.unmap.new_zeros", "mmdet.core.anchor_inside_flags.any", "len", "atss_head.ATSSHead.bbox_coder.encode", "len", "flat_anchors.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.get_num_level_anchors_inside", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap"], ["", "def", "_get_target_single", "(", "self", ",", "\n", "flat_anchors", ",", "\n", "valid_flags", ",", "\n", "num_level_anchors", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "gt_labels", ",", "\n", "img_meta", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute regression, classification targets for anchors in a single\n        image.\n\n        Args:\n            flat_anchors (Tensor): Multi-level anchors of the image, which are\n                concatenated into a single tensor of shape (num_anchors ,4)\n            valid_flags (Tensor): Multi level valid flags of the image,\n                which are concatenated into a single tensor of\n                    shape (num_anchors,).\n            num_level_anchors Tensor): Number of anchors of each scale level.\n            gt_bboxes (Tensor): Ground truth bboxes of the image,\n                shape (num_gts, 4).\n            gt_bboxes_ignore (Tensor): Ground truth bboxes to be\n                ignored, shape (num_ignored_gts, 4).\n            gt_labels (Tensor): Ground truth labels of each box,\n                shape (num_gts,).\n            img_meta (dict): Meta info of the image.\n            label_channels (int): Channel of label.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple: N is the number of total anchors in the image.\n                labels (Tensor): Labels of all anchors in the image with shape\n                    (N,).\n                label_weights (Tensor): Label weights of all anchor in the\n                    image with shape (N,).\n                bbox_targets (Tensor): BBox targets of all anchors in the\n                    image with shape (N, 4).\n                bbox_weights (Tensor): BBox weights of all anchors in the\n                    image with shape (N, 4)\n                pos_inds (Tensor): Indices of postive anchor with shape\n                    (num_pos,).\n                neg_inds (Tensor): Indices of negative anchor with shape\n                    (num_neg,).\n        \"\"\"", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "\n", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# assign gt and sample anchors", "\n", "", "anchors", "=", "flat_anchors", "[", "inside_flags", ",", ":", "]", "\n", "\n", "num_level_anchors_inside", "=", "self", ".", "get_num_level_anchors_inside", "(", "\n", "num_level_anchors", ",", "inside_flags", ")", "\n", "assign_result", "=", "self", ".", "assigner", ".", "assign", "(", "anchors", ",", "num_level_anchors_inside", ",", "\n", "gt_bboxes", ",", "gt_bboxes_ignore", ",", "\n", "gt_labels", ")", "\n", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "anchors", ",", "\n", "gt_bboxes", ")", "\n", "\n", "num_valid_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "bbox_targets", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "bbox_weights", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "labels", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "anchors", ".", "new_zeros", "(", "num_valid_anchors", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "pos_bbox_targets", "=", "self", ".", "bbox_coder", ".", "encode", "(", "\n", "sampling_result", ".", "pos_bboxes", ",", "sampling_result", ".", "pos_gt_bboxes", ")", "\n", "bbox_targets", "[", "pos_inds", ",", ":", "]", "=", "pos_bbox_targets", "\n", "bbox_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "if", "gt_labels", "is", "None", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "self", ".", "train_cfg", ".", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "self", ".", "train_cfg", ".", "pos_weight", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# map up to original set of anchors", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_anchors", ".", "size", "(", "0", ")", "\n", "anchors", "=", "unmap", "(", "anchors", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "labels", "=", "unmap", "(", "\n", "labels", ",", "num_total_anchors", ",", "inside_flags", ",", "fill", "=", "self", ".", "num_classes", ")", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "bbox_targets", "=", "unmap", "(", "bbox_targets", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_weights", "=", "unmap", "(", "bbox_weights", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "\n", "", "return", "(", "anchors", ",", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", ",", "\n", "pos_inds", ",", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.ATSSHead.get_num_level_anchors_inside": [[634, 640], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "int", "flags.sum"], "methods", ["None"], ["", "def", "get_num_level_anchors_inside", "(", "self", ",", "num_level_anchors", ",", "inside_flags", ")", ":", "\n", "        ", "split_inside_flags", "=", "torch", ".", "split", "(", "inside_flags", ",", "num_level_anchors", ")", "\n", "num_level_anchors_inside", "=", "[", "\n", "int", "(", "flags", ".", "sum", "(", ")", ")", "for", "flags", "in", "split_inside_flags", "\n", "]", "\n", "return", "num_level_anchors_inside", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.atss_head.reduce_mean": [[13, 19], ["tensor.clone.clone", "torch.all_reduce", "tensor.clone.div_", "torch.is_available", "torch.is_initialized", "torch.get_world_size"], "function", ["None"], ["def", "reduce_mean", "(", "tensor", ")", ":", "\n", "    ", "if", "not", "(", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ")", ":", "\n", "        ", "return", "tensor", "\n", "", "tensor", "=", "tensor", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "tensor", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ",", "op", "=", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.Integral.__init__": [[36, 41], ["torch.Module.__init__", "gfl_head.Integral.register_buffer", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "reg_max", "=", "16", ")", ":", "\n", "        ", "super", "(", "Integral", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reg_max", "=", "reg_max", "\n", "self", ".", "register_buffer", "(", "'project'", ",", "\n", "torch", ".", "linspace", "(", "0", ",", "self", ".", "reg_max", ",", "self", ".", "reg_max", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.Integral.forward": [[42, 57], ["torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.linear().reshape", "torch.linear().reshape", "torch.linear().reshape", "torch.linear().reshape", "torch.linear().reshape.reshape", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "gfl_head.Integral.project.type_as"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature from the regression head to get integral result of\n        bounding box location.\n\n        Args:\n            x (Tensor): Features of the regression head, shape (N, 4*(n+1)),\n                n is self.reg_max.\n\n        Returns:\n            x (Tensor): Integral result of box locations, i.e., distance\n                offsets from the box center in four directions, shape (N, 4).\n        \"\"\"", "\n", "x", "=", "F", ".", "softmax", "(", "x", ".", "reshape", "(", "-", "1", ",", "self", ".", "reg_max", "+", "1", ")", ",", "dim", "=", "1", ")", "\n", "x", "=", "F", ".", "linear", "(", "x", ",", "self", ".", "project", ".", "type_as", "(", "x", ")", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.__init__": [[92, 116], ["dict", "dict", "anchor_head.AnchorHead.__init__", "gfl_head.Integral", "builder.build_loss", "mmdet.core.build_assigner", "dict", "mmdet.core.build_sampler"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ",", "requires_grad", "=", "True", ")", ",", "\n", "loss_dfl", "=", "dict", "(", "type", "=", "'DistributionFocalLoss'", ",", "loss_weight", "=", "0.25", ")", ",", "\n", "reg_max", "=", "16", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "reg_max", "=", "reg_max", "\n", "super", "(", "GFLHead", ",", "self", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "sampling", "=", "False", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# SSD sampling=False so use PseudoSampler", "\n", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "\n", "", "self", ".", "integral", "=", "Integral", "(", "self", ".", "reg_max", ")", "\n", "self", ".", "loss_dfl", "=", "build_loss", "(", "loss_dfl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead._init_layers": [[117, 149], ["torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "gfl_head.GFLHead.cls_convs.append", "gfl_head.GFLHead.reg_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.Scale"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "assert", "self", ".", "num_anchors", "==", "1", ",", "'anchor free version'", "\n", "self", ".", "gfl_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "cls_out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "gfl_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "4", "*", "(", "self", ".", "reg_max", "+", "1", ")", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "scales", "=", "nn", ".", "ModuleList", "(", "\n", "[", "Scale", "(", "1.0", ")", "for", "_", "in", "self", ".", "anchor_generator", ".", "strides", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.init_weights": [[150, 159], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "gfl_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "gfl_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.forward": [[160, 177], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: Usually a tuple of classification scores and bbox prediction\n                cls_scores (list[Tensor]): Classification and quality (IoU)\n                    joint scores for all scale levels, each is a 4D-tensor,\n                    the channel number is num_classes.\n                bbox_preds (list[Tensor]): Box distribution logits for all\n                    scale levels, each is a 4D-tensor, the channel number is\n                    4*(n+1), n is max value of integral set.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ",", "self", ".", "scales", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.forward_single": [[178, 203], ["gfl_head.GFLHead.gfl_cls", "scale().float", "cls_conv", "reg_conv", "scale", "gfl_head.GFLHead.gfl_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ",", "scale", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n            scale (:obj: `mmcv.cnn.Scale`): Learnable scale module to resize\n                the bbox prediction.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls and quality joint scores for a single\n                    scale level the channel number is num_classes.\n                bbox_pred (Tensor): Box distribution logits for a single scale\n                    level, the channel number is 4*(n+1), n is max value of\n                    integral set.\n        \"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "", "cls_score", "=", "self", ".", "gfl_cls", "(", "cls_feat", ")", "\n", "bbox_pred", "=", "scale", "(", "self", ".", "gfl_reg", "(", "reg_feat", ")", ")", ".", "float", "(", ")", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.anchor_center": [[204, 216], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["", "def", "anchor_center", "(", "self", ",", "anchors", ")", ":", "\n", "        ", "\"\"\"Get anchor centers from anchors.\n\n        Args:\n            anchors (Tensor): Anchor list with shape (N, 4), \"xyxy\" format.\n\n        Returns:\n            Tensor: Anchor centers with shape (N, 2), \"xy\" format.\n        \"\"\"", "\n", "anchors_cx", "=", "(", "anchors", "[", ":", ",", "2", "]", "+", "anchors", "[", ":", ",", "0", "]", ")", "/", "2", "\n", "anchors_cy", "=", "(", "anchors", "[", ":", ",", "3", "]", "+", "anchors", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "return", "torch", ".", "stack", "(", "[", "anchors_cx", ",", "anchors_cy", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.loss_single": [[217, 304], ["anchors.reshape.reshape.reshape", "cls_score.permute().reshape.permute().reshape.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "bbox_targets.reshape.reshape.reshape", "labels.reshape.reshape.reshape", "label_weights.reshape.reshape.reshape", "label_weights.reshape.reshape.new_zeros", "gfl_head.GFLHead.loss_cls", "len", "cls_score.permute().reshape.permute().reshape.detach().sigmoid", "gfl_head.GFLHead.integral", "mmdet.core.distance2bbox", "mmdet.core.bbox_overlaps", "pos_bbox_pred.reshape", "mmdet.core.bbox2distance().reshape", "gfl_head.GFLHead.loss_bbox", "gfl_head.GFLHead.loss_dfl", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda.sum", "torch.tensor().cuda.sum", "torch.tensor().cuda.sum", "torch.tensor().cuda.sum", "cls_score.permute().reshape.permute().reshape.permute", "bbox_pred.permute().reshape.permute().reshape.permute", "gfl_head.GFLHead.anchor_center", "mmdet.core.distance2bbox.detach", "bbox_pred.permute().reshape.permute().reshape.sum", "bbox_pred.permute().reshape.permute().reshape.sum", "cls_score.permute().reshape.permute().reshape.detach", "torch.tensor().cuda.max", "torch.tensor().cuda.max", "torch.tensor().cuda.max", "torch.tensor().cuda.max", "mmdet.core.bbox2distance", "weight_targets[].expand().reshape", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "weight_targets[].expand"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.anchor_center", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2distance", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "loss_single", "(", "self", ",", "anchors", ",", "cls_score", ",", "bbox_pred", ",", "labels", ",", "label_weights", ",", "\n", "bbox_targets", ",", "stride", ",", "num_total_samples", ")", ":", "\n", "        ", "\"\"\"Compute loss of a single scale level.\n\n        Args:\n            anchors (Tensor): Box reference for each scale level with shape\n                (N, num_total_anchors, 4).\n            cls_score (Tensor): Cls and quality joint scores for each scale\n                level has shape (N, num_classes, H, W).\n            bbox_pred (Tensor): Box distribution logits for each scale\n                level with shape (N, 4*(n+1), H, W), n is max value of integral\n                set.\n            labels (Tensor): Labels of each anchors with shape\n                (N, num_total_anchors).\n            label_weights (Tensor): Label weights of each anchor with shape\n                (N, num_total_anchors)\n            bbox_targets (Tensor): BBox regression targets of each anchor wight\n                shape (N, num_total_anchors, 4).\n            stride (tuple): Stride in this scale level.\n            num_total_samples (int): Number of positive samples that is\n                reduced over all GPUs.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "assert", "stride", "[", "0", "]", "==", "stride", "[", "1", "]", ",", "'h stride is not equal to w stride!'", "\n", "anchors", "=", "anchors", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "\n", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "\n", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", "*", "(", "self", ".", "reg_max", "+", "1", ")", ")", "\n", "bbox_targets", "=", "bbox_targets", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "labels", "=", "labels", ".", "reshape", "(", "-", "1", ")", "\n", "label_weights", "=", "label_weights", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "bg_class_ind", "=", "self", ".", "num_classes", "\n", "pos_inds", "=", "(", "(", "labels", ">=", "0", ")", "\n", "&", "(", "labels", "<", "bg_class_ind", ")", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "score", "=", "label_weights", ".", "new_zeros", "(", "labels", ".", "shape", ")", "\n", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "pos_bbox_targets", "=", "bbox_targets", "[", "pos_inds", "]", "\n", "pos_bbox_pred", "=", "bbox_pred", "[", "pos_inds", "]", "\n", "pos_anchors", "=", "anchors", "[", "pos_inds", "]", "\n", "pos_anchor_centers", "=", "self", ".", "anchor_center", "(", "pos_anchors", ")", "/", "stride", "[", "0", "]", "\n", "\n", "weight_targets", "=", "cls_score", ".", "detach", "(", ")", ".", "sigmoid", "(", ")", "\n", "weight_targets", "=", "weight_targets", ".", "max", "(", "dim", "=", "1", ")", "[", "0", "]", "[", "pos_inds", "]", "\n", "pos_bbox_pred_corners", "=", "self", ".", "integral", "(", "pos_bbox_pred", ")", "\n", "pos_decode_bbox_pred", "=", "distance2bbox", "(", "pos_anchor_centers", ",", "\n", "pos_bbox_pred_corners", ")", "\n", "pos_decode_bbox_targets", "=", "pos_bbox_targets", "/", "stride", "[", "0", "]", "\n", "score", "[", "pos_inds", "]", "=", "bbox_overlaps", "(", "\n", "pos_decode_bbox_pred", ".", "detach", "(", ")", ",", "\n", "pos_decode_bbox_targets", ",", "\n", "is_aligned", "=", "True", ")", "\n", "pred_corners", "=", "pos_bbox_pred", ".", "reshape", "(", "-", "1", ",", "self", ".", "reg_max", "+", "1", ")", "\n", "target_corners", "=", "bbox2distance", "(", "pos_anchor_centers", ",", "\n", "pos_decode_bbox_targets", ",", "\n", "self", ".", "reg_max", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# regression loss", "\n", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "pos_decode_bbox_pred", ",", "\n", "pos_decode_bbox_targets", ",", "\n", "weight", "=", "weight_targets", ",", "\n", "avg_factor", "=", "1.0", ")", "\n", "\n", "# dfl loss", "\n", "loss_dfl", "=", "self", ".", "loss_dfl", "(", "\n", "pred_corners", ",", "\n", "target_corners", ",", "\n", "weight", "=", "weight_targets", "[", ":", ",", "None", "]", ".", "expand", "(", "-", "1", ",", "4", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "avg_factor", "=", "4.0", ")", "\n", "", "else", ":", "\n", "            ", "loss_bbox", "=", "bbox_pred", ".", "sum", "(", ")", "*", "0", "\n", "loss_dfl", "=", "bbox_pred", ".", "sum", "(", ")", "*", "0", "\n", "weight_targets", "=", "torch", ".", "tensor", "(", "0", ")", ".", "cuda", "(", ")", "\n", "\n", "# cls (qfl) loss", "\n", "", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "(", "labels", ",", "score", ")", ",", "\n", "weight", "=", "label_weights", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "\n", "return", "loss_cls", ",", "loss_bbox", ",", "loss_dfl", ",", "weight_targets", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.loss": [[305, 377], ["mmdet.core.force_fp32", "gfl_head.GFLHead.get_anchors", "gfl_head.GFLHead.get_targets", "reduce_mean().item", "max", "mmdet.core.multi_apply", "sum", "reduce_mean().item", "list", "list", "dict", "len", "map", "map", "featmap.size", "gfl_head.reduce_mean", "gfl_head.reduce_mean", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.reduce_mean", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.reduce_mean"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Cls and quality scores for each scale\n                level has shape (N, num_classes, H, W).\n            bbox_preds (list[Tensor]): Box distribution logits for each scale\n                level with shape (N, 4*(n+1), H, W), n is max value of integral\n                set.\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (list[Tensor] | None): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "(", "anchor_list", ",", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "\n", "num_total_samples", "=", "reduce_mean", "(", "\n", "torch", ".", "tensor", "(", "num_total_pos", ")", ".", "cuda", "(", ")", ")", ".", "item", "(", ")", "\n", "num_total_samples", "=", "max", "(", "num_total_samples", ",", "1.0", ")", "\n", "\n", "losses_cls", ",", "losses_bbox", ",", "losses_dfl", ",", "avg_factor", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "anchor_list", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "\n", "self", ".", "anchor_generator", ".", "strides", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "\n", "avg_factor", "=", "sum", "(", "avg_factor", ")", "\n", "avg_factor", "=", "reduce_mean", "(", "avg_factor", ")", ".", "item", "(", ")", "\n", "losses_bbox", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", "/", "avg_factor", ",", "losses_bbox", ")", ")", "\n", "losses_dfl", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", "/", "avg_factor", ",", "losses_dfl", ")", ")", "\n", "return", "dict", "(", "\n", "loss_cls", "=", "losses_cls", ",", "loss_bbox", "=", "losses_bbox", ",", "loss_dfl", "=", "losses_dfl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead._get_bboxes_single": [[378, 457], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "len", "len", "len", "cls_score.permute().reshape().sigmoid", "bbox_pred.permute.permute.permute", "cfg.get", "mmdet.core.distance2bbox", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_tensor", "gfl_head.GFLHead.integral", "cls_score.permute().reshape().sigmoid.max", "max_scores.topk", "gfl_head.GFLHead.anchor_center", "cls_score.size", "bbox_pred.permute.permute.size", "cls_score.permute().reshape", "cls_score.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.anchor_center"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "mlvl_anchors", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into labeled boxes.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for a single scale level\n                has shape (num_classes, H, W).\n            bbox_preds (list[Tensor]): Box distribution logits for a single\n                scale level with shape (4*(n+1), H, W), n is max value of\n                integral set.\n            mlvl_anchors (list[Tensor]): Box reference for a single scale level\n                with shape (num_total_anchors, 4).\n            img_shape (tuple[int]): Shape of the input image,\n                (height, width, 3).\n            scale_factor (ndarray): Scale factor of the image arange as\n                (w_scale, h_scale, w_scale, h_scale).\n            cfg (mmcv.Config | None): Test / postprocessing configuration,\n                if None, test_cfg would be used.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n\n        Returns:\n            tuple(Tensor):\n                det_bboxes (Tensor): Bbox predictions in shape (N, 5), where\n                    the first 4 columns are bounding box positions\n                    (tl_x, tl_y, br_x, br_y) and the 5-th column is a score\n                    between 0 and 1.\n                det_labels (Tensor): A (N,) tensor where each item is the\n                    predicted class label of the corresponding box.\n        \"\"\"", "\n", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "mlvl_anchors", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "stride", ",", "anchors", "in", "zip", "(", "\n", "cls_scores", ",", "bbox_preds", ",", "self", ".", "anchor_generator", ".", "strides", ",", "\n", "mlvl_anchors", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "assert", "stride", "[", "0", "]", "==", "stride", "[", "1", "]", "\n", "\n", "scores", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "\n", "-", "1", ",", "self", ".", "cls_out_channels", ")", ".", "sigmoid", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "bbox_pred", "=", "self", ".", "integral", "(", "bbox_pred", ")", "*", "stride", "[", "0", "]", "\n", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "                ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "\n", "", "bboxes", "=", "distance2bbox", "(", "\n", "self", ".", "anchor_center", "(", "anchors", ")", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "\n", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "mlvl_bboxes", ",", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.get_targets": [[458, 521], ["len", "range", "mmdet.core.multi_apply", "any", "sum", "sum", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "len", "len", "anchors.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "max", "max", "range", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels"], ["", "def", "get_targets", "(", "self", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "None", ",", "\n", "gt_labels_list", "=", "None", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get targets for GFL head.\n\n        This method is almost the same as `AnchorHead.get_targets()`. Besides\n        returning the targets as the parent method does, it also returns the\n        anchors as the first element of the returned tuple.\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "assert", "len", "(", "anchor_list", ")", "==", "len", "(", "valid_flag_list", ")", "==", "num_imgs", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "num_level_anchors_list", "=", "[", "num_level_anchors", "]", "*", "num_imgs", "\n", "\n", "# concat all level anchors and flags to a single tensor", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assert", "len", "(", "anchor_list", "[", "i", "]", ")", "==", "len", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "anchor_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", "\n", "valid_flag_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_bboxes_ignore_list", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "if", "gt_labels_list", "is", "None", ":", "\n", "            ", "gt_labels_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "(", "all_anchors", ",", "all_labels", ",", "all_label_weights", ",", "all_bbox_targets", ",", "\n", "all_bbox_weights", ",", "pos_inds_list", ",", "neg_inds_list", ")", "=", "multi_apply", "(", "\n", "self", ".", "_get_target_single", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "num_level_anchors_list", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_bboxes_ignore_list", ",", "\n", "gt_labels_list", ",", "\n", "img_metas", ",", "\n", "label_channels", "=", "label_channels", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "# no valid anchors", "\n", "if", "any", "(", "[", "labels", "is", "None", "for", "labels", "in", "all_labels", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled anchors of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "# split targets to a list w.r.t. multiple levels", "\n", "anchors_list", "=", "images_to_levels", "(", "all_anchors", ",", "num_level_anchors", ")", "\n", "labels_list", "=", "images_to_levels", "(", "all_labels", ",", "num_level_anchors", ")", "\n", "label_weights_list", "=", "images_to_levels", "(", "all_label_weights", ",", "\n", "num_level_anchors", ")", "\n", "bbox_targets_list", "=", "images_to_levels", "(", "all_bbox_targets", ",", "\n", "num_level_anchors", ")", "\n", "bbox_weights_list", "=", "images_to_levels", "(", "all_bbox_weights", ",", "\n", "num_level_anchors", ")", "\n", "return", "(", "anchors_list", ",", "labels_list", ",", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "bbox_weights_list", ",", "num_total_pos", ",", "\n", "num_total_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead._get_target_single": [[522, 625], ["mmdet.core.anchor_inside_flags", "gfl_head.GFLHead.get_num_level_anchors_inside", "gfl_head.GFLHead.assigner.assign", "gfl_head.GFLHead.sampler.sample", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "mmdet.core.unmap.new_full", "mmdet.core.unmap.new_zeros", "mmdet.core.anchor_inside_flags.any", "len", "len", "flat_anchors.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.get_num_level_anchors_inside", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap"], ["", "def", "_get_target_single", "(", "self", ",", "\n", "flat_anchors", ",", "\n", "valid_flags", ",", "\n", "num_level_anchors", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "gt_labels", ",", "\n", "img_meta", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute regression, classification targets for anchors in a single\n        image.\n\n        Args:\n            flat_anchors (Tensor): Multi-level anchors of the image, which are\n                concatenated into a single tensor of shape (num_anchors, 4)\n            valid_flags (Tensor): Multi level valid flags of the image,\n                which are concatenated into a single tensor of\n                    shape (num_anchors,).\n            num_level_anchors Tensor): Number of anchors of each scale level.\n            gt_bboxes (Tensor): Ground truth bboxes of the image,\n                shape (num_gts, 4).\n            gt_bboxes_ignore (Tensor): Ground truth bboxes to be\n                ignored, shape (num_ignored_gts, 4).\n            gt_labels (Tensor): Ground truth labels of each box,\n                shape (num_gts,).\n            img_meta (dict): Meta info of the image.\n            label_channels (int): Channel of label.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple: N is the number of total anchors in the image.\n                anchors (Tensor): All anchors in the image with shape (N, 4).\n                labels (Tensor): Labels of all anchors in the image with shape\n                    (N,).\n                label_weights (Tensor): Label weights of all anchor in the\n                    image with shape (N,).\n                bbox_targets (Tensor): BBox targets of all anchors in the\n                    image with shape (N, 4).\n                bbox_weights (Tensor): BBox weights of all anchors in the\n                    image with shape (N, 4).\n                pos_inds (Tensor): Indices of postive anchor with shape\n                    (num_pos,).\n                neg_inds (Tensor): Indices of negative anchor with shape\n                    (num_neg,).\n        \"\"\"", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "\n", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# assign gt and sample anchors", "\n", "", "anchors", "=", "flat_anchors", "[", "inside_flags", ",", ":", "]", "\n", "\n", "num_level_anchors_inside", "=", "self", ".", "get_num_level_anchors_inside", "(", "\n", "num_level_anchors", ",", "inside_flags", ")", "\n", "assign_result", "=", "self", ".", "assigner", ".", "assign", "(", "anchors", ",", "num_level_anchors_inside", ",", "\n", "gt_bboxes", ",", "gt_bboxes_ignore", ",", "\n", "gt_labels", ")", "\n", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "anchors", ",", "\n", "gt_bboxes", ")", "\n", "\n", "num_valid_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "bbox_targets", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "bbox_weights", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "labels", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "anchors", ".", "new_zeros", "(", "num_valid_anchors", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "pos_bbox_targets", "=", "sampling_result", ".", "pos_gt_bboxes", "\n", "bbox_targets", "[", "pos_inds", ",", ":", "]", "=", "pos_bbox_targets", "\n", "bbox_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "if", "gt_labels", "is", "None", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "self", ".", "train_cfg", ".", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "self", ".", "train_cfg", ".", "pos_weight", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# map up to original set of anchors", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_anchors", ".", "size", "(", "0", ")", "\n", "anchors", "=", "unmap", "(", "anchors", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "labels", "=", "unmap", "(", "\n", "labels", ",", "num_total_anchors", ",", "inside_flags", ",", "fill", "=", "self", ".", "num_classes", ")", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "bbox_targets", "=", "unmap", "(", "bbox_targets", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_weights", "=", "unmap", "(", "bbox_weights", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "\n", "", "return", "(", "anchors", ",", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", ",", "\n", "pos_inds", ",", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.GFLHead.get_num_level_anchors_inside": [[626, 632], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "int", "flags.sum"], "methods", ["None"], ["", "def", "get_num_level_anchors_inside", "(", "self", ",", "num_level_anchors", ",", "inside_flags", ")", ":", "\n", "        ", "split_inside_flags", "=", "torch", ".", "split", "(", "inside_flags", ",", "num_level_anchors", ")", "\n", "num_level_anchors_inside", "=", "[", "\n", "int", "(", "flags", ".", "sum", "(", ")", ")", "for", "flags", "in", "split_inside_flags", "\n", "]", "\n", "return", "num_level_anchors_inside", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.gfl_head.reduce_mean": [[15, 21], ["tensor.clone.clone", "torch.all_reduce", "tensor.clone.div_", "torch.is_available", "torch.is_initialized", "torch.get_world_size"], "function", ["None"], ["def", "reduce_mean", "(", "tensor", ")", ":", "\n", "    ", "if", "not", "(", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ")", ":", "\n", "        ", "return", "tensor", "\n", "", "tensor", "=", "tensor", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "tensor", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ",", "op", "=", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_head.RetinaHead.__init__": [[28, 49], ["dict", "anchor_head.AnchorHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "4", ",", "\n", "scales_per_octave", "=", "3", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "super", "(", "RetinaHead", ",", "self", ")", ".", "__init__", "(", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "anchor_generator", "=", "anchor_generator", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_head.RetinaHead._init_layers": [[50, 82], ["torch.ReLU", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv2d", "torch.Conv2d", "retina_head.RetinaHead.cls_convs.append", "retina_head.RetinaHead.reg_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "self", ".", "retina_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "retina_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_head.RetinaHead.init_weights": [[83, 92], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "retina_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.retina_head.RetinaHead.forward_single": [[93, 115], ["retina_head.RetinaHead.retina_cls", "retina_head.RetinaHead.retina_reg", "cls_conv", "reg_conv"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls scores for a single scale level\n                    the channels number is num_anchors * num_classes.\n                bbox_pred (Tensor): Box energies / deltas for a single scale\n                    level, the channels number is num_anchors * 4.\n        \"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ")", "\n", "bbox_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.nasfcos_head.NASFCOSHead._init_layers": [[20, 62], ["dict", "dict", "dict", "torch.ModuleList", "torch.ModuleList", "enumerate", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "copy.deepcopy", "isinstance", "copy.deepcopy.pop", "copy.deepcopy.pop", "copy.deepcopy.pop", "mmcv.cnn.ConvModule", "nasfcos_head.NASFCOSHead.cls_convs.append", "nasfcos_head.NASFCOSHead.reg_convs.append", "copy.deepcopy", "copy.deepcopy", "mmcv.cnn.Scale"], "methods", ["None"], ["def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "dconv3x3_config", "=", "dict", "(", "\n", "type", "=", "'DCNv2'", ",", "\n", "kernel_size", "=", "3", ",", "\n", "use_bias", "=", "True", ",", "\n", "deform_groups", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "conv3x3_config", "=", "dict", "(", "type", "=", "'Conv'", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "conv1x1_config", "=", "dict", "(", "type", "=", "'Conv'", ",", "kernel_size", "=", "1", ")", "\n", "\n", "self", ".", "arch_config", "=", "[", "\n", "dconv3x3_config", ",", "conv3x3_config", ",", "dconv3x3_config", ",", "conv1x1_config", "\n", "]", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", ",", "op_", "in", "enumerate", "(", "self", ".", "arch_config", ")", ":", "\n", "            ", "op", "=", "copy", ".", "deepcopy", "(", "op_", ")", "\n", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "assert", "isinstance", "(", "op", ",", "dict", ")", "\n", "use_bias", "=", "op", ".", "pop", "(", "'use_bias'", ",", "False", ")", "\n", "padding", "=", "op", ".", "pop", "(", "'padding'", ",", "0", ")", "\n", "kernel_size", "=", "op", ".", "pop", "(", "'kernel_size'", ")", "\n", "module", "=", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "padding", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "use_bias", ",", "\n", "conv_cfg", "=", "op", ")", "\n", "\n", "self", ".", "cls_convs", ".", "append", "(", "copy", ".", "deepcopy", "(", "module", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "copy", ".", "deepcopy", "(", "module", ")", ")", "\n", "\n", "", "self", ".", "conv_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "cls_out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_reg", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_centerness", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "1", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n", "self", ".", "scales", "=", "nn", ".", "ModuleList", "(", "[", "Scale", "(", "1.0", ")", "for", "_", "in", "self", ".", "strides", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.nasfcos_head.NASFCOSHead.init_weights": [[63, 76], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "branch.modules", "isinstance", "isinstance", "mmcv.cnn.caffe2_xavier_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "# retinanet_bias_init", "\n", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_reg", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_centerness", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "\n", "for", "branch", "in", "[", "self", ".", "cls_convs", ",", "self", ".", "reg_convs", "]", ":", "\n", "            ", "for", "module", "in", "branch", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "module", ",", "ConvModule", ")", "and", "isinstance", "(", "module", ".", "conv", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "caffe2_xavier_init", "(", "module", ".", "conv", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead.__init__": [[20, 23], ["rpn_test_mixin.RPNTestMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "RPNHead", ",", "self", ")", ".", "__init__", "(", "\n", "1", ",", "in_channels", ",", "background_label", "=", "0", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead._init_layers": [[24, 31], ["torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "rpn_conv", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "self", ".", "feat_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "rpn_cls", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "1", ")", "\n", "self", ".", "rpn_reg", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead.init_weights": [[32, 37], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "normal_init", "(", "self", ".", "rpn_conv", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "rpn_cls", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "rpn_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead.forward_single": [[38, 45], ["rpn_head.RPNHead.rpn_conv", "torch.relu", "torch.relu", "torch.relu", "rpn_head.RPNHead.rpn_cls", "rpn_head.RPNHead.rpn_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature map of a single scale level.\"\"\"", "\n", "x", "=", "self", ".", "rpn_conv", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ",", "inplace", "=", "True", ")", "\n", "rpn_cls_score", "=", "self", ".", "rpn_cls", "(", "x", ")", "\n", "rpn_bbox_pred", "=", "self", ".", "rpn_reg", "(", "x", ")", "\n", "return", "rpn_cls_score", ",", "rpn_bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead.loss": [[46, 78], ["super().loss", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "losses", "=", "super", "(", "RPNHead", ",", "self", ")", ".", "loss", "(", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "None", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "return", "dict", "(", "\n", "loss_rpn_cls", "=", "losses", "[", "'loss_cls'", "]", ",", "loss_rpn_bbox", "=", "losses", "[", "'loss_bbox'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.rpn_head.RPNHead._get_bboxes_single": [[79, 169], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "rpn_head.RPNHead.bbox_coder.decode", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "dict", "mmcv.ops.batched_nms", "len", "rpn_cls_score.reshape.reshape.permute", "rpn_bbox_pred.permute().reshape.permute().reshape.permute().reshape", "mlvl_scores.append", "mlvl_bbox_preds.append", "mlvl_valid_anchors.append", "level_ids.append", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "rpn_cls_score.reshape.reshape.reshape", "rpn_cls_score.reshape.reshape.sigmoid", "rpn_cls_score.reshape.reshape.reshape", "rpn_cls_score.reshape.sigmoid.sort", "rpn_cls_score.reshape.sigmoid.new_full", "torch.nonzero().squeeze.sum().item", "torch.nonzero().squeeze.sum().item", "torch.nonzero().squeeze.sum().item", "len", "rpn_cls_score.reshape.reshape.size", "rpn_bbox_pred.permute().reshape.permute().reshape.size", "rpn_cls_score.reshape.reshape.softmax", "rpn_bbox_pred.permute().reshape.permute().reshape.permute", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "rpn_cls_score.reshape.sigmoid.size", "torch.nonzero().squeeze.sum", "torch.nonzero().squeeze.sum", "torch.nonzero().squeeze.sum"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "mlvl_anchors", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (num_anchors * num_classes, H, W).\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (num_anchors * 4, H, W).\n            mlvl_anchors (list[Tensor]): Box reference for each scale level\n                with shape (num_total_anchors, 4).\n            img_shape (tuple[int]): Shape of the input image,\n                (height, width, 3).\n            scale_factor (ndarray): Scale factor of the image arange as\n                (w_scale, h_scale, w_scale, h_scale).\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used.\n            rescale (bool): If True, return boxes in original image space.\n\n        Returns:\n            Tensor: Labeled boxes in shape (n, 5), where the first 4 columns\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the\n                5-th column is a score between 0 and 1.\n        \"\"\"", "\n", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "# bboxes from different level should be independent during NMS,", "\n", "# level_ids are used as labels for batched NMS to separate them", "\n", "level_ids", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "mlvl_bbox_preds", "=", "[", "]", "\n", "mlvl_valid_anchors", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "cls_scores", ")", ")", ":", "\n", "            ", "rpn_cls_score", "=", "cls_scores", "[", "idx", "]", "\n", "rpn_bbox_pred", "=", "bbox_preds", "[", "idx", "]", "\n", "assert", "rpn_cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "rpn_bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "rpn_cls_score", "=", "rpn_cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "rpn_cls_score", "=", "rpn_cls_score", ".", "reshape", "(", "-", "1", ")", "\n", "scores", "=", "rpn_cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "rpn_cls_score", "=", "rpn_cls_score", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "# we set FG labels to [0, num_class-1] and BG label to", "\n", "# num_class in other heads since mmdet v2.0, However we", "\n", "# keep BG label as 0 and FG label as 1 in rpn head", "\n", "scores", "=", "rpn_cls_score", ".", "softmax", "(", "dim", "=", "1", ")", "[", ":", ",", "1", "]", "\n", "", "rpn_bbox_pred", "=", "rpn_bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "anchors", "=", "mlvl_anchors", "[", "idx", "]", "\n", "if", "cfg", ".", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "cfg", ".", "nms_pre", ":", "\n", "# sort is faster than topk", "\n", "# _, topk_inds = scores.topk(cfg.nms_pre)", "\n", "                ", "ranked_scores", ",", "rank_inds", "=", "scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "topk_inds", "=", "rank_inds", "[", ":", "cfg", ".", "nms_pre", "]", "\n", "scores", "=", "ranked_scores", "[", ":", "cfg", ".", "nms_pre", "]", "\n", "rpn_bbox_pred", "=", "rpn_bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "mlvl_bbox_preds", ".", "append", "(", "rpn_bbox_pred", ")", "\n", "mlvl_valid_anchors", ".", "append", "(", "anchors", ")", "\n", "level_ids", ".", "append", "(", "\n", "scores", ".", "new_full", "(", "(", "scores", ".", "size", "(", "0", ")", ",", ")", ",", "idx", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "\n", "", "scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "anchors", "=", "torch", ".", "cat", "(", "mlvl_valid_anchors", ")", "\n", "rpn_bbox_pred", "=", "torch", ".", "cat", "(", "mlvl_bbox_preds", ")", "\n", "proposals", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "anchors", ",", "rpn_bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "ids", "=", "torch", ".", "cat", "(", "level_ids", ")", "\n", "\n", "if", "cfg", ".", "min_bbox_size", ">", "0", ":", "\n", "            ", "w", "=", "proposals", "[", ":", ",", "2", "]", "-", "proposals", "[", ":", ",", "0", "]", "\n", "h", "=", "proposals", "[", ":", ",", "3", "]", "-", "proposals", "[", ":", ",", "1", "]", "\n", "valid_inds", "=", "torch", ".", "nonzero", "(", "\n", "(", "w", ">=", "cfg", ".", "min_bbox_size", ")", "\n", "&", "(", "h", ">=", "cfg", ".", "min_bbox_size", ")", ",", "\n", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "valid_inds", ".", "sum", "(", ")", ".", "item", "(", ")", "!=", "len", "(", "proposals", ")", ":", "\n", "                ", "proposals", "=", "proposals", "[", "valid_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "valid_inds", "]", "\n", "ids", "=", "ids", "[", "valid_inds", "]", "\n", "\n", "# TODO: remove the hard coded nms type", "\n", "", "", "nms_cfg", "=", "dict", "(", "type", "=", "'nms'", ",", "iou_threshold", "=", "cfg", ".", "nms_thr", ")", "\n", "dets", ",", "keep", "=", "batched_nms", "(", "proposals", ",", "scores", ",", "ids", ",", "nms_cfg", ")", "\n", "return", "dets", "[", ":", "cfg", ".", "nms_post", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.__init__": [[41, 85], ["dict", "dict", "base_dense_head.BaseDenseHead.__init__", "builder.build_loss", "builder.build_loss", "anchor_free_head.AnchorFreeHead._init_layers", "isinstance"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "feat_channels", "=", "256", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "strides", "=", "(", "4", ",", "8", ",", "16", ",", "32", ",", "64", ")", ",", "\n", "dcn_on_last_conv", "=", "False", ",", "\n", "conv_bias", "=", "'auto'", ",", "\n", "background_label", "=", "None", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'FocalLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "type", "=", "'IoULoss'", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "AnchorFreeHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "feat_channels", "=", "feat_channels", "\n", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "dcn_on_last_conv", "=", "dcn_on_last_conv", "\n", "assert", "conv_bias", "==", "'auto'", "or", "isinstance", "(", "conv_bias", ",", "bool", ")", "\n", "self", ".", "conv_bias", "=", "conv_bias", "\n", "self", ".", "loss_cls", "=", "build_loss", "(", "loss_cls", ")", "\n", "self", ".", "loss_bbox", "=", "build_loss", "(", "loss_bbox", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "self", ".", "background_label", "=", "(", "\n", "num_classes", "if", "background_label", "is", "None", "else", "background_label", ")", "\n", "# background_label should be either 0 or num_classes", "\n", "assert", "(", "self", ".", "background_label", "==", "0", "\n", "or", "self", ".", "background_label", "==", "num_classes", ")", "\n", "\n", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_layers": [[86, 91], ["anchor_free_head.AnchorFreeHead._init_cls_convs", "anchor_free_head.AnchorFreeHead._init_reg_convs", "anchor_free_head.AnchorFreeHead._init_predictor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_cls_convs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_reg_convs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_predictor"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "_init_cls_convs", "(", ")", "\n", "self", ".", "_init_reg_convs", "(", ")", "\n", "self", ".", "_init_predictor", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_cls_convs": [[92, 111], ["torch.ModuleList", "torch.ModuleList", "range", "anchor_free_head.AnchorFreeHead.cls_convs.append", "dict", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_cls_convs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize classification conv layers of the head.\"\"\"", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "if", "self", ".", "dcn_on_last_conv", "and", "i", "==", "self", ".", "stacked_convs", "-", "1", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'DCNv2'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "conv_bias", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_reg_convs": [[112, 131], ["torch.ModuleList", "torch.ModuleList", "range", "anchor_free_head.AnchorFreeHead.reg_convs.append", "dict", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "", "def", "_init_reg_convs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize bbox regression conv layers of the head.\"\"\"", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "if", "self", ".", "dcn_on_last_conv", "and", "i", "==", "self", ".", "stacked_convs", "-", "1", ":", "\n", "                ", "conv_cfg", "=", "dict", "(", "type", "=", "'DCNv2'", ")", "\n", "", "else", ":", "\n", "                ", "conv_cfg", "=", "self", ".", "conv_cfg", "\n", "", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "bias", "=", "self", ".", "conv_bias", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._init_predictor": [[132, 137], ["torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["None"], ["", "", "def", "_init_predictor", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize predictor layers of the head.\"\"\"", "\n", "self", ".", "conv_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "cls_out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_reg", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "4", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.init_weights": [[138, 149], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "isinstance", "isinstance", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "if", "isinstance", "(", "m", ".", "conv", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "if", "isinstance", "(", "m", ".", "conv", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "conv_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._load_from_state_dict": [[150, 187], ["local_metadata.get", "super()._load_from_state_dict", "range", "ori_predictor_keys.append", "key.split.split.split", "key[].endswith", "len", "state_dict.pop", "state_dict.keys", "k.startswith", "key[].endswith", "new_predictor_keys.append", "ori_predictor_keys.pop", "key[].endswith"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._load_from_state_dict"], ["", "def", "_load_from_state_dict", "(", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "\n", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", ")", ":", "\n", "        ", "\"\"\"Hack some keys of the model state dict so that can load checkpoints\n        of previous version.\"\"\"", "\n", "version", "=", "local_metadata", ".", "get", "(", "'version'", ",", "None", ")", "\n", "if", "version", "is", "None", ":", "\n", "# the key is different in early versions", "\n", "# for example, 'fcos_cls' become 'conv_cls' now", "\n", "            ", "bbox_head_keys", "=", "[", "\n", "k", "for", "k", "in", "state_dict", ".", "keys", "(", ")", "if", "k", ".", "startswith", "(", "prefix", ")", "\n", "]", "\n", "ori_predictor_keys", "=", "[", "]", "\n", "new_predictor_keys", "=", "[", "]", "\n", "# e.g. 'fcos_cls' or 'fcos_reg'", "\n", "for", "key", "in", "bbox_head_keys", ":", "\n", "                ", "ori_predictor_keys", ".", "append", "(", "key", ")", "\n", "key", "=", "key", ".", "split", "(", "'.'", ")", "\n", "conv_name", "=", "None", "\n", "if", "key", "[", "1", "]", ".", "endswith", "(", "'cls'", ")", ":", "\n", "                    ", "conv_name", "=", "'conv_cls'", "\n", "", "elif", "key", "[", "1", "]", ".", "endswith", "(", "'reg'", ")", ":", "\n", "                    ", "conv_name", "=", "'conv_reg'", "\n", "", "elif", "key", "[", "1", "]", ".", "endswith", "(", "'centerness'", ")", ":", "\n", "                    ", "conv_name", "=", "'conv_centerness'", "\n", "", "else", ":", "\n", "                    ", "assert", "NotImplementedError", "\n", "", "if", "conv_name", "is", "not", "None", ":", "\n", "                    ", "key", "[", "1", "]", "=", "conv_name", "\n", "new_predictor_keys", ".", "append", "(", "'.'", ".", "join", "(", "key", ")", ")", "\n", "", "else", ":", "\n", "                    ", "ori_predictor_keys", ".", "pop", "(", "-", "1", ")", "\n", "", "", "for", "i", "in", "range", "(", "len", "(", "new_predictor_keys", ")", ")", ":", "\n", "                ", "state_dict", "[", "new_predictor_keys", "[", "i", "]", "]", "=", "state_dict", ".", "pop", "(", "\n", "ori_predictor_keys", "[", "i", "]", ")", "\n", "", "", "super", "(", ")", ".", "_load_from_state_dict", "(", "state_dict", ",", "prefix", ",", "local_metadata", ",", "\n", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "\n", "error_msgs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.forward": [[188, 205], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: Usually contain classification scores and bbox predictions.\n                cls_scores (list[Tensor]): Box scores for each scale level,\n                    each is a 4D-tensor, the channel number is\n                    num_points * num_classes.\n                bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                    level, each is a 4D-tensor, the channel number is\n                    num_points * 4.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "[", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.forward_single": [[206, 228], ["anchor_free_head.AnchorFreeHead.conv_cls", "anchor_free_head.AnchorFreeHead.conv_reg", "cls_layer", "reg_layer"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward features of a single scale levle.\n\n        Args:\n            x (Tensor): FPN feature maps of the specified stride.\n\n        Returns:\n            tuple: Scores for each class, bbox predictions, features\n                after classification and regression conv layers, some\n                models needs these features like FCOS.\n        \"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "\n", "for", "cls_layer", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_layer", "(", "cls_feat", ")", "\n", "", "cls_score", "=", "self", ".", "conv_cls", "(", "cls_feat", ")", "\n", "\n", "for", "reg_layer", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_layer", "(", "reg_feat", ")", "\n", "", "bbox_pred", "=", "self", ".", "conv_reg", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "cls_feat", ",", "reg_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.loss": [[229, 257], ["mmdet.core.force_fp32"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "abstractmethod", "\n", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute loss of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level,\n                each is a 4D-tensor, the channel number is\n                num_points * num_classes.\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level, each is a 4D-tensor, the channel number is\n                num_points * 4.\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.get_bboxes": [[258, 281], ["mmdet.core.force_fp32"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "@", "abstractmethod", "\n", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "None", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_points * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_points * 4, H, W)\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used\n            rescale (bool): If True, return boxes in original image space\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.get_targets": [[282, 296], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_targets", "(", "self", ",", "points", ",", "gt_bboxes_list", ",", "gt_labels_list", ")", ":", "\n", "        ", "\"\"\"Compute regression, classification and centerss targets for points\n        in multiple images.\n\n        Args:\n            points (list[Tensor]): Points of each fpn level, each has shape\n                (num_points, 2).\n            gt_bboxes_list (list[Tensor]): Ground truth bboxes of each image,\n                each has shape (num_gt, 4).\n            gt_labels_list (list[Tensor]): Ground truth labels of each box,\n                each has shape (num_gt,).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._get_points_single": [[297, 312], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "y.flatten.flatten.flatten", "x.flatten.flatten.flatten"], "methods", ["None"], ["", "def", "_get_points_single", "(", "self", ",", "\n", "featmap_size", ",", "\n", "stride", ",", "\n", "dtype", ",", "\n", "device", ",", "\n", "flatten", "=", "False", ")", ":", "\n", "        ", "\"\"\"Get points of a single scale level.\"\"\"", "\n", "h", ",", "w", "=", "featmap_size", "\n", "x_range", "=", "torch", ".", "arange", "(", "w", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "y_range", "=", "torch", ".", "arange", "(", "h", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "y", ",", "x", "=", "torch", ".", "meshgrid", "(", "y_range", ",", "x_range", ")", "\n", "if", "flatten", ":", "\n", "            ", "y", "=", "y", ".", "flatten", "(", ")", "\n", "x", "=", "x", ".", "flatten", "(", ")", "\n", "", "return", "y", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead.get_points": [[313, 330], ["range", "len", "mlvl_points.append", "anchor_free_head.AnchorFreeHead._get_points_single"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_free_head.AnchorFreeHead._get_points_single"], ["", "def", "get_points", "(", "self", ",", "featmap_sizes", ",", "dtype", ",", "device", ",", "flatten", "=", "False", ")", ":", "\n", "        ", "\"\"\"Get points according to feature map sizes.\n\n        Args:\n            featmap_sizes (list[tuple]): Multi-level feature map sizes.\n            dtype (torch.dtype): Type of points.\n            device (torch.device): Device of points.\n\n        Returns:\n            tuple: points of each image.\n        \"\"\"", "\n", "mlvl_points", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "featmap_sizes", ")", ")", ":", "\n", "            ", "mlvl_points", ".", "append", "(", "\n", "self", ".", "_get_points_single", "(", "featmap_sizes", "[", "i", "]", ",", "self", ".", "strides", "[", "i", "]", ",", "\n", "dtype", ",", "device", ",", "flatten", ")", ")", "\n", "", "return", "mlvl_points", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead.__init__": [[16, 19], ["rpn_test_mixin.RPNTestMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "GARPNHead", ",", "self", ")", ".", "__init__", "(", "\n", "1", ",", "in_channels", ",", "background_label", "=", "0", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead._init_layers": [[20, 25], ["torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "super()._init_layers"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "rpn_conv", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "self", ".", "feat_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "super", "(", "GARPNHead", ",", "self", ")", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead.init_weights": [[26, 30], ["mmcv.cnn.normal_init", "super().init_weights"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "normal_init", "(", "self", ".", "rpn_conv", ",", "std", "=", "0.01", ")", "\n", "super", "(", "GARPNHead", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead.forward_single": [[31, 39], ["ga_rpn_head.GARPNHead.rpn_conv", "torch.relu", "torch.relu", "torch.relu", "super().forward_single"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward_single"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\"\"\"", "\n", "\n", "x", "=", "self", ".", "rpn_conv", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ",", "inplace", "=", "True", ")", "\n", "(", "cls_score", ",", "bbox_pred", ",", "shape_pred", ",", "\n", "loc_pred", ")", "=", "super", "(", "GARPNHead", ",", "self", ")", ".", "forward_single", "(", "x", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "shape_pred", ",", "loc_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead.loss": [[40, 62], ["super().loss", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "losses", "=", "super", "(", "GARPNHead", ",", "self", ")", ".", "loss", "(", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "shape_preds", ",", "\n", "loc_preds", ",", "\n", "gt_bboxes", ",", "\n", "None", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "return", "dict", "(", "\n", "loss_rpn_cls", "=", "losses", "[", "'loss_cls'", "]", ",", "\n", "loss_rpn_bbox", "=", "losses", "[", "'loss_bbox'", "]", ",", "\n", "loss_anchor_shape", "=", "losses", "[", "'loss_shape'", "]", ",", "\n", "loss_anchor_loc", "=", "losses", "[", "'loss_loc'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.ga_rpn_head.GARPNHead._get_bboxes_single": [[63, 135], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "rpn_cls_score.reshape.reshape.permute", "ga_rpn_head.GARPNHead.bbox_coder.decode", "mmcv.ops.nms", "mlvl_proposals.append", "mmcv.ops.nms", "min", "scores.unsqueeze.unsqueeze.topk", "mask.sum", "rpn_cls_score.reshape.reshape.reshape", "rpn_cls_score.reshape.reshape.sigmoid", "rpn_cls_score.reshape.reshape.reshape", "rpn_bbox_pred.unsqueeze.unsqueeze.permute().reshape", "scores.unsqueeze.unsqueeze.dim", "rpn_bbox_pred.unsqueeze.unsqueeze.unsqueeze", "anchors.unsqueeze.unsqueeze.unsqueeze", "scores.unsqueeze.unsqueeze.unsqueeze", "scores.unsqueeze.unsqueeze.topk", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "rpn_cls_score.reshape.reshape.size", "rpn_bbox_pred.unsqueeze.unsqueeze.size", "rpn_cls_score.reshape.reshape.softmax", "rpn_bbox_pred.unsqueeze.unsqueeze.permute", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "mlvl_anchors", ",", "\n", "mlvl_masks", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "mlvl_proposals", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "cls_scores", ")", ")", ":", "\n", "            ", "rpn_cls_score", "=", "cls_scores", "[", "idx", "]", "\n", "rpn_bbox_pred", "=", "bbox_preds", "[", "idx", "]", "\n", "anchors", "=", "mlvl_anchors", "[", "idx", "]", "\n", "mask", "=", "mlvl_masks", "[", "idx", "]", "\n", "assert", "rpn_cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "rpn_bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "# if no location is kept, end.", "\n", "if", "mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "rpn_cls_score", "=", "rpn_cls_score", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "rpn_cls_score", "=", "rpn_cls_score", ".", "reshape", "(", "-", "1", ")", "\n", "scores", "=", "rpn_cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "rpn_cls_score", "=", "rpn_cls_score", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "scores", "=", "rpn_cls_score", ".", "softmax", "(", "dim", "=", "1", ")", "[", ":", ",", ":", "-", "1", "]", "\n", "# filter scores, bbox_pred w.r.t. mask.", "\n", "# anchors are filtered in get_anchors() beforehand.", "\n", "", "scores", "=", "scores", "[", "mask", "]", "\n", "rpn_bbox_pred", "=", "rpn_bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "\n", "4", ")", "[", "mask", ",", ":", "]", "\n", "if", "scores", ".", "dim", "(", ")", "==", "0", ":", "\n", "                ", "rpn_bbox_pred", "=", "rpn_bbox_pred", ".", "unsqueeze", "(", "0", ")", "\n", "anchors", "=", "anchors", ".", "unsqueeze", "(", "0", ")", "\n", "scores", "=", "scores", ".", "unsqueeze", "(", "0", ")", "\n", "# filter anchors, bbox_pred, scores w.r.t. scores", "\n", "", "if", "cfg", ".", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "cfg", ".", "nms_pre", ":", "\n", "                ", "_", ",", "topk_inds", "=", "scores", ".", "topk", "(", "cfg", ".", "nms_pre", ")", "\n", "rpn_bbox_pred", "=", "rpn_bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", "]", "\n", "# get proposals w.r.t. anchors and rpn_bbox_pred", "\n", "", "proposals", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "anchors", ",", "rpn_bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "# filter out too small bboxes", "\n", "if", "cfg", ".", "min_bbox_size", ">", "0", ":", "\n", "                ", "w", "=", "proposals", "[", ":", ",", "2", "]", "-", "proposals", "[", ":", ",", "0", "]", "\n", "h", "=", "proposals", "[", ":", ",", "3", "]", "-", "proposals", "[", ":", ",", "1", "]", "\n", "valid_inds", "=", "torch", ".", "nonzero", "(", "\n", "(", "w", ">=", "cfg", ".", "min_bbox_size", ")", "&", "(", "h", ">=", "cfg", ".", "min_bbox_size", ")", ",", "\n", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "proposals", "=", "proposals", "[", "valid_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "valid_inds", "]", "\n", "# NMS in current level", "\n", "", "proposals", ",", "_", "=", "nms", "(", "proposals", ",", "scores", ",", "cfg", ".", "nms_thr", ")", "\n", "proposals", "=", "proposals", "[", ":", "cfg", ".", "nms_post", ",", ":", "]", "\n", "mlvl_proposals", ".", "append", "(", "proposals", ")", "\n", "", "proposals", "=", "torch", ".", "cat", "(", "mlvl_proposals", ",", "0", ")", "\n", "if", "cfg", ".", "nms_across_levels", ":", "\n", "# NMS across multi levels", "\n", "            ", "proposals", ",", "_", "=", "nms", "(", "proposals", "[", ":", ",", ":", "4", "]", ",", "proposals", "[", ":", ",", "-", "1", "]", ",", "cfg", ".", "nms_thr", ")", "\n", "proposals", "=", "proposals", "[", ":", "cfg", ".", "max_num", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "scores", "=", "proposals", "[", ":", ",", "4", "]", "\n", "num", "=", "min", "(", "cfg", ".", "max_num", ",", "proposals", ".", "shape", "[", "0", "]", ")", "\n", "_", ",", "topk_inds", "=", "scores", ".", "topk", "(", "num", ")", "\n", "proposals", "=", "proposals", "[", "topk_inds", ",", ":", "]", "\n", "", "return", "proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.__init__": [[31, 50], ["retina_head.RetinaHead.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "pre_anchor_topk", "=", "50", ",", "\n", "bbox_thr", "=", "0.6", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.5", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FreeAnchorRetinaHead", ",", "\n", "self", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "stacked_convs", ",", "conv_cfg", ",", "\n", "norm_cfg", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "pre_anchor_topk", "=", "pre_anchor_topk", "\n", "self", ".", "bbox_thr", "=", "bbox_thr", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.loss": [[51, 216], ["free_anchor_retina_head.FreeAnchorRetinaHead.get_anchors", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "cls.permute().reshape", "bbox_pred.permute().reshape", "zip", "mmdet.core.bbox_overlaps", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "free_anchor_retina_head.FreeAnchorRetinaHead.bbox_coder.encode", "free_anchor_retina_head.FreeAnchorRetinaHead.loss_bbox().sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "len", "positive_losses.append", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "max", "free_anchor_retina_head.FreeAnchorRetinaHead.negative_bag_loss().sum", "max", "featmap.size", "cls.size", "bbox_pred.size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.stack.append", "torch.stack.append", "gt_bboxes_.unsqueeze().expand_as", "free_anchor_retina_head.FreeAnchorRetinaHead.positive_bag_loss", "torch.cat.sum", "torch.cat.sum", "cls.permute", "bbox_pred.permute", "len", "torch.zeros().type_as", "torch.zeros().type_as", "torch.zeros().type_as", "torch.zeros().type_as", "free_anchor_retina_head.FreeAnchorRetinaHead.bbox_coder.decode", "mmdet.core.bbox_overlaps", "mmdet.core.bbox_overlaps.max().values.clamp", "gt_labels_.size", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse.sum().to_dense", "torch.sparse.sum().to_dense", "torch.sparse.sum().to_dense", "torch.sparse.sum().to_dense", "torch.nonzero().t_", "torch.nonzero().t_", "torch.nonzero().t_", "torch.nonzero().t_", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "free_anchor_retina_head.FreeAnchorRetinaHead.loss_bbox", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "free_anchor_retina_head.FreeAnchorRetinaHead.negative_bag_loss", "torch.nonzero().t_.numel", "torch.nonzero().t_.numel", "torch.zeros().type_as", "torch.zeros().type_as", "torch.zeros().type_as", "torch.zeros().type_as", "torch.sparse_coo_tensor().to_dense", "torch.sparse_coo_tensor().to_dense", "torch.sparse_coo_tensor().to_dense", "torch.sparse_coo_tensor().to_dense", "gt_labels_.view().repeat", "gt_bboxes_.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange().type_as", "torch.arange().type_as", "torch.arange().type_as", "torch.arange().type_as", "torch.sparse.sum", "torch.sparse.sum", "torch.sparse.sum", "torch.sparse.sum", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.where().max", "torch.where().max", "torch.where().max", "torch.where().max", "anchors_.size", "mmdet.core.bbox_overlaps.max", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "gt_labels_.view", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "anchors_.size", "torch.where", "torch.where", "torch.where", "torch.where", "torch.nonzero().t_.flip", "torch.nonzero().t_.flip", "torch.tensor().type_as", "torch.tensor().type_as", "torch.tensor().type_as", "torch.tensor().type_as", "gt_labels_.unsqueeze", "anchors_.size", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.positive_bag_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.negative_bag_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): each item are the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "len", "(", "self", ".", "anchor_generator", ".", "base_anchors", ")", "\n", "\n", "anchor_list", ",", "_", "=", "self", ".", "get_anchors", "(", "featmap_sizes", ",", "img_metas", ")", "\n", "anchors", "=", "[", "torch", ".", "cat", "(", "anchor", ")", "for", "anchor", "in", "anchor_list", "]", "\n", "\n", "# concatenate each level", "\n", "cls_scores", "=", "[", "\n", "cls", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "\n", "1", ")", ".", "reshape", "(", "cls", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "for", "cls", "in", "cls_scores", "\n", "]", "\n", "bbox_preds", "=", "[", "\n", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "bbox_pred", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "for", "bbox_pred", "in", "bbox_preds", "\n", "]", "\n", "cls_scores", "=", "torch", ".", "cat", "(", "cls_scores", ",", "dim", "=", "1", ")", "\n", "bbox_preds", "=", "torch", ".", "cat", "(", "bbox_preds", ",", "dim", "=", "1", ")", "\n", "\n", "cls_prob", "=", "torch", ".", "sigmoid", "(", "cls_scores", ")", "\n", "box_prob", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "positive_losses", "=", "[", "]", "\n", "for", "_", ",", "(", "anchors_", ",", "gt_labels_", ",", "gt_bboxes_", ",", "cls_prob_", ",", "\n", "bbox_preds_", ")", "in", "enumerate", "(", "\n", "zip", "(", "anchors", ",", "gt_labels", ",", "gt_bboxes", ",", "cls_prob", ",", "bbox_preds", ")", ")", ":", "\n", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "if", "len", "(", "gt_bboxes_", ")", "==", "0", ":", "\n", "                    ", "image_box_prob", "=", "torch", ".", "zeros", "(", "\n", "anchors_", ".", "size", "(", "0", ")", ",", "\n", "self", ".", "cls_out_channels", ")", ".", "type_as", "(", "bbox_preds_", ")", "\n", "", "else", ":", "\n", "# box_localization: a_{j}^{loc}, shape: [j, 4]", "\n", "                    ", "pred_boxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "anchors_", ",", "bbox_preds_", ")", "\n", "\n", "# object_box_iou: IoU_{ij}^{loc}, shape: [i, j]", "\n", "object_box_iou", "=", "bbox_overlaps", "(", "gt_bboxes_", ",", "pred_boxes", ")", "\n", "\n", "# object_box_prob: P{a_{j} -> b_{i}}, shape: [i, j]", "\n", "t1", "=", "self", ".", "bbox_thr", "\n", "t2", "=", "object_box_iou", ".", "max", "(", "\n", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "values", ".", "clamp", "(", "min", "=", "t1", "+", "1e-12", ")", "\n", "object_box_prob", "=", "(", "(", "object_box_iou", "-", "t1", ")", "/", "\n", "(", "t2", "-", "t1", ")", ")", ".", "clamp", "(", "\n", "min", "=", "0", ",", "max", "=", "1", ")", "\n", "\n", "# object_cls_box_prob: P{a_{j} -> b_{i}}, shape: [i, c, j]", "\n", "num_obj", "=", "gt_labels_", ".", "size", "(", "0", ")", "\n", "indices", "=", "torch", ".", "stack", "(", "[", "\n", "torch", ".", "arange", "(", "num_obj", ")", ".", "type_as", "(", "gt_labels_", ")", ",", "gt_labels_", "\n", "]", ",", "\n", "dim", "=", "0", ")", "\n", "object_cls_box_prob", "=", "torch", ".", "sparse_coo_tensor", "(", "\n", "indices", ",", "object_box_prob", ")", "\n", "\n", "# image_box_iou: P{a_{j} \\in A_{+}}, shape: [c, j]", "\n", "\"\"\"\n                    from \"start\" to \"end\" implement:\n                    image_box_iou = torch.sparse.max(object_cls_box_prob,\n                                                     dim=0).t()\n\n                    \"\"\"", "\n", "# start", "\n", "box_cls_prob", "=", "torch", ".", "sparse", ".", "sum", "(", "\n", "object_cls_box_prob", ",", "dim", "=", "0", ")", ".", "to_dense", "(", ")", "\n", "\n", "indices", "=", "torch", ".", "nonzero", "(", "box_cls_prob", ",", "as_tuple", "=", "False", ")", ".", "t_", "(", ")", "\n", "if", "indices", ".", "numel", "(", ")", "==", "0", ":", "\n", "                        ", "image_box_prob", "=", "torch", ".", "zeros", "(", "\n", "anchors_", ".", "size", "(", "0", ")", ",", "\n", "self", ".", "cls_out_channels", ")", ".", "type_as", "(", "object_box_prob", ")", "\n", "", "else", ":", "\n", "                        ", "nonzero_box_prob", "=", "torch", ".", "where", "(", "\n", "(", "gt_labels_", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", "==", "indices", "[", "0", "]", ")", ",", "\n", "object_box_prob", "[", ":", ",", "indices", "[", "1", "]", "]", ",", "\n", "torch", ".", "tensor", "(", "[", "\n", "0", "\n", "]", ")", ".", "type_as", "(", "object_box_prob", ")", ")", ".", "max", "(", "dim", "=", "0", ")", ".", "values", "\n", "\n", "# upmap to shape [j, c]", "\n", "image_box_prob", "=", "torch", ".", "sparse_coo_tensor", "(", "\n", "indices", ".", "flip", "(", "[", "0", "]", ")", ",", "\n", "nonzero_box_prob", ",", "\n", "size", "=", "(", "anchors_", ".", "size", "(", "0", ")", ",", "\n", "self", ".", "cls_out_channels", ")", ")", ".", "to_dense", "(", ")", "\n", "# end", "\n", "\n", "", "", "box_prob", ".", "append", "(", "image_box_prob", ")", "\n", "\n", "# construct bags for objects", "\n", "", "match_quality_matrix", "=", "bbox_overlaps", "(", "gt_bboxes_", ",", "anchors_", ")", "\n", "_", ",", "matched", "=", "torch", ".", "topk", "(", "\n", "match_quality_matrix", ",", "\n", "self", ".", "pre_anchor_topk", ",", "\n", "dim", "=", "1", ",", "\n", "sorted", "=", "False", ")", "\n", "del", "match_quality_matrix", "\n", "\n", "# matched_cls_prob: P_{ij}^{cls}", "\n", "matched_cls_prob", "=", "torch", ".", "gather", "(", "\n", "cls_prob_", "[", "matched", "]", ",", "2", ",", "\n", "gt_labels_", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "self", ".", "pre_anchor_topk", ",", "\n", "1", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "# matched_box_prob: P_{ij}^{loc}", "\n", "matched_anchors", "=", "anchors_", "[", "matched", "]", "\n", "matched_object_targets", "=", "self", ".", "bbox_coder", ".", "encode", "(", "\n", "matched_anchors", ",", "\n", "gt_bboxes_", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "expand_as", "(", "matched_anchors", ")", ")", "\n", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "bbox_preds_", "[", "matched", "]", ",", "\n", "matched_object_targets", ",", "\n", "reduction_override", "=", "'none'", ")", ".", "sum", "(", "-", "1", ")", "\n", "matched_box_prob", "=", "torch", ".", "exp", "(", "-", "loss_bbox", ")", "\n", "\n", "# positive_losses: {-log( Mean-max(P_{ij}^{cls} * P_{ij}^{loc}) )}", "\n", "num_pos", "+=", "len", "(", "gt_bboxes_", ")", "\n", "positive_losses", ".", "append", "(", "\n", "self", ".", "positive_bag_loss", "(", "matched_cls_prob", ",", "matched_box_prob", ")", ")", "\n", "", "positive_loss", "=", "torch", ".", "cat", "(", "positive_losses", ")", ".", "sum", "(", ")", "/", "max", "(", "1", ",", "num_pos", ")", "\n", "\n", "# box_prob: P{a_{j} \\in A_{+}}", "\n", "box_prob", "=", "torch", ".", "stack", "(", "box_prob", ",", "dim", "=", "0", ")", "\n", "\n", "# negative_loss:", "\n", "# \\sum_{j}{ FL((1 - P{a_{j} \\in A_{+}}) * (1 - P_{j}^{bg})) } / n||B||", "\n", "negative_loss", "=", "self", ".", "negative_bag_loss", "(", "cls_prob", ",", "box_prob", ")", ".", "sum", "(", ")", "/", "max", "(", "\n", "1", ",", "num_pos", "*", "self", ".", "pre_anchor_topk", ")", "\n", "\n", "# avoid the absence of gradients in regression subnet", "\n", "# when no ground-truth in a batch", "\n", "if", "num_pos", "==", "0", ":", "\n", "            ", "positive_loss", "=", "bbox_preds", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "losses", "=", "{", "\n", "'positive_bag_loss'", ":", "positive_loss", ",", "\n", "'negative_bag_loss'", ":", "negative_loss", "\n", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.positive_bag_loss": [[217, 243], ["weight.sum().unsqueeze", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "weight.sum", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.binary_cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.binary_cross_entropy"], ["", "def", "positive_bag_loss", "(", "self", ",", "matched_cls_prob", ",", "matched_box_prob", ")", ":", "\n", "        ", "\"\"\"Compute positive bag loss.\n\n        :math:`-log( Mean-max(P_{ij}^{cls} * P_{ij}^{loc}) )`.\n\n        :math:`P_{ij}^{cls}`: matched_cls_prob, classification probability of matched samples.\n\n        :math:`P_{ij}^{loc}`: matched_box_prob, box probability of matched samples.\n\n        Args:\n            matched_cls_prob (Tensor): Classification probabilty of matched\n                samples in shape (num_gt, pre_anchor_topk).\n            matched_box_prob (Tensor): BBox probability of matched samples,\n                in shape (num_gt, pre_anchor_topk).\n\n        Returns:\n            Tensor: Positive bag loss in shape (num_gt,).\n        \"\"\"", "# noqa: E501, W605", "\n", "# bag_prob = Mean-max(matched_prob)", "\n", "matched_prob", "=", "matched_cls_prob", "*", "matched_box_prob", "\n", "weight", "=", "1", "/", "torch", ".", "clamp", "(", "1", "-", "matched_prob", ",", "1e-12", ",", "None", ")", "\n", "weight", "/=", "weight", ".", "sum", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", "\n", "bag_prob", "=", "(", "weight", "*", "matched_prob", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "# positive_bag_loss = -self.alpha * log(bag_prob)", "\n", "return", "self", ".", "alpha", "*", "F", ".", "binary_cross_entropy", "(", "\n", "bag_prob", ",", "torch", ".", "ones_like", "(", "bag_prob", ")", ",", "reduction", "=", "'none'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.free_anchor_retina_head.FreeAnchorRetinaHead.negative_bag_loss": [[244, 266], ["torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.binary_cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.binary_cross_entropy"], ["", "def", "negative_bag_loss", "(", "self", ",", "cls_prob", ",", "box_prob", ")", ":", "\n", "        ", "\"\"\"Compute negative bag loss.\n\n        :math:`FL((1 - P_{a_{j} \\in A_{+}}) * (1 - P_{j}^{bg}))`.\n\n        :math:`P_{a_{j} \\in A_{+}}`: Box_probability of matched samples.\n\n        :math:`P_{j}^{bg}`: Classification probability of negative samples.\n\n        Args:\n            cls_prob (Tensor): Classification probability, in shape\n                (num_img, num_anchors, num_classes).\n            box_prob (Tensor): Box probability, in shape\n                (num_img, num_anchors, num_classes).\n\n        Returns:\n            Tensor: Negative bag loss in shape (num_img, num_anchors, num_classes).\n        \"\"\"", "# noqa: E501, W605", "\n", "prob", "=", "cls_prob", "*", "(", "1", "-", "box_prob", ")", "\n", "negative_bag_loss", "=", "prob", "**", "self", ".", "gamma", "*", "F", ".", "binary_cross_entropy", "(", "\n", "prob", ",", "torch", ".", "zeros_like", "(", "prob", ")", ",", "reduction", "=", "'none'", ")", "\n", "return", "(", "1", "-", "self", ".", "alpha", ")", "*", "negative_bag_loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.BiCornerPool.__init__": [[26, 54], ["dict", "torch.Module.__init__", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.ops.CornerPool", "mmcv.ops.CornerPool", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "directions", ",", "\n", "feat_channels", "=", "128", ",", "\n", "out_channels", "=", "128", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ")", ":", "\n", "        ", "super", "(", "BiCornerPool", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "direction1_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "feat_channels", ",", "3", ",", "padding", "=", "1", ",", "norm_cfg", "=", "norm_cfg", ")", "\n", "self", ".", "direction2_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "feat_channels", ",", "3", ",", "padding", "=", "1", ",", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "self", ".", "aftpool_conv", "=", "ConvModule", "(", "\n", "feat_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "in_channels", ",", "out_channels", ",", "1", ",", "norm_cfg", "=", "norm_cfg", ",", "act_cfg", "=", "None", ")", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "in_channels", ",", "out_channels", ",", "3", ",", "padding", "=", "1", ",", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "self", ".", "direction1_pool", "=", "CornerPool", "(", "directions", "[", "0", "]", ")", "\n", "self", ".", "direction2_pool", "=", "CornerPool", "(", "directions", "[", "1", "]", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.BiCornerPool.forward": [[55, 73], ["corner_head.BiCornerPool.direction1_conv", "corner_head.BiCornerPool.direction2_conv", "corner_head.BiCornerPool.direction1_pool", "corner_head.BiCornerPool.direction2_pool", "corner_head.BiCornerPool.aftpool_conv", "corner_head.BiCornerPool.conv1", "corner_head.BiCornerPool.relu", "corner_head.BiCornerPool.conv2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            x (tensor): Input feature of BiCornerPool.\n\n        Returns:\n            conv2 (tensor): Output feature of BiCornerPool.\n        \"\"\"", "\n", "direction1_conv", "=", "self", ".", "direction1_conv", "(", "x", ")", "\n", "direction2_conv", "=", "self", ".", "direction2_conv", "(", "x", ")", "\n", "direction1_feat", "=", "self", ".", "direction1_pool", "(", "direction1_conv", ")", "\n", "direction2_feat", "=", "self", ".", "direction2_pool", "(", "direction2_conv", ")", "\n", "aftpool_conv", "=", "self", ".", "aftpool_conv", "(", "direction1_feat", "+", "direction2_feat", ")", "\n", "conv1", "=", "self", ".", "conv1", "(", "x", ")", "\n", "relu", "=", "self", ".", "relu", "(", "aftpool_conv", "+", "conv1", ")", "\n", "conv2", "=", "self", ".", "conv2", "(", "relu", ")", "\n", "return", "conv2", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.__init__": [[107, 142], ["dict", "dict", "dict", "base_dense_head.BaseDenseHead.__init__", "corner_head.CornerHead._init_layers", "builder.build_loss", "builder.build_loss", "builder.build_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "num_feat_levels", "=", "2", ",", "\n", "corner_emb_channels", "=", "1", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "loss_heatmap", "=", "dict", "(", "\n", "type", "=", "'GaussianFocalLoss'", ",", "\n", "alpha", "=", "2.0", ",", "\n", "gamma", "=", "4.0", ",", "\n", "loss_weight", "=", "1", ")", ",", "\n", "loss_embedding", "=", "dict", "(", "\n", "type", "=", "'AssociativeEmbeddingLoss'", ",", "\n", "pull_weight", "=", "0.25", ",", "\n", "push_weight", "=", "0.25", ")", ",", "\n", "loss_offset", "=", "dict", "(", "\n", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", ",", "loss_weight", "=", "1", ")", ")", ":", "\n", "        ", "super", "(", "CornerHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "corner_emb_channels", "=", "corner_emb_channels", "\n", "self", ".", "with_corner_emb", "=", "self", ".", "corner_emb_channels", ">", "0", "\n", "self", ".", "corner_offset_channels", "=", "2", "\n", "self", ".", "num_feat_levels", "=", "num_feat_levels", "\n", "self", ".", "loss_heatmap", "=", "build_loss", "(", "\n", "loss_heatmap", ")", "if", "loss_heatmap", "is", "not", "None", "else", "None", "\n", "self", ".", "loss_embedding", "=", "build_loss", "(", "\n", "loss_embedding", ")", "if", "loss_embedding", "is", "not", "None", "else", "None", "\n", "self", ".", "loss_offset", "=", "build_loss", "(", "\n", "loss_offset", ")", "if", "loss_offset", "is", "not", "None", "else", "None", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers": [[143, 149], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_make_layers", "(", "self", ",", "out_channels", ",", "in_channels", "=", "256", ",", "feat_channels", "=", "256", ")", ":", "\n", "        ", "\"\"\"Initialize conv sequential for CornerHead.\"\"\"", "\n", "return", "nn", ".", "Sequential", "(", "\n", "ConvModule", "(", "in_channels", ",", "feat_channels", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "ConvModule", "(", "\n", "feat_channels", ",", "out_channels", ",", "1", ",", "norm_cfg", "=", "None", ",", "act_cfg", "=", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._init_corner_kpt_layers": [[150, 187], ["range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "corner_head.CornerHead.tl_pool.append", "corner_head.CornerHead.br_pool.append", "corner_head.CornerHead.tl_heat.append", "corner_head.CornerHead.br_heat.append", "corner_head.CornerHead.tl_off.append", "corner_head.CornerHead.br_off.append", "corner_head.BiCornerPool", "corner_head.BiCornerPool", "corner_head.CornerHead._make_layers", "corner_head.CornerHead._make_layers", "corner_head.CornerHead._make_layers", "corner_head.CornerHead._make_layers"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers"], ["", "def", "_init_corner_kpt_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize corner keypoint layers.\n\n        Including corner heatmap branch and corner offset branch. Each branch\n        has two parts: prefix `tl_` for top-left and `br_` for bottom-right.\n        \"\"\"", "\n", "self", ".", "tl_pool", ",", "self", ".", "br_pool", "=", "nn", ".", "ModuleList", "(", ")", ",", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "tl_heat", ",", "self", ".", "br_heat", "=", "nn", ".", "ModuleList", "(", ")", ",", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "tl_off", ",", "self", ".", "br_off", "=", "nn", ".", "ModuleList", "(", ")", ",", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_feat_levels", ")", ":", "\n", "            ", "self", ".", "tl_pool", ".", "append", "(", "\n", "BiCornerPool", "(", "\n", "self", ".", "in_channels", ",", "[", "'top'", ",", "'left'", "]", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "self", ".", "br_pool", ".", "append", "(", "\n", "BiCornerPool", "(", "\n", "self", ".", "in_channels", ",", "[", "'bottom'", ",", "'right'", "]", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "\n", "self", ".", "tl_heat", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "num_classes", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "self", ".", "br_heat", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "num_classes", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "\n", "self", ".", "tl_off", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "corner_offset_channels", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "self", ".", "br_off", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "corner_offset_channels", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._init_corner_emb_layers": [[188, 205], ["range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "corner_head.CornerHead.tl_emb.append", "corner_head.CornerHead.br_emb.append", "corner_head.CornerHead._make_layers", "corner_head.CornerHead._make_layers"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._make_layers"], ["", "", "def", "_init_corner_emb_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize corner embedding layers.\n\n        Only include corner embedding branch with two parts: prefix `tl_` for\n        top-left and `br_` for bottom-right.\n        \"\"\"", "\n", "self", ".", "tl_emb", ",", "self", ".", "br_emb", "=", "nn", ".", "ModuleList", "(", ")", ",", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_feat_levels", ")", ":", "\n", "            ", "self", ".", "tl_emb", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "corner_emb_channels", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "self", ".", "br_emb", ".", "append", "(", "\n", "self", ".", "_make_layers", "(", "\n", "out_channels", "=", "self", ".", "corner_emb_channels", ",", "\n", "in_channels", "=", "self", ".", "in_channels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._init_layers": [[206, 214], ["corner_head.CornerHead._init_corner_kpt_layers", "corner_head.CornerHead._init_corner_emb_layers"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._init_corner_kpt_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._init_corner_emb_layers"], ["", "", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers for CornerHead.\n\n        Including two parts: corner keypoint layers and corner embedding layers\n        \"\"\"", "\n", "self", ".", "_init_corner_kpt_layers", "(", ")", "\n", "if", "self", ".", "with_corner_emb", ":", "\n", "            ", "self", ".", "_init_corner_emb_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.init_weights": [[215, 221], ["mmcv.cnn.bias_init_with_prob", "range", "[].conv.bias.data.fill_", "[].conv.bias.data.fill_"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "bias_init", "=", "bias_init_with_prob", "(", "0.1", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_feat_levels", ")", ":", "\n", "            ", "self", ".", "tl_heat", "[", "i", "]", "[", "-", "1", "]", ".", "conv", ".", "bias", ".", "data", ".", "fill_", "(", "bias_init", ")", "\n", "self", ".", "br_heat", "[", "i", "]", "[", "-", "1", "]", ".", "conv", ".", "bias", ".", "data", ".", "fill_", "(", "bias_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.forward": [[222, 253], ["list", "mmdet.core.multi_apply", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: Usually a tuple of corner heatmaps, offset heatmaps and\n            embedding heatmaps.\n                - tl_heats (list[Tensor]): Top-left corner heatmaps for all\n                  levels, each is a 4D-tensor, the channels number is\n                  num_classes.\n                - br_heats (list[Tensor]): Bottom-right corner heatmaps for all\n                  levels, each is a 4D-tensor, the channels number is\n                  num_classes.\n                - tl_embs (list[Tensor] | list[None]): Top-left embedding\n                  heatmaps for all levels, each is a 4D-tensor or None.\n                  If not None, the channels number is corner_emb_channels.\n                - br_embs (list[Tensor] | list[None]): Bottom-right embedding\n                  heatmaps for all levels, each is a 4D-tensor or None.\n                  If not None, the channels number is corner_emb_channels.\n                - tl_offs (list[Tensor]): Top-left offset heatmaps for all\n                  levels, each is a 4D-tensor. The channels number is\n                  corner_offset_channels.\n                - br_offs (list[Tensor]): Bottom-right offset heatmaps for all\n                  levels, each is a 4D-tensor. The channels number is\n                  corner_offset_channels.\n        \"\"\"", "\n", "lvl_ind", "=", "list", "(", "range", "(", "self", ".", "num_feat_levels", ")", ")", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ",", "lvl_ind", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.forward_single": [[254, 298], ["result_list.append", "result_list.append"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ",", "lvl_ind", ",", "return_pool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single level.\n\n        Args:\n            x (Tensor): Feature of a single level.\n            lvl_ind (int): Level index of current feature.\n            return_pool (bool): Return corner pool feature or not.\n\n        Returns:\n            tuple[Tensor]: A tuple of CornerHead's output for current feature\n            level. Containing the following Tensors:\n\n                - tl_heat (Tensor): Predicted top-left corner heatmap.\n                - br_heat (Tensor): Predicted bottom-right corner heatmap.\n                - tl_emb (Tensor | None): Predicted top-left embedding heatmap.\n                  None for `self.with_corner_emb == False`.\n                - br_emb (Tensor | None): Predicted bottom-right embedding\n                  heatmap. None for `self.with_corner_emb == False`.\n                - tl_off (Tensor): Predicted top-left offset heatmap.\n                - br_off (Tensor): Predicted bottom-right offset heatmap.\n                - tl_pool (Tensor): Top-left corner pool feature. Not must\n                  have.\n                - br_pool (Tensor): Bottom-right corner pool feature. Not must\n                  have.\n        \"\"\"", "\n", "tl_pool", "=", "self", ".", "tl_pool", "[", "lvl_ind", "]", "(", "x", ")", "\n", "tl_heat", "=", "self", ".", "tl_heat", "[", "lvl_ind", "]", "(", "tl_pool", ")", "\n", "br_pool", "=", "self", ".", "br_pool", "[", "lvl_ind", "]", "(", "x", ")", "\n", "br_heat", "=", "self", ".", "br_heat", "[", "lvl_ind", "]", "(", "br_pool", ")", "\n", "\n", "tl_emb", ",", "br_emb", "=", "None", ",", "None", "\n", "if", "self", ".", "with_corner_emb", ":", "\n", "            ", "tl_emb", "=", "self", ".", "tl_emb", "[", "lvl_ind", "]", "(", "tl_pool", ")", "\n", "br_emb", "=", "self", ".", "br_emb", "[", "lvl_ind", "]", "(", "br_pool", ")", "\n", "\n", "", "tl_off", "=", "self", ".", "tl_off", "[", "lvl_ind", "]", "(", "tl_pool", ")", "\n", "br_off", "=", "self", ".", "br_off", "[", "lvl_ind", "]", "(", "br_pool", ")", "\n", "\n", "result_list", "=", "[", "tl_heat", ",", "br_heat", ",", "tl_emb", ",", "br_emb", ",", "tl_off", ",", "br_off", "]", "\n", "if", "return_pool", ":", "\n", "            ", "result_list", ".", "append", "(", "tl_pool", ")", "\n", "result_list", ".", "append", "(", "br_pool", ")", "\n", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.get_targets": [[299, 486], ["float", "float", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "range", "dict", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "gt_bboxes[].new_zeros", "range", "dict.update", "dict.update", "dict.update", "len", "int", "int", "int", "int", "math.ceil", "math.ceil", "utils.gaussian_radius", "max", "utils.gen_gaussian_target", "utils.gen_gaussian_target", "match.append", "min", "min", "min", "min", "int", "corner_match.append", "math.log", "math.log", "math.log", "math.log"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gaussian_radius", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gen_gaussian_target", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.gaussian_target.gen_gaussian_target"], ["", "def", "get_targets", "(", "self", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "feat_shape", ",", "\n", "img_shape", ",", "\n", "with_corner_emb", "=", "False", ",", "\n", "with_guiding_shift", "=", "False", ",", "\n", "with_centripetal_shift", "=", "False", ")", ":", "\n", "        ", "\"\"\"Generate corner targets.\n\n        Including corner heatmap, corner offset.\n\n        Optional: corner embedding, corner guiding shift, centripetal shift.\n\n        For CornerNet, we generate corner heatmap, corner offset and corner\n        embedding from this function.\n\n        For CentripetalNet, we generate corner heatmap, corner offset, guiding\n        shift and centripetal shift from this function.\n\n        Args:\n            gt_bboxes (list[Tensor]): Ground truth bboxes of each image, each\n                has shape (num_gt, 4).\n            gt_labels (list[Tensor]): Ground truth labels of each box, each has\n                shape (num_gt,).\n            feat_shape (list[int]): Shape of output feature,\n                [batch, channel, height, width].\n            img_shape (list[int]): Shape of input image,\n                [height, width, channel].\n            with_corner_emb (bool): Generate corner embedding target or not.\n                Default: False.\n            with_guiding_shift (bool): Generate guiding shift target or not.\n                Default: False.\n            with_centripetal_shift (bool): Generate centripetal shift target or\n                not. Default: False.\n\n        Returns:\n            dict: Ground truth of corner heatmap, corner offset, corner\n            embedding, guiding shift and centripetal shift. Containing the\n            following keys:\n\n                - topleft_heatmap (Tensor): Ground truth top-left corner\n                  heatmap.\n                - bottomright_heatmap (Tensor): Ground truth bottom-right\n                  corner heatmap.\n                - topleft_offset (Tensor): Ground truth top-left corner offset.\n                - bottomright_offset (Tensor): Ground truth bottom-right corner\n                  offset.\n                - corner_embedding (list[list[list[int]]]): Ground truth corner\n                  embedding. Not must have.\n                - topleft_guiding_shift (Tensor): Ground truth top-left corner\n                  guiding shift. Not must have.\n                - bottomright_guiding_shift (Tensor): Ground truth bottom-right\n                  corner guiding shift. Not must have.\n                - topleft_centripetal_shift (Tensor): Ground truth top-left\n                  corner centripetal shift. Not must have.\n                - bottomright_centripetal_shift (Tensor): Ground truth\n                  bottom-right corner centripetal shift. Not must have.\n        \"\"\"", "\n", "batch_size", ",", "_", ",", "height", ",", "width", "=", "feat_shape", "\n", "img_h", ",", "img_w", "=", "img_shape", "[", ":", "2", "]", "\n", "\n", "width_ratio", "=", "float", "(", "width", "/", "img_w", ")", "\n", "height_ratio", "=", "float", "(", "height", "/", "img_h", ")", "\n", "\n", "gt_tl_heatmap", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "self", ".", "num_classes", ",", "height", ",", "width", "]", ")", "\n", "gt_br_heatmap", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "self", ".", "num_classes", ",", "height", ",", "width", "]", ")", "\n", "gt_tl_offset", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "gt_br_offset", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "\n", "if", "with_corner_emb", ":", "\n", "            ", "match", "=", "[", "]", "\n", "\n", "# Guiding shift is a kind of offset, from center to corner", "\n", "", "if", "with_guiding_shift", ":", "\n", "            ", "gt_tl_guiding_shift", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "gt_br_guiding_shift", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "# Centripetal shift is also a kind of offset, from center to corner", "\n", "# and normalized by log.", "\n", "", "if", "with_centripetal_shift", ":", "\n", "            ", "gt_tl_centripetal_shift", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "gt_br_centripetal_shift", "=", "gt_bboxes", "[", "-", "1", "]", ".", "new_zeros", "(", "\n", "[", "batch_size", ",", "2", ",", "height", ",", "width", "]", ")", "\n", "\n", "", "for", "batch_id", "in", "range", "(", "batch_size", ")", ":", "\n", "# Ground truth of corner embedding per image is a list of coord set", "\n", "            ", "corner_match", "=", "[", "]", "\n", "for", "box_id", "in", "range", "(", "len", "(", "gt_labels", "[", "batch_id", "]", ")", ")", ":", "\n", "                ", "left", ",", "top", ",", "right", ",", "bottom", "=", "gt_bboxes", "[", "batch_id", "]", "[", "box_id", "]", "\n", "center_x", "=", "(", "left", "+", "right", ")", "/", "2.0", "\n", "center_y", "=", "(", "top", "+", "bottom", ")", "/", "2.0", "\n", "label", "=", "gt_labels", "[", "batch_id", "]", "[", "box_id", "]", "\n", "\n", "# Use coords in the feature level to generate ground truth", "\n", "scale_left", "=", "left", "*", "width_ratio", "\n", "scale_right", "=", "right", "*", "width_ratio", "\n", "scale_top", "=", "top", "*", "height_ratio", "\n", "scale_bottom", "=", "bottom", "*", "height_ratio", "\n", "scale_center_x", "=", "center_x", "*", "width_ratio", "\n", "scale_center_y", "=", "center_y", "*", "height_ratio", "\n", "\n", "# Int coords on feature map/ground truth tensor", "\n", "left_idx", "=", "int", "(", "min", "(", "scale_left", ",", "width", "-", "1", ")", ")", "\n", "right_idx", "=", "int", "(", "min", "(", "scale_right", ",", "width", "-", "1", ")", ")", "\n", "top_idx", "=", "int", "(", "min", "(", "scale_top", ",", "height", "-", "1", ")", ")", "\n", "bottom_idx", "=", "int", "(", "min", "(", "scale_bottom", ",", "height", "-", "1", ")", ")", "\n", "\n", "# Generate gaussian heatmap", "\n", "scale_box_width", "=", "ceil", "(", "scale_right", "-", "scale_left", ")", "\n", "scale_box_height", "=", "ceil", "(", "scale_bottom", "-", "scale_top", ")", "\n", "radius", "=", "gaussian_radius", "(", "(", "scale_box_height", ",", "scale_box_width", ")", ",", "\n", "min_overlap", "=", "0.3", ")", "\n", "radius", "=", "max", "(", "0", ",", "int", "(", "radius", ")", ")", "\n", "gt_tl_heatmap", "[", "batch_id", ",", "label", "]", "=", "gen_gaussian_target", "(", "\n", "gt_tl_heatmap", "[", "batch_id", ",", "label", "]", ",", "[", "left_idx", ",", "top_idx", "]", ",", "\n", "radius", ")", "\n", "gt_br_heatmap", "[", "batch_id", ",", "label", "]", "=", "gen_gaussian_target", "(", "\n", "gt_br_heatmap", "[", "batch_id", ",", "label", "]", ",", "[", "right_idx", ",", "bottom_idx", "]", ",", "\n", "radius", ")", "\n", "\n", "# Generate corner offset", "\n", "left_offset", "=", "scale_left", "-", "left_idx", "\n", "top_offset", "=", "scale_top", "-", "top_idx", "\n", "right_offset", "=", "scale_right", "-", "right_idx", "\n", "bottom_offset", "=", "scale_bottom", "-", "bottom_idx", "\n", "gt_tl_offset", "[", "batch_id", ",", "0", ",", "top_idx", ",", "left_idx", "]", "=", "left_offset", "\n", "gt_tl_offset", "[", "batch_id", ",", "1", ",", "top_idx", ",", "left_idx", "]", "=", "top_offset", "\n", "gt_br_offset", "[", "batch_id", ",", "0", ",", "bottom_idx", ",", "right_idx", "]", "=", "right_offset", "\n", "gt_br_offset", "[", "batch_id", ",", "1", ",", "bottom_idx", ",", "\n", "right_idx", "]", "=", "bottom_offset", "\n", "\n", "# Generate corner embedding", "\n", "if", "with_corner_emb", ":", "\n", "                    ", "corner_match", ".", "append", "(", "[", "[", "top_idx", ",", "left_idx", "]", ",", "\n", "[", "bottom_idx", ",", "right_idx", "]", "]", ")", "\n", "# Generate guiding shift", "\n", "", "if", "with_guiding_shift", ":", "\n", "                    ", "gt_tl_guiding_shift", "[", "batch_id", ",", "0", ",", "top_idx", ",", "\n", "left_idx", "]", "=", "scale_center_x", "-", "left_idx", "\n", "gt_tl_guiding_shift", "[", "batch_id", ",", "1", ",", "top_idx", ",", "\n", "left_idx", "]", "=", "scale_center_y", "-", "top_idx", "\n", "gt_br_guiding_shift", "[", "batch_id", ",", "0", ",", "bottom_idx", ",", "\n", "right_idx", "]", "=", "right_idx", "-", "scale_center_x", "\n", "gt_br_guiding_shift", "[", "\n", "batch_id", ",", "1", ",", "bottom_idx", ",", "\n", "right_idx", "]", "=", "bottom_idx", "-", "scale_center_y", "\n", "# Generate centripetal shift", "\n", "", "if", "with_centripetal_shift", ":", "\n", "                    ", "gt_tl_centripetal_shift", "[", "batch_id", ",", "0", ",", "top_idx", ",", "\n", "left_idx", "]", "=", "log", "(", "scale_center_x", "-", "\n", "scale_left", ")", "\n", "gt_tl_centripetal_shift", "[", "batch_id", ",", "1", ",", "top_idx", ",", "\n", "left_idx", "]", "=", "log", "(", "scale_center_y", "-", "\n", "scale_top", ")", "\n", "gt_br_centripetal_shift", "[", "batch_id", ",", "0", ",", "bottom_idx", ",", "\n", "right_idx", "]", "=", "log", "(", "scale_right", "-", "\n", "scale_center_x", ")", "\n", "gt_br_centripetal_shift", "[", "batch_id", ",", "1", ",", "bottom_idx", ",", "\n", "right_idx", "]", "=", "log", "(", "scale_bottom", "-", "\n", "scale_center_y", ")", "\n", "\n", "", "", "if", "with_corner_emb", ":", "\n", "                ", "match", ".", "append", "(", "corner_match", ")", "\n", "\n", "", "", "target_result", "=", "dict", "(", "\n", "topleft_heatmap", "=", "gt_tl_heatmap", ",", "\n", "topleft_offset", "=", "gt_tl_offset", ",", "\n", "bottomright_heatmap", "=", "gt_br_heatmap", ",", "\n", "bottomright_offset", "=", "gt_br_offset", ")", "\n", "\n", "if", "with_corner_emb", ":", "\n", "            ", "target_result", ".", "update", "(", "corner_embedding", "=", "match", ")", "\n", "", "if", "with_guiding_shift", ":", "\n", "            ", "target_result", ".", "update", "(", "\n", "topleft_guiding_shift", "=", "gt_tl_guiding_shift", ",", "\n", "bottomright_guiding_shift", "=", "gt_br_guiding_shift", ")", "\n", "", "if", "with_centripetal_shift", ":", "\n", "            ", "target_result", ".", "update", "(", "\n", "topleft_centripetal_shift", "=", "gt_tl_centripetal_shift", ",", "\n", "bottomright_centripetal_shift", "=", "gt_br_centripetal_shift", ")", "\n", "\n", "", "return", "target_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.loss": [[487, 548], ["corner_head.CornerHead.get_targets", "mmdet.core.multi_apply", "dict", "dict.update", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "loss", "(", "self", ",", "\n", "tl_heats", ",", "\n", "br_heats", ",", "\n", "tl_embs", ",", "\n", "br_embs", ",", "\n", "tl_offs", ",", "\n", "br_offs", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            tl_heats (list[Tensor]): Top-left corner heatmaps for each level\n                with shape (N, num_classes, H, W).\n            br_heats (list[Tensor]): Bottom-right corner heatmaps for each\n                level with shape (N, num_classes, H, W).\n            tl_embs (list[Tensor]): Top-left corner embeddings for each level\n                with shape (N, corner_emb_channels, H, W).\n            br_embs (list[Tensor]): Bottom-right corner embeddings for each\n                level with shape (N, corner_emb_channels, H, W).\n            tl_offs (list[Tensor]): Top-left corner offsets for each level\n                with shape (N, corner_offset_channels, H, W).\n            br_offs (list[Tensor]): Bottom-right corner offsets for each level\n                with shape (N, corner_offset_channels, H, W).\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [left, top, right, bottom] format.\n            gt_labels (list[Tensor]): Class indices corresponding to each box.\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (list[Tensor] | None): Specify which bounding\n                boxes can be ignored when computing the loss.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components. Containing the\n            following losses:\n\n                - det_loss (list[Tensor]): Corner keypoint losses of all\n                  feature levels.\n                - pull_loss (list[Tensor]): Part one of AssociativeEmbedding\n                  losses of all feature levels.\n                - push_loss (list[Tensor]): Part two of AssociativeEmbedding\n                  losses of all feature levels.\n                - off_loss (list[Tensor]): Corner offset losses of all feature\n                  levels.\n        \"\"\"", "\n", "targets", "=", "self", ".", "get_targets", "(", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "tl_heats", "[", "-", "1", "]", ".", "shape", ",", "\n", "img_metas", "[", "0", "]", "[", "'pad_shape'", "]", ",", "\n", "with_corner_emb", "=", "self", ".", "with_corner_emb", ")", "\n", "mlvl_targets", "=", "[", "targets", "for", "_", "in", "range", "(", "self", ".", "num_feat_levels", ")", "]", "\n", "det_losses", ",", "pull_losses", ",", "push_losses", ",", "off_losses", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "tl_heats", ",", "br_heats", ",", "tl_embs", ",", "br_embs", ",", "tl_offs", ",", "\n", "br_offs", ",", "mlvl_targets", ")", "\n", "loss_dict", "=", "dict", "(", "det_loss", "=", "det_losses", ",", "off_loss", "=", "off_losses", ")", "\n", "if", "self", ".", "with_corner_emb", ":", "\n", "            ", "loss_dict", ".", "update", "(", "pull_loss", "=", "pull_losses", ",", "push_loss", "=", "push_losses", ")", "\n", "", "return", "loss_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.loss_single": [[549, 626], ["corner_head.CornerHead.loss_heatmap", "corner_head.CornerHead.loss_heatmap", "gt_tl_hmp.eq().sum().gt().unsqueeze().type_as", "gt_br_hmp.eq().sum().gt().unsqueeze().type_as", "corner_head.CornerHead.loss_offset", "corner_head.CornerHead.loss_offset", "tl_hmp.sigmoid", "br_hmp.sigmoid", "corner_head.CornerHead.loss_embedding", "max", "max", "gt_tl_hmp.eq().sum().gt().unsqueeze", "gt_br_hmp.eq().sum().gt().unsqueeze", "max", "max", "gt_tl_hmp.eq().sum", "gt_br_hmp.eq().sum", "gt_tl_hmp.eq().sum().gt().unsqueeze().type_as.sum", "gt_br_hmp.eq().sum().gt().unsqueeze().type_as.sum", "gt_tl_hmp.eq().sum().gt", "gt_br_hmp.eq().sum().gt", "gt_tl_hmp.eq", "gt_br_hmp.eq", "gt_tl_hmp.eq().sum", "gt_br_hmp.eq().sum", "gt_tl_hmp.eq", "gt_br_hmp.eq"], "methods", ["None"], ["", "def", "loss_single", "(", "self", ",", "tl_hmp", ",", "br_hmp", ",", "tl_emb", ",", "br_emb", ",", "tl_off", ",", "br_off", ",", "\n", "targets", ")", ":", "\n", "        ", "\"\"\"Compute losses for single level.\n\n        Args:\n            tl_hmp (Tensor): Top-left corner heatmap for current level with\n                shape (N, num_classes, H, W).\n            br_hmp (Tensor): Bottom-right corner heatmap for current level with\n                shape (N, num_classes, H, W).\n            tl_emb (Tensor): Top-left corner embedding for current level with\n                shape (N, corner_emb_channels, H, W).\n            br_emb (Tensor): Bottom-right corner embedding for current level\n                with shape (N, corner_emb_channels, H, W).\n            tl_off (Tensor): Top-left corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            br_off (Tensor): Bottom-right corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            targets (dict): Corner target generated by `get_targets`.\n\n        Returns:\n            tuple[torch.Tensor]: Losses of the head's differnet branches\n            containing the following losses:\n\n                - det_loss (Tensor): Corner keypoint loss.\n                - pull_loss (Tensor): Part one of AssociativeEmbedding loss.\n                - push_loss (Tensor): Part two of AssociativeEmbedding loss.\n                - off_loss (Tensor): Corner offset loss.\n        \"\"\"", "\n", "gt_tl_hmp", "=", "targets", "[", "'topleft_heatmap'", "]", "\n", "gt_br_hmp", "=", "targets", "[", "'bottomright_heatmap'", "]", "\n", "gt_tl_off", "=", "targets", "[", "'topleft_offset'", "]", "\n", "gt_br_off", "=", "targets", "[", "'bottomright_offset'", "]", "\n", "gt_embedding", "=", "targets", "[", "'corner_embedding'", "]", "\n", "\n", "# Detection loss", "\n", "tl_det_loss", "=", "self", ".", "loss_heatmap", "(", "\n", "tl_hmp", ".", "sigmoid", "(", ")", ",", "\n", "gt_tl_hmp", ",", "\n", "avg_factor", "=", "max", "(", "1", ",", "\n", "gt_tl_hmp", ".", "eq", "(", "1", ")", ".", "sum", "(", ")", ")", ")", "\n", "br_det_loss", "=", "self", ".", "loss_heatmap", "(", "\n", "br_hmp", ".", "sigmoid", "(", ")", ",", "\n", "gt_br_hmp", ",", "\n", "avg_factor", "=", "max", "(", "1", ",", "\n", "gt_br_hmp", ".", "eq", "(", "1", ")", ".", "sum", "(", ")", ")", ")", "\n", "det_loss", "=", "(", "tl_det_loss", "+", "br_det_loss", ")", "/", "2.0", "\n", "\n", "# AssociativeEmbedding loss", "\n", "if", "self", ".", "with_corner_emb", "and", "self", ".", "loss_embedding", "is", "not", "None", ":", "\n", "            ", "pull_loss", ",", "push_loss", "=", "self", ".", "loss_embedding", "(", "tl_emb", ",", "br_emb", ",", "\n", "gt_embedding", ")", "\n", "", "else", ":", "\n", "            ", "pull_loss", ",", "push_loss", "=", "None", ",", "None", "\n", "\n", "# Offset loss", "\n", "# We only compute the offset loss at the real corner position.", "\n", "# The value of real corner would be 1 in heatmap ground truth.", "\n", "# The mask is computed in class agnostic mode and its shape is", "\n", "# batch * 1 * width * height.", "\n", "", "tl_off_mask", "=", "gt_tl_hmp", ".", "eq", "(", "1", ")", ".", "sum", "(", "1", ")", ".", "gt", "(", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "type_as", "(", "\n", "gt_tl_hmp", ")", "\n", "br_off_mask", "=", "gt_br_hmp", ".", "eq", "(", "1", ")", ".", "sum", "(", "1", ")", ".", "gt", "(", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "type_as", "(", "\n", "gt_br_hmp", ")", "\n", "tl_off_loss", "=", "self", ".", "loss_offset", "(", "\n", "tl_off", ",", "\n", "gt_tl_off", ",", "\n", "tl_off_mask", ",", "\n", "avg_factor", "=", "max", "(", "1", ",", "tl_off_mask", ".", "sum", "(", ")", ")", ")", "\n", "br_off_loss", "=", "self", ".", "loss_offset", "(", "\n", "br_off", ",", "\n", "gt_br_off", ",", "\n", "br_off_mask", ",", "\n", "avg_factor", "=", "max", "(", "1", ",", "br_off_mask", ".", "sum", "(", ")", ")", ")", "\n", "\n", "off_loss", "=", "(", "tl_off_loss", "+", "br_off_loss", ")", "/", "2.0", "\n", "\n", "return", "det_loss", ",", "pull_loss", ",", "push_loss", ",", "off_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.get_bboxes": [[627, 675], ["range", "len", "len", "result_list.append", "corner_head.CornerHead._get_bboxes_single"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "def", "get_bboxes", "(", "self", ",", "\n", "tl_heats", ",", "\n", "br_heats", ",", "\n", "tl_embs", ",", "\n", "br_embs", ",", "\n", "tl_offs", ",", "\n", "br_offs", ",", "\n", "img_metas", ",", "\n", "rescale", "=", "False", ",", "\n", "with_nms", "=", "True", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\n\n        Args:\n            tl_heats (list[Tensor]): Top-left corner heatmaps for each level\n                with shape (N, num_classes, H, W).\n            br_heats (list[Tensor]): Bottom-right corner heatmaps for each\n                level with shape (N, num_classes, H, W).\n            tl_embs (list[Tensor]): Top-left corner embeddings for each level\n                with shape (N, corner_emb_channels, H, W).\n            br_embs (list[Tensor]): Bottom-right corner embeddings for each\n                level with shape (N, corner_emb_channels, H, W).\n            tl_offs (list[Tensor]): Top-left corner offsets for each level\n                with shape (N, corner_offset_channels, H, W).\n            br_offs (list[Tensor]): Bottom-right corner offsets for each level\n                with shape (N, corner_offset_channels, H, W).\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n            with_nms (bool): If True, do nms before return boxes.\n                Default: True.\n        \"\"\"", "\n", "assert", "tl_heats", "[", "-", "1", "]", ".", "shape", "[", "0", "]", "==", "br_heats", "[", "-", "1", "]", ".", "shape", "[", "0", "]", "==", "len", "(", "img_metas", ")", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "result_list", ".", "append", "(", "\n", "self", ".", "_get_bboxes_single", "(", "\n", "tl_heats", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "br_heats", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "tl_embs", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "br_embs", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "tl_offs", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "br_offs", "[", "-", "1", "]", "[", "img_id", ":", "img_id", "+", "1", ",", ":", "]", ",", "\n", "img_metas", "[", "img_id", "]", ",", "\n", "rescale", "=", "rescale", ",", "\n", "with_nms", "=", "with_nms", ")", ")", "\n", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._get_bboxes_single": [[676, 745], ["isinstance", "corner_head.CornerHead.decode_heatmap", "batch_bboxes.view", "batch_scores.view", "batch_clses.view", "scores[].view.argsort", "bboxes[].view", "scores[].view", "clses[].view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "corner_head.CornerHead._bboxes_nms", "tl_heat.sigmoid", "br_heat.sigmoid", "scores[].view.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.decode_heatmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._bboxes_nms"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "tl_heat", ",", "\n", "br_heat", ",", "\n", "tl_emb", ",", "\n", "br_emb", ",", "\n", "tl_off", ",", "\n", "br_off", ",", "\n", "img_meta", ",", "\n", "rescale", "=", "False", ",", "\n", "with_nms", "=", "True", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into bbox predictions.\n\n        Args:\n            tl_heat (Tensor): Top-left corner heatmap for current level with\n                shape (N, num_classes, H, W).\n            br_heat (Tensor): Bottom-right corner heatmap for current level\n                with shape (N, num_classes, H, W).\n            tl_emb (Tensor): Top-left corner embedding for current level with\n                shape (N, corner_emb_channels, H, W).\n            br_emb (Tensor): Bottom-right corner embedding for current level\n                with shape (N, corner_emb_channels, H, W).\n            tl_off (Tensor): Top-left corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            br_off (Tensor): Bottom-right corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            img_meta (dict): Meta information of current image, e.g.,\n                image size, scaling factor, etc.\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n            with_nms (bool): If True, do nms before return boxes.\n                Default: True.\n        \"\"\"", "\n", "if", "isinstance", "(", "img_meta", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "img_meta", "=", "img_meta", "[", "0", "]", "\n", "\n", "", "batch_bboxes", ",", "batch_scores", ",", "batch_clses", "=", "self", ".", "decode_heatmap", "(", "\n", "tl_heat", "=", "tl_heat", ".", "sigmoid", "(", ")", ",", "\n", "br_heat", "=", "br_heat", ".", "sigmoid", "(", ")", ",", "\n", "tl_off", "=", "tl_off", ",", "\n", "br_off", "=", "br_off", ",", "\n", "tl_emb", "=", "tl_emb", ",", "\n", "br_emb", "=", "br_emb", ",", "\n", "img_meta", "=", "img_meta", ",", "\n", "k", "=", "self", ".", "test_cfg", ".", "corner_topk", ",", "\n", "kernel", "=", "self", ".", "test_cfg", ".", "local_maximum_kernel", ",", "\n", "distance_threshold", "=", "self", ".", "test_cfg", ".", "distance_threshold", ")", "\n", "\n", "if", "rescale", ":", "\n", "            ", "batch_bboxes", "/=", "img_meta", "[", "'scale_factor'", "]", "\n", "\n", "", "bboxes", "=", "batch_bboxes", ".", "view", "(", "[", "-", "1", ",", "4", "]", ")", "\n", "scores", "=", "batch_scores", ".", "view", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "clses", "=", "batch_clses", ".", "view", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "\n", "idx", "=", "scores", ".", "argsort", "(", "dim", "=", "0", ",", "descending", "=", "True", ")", "\n", "bboxes", "=", "bboxes", "[", "idx", "]", ".", "view", "(", "[", "-", "1", ",", "4", "]", ")", "\n", "scores", "=", "scores", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "clses", "=", "clses", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "\n", "detections", "=", "torch", ".", "cat", "(", "[", "bboxes", ",", "scores", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "-", "1", ")", "\n", "keepinds", "=", "(", "detections", "[", ":", ",", "-", "1", "]", ">", "-", "0.1", ")", "\n", "detections", "=", "detections", "[", "keepinds", "]", "\n", "labels", "=", "clses", "[", "keepinds", "]", "\n", "\n", "if", "with_nms", ":", "\n", "            ", "detections", ",", "labels", "=", "self", ".", "_bboxes_nms", "(", "detections", ",", "labels", ",", "\n", "self", ".", "test_cfg", ")", "\n", "\n", "", "return", "detections", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._bboxes_nms": [[746, 758], ["mmcv.ops.batched_nms", "len", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort"], "methods", ["None"], ["", "def", "_bboxes_nms", "(", "self", ",", "bboxes", ",", "labels", ",", "cfg", ")", ":", "\n", "        ", "out_bboxes", ",", "keep", "=", "batched_nms", "(", "bboxes", "[", ":", ",", ":", "4", "]", ",", "bboxes", "[", ":", ",", "-", "1", "]", ",", "labels", ",", "\n", "cfg", ".", "nms_cfg", ")", "\n", "out_labels", "=", "labels", "[", "keep", "]", "\n", "\n", "if", "len", "(", "out_bboxes", ")", ">", "0", ":", "\n", "            ", "idx", "=", "torch", ".", "argsort", "(", "out_bboxes", "[", ":", ",", "-", "1", "]", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "cfg", ".", "max_per_img", "]", "\n", "out_bboxes", "=", "out_bboxes", "[", "idx", "]", "\n", "out_labels", "=", "out_labels", "[", "idx", "]", "\n", "\n", "", "return", "out_bboxes", ",", "out_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._gather_feat": [[759, 778], ["feat.view.view.size", "ind.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "feat.view.view.gather", "ind.unsqueeze().expand.unsqueeze().expand.size", "ind.unsqueeze().expand.unsqueeze().expand.size", "mask.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze().expand_as", "feat.view.view.view", "ind.unsqueeze().expand.unsqueeze().expand.unsqueeze", "mask.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "_gather_feat", "(", "self", ",", "feat", ",", "ind", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gather feature according to index.\n\n        Args:\n            feat (Tensor): Target feature map.\n            ind (Tensor): Target coord index.\n            mask (Tensor | None): Mask of featuremap. Default: None.\n\n        Returns:\n            feat (Tensor): Gathered feature.\n        \"\"\"", "\n", "dim", "=", "feat", ".", "size", "(", "2", ")", "\n", "ind", "=", "ind", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "ind", ".", "size", "(", "0", ")", ",", "ind", ".", "size", "(", "1", ")", ",", "dim", ")", "\n", "feat", "=", "feat", ".", "gather", "(", "1", ",", "ind", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "feat", ")", "\n", "feat", "=", "feat", "[", "mask", "]", "\n", "feat", "=", "feat", ".", "view", "(", "-", "1", ",", "dim", ")", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._local_maximum": [[779, 794], ["torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d"], "methods", ["None"], ["", "def", "_local_maximum", "(", "self", ",", "heat", ",", "kernel", "=", "3", ")", ":", "\n", "        ", "\"\"\"Extract local maximum pixel with given kernal.\n\n        Args:\n            heat (Tensor): Target heatmap.\n            kernel (int): Kernel size of max pooling. Default: 3.\n\n        Returns:\n            heat (Tensor): A heatmap where local maximum pixels maintain its\n                own value and other positions are 0.\n        \"\"\"", "\n", "pad", "=", "(", "kernel", "-", "1", ")", "//", "2", "\n", "hmax", "=", "F", ".", "max_pool2d", "(", "heat", ",", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "pad", ")", "\n", "keep", "=", "(", "hmax", "==", "heat", ")", ".", "float", "(", ")", "\n", "return", "heat", "*", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat": [[795, 809], ["corner_head.CornerHead.permute().contiguous", "corner_head.CornerHead.view", "corner_head.CornerHead._gather_feat", "corner_head.CornerHead.size", "corner_head.CornerHead.size", "corner_head.CornerHead.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._gather_feat"], ["", "def", "_transpose_and_gather_feat", "(", "self", ",", "feat", ",", "ind", ")", ":", "\n", "        ", "\"\"\"Transpose and gather feature according to index.\n\n        Args:\n            feat (Tensor): Target feature map.\n            ind (Tensor): Target coord index.\n\n        Returns:\n            feat (Tensor): Transposed and gathered feature.\n        \"\"\"", "\n", "feat", "=", "feat", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "feat", "=", "feat", ".", "view", "(", "feat", ".", "size", "(", "0", ")", ",", "-", "1", ",", "feat", ".", "size", "(", "3", ")", ")", "\n", "feat", "=", "self", ".", "_gather_feat", "(", "feat", ",", "ind", ")", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._topk": [[810, 835], ["scores.size", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "scores.view"], "methods", ["None"], ["", "def", "_topk", "(", "self", ",", "scores", ",", "k", "=", "20", ")", ":", "\n", "        ", "\"\"\"Get top k positions from heatmap.\n\n        Args:\n            scores (Tensor): Target heatmap with shape\n                [batch, num_classes, height, width].\n            k (int): Target number. Default: 20.\n\n        Returns:\n            tuple[torch.Tensor]: Scores, indexes, categories and coords of\n                topk keypoint. Containing following Tensors:\n\n            - topk_scores (Tensor): Max scores of each topk keypoint.\n            - topk_inds (Tensor): Indexes of each topk keypoint.\n            - topk_clses (Tensor): Categories of each topk keypoint.\n            - topk_ys (Tensor): Y-coord of each topk keypoint.\n            - topk_xs (Tensor): X-coord of each topk keypoint.\n        \"\"\"", "\n", "batch", ",", "_", ",", "height", ",", "width", "=", "scores", ".", "size", "(", ")", "\n", "topk_scores", ",", "topk_inds", "=", "torch", ".", "topk", "(", "scores", ".", "view", "(", "batch", ",", "-", "1", ")", ",", "k", ")", "\n", "topk_clses", "=", "topk_inds", "//", "(", "height", "*", "width", ")", "\n", "topk_inds", "=", "topk_inds", "%", "(", "height", "*", "width", ")", "\n", "topk_ys", "=", "topk_inds", "//", "width", "\n", "topk_xs", "=", "(", "topk_inds", "%", "width", ")", ".", "int", "(", ")", ".", "float", "(", ")", "\n", "return", "topk_scores", ",", "topk_inds", ",", "topk_clses", ",", "topk_ys", ",", "topk_xs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.decode_heatmap": [[836, 1043], ["corner_head.CornerHead.size", "corner_head.CornerHead._local_maximum", "corner_head.CornerHead._local_maximum", "corner_head.CornerHead._topk", "corner_head.CornerHead._topk", "tl_ys.view().expand.view().expand.view().expand", "tl_xs.view().expand.view().expand.view().expand", "br_ys.view().expand.view().expand.view().expand", "br_xs.view().expand.view().expand.view().expand", "corner_head.CornerHead._transpose_and_gather_feat", "tl_off.view.view.view", "corner_head.CornerHead._transpose_and_gather_feat", "br_off.view.view.view", "tl_xs.view().expand.view().expand.gt().type_as", "tl_ys.view().expand.view().expand.gt().type_as", "br_xs.view().expand.view().expand.gt().type_as", "br_ys.view().expand.view().expand.gt().type_as", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "tl_scores.view().expand.view().expand.view().expand", "br_scores.view().expand.view().expand.view().expand", "tl_clses.view().expand.view().expand.view().expand", "br_clses.view().expand.view().expand.view().expand", "scores.unsqueeze.unsqueeze.view", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "scores.unsqueeze.unsqueeze.unsqueeze", "corner_head.CornerHead.view", "corner_head.CornerHead._gather_feat", "tl_clses.view().expand.view().expand.contiguous().view", "corner_head.CornerHead._gather_feat().float", "corner_head.CornerHead._transpose_and_gather_feat().view().exp", "corner_head.CornerHead._transpose_and_gather_feat().view().exp", "tl_ctxs.gt().type_as", "tl_ctys.gt().type_as", "br_ctxs.gt().type_as", "br_ctys.gt().type_as", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "corner_head.CornerHead._transpose_and_gather_feat", "tl_emb.view.view.view", "corner_head.CornerHead._transpose_and_gather_feat", "br_emb.view.view.view", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "tl_ys.view().expand.view().expand.view", "tl_xs.view().expand.view().expand.view", "br_ys.view().expand.view().expand.view", "br_xs.view().expand.view().expand.view", "tl_xs.view().expand.view().expand.gt", "tl_ys.view().expand.view().expand.gt", "br_xs.view().expand.view().expand.gt", "br_ys.view().expand.view().expand.gt", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "tl_scores.view().expand.view().expand.view", "br_scores.view().expand.view().expand.view", "tl_clses.view().expand.view().expand.view", "br_clses.view().expand.view().expand.view", "tl_clses.view().expand.view().expand.contiguous", "corner_head.CornerHead._gather_feat", "corner_head.CornerHead._transpose_and_gather_feat().view", "corner_head.CornerHead._transpose_and_gather_feat().view", "tl_ctxs.gt", "tl_ctys.gt", "br_ctxs.gt", "br_ctys.gt", "corner_head.CornerHead._transpose_and_gather_feat", "corner_head.CornerHead._transpose_and_gather_feat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._local_maximum", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._local_maximum", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._topk", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._topk", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead._transpose_and_gather_feat"], ["", "def", "decode_heatmap", "(", "self", ",", "\n", "tl_heat", ",", "\n", "br_heat", ",", "\n", "tl_off", ",", "\n", "br_off", ",", "\n", "tl_emb", "=", "None", ",", "\n", "br_emb", "=", "None", ",", "\n", "tl_centripetal_shift", "=", "None", ",", "\n", "br_centripetal_shift", "=", "None", ",", "\n", "img_meta", "=", "None", ",", "\n", "k", "=", "100", ",", "\n", "kernel", "=", "3", ",", "\n", "distance_threshold", "=", "0.5", ",", "\n", "num_dets", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into raw bbox predictions.\n\n        Args:\n            tl_heat (Tensor): Top-left corner heatmap for current level with\n                shape (N, num_classes, H, W).\n            br_heat (Tensor): Bottom-right corner heatmap for current level\n                with shape (N, num_classes, H, W).\n            tl_off (Tensor): Top-left corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            br_off (Tensor): Bottom-right corner offset for current level with\n                shape (N, corner_offset_channels, H, W).\n            tl_emb (Tensor | None): Top-left corner embedding for current\n                level with shape (N, corner_emb_channels, H, W).\n            br_emb (Tensor | None): Bottom-right corner embedding for current\n                level with shape (N, corner_emb_channels, H, W).\n            tl_centripetal_shift (Tensor | None): Top-left centripetal shift\n                for current level with shape (N, 2, H, W).\n            br_centripetal_shift (Tensor | None): Bottom-right centripetal\n                shift for current level with shape (N, 2, H, W).\n            img_meta (dict): Meta information of current image, e.g.,\n                image size, scaling factor, etc.\n            k (int): Get top k corner keypoints from heatmap.\n            kernel (int): Max pooling kernel for extract local maximum pixels.\n            distance_threshold (float): Distance threshold. Top-left and\n                bottom-right corner keypoints with feature distance less than\n                the threshold will be regarded as keypoints from same object.\n            num_dets (int): Num of raw boxes before doing nms.\n\n        Returns:\n            tuple[torch.Tensor]: Decoded output of CornerHead, containing the\n            following Tensors:\n\n            - bboxes (Tensor): Coords of each box.\n            - scores (Tensor): Scores of each box.\n            - clses (Tensor): Categories of each box.\n        \"\"\"", "\n", "with_embedding", "=", "tl_emb", "is", "not", "None", "and", "br_emb", "is", "not", "None", "\n", "with_centripetal_shift", "=", "(", "\n", "tl_centripetal_shift", "is", "not", "None", "\n", "and", "br_centripetal_shift", "is", "not", "None", ")", "\n", "assert", "with_embedding", "+", "with_centripetal_shift", "==", "1", "\n", "batch", ",", "_", ",", "height", ",", "width", "=", "tl_heat", ".", "size", "(", ")", "\n", "inp_h", ",", "inp_w", ",", "_", "=", "img_meta", "[", "'pad_shape'", "]", "\n", "\n", "# perform nms on heatmaps", "\n", "tl_heat", "=", "self", ".", "_local_maximum", "(", "tl_heat", ",", "kernel", "=", "kernel", ")", "\n", "br_heat", "=", "self", ".", "_local_maximum", "(", "br_heat", ",", "kernel", "=", "kernel", ")", "\n", "\n", "tl_scores", ",", "tl_inds", ",", "tl_clses", ",", "tl_ys", ",", "tl_xs", "=", "self", ".", "_topk", "(", "tl_heat", ",", "k", "=", "k", ")", "\n", "br_scores", ",", "br_inds", ",", "br_clses", ",", "br_ys", ",", "br_xs", "=", "self", ".", "_topk", "(", "br_heat", ",", "k", "=", "k", ")", "\n", "\n", "tl_ys", "=", "tl_ys", ".", "view", "(", "batch", ",", "k", ",", "1", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "tl_xs", "=", "tl_xs", ".", "view", "(", "batch", ",", "k", ",", "1", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "br_ys", "=", "br_ys", ".", "view", "(", "batch", ",", "1", ",", "k", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "br_xs", "=", "br_xs", ".", "view", "(", "batch", ",", "1", ",", "k", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "\n", "tl_off", "=", "self", ".", "_transpose_and_gather_feat", "(", "tl_off", ",", "tl_inds", ")", "\n", "tl_off", "=", "tl_off", ".", "view", "(", "batch", ",", "k", ",", "1", ",", "2", ")", "\n", "br_off", "=", "self", ".", "_transpose_and_gather_feat", "(", "br_off", ",", "br_inds", ")", "\n", "br_off", "=", "br_off", ".", "view", "(", "batch", ",", "1", ",", "k", ",", "2", ")", "\n", "\n", "tl_xs", "=", "tl_xs", "+", "tl_off", "[", "...", ",", "0", "]", "\n", "tl_ys", "=", "tl_ys", "+", "tl_off", "[", "...", ",", "1", "]", "\n", "br_xs", "=", "br_xs", "+", "br_off", "[", "...", ",", "0", "]", "\n", "br_ys", "=", "br_ys", "+", "br_off", "[", "...", ",", "1", "]", "\n", "\n", "if", "with_centripetal_shift", ":", "\n", "            ", "tl_centripetal_shift", "=", "self", ".", "_transpose_and_gather_feat", "(", "\n", "tl_centripetal_shift", ",", "tl_inds", ")", ".", "view", "(", "batch", ",", "k", ",", "1", ",", "2", ")", ".", "exp", "(", ")", "\n", "br_centripetal_shift", "=", "self", ".", "_transpose_and_gather_feat", "(", "\n", "br_centripetal_shift", ",", "br_inds", ")", ".", "view", "(", "batch", ",", "1", ",", "k", ",", "2", ")", ".", "exp", "(", ")", "\n", "\n", "tl_ctxs", "=", "tl_xs", "+", "tl_centripetal_shift", "[", "...", ",", "0", "]", "\n", "tl_ctys", "=", "tl_ys", "+", "tl_centripetal_shift", "[", "...", ",", "1", "]", "\n", "br_ctxs", "=", "br_xs", "-", "br_centripetal_shift", "[", "...", ",", "0", "]", "\n", "br_ctys", "=", "br_ys", "-", "br_centripetal_shift", "[", "...", ",", "1", "]", "\n", "\n", "# all possible boxes based on top k corners (ignoring class)", "\n", "", "tl_xs", "*=", "(", "inp_w", "/", "width", ")", "\n", "tl_ys", "*=", "(", "inp_h", "/", "height", ")", "\n", "br_xs", "*=", "(", "inp_w", "/", "width", ")", "\n", "br_ys", "*=", "(", "inp_h", "/", "height", ")", "\n", "\n", "if", "with_centripetal_shift", ":", "\n", "            ", "tl_ctxs", "*=", "(", "inp_w", "/", "width", ")", "\n", "tl_ctys", "*=", "(", "inp_h", "/", "height", ")", "\n", "br_ctxs", "*=", "(", "inp_w", "/", "width", ")", "\n", "br_ctys", "*=", "(", "inp_h", "/", "height", ")", "\n", "\n", "", "x_off", "=", "img_meta", "[", "'border'", "]", "[", "2", "]", "\n", "y_off", "=", "img_meta", "[", "'border'", "]", "[", "0", "]", "\n", "\n", "tl_xs", "-=", "x_off", "\n", "tl_ys", "-=", "y_off", "\n", "br_xs", "-=", "x_off", "\n", "br_ys", "-=", "y_off", "\n", "\n", "tl_xs", "*=", "tl_xs", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "tl_xs", ")", "\n", "tl_ys", "*=", "tl_ys", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "tl_ys", ")", "\n", "br_xs", "*=", "br_xs", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "br_xs", ")", "\n", "br_ys", "*=", "br_ys", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "br_ys", ")", "\n", "\n", "bboxes", "=", "torch", ".", "stack", "(", "(", "tl_xs", ",", "tl_ys", ",", "br_xs", ",", "br_ys", ")", ",", "dim", "=", "3", ")", "\n", "area_bboxes", "=", "(", "(", "br_xs", "-", "tl_xs", ")", "*", "(", "br_ys", "-", "tl_ys", ")", ")", ".", "abs", "(", ")", "\n", "\n", "if", "with_centripetal_shift", ":", "\n", "            ", "tl_ctxs", "-=", "x_off", "\n", "tl_ctys", "-=", "y_off", "\n", "br_ctxs", "-=", "x_off", "\n", "br_ctys", "-=", "y_off", "\n", "\n", "tl_ctxs", "*=", "tl_ctxs", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "tl_ctxs", ")", "\n", "tl_ctys", "*=", "tl_ctys", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "tl_ctys", ")", "\n", "br_ctxs", "*=", "br_ctxs", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "br_ctxs", ")", "\n", "br_ctys", "*=", "br_ctys", ".", "gt", "(", "0.0", ")", ".", "type_as", "(", "br_ctys", ")", "\n", "\n", "ct_bboxes", "=", "torch", ".", "stack", "(", "(", "tl_ctxs", ",", "tl_ctys", ",", "br_ctxs", ",", "br_ctys", ")", ",", "\n", "dim", "=", "3", ")", "\n", "area_ct_bboxes", "=", "(", "(", "br_ctxs", "-", "tl_ctxs", ")", "*", "(", "br_ctys", "-", "tl_ctys", ")", ")", ".", "abs", "(", ")", "\n", "\n", "rcentral", "=", "torch", ".", "zeros_like", "(", "ct_bboxes", ")", "\n", "# magic nums from paper section 4.1", "\n", "mu", "=", "torch", ".", "ones_like", "(", "area_bboxes", ")", "/", "2.4", "\n", "mu", "[", "area_bboxes", ">", "3500", "]", "=", "1", "/", "2.1", "# large bbox have smaller mu", "\n", "\n", "bboxes_center_x", "=", "(", "bboxes", "[", "...", ",", "0", "]", "+", "bboxes", "[", "...", ",", "2", "]", ")", "/", "2", "\n", "bboxes_center_y", "=", "(", "bboxes", "[", "...", ",", "1", "]", "+", "bboxes", "[", "...", ",", "3", "]", ")", "/", "2", "\n", "rcentral", "[", "...", ",", "0", "]", "=", "bboxes_center_x", "-", "mu", "*", "(", "bboxes", "[", "...", ",", "2", "]", "-", "\n", "bboxes", "[", "...", ",", "0", "]", ")", "/", "2", "\n", "rcentral", "[", "...", ",", "1", "]", "=", "bboxes_center_y", "-", "mu", "*", "(", "bboxes", "[", "...", ",", "3", "]", "-", "\n", "bboxes", "[", "...", ",", "1", "]", ")", "/", "2", "\n", "rcentral", "[", "...", ",", "2", "]", "=", "bboxes_center_x", "+", "mu", "*", "(", "bboxes", "[", "...", ",", "2", "]", "-", "\n", "bboxes", "[", "...", ",", "0", "]", ")", "/", "2", "\n", "rcentral", "[", "...", ",", "3", "]", "=", "bboxes_center_y", "+", "mu", "*", "(", "bboxes", "[", "...", ",", "3", "]", "-", "\n", "bboxes", "[", "...", ",", "1", "]", ")", "/", "2", "\n", "area_rcentral", "=", "(", "(", "rcentral", "[", "...", ",", "2", "]", "-", "rcentral", "[", "...", ",", "0", "]", ")", "*", "\n", "(", "rcentral", "[", "...", ",", "3", "]", "-", "rcentral", "[", "...", ",", "1", "]", ")", ")", ".", "abs", "(", ")", "\n", "dists", "=", "area_ct_bboxes", "/", "area_rcentral", "\n", "\n", "tl_ctx_inds", "=", "(", "ct_bboxes", "[", "...", ",", "0", "]", "<=", "rcentral", "[", "...", ",", "0", "]", ")", "|", "(", "\n", "ct_bboxes", "[", "...", ",", "0", "]", ">=", "rcentral", "[", "...", ",", "2", "]", ")", "\n", "tl_cty_inds", "=", "(", "ct_bboxes", "[", "...", ",", "1", "]", "<=", "rcentral", "[", "...", ",", "1", "]", ")", "|", "(", "\n", "ct_bboxes", "[", "...", ",", "1", "]", ">=", "rcentral", "[", "...", ",", "3", "]", ")", "\n", "br_ctx_inds", "=", "(", "ct_bboxes", "[", "...", ",", "2", "]", "<=", "rcentral", "[", "...", ",", "0", "]", ")", "|", "(", "\n", "ct_bboxes", "[", "...", ",", "2", "]", ">=", "rcentral", "[", "...", ",", "2", "]", ")", "\n", "br_cty_inds", "=", "(", "ct_bboxes", "[", "...", ",", "3", "]", "<=", "rcentral", "[", "...", ",", "1", "]", ")", "|", "(", "\n", "ct_bboxes", "[", "...", ",", "3", "]", ">=", "rcentral", "[", "...", ",", "3", "]", ")", "\n", "\n", "", "if", "with_embedding", ":", "\n", "            ", "tl_emb", "=", "self", ".", "_transpose_and_gather_feat", "(", "tl_emb", ",", "tl_inds", ")", "\n", "tl_emb", "=", "tl_emb", ".", "view", "(", "batch", ",", "k", ",", "1", ")", "\n", "br_emb", "=", "self", ".", "_transpose_and_gather_feat", "(", "br_emb", ",", "br_inds", ")", "\n", "br_emb", "=", "br_emb", ".", "view", "(", "batch", ",", "1", ",", "k", ")", "\n", "dists", "=", "torch", ".", "abs", "(", "tl_emb", "-", "br_emb", ")", "\n", "\n", "", "tl_scores", "=", "tl_scores", ".", "view", "(", "batch", ",", "k", ",", "1", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "br_scores", "=", "br_scores", ".", "view", "(", "batch", ",", "1", ",", "k", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "\n", "scores", "=", "(", "tl_scores", "+", "br_scores", ")", "/", "2", "# scores for all possible boxes", "\n", "\n", "# tl and br should have same class", "\n", "tl_clses", "=", "tl_clses", ".", "view", "(", "batch", ",", "k", ",", "1", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "br_clses", "=", "br_clses", ".", "view", "(", "batch", ",", "1", ",", "k", ")", ".", "expand", "(", "batch", ",", "k", ",", "k", ")", "\n", "cls_inds", "=", "(", "tl_clses", "!=", "br_clses", ")", "\n", "\n", "# reject boxes based on distances", "\n", "dist_inds", "=", "dists", ">", "distance_threshold", "\n", "\n", "# reject boxes based on widths and heights", "\n", "width_inds", "=", "(", "br_xs", "<=", "tl_xs", ")", "\n", "height_inds", "=", "(", "br_ys", "<=", "tl_ys", ")", "\n", "\n", "scores", "[", "cls_inds", "]", "=", "-", "1", "\n", "scores", "[", "width_inds", "]", "=", "-", "1", "\n", "scores", "[", "height_inds", "]", "=", "-", "1", "\n", "scores", "[", "dist_inds", "]", "=", "-", "1", "\n", "if", "with_centripetal_shift", ":", "\n", "            ", "scores", "[", "tl_ctx_inds", "]", "=", "-", "1", "\n", "scores", "[", "tl_cty_inds", "]", "=", "-", "1", "\n", "scores", "[", "br_ctx_inds", "]", "=", "-", "1", "\n", "scores", "[", "br_cty_inds", "]", "=", "-", "1", "\n", "\n", "", "scores", "=", "scores", ".", "view", "(", "batch", ",", "-", "1", ")", "\n", "scores", ",", "inds", "=", "torch", ".", "topk", "(", "scores", ",", "num_dets", ")", "\n", "scores", "=", "scores", ".", "unsqueeze", "(", "2", ")", "\n", "\n", "bboxes", "=", "bboxes", ".", "view", "(", "batch", ",", "-", "1", ",", "4", ")", "\n", "bboxes", "=", "self", ".", "_gather_feat", "(", "bboxes", ",", "inds", ")", "\n", "\n", "clses", "=", "tl_clses", ".", "contiguous", "(", ")", ".", "view", "(", "batch", ",", "-", "1", ",", "1", ")", "\n", "clses", "=", "self", ".", "_gather_feat", "(", "clses", ",", "inds", ")", ".", "float", "(", ")", "\n", "\n", "return", "bboxes", ",", "scores", ",", "clses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.__init__": [[35, 102], ["dict", "dict", "dict", "dict", "base_dense_head.BaseDenseHead.__init__", "loss_cls.get", "mmdet.core.build_bbox_coder", "builder.build_loss", "builder.build_loss", "mmdet.core.build_anchor_generator", "anchor_head.AnchorHead._init_layers", "ValueError", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "hasattr", "dict"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "feat_channels", "=", "256", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "scales", "=", "[", "8", ",", "16", ",", "32", "]", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", ",", "64", "]", ")", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "(", ".0", ",", ".0", ",", ".0", ",", ".0", ")", ",", "\n", "target_stds", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", ",", "\n", "reg_decoded_bbox", "=", "False", ",", "\n", "background_label", "=", "None", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "\n", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", "/", "9.0", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "AnchorHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "feat_channels", "=", "feat_channels", "\n", "self", ".", "use_sigmoid_cls", "=", "loss_cls", ".", "get", "(", "'use_sigmoid'", ",", "False", ")", "\n", "# TODO better way to determine whether sample or not", "\n", "self", ".", "sampling", "=", "loss_cls", "[", "'type'", "]", "not", "in", "[", "\n", "'FocalLoss'", ",", "'GHMC'", ",", "'QualityFocalLoss'", "\n", "]", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "\n", "\n", "", "if", "self", ".", "cls_out_channels", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f'num_classes={num_classes} is too small'", ")", "\n", "", "self", ".", "reg_decoded_bbox", "=", "reg_decoded_bbox", "\n", "\n", "self", ".", "background_label", "=", "(", "\n", "num_classes", "if", "background_label", "is", "None", "else", "background_label", ")", "\n", "# background_label should be either 0 or num_classes", "\n", "assert", "(", "self", ".", "background_label", "==", "0", "\n", "or", "self", ".", "background_label", "==", "num_classes", ")", "\n", "\n", "self", ".", "bbox_coder", "=", "build_bbox_coder", "(", "bbox_coder", ")", "\n", "self", ".", "loss_cls", "=", "build_loss", "(", "loss_cls", ")", "\n", "self", ".", "loss_bbox", "=", "build_loss", "(", "loss_bbox", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# use PseudoSampler when sampling is False", "\n", "if", "self", ".", "sampling", "and", "hasattr", "(", "self", ".", "train_cfg", ",", "'sampler'", ")", ":", "\n", "                ", "sampler_cfg", "=", "self", ".", "train_cfg", ".", "sampler", "\n", "", "else", ":", "\n", "                ", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "", "self", ".", "fp16_enabled", "=", "False", "\n", "\n", "self", ".", "anchor_generator", "=", "build_anchor_generator", "(", "anchor_generator", ")", "\n", "# usually the numbers of anchors for each level are the same", "\n", "# except SSD detectors", "\n", "self", ".", "num_anchors", "=", "self", ".", "anchor_generator", ".", "num_base_anchors", "[", "0", "]", "\n", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead._init_layers": [[103, 108], ["torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "conv_cls", "=", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "1", ")", "\n", "self", ".", "conv_reg", "=", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "self", ".", "num_anchors", "*", "4", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.init_weights": [[109, 113], ["mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "normal_init", "(", "self", ".", "conv_cls", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.forward_single": [[114, 130], ["anchor_head.AnchorHead.conv_cls", "anchor_head.AnchorHead.conv_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls scores for a single scale level \\\n                    the channels number is num_anchors * num_classes.\n                bbox_pred (Tensor): Box energies / deltas for a single scale \\\n                    level, the channels number is num_anchors * 4.\n        \"\"\"", "\n", "cls_score", "=", "self", ".", "conv_cls", "(", "x", ")", "\n", "bbox_pred", "=", "self", ".", "conv_reg", "(", "x", ")", "\n", "return", "cls_score", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.forward": [[131, 149], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 4D-tensor.\n\n        Returns:\n            tuple: A tuple of classification scores and bbox prediction.\n\n                - cls_scores (list[Tensor]): Classification scores for all \\\n                    scale levels, each is a 4D-tensor, the channels number \\\n                    is num_anchors * num_classes.\n                - bbox_preds (list[Tensor]): Box energies / deltas for all \\\n                    scale levels, each is a 4D-tensor, the channels number \\\n                    is num_anchors * 4.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors": [[150, 179], ["len", "anchor_head.AnchorHead.anchor_generator.grid_anchors", "enumerate", "anchor_head.AnchorHead.anchor_generator.valid_flags", "valid_flag_list.append", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags"], ["", "def", "get_anchors", "(", "self", ",", "featmap_sizes", ",", "img_metas", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Get anchors according to feature map sizes.\n\n        Args:\n            featmap_sizes (list[tuple]): Multi-level feature map sizes.\n            img_metas (list[dict]): Image meta info.\n            device (torch.device | str): Device for returned tensors\n\n        Returns:\n            tuple:\n                anchor_list (list[Tensor]): Anchors of each image.\n                valid_flag_list (list[Tensor]): Valid flags of each image.\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "\n", "# since feature map sizes of all images are the same, we only compute", "\n", "# anchors for one time", "\n", "multi_level_anchors", "=", "self", ".", "anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", ")", "\n", "anchor_list", "=", "[", "multi_level_anchors", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "# for each image, we compute valid flags of multi level anchors", "\n", "valid_flag_list", "=", "[", "]", "\n", "for", "img_id", ",", "img_meta", "in", "enumerate", "(", "img_metas", ")", ":", "\n", "            ", "multi_level_flags", "=", "self", ".", "anchor_generator", ".", "valid_flags", "(", "\n", "featmap_sizes", ",", "img_meta", "[", "'pad_shape'", "]", ",", "device", ")", "\n", "valid_flag_list", ".", "append", "(", "multi_level_flags", ")", "\n", "\n", "", "return", "anchor_list", ",", "valid_flag_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead._get_targets_single": [[180, 279], ["mmdet.core.anchor_inside_flags", "anchor_head.AnchorHead.assigner.assign", "anchor_head.AnchorHead.sampler.sample", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "anchors.new_full", "anchors.new_zeros", "mmdet.core.anchor_inside_flags.any", "len", "len", "flat_anchors.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "anchor_head.AnchorHead.bbox_coder.encode"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "_get_targets_single", "(", "self", ",", "\n", "flat_anchors", ",", "\n", "valid_flags", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "gt_labels", ",", "\n", "img_meta", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for anchors in a\n        single image.\n\n        Args:\n            flat_anchors (Tensor): Multi-level anchors of the image, which are\n                concatenated into a single tensor of shape (num_anchors ,4)\n            valid_flags (Tensor): Multi level valid flags of the image,\n                which are concatenated into a single tensor of\n                    shape (num_anchors,).\n            gt_bboxes (Tensor): Ground truth bboxes of the image,\n                shape (num_gts, 4).\n            img_meta (dict): Meta info of the image.\n            gt_bboxes_ignore (Tensor): Ground truth bboxes to be\n                ignored, shape (num_ignored_gts, 4).\n            img_meta (dict): Meta info of the image.\n            gt_labels (Tensor): Ground truth labels of each box,\n                shape (num_gts,).\n            label_channels (int): Channel of label.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple:\n                labels_list (list[Tensor]): Labels of each level\n                label_weights_list (list[Tensor]): Label weights of each level\n                bbox_targets_list (list[Tensor]): BBox targets of each level\n                bbox_weights_list (list[Tensor]): BBox weights of each level\n                num_total_pos (int): Number of positive samples in all images\n                num_total_neg (int): Number of negative samples in all images\n        \"\"\"", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "\n", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# assign gt and sample anchors", "\n", "", "anchors", "=", "flat_anchors", "[", "inside_flags", ",", ":", "]", "\n", "\n", "assign_result", "=", "self", ".", "assigner", ".", "assign", "(", "\n", "anchors", ",", "gt_bboxes", ",", "gt_bboxes_ignore", ",", "\n", "None", "if", "self", ".", "sampling", "else", "gt_labels", ")", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "anchors", ",", "\n", "gt_bboxes", ")", "\n", "\n", "num_valid_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "bbox_targets", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "bbox_weights", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "labels", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "anchors", ".", "new_zeros", "(", "num_valid_anchors", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "if", "not", "self", ".", "reg_decoded_bbox", ":", "\n", "                ", "pos_bbox_targets", "=", "self", ".", "bbox_coder", ".", "encode", "(", "\n", "sampling_result", ".", "pos_bboxes", ",", "sampling_result", ".", "pos_gt_bboxes", ")", "\n", "", "else", ":", "\n", "                ", "pos_bbox_targets", "=", "sampling_result", ".", "pos_gt_bboxes", "\n", "", "bbox_targets", "[", "pos_inds", ",", ":", "]", "=", "pos_bbox_targets", "\n", "bbox_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "if", "gt_labels", "is", "None", ":", "\n", "# only rpn gives gt_labels as None, this time FG is 1", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "self", ".", "train_cfg", ".", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "self", ".", "train_cfg", ".", "pos_weight", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# map up to original set of anchors", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_anchors", ".", "size", "(", "0", ")", "\n", "labels", "=", "unmap", "(", "\n", "labels", ",", "\n", "num_total_anchors", ",", "\n", "inside_flags", ",", "\n", "fill", "=", "self", ".", "background_label", ")", "# fill bg label", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "bbox_targets", "=", "unmap", "(", "bbox_targets", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "bbox_weights", "=", "unmap", "(", "bbox_weights", ",", "num_total_anchors", ",", "inside_flags", ")", "\n", "\n", "", "return", "(", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", ",", "pos_inds", ",", "\n", "neg_inds", ",", "sampling_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_targets": [[280, 381], ["len", "range", "mmdet.core.multi_apply", "list", "any", "sum", "sum", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "enumerate", "len", "len", "anchors.size", "concat_anchor_list.append", "concat_valid_flag_list.append", "mmdet.core.images_to_levels", "tuple", "len", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "max", "max", "range", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels"], ["", "def", "get_targets", "(", "self", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "None", ",", "\n", "gt_labels_list", "=", "None", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ",", "\n", "return_sampling_results", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for anchors in\n        multiple images.\n\n        Args:\n            anchor_list (list[list[Tensor]]): Multi level anchors of each\n                image. The outer list indicates images, and the inner list\n                corresponds to feature levels of the image. Each element of\n                the inner list is a tensor of shape (num_anchors, 4).\n            valid_flag_list (list[list[Tensor]]): Multi level valid flags of\n                each image. The outer list indicates images, and the inner list\n                corresponds to feature levels of the image. Each element of\n                the inner list is a tensor of shape (num_anchors, )\n            gt_bboxes_list (list[Tensor]): Ground truth bboxes of each image.\n            img_metas (list[dict]): Meta info of each image.\n            gt_bboxes_ignore_list (list[Tensor]): Ground truth bboxes to be\n                ignored.\n            gt_labels_list (list[Tensor]): Ground truth labels of each box.\n            label_channels (int): Channel of label.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple: Usually returns a tuple containing learning targets.\n\n                - labels_list (list[Tensor]): Labels of each level.\n                - label_weights_list (list[Tensor]): Label weights of each \\\n                    level.\n                - bbox_targets_list (list[Tensor]): BBox targets of each level.\n                - bbox_weights_list (list[Tensor]): BBox weights of each level.\n                - num_total_pos (int): Number of positive samples in all \\\n                    images.\n                - num_total_neg (int): Number of negative samples in all \\\n                    images.\n            additional_returns: This function enables user-defined returns from\n                `self._get_targets_single`. These returns are currently refined\n                to properties at each feature map (i.e. having HxW dimension).\n                The results will be concatenated after the end\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "assert", "len", "(", "anchor_list", ")", "==", "len", "(", "valid_flag_list", ")", "==", "num_imgs", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "concat_valid_flag_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assert", "len", "(", "anchor_list", "[", "i", "]", ")", "==", "len", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "concat_valid_flag_list", ".", "append", "(", "torch", ".", "cat", "(", "valid_flag_list", "[", "i", "]", ")", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_bboxes_ignore_list", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "if", "gt_labels_list", "is", "None", ":", "\n", "            ", "gt_labels_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "results", "=", "multi_apply", "(", "\n", "self", ".", "_get_targets_single", ",", "\n", "concat_anchor_list", ",", "\n", "concat_valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_bboxes_ignore_list", ",", "\n", "gt_labels_list", ",", "\n", "img_metas", ",", "\n", "label_channels", "=", "label_channels", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "(", "all_labels", ",", "all_label_weights", ",", "all_bbox_targets", ",", "all_bbox_weights", ",", "\n", "pos_inds_list", ",", "neg_inds_list", ",", "sampling_results_list", ")", "=", "results", "[", ":", "7", "]", "\n", "rest_results", "=", "list", "(", "results", "[", "7", ":", "]", ")", "# user-added return values", "\n", "# no valid anchors", "\n", "if", "any", "(", "[", "labels", "is", "None", "for", "labels", "in", "all_labels", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled anchors of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "# split targets to a list w.r.t. multiple levels", "\n", "labels_list", "=", "images_to_levels", "(", "all_labels", ",", "num_level_anchors", ")", "\n", "label_weights_list", "=", "images_to_levels", "(", "all_label_weights", ",", "\n", "num_level_anchors", ")", "\n", "bbox_targets_list", "=", "images_to_levels", "(", "all_bbox_targets", ",", "\n", "num_level_anchors", ")", "\n", "bbox_weights_list", "=", "images_to_levels", "(", "all_bbox_weights", ",", "\n", "num_level_anchors", ")", "\n", "res", "=", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "\n", "if", "return_sampling_results", ":", "\n", "            ", "res", "=", "res", "+", "(", "sampling_results_list", ",", ")", "\n", "", "for", "i", ",", "r", "in", "enumerate", "(", "rest_results", ")", ":", "# user-added return values", "\n", "            ", "rest_results", "[", "i", "]", "=", "images_to_levels", "(", "r", ",", "num_level_anchors", ")", "\n", "\n", "", "return", "res", "+", "tuple", "(", "rest_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.loss_single": [[382, 428], ["labels.reshape.reshape.reshape", "label_weights.reshape.reshape.reshape", "cls_score.permute().reshape.permute().reshape.permute().reshape", "anchor_head.AnchorHead.loss_cls", "bbox_targets.reshape.reshape.reshape", "bbox_weights.reshape.reshape.reshape", "anchor_head.AnchorHead.permute().reshape", "anchor_head.AnchorHead.loss_bbox", "anchors.reshape.reshape.reshape", "anchor_head.AnchorHead.bbox_coder.decode", "cls_score.permute().reshape.permute().reshape.permute", "anchor_head.AnchorHead.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "loss_single", "(", "self", ",", "cls_score", ",", "bbox_pred", ",", "anchors", ",", "labels", ",", "label_weights", ",", "\n", "bbox_targets", ",", "bbox_weights", ",", "num_total_samples", ")", ":", "\n", "        ", "\"\"\"Compute loss of a single scale level.\n\n        Args:\n            cls_score (Tensor): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W).\n            bbox_pred (Tensor): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W).\n            anchors (Tensor): Box reference for each scale level with shape\n                (N, num_total_anchors, 4).\n            labels (Tensor): Labels of each anchors with shape\n                (N, num_total_anchors).\n            label_weights (Tensor): Label weights of each anchor with shape\n                (N, num_total_anchors)\n            bbox_targets (Tensor): BBox regression targets of each anchor wight\n                shape (N, num_total_anchors, 4).\n            bbox_weights (Tensor): BBox regression loss weights of each anchor\n                with shape (N, num_total_anchors, 4).\n            num_total_samples (int): If sampling, num total samples equal to\n                the number of total anchors; Otherwise, it is the number of\n                positive anchors.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "# classification loss", "\n", "labels", "=", "labels", ".", "reshape", "(", "-", "1", ")", "\n", "label_weights", "=", "label_weights", ".", "reshape", "(", "-", "1", ")", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "\n", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "labels", ",", "label_weights", ",", "avg_factor", "=", "num_total_samples", ")", "\n", "# regression loss", "\n", "bbox_targets", "=", "bbox_targets", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_weights", "=", "bbox_weights", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "if", "self", ".", "reg_decoded_bbox", ":", "\n", "            ", "anchors", "=", "anchors", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_pred", "=", "self", ".", "bbox_coder", ".", "decode", "(", "anchors", ",", "bbox_pred", ")", "\n", "", "loss_bbox", "=", "self", ".", "loss_bbox", "(", "\n", "bbox_pred", ",", "\n", "bbox_targets", ",", "\n", "bbox_weights", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "return", "loss_cls", ",", "loss_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.loss": [[429, 498], ["mmdet.core.force_fp32", "anchor_head.AnchorHead.get_anchors", "anchor_head.AnchorHead.get_targets", "range", "mmdet.core.images_to_levels", "mmdet.core.multi_apply", "dict", "len", "anchors.size", "len", "concat_anchor_list.append", "featmap.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            gt_bboxes (list[Tensor]): Ground truth bboxes for each image with\n                shape (num_gts, 4) in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[Tensor]): class indices corresponding to each box\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            gt_bboxes_ignore (None | list[Tensor]): specify which bounding\n                boxes can be ignored when computing the loss. Default: None\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "self", ".", "anchor_generator", ".", "num_levels", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "get_anchors", "(", "\n", "featmap_sizes", ",", "img_metas", ",", "device", "=", "device", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "bbox_targets_list", ",", "bbox_weights_list", ",", "\n", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "num_total_samples", "=", "(", "\n", "num_total_pos", "+", "num_total_neg", "if", "self", ".", "sampling", "else", "num_total_pos", ")", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors and flags to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "anchor_list", ")", ")", ":", "\n", "            ", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "", "all_anchor_list", "=", "images_to_levels", "(", "concat_anchor_list", ",", "\n", "num_level_anchors", ")", "\n", "\n", "losses_cls", ",", "losses_bbox", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "all_anchor_list", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_targets_list", ",", "\n", "bbox_weights_list", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "return", "dict", "(", "loss_cls", "=", "losses_cls", ",", "loss_bbox", "=", "losses_bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead.get_bboxes": [[499, 577], ["mmdet.core.force_fp32", "len", "anchor_head.AnchorHead.anchor_generator.grid_anchors", "range", "len", "len", "len", "anchor_head.AnchorHead._get_bboxes_single", "result_list.append", "range", "[].detach", "[].detach", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "@", "force_fp32", "(", "apply_to", "=", "(", "'cls_scores'", ",", "'bbox_preds'", ")", ")", "\n", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into bbox predictions.\n\n        Args:\n            cls_scores (list[Tensor]): Box scores for each scale level\n                Has shape (N, num_anchors * num_classes, H, W)\n            bbox_preds (list[Tensor]): Box energies / deltas for each scale\n                level with shape (N, num_anchors * 4, H, W)\n            img_metas (list[dict]): Meta information of each image, e.g.,\n                image size, scaling factor, etc.\n            cfg (mmcv.Config | None): Test / postprocessing configuration,\n                if None, test_cfg would be used\n            rescale (bool): If True, return boxes in original image space.\n                Default: False.\n\n        Returns:\n            list[tuple[Tensor, Tensor]]: Each item in result_list is 2-tuple.\n                The first item is an (n, 5) tensor, where the first 4 columns\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the\n                5-th column is a score between 0 and 1. The second item is a\n                (n,) tensor where each item is the predicted class labelof the\n                corresponding box.\n\n        Example:\n            >>> import mmcv\n            >>> self = AnchorHead(\n            >>>     num_classes=9,\n            >>>     in_channels=1,\n            >>>     anchor_generator=dict(\n            >>>         type='AnchorGenerator',\n            >>>         scales=[8],\n            >>>         ratios=[0.5, 1.0, 2.0],\n            >>>         strides=[4,]))\n            >>> img_metas = [{'img_shape': (32, 32, 3), 'scale_factor': 1}]\n            >>> cfg = mmcv.Config(dict(\n            >>>     score_thr=0.00,\n            >>>     nms=dict(type='nms', iou_thr=1.0),\n            >>>     max_per_img=10))\n            >>> feat = torch.rand(1, 1, 3, 3)\n            >>> cls_score, bbox_pred = self.forward_single(feat)\n            >>> # note the input lists are over different levels, not images\n            >>> cls_scores, bbox_preds = [cls_score], [bbox_pred]\n            >>> result_list = self.get_bboxes(cls_scores, bbox_preds,\n            >>>                               img_metas, cfg)\n            >>> det_bboxes, det_labels = result_list[0]\n            >>> assert len(result_list) == 1\n            >>> assert det_bboxes.shape[1] == 5\n            >>> assert len(det_bboxes) == len(det_labels) == cfg.max_per_img\n        \"\"\"", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "featmap_sizes", "=", "[", "cls_scores", "[", "i", "]", ".", "shape", "[", "-", "2", ":", "]", "for", "i", "in", "range", "(", "num_levels", ")", "]", "\n", "mlvl_anchors", "=", "self", ".", "anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", "=", "device", ")", "\n", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "proposals", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "bbox_pred_list", ",", "\n", "mlvl_anchors", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ")", "\n", "result_list", ".", "append", "(", "proposals", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.anchor_head.AnchorHead._get_bboxes_single": [[578, 659], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "cfg.get", "len", "len", "len", "cls_score.permute().reshape.permute().reshape.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "cfg.get", "anchor_head.AnchorHead.bbox_coder.decode", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "cls_score.permute().reshape.permute().reshape.sigmoid", "cls_score.permute().reshape.permute().reshape.softmax", "max_scores.topk", "cls_score.permute().reshape.permute().reshape.size", "bbox_pred.permute().reshape.permute().reshape.size", "cls_score.permute().reshape.permute().reshape.permute", "bbox_pred.permute().reshape.permute().reshape.permute", "cls_score.permute().reshape.softmax.max", "scores[].max"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_score_list", ",", "\n", "bbox_pred_list", ",", "\n", "mlvl_anchors", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into bbox predictions.\n\n        Args:\n            cls_score_list (list[Tensor]): Box scores for a single scale level\n                Has shape (num_anchors * num_classes, H, W).\n            bbox_pred_list (list[Tensor]): Box energies / deltas for a single\n                scale level with shape (num_anchors * 4, H, W).\n            mlvl_anchors (list[Tensor]): Box reference for a single scale level\n                with shape (num_total_anchors, 4).\n            img_shape (tuple[int]): Shape of the input image,\n                (height, width, 3).\n            scale_factor (ndarray): Scale factor of the image arange as\n                (w_scale, h_scale, w_scale, h_scale).\n            cfg (mmcv.Config): Test / postprocessing configuration,\n                if None, test_cfg would be used.\n            rescale (bool): If True, return boxes in original image space.\n\n        Returns:\n            Tensor: Labeled boxes in shape (n, 5), where the first 4 columns\n                are bounding box positions (tl_x, tl_y, br_x, br_y) and the\n                5-th column is a score between 0 and 1.\n        \"\"\"", "\n", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_score_list", ")", "==", "len", "(", "bbox_pred_list", ")", "==", "len", "(", "mlvl_anchors", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "anchors", "in", "zip", "(", "cls_score_list", ",", "\n", "bbox_pred_list", ",", "mlvl_anchors", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "\n", "0", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "scores", "=", "cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "scores", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "\n", "", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "# Get maximum scores for foreground classes.", "\n", "                ", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                    ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "                    ", "max_scores", ",", "_", "=", "scores", "[", ":", ",", ":", "-", "1", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "", "bboxes", "=", "self", ".", "bbox_coder", ".", "decode", "(", "\n", "anchors", ",", "bbox_pred", ",", "max_shape", "=", "img_shape", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "            ", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "# set a `aug_test_flag` to identify whether in the `aug_test` mode", "\n", "", "aug_test_flag", "=", "cfg", ".", "get", "(", "'aug_test'", ",", "False", ")", "\n", "if", "aug_test_flag", ":", "\n", "            ", "return", "mlvl_bboxes", ",", "mlvl_scores", "\n", "", "else", ":", "\n", "            ", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "mlvl_bboxes", ",", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.__init__": [[32, 106], ["dict", "dict", "dict", "int", "int", "numpy.arange().astype", "numpy.repeat", "numpy.tile", "numpy.stack().reshape", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "anchor_free_head.AnchorFreeHead.__init__", "loss_cls.get", "builder.build_loss", "builder.build_loss", "numpy.sqrt", "mmdet.core.PointGenerator", "mmdet.core.build_assigner", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "torch.Parameter", "torch.Parameter", "numpy.arange", "numpy.stack", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "hasattr", "dict", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "in_channels", ",", "\n", "point_feat_channels", "=", "256", ",", "\n", "num_points", "=", "9", ",", "\n", "gradient_mul", "=", "0.1", ",", "\n", "point_strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ",", "\n", "point_base_scale", "=", "4", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'FocalLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox_init", "=", "dict", "(", "\n", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", "/", "9.0", ",", "loss_weight", "=", "0.5", ")", ",", "\n", "loss_bbox_refine", "=", "dict", "(", "\n", "type", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", "/", "9.0", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "use_grid_points", "=", "False", ",", "\n", "center_init", "=", "True", ",", "\n", "transform_method", "=", "'moment'", ",", "\n", "moment_mul", "=", "0.01", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "num_points", "=", "num_points", "\n", "self", ".", "point_feat_channels", "=", "point_feat_channels", "\n", "self", ".", "use_grid_points", "=", "use_grid_points", "\n", "self", ".", "center_init", "=", "center_init", "\n", "\n", "# we use deform conv to extract points features", "\n", "self", ".", "dcn_kernel", "=", "int", "(", "np", ".", "sqrt", "(", "num_points", ")", ")", "\n", "self", ".", "dcn_pad", "=", "int", "(", "(", "self", ".", "dcn_kernel", "-", "1", ")", "/", "2", ")", "\n", "assert", "self", ".", "dcn_kernel", "*", "self", ".", "dcn_kernel", "==", "num_points", ",", "'The points number should be a square number.'", "\n", "assert", "self", ".", "dcn_kernel", "%", "2", "==", "1", ",", "'The points number should be an odd square number.'", "\n", "dcn_base", "=", "np", ".", "arange", "(", "-", "self", ".", "dcn_pad", ",", "\n", "self", ".", "dcn_pad", "+", "1", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "dcn_base_y", "=", "np", ".", "repeat", "(", "dcn_base", ",", "self", ".", "dcn_kernel", ")", "\n", "dcn_base_x", "=", "np", ".", "tile", "(", "dcn_base", ",", "self", ".", "dcn_kernel", ")", "\n", "dcn_base_offset", "=", "np", ".", "stack", "(", "[", "dcn_base_y", ",", "dcn_base_x", "]", ",", "axis", "=", "1", ")", ".", "reshape", "(", "\n", "(", "-", "1", ")", ")", "\n", "self", ".", "dcn_base_offset", "=", "torch", ".", "tensor", "(", "dcn_base_offset", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "num_classes", ",", "in_channels", ",", "loss_cls", "=", "loss_cls", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "gradient_mul", "=", "gradient_mul", "\n", "self", ".", "point_base_scale", "=", "point_base_scale", "\n", "self", ".", "point_strides", "=", "point_strides", "\n", "self", ".", "point_generators", "=", "[", "PointGenerator", "(", ")", "for", "_", "in", "self", ".", "point_strides", "]", "\n", "\n", "self", ".", "sampling", "=", "loss_cls", "[", "'type'", "]", "not", "in", "[", "'FocalLoss'", "]", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "init_assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "init", ".", "assigner", ")", "\n", "self", ".", "refine_assigner", "=", "build_assigner", "(", "\n", "self", ".", "train_cfg", ".", "refine", ".", "assigner", ")", "\n", "# use PseudoSampler when sampling is False", "\n", "if", "self", ".", "sampling", "and", "hasattr", "(", "self", ".", "train_cfg", ",", "'sampler'", ")", ":", "\n", "                ", "sampler_cfg", "=", "self", ".", "train_cfg", ".", "sampler", "\n", "", "else", ":", "\n", "                ", "sampler_cfg", "=", "dict", "(", "type", "=", "'PseudoSampler'", ")", "\n", "", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ",", "context", "=", "self", ")", "\n", "", "self", ".", "transform_method", "=", "transform_method", "\n", "if", "self", ".", "transform_method", "==", "'moment'", ":", "\n", "            ", "self", ".", "moment_transfer", "=", "nn", ".", "Parameter", "(", "\n", "data", "=", "torch", ".", "zeros", "(", "2", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "moment_mul", "=", "moment_mul", "\n", "\n", "", "self", ".", "use_sigmoid_cls", "=", "loss_cls", ".", "get", "(", "'use_sigmoid'", ",", "False", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "self", ".", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "self", ".", "num_classes", "+", "1", "\n", "", "self", ".", "loss_bbox_init", "=", "build_loss", "(", "loss_bbox_init", ")", "\n", "self", ".", "loss_bbox_refine", "=", "build_loss", "(", "loss_bbox_refine", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._init_layers": [[107, 150], ["torch.ReLU", "torch.ReLU", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "mmcv.ops.DeformConv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "mmcv.ops.DeformConv2d", "torch.Conv2d", "torch.Conv2d", "reppoints_head.RepPointsHead.cls_convs.append", "reppoints_head.RepPointsHead.reg_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "pts_out_dim", "=", "4", "if", "self", ".", "use_grid_points", "else", "2", "*", "self", ".", "num_points", "\n", "self", ".", "reppoints_cls_conv", "=", "DeformConv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "dcn_kernel", ",", "1", ",", "\n", "self", ".", "dcn_pad", ")", "\n", "self", ".", "reppoints_cls_out", "=", "nn", ".", "Conv2d", "(", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "cls_out_channels", ",", "1", ",", "1", ",", "0", ")", "\n", "self", ".", "reppoints_pts_init_conv", "=", "nn", ".", "Conv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "3", ",", "\n", "1", ",", "1", ")", "\n", "self", ".", "reppoints_pts_init_out", "=", "nn", ".", "Conv2d", "(", "self", ".", "point_feat_channels", ",", "\n", "pts_out_dim", ",", "1", ",", "1", ",", "0", ")", "\n", "self", ".", "reppoints_pts_refine_conv", "=", "DeformConv2d", "(", "self", ".", "feat_channels", ",", "\n", "self", ".", "point_feat_channels", ",", "\n", "self", ".", "dcn_kernel", ",", "1", ",", "\n", "self", ".", "dcn_pad", ")", "\n", "self", ".", "reppoints_pts_refine_out", "=", "nn", ".", "Conv2d", "(", "self", ".", "point_feat_channels", ",", "\n", "pts_out_dim", ",", "1", ",", "1", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.init_weights": [[151, 164], ["mmcv.cnn.bias_init_with_prob", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init", "mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "reppoints_cls_conv", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "reppoints_cls_out", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "reppoints_pts_init_conv", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "reppoints_pts_init_out", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "reppoints_pts_refine_conv", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "reppoints_pts_refine_out", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.points2bbox": [[165, 215], ["pts.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pts_x.min", "pts_x.max", "pts_y.min", "pts_y.max", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pts_x.min", "pts_x.max", "pts_y.min", "pts_y.max", "pts_y.mean", "pts_x.mean", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "reppoints_head.RepPointsHead.moment_transfer.detach"], "methods", ["None"], ["", "def", "points2bbox", "(", "self", ",", "pts", ",", "y_first", "=", "True", ")", ":", "\n", "        ", "\"\"\"Converting the points set into bounding box.\n\n        :param pts: the input points sets (fields), each points\n            set (fields) is represented as 2n scalar.\n        :param y_first: if y_fisrt=True, the point set is represented as\n            [y1, x1, y2, x2 ... yn, xn], otherwise the point set is\n            represented as [x1, y1, x2, y2 ... xn, yn].\n        :return: each points set is converting to a bbox [x1, y1, x2, y2].\n        \"\"\"", "\n", "pts_reshape", "=", "pts", ".", "view", "(", "pts", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "2", ",", "*", "pts", ".", "shape", "[", "2", ":", "]", ")", "\n", "pts_y", "=", "pts_reshape", "[", ":", ",", ":", ",", "0", ",", "...", "]", "if", "y_first", "else", "pts_reshape", "[", ":", ",", ":", ",", "1", ",", "\n", "...", "]", "\n", "pts_x", "=", "pts_reshape", "[", ":", ",", ":", ",", "1", ",", "...", "]", "if", "y_first", "else", "pts_reshape", "[", ":", ",", ":", ",", "0", ",", "\n", "...", "]", "\n", "if", "self", ".", "transform_method", "==", "'minmax'", ":", "\n", "            ", "bbox_left", "=", "pts_x", ".", "min", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_right", "=", "pts_x", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_up", "=", "pts_y", ".", "min", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_bottom", "=", "pts_y", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox", "=", "torch", ".", "cat", "(", "[", "bbox_left", ",", "bbox_up", ",", "bbox_right", ",", "bbox_bottom", "]", ",", "\n", "dim", "=", "1", ")", "\n", "", "elif", "self", ".", "transform_method", "==", "'partial_minmax'", ":", "\n", "            ", "pts_y", "=", "pts_y", "[", ":", ",", ":", "4", ",", "...", "]", "\n", "pts_x", "=", "pts_x", "[", ":", ",", ":", "4", ",", "...", "]", "\n", "bbox_left", "=", "pts_x", ".", "min", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_right", "=", "pts_x", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_up", "=", "pts_y", ".", "min", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox_bottom", "=", "pts_y", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "bbox", "=", "torch", ".", "cat", "(", "[", "bbox_left", ",", "bbox_up", ",", "bbox_right", ",", "bbox_bottom", "]", ",", "\n", "dim", "=", "1", ")", "\n", "", "elif", "self", ".", "transform_method", "==", "'moment'", ":", "\n", "            ", "pts_y_mean", "=", "pts_y", ".", "mean", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "pts_x_mean", "=", "pts_x", ".", "mean", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "pts_y_std", "=", "torch", ".", "std", "(", "pts_y", "-", "pts_y_mean", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "pts_x_std", "=", "torch", ".", "std", "(", "pts_x", "-", "pts_x_mean", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "moment_transfer", "=", "(", "self", ".", "moment_transfer", "*", "self", ".", "moment_mul", ")", "+", "(", "\n", "self", ".", "moment_transfer", ".", "detach", "(", ")", "*", "(", "1", "-", "self", ".", "moment_mul", ")", ")", "\n", "moment_width_transfer", "=", "moment_transfer", "[", "0", "]", "\n", "moment_height_transfer", "=", "moment_transfer", "[", "1", "]", "\n", "half_width", "=", "pts_x_std", "*", "torch", ".", "exp", "(", "moment_width_transfer", ")", "\n", "half_height", "=", "pts_y_std", "*", "torch", ".", "exp", "(", "moment_height_transfer", ")", "\n", "bbox", "=", "torch", ".", "cat", "(", "[", "\n", "pts_x_mean", "-", "half_width", ",", "pts_y_mean", "-", "half_height", ",", "\n", "pts_x_mean", "+", "half_width", ",", "pts_y_mean", "+", "half_height", "\n", "]", ",", "\n", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.gen_grid_from_reg": [[216, 249], ["torch.linspace().view().type_as", "torch.linspace().view().type_as", "torch.linspace().view().type_as", "torch.linspace().view().type_as", "grid_x.view.view.unsqueeze().repeat", "grid_x.view.view.view", "grid_y.view.view.unsqueeze().repeat", "grid_y.view.view.view", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "grid_yx.view.view.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.linspace().view", "torch.linspace().view", "torch.linspace().view", "torch.linspace().view", "grid_x.view.view.unsqueeze", "grid_y.view.view.unsqueeze", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace"], "methods", ["None"], ["", "def", "gen_grid_from_reg", "(", "self", ",", "reg", ",", "previous_boxes", ")", ":", "\n", "        ", "\"\"\"Base on the previous bboxes and regression values, we compute the\n        regressed bboxes and generate the grids on the bboxes.\n\n        :param reg: the regression value to previous bboxes.\n        :param previous_boxes: previous bboxes.\n        :return: generate grids on the regressed bboxes.\n        \"\"\"", "\n", "b", ",", "_", ",", "h", ",", "w", "=", "reg", ".", "shape", "\n", "bxy", "=", "(", "previous_boxes", "[", ":", ",", ":", "2", ",", "...", "]", "+", "previous_boxes", "[", ":", ",", "2", ":", ",", "...", "]", ")", "/", "2.", "\n", "bwh", "=", "(", "previous_boxes", "[", ":", ",", "2", ":", ",", "...", "]", "-", "\n", "previous_boxes", "[", ":", ",", ":", "2", ",", "...", "]", ")", ".", "clamp", "(", "min", "=", "1e-6", ")", "\n", "grid_topleft", "=", "bxy", "+", "bwh", "*", "reg", "[", ":", ",", ":", "2", ",", "...", "]", "-", "0.5", "*", "bwh", "*", "torch", ".", "exp", "(", "\n", "reg", "[", ":", ",", "2", ":", ",", "...", "]", ")", "\n", "grid_wh", "=", "bwh", "*", "torch", ".", "exp", "(", "reg", "[", ":", ",", "2", ":", ",", "...", "]", ")", "\n", "grid_left", "=", "grid_topleft", "[", ":", ",", "[", "0", "]", ",", "...", "]", "\n", "grid_top", "=", "grid_topleft", "[", ":", ",", "[", "1", "]", ",", "...", "]", "\n", "grid_width", "=", "grid_wh", "[", ":", ",", "[", "0", "]", ",", "...", "]", "\n", "grid_height", "=", "grid_wh", "[", ":", ",", "[", "1", "]", ",", "...", "]", "\n", "intervel", "=", "torch", ".", "linspace", "(", "0.", ",", "1.", ",", "self", ".", "dcn_kernel", ")", ".", "view", "(", "\n", "1", ",", "self", ".", "dcn_kernel", ",", "1", ",", "1", ")", ".", "type_as", "(", "reg", ")", "\n", "grid_x", "=", "grid_left", "+", "grid_width", "*", "intervel", "\n", "grid_x", "=", "grid_x", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "self", ".", "dcn_kernel", ",", "1", ",", "1", ",", "1", ")", "\n", "grid_x", "=", "grid_x", ".", "view", "(", "b", ",", "-", "1", ",", "h", ",", "w", ")", "\n", "grid_y", "=", "grid_top", "+", "grid_height", "*", "intervel", "\n", "grid_y", "=", "grid_y", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "dcn_kernel", ",", "1", ",", "1", ")", "\n", "grid_y", "=", "grid_y", ".", "view", "(", "b", ",", "-", "1", ",", "h", ",", "w", ")", "\n", "grid_yx", "=", "torch", ".", "stack", "(", "[", "grid_y", ",", "grid_x", "]", ",", "dim", "=", "2", ")", "\n", "grid_yx", "=", "grid_yx", ".", "view", "(", "b", ",", "-", "1", ",", "h", ",", "w", ")", "\n", "regressed_bbox", "=", "torch", ".", "cat", "(", "[", "\n", "grid_left", ",", "grid_top", ",", "grid_left", "+", "grid_width", ",", "grid_top", "+", "grid_height", "\n", "]", ",", "1", ")", "\n", "return", "grid_yx", ",", "regressed_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward": [[250, 252], ["mmdet.core.multi_apply"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.forward_single": [[253, 294], ["reppoints_head.RepPointsHead.dcn_base_offset.type_as", "reppoints_head.RepPointsHead.reppoints_pts_init_out", "reppoints_head.RepPointsHead.reppoints_cls_out", "reppoints_head.RepPointsHead.reppoints_pts_refine_out", "x.new_tensor().view", "cls_conv", "reg_conv", "reppoints_head.RepPointsHead.relu", "reppoints_head.RepPointsHead.gen_grid_from_reg", "reppoints_head.RepPointsHead.relu", "reppoints_head.RepPointsHead.relu", "reppoints_head.RepPointsHead.gen_grid_from_reg", "reppoints_head.RepPointsHead.reppoints_pts_init_conv", "x.new_tensor().view.detach", "reppoints_head.RepPointsHead.detach", "reppoints_head.RepPointsHead.reppoints_cls_conv", "reppoints_head.RepPointsHead.reppoints_pts_refine_conv", "bbox_out_init.detach", "reppoints_head.RepPointsHead.detach", "reppoints_head.RepPointsHead.max", "x.new_tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.gen_grid_from_reg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.gen_grid_from_reg"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature map of a single FPN level.\"\"\"", "\n", "dcn_base_offset", "=", "self", ".", "dcn_base_offset", ".", "type_as", "(", "x", ")", "\n", "# If we use center_init, the initial reppoints is from center points.", "\n", "# If we use bounding bbox representation, the initial reppoints is", "\n", "#   from regular grid placed on a pre-defined bbox.", "\n", "if", "self", ".", "use_grid_points", "or", "not", "self", ".", "center_init", ":", "\n", "            ", "scale", "=", "self", ".", "point_base_scale", "/", "2", "\n", "points_init", "=", "dcn_base_offset", "/", "dcn_base_offset", ".", "max", "(", ")", "*", "scale", "\n", "bbox_init", "=", "x", ".", "new_tensor", "(", "[", "-", "scale", ",", "-", "scale", ",", "scale", ",", "\n", "scale", "]", ")", ".", "view", "(", "1", ",", "4", ",", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "points_init", "=", "0", "\n", "", "cls_feat", "=", "x", "\n", "pts_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "pts_feat", "=", "reg_conv", "(", "pts_feat", ")", "\n", "# initialize reppoints", "\n", "", "pts_out_init", "=", "self", ".", "reppoints_pts_init_out", "(", "\n", "self", ".", "relu", "(", "self", ".", "reppoints_pts_init_conv", "(", "pts_feat", ")", ")", ")", "\n", "if", "self", ".", "use_grid_points", ":", "\n", "            ", "pts_out_init", ",", "bbox_out_init", "=", "self", ".", "gen_grid_from_reg", "(", "\n", "pts_out_init", ",", "bbox_init", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "pts_out_init", "=", "pts_out_init", "+", "points_init", "\n", "# refine and classify reppoints", "\n", "", "pts_out_init_grad_mul", "=", "(", "1", "-", "self", ".", "gradient_mul", ")", "*", "pts_out_init", ".", "detach", "(", "\n", ")", "+", "self", ".", "gradient_mul", "*", "pts_out_init", "\n", "dcn_offset", "=", "pts_out_init_grad_mul", "-", "dcn_base_offset", "\n", "cls_out", "=", "self", ".", "reppoints_cls_out", "(", "\n", "self", ".", "relu", "(", "self", ".", "reppoints_cls_conv", "(", "cls_feat", ",", "dcn_offset", ")", ")", ")", "\n", "pts_out_refine", "=", "self", ".", "reppoints_pts_refine_out", "(", "\n", "self", ".", "relu", "(", "self", ".", "reppoints_pts_refine_conv", "(", "pts_feat", ",", "dcn_offset", ")", ")", ")", "\n", "if", "self", ".", "use_grid_points", ":", "\n", "            ", "pts_out_refine", ",", "bbox_out_refine", "=", "self", ".", "gen_grid_from_reg", "(", "\n", "pts_out_refine", ",", "bbox_out_init", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "pts_out_refine", "=", "pts_out_refine", "+", "pts_out_init", ".", "detach", "(", ")", "\n", "", "return", "cls_out", ",", "pts_out_init", ",", "pts_out_refine", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points": [[295, 334], ["len", "len", "range", "enumerate", "reppoints_head.RepPointsHead.point_generators[].grid_points", "multi_level_points.append", "range", "valid_flag_list.append", "point.clone", "range", "min", "min", "reppoints_head.RepPointsHead.point_generators[].valid_flags", "multi_level_flags.append", "int", "int", "numpy.ceil", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.grid_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags"], ["", "def", "get_points", "(", "self", ",", "featmap_sizes", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"Get points according to feature map sizes.\n\n        Args:\n            featmap_sizes (list[tuple]): Multi-level feature map sizes.\n            img_metas (list[dict]): Image meta info.\n\n        Returns:\n            tuple: points of each image, valid flags of each image\n        \"\"\"", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "num_levels", "=", "len", "(", "featmap_sizes", ")", "\n", "\n", "# since feature map sizes of all images are the same, we only compute", "\n", "# points center for one time", "\n", "multi_level_points", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "points", "=", "self", ".", "point_generators", "[", "i", "]", ".", "grid_points", "(", "\n", "featmap_sizes", "[", "i", "]", ",", "self", ".", "point_strides", "[", "i", "]", ")", "\n", "multi_level_points", ".", "append", "(", "points", ")", "\n", "", "points_list", "=", "[", "[", "point", ".", "clone", "(", ")", "for", "point", "in", "multi_level_points", "]", "\n", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "\n", "# for each image, we compute valid flags of multi level grids", "\n", "valid_flag_list", "=", "[", "]", "\n", "for", "img_id", ",", "img_meta", "in", "enumerate", "(", "img_metas", ")", ":", "\n", "            ", "multi_level_flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "                ", "point_stride", "=", "self", ".", "point_strides", "[", "i", "]", "\n", "feat_h", ",", "feat_w", "=", "featmap_sizes", "[", "i", "]", "\n", "h", ",", "w", "=", "img_meta", "[", "'pad_shape'", "]", "[", ":", "2", "]", "\n", "valid_feat_h", "=", "min", "(", "int", "(", "np", ".", "ceil", "(", "h", "/", "point_stride", ")", ")", ",", "feat_h", ")", "\n", "valid_feat_w", "=", "min", "(", "int", "(", "np", ".", "ceil", "(", "w", "/", "point_stride", ")", ")", ",", "feat_w", ")", "\n", "flags", "=", "self", ".", "point_generators", "[", "i", "]", ".", "valid_flags", "(", "\n", "(", "feat_h", ",", "feat_w", ")", ",", "(", "valid_feat_h", ",", "valid_feat_w", ")", ")", "\n", "multi_level_flags", ".", "append", "(", "flags", ")", "\n", "", "valid_flag_list", ".", "append", "(", "multi_level_flags", ")", "\n", "\n", "", "return", "points_list", ",", "valid_flag_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.centers_to_bboxes": [[335, 352], ["enumerate", "range", "bbox_list.append", "len", "torch.Tensor().view().type_as", "torch.Tensor().view().type_as", "torch.Tensor().view().type_as", "torch.Tensor().view().type_as", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bbox.append", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "centers_to_bboxes", "(", "self", ",", "point_list", ")", ":", "\n", "        ", "\"\"\"Get bboxes according to center points.\n\n        Only used in :class:`MaxIoUAssigner`.\n        \"\"\"", "\n", "bbox_list", "=", "[", "]", "\n", "for", "i_img", ",", "point", "in", "enumerate", "(", "point_list", ")", ":", "\n", "            ", "bbox", "=", "[", "]", "\n", "for", "i_lvl", "in", "range", "(", "len", "(", "self", ".", "point_strides", ")", ")", ":", "\n", "                ", "scale", "=", "self", ".", "point_base_scale", "*", "self", ".", "point_strides", "[", "i_lvl", "]", "*", "0.5", "\n", "bbox_shift", "=", "torch", ".", "Tensor", "(", "[", "-", "scale", ",", "-", "scale", ",", "scale", ",", "\n", "scale", "]", ")", ".", "view", "(", "1", ",", "4", ")", ".", "type_as", "(", "point", "[", "0", "]", ")", "\n", "bbox_center", "=", "torch", ".", "cat", "(", "\n", "[", "point", "[", "i_lvl", "]", "[", ":", ",", ":", "2", "]", ",", "point", "[", "i_lvl", "]", "[", ":", ",", ":", "2", "]", "]", ",", "dim", "=", "1", ")", "\n", "bbox", ".", "append", "(", "bbox_center", "+", "bbox_shift", ")", "\n", "", "bbox_list", ".", "append", "(", "bbox", ")", "\n", "", "return", "bbox_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.offset_to_pts": [[353, 373], ["range", "len", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "pts_list.append", "len", "[].repeat", "pts_shift.permute().view", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "xy_pts_shift.view.view.view", "torch.stack.append", "torch.stack.append", "pts_shift.permute"], "methods", ["None"], ["", "def", "offset_to_pts", "(", "self", ",", "center_list", ",", "pred_list", ")", ":", "\n", "        ", "\"\"\"Change from point offset to point coordinate.\"\"\"", "\n", "pts_list", "=", "[", "]", "\n", "for", "i_lvl", "in", "range", "(", "len", "(", "self", ".", "point_strides", ")", ")", ":", "\n", "            ", "pts_lvl", "=", "[", "]", "\n", "for", "i_img", "in", "range", "(", "len", "(", "center_list", ")", ")", ":", "\n", "                ", "pts_center", "=", "center_list", "[", "i_img", "]", "[", "i_lvl", "]", "[", ":", ",", ":", "2", "]", ".", "repeat", "(", "\n", "1", ",", "self", ".", "num_points", ")", "\n", "pts_shift", "=", "pred_list", "[", "i_lvl", "]", "[", "i_img", "]", "\n", "yx_pts_shift", "=", "pts_shift", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "view", "(", "\n", "-", "1", ",", "2", "*", "self", ".", "num_points", ")", "\n", "y_pts_shift", "=", "yx_pts_shift", "[", "...", ",", "0", ":", ":", "2", "]", "\n", "x_pts_shift", "=", "yx_pts_shift", "[", "...", ",", "1", ":", ":", "2", "]", "\n", "xy_pts_shift", "=", "torch", ".", "stack", "(", "[", "x_pts_shift", ",", "y_pts_shift", "]", ",", "-", "1", ")", "\n", "xy_pts_shift", "=", "xy_pts_shift", ".", "view", "(", "*", "yx_pts_shift", ".", "shape", "[", ":", "-", "1", "]", ",", "-", "1", ")", "\n", "pts", "=", "xy_pts_shift", "*", "self", ".", "point_strides", "[", "i_lvl", "]", "+", "pts_center", "\n", "pts_lvl", ".", "append", "(", "pts", ")", "\n", "", "pts_lvl", "=", "torch", ".", "stack", "(", "pts_lvl", ",", "0", ")", "\n", "pts_list", ".", "append", "(", "pts_lvl", ")", "\n", "", "return", "pts_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._point_target_single": [[374, 443], ["assigner.assign", "reppoints_head.RepPointsHead.sampler.sample", "proposals.new_zeros", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "proposals.new_zeros", "proposals.new_full", "proposals.new_zeros", "inside_flags.any", "len", "len", "flat_proposals.size", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap", "mmdet.core.unmap"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.unmap"], ["", "def", "_point_target_single", "(", "self", ",", "\n", "flat_proposals", ",", "\n", "valid_flags", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", ",", "\n", "gt_labels", ",", "\n", "label_channels", "=", "1", ",", "\n", "stage", "=", "'init'", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "inside_flags", "=", "valid_flags", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# assign gt and sample proposals", "\n", "", "proposals", "=", "flat_proposals", "[", "inside_flags", ",", ":", "]", "\n", "\n", "if", "stage", "==", "'init'", ":", "\n", "            ", "assigner", "=", "self", ".", "init_assigner", "\n", "pos_weight", "=", "self", ".", "train_cfg", ".", "init", ".", "pos_weight", "\n", "", "else", ":", "\n", "            ", "assigner", "=", "self", ".", "refine_assigner", "\n", "pos_weight", "=", "self", ".", "train_cfg", ".", "refine", ".", "pos_weight", "\n", "", "assign_result", "=", "assigner", ".", "assign", "(", "proposals", ",", "gt_bboxes", ",", "gt_bboxes_ignore", ",", "\n", "None", "if", "self", ".", "sampling", "else", "gt_labels", ")", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "proposals", ",", "\n", "gt_bboxes", ")", "\n", "\n", "num_valid_proposals", "=", "proposals", ".", "shape", "[", "0", "]", "\n", "bbox_gt", "=", "proposals", ".", "new_zeros", "(", "[", "num_valid_proposals", ",", "4", "]", ")", "\n", "pos_proposals", "=", "torch", ".", "zeros_like", "(", "proposals", ")", "\n", "proposals_weights", "=", "proposals", ".", "new_zeros", "(", "[", "num_valid_proposals", ",", "4", "]", ")", "\n", "labels", "=", "proposals", ".", "new_full", "(", "(", "num_valid_proposals", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "proposals", ".", "new_zeros", "(", "\n", "num_valid_proposals", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "pos_gt_bboxes", "=", "sampling_result", ".", "pos_gt_bboxes", "\n", "bbox_gt", "[", "pos_inds", ",", ":", "]", "=", "pos_gt_bboxes", "\n", "pos_proposals", "[", "pos_inds", ",", ":", "]", "=", "proposals", "[", "pos_inds", ",", ":", "]", "\n", "proposals_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "if", "gt_labels", "is", "None", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "pos_weight", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# map up to original set of proposals", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_proposals", "=", "flat_proposals", ".", "size", "(", "0", ")", "\n", "labels", "=", "unmap", "(", "labels", ",", "num_total_proposals", ",", "inside_flags", ")", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_proposals", ",", "\n", "inside_flags", ")", "\n", "bbox_gt", "=", "unmap", "(", "bbox_gt", ",", "num_total_proposals", ",", "inside_flags", ")", "\n", "pos_proposals", "=", "unmap", "(", "pos_proposals", ",", "num_total_proposals", ",", "\n", "inside_flags", ")", "\n", "proposals_weights", "=", "unmap", "(", "proposals_weights", ",", "num_total_proposals", ",", "\n", "inside_flags", ")", "\n", "\n", "", "return", "(", "labels", ",", "label_weights", ",", "bbox_gt", ",", "pos_proposals", ",", "\n", "proposals_weights", ",", "pos_inds", ",", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets": [[444, 527], ["len", "range", "mmdet.core.multi_apply", "any", "sum", "sum", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "mmdet.core.images_to_levels", "len", "len", "points.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "max", "max", "range", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels"], ["", "def", "get_targets", "(", "self", ",", "\n", "proposals_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "None", ",", "\n", "gt_labels_list", "=", "None", ",", "\n", "stage", "=", "'init'", ",", "\n", "label_channels", "=", "1", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute corresponding GT box and classification targets for\n        proposals.\n\n        Args:\n            proposals_list (list[list]): Multi level points/bboxes of each\n                image.\n            valid_flag_list (list[list]): Multi level valid flags of each\n                image.\n            gt_bboxes_list (list[Tensor]): Ground truth bboxes of each image.\n            img_metas (list[dict]): Meta info of each image.\n            gt_bboxes_ignore_list (list[Tensor]): Ground truth bboxes to be\n                ignored.\n            gt_bboxes_list (list[Tensor]): Ground truth labels of each box.\n            stage (str): `init` or `refine`. Generate target for init stage or\n                refine stage\n            label_channels (int): Channel of label.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple:\n                - labels_list (list[Tensor]): Labels of each level.\n                - label_weights_list (list[Tensor]): Label weights of each level.  # noqa: E501\n                - bbox_gt_list (list[Tensor]): Ground truth bbox of each level.\n                - proposal_list (list[Tensor]): Proposals(points/bboxes) of each level.  # noqa: E501\n                - proposal_weights_list (list[Tensor]): Proposal weights of each level.  # noqa: E501\n                - num_total_pos (int): Number of positive samples in all images.  # noqa: E501\n                - num_total_neg (int): Number of negative samples in all images.  # noqa: E501\n        \"\"\"", "\n", "assert", "stage", "in", "[", "'init'", ",", "'refine'", "]", "\n", "num_imgs", "=", "len", "(", "img_metas", ")", "\n", "assert", "len", "(", "proposals_list", ")", "==", "len", "(", "valid_flag_list", ")", "==", "num_imgs", "\n", "\n", "# points number of multi levels", "\n", "num_level_proposals", "=", "[", "points", ".", "size", "(", "0", ")", "for", "points", "in", "proposals_list", "[", "0", "]", "]", "\n", "\n", "# concat all level points and flags to a single tensor", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "            ", "assert", "len", "(", "proposals_list", "[", "i", "]", ")", "==", "len", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "proposals_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "proposals_list", "[", "i", "]", ")", "\n", "valid_flag_list", "[", "i", "]", "=", "torch", ".", "cat", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_bboxes_ignore_list", "is", "None", ":", "\n", "            ", "gt_bboxes_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "if", "gt_labels_list", "is", "None", ":", "\n", "            ", "gt_labels_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "", "(", "all_labels", ",", "all_label_weights", ",", "all_bbox_gt", ",", "all_proposals", ",", "\n", "all_proposal_weights", ",", "pos_inds_list", ",", "neg_inds_list", ")", "=", "multi_apply", "(", "\n", "self", ".", "_point_target_single", ",", "\n", "proposals_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes_list", ",", "\n", "gt_bboxes_ignore_list", ",", "\n", "gt_labels_list", ",", "\n", "stage", "=", "stage", ",", "\n", "label_channels", "=", "label_channels", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "# no valid points", "\n", "if", "any", "(", "[", "labels", "is", "None", "for", "labels", "in", "all_labels", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled points of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "labels_list", "=", "images_to_levels", "(", "all_labels", ",", "num_level_proposals", ")", "\n", "label_weights_list", "=", "images_to_levels", "(", "all_label_weights", ",", "\n", "num_level_proposals", ")", "\n", "bbox_gt_list", "=", "images_to_levels", "(", "all_bbox_gt", ",", "num_level_proposals", ")", "\n", "proposals_list", "=", "images_to_levels", "(", "all_proposals", ",", "num_level_proposals", ")", "\n", "proposal_weights_list", "=", "images_to_levels", "(", "all_proposal_weights", ",", "\n", "num_level_proposals", ")", "\n", "return", "(", "labels_list", ",", "label_weights_list", ",", "bbox_gt_list", ",", "proposals_list", ",", "\n", "proposal_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss_single": [[528, 564], ["labels.reshape.reshape.reshape", "label_weights.reshape.reshape.reshape", "cls_score.permute().reshape.permute().reshape.permute().reshape", "reppoints_head.RepPointsHead.loss_cls", "bbox_gt_init.reshape.reshape.reshape", "bbox_weights_init.reshape.reshape.reshape", "reppoints_head.RepPointsHead.points2bbox", "bbox_gt_refine.reshape.reshape.reshape", "bbox_weights_refine.reshape.reshape.reshape", "reppoints_head.RepPointsHead.points2bbox", "reppoints_head.RepPointsHead.loss_bbox_init", "reppoints_head.RepPointsHead.loss_bbox_refine", "pts_pred_init.reshape", "pts_pred_refine.reshape", "cls_score.permute().reshape.permute().reshape.permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.points2bbox", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.points2bbox"], ["", "def", "loss_single", "(", "self", ",", "cls_score", ",", "pts_pred_init", ",", "pts_pred_refine", ",", "labels", ",", "\n", "label_weights", ",", "bbox_gt_init", ",", "bbox_weights_init", ",", "\n", "bbox_gt_refine", ",", "bbox_weights_refine", ",", "stride", ",", "\n", "num_total_samples_init", ",", "num_total_samples_refine", ")", ":", "\n", "# classification loss", "\n", "        ", "labels", "=", "labels", ".", "reshape", "(", "-", "1", ")", "\n", "label_weights", "=", "label_weights", ".", "reshape", "(", "-", "1", ")", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "\n", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "\n", "labels", ",", "\n", "label_weights", ",", "\n", "avg_factor", "=", "num_total_samples_refine", ")", "\n", "\n", "# points loss", "\n", "bbox_gt_init", "=", "bbox_gt_init", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_weights_init", "=", "bbox_weights_init", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_pred_init", "=", "self", ".", "points2bbox", "(", "\n", "pts_pred_init", ".", "reshape", "(", "-", "1", ",", "2", "*", "self", ".", "num_points", ")", ",", "y_first", "=", "False", ")", "\n", "bbox_gt_refine", "=", "bbox_gt_refine", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_weights_refine", "=", "bbox_weights_refine", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox_pred_refine", "=", "self", ".", "points2bbox", "(", "\n", "pts_pred_refine", ".", "reshape", "(", "-", "1", ",", "2", "*", "self", ".", "num_points", ")", ",", "y_first", "=", "False", ")", "\n", "normalize_term", "=", "self", ".", "point_base_scale", "*", "stride", "\n", "loss_pts_init", "=", "self", ".", "loss_bbox_init", "(", "\n", "bbox_pred_init", "/", "normalize_term", ",", "\n", "bbox_gt_init", "/", "normalize_term", ",", "\n", "bbox_weights_init", ",", "\n", "avg_factor", "=", "num_total_samples_init", ")", "\n", "loss_pts_refine", "=", "self", ".", "loss_bbox_refine", "(", "\n", "bbox_pred_refine", "/", "normalize_term", ",", "\n", "bbox_gt_refine", "/", "normalize_term", ",", "\n", "bbox_weights_refine", ",", "\n", "avg_factor", "=", "num_total_samples_refine", ")", "\n", "return", "loss_cls", ",", "loss_pts_init", ",", "loss_pts_refine", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss": [[565, 659], ["reppoints_head.RepPointsHead.get_points", "reppoints_head.RepPointsHead.offset_to_pts", "reppoints_head.RepPointsHead.get_targets", "reppoints_head.RepPointsHead.get_points", "reppoints_head.RepPointsHead.offset_to_pts", "enumerate", "reppoints_head.RepPointsHead.get_targets", "mmdet.core.multi_apply", "len", "len", "reppoints_head.RepPointsHead.centers_to_bboxes", "range", "reppoints_head.RepPointsHead.append", "featmap.size", "len", "reppoints_head.RepPointsHead.points2bbox", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bbox.append", "pts_preds_init[].detach", "bbox_shift[].permute().reshape", "bbox_shift[].permute"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.offset_to_pts", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.offset_to_pts", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.misc.multi_apply", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.centers_to_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.points2bbox"], ["", "def", "loss", "(", "self", ",", "\n", "cls_scores", ",", "\n", "pts_preds_init", ",", "\n", "pts_preds_refine", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore", "=", "None", ")", ":", "\n", "        ", "featmap_sizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "-", "2", ":", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "assert", "len", "(", "featmap_sizes", ")", "==", "len", "(", "self", ".", "point_generators", ")", "\n", "label_channels", "=", "self", ".", "cls_out_channels", "if", "self", ".", "use_sigmoid_cls", "else", "1", "\n", "\n", "# target for initial stage", "\n", "center_list", ",", "valid_flag_list", "=", "self", ".", "get_points", "(", "featmap_sizes", ",", "\n", "img_metas", ")", "\n", "pts_coordinate_preds_init", "=", "self", ".", "offset_to_pts", "(", "center_list", ",", "\n", "pts_preds_init", ")", "\n", "if", "self", ".", "train_cfg", ".", "init", ".", "assigner", "[", "'type'", "]", "==", "'PointAssigner'", ":", "\n", "# Assign target for center list", "\n", "            ", "candidate_list", "=", "center_list", "\n", "", "else", ":", "\n", "# transform center list to bbox list and", "\n", "#   assign target for bbox list", "\n", "            ", "bbox_list", "=", "self", ".", "centers_to_bboxes", "(", "center_list", ")", "\n", "candidate_list", "=", "bbox_list", "\n", "", "cls_reg_targets_init", "=", "self", ".", "get_targets", "(", "\n", "candidate_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "stage", "=", "'init'", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "(", "*", "_", ",", "bbox_gt_list_init", ",", "candidate_list_init", ",", "bbox_weights_list_init", ",", "\n", "num_total_pos_init", ",", "num_total_neg_init", ")", "=", "cls_reg_targets_init", "\n", "num_total_samples_init", "=", "(", "\n", "num_total_pos_init", "+", "\n", "num_total_neg_init", "if", "self", ".", "sampling", "else", "num_total_pos_init", ")", "\n", "\n", "# target for refinement stage", "\n", "center_list", ",", "valid_flag_list", "=", "self", ".", "get_points", "(", "featmap_sizes", ",", "\n", "img_metas", ")", "\n", "pts_coordinate_preds_refine", "=", "self", ".", "offset_to_pts", "(", "\n", "center_list", ",", "pts_preds_refine", ")", "\n", "bbox_list", "=", "[", "]", "\n", "for", "i_img", ",", "center", "in", "enumerate", "(", "center_list", ")", ":", "\n", "            ", "bbox", "=", "[", "]", "\n", "for", "i_lvl", "in", "range", "(", "len", "(", "pts_preds_refine", ")", ")", ":", "\n", "                ", "bbox_preds_init", "=", "self", ".", "points2bbox", "(", "\n", "pts_preds_init", "[", "i_lvl", "]", ".", "detach", "(", ")", ")", "\n", "bbox_shift", "=", "bbox_preds_init", "*", "self", ".", "point_strides", "[", "i_lvl", "]", "\n", "bbox_center", "=", "torch", ".", "cat", "(", "\n", "[", "center", "[", "i_lvl", "]", "[", ":", ",", ":", "2", "]", ",", "center", "[", "i_lvl", "]", "[", ":", ",", ":", "2", "]", "]", ",", "dim", "=", "1", ")", "\n", "bbox", ".", "append", "(", "bbox_center", "+", "\n", "bbox_shift", "[", "i_img", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", "\n", "", "bbox_list", ".", "append", "(", "bbox", ")", "\n", "", "cls_reg_targets_refine", "=", "self", ".", "get_targets", "(", "\n", "bbox_list", ",", "\n", "valid_flag_list", ",", "\n", "gt_bboxes", ",", "\n", "img_metas", ",", "\n", "gt_bboxes_ignore_list", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels_list", "=", "gt_labels", ",", "\n", "stage", "=", "'refine'", ",", "\n", "label_channels", "=", "label_channels", ")", "\n", "(", "labels_list", ",", "label_weights_list", ",", "bbox_gt_list_refine", ",", "\n", "candidate_list_refine", ",", "bbox_weights_list_refine", ",", "num_total_pos_refine", ",", "\n", "num_total_neg_refine", ")", "=", "cls_reg_targets_refine", "\n", "num_total_samples_refine", "=", "(", "\n", "num_total_pos_refine", "+", "\n", "num_total_neg_refine", "if", "self", ".", "sampling", "else", "num_total_pos_refine", ")", "\n", "\n", "# compute loss", "\n", "losses_cls", ",", "losses_pts_init", ",", "losses_pts_refine", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "cls_scores", ",", "\n", "pts_coordinate_preds_init", ",", "\n", "pts_coordinate_preds_refine", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "bbox_gt_list_init", ",", "\n", "bbox_weights_list_init", ",", "\n", "bbox_gt_list_refine", ",", "\n", "bbox_weights_list_refine", ",", "\n", "self", ".", "point_strides", ",", "\n", "num_total_samples_init", "=", "num_total_samples_init", ",", "\n", "num_total_samples_refine", "=", "num_total_samples_refine", ")", "\n", "loss_dict_all", "=", "{", "\n", "'loss_cls'", ":", "losses_cls", ",", "\n", "'loss_pts_init'", ":", "losses_pts_init", ",", "\n", "'loss_pts_refine'", ":", "losses_pts_refine", "\n", "}", "\n", "return", "loss_dict_all", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_bboxes": [[660, 696], ["len", "range", "len", "len", "reppoints_head.RepPointsHead.points2bbox", "reppoints_head.RepPointsHead.point_generators[].grid_points", "len", "reppoints_head.RepPointsHead._get_bboxes_single", "result_list.append", "range", "[].detach", "[].detach", "cls_scores[].size", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.points2bbox", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.grid_points", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single"], ["", "def", "get_bboxes", "(", "self", ",", "\n", "cls_scores", ",", "\n", "pts_preds_init", ",", "\n", "pts_preds_refine", ",", "\n", "img_metas", ",", "\n", "cfg", "=", "None", ",", "\n", "rescale", "=", "False", ",", "\n", "nms", "=", "True", ")", ":", "\n", "        ", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "pts_preds_refine", ")", "\n", "bbox_preds_refine", "=", "[", "\n", "self", ".", "points2bbox", "(", "pts_pred_refine", ")", "\n", "for", "pts_pred_refine", "in", "pts_preds_refine", "\n", "]", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "mlvl_points", "=", "[", "\n", "self", ".", "point_generators", "[", "i", "]", ".", "grid_points", "(", "cls_scores", "[", "i", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", ",", "\n", "self", ".", "point_strides", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "result_list", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "bbox_pred_list", "=", "[", "\n", "bbox_preds_refine", "[", "i", "]", "[", "img_id", "]", ".", "detach", "(", ")", "\n", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "img_shape", "=", "img_metas", "[", "img_id", "]", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_metas", "[", "img_id", "]", "[", "'scale_factor'", "]", "\n", "proposals", "=", "self", ".", "_get_bboxes_single", "(", "cls_score_list", ",", "bbox_pred_list", ",", "\n", "mlvl_points", ",", "img_shape", ",", "\n", "scale_factor", ",", "cfg", ",", "rescale", ",", "\n", "nms", ")", "\n", "result_list", ".", "append", "(", "proposals", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead._get_bboxes_single": [[697, 759], ["enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "len", "zip", "cls_score.permute().reshape.permute().reshape.permute().reshape", "bbox_pred.permute().reshape.permute().reshape.permute().reshape", "cfg.get", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bboxes[].clamp", "bboxes[].clamp", "bboxes[].clamp", "bboxes[].clamp", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.new_tensor", "torch.cat.new_tensor", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mmdet.core.multiclass_nms", "cls_score.permute().reshape.permute().reshape.sigmoid", "cls_score.permute().reshape.permute().reshape.softmax", "max_scores.topk", "cls_score.permute().reshape.permute().reshape.size", "bbox_pred.permute().reshape.permute().reshape.size", "cls_score.permute().reshape.permute().reshape.permute", "bbox_pred.permute().reshape.permute().reshape.permute", "cls_score.permute().reshape.softmax.max", "scores[].max"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms"], ["", "def", "_get_bboxes_single", "(", "self", ",", "\n", "cls_scores", ",", "\n", "bbox_preds", ",", "\n", "mlvl_points", ",", "\n", "img_shape", ",", "\n", "scale_factor", ",", "\n", "cfg", ",", "\n", "rescale", "=", "False", ",", "\n", "nms", "=", "True", ")", ":", "\n", "        ", "cfg", "=", "self", ".", "test_cfg", "if", "cfg", "is", "None", "else", "cfg", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "bbox_preds", ")", "==", "len", "(", "mlvl_points", ")", "\n", "mlvl_bboxes", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "for", "i_lvl", ",", "(", "cls_score", ",", "bbox_pred", ",", "points", ")", "in", "enumerate", "(", "\n", "zip", "(", "cls_scores", ",", "bbox_preds", ",", "mlvl_points", ")", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "bbox_pred", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "1", ",", "2", ",", "\n", "0", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "scores", "=", "cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "scores", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "\n", "", "bbox_pred", "=", "bbox_pred", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "nms_pre", "=", "cfg", ".", "get", "(", "'nms_pre'", ",", "-", "1", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "                ", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                    ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "                    ", "max_scores", ",", "_", "=", "scores", "[", ":", ",", ":", "-", "1", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "points", "=", "points", "[", "topk_inds", ",", ":", "]", "\n", "bbox_pred", "=", "bbox_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "", "bbox_pos_center", "=", "torch", ".", "cat", "(", "[", "points", "[", ":", ",", ":", "2", "]", ",", "points", "[", ":", ",", ":", "2", "]", "]", ",", "dim", "=", "1", ")", "\n", "bboxes", "=", "bbox_pred", "*", "self", ".", "point_strides", "[", "i_lvl", "]", "+", "bbox_pos_center", "\n", "x1", "=", "bboxes", "[", ":", ",", "0", "]", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "1", "]", ")", "\n", "y1", "=", "bboxes", "[", ":", ",", "1", "]", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "0", "]", ")", "\n", "x2", "=", "bboxes", "[", ":", ",", "2", "]", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "1", "]", ")", "\n", "y2", "=", "bboxes", "[", ":", ",", "3", "]", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "img_shape", "[", "0", "]", ")", "\n", "bboxes", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "dim", "=", "-", "1", ")", "\n", "mlvl_bboxes", ".", "append", "(", "bboxes", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "", "mlvl_bboxes", "=", "torch", ".", "cat", "(", "mlvl_bboxes", ")", "\n", "if", "rescale", ":", "\n", "            ", "mlvl_bboxes", "/=", "mlvl_bboxes", ".", "new_tensor", "(", "scale_factor", ")", "\n", "", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "            ", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "", "if", "nms", ":", "\n", "            ", "det_bboxes", ",", "det_labels", "=", "multiclass_nms", "(", "mlvl_bboxes", ",", "mlvl_scores", ",", "\n", "cfg", ".", "score_thr", ",", "cfg", ".", "nms", ",", "\n", "cfg", ".", "max_per_img", ")", "\n", "return", "det_bboxes", ",", "det_labels", "\n", "", "else", ":", "\n", "            ", "return", "mlvl_bboxes", ",", "mlvl_scores", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnext.Bottleneck.__init__": [[13, 95], ["detectors_resnet.Bottleneck.__init__", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "detectors_resnext.Bottleneck.add_module", "detectors_resnext.Bottleneck.add_module", "mmcv.cnn.build_conv_layer", "detectors_resnext.Bottleneck.add_module", "detectors_resnext.Bottleneck.dcn.pop", "mmcv.cnn.build_conv_layer", "math.floor", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "groups", "=", "1", ",", "\n", "base_width", "=", "4", ",", "\n", "base_channels", "=", "64", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Bottleneck block for ResNeXt.\n\n        If style is \"pytorch\", the stride-two layer is the 3x3 conv layer, if\n        it is \"caffe\", the stride-two layer is the first 1x1 conv layer.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", "inplanes", ",", "planes", ",", "**", "kwargs", ")", "\n", "\n", "if", "groups", "==", "1", ":", "\n", "            ", "width", "=", "self", ".", "planes", "\n", "", "else", ":", "\n", "            ", "width", "=", "math", ".", "floor", "(", "self", ".", "planes", "*", "\n", "(", "base_width", "/", "base_channels", ")", ")", "*", "groups", "\n", "\n", "", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "2", ")", "\n", "self", ".", "norm3_name", ",", "norm3", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "self", ".", "planes", "*", "self", ".", "expansion", ",", "postfix", "=", "3", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "self", ".", "inplanes", ",", "\n", "width", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "self", ".", "conv1_stride", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "fallback_on_stride", "=", "False", "\n", "self", ".", "with_modulated_dcn", "=", "False", "\n", "if", "self", ".", "with_dcn", ":", "\n", "            ", "fallback_on_stride", "=", "self", ".", "dcn", ".", "pop", "(", "'fallback_on_stride'", ",", "False", ")", "\n", "", "if", "self", ".", "with_sac", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "sac", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "", "elif", "not", "self", ".", "with_dcn", "or", "fallback_on_stride", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "conv_cfg", "is", "None", ",", "'conv_cfg must be None for DCN'", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "dcn", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "self", ".", "conv3", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "self", ".", "planes", "*", "self", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm3_name", ",", "norm3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnext.DetectoRS_ResNeXt.__init__": [[112, 116], ["detectors_resnet.DetectoRS_ResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "groups", "=", "1", ",", "base_width", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "groups", "=", "groups", "\n", "self", ".", "base_width", "=", "base_width", "\n", "super", "(", "DetectoRS_ResNeXt", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnext.DetectoRS_ResNeXt.make_res_layer": [[117, 123], ["super().make_res_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.make_res_layer"], ["", "def", "make_res_layer", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "make_res_layer", "(", "\n", "groups", "=", "self", ".", "groups", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "\n", "base_channels", "=", "self", ".", "base_channels", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.SSDVGG.__init__": [[38, 74], ["mmcv.cnn.VGG.__init__", "ssd_vgg.SSDVGG.features.add_module", "ssd_vgg.SSDVGG.features.add_module", "ssd_vgg.SSDVGG.features.add_module", "ssd_vgg.SSDVGG.features.add_module", "ssd_vgg.SSDVGG.features.add_module", "ssd_vgg.SSDVGG._make_extra_layers", "ssd_vgg.L2Norm", "str", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "str", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "str", "torch.ReLU", "torch.ReLU", "torch.ReLU", "str", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "str", "torch.ReLU", "torch.ReLU", "torch.ReLU", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.SSDVGG._make_extra_layers"], ["def", "__init__", "(", "self", ",", "\n", "input_size", ",", "\n", "depth", ",", "\n", "with_last_pool", "=", "False", ",", "\n", "ceil_mode", "=", "True", ",", "\n", "out_indices", "=", "(", "3", ",", "4", ")", ",", "\n", "out_feature_indices", "=", "(", "22", ",", "34", ")", ",", "\n", "l2_norm_scale", "=", "20.", ")", ":", "\n", "# TODO: in_channels for mmcv.VGG", "\n", "        ", "super", "(", "SSDVGG", ",", "self", ")", ".", "__init__", "(", "\n", "depth", ",", "\n", "with_last_pool", "=", "with_last_pool", ",", "\n", "ceil_mode", "=", "ceil_mode", ",", "\n", "out_indices", "=", "out_indices", ")", "\n", "assert", "input_size", "in", "(", "300", ",", "512", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "\n", "self", ".", "features", ".", "add_module", "(", "\n", "str", "(", "len", "(", "self", ".", "features", ")", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ")", "\n", "self", ".", "features", ".", "add_module", "(", "\n", "str", "(", "len", "(", "self", ".", "features", ")", ")", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "1024", ",", "kernel_size", "=", "3", ",", "padding", "=", "6", ",", "dilation", "=", "6", ")", ")", "\n", "self", ".", "features", ".", "add_module", "(", "\n", "str", "(", "len", "(", "self", ".", "features", ")", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "features", ".", "add_module", "(", "\n", "str", "(", "len", "(", "self", ".", "features", ")", ")", ",", "nn", ".", "Conv2d", "(", "1024", ",", "1024", ",", "kernel_size", "=", "1", ")", ")", "\n", "self", ".", "features", ".", "add_module", "(", "\n", "str", "(", "len", "(", "self", ".", "features", ")", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "out_feature_indices", "=", "out_feature_indices", "\n", "\n", "self", ".", "inplanes", "=", "1024", "\n", "self", ".", "extra", "=", "self", ".", "_make_extra_layers", "(", "self", ".", "extra_setting", "[", "input_size", "]", ")", "\n", "self", ".", "l2_norm", "=", "L2Norm", "(", "\n", "self", ".", "features", "[", "out_feature_indices", "[", "0", "]", "-", "1", "]", ".", "out_channels", ",", "\n", "l2_norm_scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.SSDVGG.init_weights": [[75, 101], ["isinstance", "ssd_vgg.SSDVGG.extra.modules", "mmcv.cnn.constant_init", "mmdet.utils.get_root_logger", "mmcv.runner.load_checkpoint", "isinstance", "ssd_vgg.SSDVGG.features.modules", "TypeError", "mmcv.cnn.xavier_init", "isinstance", "mmcv.cnn.kaiming_init", "isinstance", "mmcv.cnn.constant_init", "isinstance", "mmcv.cnn.normal_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in backbone.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "isinstance", "(", "pretrained", ",", "str", ")", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "load_checkpoint", "(", "self", ",", "pretrained", ",", "strict", "=", "False", ",", "logger", "=", "logger", ")", "\n", "", "elif", "pretrained", "is", "None", ":", "\n", "            ", "for", "m", "in", "self", ".", "features", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "kaiming_init", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                    ", "constant_init", "(", "m", ",", "1", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "normal_init", "(", "m", ",", "std", "=", "0.01", ")", "\n", "", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'pretrained must be a str or None'", ")", "\n", "\n", "", "for", "m", "in", "self", ".", "extra", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "\n", "", "", "constant_init", "(", "self", ".", "l2_norm", ",", "self", ".", "l2_norm", ".", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.SSDVGG.forward": [[102, 118], ["enumerate", "enumerate", "ssd_vgg.SSDVGG.l2_norm", "layer", "torch.relu", "torch.relu", "torch.relu", "len", "tuple", "outs.append", "layer", "outs.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "features", ")", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "if", "i", "in", "self", ".", "out_feature_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "extra", ")", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ",", "inplace", "=", "True", ")", "\n", "if", "i", "%", "2", "==", "1", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "outs", "[", "0", "]", "=", "self", ".", "l2_norm", "(", "outs", "[", "0", "]", ")", "\n", "if", "len", "(", "outs", ")", "==", "1", ":", "\n", "            ", "return", "outs", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.SSDVGG._make_extra_layers": [[119, 144], ["range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "len", "layers.append", "layers.append", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["None"], ["", "", "def", "_make_extra_layers", "(", "self", ",", "outplanes", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "kernel_sizes", "=", "(", "1", ",", "3", ")", "\n", "num_layers", "=", "0", "\n", "outplane", "=", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "outplanes", ")", ")", ":", "\n", "            ", "if", "self", ".", "inplanes", "==", "'S'", ":", "\n", "                ", "self", ".", "inplanes", "=", "outplane", "\n", "continue", "\n", "", "k", "=", "kernel_sizes", "[", "num_layers", "%", "2", "]", "\n", "if", "outplanes", "[", "i", "]", "==", "'S'", ":", "\n", "                ", "outplane", "=", "outplanes", "[", "i", "+", "1", "]", "\n", "conv", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "inplanes", ",", "outplane", ",", "k", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "outplane", "=", "outplanes", "[", "i", "]", "\n", "conv", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "inplanes", ",", "outplane", ",", "k", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "", "layers", ".", "append", "(", "conv", ")", "\n", "self", ".", "inplanes", "=", "outplanes", "[", "i", "]", "\n", "num_layers", "+=", "1", "\n", "", "if", "self", ".", "input_size", "==", "512", ":", "\n", "            ", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "256", ",", "4", ",", "padding", "=", "1", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.L2Norm.__init__": [[148, 162], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_dims", ",", "scale", "=", "20.", ",", "eps", "=", "1e-10", ")", ":", "\n", "        ", "\"\"\"L2 normalization layer.\n\n        Args:\n            n_dims (int): Number of dimensions to be normalized\n            scale (float, optional): Defaults to 20..\n            eps (float, optional): Used to avoid division by zero.\n                Defaults to 1e-10.\n        \"\"\"", "\n", "super", "(", "L2Norm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_dims", "=", "n_dims", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "n_dims", ")", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.ssd_vgg.L2Norm.forward": [[163, 170], ["x.float", "x.float.pow().sum().sqrt", "x.float.pow().sum", "ssd_vgg.L2Norm.weight[].float().expand_as", "x.float.pow", "ssd_vgg.L2Norm.weight[].float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "# normalization layer convert to FP32 in FP16 training", "\n", "x_float", "=", "x", ".", "float", "(", ")", "\n", "norm", "=", "x_float", ".", "pow", "(", "2", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", ".", "sqrt", "(", ")", "+", "self", ".", "eps", "\n", "return", "(", "self", ".", "weight", "[", "None", ",", ":", ",", "None", ",", "None", "]", ".", "float", "(", ")", ".", "expand_as", "(", "x_float", ")", "*", "\n", "x_float", "/", "norm", ")", ".", "type_as", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.res2net.Bottle2neck.__init__": [[16, 103], ["resnet.Bottleneck.__init__", "int", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "res2net.Bottle2neck.add_module", "mmcv.cnn.build_conv_layer", "res2net.Bottle2neck.add_module", "delattr", "delattr", "math.floor", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "res2net.Bottle2neck.dcn.pop", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "convs.append", "bns.append", "convs.append", "bns.append", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "scales", "=", "4", ",", "\n", "base_width", "=", "26", ",", "\n", "base_channels", "=", "64", ",", "\n", "stage_type", "=", "'normal'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Bottle2neck block for Res2Net.\n\n        If style is \"pytorch\", the stride-two layer is the 3x3 conv layer, if\n        it is \"caffe\", the stride-two layer is the first 1x1 conv layer.\n        \"\"\"", "\n", "super", "(", "Bottle2neck", ",", "self", ")", ".", "__init__", "(", "inplanes", ",", "planes", ",", "**", "kwargs", ")", "\n", "assert", "scales", ">", "1", ",", "'Res2Net degenerates to ResNet when scales = 1.'", "\n", "width", "=", "int", "(", "math", ".", "floor", "(", "self", ".", "planes", "*", "(", "base_width", "/", "base_channels", ")", ")", ")", "\n", "\n", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", "*", "scales", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm3_name", ",", "norm3", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "self", ".", "planes", "*", "self", ".", "expansion", ",", "postfix", "=", "3", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "self", ".", "inplanes", ",", "\n", "width", "*", "scales", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "self", ".", "conv1_stride", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "\n", "if", "stage_type", "==", "'stage'", "and", "self", ".", "conv2_stride", "!=", "1", ":", "\n", "            ", "self", ".", "pool", "=", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "3", ",", "stride", "=", "self", ".", "conv2_stride", ",", "padding", "=", "1", ")", "\n", "", "convs", "=", "[", "]", "\n", "bns", "=", "[", "]", "\n", "\n", "fallback_on_stride", "=", "False", "\n", "if", "self", ".", "with_dcn", ":", "\n", "            ", "fallback_on_stride", "=", "self", ".", "dcn", ".", "pop", "(", "'fallback_on_stride'", ",", "False", ")", "\n", "", "if", "not", "self", ".", "with_dcn", "or", "fallback_on_stride", ":", "\n", "            ", "for", "i", "in", "range", "(", "scales", "-", "1", ")", ":", "\n", "                ", "convs", ".", "append", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "bias", "=", "False", ")", ")", "\n", "bns", ".", "append", "(", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "i", "+", "1", ")", "[", "1", "]", ")", "\n", "", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", "convs", ")", "\n", "self", ".", "bns", "=", "nn", ".", "ModuleList", "(", "bns", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "conv_cfg", "is", "None", ",", "'conv_cfg must be None for DCN'", "\n", "for", "i", "in", "range", "(", "scales", "-", "1", ")", ":", "\n", "                ", "convs", ".", "append", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "dcn", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "bias", "=", "False", ")", ")", "\n", "bns", ".", "append", "(", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "i", "+", "1", ")", "[", "1", "]", ")", "\n", "", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", "convs", ")", "\n", "self", ".", "bns", "=", "nn", ".", "ModuleList", "(", "bns", ")", "\n", "\n", "", "self", ".", "conv3", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", "*", "scales", ",", "\n", "self", ".", "planes", "*", "self", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm3_name", ",", "norm3", ")", "\n", "\n", "self", ".", "stage_type", "=", "stage_type", "\n", "self", ".", "scales", "=", "scales", "\n", "self", ".", "width", "=", "width", "\n", "delattr", "(", "self", ",", "'conv2'", ")", "\n", "delattr", "(", "self", ",", "self", ".", "norm2_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.res2net.Bottle2neck.forward": [[104, 159], ["res2net.Bottle2neck.relu", "res2net.Bottle2neck.conv1", "res2net.Bottle2neck.norm1", "res2net.Bottle2neck.relu", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "res2net.Bottle2neck.relu", "range", "res2net.Bottle2neck.conv3", "res2net.Bottle2neck.norm3", "torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "res2net.Bottle2neck.forward._inner_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm3"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "norm1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv1_plugin_names", ")", "\n", "\n", "", "spx", "=", "torch", ".", "split", "(", "out", ",", "self", ".", "width", ",", "1", ")", "\n", "sp", "=", "self", ".", "convs", "[", "0", "]", "(", "spx", "[", "0", "]", ".", "contiguous", "(", ")", ")", "\n", "sp", "=", "self", ".", "relu", "(", "self", ".", "bns", "[", "0", "]", "(", "sp", ")", ")", "\n", "out", "=", "sp", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "scales", "-", "1", ")", ":", "\n", "                ", "if", "self", ".", "stage_type", "==", "'stage'", ":", "\n", "                    ", "sp", "=", "spx", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "sp", "=", "sp", "+", "spx", "[", "i", "]", "\n", "", "sp", "=", "self", ".", "convs", "[", "i", "]", "(", "sp", ".", "contiguous", "(", ")", ")", "\n", "sp", "=", "self", ".", "relu", "(", "self", ".", "bns", "[", "i", "]", "(", "sp", ")", ")", "\n", "out", "=", "torch", ".", "cat", "(", "(", "out", ",", "sp", ")", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "stage_type", "==", "'normal'", "or", "self", ".", "conv2_stride", "==", "1", ":", "\n", "                ", "out", "=", "torch", ".", "cat", "(", "(", "out", ",", "spx", "[", "self", ".", "scales", "-", "1", "]", ")", ",", "1", ")", "\n", "", "elif", "self", ".", "stage_type", "==", "'stage'", ":", "\n", "                ", "out", "=", "torch", ".", "cat", "(", "(", "out", ",", "self", ".", "pool", "(", "spx", "[", "self", ".", "scales", "-", "1", "]", ")", ")", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv2_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm3", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv3_plugin_names", ")", "\n", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.res2net.Res2Layer.__init__": [[180, 238], ["dict", "layers.append", "range", "torch.Sequential.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "mmcv.cnn.build_conv_layer", "block", "mmcv.cnn.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "1", ",", "\n", "avg_down", "=", "True", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "scales", "=", "4", ",", "\n", "base_width", "=", "26", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "block", "=", "block", "\n", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "stride", ",", "\n", "stride", "=", "stride", ",", "\n", "ceil_mode", "=", "True", ",", "\n", "count_include_pad", "=", "False", ")", ",", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "scales", "=", "scales", ",", "\n", "base_width", "=", "base_width", ",", "\n", "stage_type", "=", "'stage'", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "scales", "=", "scales", ",", "\n", "base_width", "=", "base_width", ",", "\n", "**", "kwargs", ")", ")", "\n", "", "super", "(", "Res2Layer", ",", "self", ")", ".", "__init__", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.res2net.Res2Net.__init__": [[298, 309], ["resnet.ResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "scales", "=", "4", ",", "\n", "base_width", "=", "26", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "deep_stem", "=", "True", ",", "\n", "avg_down", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "scales", "=", "scales", "\n", "self", ".", "base_width", "=", "base_width", "\n", "super", "(", "Res2Net", ",", "self", ")", ".", "__init__", "(", "\n", "style", "=", "'pytorch'", ",", "deep_stem", "=", "True", ",", "avg_down", "=", "True", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.res2net.Res2Net.make_res_layer": [[310, 316], ["res2net.Res2Layer"], "methods", ["None"], ["", "def", "make_res_layer", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "Res2Layer", "(", "\n", "scales", "=", "self", ".", "scales", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "\n", "base_channels", "=", "self", ".", "base_channels", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.Bottleneck.__init__": [[28, 60], ["resnet.Bottleneck.__init__", "detectors_resnet.Bottleneck.init_weights", "isinstance", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "rfp_inplanes", "=", "None", ",", "\n", "sac", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", "inplanes", ",", "planes", ",", "**", "kwargs", ")", "\n", "\n", "assert", "sac", "is", "None", "or", "isinstance", "(", "sac", ",", "dict", ")", "\n", "self", ".", "sac", "=", "sac", "\n", "self", ".", "with_sac", "=", "sac", "is", "not", "None", "\n", "if", "self", ".", "with_sac", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "sac", ",", "\n", "planes", ",", "\n", "planes", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "rfp_inplanes", "=", "rfp_inplanes", "\n", "if", "self", ".", "rfp_inplanes", ":", "\n", "            ", "self", ".", "rfp_conv", "=", "build_conv_layer", "(", "\n", "None", ",", "\n", "self", ".", "rfp_inplanes", ",", "\n", "planes", "*", "self", ".", "expansion", ",", "\n", "1", ",", "\n", "stride", "=", "1", ",", "\n", "bias", "=", "True", ")", "\n", "", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.Bottleneck.init_weights": [[61, 65], ["mmcv.cnn.constant_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights.\"\"\"", "\n", "if", "self", ".", "rfp_inplanes", ":", "\n", "            ", "constant_init", "(", "self", ".", "rfp_conv", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.Bottleneck.rfp_forward": [[66, 111], ["detectors_resnet.Bottleneck.relu", "detectors_resnet.Bottleneck.conv1", "detectors_resnet.Bottleneck.norm1", "detectors_resnet.Bottleneck.relu", "detectors_resnet.Bottleneck.conv2", "detectors_resnet.Bottleneck.norm2", "detectors_resnet.Bottleneck.relu", "detectors_resnet.Bottleneck.conv3", "detectors_resnet.Bottleneck.norm3", "torch.checkpoint", "torch.checkpoint", "detectors_resnet.Bottleneck.rfp_forward._inner_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm2", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm3"], ["", "", "def", "rfp_forward", "(", "self", ",", "x", ",", "rfp_feat", ")", ":", "\n", "        ", "\"\"\"The forward function that also takes the RFP features as input.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "norm1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv1_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv2_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm3", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv3_plugin_names", ")", "\n", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "rfp_inplanes", ":", "\n", "            ", "rfp_feat", "=", "self", ".", "rfp_conv", "(", "rfp_feat", ")", "\n", "out", "=", "out", "+", "rfp_feat", "\n", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.ResLayer.__init__": [[139, 202], ["dict", "layers.append", "range", "torch.Sequential.__init__", "torch.Sequential.extend", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Sequential.append", "block", "torch.AvgPool2d", "torch.AvgPool2d", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "1", ",", "\n", "avg_down", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "downsample_first", "=", "True", ",", "\n", "rfp_inplanes", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "block", "=", "block", "\n", "assert", "downsample_first", ",", "f'downsampel_first={downsample_first} is '", "'not supported in DetectoRS'", "\n", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "[", "]", "\n", "conv_stride", "=", "stride", "\n", "if", "avg_down", "and", "stride", "!=", "1", ":", "\n", "                ", "conv_stride", "=", "1", "\n", "downsample", ".", "append", "(", "\n", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "stride", ",", "\n", "stride", "=", "stride", ",", "\n", "ceil_mode", "=", "True", ",", "\n", "count_include_pad", "=", "False", ")", ")", "\n", "", "downsample", ".", "extend", "(", "[", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "conv_stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", "\n", "]", ")", "\n", "downsample", "=", "nn", ".", "Sequential", "(", "*", "downsample", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "rfp_inplanes", "=", "rfp_inplanes", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "super", "(", "ResLayer", ",", "self", ")", ".", "__init__", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.__init__": [[228, 276], ["resnet.ResNet.__init__", "enumerate", "detectors_resnet.DetectoRS_ResNet._freeze_stages", "detectors_resnet.DetectoRS_ResNet.make_res_layer", "detectors_resnet.DetectoRS_ResNet.add_module", "detectors_resnet.DetectoRS_ResNet.res_layers.append", "detectors_resnet.DetectoRS_ResNet.make_stage_plugins"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.make_res_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.make_stage_plugins"], ["def", "__init__", "(", "self", ",", "\n", "sac", "=", "None", ",", "\n", "stage_with_sac", "=", "(", "False", ",", "False", ",", "False", ",", "False", ")", ",", "\n", "rfp_inplanes", "=", "None", ",", "\n", "output_img", "=", "False", ",", "\n", "pretrained", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "sac", "=", "sac", "\n", "self", ".", "stage_with_sac", "=", "stage_with_sac", "\n", "self", ".", "rfp_inplanes", "=", "rfp_inplanes", "\n", "self", ".", "output_img", "=", "output_img", "\n", "self", ".", "pretrained", "=", "pretrained", "\n", "super", "(", "DetectoRS_ResNet", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "inplanes", "=", "self", ".", "stem_channels", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "self", ".", "stage_blocks", ")", ":", "\n", "            ", "stride", "=", "self", ".", "strides", "[", "i", "]", "\n", "dilation", "=", "self", ".", "dilations", "[", "i", "]", "\n", "dcn", "=", "self", ".", "dcn", "if", "self", ".", "stage_with_dcn", "[", "i", "]", "else", "None", "\n", "sac", "=", "self", ".", "sac", "if", "self", ".", "stage_with_sac", "[", "i", "]", "else", "None", "\n", "if", "self", ".", "plugins", "is", "not", "None", ":", "\n", "                ", "stage_plugins", "=", "self", ".", "make_stage_plugins", "(", "self", ".", "plugins", ",", "i", ")", "\n", "", "else", ":", "\n", "                ", "stage_plugins", "=", "None", "\n", "", "planes", "=", "self", ".", "base_channels", "*", "2", "**", "i", "\n", "res_layer", "=", "self", ".", "make_res_layer", "(", "\n", "block", "=", "self", ".", "block", ",", "\n", "inplanes", "=", "self", ".", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "num_blocks", "=", "num_blocks", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "style", "=", "self", ".", "style", ",", "\n", "avg_down", "=", "self", ".", "avg_down", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "sac", "=", "sac", ",", "\n", "rfp_inplanes", "=", "rfp_inplanes", "if", "i", ">", "0", "else", "None", ",", "\n", "plugins", "=", "stage_plugins", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "self", ".", "block", ".", "expansion", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "self", ".", "_freeze_stages", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.make_res_layer": [[277, 280], ["detectors_resnet.ResLayer"], "methods", ["None"], ["", "def", "make_res_layer", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Pack all blocks in a stage into a ``ResLayer`` for DetectoRS.\"\"\"", "\n", "return", "ResLayer", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.forward": [[281, 287], ["list", "tuple", "super().forward", "list.insert"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "outs", "=", "list", "(", "super", "(", "DetectoRS_ResNet", ",", "self", ")", ".", "forward", "(", "x", ")", ")", "\n", "if", "self", ".", "output_img", ":", "\n", "            ", "outs", ".", "insert", "(", "0", ",", "x", ")", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.rfp_forward": [[288, 306], ["detectors_resnet.DetectoRS_ResNet.maxpool", "enumerate", "tuple", "detectors_resnet.DetectoRS_ResNet.stem", "detectors_resnet.DetectoRS_ResNet.conv1", "detectors_resnet.DetectoRS_ResNet.norm1", "detectors_resnet.DetectoRS_ResNet.relu", "getattr", "layer.rfp_forward", "outs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.detectors_resnet.DetectoRS_ResNet.rfp_forward"], ["", "def", "rfp_forward", "(", "self", ",", "x", ",", "rfp_feats", ")", ":", "\n", "        ", "\"\"\"Forward function for RFP.\"\"\"", "\n", "if", "self", ".", "deep_stem", ":", "\n", "            ", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "rfp_feat", "=", "rfp_feats", "[", "i", "]", "if", "i", ">", "0", "else", "None", "\n", "for", "layer", "in", "res_layer", ":", "\n", "                ", "x", "=", "layer", ".", "rfp_forward", "(", "x", ",", "rfp_feat", ")", "\n", "", "if", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule.__init__": [[19, 44], ["dict", "torch.Module.__init__", "hrnet.HRModule._check_branches", "hrnet.HRModule._make_branches", "hrnet.HRModule._make_fuse_layers", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._check_branches", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_branches", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_fuse_layers"], ["def", "__init__", "(", "self", ",", "\n", "num_branches", ",", "\n", "blocks", ",", "\n", "num_blocks", ",", "\n", "in_channels", ",", "\n", "num_channels", ",", "\n", "multiscale_output", "=", "True", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", ":", "\n", "        ", "super", "(", "HRModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_check_branches", "(", "num_branches", ",", "num_blocks", ",", "in_channels", ",", "\n", "num_channels", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_branches", "=", "num_branches", "\n", "\n", "self", ".", "multiscale_output", "=", "multiscale_output", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "branches", "=", "self", ".", "_make_branches", "(", "num_branches", ",", "blocks", ",", "num_blocks", ",", "\n", "num_channels", ")", "\n", "self", ".", "fuse_layers", "=", "self", ".", "_make_fuse_layers", "(", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._check_branches": [[45, 61], ["len", "ValueError", "len", "ValueError", "len", "ValueError", "len", "len", "len"], "methods", ["None"], ["", "def", "_check_branches", "(", "self", ",", "num_branches", ",", "num_blocks", ",", "in_channels", ",", "\n", "num_channels", ")", ":", "\n", "        ", "if", "num_branches", "!=", "len", "(", "num_blocks", ")", ":", "\n", "            ", "error_msg", "=", "f'NUM_BRANCHES({num_branches}) '", "f'!= NUM_BLOCKS({len(num_blocks)})'", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "num_channels", ")", ":", "\n", "            ", "error_msg", "=", "f'NUM_BRANCHES({num_branches}) '", "f'!= NUM_CHANNELS({len(num_channels)})'", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "in_channels", ")", ":", "\n", "            ", "error_msg", "=", "f'NUM_BRANCHES({num_branches}) '", "f'!= NUM_INCHANNELS({len(in_channels)})'", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_one_branch": [[62, 105], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "mmcv.cnn.build_conv_layer", "block", "mmcv.cnn.build_norm_layer"], "methods", ["None"], ["", "", "def", "_make_one_branch", "(", "self", ",", "\n", "branch_index", ",", "\n", "block", ",", "\n", "num_blocks", ",", "\n", "num_channels", ",", "\n", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "in_channels", "[", "branch_index", "]", "!=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "self", ".", "in_channels", "[", "branch_index", "]", ",", "\n", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "num_channels", "[", "branch_index", "]", "*", "\n", "block", ".", "expansion", ")", "[", "1", "]", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "self", ".", "in_channels", "[", "branch_index", "]", ",", "\n", "num_channels", "[", "branch_index", "]", ",", "\n", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ")", ")", "\n", "self", ".", "in_channels", "[", "branch_index", "]", "=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "num_blocks", "[", "branch_index", "]", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "self", ".", "in_channels", "[", "branch_index", "]", ",", "\n", "num_channels", "[", "branch_index", "]", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_branches": [[106, 114], ["range", "torch.ModuleList", "branches.append", "hrnet.HRModule._make_one_branch"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_one_branch"], ["", "def", "_make_branches", "(", "self", ",", "num_branches", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ":", "\n", "        ", "branches", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_branches", ")", ":", "\n", "            ", "branches", ".", "append", "(", "\n", "self", ".", "_make_one_branch", "(", "i", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "branches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule._make_fuse_layers": [[115, 176], ["range", "torch.ModuleList", "range", "fuse_layers.append", "torch.ModuleList", "fuse_layer.append", "torch.Sequential", "fuse_layer.append", "range", "fuse_layer.append", "mmcv.cnn.build_conv_layer", "torch.Upsample", "torch.Sequential", "mmcv.cnn.build_norm_layer", "conv_downsamples.append", "conv_downsamples.append", "torch.Sequential", "torch.Sequential", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer", "torch.ReLU", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer"], "methods", ["None"], ["", "def", "_make_fuse_layers", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "None", "\n", "\n", "", "num_branches", "=", "self", ".", "num_branches", "\n", "in_channels", "=", "self", ".", "in_channels", "\n", "fuse_layers", "=", "[", "]", "\n", "num_out_branches", "=", "num_branches", "if", "self", ".", "multiscale_output", "else", "1", "\n", "for", "i", "in", "range", "(", "num_out_branches", ")", ":", "\n", "            ", "fuse_layer", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "num_branches", ")", ":", "\n", "                ", "if", "j", ">", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", "[", "j", "]", ",", "\n", "in_channels", "[", "i", "]", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "in_channels", "[", "i", "]", ")", "[", "1", "]", ",", "\n", "nn", ".", "Upsample", "(", "\n", "scale_factor", "=", "2", "**", "(", "j", "-", "i", ")", ",", "mode", "=", "'nearest'", ")", ")", ")", "\n", "", "elif", "j", "==", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "None", ")", "\n", "", "else", ":", "\n", "                    ", "conv_downsamples", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "i", "-", "j", ")", ":", "\n", "                        ", "if", "k", "==", "i", "-", "j", "-", "1", ":", "\n", "                            ", "conv_downsamples", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", "[", "j", "]", ",", "\n", "in_channels", "[", "i", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "\n", "in_channels", "[", "i", "]", ")", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                            ", "conv_downsamples", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", "[", "j", "]", ",", "\n", "in_channels", "[", "j", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "\n", "in_channels", "[", "j", "]", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", ")", ")", "\n", "", "", "fuse_layer", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv_downsamples", ")", ")", "\n", "", "", "fuse_layers", ".", "append", "(", "nn", ".", "ModuleList", "(", "fuse_layer", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "fuse_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRModule.forward": [[177, 195], ["range", "range", "len", "range", "x_fuse.append", "hrnet.HRModule.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "[", "self", ".", "branches", "[", "0", "]", "(", "x", "[", "0", "]", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_branches", ")", ":", "\n", "            ", "x", "[", "i", "]", "=", "self", ".", "branches", "[", "i", "]", "(", "x", "[", "i", "]", ")", "\n", "\n", "", "x_fuse", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "fuse_layers", ")", ")", ":", "\n", "            ", "y", "=", "0", "\n", "for", "j", "in", "range", "(", "self", ".", "num_branches", ")", ":", "\n", "                ", "if", "i", "==", "j", ":", "\n", "                    ", "y", "+=", "x", "[", "j", "]", "\n", "", "else", ":", "\n", "                    ", "y", "+=", "self", ".", "fuse_layers", "[", "i", "]", "[", "j", "]", "(", "x", "[", "j", "]", ")", "\n", "", "", "x_fuse", ".", "append", "(", "self", ".", "relu", "(", "y", ")", ")", "\n", "", "return", "x_fuse", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.__init__": [[259, 346], ["dict", "torch.Module.__init__", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "hrnet.HRNet.add_module", "mmcv.cnn.build_conv_layer", "hrnet.HRNet.add_module", "torch.ReLU", "hrnet.HRNet._make_layer", "hrnet.HRNet._make_transition_layer", "hrnet.HRNet._make_stage", "hrnet.HRNet._make_transition_layer", "hrnet.HRNet._make_stage", "hrnet.HRNet._make_transition_layer", "hrnet.HRNet._make_stage"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_transition_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_stage", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_transition_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_stage", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_transition_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_stage"], ["def", "__init__", "(", "self", ",", "\n", "extra", ",", "\n", "in_channels", "=", "3", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "norm_eval", "=", "True", ",", "\n", "with_cp", "=", "False", ",", "\n", "zero_init_residual", "=", "False", ")", ":", "\n", "        ", "super", "(", "HRNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "extra", "=", "extra", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "norm_eval", "=", "norm_eval", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "zero_init_residual", "=", "zero_init_residual", "\n", "\n", "# stem net", "\n", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "64", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "64", ",", "postfix", "=", "2", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "64", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "64", ",", "\n", "64", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# stage 1", "\n", "self", ".", "stage1_cfg", "=", "self", ".", "extra", "[", "'stage1'", "]", "\n", "num_channels", "=", "self", ".", "stage1_cfg", "[", "'num_channels'", "]", "[", "0", "]", "\n", "block_type", "=", "self", ".", "stage1_cfg", "[", "'block'", "]", "\n", "num_blocks", "=", "self", ".", "stage1_cfg", "[", "'num_blocks'", "]", "[", "0", "]", "\n", "\n", "block", "=", "self", ".", "blocks_dict", "[", "block_type", "]", "\n", "stage1_out_channels", "=", "num_channels", "*", "block", ".", "expansion", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "num_channels", ",", "num_blocks", ")", "\n", "\n", "# stage 2", "\n", "self", ".", "stage2_cfg", "=", "self", ".", "extra", "[", "'stage2'", "]", "\n", "num_channels", "=", "self", ".", "stage2_cfg", "[", "'num_channels'", "]", "\n", "block_type", "=", "self", ".", "stage2_cfg", "[", "'block'", "]", "\n", "\n", "block", "=", "self", ".", "blocks_dict", "[", "block_type", "]", "\n", "num_channels", "=", "[", "channel", "*", "block", ".", "expansion", "for", "channel", "in", "num_channels", "]", "\n", "self", ".", "transition1", "=", "self", ".", "_make_transition_layer", "(", "[", "stage1_out_channels", "]", ",", "\n", "num_channels", ")", "\n", "self", ".", "stage2", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "\n", "self", ".", "stage2_cfg", ",", "num_channels", ")", "\n", "\n", "# stage 3", "\n", "self", ".", "stage3_cfg", "=", "self", ".", "extra", "[", "'stage3'", "]", "\n", "num_channels", "=", "self", ".", "stage3_cfg", "[", "'num_channels'", "]", "\n", "block_type", "=", "self", ".", "stage3_cfg", "[", "'block'", "]", "\n", "\n", "block", "=", "self", ".", "blocks_dict", "[", "block_type", "]", "\n", "num_channels", "=", "[", "channel", "*", "block", ".", "expansion", "for", "channel", "in", "num_channels", "]", "\n", "self", ".", "transition2", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "\n", "num_channels", ")", "\n", "self", ".", "stage3", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "\n", "self", ".", "stage3_cfg", ",", "num_channels", ")", "\n", "\n", "# stage 4", "\n", "self", ".", "stage4_cfg", "=", "self", ".", "extra", "[", "'stage4'", "]", "\n", "num_channels", "=", "self", ".", "stage4_cfg", "[", "'num_channels'", "]", "\n", "block_type", "=", "self", ".", "stage4_cfg", "[", "'block'", "]", "\n", "\n", "block", "=", "self", ".", "blocks_dict", "[", "block_type", "]", "\n", "num_channels", "=", "[", "channel", "*", "block", ".", "expansion", "for", "channel", "in", "num_channels", "]", "\n", "self", ".", "transition3", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "\n", "num_channels", ")", "\n", "self", ".", "stage4", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "\n", "self", ".", "stage4_cfg", ",", "num_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.norm1": [[347, 351], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm1", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: the normalization layer named \"norm1\" \"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm1_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.norm2": [[352, 356], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm2", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: the normalization layer named \"norm2\" \"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm2_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_transition_layer": [[357, 402], ["len", "len", "range", "torch.ModuleList", "range", "transition_layers.append", "transition_layers.append", "transition_layers.append", "conv_downsamples.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "mmcv.cnn.build_conv_layer", "torch.ReLU", "mmcv.cnn.build_conv_layer", "torch.ReLU", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer"], "methods", ["None"], ["", "def", "_make_transition_layer", "(", "self", ",", "num_channels_pre_layer", ",", "\n", "num_channels_cur_layer", ")", ":", "\n", "        ", "num_branches_cur", "=", "len", "(", "num_channels_cur_layer", ")", "\n", "num_branches_pre", "=", "len", "(", "num_channels_pre_layer", ")", "\n", "\n", "transition_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_branches_cur", ")", ":", "\n", "            ", "if", "i", "<", "num_branches_pre", ":", "\n", "                ", "if", "num_channels_cur_layer", "[", "i", "]", "!=", "num_channels_pre_layer", "[", "i", "]", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "num_channels_pre_layer", "[", "i", "]", ",", "\n", "num_channels_cur_layer", "[", "i", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "\n", "num_channels_cur_layer", "[", "i", "]", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ")", "\n", "", "else", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "None", ")", "\n", "", "", "else", ":", "\n", "                ", "conv_downsamples", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "i", "+", "1", "-", "num_branches_pre", ")", ":", "\n", "                    ", "in_channels", "=", "num_channels_pre_layer", "[", "-", "1", "]", "\n", "out_channels", "=", "num_channels_cur_layer", "[", "i", "]", "if", "j", "==", "i", "-", "num_branches_pre", "else", "in_channels", "\n", "conv_downsamples", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "out_channels", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ")", "\n", "", "transition_layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv_downsamples", ")", ")", "\n", "\n", "", "", "return", "nn", ".", "ModuleList", "(", "transition_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_layer": [[403, 437], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "mmcv.cnn.build_conv_layer", "block", "mmcv.cnn.build_norm_layer"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "inplanes", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet._make_stage": [[438, 466], ["range", "hr_modules.append", "torch.Sequential", "hrnet.HRModule"], "methods", ["None"], ["", "def", "_make_stage", "(", "self", ",", "layer_config", ",", "in_channels", ",", "multiscale_output", "=", "True", ")", ":", "\n", "        ", "num_modules", "=", "layer_config", "[", "'num_modules'", "]", "\n", "num_branches", "=", "layer_config", "[", "'num_branches'", "]", "\n", "num_blocks", "=", "layer_config", "[", "'num_blocks'", "]", "\n", "num_channels", "=", "layer_config", "[", "'num_channels'", "]", "\n", "block", "=", "self", ".", "blocks_dict", "[", "layer_config", "[", "'block'", "]", "]", "\n", "\n", "hr_modules", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_modules", ")", ":", "\n", "# multi_scale_output is only used for the last module", "\n", "            ", "if", "not", "multiscale_output", "and", "i", "==", "num_modules", "-", "1", ":", "\n", "                ", "reset_multiscale_output", "=", "False", "\n", "", "else", ":", "\n", "                ", "reset_multiscale_output", "=", "True", "\n", "\n", "", "hr_modules", ".", "append", "(", "\n", "HRModule", "(", "\n", "num_branches", ",", "\n", "block", ",", "\n", "num_blocks", ",", "\n", "in_channels", ",", "\n", "num_channels", ",", "\n", "reset_multiscale_output", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "hr_modules", ")", ",", "in_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.init_weights": [[467, 492], ["isinstance", "mmdet.utils.get_root_logger", "mmcv.runner.load_checkpoint", "hrnet.HRNet.modules", "TypeError", "isinstance", "hrnet.HRNet.modules", "mmcv.cnn.kaiming_init", "isinstance", "isinstance", "mmcv.cnn.constant_init", "mmcv.cnn.constant_init", "isinstance", "mmcv.cnn.constant_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in backbone.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "isinstance", "(", "pretrained", ",", "str", ")", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "load_checkpoint", "(", "self", ",", "pretrained", ",", "strict", "=", "False", ",", "logger", "=", "logger", ")", "\n", "", "elif", "pretrained", "is", "None", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "kaiming_init", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "(", "_BatchNorm", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "                    ", "constant_init", "(", "m", ",", "1", ")", "\n", "\n", "", "", "if", "self", ".", "zero_init_residual", ":", "\n", "                ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", ":", "\n", "                        ", "constant_init", "(", "m", ".", "norm3", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock", ")", ":", "\n", "                        ", "constant_init", "(", "m", ".", "norm2", ",", "0", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'pretrained must be a str or None'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.forward": [[493, 528], ["hrnet.HRNet.conv1", "hrnet.HRNet.norm1", "hrnet.HRNet.relu", "hrnet.HRNet.conv2", "hrnet.HRNet.norm2", "hrnet.HRNet.relu", "hrnet.HRNet.layer1", "range", "hrnet.HRNet.stage2", "range", "hrnet.HRNet.stage3", "range", "hrnet.HRNet.stage4", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm2"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "norm2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage2_cfg", "[", "'num_branches'", "]", ")", ":", "\n", "            ", "if", "self", ".", "transition1", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition1", "[", "i", "]", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "x", ")", "\n", "", "", "y_list", "=", "self", ".", "stage2", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage3_cfg", "[", "'num_branches'", "]", ")", ":", "\n", "            ", "if", "self", ".", "transition2", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition2", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage3", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage4_cfg", "[", "'num_branches'", "]", ")", ":", "\n", "            ", "if", "self", ".", "transition3", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition3", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage4", "(", "x_list", ")", "\n", "\n", "return", "y_list", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hrnet.HRNet.train": [[529, 538], ["super().train", "hrnet.HRNet.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Convert the model into training mode whill keeping the normalization\n        layer freezed.\"\"\"", "\n", "super", "(", "HRNet", ",", "self", ")", ".", "train", "(", "mode", ")", "\n", "if", "mode", "and", "self", ".", "norm_eval", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "# trick: eval have effect on BatchNorm only", "\n", "                ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hourglass.HourglassModule.__init__": [[23, 69], ["dict", "torch.Module.__init__", "utils.ResLayer", "utils.ResLayer", "utils.ResLayer", "torch.Upsample", "hourglass.HourglassModule", "utils.ResLayer"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "depth", ",", "\n", "stage_channels", ",", "\n", "stage_blocks", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ")", ":", "\n", "        ", "super", "(", "HourglassModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "depth", "=", "depth", "\n", "\n", "cur_block", "=", "stage_blocks", "[", "0", "]", "\n", "next_block", "=", "stage_blocks", "[", "1", "]", "\n", "\n", "cur_channel", "=", "stage_channels", "[", "0", "]", "\n", "next_channel", "=", "stage_channels", "[", "1", "]", "\n", "\n", "self", ".", "up1", "=", "ResLayer", "(", "\n", "BasicBlock", ",", "cur_channel", ",", "cur_channel", ",", "cur_block", ",", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "self", ".", "low1", "=", "ResLayer", "(", "\n", "BasicBlock", ",", "\n", "cur_channel", ",", "\n", "next_channel", ",", "\n", "cur_block", ",", "\n", "stride", "=", "2", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "if", "self", ".", "depth", ">", "1", ":", "\n", "            ", "self", ".", "low2", "=", "HourglassModule", "(", "depth", "-", "1", ",", "stage_channels", "[", "1", ":", "]", ",", "\n", "stage_blocks", "[", "1", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "low2", "=", "ResLayer", "(", "\n", "BasicBlock", ",", "\n", "next_channel", ",", "\n", "next_channel", ",", "\n", "next_block", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "", "self", ".", "low3", "=", "ResLayer", "(", "\n", "BasicBlock", ",", "\n", "next_channel", ",", "\n", "cur_channel", ",", "\n", "cur_block", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "downsample_first", "=", "False", ")", "\n", "\n", "self", ".", "up2", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hourglass.HourglassModule.forward": [[70, 78], ["hourglass.HourglassModule.up1", "hourglass.HourglassModule.low1", "hourglass.HourglassModule.low2", "hourglass.HourglassModule.low3", "hourglass.HourglassModule.up2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "up1", "=", "self", ".", "up1", "(", "x", ")", "\n", "low1", "=", "self", ".", "low1", "(", "x", ")", "\n", "low2", "=", "self", ".", "low2", "(", "low1", ")", "\n", "low3", "=", "self", ".", "low3", "(", "low2", ")", "\n", "up2", "=", "self", ".", "up2", "(", "low3", ")", "\n", "return", "up1", "+", "up2", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hourglass.HourglassNet.__init__": [[112, 163], ["dict", "torch.Module.__init__", "torch.Sequential", "torch.ModuleList", "utils.ResLayer", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ReLU", "len", "len", "len", "mmcv.cnn.ConvModule", "utils.ResLayer", "hourglass.HourglassModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "downsample_times", "=", "5", ",", "\n", "num_stacks", "=", "2", ",", "\n", "stage_channels", "=", "(", "256", ",", "256", ",", "384", ",", "384", ",", "384", ",", "512", ")", ",", "\n", "stage_blocks", "=", "(", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "4", ")", ",", "\n", "feat_channel", "=", "256", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ")", ":", "\n", "        ", "super", "(", "HourglassNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_stacks", "=", "num_stacks", "\n", "assert", "self", ".", "num_stacks", ">=", "1", "\n", "assert", "len", "(", "stage_channels", ")", "==", "len", "(", "stage_blocks", ")", "\n", "assert", "len", "(", "stage_channels", ")", ">", "downsample_times", "\n", "\n", "cur_channel", "=", "stage_channels", "[", "0", "]", "\n", "\n", "self", ".", "stem", "=", "nn", ".", "Sequential", "(", "\n", "ConvModule", "(", "3", ",", "128", ",", "7", ",", "padding", "=", "3", ",", "stride", "=", "2", ",", "norm_cfg", "=", "norm_cfg", ")", ",", "\n", "ResLayer", "(", "BasicBlock", ",", "128", ",", "256", ",", "1", ",", "stride", "=", "2", ",", "norm_cfg", "=", "norm_cfg", ")", ")", "\n", "\n", "self", ".", "hourglass_modules", "=", "nn", ".", "ModuleList", "(", "[", "\n", "HourglassModule", "(", "downsample_times", ",", "stage_channels", ",", "stage_blocks", ")", "\n", "for", "_", "in", "range", "(", "num_stacks", ")", "\n", "]", ")", "\n", "\n", "self", ".", "inters", "=", "ResLayer", "(", "\n", "BasicBlock", ",", "\n", "cur_channel", ",", "\n", "cur_channel", ",", "\n", "num_stacks", "-", "1", ",", "\n", "norm_cfg", "=", "norm_cfg", ")", "\n", "\n", "self", ".", "conv1x1s", "=", "nn", ".", "ModuleList", "(", "[", "\n", "ConvModule", "(", "\n", "cur_channel", ",", "cur_channel", ",", "1", ",", "norm_cfg", "=", "norm_cfg", ",", "act_cfg", "=", "None", ")", "\n", "for", "_", "in", "range", "(", "num_stacks", "-", "1", ")", "\n", "]", ")", "\n", "\n", "self", ".", "out_convs", "=", "nn", ".", "ModuleList", "(", "[", "\n", "ConvModule", "(", "\n", "cur_channel", ",", "feat_channel", ",", "3", ",", "padding", "=", "1", ",", "norm_cfg", "=", "norm_cfg", ")", "\n", "for", "_", "in", "range", "(", "num_stacks", ")", "\n", "]", ")", "\n", "\n", "self", ".", "remap_convs", "=", "nn", ".", "ModuleList", "(", "[", "\n", "ConvModule", "(", "\n", "feat_channel", ",", "cur_channel", ",", "1", ",", "norm_cfg", "=", "norm_cfg", ",", "act_cfg", "=", "None", ")", "\n", "for", "_", "in", "range", "(", "num_stacks", "-", "1", ")", "\n", "]", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hourglass.HourglassNet.init_weights": [[164, 175], ["None"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Init module weights.\n\n        We do nothing in this function because all modules we used\n        (ConvModule, BasicBlock and etc.) have default initialization, and\n        currently we don't provide pretrained model of HourglassNet.\n\n        Detector's __init__() will call backbone's init_weights() with\n        pretrained as input, so we keep this function.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.hourglass.HourglassNet.forward": [[176, 196], ["hourglass.HourglassNet.stem", "range", "single_hourglass", "out_conv", "out_feats.append", "hourglass.HourglassNet.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "inter_feat", "=", "self", ".", "stem", "(", "x", ")", "\n", "out_feats", "=", "[", "]", "\n", "\n", "for", "ind", "in", "range", "(", "self", ".", "num_stacks", ")", ":", "\n", "            ", "single_hourglass", "=", "self", ".", "hourglass_modules", "[", "ind", "]", "\n", "out_conv", "=", "self", ".", "out_convs", "[", "ind", "]", "\n", "\n", "hourglass_feat", "=", "single_hourglass", "(", "inter_feat", ")", "\n", "out_feat", "=", "out_conv", "(", "hourglass_feat", ")", "\n", "out_feats", ".", "append", "(", "out_feat", ")", "\n", "\n", "if", "ind", "<", "self", ".", "num_stacks", "-", "1", ":", "\n", "                ", "inter_feat", "=", "self", ".", "conv1x1s", "[", "ind", "]", "(", "\n", "inter_feat", ")", "+", "self", ".", "remap_convs", "[", "ind", "]", "(", "\n", "out_feat", ")", "\n", "inter_feat", "=", "self", ".", "inters", "[", "ind", "]", "(", "self", ".", "relu", "(", "inter_feat", ")", ")", "\n", "\n", "", "", "return", "out_feats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.BasicBlock.__init__": [[16, 54], ["dict", "torch.Module.__init__", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "resnet.BasicBlock.add_module", "mmcv.cnn.build_conv_layer", "resnet.BasicBlock.add_module", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "downsample", "=", "None", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "dcn", "is", "None", ",", "'Not implemented yet.'", "\n", "assert", "plugins", "is", "None", ",", "'Not implemented yet.'", "\n", "\n", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "norm_cfg", ",", "planes", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "norm_cfg", ",", "planes", ",", "postfix", "=", "2", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "planes", ",", "planes", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.BasicBlock.norm1": [[55, 59], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm1", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: normalization layer after the first convolution layer\"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm1_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.BasicBlock.norm2": [[60, 64], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm2", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: normalization layer after the second convolution layer\"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm2_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.BasicBlock.forward": [[65, 93], ["resnet.BasicBlock.relu", "resnet.BasicBlock.conv1", "resnet.BasicBlock.norm1", "resnet.BasicBlock.relu", "resnet.BasicBlock.conv2", "resnet.BasicBlock.norm2", "torch.checkpoint", "torch.checkpoint", "resnet.BasicBlock.forward._inner_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm2"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "norm1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.__init__": [[98, 215], ["dict", "torch.Module.__init__", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "resnet.Bottleneck.add_module", "resnet.Bottleneck.add_module", "mmcv.cnn.build_conv_layer", "resnet.Bottleneck.add_module", "torch.ReLU", "torch.ReLU", "isinstance", "isinstance", "all", "dcn.pop", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer", "resnet.Bottleneck.make_block_plugins", "resnet.Bottleneck.make_block_plugins", "resnet.Bottleneck.make_block_plugins"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.make_block_plugins", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.make_block_plugins", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.make_block_plugins"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "downsample", "=", "None", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ":", "\n", "        ", "\"\"\"Bottleneck block for ResNet.\n\n        If style is \"pytorch\", the stride-two layer is the 3x3 conv layer, if\n        it is \"caffe\", the stride-two layer is the first 1x1 conv layer.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "style", "in", "[", "'pytorch'", ",", "'caffe'", "]", "\n", "assert", "dcn", "is", "None", "or", "isinstance", "(", "dcn", ",", "dict", ")", "\n", "assert", "plugins", "is", "None", "or", "isinstance", "(", "plugins", ",", "list", ")", "\n", "if", "plugins", "is", "not", "None", ":", "\n", "            ", "allowed_position", "=", "[", "'after_conv1'", ",", "'after_conv2'", ",", "'after_conv3'", "]", "\n", "assert", "all", "(", "p", "[", "'position'", "]", "in", "allowed_position", "for", "p", "in", "plugins", ")", "\n", "\n", "", "self", ".", "inplanes", "=", "inplanes", "\n", "self", ".", "planes", "=", "planes", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "dcn", "=", "dcn", "\n", "self", ".", "with_dcn", "=", "dcn", "is", "not", "None", "\n", "self", ".", "plugins", "=", "plugins", "\n", "self", ".", "with_plugins", "=", "plugins", "is", "not", "None", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "# collect plugins for conv1/conv2/conv3", "\n", "            ", "self", ".", "after_conv1_plugins", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_conv1'", "\n", "]", "\n", "self", ".", "after_conv2_plugins", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_conv2'", "\n", "]", "\n", "self", ".", "after_conv3_plugins", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_conv3'", "\n", "]", "\n", "\n", "", "if", "self", ".", "style", "==", "'pytorch'", ":", "\n", "            ", "self", ".", "conv1_stride", "=", "1", "\n", "self", ".", "conv2_stride", "=", "stride", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv1_stride", "=", "stride", "\n", "self", ".", "conv2_stride", "=", "1", "\n", "\n", "", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "norm_cfg", ",", "planes", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "norm_cfg", ",", "planes", ",", "postfix", "=", "2", ")", "\n", "self", ".", "norm3_name", ",", "norm3", "=", "build_norm_layer", "(", "\n", "norm_cfg", ",", "planes", "*", "self", ".", "expansion", ",", "postfix", "=", "3", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "self", ".", "conv1_stride", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "fallback_on_stride", "=", "False", "\n", "if", "self", ".", "with_dcn", ":", "\n", "            ", "fallback_on_stride", "=", "dcn", ".", "pop", "(", "'fallback_on_stride'", ",", "False", ")", "\n", "", "if", "not", "self", ".", "with_dcn", "or", "fallback_on_stride", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "planes", ",", "\n", "planes", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "conv_cfg", "is", "None", ",", "'conv_cfg must be None for DCN'", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "dcn", ",", "\n", "planes", ",", "\n", "planes", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "self", ".", "conv3", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "planes", ",", "\n", "planes", "*", "self", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm3_name", ",", "norm3", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "            ", "self", ".", "after_conv1_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", ",", "self", ".", "after_conv1_plugins", ")", "\n", "self", ".", "after_conv2_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", ",", "self", ".", "after_conv2_plugins", ")", "\n", "self", ".", "after_conv3_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", "*", "self", ".", "expansion", ",", "self", ".", "after_conv3_plugins", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.make_block_plugins": [[216, 238], ["isinstance", "plugin.copy.copy.copy", "mmcv.cnn.build_plugin_layer", "resnet.Bottleneck.add_module", "plugin_names.append", "hasattr", "plugin.copy.copy.pop"], "methods", ["None"], ["", "", "def", "make_block_plugins", "(", "self", ",", "in_channels", ",", "plugins", ")", ":", "\n", "        ", "\"\"\"make plugins for block.\n\n        Args:\n            in_channels (int): Input channels of plugin.\n            plugins (list[dict]): List of plugins cfg to build.\n\n        Returns:\n            list[str]: List of the names of plugin.\n        \"\"\"", "\n", "assert", "isinstance", "(", "plugins", ",", "list", ")", "\n", "plugin_names", "=", "[", "]", "\n", "for", "plugin", "in", "plugins", ":", "\n", "            ", "plugin", "=", "plugin", ".", "copy", "(", ")", "\n", "name", ",", "layer", "=", "build_plugin_layer", "(", "\n", "plugin", ",", "\n", "in_channels", "=", "in_channels", ",", "\n", "postfix", "=", "plugin", ".", "pop", "(", "'postfix'", ",", "''", ")", ")", "\n", "assert", "not", "hasattr", "(", "self", ",", "name", ")", ",", "f'duplicate plugin {name}'", "\n", "self", ".", "add_module", "(", "name", ",", "layer", ")", "\n", "plugin_names", ".", "append", "(", "name", ")", "\n", "", "return", "plugin_names", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.forward_plugin": [[239, 244], ["getattr"], "methods", ["None"], ["", "def", "forward_plugin", "(", "self", ",", "x", ",", "plugin_names", ")", ":", "\n", "        ", "out", "=", "x", "\n", "for", "name", "in", "plugin_names", ":", "\n", "            ", "out", "=", "getattr", "(", "self", ",", "name", ")", "(", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm1": [[245, 249], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm1", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: normalization layer after the first convolution layer\"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm1_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm2": [[250, 254], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm2", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: normalization layer after the second convolution layer\"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm2_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm3": [[255, 259], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm3", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: normalization layer after the third convolution layer\"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm3_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.forward": [[260, 301], ["resnet.Bottleneck.relu", "resnet.Bottleneck.conv1", "resnet.Bottleneck.norm1", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv2", "resnet.Bottleneck.norm2", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv3", "resnet.Bottleneck.norm3", "torch.checkpoint", "torch.checkpoint", "resnet.Bottleneck.forward._inner_forward"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm2", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.Bottleneck.norm3"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "norm1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv1_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv2_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm3", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "                ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv3_plugin_names", ")", "\n", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.__init__": [[364, 453], ["dict", "torch.Module.__init__", "resnet.ResNet._make_stem_layer", "enumerate", "resnet.ResNet._freeze_stages", "KeyError", "len", "len", "max", "resnet.ResNet.make_res_layer", "resnet.ResNet.add_module", "resnet.ResNet.res_layers.append", "len", "resnet.ResNet.make_stage_plugins", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet._make_stem_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.make_res_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.make_stage_plugins"], ["def", "__init__", "(", "self", ",", "\n", "depth", ",", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "None", ",", "\n", "base_channels", "=", "64", ",", "\n", "num_stages", "=", "4", ",", "\n", "strides", "=", "(", "1", ",", "2", ",", "2", ",", "2", ")", ",", "\n", "dilations", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "out_indices", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "deep_stem", "=", "False", ",", "\n", "avg_down", "=", "False", ",", "\n", "frozen_stages", "=", "-", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ",", "\n", "norm_eval", "=", "True", ",", "\n", "dcn", "=", "None", ",", "\n", "stage_with_dcn", "=", "(", "False", ",", "False", ",", "False", ",", "False", ")", ",", "\n", "plugins", "=", "None", ",", "\n", "with_cp", "=", "False", ",", "\n", "zero_init_residual", "=", "True", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "depth", "not", "in", "self", ".", "arch_settings", ":", "\n", "            ", "raise", "KeyError", "(", "f'invalid depth {depth} for resnet'", ")", "\n", "", "self", ".", "depth", "=", "depth", "\n", "if", "stem_channels", "is", "None", ":", "\n", "            ", "stem_channels", "=", "base_channels", "\n", "", "self", ".", "stem_channels", "=", "stem_channels", "\n", "self", ".", "base_channels", "=", "base_channels", "\n", "self", ".", "num_stages", "=", "num_stages", "\n", "assert", "num_stages", ">=", "1", "and", "num_stages", "<=", "4", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "dilations", "=", "dilations", "\n", "assert", "len", "(", "strides", ")", "==", "len", "(", "dilations", ")", "==", "num_stages", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "assert", "max", "(", "out_indices", ")", "<", "num_stages", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "deep_stem", "=", "deep_stem", "\n", "self", ".", "avg_down", "=", "avg_down", "\n", "self", ".", "frozen_stages", "=", "frozen_stages", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "norm_eval", "=", "norm_eval", "\n", "self", ".", "dcn", "=", "dcn", "\n", "self", ".", "stage_with_dcn", "=", "stage_with_dcn", "\n", "if", "dcn", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "stage_with_dcn", ")", "==", "num_stages", "\n", "", "self", ".", "plugins", "=", "plugins", "\n", "self", ".", "zero_init_residual", "=", "zero_init_residual", "\n", "self", ".", "block", ",", "stage_blocks", "=", "self", ".", "arch_settings", "[", "depth", "]", "\n", "self", ".", "stage_blocks", "=", "stage_blocks", "[", ":", "num_stages", "]", "\n", "self", ".", "inplanes", "=", "stem_channels", "\n", "\n", "self", ".", "_make_stem_layer", "(", "in_channels", ",", "stem_channels", ")", "\n", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "self", ".", "stage_blocks", ")", ":", "\n", "            ", "stride", "=", "strides", "[", "i", "]", "\n", "dilation", "=", "dilations", "[", "i", "]", "\n", "dcn", "=", "self", ".", "dcn", "if", "self", ".", "stage_with_dcn", "[", "i", "]", "else", "None", "\n", "if", "plugins", "is", "not", "None", ":", "\n", "                ", "stage_plugins", "=", "self", ".", "make_stage_plugins", "(", "plugins", ",", "i", ")", "\n", "", "else", ":", "\n", "                ", "stage_plugins", "=", "None", "\n", "", "planes", "=", "base_channels", "*", "2", "**", "i", "\n", "res_layer", "=", "self", ".", "make_res_layer", "(", "\n", "block", "=", "self", ".", "block", ",", "\n", "inplanes", "=", "self", ".", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "num_blocks", "=", "num_blocks", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "style", "=", "self", ".", "style", ",", "\n", "avg_down", "=", "self", ".", "avg_down", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "plugins", "=", "stage_plugins", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "self", ".", "block", ".", "expansion", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "self", ".", "_freeze_stages", "(", ")", "\n", "\n", "self", ".", "feat_dim", "=", "self", ".", "block", ".", "expansion", "*", "base_channels", "*", "2", "**", "(", "\n", "len", "(", "self", ".", "stage_blocks", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.make_stage_plugins": [[454, 515], ["plugin.copy.copy.copy", "plugin.copy.copy.pop", "stage_plugins.append", "len"], "methods", ["None"], ["", "def", "make_stage_plugins", "(", "self", ",", "plugins", ",", "stage_idx", ")", ":", "\n", "        ", "\"\"\"Make plugins for ResNet ``stage_idx`` th stage.\n\n        Currently we support to insert ``context_block``,\n        ``empirical_attention_block``, ``nonlocal_block`` into the backbone\n        like ResNet/ResNeXt. They could be inserted after conv1/conv2/conv3 of\n        Bottleneck.\n\n        An example of plugins format could be:\n\n        Examples:\n            >>> plugins=[\n            ...     dict(cfg=dict(type='xxx', arg1='xxx'),\n            ...          stages=(False, True, True, True),\n            ...          position='after_conv2'),\n            ...     dict(cfg=dict(type='yyy'),\n            ...          stages=(True, True, True, True),\n            ...          position='after_conv3'),\n            ...     dict(cfg=dict(type='zzz', postfix='1'),\n            ...          stages=(True, True, True, True),\n            ...          position='after_conv3'),\n            ...     dict(cfg=dict(type='zzz', postfix='2'),\n            ...          stages=(True, True, True, True),\n            ...          position='after_conv3')\n            ... ]\n            >>> self = ResNet(depth=18)\n            >>> stage_plugins = self.make_stage_plugins(plugins, 0)\n            >>> assert len(stage_plugins) == 3\n\n        Suppose ``stage_idx=0``, the structure of blocks in the stage would be:\n\n        .. code-block:: none\n\n            conv1-> conv2->conv3->yyy->zzz1->zzz2\n\n        Suppose 'stage_idx=1', the structure of blocks in the stage would be:\n\n        .. code-block:: none\n\n            conv1-> conv2->xxx->conv3->yyy->zzz1->zzz2\n\n        If stages is missing, the plugin would be applied to all stages.\n\n        Args:\n            plugins (list[dict]): List of plugins cfg to build. The postfix is\n                required if multiple same type plugins are inserted.\n            stage_idx (int): Index of stage to build\n\n        Returns:\n            list[dict]: Plugins for current stage\n        \"\"\"", "\n", "stage_plugins", "=", "[", "]", "\n", "for", "plugin", "in", "plugins", ":", "\n", "            ", "plugin", "=", "plugin", ".", "copy", "(", ")", "\n", "stages", "=", "plugin", ".", "pop", "(", "'stages'", ",", "None", ")", "\n", "assert", "stages", "is", "None", "or", "len", "(", "stages", ")", "==", "self", ".", "num_stages", "\n", "# whether to insert plugin into current stage", "\n", "if", "stages", "is", "None", "or", "stages", "[", "stage_idx", "]", ":", "\n", "                ", "stage_plugins", ".", "append", "(", "plugin", ")", "\n", "\n", "", "", "return", "stage_plugins", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.make_res_layer": [[516, 519], ["utils.ResLayer"], "methods", ["None"], ["", "def", "make_res_layer", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Pack all blocks in a stage into a ``ResLayer``.\"\"\"", "\n", "return", "ResLayer", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1": [[520, 524], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm1", "(", "self", ")", ":", "\n", "        ", "\"\"\"nn.Module: the normalization layer named \"norm1\" \"\"\"", "\n", "return", "getattr", "(", "self", ",", "self", ".", "norm1_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._make_stem_layer": [[525, 572], ["torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_norm_layer", "resnet.ResNet.add_module", "torch.ReLU", "torch.ReLU", "mmcv.cnn.build_conv_layer", "torch.ReLU", "torch.ReLU", "mmcv.cnn.build_conv_layer", "torch.ReLU", "torch.ReLU", "mmcv.cnn.build_conv_layer", "torch.ReLU", "torch.ReLU", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer"], "methods", ["None"], ["", "def", "_make_stem_layer", "(", "self", ",", "in_channels", ",", "stem_channels", ")", ":", "\n", "        ", "if", "self", ".", "deep_stem", ":", "\n", "            ", "self", ".", "stem", "=", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "stem_channels", "//", "2", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "stem_channels", "//", "2", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "stem_channels", "//", "2", ",", "\n", "stem_channels", "//", "2", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "stem_channels", "//", "2", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "stem_channels", "//", "2", ",", "\n", "stem_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "self", ".", "norm_cfg", ",", "stem_channels", ")", "[", "1", "]", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "stem_channels", ",", "\n", "kernel_size", "=", "7", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "stem_channels", ",", "postfix", "=", "1", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._freeze_stages": [[573, 590], ["range", "getattr", "getattr.eval", "getattr.parameters", "resnet.ResNet.stem.eval", "resnet.ResNet.stem.parameters", "resnet.ResNet.norm1.eval", "getattr.parameters"], "methods", ["None"], ["", "def", "_freeze_stages", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "frozen_stages", ">=", "0", ":", "\n", "            ", "if", "self", ".", "deep_stem", ":", "\n", "                ", "self", ".", "stem", ".", "eval", "(", ")", "\n", "for", "param", "in", "self", ".", "stem", ".", "parameters", "(", ")", ":", "\n", "                    ", "param", ".", "requires_grad", "=", "False", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "norm1", ".", "eval", "(", ")", "\n", "for", "m", "in", "[", "self", ".", "conv1", ",", "self", ".", "norm1", "]", ":", "\n", "                    ", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                        ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "", "for", "i", "in", "range", "(", "1", ",", "self", ".", "frozen_stages", "+", "1", ")", ":", "\n", "            ", "m", "=", "getattr", "(", "self", ",", "f'layer{i}'", ")", "\n", "m", ".", "eval", "(", ")", "\n", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights": [[591, 622], ["isinstance", "mmdet.utils.get_root_logger", "mmcv.runner.load_checkpoint", "resnet.ResNet.modules", "TypeError", "isinstance", "resnet.ResNet.modules", "resnet.ResNet.modules", "mmcv.cnn.kaiming_init", "isinstance", "isinstance", "mmcv.cnn.constant_init", "isinstance", "hasattr", "mmcv.cnn.constant_init", "mmcv.cnn.constant_init", "isinstance", "mmcv.cnn.constant_init"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger"], ["", "", "", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in backbone.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "if", "isinstance", "(", "pretrained", ",", "str", ")", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "load_checkpoint", "(", "self", ",", "pretrained", ",", "strict", "=", "False", ",", "logger", "=", "logger", ")", "\n", "", "elif", "pretrained", "is", "None", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "kaiming_init", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "(", "_BatchNorm", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "                    ", "constant_init", "(", "m", ",", "1", ")", "\n", "\n", "", "", "if", "self", ".", "dcn", "is", "not", "None", ":", "\n", "                ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", "and", "hasattr", "(", "\n", "m", ".", "conv2", ",", "'conv_offset'", ")", ":", "\n", "                        ", "constant_init", "(", "m", ".", "conv2", ".", "conv_offset", ",", "0", ")", "\n", "\n", "", "", "", "if", "self", ".", "zero_init_residual", ":", "\n", "                ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", ":", "\n", "                        ", "constant_init", "(", "m", ".", "norm3", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock", ")", ":", "\n", "                        ", "constant_init", "(", "m", ".", "norm2", ",", "0", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'pretrained must be a str or None'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.forward": [[623, 639], ["resnet.ResNet.maxpool", "enumerate", "tuple", "resnet.ResNet.stem", "resnet.ResNet.conv1", "resnet.ResNet.norm1", "resnet.ResNet.relu", "getattr", "getattr.", "outs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "if", "self", ".", "deep_stem", ":", "\n", "            ", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "x", "=", "res_layer", "(", "x", ")", "\n", "if", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train": [[640, 650], ["super().train", "resnet.ResNet._freeze_stages", "resnet.ResNet.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._freeze_stages"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Convert the model into training mode while keep normalization layer\n        freezed.\"\"\"", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "train", "(", "mode", ")", "\n", "self", ".", "_freeze_stages", "(", ")", "\n", "if", "mode", "and", "self", ".", "norm_eval", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "# trick: eval have effect on BatchNorm only", "\n", "                ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNetV1d.__init__": [[662, 665], ["resnet.ResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ResNetV1d", ",", "self", ")", ".", "__init__", "(", "\n", "deep_stem", "=", "True", ",", "avg_down", "=", "True", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.Bottleneck.__init__": [[14, 85], ["resnet.Bottleneck.__init__", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_norm_layer", "mmcv.cnn.build_conv_layer", "resnext.Bottleneck.add_module", "resnext.Bottleneck.add_module", "mmcv.cnn.build_conv_layer", "resnext.Bottleneck.add_module", "resnext.Bottleneck.dcn.pop", "mmcv.cnn.build_conv_layer", "mmcv.cnn.build_conv_layer", "math.floor"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "groups", "=", "1", ",", "\n", "base_width", "=", "4", ",", "\n", "base_channels", "=", "64", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Bottleneck block for ResNeXt.\n\n        If style is \"pytorch\", the stride-two layer is the 3x3 conv layer, if\n        it is \"caffe\", the stride-two layer is the first 1x1 conv layer.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", "inplanes", ",", "planes", ",", "**", "kwargs", ")", "\n", "\n", "if", "groups", "==", "1", ":", "\n", "            ", "width", "=", "self", ".", "planes", "\n", "", "else", ":", "\n", "            ", "width", "=", "math", ".", "floor", "(", "self", ".", "planes", "*", "\n", "(", "base_width", "/", "base_channels", ")", ")", "*", "groups", "\n", "\n", "", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "2", ")", "\n", "self", ".", "norm3_name", ",", "norm3", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "self", ".", "planes", "*", "self", ".", "expansion", ",", "postfix", "=", "3", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "self", ".", "inplanes", ",", "\n", "width", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "self", ".", "conv1_stride", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "fallback_on_stride", "=", "False", "\n", "self", ".", "with_modulated_dcn", "=", "False", "\n", "if", "self", ".", "with_dcn", ":", "\n", "            ", "fallback_on_stride", "=", "self", ".", "dcn", ".", "pop", "(", "'fallback_on_stride'", ",", "False", ")", "\n", "", "if", "not", "self", ".", "with_dcn", "or", "fallback_on_stride", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "conv_cfg", "is", "None", ",", "'conv_cfg must be None for DCN'", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "dcn", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "self", ".", "conv3", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "self", ".", "planes", "*", "self", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm3_name", ",", "norm3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.__init__": [[121, 125], ["resnet.ResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "groups", "=", "1", ",", "base_width", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "groups", "=", "groups", "\n", "self", ".", "base_width", "=", "base_width", "\n", "super", "(", "ResNeXt", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.make_res_layer": [[126, 133], ["utils.ResLayer"], "methods", ["None"], ["", "def", "make_res_layer", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Pack all blocks in a stage into a ``ResLayer``\"\"\"", "\n", "return", "ResLayer", "(", "\n", "groups", "=", "self", ".", "groups", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "\n", "base_channels", "=", "self", ".", "base_channels", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.__init__": [[84, 206], ["dict", "resnet.ResNet.__init__", "isinstance", "regnet.RegNet.generate_regnet", "regnet.RegNet.get_stages_from_blocks", "regnet.RegNet.adjust_width_group", "sum", "regnet.RegNet._make_stem_layer", "enumerate", "regnet.RegNet._freeze_stages", "len", "len", "max", "int", "regnet.RegNet.make_res_layer", "regnet.RegNet.add_module", "regnet.RegNet.res_layers.append", "isinstance", "ValueError", "range", "range", "len", "round", "regnet.RegNet.make_stage_plugins", "type"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.generate_regnet", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.get_stages_from_blocks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.adjust_width_group", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet._make_stem_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnext.ResNeXt.make_res_layer", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.make_stage_plugins"], ["def", "__init__", "(", "self", ",", "\n", "arch", ",", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "32", ",", "\n", "base_channels", "=", "32", ",", "\n", "strides", "=", "(", "2", ",", "2", ",", "2", ",", "2", ")", ",", "\n", "dilations", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "out_indices", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "deep_stem", "=", "False", ",", "\n", "avg_down", "=", "False", ",", "\n", "frozen_stages", "=", "-", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ",", "\n", "norm_eval", "=", "True", ",", "\n", "dcn", "=", "None", ",", "\n", "stage_with_dcn", "=", "(", "False", ",", "False", ",", "False", ",", "False", ")", ",", "\n", "plugins", "=", "None", ",", "\n", "with_cp", "=", "False", ",", "\n", "zero_init_residual", "=", "True", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Generate RegNet parameters first", "\n", "if", "isinstance", "(", "arch", ",", "str", ")", ":", "\n", "            ", "assert", "arch", "in", "self", ".", "arch_settings", ",", "f'\"arch\": \"{arch}\" is not one of the'", "' arch_settings'", "\n", "arch", "=", "self", ".", "arch_settings", "[", "arch", "]", "\n", "", "elif", "not", "isinstance", "(", "arch", ",", "dict", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Expect \"arch\" to be either a string '", "\n", "f'or a dict, got {type(arch)}'", ")", "\n", "\n", "", "widths", ",", "num_stages", "=", "self", ".", "generate_regnet", "(", "\n", "arch", "[", "'w0'", "]", ",", "\n", "arch", "[", "'wa'", "]", ",", "\n", "arch", "[", "'wm'", "]", ",", "\n", "arch", "[", "'depth'", "]", ",", "\n", ")", "\n", "# Convert to per stage format", "\n", "stage_widths", ",", "stage_blocks", "=", "self", ".", "get_stages_from_blocks", "(", "widths", ")", "\n", "# Generate group widths and bot muls", "\n", "group_widths", "=", "[", "arch", "[", "'group_w'", "]", "for", "_", "in", "range", "(", "num_stages", ")", "]", "\n", "self", ".", "bottleneck_ratio", "=", "[", "arch", "[", "'bot_mul'", "]", "for", "_", "in", "range", "(", "num_stages", ")", "]", "\n", "# Adjust the compatibility of stage_widths and group_widths", "\n", "stage_widths", ",", "group_widths", "=", "self", ".", "adjust_width_group", "(", "\n", "stage_widths", ",", "self", ".", "bottleneck_ratio", ",", "group_widths", ")", "\n", "\n", "# Group params by stage", "\n", "self", ".", "stage_widths", "=", "stage_widths", "\n", "self", ".", "group_widths", "=", "group_widths", "\n", "self", ".", "depth", "=", "sum", "(", "stage_blocks", ")", "\n", "self", ".", "stem_channels", "=", "stem_channels", "\n", "self", ".", "base_channels", "=", "base_channels", "\n", "self", ".", "num_stages", "=", "num_stages", "\n", "assert", "num_stages", ">=", "1", "and", "num_stages", "<=", "4", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "dilations", "=", "dilations", "\n", "assert", "len", "(", "strides", ")", "==", "len", "(", "dilations", ")", "==", "num_stages", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "assert", "max", "(", "out_indices", ")", "<", "num_stages", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "deep_stem", "=", "deep_stem", "\n", "self", ".", "avg_down", "=", "avg_down", "\n", "self", ".", "frozen_stages", "=", "frozen_stages", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "norm_eval", "=", "norm_eval", "\n", "self", ".", "dcn", "=", "dcn", "\n", "self", ".", "stage_with_dcn", "=", "stage_with_dcn", "\n", "if", "dcn", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "stage_with_dcn", ")", "==", "num_stages", "\n", "", "self", ".", "plugins", "=", "plugins", "\n", "self", ".", "zero_init_residual", "=", "zero_init_residual", "\n", "self", ".", "block", "=", "Bottleneck", "\n", "expansion_bak", "=", "self", ".", "block", ".", "expansion", "\n", "self", ".", "block", ".", "expansion", "=", "1", "\n", "self", ".", "stage_blocks", "=", "stage_blocks", "[", ":", "num_stages", "]", "\n", "\n", "self", ".", "_make_stem_layer", "(", "in_channels", ",", "stem_channels", ")", "\n", "\n", "self", ".", "inplanes", "=", "stem_channels", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "self", ".", "stage_blocks", ")", ":", "\n", "            ", "stride", "=", "self", ".", "strides", "[", "i", "]", "\n", "dilation", "=", "self", ".", "dilations", "[", "i", "]", "\n", "group_width", "=", "self", ".", "group_widths", "[", "i", "]", "\n", "width", "=", "int", "(", "round", "(", "self", ".", "stage_widths", "[", "i", "]", "*", "self", ".", "bottleneck_ratio", "[", "i", "]", ")", ")", "\n", "stage_groups", "=", "width", "//", "group_width", "\n", "\n", "dcn", "=", "self", ".", "dcn", "if", "self", ".", "stage_with_dcn", "[", "i", "]", "else", "None", "\n", "if", "self", ".", "plugins", "is", "not", "None", ":", "\n", "                ", "stage_plugins", "=", "self", ".", "make_stage_plugins", "(", "self", ".", "plugins", ",", "i", ")", "\n", "", "else", ":", "\n", "                ", "stage_plugins", "=", "None", "\n", "\n", "", "res_layer", "=", "self", ".", "make_res_layer", "(", "\n", "block", "=", "self", ".", "block", ",", "\n", "inplanes", "=", "self", ".", "inplanes", ",", "\n", "planes", "=", "self", ".", "stage_widths", "[", "i", "]", ",", "\n", "num_blocks", "=", "num_blocks", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "style", "=", "self", ".", "style", ",", "\n", "avg_down", "=", "self", ".", "avg_down", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "plugins", "=", "stage_plugins", ",", "\n", "groups", "=", "stage_groups", ",", "\n", "base_width", "=", "group_width", ",", "\n", "base_channels", "=", "self", ".", "stage_widths", "[", "i", "]", ")", "\n", "self", ".", "inplanes", "=", "self", ".", "stage_widths", "[", "i", "]", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "self", ".", "_freeze_stages", "(", ")", "\n", "\n", "self", ".", "feat_dim", "=", "stage_widths", "[", "-", "1", "]", "\n", "self", ".", "block", ".", "expansion", "=", "expansion_bak", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet._make_stem_layer": [[207, 220], ["mmcv.cnn.build_conv_layer", "mmcv.cnn.build_norm_layer", "regnet.RegNet.add_module", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_stem_layer", "(", "self", ",", "in_channels", ",", "base_channels", ")", ":", "\n", "        ", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "base_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "base_channels", ",", "postfix", "=", "1", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.generate_regnet": [[221, 252], ["numpy.round", "len", "numpy.power", "numpy.round", "numpy.unique", "widths.astype().tolist", "widths_cont.tolist", "numpy.arange", "numpy.log", "numpy.log", "numpy.divide", "widths.astype"], "methods", ["None"], ["", "def", "generate_regnet", "(", "self", ",", "\n", "initial_width", ",", "\n", "width_slope", ",", "\n", "width_parameter", ",", "\n", "depth", ",", "\n", "divisor", "=", "8", ")", ":", "\n", "        ", "\"\"\"Generates per block width from RegNet parameters.\n\n        Args:\n            initial_width ([int]): Initial width of the backbone\n            width_slope ([float]): Slope of the quantized linear function\n            width_parameter ([int]): Parameter used to quantize the width.\n            depth ([int]): Depth of the backbone.\n            divisor (int, optional): The divisor of channels. Defaults to 8.\n\n        Returns:\n            list, int: return a list of widths of each stage and the number \\\n                of stages\n        \"\"\"", "\n", "assert", "width_slope", ">=", "0", "\n", "assert", "initial_width", ">", "0", "\n", "assert", "width_parameter", ">", "1", "\n", "assert", "initial_width", "%", "divisor", "==", "0", "\n", "widths_cont", "=", "np", ".", "arange", "(", "depth", ")", "*", "width_slope", "+", "initial_width", "\n", "ks", "=", "np", ".", "round", "(", "\n", "np", ".", "log", "(", "widths_cont", "/", "initial_width", ")", "/", "np", ".", "log", "(", "width_parameter", ")", ")", "\n", "widths", "=", "initial_width", "*", "np", ".", "power", "(", "width_parameter", ",", "ks", ")", "\n", "widths", "=", "np", ".", "round", "(", "np", ".", "divide", "(", "widths", ",", "divisor", ")", ")", "*", "divisor", "\n", "num_stages", "=", "len", "(", "np", ".", "unique", "(", "widths", ")", ")", "\n", "widths", ",", "widths_cont", "=", "widths", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", ",", "widths_cont", ".", "tolist", "(", ")", "\n", "return", "widths", ",", "num_stages", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.quantize_float": [[253, 265], ["int", "round"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "quantize_float", "(", "number", ",", "divisor", ")", ":", "\n", "        ", "\"\"\"Converts a float to closest non-zero int divisible by divior.\n\n        Args:\n            number (int): Original number to be quantized.\n            divisor (int): Divisor used to quantize the number.\n\n        Returns:\n            int: quantized number that is divisible by devisor.\n        \"\"\"", "\n", "return", "int", "(", "round", "(", "number", "/", "divisor", ")", "*", "divisor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.adjust_width_group": [[266, 290], ["int", "min", "regnet.RegNet.quantize_float", "int", "zip", "zip", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.quantize_float"], ["", "def", "adjust_width_group", "(", "self", ",", "widths", ",", "bottleneck_ratio", ",", "groups", ")", ":", "\n", "        ", "\"\"\"Adjusts the compatibility of widths and groups.\n\n        Args:\n            widths (list[int]): Width of each stage.\n            bottleneck_ratio (float): Bottleneck ratio.\n            groups (int): number of groups in each stage\n\n        Returns:\n            tuple(list): The adjusted widths and groups of each stage.\n        \"\"\"", "\n", "bottleneck_width", "=", "[", "\n", "int", "(", "w", "*", "b", ")", "for", "w", ",", "b", "in", "zip", "(", "widths", ",", "bottleneck_ratio", ")", "\n", "]", "\n", "groups", "=", "[", "min", "(", "g", ",", "w_bot", ")", "for", "g", ",", "w_bot", "in", "zip", "(", "groups", ",", "bottleneck_width", ")", "]", "\n", "bottleneck_width", "=", "[", "\n", "self", ".", "quantize_float", "(", "w_bot", ",", "g", ")", "\n", "for", "w_bot", ",", "g", "in", "zip", "(", "bottleneck_width", ",", "groups", ")", "\n", "]", "\n", "widths", "=", "[", "\n", "int", "(", "w_bot", "/", "b", ")", "\n", "for", "w_bot", ",", "b", "in", "zip", "(", "bottleneck_width", ",", "bottleneck_ratio", ")", "\n", "]", "\n", "return", "widths", ",", "groups", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.get_stages_from_blocks": [[291, 312], ["numpy.diff().tolist", "zip", "zip", "numpy.diff", "zip", "range", "len"], "methods", ["None"], ["", "def", "get_stages_from_blocks", "(", "self", ",", "widths", ")", ":", "\n", "        ", "\"\"\"Gets widths/stage_blocks of network at each stage.\n\n        Args:\n            widths (list[int]): Width in each stage.\n\n        Returns:\n            tuple(list): width and depth of each stage\n        \"\"\"", "\n", "width_diff", "=", "[", "\n", "width", "!=", "width_prev", "\n", "for", "width", ",", "width_prev", "in", "zip", "(", "widths", "+", "[", "0", "]", ",", "[", "0", "]", "+", "widths", ")", "\n", "]", "\n", "stage_widths", "=", "[", "\n", "width", "for", "width", ",", "diff", "in", "zip", "(", "widths", ",", "width_diff", "[", ":", "-", "1", "]", ")", "if", "diff", "\n", "]", "\n", "stage_blocks", "=", "np", ".", "diff", "(", "[", "\n", "depth", "for", "depth", ",", "diff", "in", "zip", "(", "range", "(", "len", "(", "width_diff", ")", ")", ",", "width_diff", ")", "\n", "if", "diff", "\n", "]", ")", ".", "tolist", "(", ")", "\n", "return", "stage_widths", ",", "stage_blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.regnet.RegNet.forward": [[313, 326], ["regnet.RegNet.conv1", "regnet.RegNet.norm1", "regnet.RegNet.relu", "enumerate", "tuple", "getattr", "getattr.", "outs.append"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.norm1"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "x", "=", "res_layer", "(", "x", ")", "\n", "if", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.QualityFocalLoss.__init__": [[92, 103], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "beta", "=", "2.0", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "QualityFocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "use_sigmoid", "is", "True", ",", "'Only sigmoid in QFL supported now.'", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.QualityFocalLoss.forward": [[104, 140], ["gfocal_loss.quality_focal_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.quality_focal_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): Predicted joint representation of\n                classification and quality (IoU) estimation with shape (N, C),\n                C is the number of classes.\n            target (tuple([torch.Tensor])): Target category label with shape\n                (N,) and target quality label with shape (N,).\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "self", ".", "use_sigmoid", ":", "\n", "            ", "loss_cls", "=", "self", ".", "loss_weight", "*", "quality_focal_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "loss_cls", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.DistributionFocalLoss.__init__": [[153, 157], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "DistributionFocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.DistributionFocalLoss.forward": [[158, 186], ["gfocal_loss.distribution_focal_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.distribution_focal_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): Predicted general distribution of bounding\n                boxes (before softmax) with shape (N, n+1), n is the max value\n                of the integral set `{0, ..., n}` in paper.\n            target (torch.Tensor): Target distance label for bounding boxes\n                with shape (N,).\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_cls", "=", "self", ".", "loss_weight", "*", "distribution_focal_loss", "(", "\n", "pred", ",", "target", ",", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "return", "loss_cls", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.quality_focal_loss": [[8, 50], ["pred.sigmoid", "scale_factor.new_zeros", "pred.size", "label[].long", "loss.sum.sum", "len", "torch.binary_cross_entropy_with_logits", "scale_factor.pow", "torch.binary_cross_entropy_with_logits", "scale_factor.abs().pow", "scale_factor.abs"], "function", ["None"], ["@", "weighted_loss", "\n", "def", "quality_focal_loss", "(", "pred", ",", "target", ",", "beta", "=", "2.0", ")", ":", "\n", "    ", "r\"\"\"Quality Focal Loss (QFL) is from `Generalized Focal Loss: Learning\n    Qualified and Distributed Bounding Boxes for Dense Object Detection\n    <https://arxiv.org/abs/2006.04388>`_.\n\n    Args:\n        pred (torch.Tensor): Predicted joint representation of classification\n            and quality (IoU) estimation with shape (N, C), C is the number of\n            classes.\n        target (tuple([torch.Tensor])): Target category label with shape (N,)\n            and target quality label with shape (N,).\n        beta (float): The beta parameter for calculating the modulating factor.\n            Defaults to 2.0.\n\n    Returns:\n        torch.Tensor: Loss tensor with shape (N,).\n    \"\"\"", "\n", "assert", "len", "(", "target", ")", "==", "2", ",", "\"\"\"target for QFL must be a tuple of two elements,\n        including category label and quality label, respectively\"\"\"", "\n", "# label denotes the category id, score denotes the quality score", "\n", "label", ",", "score", "=", "target", "\n", "\n", "# negatives are supervised by 0 quality score", "\n", "pred_sigmoid", "=", "pred", ".", "sigmoid", "(", ")", "\n", "scale_factor", "=", "pred_sigmoid", "\n", "zerolabel", "=", "scale_factor", ".", "new_zeros", "(", "pred", ".", "shape", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "zerolabel", ",", "reduction", "=", "'none'", ")", "*", "scale_factor", ".", "pow", "(", "beta", ")", "\n", "\n", "# FG cat_id: [0, num_classes -1], BG cat_id: num_classes", "\n", "bg_class_ind", "=", "pred", ".", "size", "(", "1", ")", "\n", "pos", "=", "(", "(", "label", ">=", "0", ")", "&", "(", "label", "<", "bg_class_ind", ")", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "pos_label", "=", "label", "[", "pos", "]", ".", "long", "(", ")", "\n", "# positives are supervised by bbox quality (IoU) score", "\n", "scale_factor", "=", "score", "[", "pos", "]", "-", "pred_sigmoid", "[", "pos", ",", "pos_label", "]", "\n", "loss", "[", "pos", ",", "pos_label", "]", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", "[", "pos", ",", "pos_label", "]", ",", "score", "[", "pos", "]", ",", "\n", "reduction", "=", "'none'", ")", "*", "scale_factor", ".", "abs", "(", ")", ".", "pow", "(", "beta", ")", "\n", "\n", "loss", "=", "loss", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gfocal_loss.distribution_focal_loss": [[52, 75], ["label.long", "dis_right.float", "label.long.float", "torch.cross_entropy", "torch.cross_entropy"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy"], ["", "@", "weighted_loss", "\n", "def", "distribution_focal_loss", "(", "pred", ",", "label", ")", ":", "\n", "    ", "r\"\"\"Distribution Focal Loss (DFL) is from `Generalized Focal Loss: Learning\n    Qualified and Distributed Bounding Boxes for Dense Object Detection\n    <https://arxiv.org/abs/2006.04388>`_.\n\n    Args:\n        pred (torch.Tensor): Predicted general distribution of bounding boxes\n            (before softmax) with shape (N, n+1), n is the max value of the\n            integral set `{0, ..., n}` in paper.\n        label (torch.Tensor): Target distance label for bounding boxes with\n            shape (N,).\n\n    Returns:\n        torch.Tensor: Loss tensor with shape (N,).\n    \"\"\"", "\n", "dis_left", "=", "label", ".", "long", "(", ")", "\n", "dis_right", "=", "dis_left", "+", "1", "\n", "weight_left", "=", "dis_right", ".", "float", "(", ")", "-", "label", "\n", "weight_right", "=", "label", "-", "dis_left", ".", "float", "(", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "pred", ",", "dis_left", ",", "reduction", "=", "'none'", ")", "*", "weight_left", "+", "F", ".", "cross_entropy", "(", "pred", ",", "dis_right", ",", "reduction", "=", "'none'", ")", "*", "weight_right", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.balanced_l1_loss.BalancedL1Loss.__init__": [[68, 80], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "alpha", "=", "0.5", ",", "\n", "gamma", "=", "1.5", ",", "\n", "beta", "=", "1.0", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "BalancedL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.balanced_l1_loss.BalancedL1Loss.forward": [[81, 119], ["balanced_l1_loss.balanced_l1_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.balanced_l1_loss.balanced_l1_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function of loss.\n\n        Args:\n            pred (torch.Tensor): The prediction with shape (N, 4).\n            target (torch.Tensor): The learning target of the prediction with\n                shape (N, 4).\n            weight (torch.Tensor, optional): Sample-wise loss weight with\n                shape (N, ).\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Options are \"none\", \"mean\" and \"sum\".\n\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_bbox", "=", "self", ".", "loss_weight", "*", "balanced_l1_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "alpha", "=", "self", ".", "alpha", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss_bbox", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.balanced_l1_loss.balanced_l1_loss": [[9, 48], ["torch.abs", "torch.abs", "torch.where", "torch.where", "pred.size", "target.size", "target.numel", "torch.log", "torch.log"], "function", ["None"], ["@", "weighted_loss", "\n", "def", "balanced_l1_loss", "(", "pred", ",", "\n", "target", ",", "\n", "beta", "=", "1.0", ",", "\n", "alpha", "=", "0.5", ",", "\n", "gamma", "=", "1.5", ",", "\n", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "\"\"\"Calculate balanced L1 loss.\n\n    Please see the `Libra R-CNN <https://arxiv.org/pdf/1904.02701.pdf>`_\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, 4).\n        target (torch.Tensor): The learning target of the prediction with\n            shape (N, 4).\n        beta (float): The loss is a piecewise function of prediction and target\n            and ``beta`` serves as a threshold for the difference between the\n            prediction and target. Defaults to 1.0.\n        alpha (float): The denominator ``alpha`` in the balanced L1 loss.\n            Defaults to 0.5.\n        gamma (float): The ``gamma`` in the balanced L1 loss.\n            Defaults to 1.5.\n        reduction (str, optional): The method that reduces the loss to a\n            scalar. Options are \"none\", \"mean\" and \"sum\".\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "assert", "beta", ">", "0", "\n", "assert", "pred", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", "and", "target", ".", "numel", "(", ")", ">", "0", "\n", "\n", "diff", "=", "torch", ".", "abs", "(", "pred", "-", "target", ")", "\n", "b", "=", "np", ".", "e", "**", "(", "gamma", "/", "alpha", ")", "-", "1", "\n", "loss", "=", "torch", ".", "where", "(", "\n", "diff", "<", "beta", ",", "alpha", "/", "b", "*", "\n", "(", "b", "*", "diff", "+", "1", ")", "*", "torch", ".", "log", "(", "b", "*", "diff", "/", "beta", "+", "1", ")", "-", "alpha", "*", "diff", ",", "\n", "gamma", "*", "diff", "+", "gamma", "/", "b", "-", "alpha", "*", "beta", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.mse_loss.MSELoss.__init__": [[24, 28], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.mse_loss.MSELoss.forward": [[29, 50], ["mse_loss.mse_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.mse_loss.mse_loss"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ",", "avg_factor", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function of loss.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): Weight of the loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "loss", "=", "self", ".", "loss_weight", "*", "mse_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "reduction", "=", "self", ".", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.mse_loss.mse_loss": [[8, 12], ["torch.mse_loss"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.mse_loss.mse_loss"], ["@", "weighted_loss", "\n", "def", "mse_loss", "(", "pred", ",", "target", ")", ":", "\n", "    ", "\"\"\"Warpper of mse loss.\"\"\"", "\n", "return", "F", ".", "mse_loss", "(", "pred", ",", "target", ",", "reduction", "=", "'none'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gaussian_focal_loss.GaussianFocalLoss.__init__": [[47, 57], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "alpha", "=", "2.0", ",", "\n", "gamma", "=", "4.0", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GaussianFocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gaussian_focal_loss.GaussianFocalLoss.forward": [[58, 90], ["gaussian_focal_loss.gaussian_focal_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gaussian_focal_loss.gaussian_focal_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction\n                in gaussian distribution.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_reg", "=", "self", ".", "loss_weight", "*", "gaussian_focal_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "alpha", "=", "self", ".", "alpha", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ")", "\n", "return", "loss_reg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.gaussian_focal_loss.gaussian_focal_loss": [[7, 27], ["gaussian_target.eq", "pred.pow"], "function", ["None"], ["@", "weighted_loss", "\n", "def", "gaussian_focal_loss", "(", "pred", ",", "gaussian_target", ",", "alpha", "=", "2.0", ",", "gamma", "=", "4.0", ")", ":", "\n", "    ", "\"\"\"`Focal Loss <https://arxiv.org/abs/1708.02002>`_ for targets in gaussian\n    distribution.\n\n    Args:\n        pred (torch.Tensor): The prediction.\n        gaussian_target (torch.Tensor): The learning target of the prediction\n            in gaussian distribution.\n        alpha (float, optional): A balanced form for Focal Loss.\n            Defaults to 2.0.\n        gamma (float, optional): The gamma for calculating the modulating\n            factor. Defaults to 4.0.\n    \"\"\"", "\n", "eps", "=", "1e-12", "\n", "pos_weights", "=", "gaussian_target", ".", "eq", "(", "1", ")", "\n", "neg_weights", "=", "(", "1", "-", "gaussian_target", ")", ".", "pow", "(", "gamma", ")", "\n", "pos_loss", "=", "-", "(", "pred", "+", "eps", ")", ".", "log", "(", ")", "*", "(", "1", "-", "pred", ")", ".", "pow", "(", "alpha", ")", "*", "pos_weights", "\n", "neg_loss", "=", "-", "(", "1", "-", "pred", "+", "eps", ")", ".", "log", "(", ")", "*", "pred", ".", "pow", "(", "alpha", ")", "*", "neg_weights", "\n", "return", "pos_loss", "+", "neg_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.IoULoss.__init__": [[244, 249], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "IoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.IoULoss.forward": [[250, 291], ["weight.mean.mean.mean", "iou_loss.iou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.iou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None. Options are \"none\", \"mean\" and \"sum\".\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "(", "weight", "is", "not", "None", ")", "and", "(", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ")", "and", "(", "\n", "reduction", "!=", "'none'", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# iou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "iou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.BoundedIoULoss.__init__": [[296, 302], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "beta", "=", "0.2", ",", "eps", "=", "1e-3", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "BoundedIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.BoundedIoULoss.forward": [[303, 325], ["iou_loss.bounded_iou_loss", "torch.any", "torch.any", "torch.any", "torch.any"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.bounded_iou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss", "=", "self", ".", "loss_weight", "*", "bounded_iou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.GIoULoss.__init__": [[330, 335], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.GIoULoss.forward": [[336, 363], ["weight.mean.mean.mean", "iou_loss.giou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.giou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# giou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "giou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.DIoULoss.__init__": [[368, 373], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "DIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.DIoULoss.forward": [[374, 401], ["weight.mean.mean.mean", "iou_loss.diou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.diou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# giou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "diou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.CIoULoss.__init__": [[406, 411], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "CIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.CIoULoss.forward": [[412, 439], ["weight.mean.mean.mean", "iou_loss.ciou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.ciou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# giou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "ciou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.iou_loss": [[11, 30], ["mmdet.core.bbox_overlaps().clamp", "bbox_overlaps().clamp.log", "mmdet.core.bbox_overlaps"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["@", "weighted_loss", "\n", "def", "iou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"IoU loss.\n\n    Computing the IoU loss between a set of predicted bboxes and target bboxes.\n    The loss is calculated as negative log of IoU.\n\n    Args:\n        pred (torch.Tensor): Predicted bboxes of format (x1, y1, x2, y2),\n            shape (n, 4).\n        target (torch.Tensor): Corresponding gt bboxes, shape (n, 4).\n        eps (float): Eps to avoid log(0).\n\n    Return:\n        torch.Tensor: Loss tensor.\n    \"\"\"", "\n", "ious", "=", "bbox_overlaps", "(", "pred", ",", "target", ",", "is_aligned", "=", "True", ")", ".", "clamp", "(", "min", "=", "eps", ")", "\n", "loss", "=", "-", "ious", ".", "log", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.bounded_iou_loss": [[32, 75], ["torch.stack().view", "torch.stack().view", "torch.where", "torch.where", "torch.no_grad", "torch.no_grad", "torch.max", "torch.max", "torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "loss_dx.size", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.stack", "torch.stack", "dx.abs", "dy.abs", "dx.abs", "dy.abs"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "bounded_iou_loss", "(", "pred", ",", "target", ",", "beta", "=", "0.2", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"BIoULoss.\n\n    This is an implementation of paper\n    `Improving Object Localization with Fitness NMS and Bounded IoU Loss.\n    <https://arxiv.org/abs/1711.00164>`_.\n\n    Args:\n        pred (torch.Tensor): Predicted bboxes.\n        target (torch.Tensor): Target bboxes.\n        beta (float): beta parameter in smoothl1.\n        eps (float): eps to avoid NaN.\n    \"\"\"", "\n", "pred_ctrx", "=", "(", "pred", "[", ":", ",", "0", "]", "+", "pred", "[", ":", ",", "2", "]", ")", "*", "0.5", "\n", "pred_ctry", "=", "(", "pred", "[", ":", ",", "1", "]", "+", "pred", "[", ":", ",", "3", "]", ")", "*", "0.5", "\n", "pred_w", "=", "pred", "[", ":", ",", "2", "]", "-", "pred", "[", ":", ",", "0", "]", "\n", "pred_h", "=", "pred", "[", ":", ",", "3", "]", "-", "pred", "[", ":", ",", "1", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "target_ctrx", "=", "(", "target", "[", ":", ",", "0", "]", "+", "target", "[", ":", ",", "2", "]", ")", "*", "0.5", "\n", "target_ctry", "=", "(", "target", "[", ":", ",", "1", "]", "+", "target", "[", ":", ",", "3", "]", ")", "*", "0.5", "\n", "target_w", "=", "target", "[", ":", ",", "2", "]", "-", "target", "[", ":", ",", "0", "]", "\n", "target_h", "=", "target", "[", ":", ",", "3", "]", "-", "target", "[", ":", ",", "1", "]", "\n", "\n", "", "dx", "=", "target_ctrx", "-", "pred_ctrx", "\n", "dy", "=", "target_ctry", "-", "pred_ctry", "\n", "\n", "loss_dx", "=", "1", "-", "torch", ".", "max", "(", "\n", "(", "target_w", "-", "2", "*", "dx", ".", "abs", "(", ")", ")", "/", "\n", "(", "target_w", "+", "2", "*", "dx", ".", "abs", "(", ")", "+", "eps", ")", ",", "torch", ".", "zeros_like", "(", "dx", ")", ")", "\n", "loss_dy", "=", "1", "-", "torch", ".", "max", "(", "\n", "(", "target_h", "-", "2", "*", "dy", ".", "abs", "(", ")", ")", "/", "\n", "(", "target_h", "+", "2", "*", "dy", ".", "abs", "(", ")", "+", "eps", ")", ",", "torch", ".", "zeros_like", "(", "dy", ")", ")", "\n", "loss_dw", "=", "1", "-", "torch", ".", "min", "(", "target_w", "/", "(", "pred_w", "+", "eps", ")", ",", "pred_w", "/", "\n", "(", "target_w", "+", "eps", ")", ")", "\n", "loss_dh", "=", "1", "-", "torch", ".", "min", "(", "target_h", "/", "(", "pred_h", "+", "eps", ")", ",", "pred_h", "/", "\n", "(", "target_h", "+", "eps", ")", ")", "\n", "loss_comb", "=", "torch", ".", "stack", "(", "[", "loss_dx", ",", "loss_dy", ",", "loss_dw", ",", "loss_dh", "]", ",", "\n", "dim", "=", "-", "1", ")", ".", "view", "(", "loss_dx", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n", "loss", "=", "torch", ".", "where", "(", "loss_comb", "<", "beta", ",", "0.5", "*", "loss_comb", "*", "loss_comb", "/", "beta", ",", "\n", "loss_comb", "-", "0.5", "*", "beta", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.giou_loss": [[77, 115], ["torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "giou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-7", ")", ":", "\n", "    ", "r\"\"\"`Generalized Intersection over Union: A Metric and A Loss for Bounding\n    Box Regression <https://arxiv.org/abs/1902.09630>`_.\n\n    Args:\n        pred (torch.Tensor): Predicted bboxes of format (x1, y1, x2, y2),\n            shape (n, 4).\n        target (torch.Tensor): Corresponding gt bboxes, shape (n, 4).\n        eps (float): Eps to avoid log(0).\n\n    Return:\n        Tensor: Loss tensor.\n    \"\"\"", "\n", "# overlap", "\n", "lt", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "rb", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "overlap", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "\n", "\n", "# union", "\n", "ap", "=", "(", "pred", "[", ":", ",", "2", "]", "-", "pred", "[", ":", ",", "0", "]", ")", "*", "(", "pred", "[", ":", ",", "3", "]", "-", "pred", "[", ":", ",", "1", "]", ")", "\n", "ag", "=", "(", "target", "[", ":", ",", "2", "]", "-", "target", "[", ":", ",", "0", "]", ")", "*", "(", "target", "[", ":", ",", "3", "]", "-", "target", "[", ":", ",", "1", "]", ")", "\n", "union", "=", "ap", "+", "ag", "-", "overlap", "+", "eps", "\n", "\n", "# IoU", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "# enclose area", "\n", "enclose_x1y1", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "enclose_x2y2", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "enclose_wh", "=", "(", "enclose_x2y2", "-", "enclose_x1y1", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "enclose_area", "=", "enclose_wh", "[", ":", ",", "0", "]", "*", "enclose_wh", "[", ":", ",", "1", "]", "+", "eps", "\n", "\n", "# GIoU", "\n", "gious", "=", "ious", "-", "(", "enclose_area", "-", "union", ")", "/", "enclose_area", "\n", "loss", "=", "1", "-", "gious", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.diou_loss": [[117, 169], ["torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "diou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-7", ")", ":", "\n", "    ", "r\"\"\"`Implementation of Distance-IoU Loss: Faster and Better\n    Learning for Bounding Box Regression, https://arxiv.org/abs/1911.08287`_.\n\n    Code is modified from https://github.com/Zzh-tju/DIoU.\n\n    Args:\n        pred (Tensor): Predicted bboxes of format (x1, y1, x2, y2),\n            shape (n, 4).\n        target (Tensor): Corresponding gt bboxes, shape (n, 4).\n        eps (float): Eps to avoid log(0).\n    Return:\n        Tensor: Loss tensor.\n    \"\"\"", "\n", "# overlap", "\n", "lt", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "rb", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "overlap", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "\n", "\n", "# union", "\n", "ap", "=", "(", "pred", "[", ":", ",", "2", "]", "-", "pred", "[", ":", ",", "0", "]", ")", "*", "(", "pred", "[", ":", ",", "3", "]", "-", "pred", "[", ":", ",", "1", "]", ")", "\n", "ag", "=", "(", "target", "[", ":", ",", "2", "]", "-", "target", "[", ":", ",", "0", "]", ")", "*", "(", "target", "[", ":", ",", "3", "]", "-", "target", "[", ":", ",", "1", "]", ")", "\n", "union", "=", "ap", "+", "ag", "-", "overlap", "+", "eps", "\n", "\n", "# IoU", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "# enclose area", "\n", "enclose_x1y1", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "enclose_x2y2", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "enclose_wh", "=", "(", "enclose_x2y2", "-", "enclose_x1y1", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "\n", "cw", "=", "enclose_wh", "[", ":", ",", "0", "]", "\n", "ch", "=", "enclose_wh", "[", ":", ",", "1", "]", "\n", "\n", "c2", "=", "cw", "**", "2", "+", "ch", "**", "2", "+", "eps", "\n", "\n", "b1_x1", ",", "b1_y1", "=", "pred", "[", ":", ",", "0", "]", ",", "pred", "[", ":", ",", "1", "]", "\n", "b1_x2", ",", "b1_y2", "=", "pred", "[", ":", ",", "2", "]", ",", "pred", "[", ":", ",", "3", "]", "\n", "b2_x1", ",", "b2_y1", "=", "target", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "1", "]", "\n", "b2_x2", ",", "b2_y2", "=", "target", "[", ":", ",", "2", "]", ",", "target", "[", ":", ",", "3", "]", "\n", "\n", "left", "=", "(", "(", "b2_x1", "+", "b2_x2", ")", "-", "(", "b1_x1", "+", "b1_x2", ")", ")", "**", "2", "/", "4", "\n", "right", "=", "(", "(", "b2_y1", "+", "b2_y2", ")", "-", "(", "b1_y1", "+", "b1_y2", ")", ")", "**", "2", "/", "4", "\n", "rho2", "=", "left", "+", "right", "\n", "\n", "# DIoU", "\n", "dious", "=", "ious", "-", "rho2", "/", "c2", "\n", "loss", "=", "1", "-", "dious", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.iou_loss.ciou_loss": [[171, 230], ["torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.pow", "torch.pow", "torch.atan", "torch.atan", "torch.atan", "torch.atan"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "ciou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-7", ")", ":", "\n", "    ", "r\"\"\"`Implementation of paper `Enhancing Geometric Factors into\n    Model Learning and Inference for Object Detection and Instance\n    Segmentation <https://arxiv.org/abs/2005.03572>`_.\n\n    Code is modified from https://github.com/Zzh-tju/CIoU.\n\n    Args:\n        pred (Tensor): Predicted bboxes of format (x1, y1, x2, y2),\n            shape (n, 4).\n        target (Tensor): Corresponding gt bboxes, shape (n, 4).\n        eps (float): Eps to avoid log(0).\n    Return:\n        Tensor: Loss tensor.\n    \"\"\"", "\n", "# overlap", "\n", "lt", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "rb", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "overlap", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "\n", "\n", "# union", "\n", "ap", "=", "(", "pred", "[", ":", ",", "2", "]", "-", "pred", "[", ":", ",", "0", "]", ")", "*", "(", "pred", "[", ":", ",", "3", "]", "-", "pred", "[", ":", ",", "1", "]", ")", "\n", "ag", "=", "(", "target", "[", ":", ",", "2", "]", "-", "target", "[", ":", ",", "0", "]", ")", "*", "(", "target", "[", ":", ",", "3", "]", "-", "target", "[", ":", ",", "1", "]", ")", "\n", "union", "=", "ap", "+", "ag", "-", "overlap", "+", "eps", "\n", "\n", "# IoU", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "# enclose area", "\n", "enclose_x1y1", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", ":", "2", "]", ",", "target", "[", ":", ",", ":", "2", "]", ")", "\n", "enclose_x2y2", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "2", ":", "]", ",", "target", "[", ":", ",", "2", ":", "]", ")", "\n", "enclose_wh", "=", "(", "enclose_x2y2", "-", "enclose_x1y1", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "\n", "cw", "=", "enclose_wh", "[", ":", ",", "0", "]", "\n", "ch", "=", "enclose_wh", "[", ":", ",", "1", "]", "\n", "\n", "c2", "=", "cw", "**", "2", "+", "ch", "**", "2", "+", "eps", "\n", "\n", "b1_x1", ",", "b1_y1", "=", "pred", "[", ":", ",", "0", "]", ",", "pred", "[", ":", ",", "1", "]", "\n", "b1_x2", ",", "b1_y2", "=", "pred", "[", ":", ",", "2", "]", ",", "pred", "[", ":", ",", "3", "]", "\n", "b2_x1", ",", "b2_y1", "=", "target", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "1", "]", "\n", "b2_x2", ",", "b2_y2", "=", "target", "[", ":", ",", "2", "]", ",", "target", "[", ":", ",", "3", "]", "\n", "\n", "w1", ",", "h1", "=", "b1_x2", "-", "b1_x1", ",", "b1_y2", "-", "b1_y1", "+", "eps", "\n", "w2", ",", "h2", "=", "b2_x2", "-", "b2_x1", ",", "b2_y2", "-", "b2_y1", "+", "eps", "\n", "\n", "left", "=", "(", "(", "b2_x1", "+", "b2_x2", ")", "-", "(", "b1_x1", "+", "b1_x2", ")", ")", "**", "2", "/", "4", "\n", "right", "=", "(", "(", "b2_y1", "+", "b2_y2", ")", "-", "(", "b1_y1", "+", "b1_y2", ")", ")", "**", "2", "/", "4", "\n", "rho2", "=", "left", "+", "right", "\n", "\n", "factor", "=", "4", "/", "math", ".", "pi", "**", "2", "\n", "v", "=", "factor", "*", "torch", ".", "pow", "(", "torch", ".", "atan", "(", "w2", "/", "h2", ")", "-", "torch", ".", "atan", "(", "w1", "/", "h1", ")", ",", "2", ")", "\n", "\n", "# CIoU", "\n", "cious", "=", "ious", "-", "(", "rho2", "/", "c2", "+", "v", "**", "2", "/", "(", "1", "-", "ious", "+", "v", ")", ")", "\n", "loss", "=", "1", "-", "cious", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.FocalLoss.__init__": [[92, 119], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"`Focal Loss <https://arxiv.org/abs/1708.02002>`_\n\n        Args:\n            use_sigmoid (bool, optional): Whether to the prediction is\n                used for sigmoid or softmax. Defaults to True.\n            gamma (float, optional): The gamma for calculating the modulating\n                factor. Defaults to 2.0.\n            alpha (float, optional): A balanced form for Focal Loss.\n                Defaults to 0.25.\n            reduction (str, optional): The method used to reduce the loss into\n                a scalar. Defaults to 'mean'. Options are \"none\", \"mean\" and\n                \"sum\".\n            loss_weight (float, optional): Weight of loss. Defaults to 1.0.\n        \"\"\"", "\n", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "use_sigmoid", "is", "True", ",", "'Only sigmoid focal loss supported now.'", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.FocalLoss.forward": [[120, 157], ["mmcv.ops.sigmoid_focal_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.sigmoid_focal_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning label of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Options are \"none\", \"mean\" and \"sum\".\n\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "self", ".", "use_sigmoid", ":", "\n", "            ", "loss_cls", "=", "self", ".", "loss_weight", "*", "sigmoid_focal_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "alpha", "=", "self", ".", "alpha", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "loss_cls", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.py_sigmoid_focal_loss": [[10, 42], ["pred.sigmoid", "target.type_as.type_as", "utils.weight_reduce_loss", "pt.pow", "torch.binary_cross_entropy_with_logits"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss"], ["def", "py_sigmoid_focal_loss", "(", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ")", ":", "\n", "    ", "\"\"\"PyTorch version of `Focal Loss <https://arxiv.org/abs/1708.02002>`_.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the\n            number of classes\n        target (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        gamma (float, optional): The gamma for calculating the modulating\n            factor. Defaults to 2.0.\n        alpha (float, optional): A balanced form for Focal Loss.\n            Defaults to 0.25.\n        reduction (str, optional): The method used to reduce the loss into\n            a scalar. Defaults to 'mean'.\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n    \"\"\"", "\n", "pred_sigmoid", "=", "pred", ".", "sigmoid", "(", ")", "\n", "target", "=", "target", ".", "type_as", "(", "pred", ")", "\n", "pt", "=", "(", "1", "-", "pred_sigmoid", ")", "*", "target", "+", "pred_sigmoid", "*", "(", "1", "-", "target", ")", "\n", "focal_weight", "=", "(", "alpha", "*", "target", "+", "(", "1", "-", "alpha", ")", "*", "\n", "(", "1", "-", "target", ")", ")", "*", "pt", ".", "pow", "(", "gamma", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "target", ",", "reduction", "=", "'none'", ")", "*", "focal_weight", "\n", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ",", "avg_factor", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.sigmoid_focal_loss": [[44, 87], ["mmcv.ops.sigmoid_focal_loss", "utils.weight_reduce_loss", "weight.view.size", "utils.weight_reduce_loss.size", "weight.view.view", "weight.view.view", "weight.view.numel", "utils.weight_reduce_loss.numel", "utils.weight_reduce_loss.size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.focal_loss.sigmoid_focal_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss"], ["", "def", "sigmoid_focal_loss", "(", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ")", ":", "\n", "    ", "r\"\"\"A warpper of cuda version `Focal Loss\n    <https://arxiv.org/abs/1708.02002>`_.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the number\n            of classes.\n        target (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        gamma (float, optional): The gamma for calculating the modulating\n            factor. Defaults to 2.0.\n        alpha (float, optional): A balanced form for Focal Loss.\n            Defaults to 0.25.\n        reduction (str, optional): The method used to reduce the loss into\n            a scalar. Defaults to 'mean'. Options are \"none\", \"mean\" and \"sum\".\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n    \"\"\"", "\n", "# Function.apply does not accept keyword arguments, so the decorator", "\n", "# \"weighted_loss\" is not applicable", "\n", "loss", "=", "_sigmoid_focal_loss", "(", "pred", ",", "target", ",", "gamma", ",", "alpha", ",", "None", ",", "'none'", ")", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "if", "weight", ".", "shape", "!=", "loss", ".", "shape", ":", "\n", "            ", "if", "weight", ".", "size", "(", "0", ")", "==", "loss", ".", "size", "(", "0", ")", ":", "\n", "# For most cases, weight is of shape (num_priors, ),", "\n", "#  which means it does not have the second axis num_class", "\n", "                ", "weight", "=", "weight", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "# Sometimes, weight per anchor per class is also needed. e.g.", "\n", "#  in FSAF. But it may be flattened of shape", "\n", "#  (num_priors x num_class, ), while loss is still of shape", "\n", "#  (num_priors, num_class).", "\n", "                ", "assert", "weight", ".", "numel", "(", ")", "==", "loss", ".", "numel", "(", ")", "\n", "weight", "=", "weight", ".", "view", "(", "loss", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "", "", "assert", "weight", ".", "ndim", "==", "loss", ".", "ndim", "\n", "", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ",", "avg_factor", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss.GHMC.__init__": [[35, 49], ["torch.Module.__init__", "ghm_loss.GHMC.register_buffer", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "ghm_loss.GHMC.register_buffer", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "bins", "=", "10", ",", "momentum", "=", "0", ",", "use_sigmoid", "=", "True", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GHMC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bins", "=", "bins", "\n", "self", ".", "momentum", "=", "momentum", "\n", "edges", "=", "torch", ".", "arange", "(", "bins", "+", "1", ")", ".", "float", "(", ")", "/", "bins", "\n", "self", ".", "register_buffer", "(", "'edges'", ",", "edges", ")", "\n", "self", ".", "edges", "[", "-", "1", "]", "+=", "1e-6", "\n", "if", "momentum", ">", "0", ":", "\n", "            ", "acc_sum", "=", "torch", ".", "zeros", "(", "bins", ")", "\n", "self", ".", "register_buffer", "(", "'acc_sum'", ",", "acc_sum", ")", "\n", "", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "if", "not", "self", ".", "use_sigmoid", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss.GHMC.forward": [[50, 95], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "max", "range", "pred.dim", "target.dim", "ghm_loss._expand_onehot_labels", "target.float", "label_weight.float", "valid.float().sum().item", "inds.sum().item", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "pred.size", "pred.sigmoid().detach", "valid.float().sum", "inds.sum", "pred.sigmoid", "valid.float"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss._expand_onehot_labels"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "label_weight", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Calculate the GHM-C loss.\n\n        Args:\n            pred (float tensor of size [batch_num, class_num]):\n                The direct prediction of classification fc layer.\n            target (float tensor of size [batch_num, class_num]):\n                Binary class target for each sample.\n            label_weight (float tensor of size [batch_num, class_num]):\n                the value is 1 if the sample is valid and 0 if ignored.\n        Returns:\n            The gradient harmonized loss.\n        \"\"\"", "\n", "# the target should be binary class label", "\n", "if", "pred", ".", "dim", "(", ")", "!=", "target", ".", "dim", "(", ")", ":", "\n", "            ", "target", ",", "label_weight", "=", "_expand_onehot_labels", "(", "\n", "target", ",", "label_weight", ",", "pred", ".", "size", "(", "-", "1", ")", ")", "\n", "", "target", ",", "label_weight", "=", "target", ".", "float", "(", ")", ",", "label_weight", ".", "float", "(", ")", "\n", "edges", "=", "self", ".", "edges", "\n", "mmt", "=", "self", ".", "momentum", "\n", "weights", "=", "torch", ".", "zeros_like", "(", "pred", ")", "\n", "\n", "# gradient length", "\n", "g", "=", "torch", ".", "abs", "(", "pred", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", "-", "target", ")", "\n", "\n", "valid", "=", "label_weight", ">", "0", "\n", "tot", "=", "max", "(", "valid", ".", "float", "(", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "1.0", ")", "\n", "n", "=", "0", "# n valid bins", "\n", "for", "i", "in", "range", "(", "self", ".", "bins", ")", ":", "\n", "            ", "inds", "=", "(", "g", ">=", "edges", "[", "i", "]", ")", "&", "(", "g", "<", "edges", "[", "i", "+", "1", "]", ")", "&", "valid", "\n", "num_in_bin", "=", "inds", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "num_in_bin", ">", "0", ":", "\n", "                ", "if", "mmt", ">", "0", ":", "\n", "                    ", "self", ".", "acc_sum", "[", "i", "]", "=", "mmt", "*", "self", ".", "acc_sum", "[", "i", "]", "+", "(", "1", "-", "mmt", ")", "*", "num_in_bin", "\n", "weights", "[", "inds", "]", "=", "tot", "/", "self", ".", "acc_sum", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "weights", "[", "inds", "]", "=", "tot", "/", "num_in_bin", "\n", "", "n", "+=", "1", "\n", "", "", "if", "n", ">", "0", ":", "\n", "            ", "weights", "=", "weights", "/", "n", "\n", "\n", "", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "target", ",", "weights", ",", "reduction", "=", "'sum'", ")", "/", "tot", "\n", "return", "loss", "*", "self", ".", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss.GHMR.__init__": [[113, 125], ["torch.Module.__init__", "ghm_loss.GHMR.register_buffer", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "ghm_loss.GHMR.register_buffer", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "mu", "=", "0.02", ",", "bins", "=", "10", ",", "momentum", "=", "0", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GHMR", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mu", "=", "mu", "\n", "self", ".", "bins", "=", "bins", "\n", "edges", "=", "torch", ".", "arange", "(", "bins", "+", "1", ")", ".", "float", "(", ")", "/", "bins", "\n", "self", ".", "register_buffer", "(", "'edges'", ",", "edges", ")", "\n", "self", ".", "edges", "[", "-", "1", "]", "=", "1e3", "\n", "self", ".", "momentum", "=", "momentum", "\n", "if", "momentum", ">", "0", ":", "\n", "            ", "acc_sum", "=", "torch", ".", "zeros", "(", "bins", ")", "\n", "self", ".", "register_buffer", "(", "'acc_sum'", ",", "acc_sum", ")", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss.GHMR.forward": [[127, 173], ["torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.abs().detach", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "max", "range", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "label_weight.float().sum().item", "inds.sum().item", "loss.sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "label_weight.float().sum", "inds.sum", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "label_weight.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "label_weight", ",", "avg_factor", "=", "None", ")", ":", "\n", "        ", "\"\"\"Calculate the GHM-R loss.\n\n        Args:\n            pred (float tensor of size [batch_num, 4 (* class_num)]):\n                The prediction of box regression layer. Channel number can be 4\n                or 4 * class_num depending on whether it is class-agnostic.\n            target (float tensor of size [batch_num, 4 (* class_num)]):\n                The target regression values with the same size of pred.\n            label_weight (float tensor of size [batch_num, 4 (* class_num)]):\n                The weight of each sample, 0 if ignored.\n        Returns:\n            The gradient harmonized loss.\n        \"\"\"", "\n", "mu", "=", "self", ".", "mu", "\n", "edges", "=", "self", ".", "edges", "\n", "mmt", "=", "self", ".", "momentum", "\n", "\n", "# ASL1 loss", "\n", "diff", "=", "pred", "-", "target", "\n", "loss", "=", "torch", ".", "sqrt", "(", "diff", "*", "diff", "+", "mu", "*", "mu", ")", "-", "mu", "\n", "\n", "# gradient length", "\n", "g", "=", "torch", ".", "abs", "(", "diff", "/", "torch", ".", "sqrt", "(", "mu", "*", "mu", "+", "diff", "*", "diff", ")", ")", ".", "detach", "(", ")", "\n", "weights", "=", "torch", ".", "zeros_like", "(", "g", ")", "\n", "\n", "valid", "=", "label_weight", ">", "0", "\n", "tot", "=", "max", "(", "label_weight", ".", "float", "(", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "1.0", ")", "\n", "n", "=", "0", "# n: valid bins", "\n", "for", "i", "in", "range", "(", "self", ".", "bins", ")", ":", "\n", "            ", "inds", "=", "(", "g", ">=", "edges", "[", "i", "]", ")", "&", "(", "g", "<", "edges", "[", "i", "+", "1", "]", ")", "&", "valid", "\n", "num_in_bin", "=", "inds", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "num_in_bin", ">", "0", ":", "\n", "                ", "n", "+=", "1", "\n", "if", "mmt", ">", "0", ":", "\n", "                    ", "self", ".", "acc_sum", "[", "i", "]", "=", "mmt", "*", "self", ".", "acc_sum", "[", "i", "]", "+", "(", "1", "-", "mmt", ")", "*", "num_in_bin", "\n", "weights", "[", "inds", "]", "=", "tot", "/", "self", ".", "acc_sum", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "weights", "[", "inds", "]", "=", "tot", "/", "num_in_bin", "\n", "", "", "", "if", "n", ">", "0", ":", "\n", "            ", "weights", "/=", "n", "\n", "\n", "", "loss", "=", "loss", "*", "weights", "\n", "loss", "=", "loss", ".", "sum", "(", ")", "/", "tot", "\n", "return", "loss", "*", "self", ".", "loss_weight", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ghm_loss._expand_onehot_labels": [[8, 17], ["labels.new_full", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "label_weights.view().expand", "torch.nonzero().squeeze.numel", "label_weights.size", "labels.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "label_weights.view"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["def", "_expand_onehot_labels", "(", "labels", ",", "label_weights", ",", "label_channels", ")", ":", "\n", "    ", "bin_labels", "=", "labels", ".", "new_full", "(", "(", "labels", ".", "size", "(", "0", ")", ",", "label_channels", ")", ",", "0", ")", "\n", "inds", "=", "torch", ".", "nonzero", "(", "\n", "(", "labels", ">=", "0", ")", "&", "(", "labels", "<", "label_channels", ")", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "        ", "bin_labels", "[", "inds", ",", "labels", "[", "inds", "]", "]", "=", "1", "\n", "", "bin_label_weights", "=", "label_weights", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "\n", "label_weights", ".", "size", "(", "0", ")", ",", "label_channels", ")", "\n", "return", "bin_labels", ",", "bin_label_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ae_loss.AssociativeEmbeddingLoss.__init__": [[85, 89], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "pull_weight", "=", "0.25", ",", "push_weight", "=", "0.25", ")", ":", "\n", "        ", "super", "(", "AssociativeEmbeddingLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pull_weight", "=", "pull_weight", "\n", "self", ".", "push_weight", "=", "push_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ae_loss.AssociativeEmbeddingLoss.forward": [[90, 101], ["pred.size", "range", "ae_loss.ae_loss_per_image"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ae_loss.ae_loss_per_image"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "match", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "batch", "=", "pred", ".", "size", "(", "0", ")", "\n", "pull_all", ",", "push_all", "=", "0.0", ",", "0.0", "\n", "for", "i", "in", "range", "(", "batch", ")", ":", "\n", "            ", "pull", ",", "push", "=", "ae_loss_per_image", "(", "pred", "[", "i", "]", ",", "target", "[", "i", "]", ",", "match", "[", "i", "]", ")", "\n", "\n", "pull_all", "+=", "self", ".", "pull_weight", "*", "pull", "\n", "push_all", "+=", "self", ".", "push_weight", "*", "push", "\n", "\n", "", "return", "pull_all", ",", "push_all", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.ae_loss.ae_loss_per_image": [[8, 69], ["len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.size", "tl_preds.sum", "tl_preds.sum", "tl_preds[].view", "br_preds[].view", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.size", "torch.cat.size", "pull_loss.sum", "torch.cat.expand().permute", "torch.eye().type_as", "torch.eye().type_as", "torch.eye().type_as", "conf_mat.sum().abs", "torch.relu().sum", "tl_preds.sum", "torch.cat.expand", "torch.eye", "torch.eye", "torch.eye", "conf_mat.sum", "torch.relu"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["def", "ae_loss_per_image", "(", "tl_preds", ",", "br_preds", ",", "match", ")", ":", "\n", "    ", "\"\"\"Associative Embedding Loss in one image.\n\n    Associative Embedding Loss including two parts: pull loss and push loss.\n    Pull loss makes embedding vectors from same object closer to each other.\n    Push loss distinguish embedding vector from different objects, and makes\n        the gap between them is large enough.\n\n    During computing, usually there are 3 cases:\n        - no object in image: both pull loss and push loss will be 0.\n        - one object in image: push loss will be 0 and pull loss is computed\n            by the two corner of the only object.\n        - more than one objects in image: pull loss is computed by corner pairs\n            from each object, push loss is computed by each object with all\n            other objects. We use confusion matrix with 0 in diagonal to\n            compute the push loss.\n\n    Args:\n        tl_preds (tensor): Embedding feature map of left-top corner.\n        br_preds (tensor): Embedding feature map of bottim-right corner.\n        match (list): Downsampled coordinates pair of each ground truth box.\n    \"\"\"", "\n", "\n", "tl_list", ",", "br_list", ",", "me_list", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "if", "len", "(", "match", ")", "==", "0", ":", "# no object in image", "\n", "        ", "pull_loss", "=", "tl_preds", ".", "sum", "(", ")", "*", "0.", "\n", "push_loss", "=", "tl_preds", ".", "sum", "(", ")", "*", "0.", "\n", "", "else", ":", "\n", "        ", "for", "m", "in", "match", ":", "\n", "            ", "[", "tl_y", ",", "tl_x", "]", ",", "[", "br_y", ",", "br_x", "]", "=", "m", "\n", "tl_e", "=", "tl_preds", "[", ":", ",", "tl_y", ",", "tl_x", "]", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "br_e", "=", "br_preds", "[", ":", ",", "br_y", ",", "br_x", "]", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "tl_list", ".", "append", "(", "tl_e", ")", "\n", "br_list", ".", "append", "(", "br_e", ")", "\n", "me_list", ".", "append", "(", "(", "tl_e", "+", "br_e", ")", "/", "2.0", ")", "\n", "\n", "", "tl_list", "=", "torch", ".", "cat", "(", "tl_list", ")", "\n", "br_list", "=", "torch", ".", "cat", "(", "br_list", ")", "\n", "me_list", "=", "torch", ".", "cat", "(", "me_list", ")", "\n", "\n", "assert", "tl_list", ".", "size", "(", ")", "==", "br_list", ".", "size", "(", ")", "\n", "\n", "# N is object number in image, M is dimension of embedding vector", "\n", "N", ",", "M", "=", "tl_list", ".", "size", "(", ")", "\n", "\n", "pull_loss", "=", "(", "tl_list", "-", "me_list", ")", ".", "pow", "(", "2", ")", "+", "(", "br_list", "-", "me_list", ")", ".", "pow", "(", "2", ")", "\n", "pull_loss", "=", "pull_loss", ".", "sum", "(", ")", "/", "N", "\n", "\n", "margin", "=", "1", "# exp setting of CornerNet, details in section 3.3 of paper", "\n", "\n", "# confusion matrix of push loss", "\n", "conf_mat", "=", "me_list", ".", "expand", "(", "(", "N", ",", "N", ",", "M", ")", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "-", "me_list", "\n", "conf_weight", "=", "1", "-", "torch", ".", "eye", "(", "N", ")", ".", "type_as", "(", "me_list", ")", "\n", "conf_mat", "=", "conf_weight", "*", "(", "margin", "-", "conf_mat", ".", "sum", "(", "-", "1", ")", ".", "abs", "(", ")", ")", "\n", "\n", "if", "N", ">", "1", ":", "# more than one object in current image", "\n", "            ", "push_loss", "=", "F", ".", "relu", "(", "conf_mat", ")", ".", "sum", "(", ")", "/", "(", "N", "*", "(", "N", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "push_loss", "=", "tl_preds", ".", "sum", "(", ")", "*", "0.", "\n", "\n", "", "", "return", "pull_loss", ",", "push_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.Accuracy.__init__": [[53, 65], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "topk", "=", "(", "1", ",", ")", ",", "thresh", "=", "None", ")", ":", "\n", "        ", "\"\"\"Module to calculate the accuracy.\n\n        Args:\n            topk (tuple, optional): The criterion used to calculate the\n                accuracy. Defaults to (1,).\n            thresh (float, optional): If not None, predictions with scores\n                under this threshold are considered incorrect. Default to None.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "topk", "=", "topk", "\n", "self", ".", "thresh", "=", "thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.Accuracy.forward": [[66, 77], ["accuracy.accuracy"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.accuracy"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ")", ":", "\n", "        ", "\"\"\"Forward function to calculate accuracy.\n\n        Args:\n            pred (torch.Tensor): Prediction of models.\n            target (torch.Tensor): Target for each prediction.\n\n        Returns:\n            tuple[float]: The accuracies under different topk criterions.\n        \"\"\"", "\n", "return", "accuracy", "(", "pred", ",", "target", ",", "self", ".", "topk", ",", "self", ".", "thresh", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.accuracy.accuracy": [[4, 49], ["isinstance", "isinstance", "max", "pred.topk", "pred_label.t.t", "pred_label.t.eq", "pred.size", "pred.size", "target.size", "pred.size", "target.view().expand_as", "correct[].view().float().sum", "res.append", "pred.new_tensor", "pred.size", "correct[].view().float().sum.mul_", "range", "target.view", "correct[].view().float", "len", "pred.size", "correct[].view"], "function", ["None"], ["def", "accuracy", "(", "pred", ",", "target", ",", "topk", "=", "1", ",", "thresh", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate accuracy according to the prediction and target.\n\n    Args:\n        pred (torch.Tensor): The model prediction, shape (N, num_class)\n        target (torch.Tensor): The target of each prediction, shape (N, )\n        topk (int | tuple[int], optional): If the predictions in ``topk``\n            matches the target, the predictions will be regarded as\n            correct ones. Defaults to 1.\n        thresh (float, optional): If not None, predictions with scores under\n            this threshold are considered incorrect. Default to None.\n\n    Returns:\n        float | tuple[float]: If the input ``topk`` is a single integer,\n            the function will return a single float as accuracy. If\n            ``topk`` is a tuple containing multiple integers, the\n            function will return a tuple containing accuracies of\n            each ``topk`` number.\n    \"\"\"", "\n", "assert", "isinstance", "(", "topk", ",", "(", "int", ",", "tuple", ")", ")", "\n", "if", "isinstance", "(", "topk", ",", "int", ")", ":", "\n", "        ", "topk", "=", "(", "topk", ",", ")", "\n", "return_single", "=", "True", "\n", "", "else", ":", "\n", "        ", "return_single", "=", "False", "\n", "\n", "", "maxk", "=", "max", "(", "topk", ")", "\n", "if", "pred", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "        ", "accu", "=", "[", "pred", ".", "new_tensor", "(", "0.", ")", "for", "i", "in", "range", "(", "len", "(", "topk", ")", ")", "]", "\n", "return", "accu", "[", "0", "]", "if", "return_single", "else", "accu", "\n", "", "assert", "pred", ".", "ndim", "==", "2", "and", "target", ".", "ndim", "==", "1", "\n", "assert", "pred", ".", "size", "(", "0", ")", "==", "target", ".", "size", "(", "0", ")", "\n", "assert", "maxk", "<=", "pred", ".", "size", "(", "1", ")", ",", "f'maxk {maxk} exceeds pred dimension {pred.size(1)}'", "\n", "pred_value", ",", "pred_label", "=", "pred", ".", "topk", "(", "maxk", ",", "dim", "=", "1", ")", "\n", "pred_label", "=", "pred_label", ".", "t", "(", ")", "# transpose to shape (maxk, N)", "\n", "correct", "=", "pred_label", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred_label", ")", ")", "\n", "if", "thresh", "is", "not", "None", ":", "\n", "# Only prediction values larger than thresh are counted as correct", "\n", "        ", "correct", "=", "correct", "&", "(", "pred_value", ">", "thresh", ")", ".", "t", "(", ")", "\n", "", "res", "=", "[", "]", "\n", "for", "k", "in", "topk", ":", "\n", "        ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "res", ".", "append", "(", "correct_k", ".", "mul_", "(", "100.0", "/", "pred", ".", "size", "(", "0", ")", ")", ")", "\n", "", "return", "res", "[", "0", "]", "if", "return_single", "else", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.isr_p": [[6, 117], ["float", "list", "range", "torch.cat", "cls_score.detach.detach", "bbox_pred.view.detach", "bbox_targets[].view", "bbox_coder.decode", "bbox_coder.decode", "mmdet.core.bbox_overlaps", "pos_labels.bincount().max", "pos_labels.unique", "loss_cls", "pos_label_inds.size", "len", "torch.cat.append", "len", "rois.size", "bbox_pred.view.size", "bbox_pred.view.view", "bbox_pred[].view", "bbox_pred[].view", "l_gts.unique", "l_ious.sort", "l_iou_rank_idx.sort", "loss_cls.dim", "ori_pos_loss_cls.sum", "new_pos_loss_cls.sum", "len", "bbox_pred.view.size", "pos_labels.bincount", "t_ious.sort", "t_iou_rank_idx.sort", "gt_i.max", "t_iou_rank.float", "l_iou_rank.float"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["def", "isr_p", "(", "cls_score", ",", "\n", "bbox_pred", ",", "\n", "bbox_targets", ",", "\n", "rois", ",", "\n", "sampling_results", ",", "\n", "loss_cls", ",", "\n", "bbox_coder", ",", "\n", "k", "=", "2", ",", "\n", "bias", "=", "0", ",", "\n", "num_class", "=", "80", ")", ":", "\n", "    ", "\"\"\"Importance-based Sample Reweighting (ISR_P), positive part.\n\n    Args:\n        cls_score (Tensor): Predicted classification scores.\n        bbox_pred (Tensor): Predicted bbox deltas.\n        bbox_targets (tuple[Tensor]): A tuple of bbox targets, the are\n            labels, label_weights, bbox_targets, bbox_weights, respectively.\n        rois (Tensor): Anchors (single_stage) in shape (n, 4) or RoIs\n            (two_stage) in shape (n, 5).\n        sampling_results (obj): Sampling results.\n        loss_cls (func): Classification loss func of the head.\n        bbox_coder (obj): BBox coder of the head.\n        k (float): Power of the non-linear mapping.\n        bias (float): Shift of the non-linear mapping.\n        num_class (int): Number of classes, default: 80.\n\n    Return:\n        tuple([Tensor]): labels, imp_based_label_weights, bbox_targets,\n            bbox_target_weights\n    \"\"\"", "\n", "\n", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "=", "bbox_targets", "\n", "pos_label_inds", "=", "(", "(", "labels", ">=", "0", ")", "&", "\n", "(", "labels", "<", "num_class", ")", ")", ".", "nonzero", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "pos_labels", "=", "labels", "[", "pos_label_inds", "]", "\n", "\n", "# if no positive samples, return the original targets", "\n", "num_pos", "=", "float", "(", "pos_label_inds", ".", "size", "(", "0", ")", ")", "\n", "if", "num_pos", "==", "0", ":", "\n", "        ", "return", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "\n", "\n", "# merge pos_assigned_gt_inds of per image to a single tensor", "\n", "", "gts", "=", "list", "(", ")", "\n", "last_max_gt", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "sampling_results", ")", ")", ":", "\n", "        ", "gt_i", "=", "sampling_results", "[", "i", "]", ".", "pos_assigned_gt_inds", "\n", "gts", ".", "append", "(", "gt_i", "+", "last_max_gt", ")", "\n", "if", "len", "(", "gt_i", ")", "!=", "0", ":", "\n", "            ", "last_max_gt", "=", "gt_i", ".", "max", "(", ")", "+", "1", "\n", "", "", "gts", "=", "torch", ".", "cat", "(", "gts", ")", "\n", "assert", "len", "(", "gts", ")", "==", "num_pos", "\n", "\n", "cls_score", "=", "cls_score", ".", "detach", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "detach", "(", ")", "\n", "\n", "# For single stage detectors, rois here indicate anchors, in shape (N, 4)", "\n", "# For two stage detectors, rois are in shape (N, 5)", "\n", "if", "rois", ".", "size", "(", "-", "1", ")", "==", "5", ":", "\n", "        ", "pos_rois", "=", "rois", "[", "pos_label_inds", "]", "[", ":", ",", "1", ":", "]", "\n", "", "else", ":", "\n", "        ", "pos_rois", "=", "rois", "[", "pos_label_inds", "]", "\n", "\n", "", "if", "bbox_pred", ".", "size", "(", "-", "1", ")", ">", "4", ":", "\n", "        ", "bbox_pred", "=", "bbox_pred", ".", "view", "(", "bbox_pred", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "pos_delta_pred", "=", "bbox_pred", "[", "pos_label_inds", ",", "pos_labels", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "", "else", ":", "\n", "        ", "pos_delta_pred", "=", "bbox_pred", "[", "pos_label_inds", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "\n", "# compute iou of the predicted bbox and the corresponding GT", "\n", "", "pos_delta_target", "=", "bbox_targets", "[", "pos_label_inds", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "pos_bbox_pred", "=", "bbox_coder", ".", "decode", "(", "pos_rois", ",", "pos_delta_pred", ")", "\n", "target_bbox_pred", "=", "bbox_coder", ".", "decode", "(", "pos_rois", ",", "pos_delta_target", ")", "\n", "ious", "=", "bbox_overlaps", "(", "pos_bbox_pred", ",", "target_bbox_pred", ",", "is_aligned", "=", "True", ")", "\n", "\n", "pos_imp_weights", "=", "label_weights", "[", "pos_label_inds", "]", "\n", "# Two steps to compute IoU-HLR. Samples are first sorted by IoU locally,", "\n", "# then sorted again within the same-rank group", "\n", "max_l_num", "=", "pos_labels", ".", "bincount", "(", ")", ".", "max", "(", ")", "\n", "for", "label", "in", "pos_labels", ".", "unique", "(", ")", ":", "\n", "        ", "l_inds", "=", "(", "pos_labels", "==", "label", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "l_gts", "=", "gts", "[", "l_inds", "]", "\n", "for", "t", "in", "l_gts", ".", "unique", "(", ")", ":", "\n", "            ", "t_inds", "=", "l_inds", "[", "l_gts", "==", "t", "]", "\n", "t_ious", "=", "ious", "[", "t_inds", "]", "\n", "_", ",", "t_iou_rank_idx", "=", "t_ious", ".", "sort", "(", "descending", "=", "True", ")", "\n", "_", ",", "t_iou_rank", "=", "t_iou_rank_idx", ".", "sort", "(", ")", "\n", "ious", "[", "t_inds", "]", "+=", "max_l_num", "-", "t_iou_rank", ".", "float", "(", ")", "\n", "", "l_ious", "=", "ious", "[", "l_inds", "]", "\n", "_", ",", "l_iou_rank_idx", "=", "l_ious", ".", "sort", "(", "descending", "=", "True", ")", "\n", "_", ",", "l_iou_rank", "=", "l_iou_rank_idx", ".", "sort", "(", ")", "# IoU-HLR", "\n", "# linearly map HLR to label weights", "\n", "pos_imp_weights", "[", "l_inds", "]", "*=", "(", "max_l_num", "-", "l_iou_rank", ".", "float", "(", ")", ")", "/", "max_l_num", "\n", "\n", "", "pos_imp_weights", "=", "(", "bias", "+", "pos_imp_weights", "*", "(", "1", "-", "bias", ")", ")", ".", "pow", "(", "k", ")", "\n", "\n", "# normalize to make the new weighted loss value equal to the original loss", "\n", "pos_loss_cls", "=", "loss_cls", "(", "\n", "cls_score", "[", "pos_label_inds", "]", ",", "pos_labels", ",", "reduction_override", "=", "'none'", ")", "\n", "if", "pos_loss_cls", ".", "dim", "(", ")", ">", "1", ":", "\n", "        ", "ori_pos_loss_cls", "=", "pos_loss_cls", "*", "label_weights", "[", "pos_label_inds", "]", "[", ":", ",", "\n", "None", "]", "\n", "new_pos_loss_cls", "=", "pos_loss_cls", "*", "pos_imp_weights", "[", ":", ",", "None", "]", "\n", "", "else", ":", "\n", "        ", "ori_pos_loss_cls", "=", "pos_loss_cls", "*", "label_weights", "[", "pos_label_inds", "]", "\n", "new_pos_loss_cls", "=", "pos_loss_cls", "*", "pos_imp_weights", "\n", "", "pos_loss_cls_ratio", "=", "ori_pos_loss_cls", ".", "sum", "(", ")", "/", "new_pos_loss_cls", ".", "sum", "(", ")", "\n", "pos_imp_weights", "=", "pos_imp_weights", "*", "pos_loss_cls_ratio", "\n", "label_weights", "[", "pos_label_inds", "]", "=", "pos_imp_weights", "\n", "\n", "bbox_targets", "=", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "\n", "return", "bbox_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.pisa_loss.carl_loss": [[119, 181], ["float", "dict", "pos_label_inds.numel", "dict", "pos_cls_score.size", "carl_loss_weights.sum", "bbox_targets.size", "bbox_pred.view.size", "bbox_pred.view.view", "loss_bbox", "cls_score.sigmoid", "cls_score.softmax", "bbox_pred.view.size", "cls_score.sum"], "function", ["None"], ["", "def", "carl_loss", "(", "cls_score", ",", "\n", "labels", ",", "\n", "bbox_pred", ",", "\n", "bbox_targets", ",", "\n", "loss_bbox", ",", "\n", "k", "=", "1", ",", "\n", "bias", "=", "0.2", ",", "\n", "avg_factor", "=", "None", ",", "\n", "sigmoid", "=", "False", ",", "\n", "num_class", "=", "80", ")", ":", "\n", "    ", "\"\"\"Classification-Aware Regression Loss (CARL).\n\n    Args:\n        cls_score (Tensor): Predicted classification scores.\n        labels (Tensor): Targets of classification.\n        bbox_pred (Tensor): Predicted bbox deltas.\n        bbox_targets (Tensor): Target of bbox regression.\n        loss_bbox (func): Regression loss func of the head.\n        bbox_coder (obj): BBox coder of the head.\n        k (float): Power of the non-linear mapping.\n        bias (float): Shift of the non-linear mapping.\n        avg_factor (int): Average factor used in regression loss.\n        sigmoid (bool): Activation of the classification score.\n        num_class (int): Number of classes, default: 80.\n\n    Return:\n        dict: CARL loss dict.\n    \"\"\"", "\n", "pos_label_inds", "=", "(", "(", "labels", ">=", "0", ")", "&", "\n", "(", "labels", "<", "num_class", ")", ")", ".", "nonzero", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "if", "pos_label_inds", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "dict", "(", "loss_carl", "=", "cls_score", ".", "sum", "(", ")", "[", "None", "]", "*", "0.", ")", "\n", "", "pos_labels", "=", "labels", "[", "pos_label_inds", "]", "\n", "\n", "# multiply pos_cls_score with the corresponding bbox weight", "\n", "# and remain gradient", "\n", "if", "sigmoid", ":", "\n", "        ", "pos_cls_score", "=", "cls_score", ".", "sigmoid", "(", ")", "[", "pos_label_inds", ",", "pos_labels", "]", "\n", "", "else", ":", "\n", "        ", "pos_cls_score", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "[", "pos_label_inds", ",", "pos_labels", "]", "\n", "", "carl_loss_weights", "=", "(", "bias", "+", "(", "1", "-", "bias", ")", "*", "pos_cls_score", ")", ".", "pow", "(", "k", ")", "\n", "\n", "# normalize carl_loss_weight to make its sum equal to num positive", "\n", "num_pos", "=", "float", "(", "pos_cls_score", ".", "size", "(", "0", ")", ")", "\n", "weight_ratio", "=", "num_pos", "/", "carl_loss_weights", ".", "sum", "(", ")", "\n", "carl_loss_weights", "*=", "weight_ratio", "\n", "\n", "if", "avg_factor", "is", "None", ":", "\n", "        ", "avg_factor", "=", "bbox_targets", ".", "size", "(", "0", ")", "\n", "# if is class agnostic, bbox pred is in shape (N, 4)", "\n", "# otherwise, bbox pred is in shape (N, #classes, 4)", "\n", "", "if", "bbox_pred", ".", "size", "(", "-", "1", ")", ">", "4", ":", "\n", "        ", "bbox_pred", "=", "bbox_pred", ".", "view", "(", "bbox_pred", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "pos_bbox_preds", "=", "bbox_pred", "[", "pos_label_inds", ",", "pos_labels", "]", "\n", "", "else", ":", "\n", "        ", "pos_bbox_preds", "=", "bbox_pred", "[", "pos_label_inds", "]", "\n", "", "ori_loss_reg", "=", "loss_bbox", "(", "\n", "pos_bbox_preds", ",", "\n", "bbox_targets", "[", "pos_label_inds", "]", ",", "\n", "reduction_override", "=", "'none'", ")", "/", "avg_factor", "\n", "loss_carl", "=", "(", "ori_loss_reg", "*", "carl_loss_weights", "[", ":", ",", "None", "]", ")", ".", "sum", "(", ")", "\n", "return", "dict", "(", "loss_carl", "=", "loss_carl", "[", "None", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.reduce_loss": [[6, 24], ["torch._Reduction.get_enum", "loss.mean", "loss.sum"], "function", ["None"], ["def", "reduce_loss", "(", "loss", ",", "reduction", ")", ":", "\n", "    ", "\"\"\"Reduce loss as specified.\n\n    Args:\n        loss (Tensor): Elementwise loss tensor.\n        reduction (str): Options are \"none\", \"mean\" and \"sum\".\n\n    Return:\n        Tensor: Reduced loss tensor.\n    \"\"\"", "\n", "reduction_enum", "=", "F", ".", "_Reduction", ".", "get_enum", "(", "reduction", ")", "\n", "# none: 0, elementwise_mean:1, sum: 2", "\n", "if", "reduction_enum", "==", "0", ":", "\n", "        ", "return", "loss", "\n", "", "elif", "reduction_enum", "==", "1", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "elif", "reduction_enum", "==", "2", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss": [[26, 53], ["utils.reduce_loss", "reduce_loss.sum", "ValueError"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.reduce_loss"], ["", "", "def", "weight_reduce_loss", "(", "loss", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "avg_factor", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply element-wise weight and reduce loss.\n\n    Args:\n        loss (Tensor): Element-wise loss.\n        weight (Tensor): Element-wise weights.\n        reduction (str): Same as built-in losses of PyTorch.\n        avg_factor (float): Avarage factor when computing the mean of losses.\n\n    Returns:\n        Tensor: Processed loss values.\n    \"\"\"", "\n", "# if weight is specified, apply element-wise weight", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "loss", "=", "loss", "*", "weight", "\n", "\n", "# if avg_factor is not specified, just reduce the loss", "\n", "", "if", "avg_factor", "is", "None", ":", "\n", "        ", "loss", "=", "reduce_loss", "(", "loss", ",", "reduction", ")", "\n", "", "else", ":", "\n", "# if reduction is mean, then average the loss by avg_factor", "\n", "        ", "if", "reduction", "==", "'mean'", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "avg_factor", "\n", "# if reduction is 'none', then do nothing, otherwise raise an error", "\n", "", "elif", "reduction", "!=", "'none'", ":", "\n", "            ", "raise", "ValueError", "(", "'avg_factor can not be used with reduction=\"sum\"'", ")", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weighted_loss": [[55, 99], ["functools.wraps", "loss_func", "utils.weight_reduce_loss"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss"], ["", "def", "weighted_loss", "(", "loss_func", ")", ":", "\n", "    ", "\"\"\"Create a weighted version of a given loss function.\n\n    To use this decorator, the loss function must have the signature like\n    `loss_func(pred, target, **kwargs)`. The function only needs to compute\n    element-wise loss without any reduction. This decorator will add weight\n    and reduction arguments to the function. The decorated function will have\n    the signature like `loss_func(pred, target, weight=None, reduction='mean',\n    avg_factor=None, **kwargs)`.\n\n    :Example:\n\n    >>> import torch\n    >>> @weighted_loss\n    >>> def l1_loss(pred, target):\n    >>>     return (pred - target).abs()\n\n    >>> pred = torch.Tensor([0, 2, 3])\n    >>> target = torch.Tensor([1, 1, 1])\n    >>> weight = torch.Tensor([1, 0, 1])\n\n    >>> l1_loss(pred, target)\n    tensor(1.3333)\n    >>> l1_loss(pred, target, weight)\n    tensor(1.)\n    >>> l1_loss(pred, target, reduction='none')\n    tensor([1., 1., 2.])\n    >>> l1_loss(pred, target, weight, avg_factor=2)\n    tensor(1.5000)\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "loss_func", ")", "\n", "def", "wrapper", "(", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "# get element-wise loss", "\n", "        ", "loss", "=", "loss_func", "(", "pred", ",", "target", ",", "**", "kwargs", ")", "\n", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ",", "avg_factor", ")", "\n", "return", "loss", "\n", "\n", "", "return", "wrapper", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.CrossEntropyLoss.__init__": [[133, 166], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "use_sigmoid", "=", "False", ",", "\n", "use_mask", "=", "False", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "class_weight", "=", "None", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"CrossEntropyLoss.\n\n        Args:\n            use_sigmoid (bool, optional): Whether the prediction uses sigmoid\n                of softmax. Defaults to False.\n            use_mask (bool, optional): Whether to use mask cross entropy loss.\n                Defaults to False.\n            reduction (str, optional): . Defaults to 'mean'.\n                Options are \"none\", \"mean\" and \"sum\".\n            class_weight (list[float], optional): Weight of each class.\n                Defaults to None.\n            loss_weight (float, optional): Weight of the loss. Defaults to 1.0.\n        \"\"\"", "\n", "super", "(", "CrossEntropyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "(", "use_sigmoid", "is", "False", ")", "or", "(", "use_mask", "is", "False", ")", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "use_mask", "=", "use_mask", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "class_weight", "=", "class_weight", "\n", "\n", "if", "self", ".", "use_sigmoid", ":", "\n", "            ", "self", ".", "cls_criterion", "=", "binary_cross_entropy", "\n", "", "elif", "self", ".", "use_mask", ":", "\n", "            ", "self", ".", "cls_criterion", "=", "mask_cross_entropy", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_criterion", "=", "cross_entropy", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.CrossEntropyLoss.forward": [[167, 203], ["cls_score.new_tensor", "cross_entropy_loss.CrossEntropyLoss.cls_criterion"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "\n", "cls_score", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            cls_score (torch.Tensor): The prediction.\n            label (torch.Tensor): The learning label of the prediction.\n            weight (torch.Tensor, optional): Sample-wise loss weight.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction (str, optional): The method used to reduce the loss.\n                Options are \"none\", \"mean\" and \"sum\".\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "self", ".", "class_weight", "is", "not", "None", ":", "\n", "            ", "class_weight", "=", "cls_score", ".", "new_tensor", "(", "self", ".", "class_weight", ")", "\n", "", "else", ":", "\n", "            ", "class_weight", "=", "None", "\n", "", "loss_cls", "=", "self", ".", "loss_weight", "*", "self", ".", "cls_criterion", "(", "\n", "cls_score", ",", "\n", "label", ",", "\n", "weight", ",", "\n", "class_weight", "=", "class_weight", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss_cls", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy": [[9, 42], ["torch.cross_entropy", "utils.weight_reduce_loss", "weight.float.float"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss"], ["def", "cross_entropy", "(", "pred", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "class_weight", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Calculate the CrossEntropy loss.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the number\n            of classes.\n        label (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        reduction (str, optional): The method used to reduce the loss.\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n        class_weight (list[float], optional): The weight for each class.\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "# element-wise losses", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "pred", ",", "label", ",", "weight", "=", "class_weight", ",", "\n", "reduction", "=", "'none'", ",", "**", "kwargs", ")", "\n", "\n", "# apply weights and do the reduction", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "weight", "=", "weight", ".", "float", "(", ")", "\n", "", "loss", "=", "weight_reduce_loss", "(", "\n", "loss", ",", "weight", "=", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss._expand_binary_labels": [[44, 58], ["labels.new_full", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze.numel", "label_weights.view().expand", "labels.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "label_weights.size", "label_weights.view"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "_expand_binary_labels", "(", "labels", ",", "label_weights", ",", "label_channels", ")", ":", "\n", "# Caution: this function should only be used in RPN", "\n", "# in other files such as in ghm_loss, the _expand_binary_labels", "\n", "# is used for multi-class classification.", "\n", "    ", "bin_labels", "=", "labels", ".", "new_full", "(", "(", "labels", ".", "size", "(", "0", ")", ",", "label_channels", ")", ",", "0", ")", "\n", "inds", "=", "torch", ".", "nonzero", "(", "labels", ">=", "1", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "        ", "bin_labels", "[", "inds", ",", "labels", "[", "inds", "]", "-", "1", "]", "=", "1", "\n", "", "if", "label_weights", "is", "None", ":", "\n", "        ", "bin_label_weights", "=", "None", "\n", "", "else", ":", "\n", "        ", "bin_label_weights", "=", "label_weights", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "\n", "label_weights", ".", "size", "(", "0", ")", ",", "label_channels", ")", "\n", "", "return", "bin_labels", ",", "bin_label_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.binary_cross_entropy": [[60, 94], ["torch.binary_cross_entropy_with_logits", "utils.weight_reduce_loss", "pred.dim", "label.dim", "cross_entropy_loss._expand_binary_labels", "weight.float.float", "label.float", "pred.size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.utils.weight_reduce_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss._expand_binary_labels"], ["", "def", "binary_cross_entropy", "(", "pred", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "class_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the binary CrossEntropy loss.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, 1).\n        label (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        reduction (str, optional): The method used to reduce the loss.\n            Options are \"none\", \"mean\" and \"sum\".\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n        class_weight (list[float], optional): The weight for each class.\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "if", "pred", ".", "dim", "(", ")", "!=", "label", ".", "dim", "(", ")", ":", "\n", "        ", "label", ",", "weight", "=", "_expand_binary_labels", "(", "label", ",", "weight", ",", "pred", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "# weighted element-wise losses", "\n", "", "if", "weight", "is", "not", "None", ":", "\n", "        ", "weight", "=", "weight", ".", "float", "(", ")", "\n", "", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "label", ".", "float", "(", ")", ",", "weight", "=", "class_weight", ",", "reduction", "=", "'none'", ")", "\n", "# do the reduction for the weighted loss", "\n", "loss", "=", "weight_reduce_loss", "(", "\n", "loss", ",", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.cross_entropy_loss.mask_cross_entropy": [[96, 128], ["torch.arange", "torch.arange", "torch.arange", "pred[].squeeze", "pred.size", "torch.binary_cross_entropy_with_logits"], "function", ["None"], ["", "def", "mask_cross_entropy", "(", "pred", ",", "\n", "target", ",", "\n", "label", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "class_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the CrossEntropy loss for masks.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the number\n            of classes.\n        target (torch.Tensor): The learning label of the prediction.\n        label (torch.Tensor): ``label`` indicates the class label of the mask'\n            corresponding object. This will be used to select the mask in the\n            of the class which the object belongs to when the mask prediction\n            if not class-agnostic.\n        reduction (str, optional): The method used to reduce the loss.\n            Options are \"none\", \"mean\" and \"sum\".\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n        class_weight (list[float], optional): The weight for each class.\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "# TODO: handle these two reserved arguments", "\n", "assert", "reduction", "==", "'mean'", "and", "avg_factor", "is", "None", "\n", "num_rois", "=", "pred", ".", "size", "(", ")", "[", "0", "]", "\n", "inds", "=", "torch", ".", "arange", "(", "0", ",", "num_rois", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "pred", ".", "device", ")", "\n", "pred_slice", "=", "pred", "[", "inds", ",", "label", "]", ".", "squeeze", "(", "1", ")", "\n", "return", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred_slice", ",", "target", ",", "weight", "=", "class_weight", ",", "reduction", "=", "'mean'", ")", "[", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.SmoothL1Loss.__init__": [[57, 62], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "beta", "=", "1.0", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "SmoothL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.SmoothL1Loss.forward": [[63, 95], ["smooth_l1_loss.smooth_l1_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.smooth_l1_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_bbox", "=", "self", ".", "loss_weight", "*", "smooth_l1_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.__init__": [[107, 111], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "L1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward": [[112, 137], ["smooth_l1_loss.l1_loss"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.l1_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_bbox", "=", "self", ".", "loss_weight", "*", "l1_loss", "(", "\n", "pred", ",", "target", ",", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "return", "loss_bbox", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.smooth_l1_loss": [[8, 27], ["torch.abs", "torch.abs", "torch.where", "torch.where", "pred.size", "target.size", "target.numel"], "function", ["None"], ["@", "weighted_loss", "\n", "def", "smooth_l1_loss", "(", "pred", ",", "target", ",", "beta", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Smooth L1 loss.\n\n    Args:\n        pred (torch.Tensor): The prediction.\n        target (torch.Tensor): The learning target of the prediction.\n        beta (float, optional): The threshold in the piecewise function.\n            Defaults to 1.0.\n\n    Returns:\n        torch.Tensor: Calculated loss\n    \"\"\"", "\n", "assert", "beta", ">", "0", "\n", "assert", "pred", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", "and", "target", ".", "numel", "(", ")", ">", "0", "\n", "diff", "=", "torch", ".", "abs", "(", "pred", "-", "target", ")", "\n", "loss", "=", "torch", ".", "where", "(", "diff", "<", "beta", ",", "0.5", "*", "diff", "*", "diff", "/", "beta", ",", "\n", "diff", "-", "0.5", "*", "beta", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.l1_loss": [[29, 43], ["torch.abs", "torch.abs", "pred.size", "target.size", "target.numel"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "l1_loss", "(", "pred", ",", "target", ")", ":", "\n", "    ", "\"\"\"L1 loss.\n\n    Args:\n        pred (torch.Tensor): The prediction.\n        target (torch.Tensor): The learning target of the prediction.\n\n    Returns:\n        torch.Tensor: Calculated loss\n    \"\"\"", "\n", "assert", "pred", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", "and", "target", ".", "numel", "(", ")", ">", "0", "\n", "loss", "=", "torch", ".", "abs", "(", "pred", "-", "target", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16": [[9, 86], ["functools.wraps", "inspect.getfullargspec", "old_func", "isinstance", "TypeError", "old_func", "enumerate", "kwargs.items", "utils.cast_tensor_type", "hasattr", "len", "new_args.append", "new_args.append", "utils.cast_tensor_type", "utils.cast_tensor_type"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type"], ["def", "auto_fp16", "(", "apply_to", "=", "None", ",", "out_fp32", "=", "False", ")", ":", "\n", "    ", "\"\"\"Decorator to enable fp16 training automatically.\n\n    This decorator is useful when you write custom modules and want to support\n    mixed precision training. If inputs arguments are fp32 tensors, they will\n    be converted to fp16 automatically. Arguments other than fp32 tensors are\n    ignored.\n\n    Args:\n        apply_to (Iterable, optional): The argument names to be converted.\n            `None` indicates all arguments.\n        out_fp32 (bool): Whether to convert the output back to fp32.\n\n    Example:\n\n        >>> import torch.nn as nn\n        >>> class MyModule1(nn.Module):\n        >>>\n        >>>     # Convert x and y to fp16\n        >>>     @auto_fp16()\n        >>>     def forward(self, x, y):\n        >>>         pass\n\n        >>> import torch.nn as nn\n        >>> class MyModule2(nn.Module):\n        >>>\n        >>>     # convert pred to fp16\n        >>>     @auto_fp16(apply_to=('pred', ))\n        >>>     def do_something(self, pred, others):\n        >>>         pass\n    \"\"\"", "\n", "\n", "def", "auto_fp16_wrapper", "(", "old_func", ")", ":", "\n", "\n", "        ", "@", "functools", ".", "wraps", "(", "old_func", ")", "\n", "def", "new_func", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# check if the module has set the attribute `fp16_enabled`, if not,", "\n", "# just fallback to the original method.", "\n", "            ", "if", "not", "isinstance", "(", "args", "[", "0", "]", ",", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "                ", "raise", "TypeError", "(", "'@auto_fp16 can only be used to decorate the '", "\n", "'method of nn.Module'", ")", "\n", "", "if", "not", "(", "hasattr", "(", "args", "[", "0", "]", ",", "'fp16_enabled'", ")", "and", "args", "[", "0", "]", ".", "fp16_enabled", ")", ":", "\n", "                ", "return", "old_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# get the arg spec of the decorated method", "\n", "", "args_info", "=", "getfullargspec", "(", "old_func", ")", "\n", "# get the argument names to be casted", "\n", "args_to_cast", "=", "args_info", ".", "args", "if", "apply_to", "is", "None", "else", "apply_to", "\n", "# convert the args that need to be processed", "\n", "new_args", "=", "[", "]", "\n", "# NOTE: default args are not taken into consideration", "\n", "if", "args", ":", "\n", "                ", "arg_names", "=", "args_info", ".", "args", "[", ":", "len", "(", "args", ")", "]", "\n", "for", "i", ",", "arg_name", "in", "enumerate", "(", "arg_names", ")", ":", "\n", "                    ", "if", "arg_name", "in", "args_to_cast", ":", "\n", "                        ", "new_args", ".", "append", "(", "\n", "cast_tensor_type", "(", "args", "[", "i", "]", ",", "torch", ".", "float", ",", "torch", ".", "half", ")", ")", "\n", "", "else", ":", "\n", "                        ", "new_args", ".", "append", "(", "args", "[", "i", "]", ")", "\n", "# convert the kwargs that need to be processed", "\n", "", "", "", "new_kwargs", "=", "{", "}", "\n", "if", "kwargs", ":", "\n", "                ", "for", "arg_name", ",", "arg_value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                    ", "if", "arg_name", "in", "args_to_cast", ":", "\n", "                        ", "new_kwargs", "[", "arg_name", "]", "=", "cast_tensor_type", "(", "\n", "arg_value", ",", "torch", ".", "float", ",", "torch", ".", "half", ")", "\n", "", "else", ":", "\n", "                        ", "new_kwargs", "[", "arg_name", "]", "=", "arg_value", "\n", "# apply converted arguments to the decorated method", "\n", "", "", "", "output", "=", "old_func", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "# cast the results back to fp32 if necessary", "\n", "if", "out_fp32", ":", "\n", "                ", "output", "=", "cast_tensor_type", "(", "output", ",", "torch", ".", "half", ",", "torch", ".", "float", ")", "\n", "", "return", "output", "\n", "\n", "", "return", "new_func", "\n", "\n", "", "return", "auto_fp16_wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32": [[88, 165], ["functools.wraps", "inspect.getfullargspec", "dict", "old_func", "isinstance", "TypeError", "old_func", "enumerate", "kwargs.items", "utils.cast_tensor_type", "hasattr", "len", "new_args.append", "new_args.append", "utils.cast_tensor_type", "utils.cast_tensor_type"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type"], ["", "def", "force_fp32", "(", "apply_to", "=", "None", ",", "out_fp16", "=", "False", ")", ":", "\n", "    ", "\"\"\"Decorator to convert input arguments to fp32 in force.\n\n    This decorator is useful when you write custom modules and want to support\n    mixed precision training. If there are some inputs that must be processed\n    in fp32 mode, then this decorator can handle it. If inputs arguments are\n    fp16 tensors, they will be converted to fp32 automatically. Arguments other\n    than fp16 tensors are ignored.\n\n    Args:\n        apply_to (Iterable, optional): The argument names to be converted.\n            `None` indicates all arguments.\n        out_fp16 (bool): Whether to convert the output back to fp16.\n\n    Example:\n\n        >>> import torch.nn as nn\n        >>> class MyModule1(nn.Module):\n        >>>\n        >>>     # Convert x and y to fp32\n        >>>     @force_fp32()\n        >>>     def loss(self, x, y):\n        >>>         pass\n\n        >>> import torch.nn as nn\n        >>> class MyModule2(nn.Module):\n        >>>\n        >>>     # convert pred to fp32\n        >>>     @force_fp32(apply_to=('pred', ))\n        >>>     def post_process(self, pred, others):\n        >>>         pass\n    \"\"\"", "\n", "\n", "def", "force_fp32_wrapper", "(", "old_func", ")", ":", "\n", "\n", "        ", "@", "functools", ".", "wraps", "(", "old_func", ")", "\n", "def", "new_func", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# check if the module has set the attribute `fp16_enabled`, if not,", "\n", "# just fallback to the original method.", "\n", "            ", "if", "not", "isinstance", "(", "args", "[", "0", "]", ",", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "                ", "raise", "TypeError", "(", "'@force_fp32 can only be used to decorate the '", "\n", "'method of nn.Module'", ")", "\n", "", "if", "not", "(", "hasattr", "(", "args", "[", "0", "]", ",", "'fp16_enabled'", ")", "and", "args", "[", "0", "]", ".", "fp16_enabled", ")", ":", "\n", "                ", "return", "old_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# get the arg spec of the decorated method", "\n", "", "args_info", "=", "getfullargspec", "(", "old_func", ")", "\n", "# get the argument names to be casted", "\n", "args_to_cast", "=", "args_info", ".", "args", "if", "apply_to", "is", "None", "else", "apply_to", "\n", "# convert the args that need to be processed", "\n", "new_args", "=", "[", "]", "\n", "if", "args", ":", "\n", "                ", "arg_names", "=", "args_info", ".", "args", "[", ":", "len", "(", "args", ")", "]", "\n", "for", "i", ",", "arg_name", "in", "enumerate", "(", "arg_names", ")", ":", "\n", "                    ", "if", "arg_name", "in", "args_to_cast", ":", "\n", "                        ", "new_args", ".", "append", "(", "\n", "cast_tensor_type", "(", "args", "[", "i", "]", ",", "torch", ".", "half", ",", "torch", ".", "float", ")", ")", "\n", "", "else", ":", "\n", "                        ", "new_args", ".", "append", "(", "args", "[", "i", "]", ")", "\n", "# convert the kwargs that need to be processed", "\n", "", "", "", "new_kwargs", "=", "dict", "(", ")", "\n", "if", "kwargs", ":", "\n", "                ", "for", "arg_name", ",", "arg_value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                    ", "if", "arg_name", "in", "args_to_cast", ":", "\n", "                        ", "new_kwargs", "[", "arg_name", "]", "=", "cast_tensor_type", "(", "\n", "arg_value", ",", "torch", ".", "half", ",", "torch", ".", "float", ")", "\n", "", "else", ":", "\n", "                        ", "new_kwargs", "[", "arg_name", "]", "=", "arg_value", "\n", "# apply converted arguments to the decorated method", "\n", "", "", "", "output", "=", "old_func", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "# cast the results back to fp32 if necessary", "\n", "if", "out_fp16", ":", "\n", "                ", "output", "=", "cast_tensor_type", "(", "output", ",", "torch", ".", "float", ",", "torch", ".", "half", ")", "\n", "", "return", "output", "\n", "\n", "", "return", "new_func", "\n", "\n", "", "return", "force_fp32_wrapper", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.__init__": [[27, 38], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "grad_clip", "=", "None", ",", "\n", "coalesce", "=", "True", ",", "\n", "bucket_size_mb", "=", "-", "1", ",", "\n", "loss_scale", "=", "512.", ",", "\n", "distributed", "=", "True", ")", ":", "\n", "        ", "self", ".", "grad_clip", "=", "grad_clip", "\n", "self", ".", "coalesce", "=", "coalesce", "\n", "self", ".", "bucket_size_mb", "=", "bucket_size_mb", "\n", "self", ".", "loss_scale", "=", "loss_scale", "\n", "self", ".", "distributed", "=", "distributed", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.before_run": [[39, 50], ["copy.deepcopy", "hooks.wrap_fp16_model"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.wrap_fp16_model"], ["", "def", "before_run", "(", "self", ",", "runner", ")", ":", "\n", "        ", "\"\"\"Preparing steps before Mixed Precision Training.\n\n        1. Make a master copy of fp32 weights for optimization.\n        2. Convert the main model from fp32 to fp16.\n        \"\"\"", "\n", "# keep a copy of fp32 weights", "\n", "runner", ".", "optimizer", ".", "param_groups", "=", "copy", ".", "deepcopy", "(", "\n", "runner", ".", "optimizer", ".", "param_groups", ")", "\n", "# convert model to fp16", "\n", "wrap_fp16_model", "(", "runner", ".", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.copy_grads_to_fp32": [[51, 58], ["zip", "fp16_net.parameters", "fp32_param.grad.copy_", "fp32_param.data.new", "fp32_param.size"], "methods", ["None"], ["", "def", "copy_grads_to_fp32", "(", "self", ",", "fp16_net", ",", "fp32_weights", ")", ":", "\n", "        ", "\"\"\"Copy gradients from fp16 model to fp32 weight copy.\"\"\"", "\n", "for", "fp32_param", ",", "fp16_param", "in", "zip", "(", "fp32_weights", ",", "fp16_net", ".", "parameters", "(", ")", ")", ":", "\n", "            ", "if", "fp16_param", ".", "grad", "is", "not", "None", ":", "\n", "                ", "if", "fp32_param", ".", "grad", "is", "None", ":", "\n", "                    ", "fp32_param", ".", "grad", "=", "fp32_param", ".", "data", ".", "new", "(", "fp32_param", ".", "size", "(", ")", ")", "\n", "", "fp32_param", ".", "grad", ".", "copy_", "(", "fp16_param", ".", "grad", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.copy_params_to_fp16": [[59, 63], ["zip", "fp16_net.parameters", "fp16_param.data.copy_"], "methods", ["None"], ["", "", "", "def", "copy_params_to_fp16", "(", "self", ",", "fp16_net", ",", "fp32_weights", ")", ":", "\n", "        ", "\"\"\"Copy updated params from fp32 weight copy to fp16 model.\"\"\"", "\n", "for", "fp16_param", ",", "fp32_param", "in", "zip", "(", "fp16_net", ".", "parameters", "(", ")", ",", "fp32_weights", ")", ":", "\n", "            ", "fp16_param", ".", "data", ".", "copy_", "(", "fp32_param", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.after_train_iter": [[64, 97], ["runner.model.zero_grad", "runner.optimizer.zero_grad", "scaled_loss.backward", "hooks.Fp16OptimizerHook.copy_grads_to_fp32", "runner.optimizer.step", "hooks.Fp16OptimizerHook.copy_params_to_fp16", "utils.dist_utils.allreduce_grads", "hooks.Fp16OptimizerHook.clip_grads", "param.grad.div_"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.copy_grads_to_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.Fp16OptimizerHook.copy_params_to_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.dist_utils.allreduce_grads"], ["", "", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "\"\"\"Backward optimization steps for Mixed Precision Training.\n\n        1. Scale the loss by a scale factor.\n        2. Backward the loss to obtain the gradients (fp16).\n        3. Copy gradients from the model to the fp32 weight copy.\n        4. Scale the gradients back and update the fp32 weight copy.\n        5. Copy back the params from fp32 weight copy to the fp16 model.\n        \"\"\"", "\n", "# clear grads of last iteration", "\n", "runner", ".", "model", ".", "zero_grad", "(", ")", "\n", "runner", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "# scale the loss value", "\n", "scaled_loss", "=", "runner", ".", "outputs", "[", "'loss'", "]", "*", "self", ".", "loss_scale", "\n", "scaled_loss", ".", "backward", "(", ")", "\n", "# copy fp16 grads in the model to fp32 params in the optimizer", "\n", "fp32_weights", "=", "[", "]", "\n", "for", "param_group", "in", "runner", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "fp32_weights", "+=", "param_group", "[", "'params'", "]", "\n", "", "self", ".", "copy_grads_to_fp32", "(", "runner", ".", "model", ",", "fp32_weights", ")", "\n", "# allreduce grads", "\n", "if", "self", ".", "distributed", ":", "\n", "            ", "allreduce_grads", "(", "fp32_weights", ",", "self", ".", "coalesce", ",", "self", ".", "bucket_size_mb", ")", "\n", "# scale the gradients back", "\n", "", "for", "param", "in", "fp32_weights", ":", "\n", "            ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "                ", "param", ".", "grad", ".", "div_", "(", "self", ".", "loss_scale", ")", "\n", "", "", "if", "self", ".", "grad_clip", "is", "not", "None", ":", "\n", "            ", "self", ".", "clip_grads", "(", "fp32_weights", ")", "\n", "# update fp32 params", "\n", "", "runner", ".", "optimizer", ".", "step", "(", ")", "\n", "# copy fp32 params to the fp16 model", "\n", "self", ".", "copy_params_to_fp16", "(", "runner", ".", "model", ",", "fp32_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.wrap_fp16_model": [[99, 116], ["model.half", "hooks.patch_norm_fp32", "model.modules", "hasattr"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.patch_norm_fp32"], ["", "", "def", "wrap_fp16_model", "(", "model", ")", ":", "\n", "    ", "\"\"\"Wrap the FP32 model to FP16.\n\n    1. Convert FP32 model to FP16.\n    2. Remain some necessary layers to be FP32, e.g., normalization layers.\n\n    Args:\n        model (nn.Module): Model in FP32.\n    \"\"\"", "\n", "# convert model to fp16", "\n", "model", ".", "half", "(", ")", "\n", "# patch the normalization layers to make it work in fp32 mode", "\n", "patch_norm_fp32", "(", "model", ")", "\n", "# set `fp16_enabled` flag", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "hasattr", "(", "m", ",", "'fp16_enabled'", ")", ":", "\n", "            ", "m", ".", "fp16_enabled", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.patch_norm_fp32": [[118, 136], ["isinstance", "module.children", "module.float", "hooks.patch_norm_fp32", "isinstance", "hooks.patch_forward_method"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.patch_norm_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.patch_forward_method"], ["", "", "", "def", "patch_norm_fp32", "(", "module", ")", ":", "\n", "    ", "\"\"\"Recursively convert normalization layers from FP16 to FP32.\n\n    Args:\n        module (nn.Module): The modules to be converted in FP16.\n\n    Returns:\n        nn.Module: The converted module, the normalization layers have been\n            converted to FP32.\n    \"\"\"", "\n", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "modules", ".", "batchnorm", ".", "_BatchNorm", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "        ", "module", ".", "float", "(", ")", "\n", "if", "isinstance", "(", "module", ",", "nn", ".", "GroupNorm", ")", "or", "torch", ".", "__version__", "==", "'parrots'", ":", "\n", "            ", "module", ".", "forward", "=", "patch_forward_method", "(", "module", ".", "forward", ",", "torch", ".", "half", ",", "\n", "torch", ".", "float", ")", "\n", "", "", "for", "child", "in", "module", ".", "children", "(", ")", ":", "\n", "        ", "patch_norm_fp32", "(", "child", ")", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.patch_forward_method": [[138, 159], ["func", "utils.cast_tensor_type", "utils.cast_tensor_type", "utils.cast_tensor_type", "torch.half", "torch.half", "torch.float", "torch.float"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type"], ["", "def", "patch_forward_method", "(", "func", ",", "src_type", ",", "dst_type", ",", "convert_output", "=", "True", ")", ":", "\n", "    ", "\"\"\"Patch the forward method of a module.\n\n    Args:\n        func (callable): The original forward method.\n        src_type (torch.dtype): Type of input arguments to be converted from.\n        dst_type (torch.dtype): Type of input arguments to be converted to.\n        convert_output (bool): Whether to convert the output back to src_type.\n\n    Returns:\n        callable: The patched forward method.\n    \"\"\"", "\n", "\n", "def", "new_forward", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "output", "=", "func", "(", "*", "cast_tensor_type", "(", "args", ",", "src_type", ",", "dst_type", ")", ",", "\n", "**", "cast_tensor_type", "(", "kwargs", ",", "src_type", ",", "dst_type", ")", ")", "\n", "if", "convert_output", ":", "\n", "            ", "output", "=", "cast_tensor_type", "(", "output", ",", "dst_type", ",", "src_type", ")", "\n", "", "return", "output", "\n", "\n", "", "return", "new_forward", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type": [[7, 34], ["isinstance", "inputs.to", "isinstance", "isinstance", "isinstance", "isinstance", "type", "utils.cast_tensor_type", "type", "inputs.items", "utils.cast_tensor_type"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type"], ["    ", "\"\"\"Reduce loss as specified.\n\n    Args:\n        loss (Tensor): Elementwise loss tensor.\n        reduction (str): Options are \"none\", \"mean\" and \"sum\".\n\n    Return:\n        Tensor: Reduced loss tensor.\n    \"\"\"", "\n", "reduction_enum", "=", "F", ".", "_Reduction", ".", "get_enum", "(", "reduction", ")", "\n", "# none: 0, elementwise_mean:1, sum: 2", "\n", "if", "reduction_enum", "==", "0", ":", "\n", "        ", "return", "loss", "\n", "", "elif", "reduction_enum", "==", "1", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "elif", "reduction_enum", "==", "2", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "\n", "\n", "", "", "def", "weight_reduce_loss", "(", "loss", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "avg_factor", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_proposals": [[8, 48], ["zip", "torch.cat", "mmcv.ops.nms", "scores.sort", "min", "proposals.clone", "bbox.bbox_mapping_back", "recovered_proposals.append", "aug_proposals[].contiguous", "aug_proposals[].contiguous"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping_back"], ["def", "merge_aug_proposals", "(", "aug_proposals", ",", "img_metas", ",", "rpn_test_cfg", ")", ":", "\n", "    ", "\"\"\"Merge augmented proposals (multiscale, flip, etc.)\n\n    Args:\n        aug_proposals (list[Tensor]): proposals from different testing\n            schemes, shape (n, 5). Note that they are not rescaled to the\n            original image size.\n\n        img_metas (list[dict]): list of image info dict where each dict has:\n            'img_shape', 'scale_factor', 'flip', and my also contain\n            'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n            For details on the values of these keys see\n            `mmdet/datasets/pipelines/formatting.py:Collect`.\n\n        rpn_test_cfg (dict): rpn test config.\n\n    Returns:\n        Tensor: shape (n, 4), proposals corresponding to original image scale.\n    \"\"\"", "\n", "recovered_proposals", "=", "[", "]", "\n", "for", "proposals", ",", "img_info", "in", "zip", "(", "aug_proposals", ",", "img_metas", ")", ":", "\n", "        ", "img_shape", "=", "img_info", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_info", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_info", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_info", "[", "'flip_direction'", "]", "\n", "_proposals", "=", "proposals", ".", "clone", "(", ")", "\n", "_proposals", "[", ":", ",", ":", "4", "]", "=", "bbox_mapping_back", "(", "_proposals", "[", ":", ",", ":", "4", "]", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ",", "\n", "flip_direction", ")", "\n", "recovered_proposals", ".", "append", "(", "_proposals", ")", "\n", "", "aug_proposals", "=", "torch", ".", "cat", "(", "recovered_proposals", ",", "dim", "=", "0", ")", "\n", "merged_proposals", ",", "_", "=", "nms", "(", "aug_proposals", "[", ":", ",", ":", "4", "]", ".", "contiguous", "(", ")", ",", "\n", "aug_proposals", "[", ":", ",", "-", "1", "]", ".", "contiguous", "(", ")", ",", "\n", "rpn_test_cfg", ".", "nms_thr", ")", "\n", "scores", "=", "merged_proposals", "[", ":", ",", "4", "]", "\n", "_", ",", "order", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "num", "=", "min", "(", "rpn_test_cfg", ".", "max_num", ",", "merged_proposals", ".", "shape", "[", "0", "]", ")", "\n", "order", "=", "order", "[", ":", "num", "]", "\n", "merged_proposals", "=", "merged_proposals", "[", "order", ",", ":", "]", "\n", "return", "merged_proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_bboxes": [[50, 84], ["zip", "bbox.bbox_mapping_back", "recovered_bboxes.append", "torch.stack().mean", "torch.cat", "torch.stack().mean", "torch.cat", "torch.stack", "torch.stack"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping_back"], ["", "def", "merge_aug_bboxes", "(", "aug_bboxes", ",", "aug_scores", ",", "img_metas", ",", "rcnn_test_cfg", ",", "\n", "return_mean", "=", "True", ")", ":", "\n", "    ", "\"\"\"Merge augmented detection bboxes and scores.\n\n    Args:\n        aug_bboxes (list[Tensor]): shape (n, 4*#class)\n        aug_scores (list[Tensor] or None): shape (n, #class)\n        img_shapes (list[Tensor]): shape (3, ).\n        rcnn_test_cfg (dict): rcnn test config.\n\n    Returns:\n        tuple: (bboxes, scores)\n    \"\"\"", "\n", "recovered_bboxes", "=", "[", "]", "\n", "for", "bboxes", ",", "img_info", "in", "zip", "(", "aug_bboxes", ",", "img_metas", ")", ":", "\n", "        ", "img_shape", "=", "img_info", "[", "'img_shape'", "]", "\n", "scale_factor", "=", "img_info", "[", "'scale_factor'", "]", "\n", "flip", "=", "img_info", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_info", "[", "'flip_direction'", "]", "\n", "bboxes", "=", "bbox_mapping_back", "(", "bboxes", ",", "img_shape", ",", "scale_factor", ",", "flip", ",", "\n", "flip_direction", ")", "\n", "recovered_bboxes", ".", "append", "(", "bboxes", ")", "\n", "", "if", "return_mean", ":", "\n", "        ", "bboxes", "=", "torch", ".", "stack", "(", "recovered_bboxes", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "bboxes", "=", "torch", ".", "cat", "(", "recovered_bboxes", ",", "dim", "=", "0", ")", "\n", "", "if", "aug_scores", "is", "None", ":", "\n", "        ", "return", "bboxes", "\n", "", "else", ":", "\n", "        ", "if", "return_mean", ":", "\n", "            ", "scores", "=", "torch", ".", "stack", "(", "aug_scores", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "torch", ".", "cat", "(", "aug_scores", ",", "dim", "=", "0", ")", "\n", "", "return", "bboxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_scores": [[86, 92], ["isinstance", "torch.mean", "numpy.mean", "torch.stack"], "function", ["None"], ["", "", "def", "merge_aug_scores", "(", "aug_scores", ")", ":", "\n", "    ", "\"\"\"Merge augmented bbox scores.\"\"\"", "\n", "if", "isinstance", "(", "aug_scores", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "aug_scores", ")", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "mean", "(", "aug_scores", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.merge_augs.merge_aug_masks": [[94, 125], ["zip", "recovered_masks.append", "numpy.mean", "numpy.average", "numpy.array", "numpy.array", "ValueError"], "function", ["None"], ["", "", "def", "merge_aug_masks", "(", "aug_masks", ",", "img_metas", ",", "rcnn_test_cfg", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"Merge augmented mask prediction.\n\n    Args:\n        aug_masks (list[ndarray]): shape (n, #class, h, w)\n        img_shapes (list[ndarray]): shape (3, ).\n        rcnn_test_cfg (dict): rcnn test config.\n\n    Returns:\n        tuple: (bboxes, scores)\n    \"\"\"", "\n", "recovered_masks", "=", "[", "]", "\n", "for", "mask", ",", "img_info", "in", "zip", "(", "aug_masks", ",", "img_metas", ")", ":", "\n", "        ", "flip", "=", "img_info", "[", "'flip'", "]", "\n", "flip_direction", "=", "img_info", "[", "'flip_direction'", "]", "\n", "if", "flip", ":", "\n", "            ", "if", "flip_direction", "==", "'horizontal'", ":", "\n", "                ", "mask", "=", "mask", "[", ":", ",", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "", "elif", "flip_direction", "==", "'vertical'", ":", "\n", "                ", "mask", "=", "mask", "[", ":", ",", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Invalid flipping direction '{flip_direction}'\"", ")", "\n", "", "", "recovered_masks", ".", "append", "(", "mask", ")", "\n", "\n", "", "if", "weights", "is", "None", ":", "\n", "        ", "merged_masks", "=", "np", ".", "mean", "(", "recovered_masks", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "merged_masks", "=", "np", ".", "average", "(", "\n", "np", ".", "array", "(", "recovered_masks", ")", ",", "axis", "=", "0", ",", "weights", "=", "np", ".", "array", "(", "weights", ")", ")", "\n", "", "return", "merged_masks", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.combine_panoptic.combine_to_panoptic": [[29, 120], ["utils.IdGenerator", "enumerate", "numpy.zeros", "img[].replace", "enumerate", "panoptic_json.append", "os.join", "os.dirname", "mmcv.mkdir_or_exist", "PIL.fromarray().save", "print", "pycocotools.mask.area", "pycocotools.mask.merge", "utils.IdGenerator.get_id", "segments_info.append", "numpy.logical_and", "utils.IdGenerator.get_id", "segments_info.append", "os.abspath", "copy.deepcopy", "pycocotools.mask.area", "pycocotools.mask.decode", "numpy.logical_and", "[].update", "pycocotools.mask.decode", "np.logical_and.sum", "numpy.zeros", "numpy.logical_and", "utils.IdGenerator.get_id", "ann.get", "segments_info.append", "PIL.fromarray", "len", "pycocotools.mask.merge", "dict", "int", "int", "int", "int", "np.logical_and.sum", "np.zeros.sum", "utils.id2rgb"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.id2rgb"], ["def", "combine_to_panoptic", "(", "proc_id", ",", "img_ids", ",", "img_id2img", ",", "inst_by_image", ",", "\n", "sem_by_image", ",", "bbox_by_image", ",", "segmentations_folder", ",", "\n", "bbox_overlap_thr", ",", "overlap_thr", ",", "stuff_area_limit", ",", "\n", "categories", ",", "using_bbox", "=", "False", ")", ":", "\n", "    ", "panoptic_json", "=", "[", "]", "\n", "id_generator", "=", "IdGenerator", "(", "categories", ")", "\n", "\n", "for", "idx", ",", "img_id", "in", "enumerate", "(", "img_ids", ")", ":", "\n", "        ", "img", "=", "img_id2img", "[", "img_id", "]", "\n", "\n", "if", "idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "'Core: {}, {} from {} images processed.'", ".", "\n", "format", "(", "proc_id", ",", "idx", ",", "len", "(", "img_ids", ")", ")", ")", "\n", "\n", "", "pan_segm_id", "=", "np", ".", "zeros", "(", "(", "img", "[", "'height'", "]", ",", "img", "[", "'width'", "]", ")", ",", "\n", "dtype", "=", "np", ".", "uint32", ")", "\n", "used", "=", "None", "\n", "annotation", "=", "{", "}", "\n", "annotation", "[", "'image_id'", "]", "=", "img_id", "\n", "annotation", "[", "'file_name'", "]", "=", "img", "[", "'file_name'", "]", ".", "replace", "(", "'.jpg'", ",", "'.png'", ")", "\n", "\n", "segments_info", "=", "[", "]", "\n", "for", "ann_id", ",", "ann", "in", "enumerate", "(", "inst_by_image", "[", "img_id", "]", ")", ":", "\n", "            ", "area", "=", "COCOmask", ".", "area", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "if", "area", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "used", "is", "None", ":", "\n", "                ", "intersect", "=", "0", "\n", "used", "=", "copy", ".", "deepcopy", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "", "else", ":", "\n", "                ", "intersect", "=", "COCOmask", ".", "area", "(", "\n", "COCOmask", ".", "merge", "(", "[", "used", ",", "ann", "[", "'segmentation'", "]", "]", ",", "intersect", "=", "True", ")", "\n", ")", "\n", "", "if", "intersect", "/", "area", ">", "overlap_thr", ":", "\n", "                ", "continue", "\n", "", "used", "=", "COCOmask", ".", "merge", "(", "[", "used", ",", "ann", "[", "'segmentation'", "]", "]", ",", "intersect", "=", "False", ")", "\n", "\n", "mask", "=", "COCOmask", ".", "decode", "(", "ann", "[", "'segmentation'", "]", ")", "==", "1", "\n", "if", "intersect", "!=", "0", ":", "\n", "                ", "mask", "=", "np", ".", "logical_and", "(", "pan_segm_id", "==", "0", ",", "mask", ")", "\n", "", "segment_id", "=", "id_generator", ".", "get_id", "(", "ann", "[", "'category_id'", "]", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "ann", "[", "'category_id'", "]", "\n", "pan_segm_id", "[", "mask", "]", "=", "segment_id", "\n", "if", "using_bbox", ":", "\n", "                ", "bbox_by_image", "[", "img_id", "]", "[", "ann_id", "]", ".", "update", "(", "\n", "dict", "(", "segment_id", "=", "segment_id", ")", ")", "\n", "", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "for", "ann", "in", "sem_by_image", "[", "img_id", "]", ":", "\n", "            ", "mask", "=", "COCOmask", ".", "decode", "(", "ann", "[", "'segmentation'", "]", ")", "==", "1", "\n", "mask_left", "=", "np", ".", "logical_and", "(", "pan_segm_id", "==", "0", ",", "mask", ")", "\n", "if", "mask_left", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                ", "continue", "\n", "", "segment_id", "=", "id_generator", ".", "get_id", "(", "ann", "[", "'category_id'", "]", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "ann", "[", "'category_id'", "]", "\n", "pan_segm_id", "[", "mask_left", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "if", "using_bbox", ":", "\n", "            ", "for", "ann", "in", "bbox_by_image", "[", "img_id", "]", ":", "\n", "                ", "bbox", "=", "[", "int", "(", "ann", "[", "'bbox'", "]", "[", "0", "]", ")", ",", "int", "(", "ann", "[", "'bbox'", "]", "[", "1", "]", ")", ",", "\n", "int", "(", "ann", "[", "'bbox'", "]", "[", "0", "]", "+", "ann", "[", "'bbox'", "]", "[", "2", "]", ")", ",", "\n", "int", "(", "ann", "[", "'bbox'", "]", "[", "1", "]", "+", "ann", "[", "'bbox'", "]", "[", "3", "]", ")", "]", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "img", "[", "'height'", "]", ",", "img", "[", "'width'", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "bbox", "[", "1", "]", ":", "bbox", "[", "3", "]", ",", "bbox", "[", "0", "]", ":", "bbox", "[", "2", "]", "]", "=", "1", "\n", "mask_left", "=", "np", ".", "logical_and", "(", "pan_segm_id", "==", "0", ",", "mask", "==", "1", ")", "\n", "overlap", "=", "mask_left", ".", "sum", "(", ")", "/", "mask", ".", "sum", "(", ")", "\n", "if", "overlap", "<", "bbox_overlap_thr", ":", "\n", "                    ", "continue", "\n", "", "generated_id", "=", "id_generator", ".", "get_id", "(", "ann", "[", "'category_id'", "]", ")", "\n", "segment_id", "=", "ann", ".", "get", "(", "'segment_id'", ",", "generated_id", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "ann", "[", "'category_id'", "]", "\n", "pan_segm_id", "[", "mask_left", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "", "annotation", "[", "'segments_info'", "]", "=", "segments_info", "\n", "panoptic_json", ".", "append", "(", "annotation", ")", "\n", "save_image_path", "=", "osp", ".", "join", "(", "\n", "segmentations_folder", ",", "annotation", "[", "'file_name'", "]", ")", "\n", "dir_name", "=", "osp", ".", "dirname", "(", "osp", ".", "abspath", "(", "save_image_path", ")", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "dir_name", ")", "\n", "\n", "Image", ".", "fromarray", "(", "id2rgb", "(", "pan_segm_id", ")", ")", ".", "save", "(", "save_image_path", ")", "\n", "\n", "", "return", "panoptic_json", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.combine_panoptic.combine_panoptic_predictions": [[122, 218], ["time.time", "mmcv.load", "mmcv.load", "mmcv.load", "mmcv.load", "mmcv.load", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "collections.defaultdict", "collections.defaultdict.keys", "collections.defaultdict", "collections.defaultdict.keys", "collections.defaultdict", "list", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "mmcv.load", "list", "mmcv.dump", "print", "len", "len", "os.isdir", "print", "os.mkdir", "os.mkdir", "inst_by_image[].append", "sorted", "bbox_by_image[].append", "sorted", "sem_by_image[].append", "img_id2img.keys", "multiprocessing.Pool.apply_async", "processes.append", "panoptic_json.extend", "categories.values", "time.time", "panoptic_json_file.rsplit", "len", "len", "len", "workers.apply_async.get"], "function", ["None"], ["", "def", "combine_panoptic_predictions", "(", "semseg_json_file", ",", "\n", "instseg_json_file", ",", "\n", "bbox_json_file", ",", "\n", "images_json_file", ",", "\n", "categories_json_file", ",", "\n", "segmentations_folder", ",", "\n", "panoptic_json_file", ",", "\n", "confidence_thr", ",", "\n", "bbox_overlap_thr", ",", "\n", "overlap_thr", ",", "\n", "stuff_area_limit", ",", "\n", "using_bbox", "=", "False", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "sem_results", "=", "mmcv", ".", "load", "(", "semseg_json_file", ")", "\n", "inst_results", "=", "mmcv", ".", "load", "(", "instseg_json_file", ")", "\n", "bbox_results", "=", "mmcv", ".", "load", "(", "bbox_json_file", ")", "\n", "assert", "len", "(", "bbox_results", ")", "==", "len", "(", "inst_results", ")", "\n", "images_d", "=", "mmcv", ".", "load", "(", "images_json_file", ")", "\n", "img_id2img", "=", "{", "img", "[", "'id'", "]", ":", "img", "for", "img", "in", "images_d", "[", "'images'", "]", "}", "\n", "\n", "categories_list", "=", "mmcv", ".", "load", "(", "categories_json_file", ")", "\n", "categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "categories_list", "}", "\n", "\n", "if", "segmentations_folder", "is", "None", ":", "\n", "        ", "segmentations_folder", "=", "panoptic_json_file", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "", "if", "not", "osp", ".", "isdir", "(", "segmentations_folder", ")", ":", "\n", "        ", "print", "(", "\"Creating folder {} for panoptic segmentation PNGs\"", ".", "\n", "format", "(", "segmentations_folder", ")", ")", "\n", "os", ".", "mkdir", "(", "segmentations_folder", ")", "\n", "\n", "", "print", "(", "\"Combining:\"", ")", "\n", "print", "(", "\"Semantic segmentation:\"", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "semseg_json_file", ")", ")", "\n", "print", "(", "\"and\"", ")", "\n", "print", "(", "\"Instance segmentations:\"", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "instseg_json_file", ")", ")", "\n", "print", "(", "\"into\"", ")", "\n", "print", "(", "\"Panoptic segmentations:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "segmentations_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "panoptic_json_file", ")", ")", "\n", "print", "(", "\"List of images to combine is takes from {}\"", ".", "\n", "format", "(", "images_json_file", ")", ")", "\n", "print", "(", "'\\n'", ")", "\n", "\n", "inst_by_image", "=", "defaultdict", "(", "list", ")", "\n", "for", "inst", "in", "inst_results", ":", "\n", "        ", "if", "inst", "[", "'score'", "]", "<", "confidence_thr", ":", "\n", "            ", "continue", "\n", "", "inst_by_image", "[", "inst", "[", "'image_id'", "]", "]", ".", "append", "(", "inst", ")", "\n", "", "for", "img_id", "in", "inst_by_image", ".", "keys", "(", ")", ":", "\n", "        ", "inst_by_image", "[", "img_id", "]", "=", "sorted", "(", "inst_by_image", "[", "img_id", "]", ",", "\n", "key", "=", "lambda", "el", ":", "-", "el", "[", "'score'", "]", ")", "\n", "", "bbox_by_image", "=", "defaultdict", "(", "list", ")", "\n", "for", "bbox", "in", "bbox_results", ":", "\n", "        ", "if", "bbox", "[", "'score'", "]", "<", "confidence_thr", ":", "\n", "            ", "continue", "\n", "", "bbox_by_image", "[", "bbox", "[", "'image_id'", "]", "]", ".", "append", "(", "bbox", ")", "\n", "", "for", "img_id", "in", "bbox_by_image", ".", "keys", "(", ")", ":", "\n", "        ", "assert", "len", "(", "bbox_by_image", "[", "img_id", "]", ")", "==", "len", "(", "inst_by_image", "[", "img_id", "]", ")", "\n", "bbox_by_image", "[", "img_id", "]", "=", "sorted", "(", "bbox_by_image", "[", "img_id", "]", ",", "\n", "key", "=", "lambda", "el", ":", "-", "el", "[", "'score'", "]", ")", "\n", "\n", "", "sem_by_image", "=", "defaultdict", "(", "list", ")", "\n", "for", "sem", "in", "sem_results", ":", "\n", "        ", "if", "(", "sem", "[", "'category_id'", "]", "==", "183", ")", "or", "(", "categories", "[", "sem", "[", "'category_id'", "]", "]", "[", "'isthing'", "]", "==", "1", ")", ":", "\n", "            ", "continue", "\n", "", "sem_by_image", "[", "sem", "[", "'image_id'", "]", "]", ".", "append", "(", "sem", ")", "\n", "\n", "", "imgs_ids_all", "=", "list", "(", "img_id2img", ".", "keys", "(", ")", ")", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "img_ids_split", "=", "np", ".", "array_split", "(", "imgs_ids_all", ",", "cpu_num", ")", "\n", "print", "(", "\"Number of cores: {}, images per core: {}\"", ".", "\n", "format", "(", "cpu_num", ",", "len", "(", "img_ids_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "img_ids", "in", "enumerate", "(", "img_ids_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "combine_to_panoptic", ",", "\n", "(", "proc_id", ",", "img_ids", ",", "img_id2img", ",", "inst_by_image", ",", "\n", "sem_by_image", ",", "bbox_by_image", ",", "\n", "segmentations_folder", ",", "bbox_overlap_thr", ",", "\n", "overlap_thr", ",", "stuff_area_limit", ",", "categories", ",", "\n", "using_bbox", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "panoptic_json", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "panoptic_json", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "\n", "", "coco_d", "=", "mmcv", ".", "load", "(", "images_json_file", ")", "\n", "coco_d", "[", "'annotations'", "]", "=", "panoptic_json", "\n", "coco_d", "[", "'categories'", "]", "=", "list", "(", "categories", ".", "values", "(", ")", ")", "\n", "mmcv", ".", "dump", "(", "coco_d", ",", "panoptic_json_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.post_processing.bbox_nms.multiclass_nms": [[5, 70], ["torch.masked_select().view", "torch.masked_select", "mmcv.ops.nms.batched_nms", "multi_scores.size", "multi_bboxes.view", "multi_bboxes[].expand", "valid_mask.nonzero", "multi_bboxes.new_zeros.numel", "multi_bboxes.new_zeros", "multi_bboxes.new_zeros", "torch.onnx.is_in_onnx_export", "multi_scores.size", "multi_scores.size", "torch.masked_select", "RuntimeError", "torch.stack"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["def", "multiclass_nms", "(", "multi_bboxes", ",", "\n", "multi_scores", ",", "\n", "score_thr", ",", "\n", "nms_cfg", ",", "\n", "max_num", "=", "-", "1", ",", "\n", "score_factors", "=", "None", ")", ":", "\n", "    ", "\"\"\"NMS for multi-class bboxes.\n\n    Args:\n        multi_bboxes (Tensor): shape (n, #class*4) or (n, 4)\n        multi_scores (Tensor): shape (n, #class), where the last column\n            contains scores of the background class, but this will be ignored.\n        score_thr (float): bbox threshold, bboxes with scores lower than it\n            will not be considered.\n        nms_thr (float): NMS IoU threshold\n        max_num (int): if there are more than max_num bboxes after NMS,\n            only top max_num will be kept.\n        score_factors (Tensor): The factors multiplied to scores before\n            applying NMS\n\n    Returns:\n        tuple: (bboxes, labels), tensors of shape (k, 5) and (k, 1). Labels \\\n            are 0-based.\n    \"\"\"", "\n", "num_classes", "=", "multi_scores", ".", "size", "(", "1", ")", "-", "1", "\n", "# exclude background category", "\n", "if", "multi_bboxes", ".", "shape", "[", "1", "]", ">", "4", ":", "\n", "        ", "bboxes", "=", "multi_bboxes", ".", "view", "(", "multi_scores", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "", "else", ":", "\n", "        ", "bboxes", "=", "multi_bboxes", "[", ":", ",", "None", "]", ".", "expand", "(", "\n", "multi_scores", ".", "size", "(", "0", ")", ",", "num_classes", ",", "4", ")", "\n", "", "scores", "=", "multi_scores", "[", ":", ",", ":", "-", "1", "]", "\n", "\n", "# filter out boxes with low scores", "\n", "valid_mask", "=", "scores", ">", "score_thr", "\n", "\n", "# We use masked_select for ONNX exporting purpose,", "\n", "# which is equivalent to bboxes = bboxes[valid_mask]", "\n", "# (TODO): as ONNX does not support repeat now,", "\n", "# we have to use this ugly code", "\n", "bboxes", "=", "torch", ".", "masked_select", "(", "\n", "bboxes", ",", "\n", "torch", ".", "stack", "(", "(", "valid_mask", ",", "valid_mask", ",", "valid_mask", ",", "valid_mask", ")", ",", "\n", "-", "1", ")", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "if", "score_factors", "is", "not", "None", ":", "\n", "        ", "scores", "=", "scores", "*", "score_factors", "[", ":", ",", "None", "]", "\n", "", "scores", "=", "torch", ".", "masked_select", "(", "scores", ",", "valid_mask", ")", "\n", "labels", "=", "valid_mask", ".", "nonzero", "(", ")", "[", ":", ",", "1", "]", "\n", "\n", "if", "bboxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "bboxes", "=", "multi_bboxes", ".", "new_zeros", "(", "(", "0", ",", "5", ")", ")", "\n", "labels", "=", "multi_bboxes", ".", "new_zeros", "(", "(", "0", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'[ONNX Error] Can not record NMS '", "\n", "'as it has not been executed this time'", ")", "\n", "", "return", "bboxes", ",", "labels", "\n", "\n", "", "dets", ",", "keep", "=", "batched_nms", "(", "bboxes", ",", "scores", ",", "labels", ",", "nms_cfg", ")", "\n", "\n", "if", "max_num", ">", "0", ":", "\n", "        ", "dets", "=", "dets", "[", ":", "max_num", "]", "\n", "keep", "=", "keep", "[", ":", "max_num", "]", "\n", "\n", "", "return", "dets", ",", "labels", "[", "keep", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.mask_target.mask_target": [[6, 29], ["map", "list", "len", "torch.cat", "range", "len"], "function", ["None"], ["def", "mask_target", "(", "pos_proposals_list", ",", "pos_assigned_gt_inds_list", ",", "gt_masks_list", ",", "\n", "cfg", ")", ":", "\n", "    ", "\"\"\"Compute mask target for positive proposals in multiple images.\n\n    Args:\n        pos_proposals_list (list[Tensor]): Positive proposals in multiple\n            images.\n        pos_assigned_gt_inds_list (list[Tensor]): Assigned GT indices for each\n            positive proposals.\n        gt_masks_list (list[:obj:`BaseInstanceMasks`]): Ground truth masks of\n            each image.\n        cfg (dict): Config dict that specifies the mask size.\n\n    Returns:\n        list[Tensor]: Mask target of each image.\n    \"\"\"", "\n", "cfg_list", "=", "[", "cfg", "for", "_", "in", "range", "(", "len", "(", "pos_proposals_list", ")", ")", "]", "\n", "mask_targets", "=", "map", "(", "mask_target_single", ",", "pos_proposals_list", ",", "\n", "pos_assigned_gt_inds_list", ",", "gt_masks_list", ",", "cfg_list", ")", "\n", "mask_targets", "=", "list", "(", "mask_targets", ")", "\n", "if", "len", "(", "mask_targets", ")", ">", "0", ":", "\n", "        ", "mask_targets", "=", "torch", ".", "cat", "(", "mask_targets", ")", "\n", "", "return", "mask_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.mask_target.mask_target_single": [[31, 63], ["torch.nn.modules.utils._pair", "pos_proposals.size", "pos_proposals.cpu().numpy", "numpy.clip", "numpy.clip", "pos_assigned_gt_inds.cpu().numpy.cpu().numpy", "gt_masks.crop_and_resize().to_ndarray", "torch.from_numpy().float().to", "pos_proposals.new_zeros", "pos_proposals.cpu", "pos_assigned_gt_inds.cpu().numpy.cpu", "gt_masks.crop_and_resize", "torch.from_numpy().float", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize"], ["", "def", "mask_target_single", "(", "pos_proposals", ",", "pos_assigned_gt_inds", ",", "gt_masks", ",", "cfg", ")", ":", "\n", "    ", "\"\"\"Compute mask target for each positive proposal in the image.\n\n    Args:\n        pos_proposals (Tensor): Positive proposals.\n        pos_assigned_gt_inds (Tensor): Assigned GT inds of positive proposals.\n        gt_masks (:obj:`BaseInstanceMasks`): GT masks in the format of Bitmap\n            or Polygon.\n        cfg (dict): Config dict that indicate the mask size.\n\n    Returns:\n        Tensor: Mask target of each positive proposals in the image.\n    \"\"\"", "\n", "device", "=", "pos_proposals", ".", "device", "\n", "mask_size", "=", "_pair", "(", "cfg", ".", "mask_size", ")", "\n", "num_pos", "=", "pos_proposals", ".", "size", "(", "0", ")", "\n", "if", "num_pos", ">", "0", ":", "\n", "        ", "proposals_np", "=", "pos_proposals", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "maxh", ",", "maxw", "=", "gt_masks", ".", "height", ",", "gt_masks", ".", "width", "\n", "proposals_np", "[", ":", ",", "[", "0", ",", "2", "]", "]", "=", "np", ".", "clip", "(", "proposals_np", "[", ":", ",", "[", "0", ",", "2", "]", "]", ",", "0", ",", "maxw", ")", "\n", "proposals_np", "[", ":", ",", "[", "1", ",", "3", "]", "]", "=", "np", ".", "clip", "(", "proposals_np", "[", ":", ",", "[", "1", ",", "3", "]", "]", ",", "0", ",", "maxh", ")", "\n", "pos_assigned_gt_inds", "=", "pos_assigned_gt_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "mask_targets", "=", "gt_masks", ".", "crop_and_resize", "(", "\n", "proposals_np", ",", "mask_size", ",", "device", "=", "device", ",", "\n", "inds", "=", "pos_assigned_gt_inds", ")", ".", "to_ndarray", "(", ")", "\n", "\n", "mask_targets", "=", "torch", ".", "from_numpy", "(", "mask_targets", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "mask_targets", "=", "pos_proposals", ".", "new_zeros", "(", "(", "0", ",", ")", "+", "mask_size", ")", "\n", "\n", "", "return", "mask_targets", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.rescale": [[13, 26], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "rescale", "(", "self", ",", "scale", ",", "interpolation", "=", "'nearest'", ")", ":", "\n", "        ", "\"\"\"Rescale masks as large as possible while keeping the aspect ratio.\n        For details can refer to `mmcv.imrescale`.\n\n        Args:\n            scale (tuple[int]): The maximum size (h, w) of rescaled mask.\n            interpolation (str): Same as :func:`mmcv.imrescale`.\n\n        Returns:\n            BaseInstanceMasks: The rescaled masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.resize": [[27, 39], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "resize", "(", "self", ",", "out_shape", ",", "interpolation", "=", "'nearest'", ")", ":", "\n", "        ", "\"\"\"Resize masks to the given out_shape.\n\n        Args:\n            out_shape: Target (h, w) of resized mask.\n            interpolation (str): See :func:`mmcv.imresize`.\n\n        Returns:\n            BaseInstanceMasks: The resized masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.flip": [[40, 51], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "flip", "(", "self", ",", "flip_direction", "=", "'horizontal'", ")", ":", "\n", "        ", "\"\"\"Flip masks alone the given direction.\n\n        Args:\n            flip_direction (str): Either 'horizontal' or 'vertical'.\n\n        Returns:\n            BaseInstanceMasks: The flipped masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.pad": [[52, 64], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "pad", "(", "self", ",", "out_shape", ",", "pad_val", ")", ":", "\n", "        ", "\"\"\"Pad masks to the given size of (h, w).\n\n        Args:\n            out_shape (tuple[int]): Target (h, w) of padded mask.\n            pad_val (int): The padded value.\n\n        Returns:\n            BaseInstanceMasks: The padded masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.crop": [[65, 76], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "crop", "(", "self", ",", "bbox", ")", ":", "\n", "        ", "\"\"\"Crop each mask by the given bbox.\n\n        Args:\n            bbox (ndarray): Bbox in format [x1, y1, x2, y2], shape (4, ).\n\n        Return:\n            BaseInstanceMasks: The cropped masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.crop_and_resize": [[77, 101], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "crop_and_resize", "(", "self", ",", "\n", "bboxes", ",", "\n", "out_shape", ",", "\n", "inds", ",", "\n", "device", ",", "\n", "interpolation", "=", "'bilinear'", ")", ":", "\n", "        ", "\"\"\"Crop and resize masks by the given bboxes.\n\n        This function is mainly used in mask targets computation.\n        It firstly align mask to bboxes by assigned_inds, then crop mask by the\n        assigned bbox and resize to the size of (mask_h, mask_w)\n\n        Args:\n            bboxes (Tensor): Bboxes in format [x1, y1, x2, y2], shape (N, 4)\n            out_shape (tuple[int]): Target (h, w) of resized mask\n            inds (ndarray): Indexes to assign masks to each bbox\n            device (str): Device of bboxes\n            interpolation (str): See `mmcv.imresize`\n\n        Return:\n            BaseInstanceMasks: the cropped and resized masks.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.expand": [[102, 106], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "expand", "(", "self", ",", "expanded_h", ",", "expanded_w", ",", "top", ",", "left", ")", ":", "\n", "        ", "\"\"\"see :class:`Expand`.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.areas": [[107, 112], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "areas", "(", "self", ")", ":", "\n", "        ", "\"\"\"ndarray: areas of each instance.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.to_ndarray": [[113, 121], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "to_ndarray", "(", "self", ")", ":", "\n", "        ", "\"\"\"Convert masks to the format of ndarray.\n\n        Return:\n            ndarray: Converted masks in the format of ndarray.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BaseInstanceMasks.to_tensor": [[122, 134], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "to_tensor", "(", "self", ",", "dtype", ",", "device", ")", ":", "\n", "        ", "\"\"\"Convert masks to the format of Tensor.\n\n        Args:\n            dtype (str): Dtype of converted mask.\n            device (torch.device): Device of converted masks.\n\n        Returns:\n            Tensor: Converted masks in the format of Tensor.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.__init__": [[146, 162], ["len", "numpy.empty", "isinstance", "isinstance", "numpy.stack().reshape", "isinstance", "numpy.stack"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "masks", ",", "height", ",", "width", ")", ":", "\n", "        ", "self", ".", "height", "=", "height", "\n", "self", ".", "width", "=", "width", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "            ", "self", ".", "masks", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "masks", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", "\n", "if", "isinstance", "(", "masks", ",", "list", ")", ":", "\n", "                ", "assert", "isinstance", "(", "masks", "[", "0", "]", ",", "np", ".", "ndarray", ")", "\n", "assert", "masks", "[", "0", "]", ".", "ndim", "==", "2", "# (H, W)", "\n", "", "else", ":", "\n", "                ", "assert", "masks", ".", "ndim", "==", "3", "# (N, H, W)", "\n", "\n", "", "self", ".", "masks", "=", "np", ".", "stack", "(", "masks", ")", ".", "reshape", "(", "-", "1", ",", "height", ",", "width", ")", "\n", "assert", "self", ".", "masks", ".", "shape", "[", "1", "]", "==", "self", ".", "height", "\n", "assert", "self", ".", "masks", ".", "shape", "[", "2", "]", "==", "self", ".", "width", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.__getitem__": [[163, 174], ["structures.BitmapMasks.masks[].reshape", "structures.BitmapMasks"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Index the BitmapMask.\n\n        Args:\n            index (int | ndarray): Indices in the format of integer or ndarray.\n\n        Returns:\n            :obj:`BitmapMasks`: Indexed bitmap masks.\n        \"\"\"", "\n", "masks", "=", "self", ".", "masks", "[", "index", "]", ".", "reshape", "(", "-", "1", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "return", "BitmapMasks", "(", "masks", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.__iter__": [[175, 177], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.__repr__": [[178, 184], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "s", "+=", "f'num_masks={len(self.masks)}, '", "\n", "s", "+=", "f'height={self.height}, '", "\n", "s", "+=", "f'width={self.width})'", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.__len__": [[185, 188], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Number of masks.\"\"\"", "\n", "return", "len", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.rescale": [[189, 201], ["structures.BitmapMasks", "len", "mmcv.rescale_size", "numpy.empty", "numpy.stack", "mmcv.imrescale"], "methods", ["None"], ["", "def", "rescale", "(", "self", ",", "scale", ",", "interpolation", "=", "'nearest'", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.rescale`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "new_w", ",", "new_h", "=", "mmcv", ".", "rescale_size", "(", "(", "self", ".", "width", ",", "self", ".", "height", ")", ",", "scale", ")", "\n", "rescaled_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "new_h", ",", "new_w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "rescaled_masks", "=", "np", ".", "stack", "(", "[", "\n", "mmcv", ".", "imrescale", "(", "mask", ",", "scale", ",", "interpolation", "=", "interpolation", ")", "\n", "for", "mask", "in", "self", ".", "masks", "\n", "]", ")", "\n", "", "height", ",", "width", "=", "rescaled_masks", ".", "shape", "[", "1", ":", "]", "\n", "return", "BitmapMasks", "(", "rescaled_masks", ",", "height", ",", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.resize": [[202, 212], ["structures.BitmapMasks", "len", "numpy.empty", "numpy.stack", "mmcv.imresize"], "methods", ["None"], ["", "def", "resize", "(", "self", ",", "out_shape", ",", "interpolation", "=", "'nearest'", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.resize`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "resized_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "*", "out_shape", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "resized_masks", "=", "np", ".", "stack", "(", "[", "\n", "mmcv", ".", "imresize", "(", "mask", ",", "out_shape", ",", "interpolation", "=", "interpolation", ")", "\n", "for", "mask", "in", "self", ".", "masks", "\n", "]", ")", "\n", "", "return", "BitmapMasks", "(", "resized_masks", ",", "*", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.flip": [[213, 225], ["structures.BitmapMasks", "len", "numpy.stack", "mmcv.imflip"], "methods", ["None"], ["", "def", "flip", "(", "self", ",", "flip_direction", "=", "'horizontal'", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.flip`.\"\"\"", "\n", "assert", "flip_direction", "in", "(", "'horizontal'", ",", "'vertical'", ")", "\n", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "flipped_masks", "=", "self", ".", "masks", "\n", "", "else", ":", "\n", "            ", "flipped_masks", "=", "np", ".", "stack", "(", "[", "\n", "mmcv", ".", "imflip", "(", "mask", ",", "direction", "=", "flip_direction", ")", "\n", "for", "mask", "in", "self", ".", "masks", "\n", "]", ")", "\n", "", "return", "BitmapMasks", "(", "flipped_masks", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.pad": [[226, 236], ["structures.BitmapMasks", "len", "numpy.empty", "numpy.stack", "mmcv.impad"], "methods", ["None"], ["", "def", "pad", "(", "self", ",", "out_shape", ",", "pad_val", "=", "0", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.pad`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "padded_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "*", "out_shape", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "padded_masks", "=", "np", ".", "stack", "(", "[", "\n", "mmcv", ".", "impad", "(", "mask", ",", "shape", "=", "out_shape", ",", "pad_val", "=", "pad_val", ")", "\n", "for", "mask", "in", "self", ".", "masks", "\n", "]", ")", "\n", "", "return", "BitmapMasks", "(", "padded_masks", ",", "*", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.crop": [[237, 255], ["isinstance", "bbox.copy.copy.copy", "numpy.clip", "numpy.clip", "numpy.maximum", "numpy.maximum", "structures.BitmapMasks", "len", "numpy.empty"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "bbox", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.crop`.\"\"\"", "\n", "assert", "isinstance", "(", "bbox", ",", "np", ".", "ndarray", ")", "\n", "assert", "bbox", ".", "ndim", "==", "1", "\n", "\n", "# clip the boundary", "\n", "bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "bbox", "[", "0", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bbox", "[", "0", ":", ":", "2", "]", ",", "0", ",", "self", ".", "width", ")", "\n", "bbox", "[", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bbox", "[", "1", ":", ":", "2", "]", ",", "0", ",", "self", ".", "height", ")", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bbox", "\n", "w", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "1", ")", "\n", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "cropped_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "cropped_masks", "=", "self", ".", "masks", "[", ":", ",", "y1", ":", "y1", "+", "h", ",", "x1", ":", "x1", "+", "w", "]", "\n", "", "return", "BitmapMasks", "(", "cropped_masks", ",", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.crop_and_resize": [[256, 287], ["isinstance", "isinstance", "torch.cat", "rois.to.to.to", "structures.BitmapMasks", "len", "numpy.empty", "structures.BitmapMasks", "torch.from_numpy().to", "torch.from_numpy().to", "torch.arange().to", "torch.from_numpy().to().index_select().to", "mmcv.ops.roi_align.roi_align().squeeze", "torch.from_numpy", "torch.from_numpy", "torch.arange", "torch.from_numpy().to().index_select", "mmcv.ops.roi_align.roi_align", "torch.from_numpy().to", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "def", "crop_and_resize", "(", "self", ",", "\n", "bboxes", ",", "\n", "out_shape", ",", "\n", "inds", ",", "\n", "device", "=", "'cpu'", ",", "\n", "interpolation", "=", "'bilinear'", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.crop_and_resize`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "empty_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "*", "out_shape", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "return", "BitmapMasks", "(", "empty_masks", ",", "*", "out_shape", ")", "\n", "\n", "# convert bboxes to tensor", "\n", "", "if", "isinstance", "(", "bboxes", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "bboxes", "=", "torch", ".", "from_numpy", "(", "bboxes", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "", "if", "isinstance", "(", "inds", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "inds", "=", "torch", ".", "from_numpy", "(", "inds", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "", "num_bbox", "=", "bboxes", ".", "shape", "[", "0", "]", "\n", "fake_inds", "=", "torch", ".", "arange", "(", "\n", "num_bbox", ",", "device", "=", "device", ")", ".", "to", "(", "dtype", "=", "bboxes", ".", "dtype", ")", "[", ":", ",", "None", "]", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "fake_inds", ",", "bboxes", "]", ",", "dim", "=", "1", ")", "# Nx5", "\n", "rois", "=", "rois", ".", "to", "(", "device", "=", "device", ")", "\n", "if", "num_bbox", ">", "0", ":", "\n", "            ", "gt_masks_th", "=", "torch", ".", "from_numpy", "(", "self", ".", "masks", ")", ".", "to", "(", "device", ")", ".", "index_select", "(", "\n", "0", ",", "inds", ")", ".", "to", "(", "dtype", "=", "rois", ".", "dtype", ")", "\n", "targets", "=", "roi_align", "(", "gt_masks_th", "[", ":", ",", "None", ",", ":", ",", ":", "]", ",", "rois", ",", "out_shape", ",", "\n", "1.0", ",", "0", ",", "'avg'", ",", "True", ")", ".", "squeeze", "(", "1", ")", "\n", "resized_masks", "=", "(", "targets", ">=", "0.5", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "resized_masks", "=", "[", "]", "\n", "", "return", "BitmapMasks", "(", "resized_masks", ",", "*", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.expand": [[288, 299], ["structures.BitmapMasks", "len", "numpy.empty", "numpy.zeros", "len"], "methods", ["None"], ["", "def", "expand", "(", "self", ",", "expanded_h", ",", "expanded_w", ",", "top", ",", "left", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.expand`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "expanded_mask", "=", "np", ".", "empty", "(", "(", "0", ",", "expanded_h", ",", "expanded_w", ")", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "expanded_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ")", ",", "expanded_h", ",", "expanded_w", ")", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "\n", "expanded_mask", "[", ":", ",", "top", ":", "top", "+", "self", ".", "height", ",", "\n", "left", ":", "left", "+", "self", ".", "width", "]", "=", "self", ".", "masks", "\n", "", "return", "BitmapMasks", "(", "expanded_mask", ",", "expanded_h", ",", "expanded_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.areas": [[300, 304], ["structures.BitmapMasks.masks.sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "areas", "(", "self", ")", ":", "\n", "        ", "\"\"\"See :py:attr:`BaseInstanceMasks.areas`.\"\"\"", "\n", "return", "self", ".", "masks", ".", "sum", "(", "(", "1", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.to_ndarray": [[305, 308], ["None"], "methods", ["None"], ["", "def", "to_ndarray", "(", "self", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.to_ndarray`.\"\"\"", "\n", "return", "self", ".", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.BitmapMasks.to_tensor": [[309, 312], ["torch.tensor"], "methods", ["None"], ["", "def", "to_tensor", "(", "self", ",", "dtype", ",", "device", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.to_tensor`.\"\"\"", "\n", "return", "torch", ".", "tensor", "(", "self", ".", "masks", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.__init__": [[329, 338], ["isinstance", "len", "isinstance", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "masks", ",", "height", ",", "width", ")", ":", "\n", "        ", "assert", "isinstance", "(", "masks", ",", "list", ")", "\n", "if", "len", "(", "masks", ")", ">", "0", ":", "\n", "            ", "assert", "isinstance", "(", "masks", "[", "0", "]", ",", "list", ")", "\n", "assert", "isinstance", "(", "masks", "[", "0", "]", "[", "0", "]", ",", "np", ".", "ndarray", ")", "\n", "\n", "", "self", ".", "height", "=", "height", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "masks", "=", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.__getitem__": [[339, 361], ["isinstance", "isinstance", "isinstance", "structures.PolygonMasks", "index.tolist.tolist.tolist", "ValueError", "type"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Index the polygon masks.\n\n        Args:\n            index (ndarray | List): The indices.\n\n        Returns:\n            :obj:`PolygonMasks`: The indexed polygon masks.\n        \"\"\"", "\n", "if", "isinstance", "(", "index", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "index", "=", "index", ".", "tolist", "(", ")", "\n", "", "if", "isinstance", "(", "index", ",", "list", ")", ":", "\n", "            ", "masks", "=", "[", "self", ".", "masks", "[", "i", "]", "for", "i", "in", "index", "]", "\n", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "masks", "=", "self", ".", "masks", "[", "index", "]", "\n", "", "except", "Exception", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f'Unsupported input of type {type(index)} for indexing!'", ")", "\n", "", "", "if", "isinstance", "(", "masks", "[", "0", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "masks", "=", "[", "masks", "]", "# ensure a list of three levels", "\n", "", "return", "PolygonMasks", "(", "masks", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.__iter__": [[362, 364], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.__repr__": [[365, 371], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "s", "+=", "f'num_masks={len(self.masks)}, '", "\n", "s", "+=", "f'height={self.height}, '", "\n", "s", "+=", "f'width={self.width})'", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.__len__": [[372, 375], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Number of masks.\"\"\"", "\n", "return", "len", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale": [[376, 384], ["mmcv.rescale_size", "len", "structures.PolygonMasks", "structures.PolygonMasks.resize"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize"], ["", "def", "rescale", "(", "self", ",", "scale", ",", "interpolation", "=", "None", ")", ":", "\n", "        ", "\"\"\"see :func:`BaseInstanceMasks.rescale`\"\"\"", "\n", "new_w", ",", "new_h", "=", "mmcv", ".", "rescale_size", "(", "(", "self", ".", "width", ",", "self", ".", "height", ")", ",", "scale", ")", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "rescaled_masks", "=", "PolygonMasks", "(", "[", "]", ",", "new_h", ",", "new_w", ")", "\n", "", "else", ":", "\n", "            ", "rescaled_masks", "=", "self", ".", "resize", "(", "(", "new_h", ",", "new_w", ")", ")", "\n", "", "return", "rescaled_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize": [[385, 403], ["len", "structures.PolygonMasks", "structures.PolygonMasks", "PolygonMasks.append", "p.copy.copy.copy", "resized_poly.append"], "methods", ["None"], ["", "def", "resize", "(", "self", ",", "out_shape", ",", "interpolation", "=", "None", ")", ":", "\n", "        ", "\"\"\"see :func:`BaseInstanceMasks.resize`\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "resized_masks", "=", "PolygonMasks", "(", "[", "]", ",", "*", "out_shape", ")", "\n", "", "else", ":", "\n", "            ", "h_scale", "=", "out_shape", "[", "0", "]", "/", "self", ".", "height", "\n", "w_scale", "=", "out_shape", "[", "1", "]", "/", "self", ".", "width", "\n", "resized_masks", "=", "[", "]", "\n", "for", "poly_per_obj", "in", "self", ".", "masks", ":", "\n", "                ", "resized_poly", "=", "[", "]", "\n", "for", "p", "in", "poly_per_obj", ":", "\n", "                    ", "p", "=", "p", ".", "copy", "(", ")", "\n", "p", "[", "0", ":", ":", "2", "]", "*=", "w_scale", "\n", "p", "[", "1", ":", ":", "2", "]", "*=", "h_scale", "\n", "resized_poly", ".", "append", "(", "p", ")", "\n", "", "resized_masks", ".", "append", "(", "resized_poly", ")", "\n", "", "resized_masks", "=", "PolygonMasks", "(", "resized_masks", ",", "*", "out_shape", ")", "\n", "", "return", "resized_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip": [[404, 427], ["len", "structures.PolygonMasks", "structures.PolygonMasks", "PolygonMasks.append", "p.copy.copy.copy", "flipped_poly_per_obj.append"], "methods", ["None"], ["", "def", "flip", "(", "self", ",", "flip_direction", "=", "'horizontal'", ")", ":", "\n", "        ", "\"\"\"see :func:`BaseInstanceMasks.flip`\"\"\"", "\n", "assert", "flip_direction", "in", "(", "'horizontal'", ",", "'vertical'", ")", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "flipped_masks", "=", "PolygonMasks", "(", "[", "]", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "", "else", ":", "\n", "            ", "if", "flip_direction", "==", "'horizontal'", ":", "\n", "                ", "dim", "=", "self", ".", "width", "\n", "idx", "=", "0", "\n", "", "else", ":", "\n", "                ", "dim", "=", "self", ".", "height", "\n", "idx", "=", "1", "\n", "", "flipped_masks", "=", "[", "]", "\n", "for", "poly_per_obj", "in", "self", ".", "masks", ":", "\n", "                ", "flipped_poly_per_obj", "=", "[", "]", "\n", "for", "p", "in", "poly_per_obj", ":", "\n", "                    ", "p", "=", "p", ".", "copy", "(", ")", "\n", "p", "[", "idx", ":", ":", "2", "]", "=", "dim", "-", "p", "[", "idx", ":", ":", "2", "]", "\n", "flipped_poly_per_obj", ".", "append", "(", "p", ")", "\n", "", "flipped_masks", ".", "append", "(", "flipped_poly_per_obj", ")", "\n", "", "flipped_masks", "=", "PolygonMasks", "(", "flipped_masks", ",", "self", ".", "height", ",", "\n", "self", ".", "width", ")", "\n", "", "return", "flipped_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop": [[428, 456], ["isinstance", "bbox.copy.copy.copy", "numpy.clip", "numpy.clip", "numpy.maximum", "numpy.maximum", "len", "structures.PolygonMasks", "structures.PolygonMasks", "PolygonMasks.append", "p.copy.copy.copy", "cropped_poly_per_obj.append"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "bbox", ")", ":", "\n", "        ", "\"\"\"see :func:`BaseInstanceMasks.crop`\"\"\"", "\n", "assert", "isinstance", "(", "bbox", ",", "np", ".", "ndarray", ")", "\n", "assert", "bbox", ".", "ndim", "==", "1", "\n", "\n", "# clip the boundary", "\n", "bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "bbox", "[", "0", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bbox", "[", "0", ":", ":", "2", "]", ",", "0", ",", "self", ".", "width", ")", "\n", "bbox", "[", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "bbox", "[", "1", ":", ":", "2", "]", ",", "0", ",", "self", ".", "height", ")", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bbox", "\n", "w", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "1", ")", "\n", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "cropped_masks", "=", "PolygonMasks", "(", "[", "]", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "cropped_masks", "=", "[", "]", "\n", "for", "poly_per_obj", "in", "self", ".", "masks", ":", "\n", "                ", "cropped_poly_per_obj", "=", "[", "]", "\n", "for", "p", "in", "poly_per_obj", ":", "\n", "# pycocotools will clip the boundary", "\n", "                    ", "p", "=", "p", ".", "copy", "(", ")", "\n", "p", "[", "0", ":", ":", "2", "]", "-=", "bbox", "[", "0", "]", "\n", "p", "[", "1", ":", ":", "2", "]", "-=", "bbox", "[", "1", "]", "\n", "cropped_poly_per_obj", ".", "append", "(", "p", ")", "\n", "", "cropped_masks", ".", "append", "(", "cropped_poly_per_obj", ")", "\n", "", "cropped_masks", "=", "PolygonMasks", "(", "cropped_masks", ",", "h", ",", "w", ")", "\n", "", "return", "cropped_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad": [[457, 460], ["structures.PolygonMasks"], "methods", ["None"], ["", "def", "pad", "(", "self", ",", "out_shape", ",", "pad_val", "=", "0", ")", ":", "\n", "        ", "\"\"\"padding has no effect on polygons`\"\"\"", "\n", "return", "PolygonMasks", "(", "self", ".", "masks", ",", "*", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand": [[461, 464], ["None"], "methods", ["None"], ["", "def", "expand", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"TODO: Add expand for polygon\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize": [[465, 500], ["range", "structures.PolygonMasks", "len", "structures.PolygonMasks", "len", "numpy.maximum", "numpy.maximum", "resized_masks.append", "max", "max", "p.copy.copy.copy", "resized_mask.append"], "methods", ["None"], ["", "def", "crop_and_resize", "(", "self", ",", "\n", "bboxes", ",", "\n", "out_shape", ",", "\n", "inds", ",", "\n", "device", "=", "'cpu'", ",", "\n", "interpolation", "=", "'bilinear'", ")", ":", "\n", "        ", "\"\"\"see :func:`BaseInstanceMasks.crop_and_resize`\"\"\"", "\n", "out_h", ",", "out_w", "=", "out_shape", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "return", "PolygonMasks", "(", "[", "]", ",", "out_h", ",", "out_w", ")", "\n", "\n", "", "resized_masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "bboxes", ")", ")", ":", "\n", "            ", "mask", "=", "self", ".", "masks", "[", "inds", "[", "i", "]", "]", "\n", "bbox", "=", "bboxes", "[", "i", ",", ":", "]", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bbox", "\n", "w", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "1", ")", "\n", "h_scale", "=", "out_h", "/", "max", "(", "h", ",", "0.1", ")", "# avoid too large scale", "\n", "w_scale", "=", "out_w", "/", "max", "(", "w", ",", "0.1", ")", "\n", "\n", "resized_mask", "=", "[", "]", "\n", "for", "p", "in", "mask", ":", "\n", "                ", "p", "=", "p", ".", "copy", "(", ")", "\n", "# crop", "\n", "# pycocotools will clip the boundary", "\n", "p", "[", "0", ":", ":", "2", "]", "-=", "bbox", "[", "0", "]", "\n", "p", "[", "1", ":", ":", "2", "]", "-=", "bbox", "[", "1", "]", "\n", "\n", "# resize", "\n", "p", "[", "0", ":", ":", "2", "]", "*=", "w_scale", "\n", "p", "[", "1", ":", ":", "2", "]", "*=", "h_scale", "\n", "resized_mask", ".", "append", "(", "p", ")", "\n", "", "resized_masks", ".", "append", "(", "resized_mask", ")", "\n", "", "return", "PolygonMasks", "(", "resized_masks", ",", "*", "out_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_bitmap": [[501, 505], ["structures.PolygonMasks.to_ndarray", "structures.BitmapMasks"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "to_bitmap", "(", "self", ")", ":", "\n", "        ", "\"\"\"convert polygon masks to bitmap masks.\"\"\"", "\n", "bitmap_masks", "=", "self", ".", "to_ndarray", "(", ")", "\n", "return", "BitmapMasks", "(", "bitmap_masks", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.areas": [[506, 524], ["numpy.asarray", "area.append", "structures.PolygonMasks._polygon_area"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks._polygon_area"], ["", "@", "property", "\n", "def", "areas", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute areas of masks.\n\n        This func is modified from `detectron2\n        <https://github.com/facebookresearch/detectron2/blob/ffff8acc35ea88ad1cb1806ab0f00b4c1c5dbfd9/detectron2/structures/masks.py#L387>`_.\n        The function only works with Polygons using the shoelace formula.\n\n        Return:\n            ndarray: areas of each instance\n        \"\"\"", "# noqa: W501", "\n", "area", "=", "[", "]", "\n", "for", "polygons_per_obj", "in", "self", ".", "masks", ":", "\n", "            ", "area_per_obj", "=", "0", "\n", "for", "p", "in", "polygons_per_obj", ":", "\n", "                ", "area_per_obj", "+=", "self", ".", "_polygon_area", "(", "p", "[", "0", ":", ":", "2", "]", ",", "p", "[", "1", ":", ":", "2", "]", ")", "\n", "", "area", ".", "append", "(", "area_per_obj", ")", "\n", "", "return", "np", ".", "asarray", "(", "area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks._polygon_area": [[525, 540], ["numpy.abs", "numpy.dot", "numpy.dot", "numpy.roll", "numpy.roll"], "methods", ["None"], ["", "def", "_polygon_area", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"Compute the area of a component of a polygon.\n\n        Using the shoelace formula:\n        https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n\n        Args:\n            x (ndarray): x coordinates of the component\n            y (ndarray): y coordinates of the component\n\n        Return:\n            float: the are of the component\n        \"\"\"", "# noqa: 501", "\n", "return", "0.5", "*", "np", ".", "abs", "(", "\n", "np", ".", "dot", "(", "x", ",", "np", ".", "roll", "(", "y", ",", "1", ")", ")", "-", "np", ".", "dot", "(", "y", ",", "np", ".", "roll", "(", "x", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray": [[541, 550], ["numpy.stack", "len", "numpy.empty", "bitmap_masks.append", "structures.polygon_to_bitmap"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.polygon_to_bitmap"], ["", "def", "to_ndarray", "(", "self", ")", ":", "\n", "        ", "\"\"\"Convert masks to the format of ndarray.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "return", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "bitmap_masks", "=", "[", "]", "\n", "for", "poly_per_obj", "in", "self", ".", "masks", ":", "\n", "            ", "bitmap_masks", ".", "append", "(", "\n", "polygon_to_bitmap", "(", "poly_per_obj", ",", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "", "return", "np", ".", "stack", "(", "bitmap_masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor": [[551, 559], ["structures.PolygonMasks.to_ndarray", "torch.tensor", "len", "torch.empty"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "to_tensor", "(", "self", ",", "dtype", ",", "device", ")", ":", "\n", "        ", "\"\"\"See :func:`BaseInstanceMasks.to_tensor`.\"\"\"", "\n", "if", "len", "(", "self", ".", "masks", ")", "==", "0", ":", "\n", "            ", "return", "torch", ".", "empty", "(", "(", "0", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ")", "\n", "", "ndarray_masks", "=", "self", ".", "to_ndarray", "(", ")", "\n", "return", "torch", ".", "tensor", "(", "ndarray_masks", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.polygon_to_bitmap": [[561, 576], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode().astype", "pycocotools.decode"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "", "def", "polygon_to_bitmap", "(", "polygons", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"Convert masks from the form of polygons to bitmaps.\n\n    Args:\n        polygons (list[ndarray]): masks in polygon representation\n        height (int): mask height\n        width (int): mask width\n\n    Return:\n        ndarray: the converted masks in bitmap representation\n    \"\"\"", "\n", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "bitmap_mask", "=", "maskUtils", ".", "decode", "(", "rle", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "return", "bitmap_mask", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.utils.split_combined_polys": [[6, 33], ["range", "len", "poly_lens[].tolist", "polys_per_mask[].tolist", "mmcv.slice_list", "mmcv.slice_list", "mask_polys_list.append"], "function", ["None"], ["def", "reduce_loss", "(", "loss", ",", "reduction", ")", ":", "\n", "    ", "\"\"\"Reduce loss as specified.\n\n    Args:\n        loss (Tensor): Elementwise loss tensor.\n        reduction (str): Options are \"none\", \"mean\" and \"sum\".\n\n    Return:\n        Tensor: Reduced loss tensor.\n    \"\"\"", "\n", "reduction_enum", "=", "F", ".", "_Reduction", ".", "get_enum", "(", "reduction", ")", "\n", "# none: 0, elementwise_mean:1, sum: 2", "\n", "if", "reduction_enum", "==", "0", ":", "\n", "        ", "return", "loss", "\n", "", "elif", "reduction_enum", "==", "1", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "elif", "reduction_enum", "==", "2", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "\n", "\n", "", "", "def", "weight_reduce_loss", "(", "loss", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "avg_factor", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.utils.encode_mask_results": [[36, 64], ["isinstance", "len", "range", "isinstance", "len", "range", "encoded_mask_results[].append", "pycocotools.encode", "numpy.array"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["\n", "# if weight is specified, apply element-wise weight", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "loss", "=", "loss", "*", "weight", "\n", "\n", "# if avg_factor is not specified, just reduce the loss", "\n", "", "if", "avg_factor", "is", "None", ":", "\n", "        ", "loss", "=", "reduce_loss", "(", "loss", ",", "reduction", ")", "\n", "", "else", ":", "\n", "# if reduction is mean, then average the loss by avg_factor", "\n", "        ", "if", "reduction", "==", "'mean'", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "avg_factor", "\n", "# if reduction is 'none', then do nothing, otherwise raise an error", "\n", "", "elif", "reduction", "!=", "'none'", ":", "\n", "            ", "raise", "ValueError", "(", "'avg_factor can not be used with reduction=\"sum\"'", ")", "\n", "", "", "return", "loss", "\n", "\n", "\n", "", "def", "weighted_loss", "(", "loss_func", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.__init__": [[58, 111], ["torch.Tensor", "anchor_generator.AnchorGenerator.gen_base_anchors", "ValueError", "torch.nn.modules.utils._pair", "len", "len", "torch.Tensor", "len", "len", "min", "numpy.array", "torch.Tensor", "ValueError", "range"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.gen_base_anchors"], ["def", "__init__", "(", "self", ",", "\n", "strides", ",", "\n", "ratios", ",", "\n", "scales", "=", "None", ",", "\n", "base_sizes", "=", "None", ",", "\n", "scale_major", "=", "True", ",", "\n", "octave_base_scale", "=", "None", ",", "\n", "scales_per_octave", "=", "None", ",", "\n", "centers", "=", "None", ",", "\n", "center_offset", "=", "0.", ")", ":", "\n", "# check center and center_offset", "\n", "        ", "if", "center_offset", "!=", "0", ":", "\n", "            ", "assert", "centers", "is", "None", ",", "'center cannot be set when center_offset'", "f'!=0, {centers} is given.'", "\n", "", "if", "not", "(", "0", "<=", "center_offset", "<=", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'center_offset should be in range [0, 1], '", "\n", "f'{center_offset} is given.'", ")", "\n", "", "if", "centers", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "centers", ")", "==", "len", "(", "strides", ")", ",", "'The number of strides should be the same as centers, got '", "f'{strides} and {centers}'", "\n", "\n", "# calculate base sizes of anchors", "\n", "", "self", ".", "strides", "=", "[", "_pair", "(", "stride", ")", "for", "stride", "in", "strides", "]", "\n", "self", ".", "base_sizes", "=", "[", "min", "(", "stride", ")", "for", "stride", "in", "self", ".", "strides", "\n", "]", "if", "base_sizes", "is", "None", "else", "base_sizes", "\n", "assert", "len", "(", "self", ".", "base_sizes", ")", "==", "len", "(", "self", ".", "strides", ")", ",", "'The number of strides should be the same as base sizes, got '", "f'{self.strides} and {self.base_sizes}'", "\n", "\n", "# calculate scales of anchors", "\n", "assert", "(", "(", "octave_base_scale", "is", "not", "None", "\n", "and", "scales_per_octave", "is", "not", "None", ")", "^", "(", "scales", "is", "not", "None", ")", ")", ",", "'scales and octave_base_scale with scales_per_octave cannot'", "' be set at the same time'", "\n", "if", "scales", "is", "not", "None", ":", "\n", "            ", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "elif", "octave_base_scale", "is", "not", "None", "and", "scales_per_octave", "is", "not", "None", ":", "\n", "            ", "octave_scales", "=", "np", ".", "array", "(", "\n", "[", "2", "**", "(", "i", "/", "scales_per_octave", ")", "for", "i", "in", "range", "(", "scales_per_octave", ")", "]", ")", "\n", "scales", "=", "octave_scales", "*", "octave_base_scale", "\n", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Either scales or octave_base_scale with '", "\n", "'scales_per_octave should be set'", ")", "\n", "\n", "", "self", ".", "octave_base_scale", "=", "octave_base_scale", "\n", "self", ".", "scales_per_octave", "=", "scales_per_octave", "\n", "self", ".", "ratios", "=", "torch", ".", "Tensor", "(", "ratios", ")", "\n", "self", ".", "scale_major", "=", "scale_major", "\n", "self", ".", "centers", "=", "centers", "\n", "self", ".", "center_offset", "=", "center_offset", "\n", "self", ".", "base_anchors", "=", "self", ".", "gen_base_anchors", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.num_base_anchors": [[112, 116], ["base_anchors.size"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_base_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"list[int]: total number of base anchors in a feature grid\"\"\"", "\n", "return", "[", "base_anchors", ".", "size", "(", "0", ")", "for", "base_anchors", "in", "self", ".", "base_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.num_levels": [[117, 121], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_levels", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: number of feature levels that the generator will be applied\"\"\"", "\n", "return", "len", "(", "self", ".", "strides", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.gen_base_anchors": [[122, 141], ["enumerate", "multi_level_base_anchors.append", "anchor_generator.AnchorGenerator.gen_single_level_base_anchors"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.LegacyAnchorGenerator.gen_single_level_base_anchors"], ["", "def", "gen_base_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generate base anchors.\n\n        Returns:\n            list(torch.Tensor): Base anchors of a feature grid in multiple \\\n                feature levels.\n        \"\"\"", "\n", "multi_level_base_anchors", "=", "[", "]", "\n", "for", "i", ",", "base_size", "in", "enumerate", "(", "self", ".", "base_sizes", ")", ":", "\n", "            ", "center", "=", "None", "\n", "if", "self", ".", "centers", "is", "not", "None", ":", "\n", "                ", "center", "=", "self", ".", "centers", "[", "i", "]", "\n", "", "multi_level_base_anchors", ".", "append", "(", "\n", "self", ".", "gen_single_level_base_anchors", "(", "\n", "base_size", ",", "\n", "scales", "=", "self", ".", "scales", ",", "\n", "ratios", "=", "self", ".", "ratios", ",", "\n", "center", "=", "center", ")", ")", "\n", "", "return", "multi_level_base_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.gen_single_level_base_anchors": [[142, 186], ["torch.sqrt", "torch.stack"], "methods", ["None"], ["", "def", "gen_single_level_base_anchors", "(", "self", ",", "\n", "base_size", ",", "\n", "scales", ",", "\n", "ratios", ",", "\n", "center", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate base anchors of a single level.\n\n        Args:\n            base_size (int | float): Basic size of an anchor.\n            scales (torch.Tensor): Scales of the anchor.\n            ratios (torch.Tensor): The ratio between between the height\n                and width of anchors in a single level.\n            center (tuple[float], optional): The center of the base anchor\n                related to a single feature grid. Defaults to None.\n\n        Returns:\n            torch.Tensor: Anchors in a single-level feature maps.\n        \"\"\"", "\n", "w", "=", "base_size", "\n", "h", "=", "base_size", "\n", "if", "center", "is", "None", ":", "\n", "            ", "x_center", "=", "self", ".", "center_offset", "*", "w", "\n", "y_center", "=", "self", ".", "center_offset", "*", "h", "\n", "", "else", ":", "\n", "            ", "x_center", ",", "y_center", "=", "center", "\n", "\n", "", "h_ratios", "=", "torch", ".", "sqrt", "(", "ratios", ")", "\n", "w_ratios", "=", "1", "/", "h_ratios", "\n", "if", "self", ".", "scale_major", ":", "\n", "            ", "ws", "=", "(", "w", "*", "w_ratios", "[", ":", ",", "None", "]", "*", "scales", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "hs", "=", "(", "h", "*", "h_ratios", "[", ":", ",", "None", "]", "*", "scales", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "ws", "=", "(", "w", "*", "scales", "[", ":", ",", "None", "]", "*", "w_ratios", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "hs", "=", "(", "h", "*", "scales", "[", ":", ",", "None", "]", "*", "h_ratios", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "# use float anchor and the anchor's center is aligned with the", "\n", "# pixel center", "\n", "", "base_anchors", "=", "[", "\n", "x_center", "-", "0.5", "*", "ws", ",", "y_center", "-", "0.5", "*", "hs", ",", "x_center", "+", "0.5", "*", "ws", ",", "\n", "y_center", "+", "0.5", "*", "hs", "\n", "]", "\n", "base_anchors", "=", "torch", ".", "stack", "(", "base_anchors", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "base_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator._meshgrid": [[187, 205], ["x.repeat", "y.view().repeat().view", "len", "y.view().repeat", "len", "y.view"], "methods", ["None"], ["", "def", "_meshgrid", "(", "self", ",", "x", ",", "y", ",", "row_major", "=", "True", ")", ":", "\n", "        ", "\"\"\"Generate mesh grid of x and y.\n\n        Args:\n            x (torch.Tensor): Grids of x dimension.\n            y (torch.Tensor): Grids of y dimension.\n            row_major (bool, optional): Whether to return y grids first.\n                Defaults to True.\n\n        Returns:\n            tuple[torch.Tensor]: The mesh grids of x and y.\n        \"\"\"", "\n", "xx", "=", "x", ".", "repeat", "(", "len", "(", "y", ")", ")", "\n", "yy", "=", "y", ".", "view", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "len", "(", "x", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "row_major", ":", "\n", "            ", "return", "xx", ",", "yy", "\n", "", "else", ":", "\n", "            ", "return", "yy", ",", "xx", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors": [[206, 231], ["range", "len", "anchor_generator.AnchorGenerator.single_level_grid_anchors", "multi_level_anchors.append", "anchor_generator.AnchorGenerator.base_anchors[].to"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.single_level_grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "", "def", "grid_anchors", "(", "self", ",", "featmap_sizes", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate grid anchors in multiple feature levels.\n\n        Args:\n            featmap_sizes (list[tuple]): List of feature map sizes in\n                multiple feature levels.\n            device (str): Device where the anchors will be put on.\n\n        Return:\n            list[torch.Tensor]: Anchors in multiple feature levels. \\\n                The sizes of each tensor should be [N, 4], where \\\n                N = width * height * num_base_anchors, width and height \\\n                are the sizes of the corresponding feature lavel, \\\n                num_base_anchors is the number of anchors for that level.\n        \"\"\"", "\n", "assert", "self", ".", "num_levels", "==", "len", "(", "featmap_sizes", ")", "\n", "multi_level_anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "anchors", "=", "self", ".", "single_level_grid_anchors", "(", "\n", "self", ".", "base_anchors", "[", "i", "]", ".", "to", "(", "device", ")", ",", "\n", "featmap_sizes", "[", "i", "]", ",", "\n", "self", ".", "strides", "[", "i", "]", ",", "\n", "device", "=", "device", ")", "\n", "multi_level_anchors", ".", "append", "(", "anchors", ")", "\n", "", "return", "multi_level_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.single_level_grid_anchors": [[232, 272], ["int", "int", "anchor_generator.AnchorGenerator._meshgrid", "torch.stack", "shifts.type_as.type_as.type_as", "all_anchors.view.view.view", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator._meshgrid"], ["", "def", "single_level_grid_anchors", "(", "self", ",", "\n", "base_anchors", ",", "\n", "featmap_size", ",", "\n", "stride", "=", "(", "16", ",", "16", ")", ",", "\n", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate grid anchors of a single level.\n\n        Note:\n            This function is usually called by method ``self.grid_anchors``.\n\n        Args:\n            base_anchors (torch.Tensor): The base anchors of a feature grid.\n            featmap_size (tuple[int]): Size of the feature maps.\n            stride (tuple[int], optional): Stride of the feature map.\n                Defaults to (16, 16).\n            device (str, optional): Device the tensor will be put on.\n                Defaults to 'cuda'.\n\n        Returns:\n            torch.Tensor: Anchors in the overall feature maps.\n        \"\"\"", "\n", "feat_h", ",", "feat_w", "=", "featmap_size", "\n", "# convert Tensor to int, so that we can covert to ONNX correctlly", "\n", "feat_h", "=", "int", "(", "feat_h", ")", "\n", "feat_w", "=", "int", "(", "feat_w", ")", "\n", "shift_x", "=", "torch", ".", "arange", "(", "0", ",", "feat_w", ",", "device", "=", "device", ")", "*", "stride", "[", "0", "]", "\n", "shift_y", "=", "torch", ".", "arange", "(", "0", ",", "feat_h", ",", "device", "=", "device", ")", "*", "stride", "[", "1", "]", "\n", "\n", "shift_xx", ",", "shift_yy", "=", "self", ".", "_meshgrid", "(", "shift_x", ",", "shift_y", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "[", "shift_xx", ",", "shift_yy", ",", "shift_xx", ",", "shift_yy", "]", ",", "dim", "=", "-", "1", ")", "\n", "shifts", "=", "shifts", ".", "type_as", "(", "base_anchors", ")", "\n", "# first feat_w elements correspond to the first row of shifts", "\n", "# add A anchors (1, A, 4) to K shifts (K, 1, 4) to get", "\n", "# shifted anchors (K, A, 4), reshape to (K*A, 4)", "\n", "\n", "all_anchors", "=", "base_anchors", "[", "None", ",", ":", ",", ":", "]", "+", "shifts", "[", ":", ",", "None", ",", ":", "]", "\n", "all_anchors", "=", "all_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "# first A rows correspond to A anchors of (0, 0) in feature map,", "\n", "# then (0, 1), (0, 2), ...", "\n", "return", "all_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.valid_flags": [[273, 299], ["range", "len", "min", "min", "anchor_generator.AnchorGenerator.single_level_valid_flags", "multi_level_flags.append", "int", "int", "numpy.ceil", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.single_level_valid_flags"], ["", "def", "valid_flags", "(", "self", ",", "featmap_sizes", ",", "pad_shape", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate valid flags of anchors in multiple feature levels.\n\n        Args:\n            featmap_sizes (list(tuple)): List of feature map sizes in\n                multiple feature levels.\n            pad_shape (tuple): The padded shape of the image.\n            device (str): Device where the anchors will be put on.\n\n        Return:\n            list(torch.Tensor): Valid flags of anchors in multiple levels.\n        \"\"\"", "\n", "assert", "self", ".", "num_levels", "==", "len", "(", "featmap_sizes", ")", "\n", "multi_level_flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "anchor_stride", "=", "self", ".", "strides", "[", "i", "]", "\n", "feat_h", ",", "feat_w", "=", "featmap_sizes", "[", "i", "]", "\n", "h", ",", "w", "=", "pad_shape", "[", ":", "2", "]", "\n", "valid_feat_h", "=", "min", "(", "int", "(", "np", ".", "ceil", "(", "h", "/", "anchor_stride", "[", "0", "]", ")", ")", ",", "feat_h", ")", "\n", "valid_feat_w", "=", "min", "(", "int", "(", "np", ".", "ceil", "(", "w", "/", "anchor_stride", "[", "1", "]", ")", ")", ",", "feat_w", ")", "\n", "flags", "=", "self", ".", "single_level_valid_flags", "(", "(", "feat_h", ",", "feat_w", ")", ",", "\n", "(", "valid_feat_h", ",", "valid_feat_w", ")", ",", "\n", "self", ".", "num_base_anchors", "[", "i", "]", ",", "\n", "device", "=", "device", ")", "\n", "multi_level_flags", ".", "append", "(", "flags", ")", "\n", "", "return", "multi_level_flags", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.single_level_valid_flags": [[300, 330], ["torch.zeros", "torch.zeros", "anchor_generator.AnchorGenerator._meshgrid", "valid[].expand().contiguous().view", "valid[].expand().contiguous", "valid[].expand", "valid[].expand().contiguous().view.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator._meshgrid", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "single_level_valid_flags", "(", "self", ",", "\n", "featmap_size", ",", "\n", "valid_size", ",", "\n", "num_base_anchors", ",", "\n", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate the valid flags of anchor in a single feature map.\n\n        Args:\n            featmap_size (tuple[int]): The size of feature maps.\n            valid_size (tuple[int]): The valid size of the feature maps.\n            num_base_anchors (int): The number of base anchors.\n            device (str, optional): Device where the flags will be put on.\n                Defaults to 'cuda'.\n\n        Returns:\n            torch.Tensor: The valid flags of each anchor in a single level \\\n                feature map.\n        \"\"\"", "\n", "feat_h", ",", "feat_w", "=", "featmap_size", "\n", "valid_h", ",", "valid_w", "=", "valid_size", "\n", "assert", "valid_h", "<=", "feat_h", "and", "valid_w", "<=", "feat_w", "\n", "valid_x", "=", "torch", ".", "zeros", "(", "feat_w", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "valid_y", "=", "torch", ".", "zeros", "(", "feat_h", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "valid_x", "[", ":", "valid_w", "]", "=", "1", "\n", "valid_y", "[", ":", "valid_h", "]", "=", "1", "\n", "valid_xx", ",", "valid_yy", "=", "self", ".", "_meshgrid", "(", "valid_x", ",", "valid_y", ")", "\n", "valid", "=", "valid_xx", "&", "valid_yy", "\n", "valid", "=", "valid", "[", ":", ",", "None", "]", ".", "expand", "(", "valid", ".", "size", "(", "0", ")", ",", "\n", "num_base_anchors", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "return", "valid", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.__repr__": [[331, 348], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a string that describes the module\"\"\"", "\n", "indent_str", "=", "'    '", "\n", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "+", "'(\\n'", "\n", "repr_str", "+=", "f'{indent_str}strides={self.strides},\\n'", "\n", "repr_str", "+=", "f'{indent_str}ratios={self.ratios},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scales={self.scales},\\n'", "\n", "repr_str", "+=", "f'{indent_str}base_sizes={self.base_sizes},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scale_major={self.scale_major},\\n'", "\n", "repr_str", "+=", "f'{indent_str}octave_base_scale='", "\n", "repr_str", "+=", "f'{self.octave_base_scale},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scales_per_octave='", "\n", "repr_str", "+=", "f'{self.scales_per_octave},\\n'", "\n", "repr_str", "+=", "f'{indent_str}num_levels={self.num_levels}\\n'", "\n", "repr_str", "+=", "f'{indent_str}centers={self.centers},\\n'", "\n", "repr_str", "+=", "f'{indent_str}center_offset={self.center_offset})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.__init__": [[367, 435], ["mmcv.is_tuple_of", "int", "int", "int", "range", "range", "anchor_generator.SSDAnchorGenerator.gen_base_anchors", "len", "len", "torch.nn.modules.utils._pair", "int", "min_sizes.append", "max_sizes.append", "len", "anchor_ratios.append", "anchor_scales.append", "numpy.floor", "int", "int", "int", "min_sizes.insert", "max_sizes.insert", "ValueError", "numpy.sqrt", "torch.Tensor", "torch.Tensor", "int", "int", "min_sizes.insert", "max_sizes.insert", "ValueError", "min_sizes.insert", "max_sizes.insert", "int", "int", "int", "int", "min_sizes.insert", "max_sizes.insert", "ValueError", "int", "int"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.gen_base_anchors"], ["def", "__init__", "(", "self", ",", "\n", "strides", ",", "\n", "ratios", ",", "\n", "basesize_ratio_range", ",", "\n", "input_size", "=", "300", ",", "\n", "scale_major", "=", "True", ")", ":", "\n", "        ", "assert", "len", "(", "strides", ")", "==", "len", "(", "ratios", ")", "\n", "assert", "mmcv", ".", "is_tuple_of", "(", "basesize_ratio_range", ",", "float", ")", "\n", "\n", "self", ".", "strides", "=", "[", "_pair", "(", "stride", ")", "for", "stride", "in", "strides", "]", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "centers", "=", "[", "(", "stride", "[", "0", "]", "/", "2.", ",", "stride", "[", "1", "]", "/", "2.", ")", "\n", "for", "stride", "in", "self", ".", "strides", "]", "\n", "self", ".", "basesize_ratio_range", "=", "basesize_ratio_range", "\n", "\n", "# calculate anchor ratios and sizes", "\n", "min_ratio", ",", "max_ratio", "=", "basesize_ratio_range", "\n", "min_ratio", "=", "int", "(", "min_ratio", "*", "100", ")", "\n", "max_ratio", "=", "int", "(", "max_ratio", "*", "100", ")", "\n", "step", "=", "int", "(", "np", ".", "floor", "(", "max_ratio", "-", "min_ratio", ")", "/", "(", "self", ".", "num_levels", "-", "2", ")", ")", "\n", "min_sizes", "=", "[", "]", "\n", "max_sizes", "=", "[", "]", "\n", "for", "ratio", "in", "range", "(", "int", "(", "min_ratio", ")", ",", "int", "(", "max_ratio", ")", "+", "1", ",", "step", ")", ":", "\n", "            ", "min_sizes", ".", "append", "(", "int", "(", "self", ".", "input_size", "*", "ratio", "/", "100", ")", ")", "\n", "max_sizes", ".", "append", "(", "int", "(", "self", ".", "input_size", "*", "(", "ratio", "+", "step", ")", "/", "100", ")", ")", "\n", "", "if", "self", ".", "input_size", "==", "300", ":", "\n", "            ", "if", "basesize_ratio_range", "[", "0", "]", "==", "0.15", ":", "# SSD300 COCO", "\n", "                ", "min_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "7", "/", "100", ")", ")", "\n", "max_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "15", "/", "100", ")", ")", "\n", "", "elif", "basesize_ratio_range", "[", "0", "]", "==", "0.2", ":", "# SSD300 VOC", "\n", "                ", "min_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "10", "/", "100", ")", ")", "\n", "max_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "20", "/", "100", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'basesize_ratio_range[0] should be either 0.15'", "\n", "'or 0.2 when input_size is 300, got '", "\n", "f'{basesize_ratio_range[0]}.'", ")", "\n", "", "", "elif", "self", ".", "input_size", "==", "512", ":", "\n", "            ", "if", "basesize_ratio_range", "[", "0", "]", "==", "0.1", ":", "# SSD512 COCO", "\n", "                ", "min_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "4", "/", "100", ")", ")", "\n", "max_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "10", "/", "100", ")", ")", "\n", "", "elif", "basesize_ratio_range", "[", "0", "]", "==", "0.15", ":", "# SSD512 VOC", "\n", "                ", "min_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "7", "/", "100", ")", ")", "\n", "max_sizes", ".", "insert", "(", "0", ",", "int", "(", "self", ".", "input_size", "*", "15", "/", "100", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'basesize_ratio_range[0] should be either 0.1'", "\n", "'or 0.15 when input_size is 512, got'", "\n", "' {basesize_ratio_range[0]}.'", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Only support 300 or 512 in SSDAnchorGenerator'", "\n", "f', got {self.input_size}.'", ")", "\n", "\n", "", "anchor_ratios", "=", "[", "]", "\n", "anchor_scales", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "self", ".", "strides", ")", ")", ":", "\n", "            ", "scales", "=", "[", "1.", ",", "np", ".", "sqrt", "(", "max_sizes", "[", "k", "]", "/", "min_sizes", "[", "k", "]", ")", "]", "\n", "anchor_ratio", "=", "[", "1.", "]", "\n", "for", "r", "in", "ratios", "[", "k", "]", ":", "\n", "                ", "anchor_ratio", "+=", "[", "1", "/", "r", ",", "r", "]", "# 4 or 6 ratio", "\n", "", "anchor_ratios", ".", "append", "(", "torch", ".", "Tensor", "(", "anchor_ratio", ")", ")", "\n", "anchor_scales", ".", "append", "(", "torch", ".", "Tensor", "(", "scales", ")", ")", "\n", "\n", "", "self", ".", "base_sizes", "=", "min_sizes", "\n", "self", ".", "scales", "=", "anchor_scales", "\n", "self", ".", "ratios", "=", "anchor_ratios", "\n", "self", ".", "scale_major", "=", "scale_major", "\n", "self", ".", "center_offset", "=", "0", "\n", "self", ".", "base_anchors", "=", "self", ".", "gen_base_anchors", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.gen_base_anchors": [[436, 456], ["enumerate", "anchor_generator.SSDAnchorGenerator.gen_single_level_base_anchors", "list", "list.insert", "torch.index_select", "multi_level_base_anchors.append", "range", "len", "torch.LongTensor", "len"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.LegacyAnchorGenerator.gen_single_level_base_anchors"], ["", "def", "gen_base_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generate base anchors.\n\n        Returns:\n            list(torch.Tensor): Base anchors of a feature grid in multiple \\\n                feature levels.\n        \"\"\"", "\n", "multi_level_base_anchors", "=", "[", "]", "\n", "for", "i", ",", "base_size", "in", "enumerate", "(", "self", ".", "base_sizes", ")", ":", "\n", "            ", "base_anchors", "=", "self", ".", "gen_single_level_base_anchors", "(", "\n", "base_size", ",", "\n", "scales", "=", "self", ".", "scales", "[", "i", "]", ",", "\n", "ratios", "=", "self", ".", "ratios", "[", "i", "]", ",", "\n", "center", "=", "self", ".", "centers", "[", "i", "]", ")", "\n", "indices", "=", "list", "(", "range", "(", "len", "(", "self", ".", "ratios", "[", "i", "]", ")", ")", ")", "\n", "indices", ".", "insert", "(", "1", ",", "len", "(", "indices", ")", ")", "\n", "base_anchors", "=", "torch", ".", "index_select", "(", "base_anchors", ",", "0", ",", "\n", "torch", ".", "LongTensor", "(", "indices", ")", ")", "\n", "multi_level_base_anchors", ".", "append", "(", "base_anchors", ")", "\n", "", "return", "multi_level_base_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.__repr__": [[457, 472], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a string that describes the module\"\"\"", "\n", "indent_str", "=", "'    '", "\n", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "+", "'(\\n'", "\n", "repr_str", "+=", "f'{indent_str}strides={self.strides},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scales={self.scales},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scale_major={self.scale_major},\\n'", "\n", "repr_str", "+=", "f'{indent_str}input_size={self.input_size},\\n'", "\n", "repr_str", "+=", "f'{indent_str}scales={self.scales},\\n'", "\n", "repr_str", "+=", "f'{indent_str}ratios={self.ratios},\\n'", "\n", "repr_str", "+=", "f'{indent_str}num_levels={self.num_levels},\\n'", "\n", "repr_str", "+=", "f'{indent_str}base_sizes={self.base_sizes},\\n'", "\n", "repr_str", "+=", "f'{indent_str}basesize_ratio_range='", "\n", "repr_str", "+=", "f'{self.basesize_ratio_range})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.LegacyAnchorGenerator.gen_single_level_base_anchors": [[523, 571], ["torch.sqrt", "torch.stack().round", "torch.stack"], "methods", ["None"], ["def", "gen_single_level_base_anchors", "(", "self", ",", "\n", "base_size", ",", "\n", "scales", ",", "\n", "ratios", ",", "\n", "center", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate base anchors of a single level.\n\n        Note:\n            The width/height of anchors are minused by 1 when calculating \\\n                the centers and corners to meet the V1.x coordinate system.\n\n        Args:\n            base_size (int | float): Basic size of an anchor.\n            scales (torch.Tensor): Scales of the anchor.\n            ratios (torch.Tensor): The ratio between between the height.\n                and width of anchors in a single level.\n            center (tuple[float], optional): The center of the base anchor\n                related to a single feature grid. Defaults to None.\n\n        Returns:\n            torch.Tensor: Anchors in a single-level feature map.\n        \"\"\"", "\n", "w", "=", "base_size", "\n", "h", "=", "base_size", "\n", "if", "center", "is", "None", ":", "\n", "            ", "x_center", "=", "self", ".", "center_offset", "*", "(", "w", "-", "1", ")", "\n", "y_center", "=", "self", ".", "center_offset", "*", "(", "h", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x_center", ",", "y_center", "=", "center", "\n", "\n", "", "h_ratios", "=", "torch", ".", "sqrt", "(", "ratios", ")", "\n", "w_ratios", "=", "1", "/", "h_ratios", "\n", "if", "self", ".", "scale_major", ":", "\n", "            ", "ws", "=", "(", "w", "*", "w_ratios", "[", ":", ",", "None", "]", "*", "scales", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "hs", "=", "(", "h", "*", "h_ratios", "[", ":", ",", "None", "]", "*", "scales", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "ws", "=", "(", "w", "*", "scales", "[", ":", ",", "None", "]", "*", "w_ratios", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "hs", "=", "(", "h", "*", "scales", "[", ":", ",", "None", "]", "*", "h_ratios", "[", "None", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "# use float anchor and the anchor's center is aligned with the", "\n", "# pixel center", "\n", "", "base_anchors", "=", "[", "\n", "x_center", "-", "0.5", "*", "(", "ws", "-", "1", ")", ",", "y_center", "-", "0.5", "*", "(", "hs", "-", "1", ")", ",", "\n", "x_center", "+", "0.5", "*", "(", "ws", "-", "1", ")", ",", "y_center", "+", "0.5", "*", "(", "hs", "-", "1", ")", "\n", "]", "\n", "base_anchors", "=", "torch", ".", "stack", "(", "base_anchors", ",", "dim", "=", "-", "1", ")", ".", "round", "(", ")", "\n", "\n", "return", "base_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.LegacySSDAnchorGenerator.__init__": [[581, 593], ["anchor_generator.SSDAnchorGenerator.__init__", "anchor_generator.LegacySSDAnchorGenerator.gen_base_anchors"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.SSDAnchorGenerator.gen_base_anchors"], ["def", "__init__", "(", "self", ",", "\n", "strides", ",", "\n", "ratios", ",", "\n", "basesize_ratio_range", ",", "\n", "input_size", "=", "300", ",", "\n", "scale_major", "=", "True", ")", ":", "\n", "        ", "super", "(", "LegacySSDAnchorGenerator", ",", "\n", "self", ")", ".", "__init__", "(", "strides", ",", "ratios", ",", "basesize_ratio_range", ",", "input_size", ",", "\n", "scale_major", ")", "\n", "self", ".", "centers", "=", "[", "(", "(", "stride", "-", "1", ")", "/", "2.", ",", "(", "stride", "-", "1", ")", "/", "2.", ")", "\n", "for", "stride", "in", "strides", "]", "\n", "self", ".", "base_anchors", "=", "self", ".", "gen_base_anchors", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator": [[6, 8], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["import", "numpy", "as", "np", "\n", "from", "mmcv", ".", "parallel", "import", "collate", "\n", "from", "mmcv", ".", "runner", "import", "get_dist_info", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator._meshgrid": [[9, 16], ["x.repeat", "y.view().repeat().view", "len", "y.view().repeat", "len", "y.view"], "methods", ["None"], ["    ", "def", "_meshgrid", "(", "self", ",", "x", ",", "y", ",", "row_major", "=", "True", ")", ":", "\n", "        ", "xx", "=", "x", ".", "repeat", "(", "len", "(", "y", ")", ")", "\n", "yy", "=", "y", ".", "view", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "len", "(", "x", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "row_major", ":", "\n", "            ", "return", "xx", ",", "yy", "\n", "", "else", ":", "\n", "            ", "return", "yy", ",", "xx", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.grid_points": [[17, 26], ["point_generator.PointGenerator._meshgrid", "shift_x.new_full", "torch.stack", "torch.stack.to", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator._meshgrid", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "", "def", "grid_points", "(", "self", ",", "featmap_size", ",", "stride", "=", "16", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "feat_h", ",", "feat_w", "=", "featmap_size", "\n", "shift_x", "=", "torch", ".", "arange", "(", "0.", ",", "feat_w", ",", "device", "=", "device", ")", "*", "stride", "\n", "shift_y", "=", "torch", ".", "arange", "(", "0.", ",", "feat_h", ",", "device", "=", "device", ")", "*", "stride", "\n", "shift_xx", ",", "shift_yy", "=", "self", ".", "_meshgrid", "(", "shift_x", ",", "shift_y", ")", "\n", "stride", "=", "shift_x", ".", "new_full", "(", "(", "shift_xx", ".", "shape", "[", "0", "]", ",", ")", ",", "stride", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "[", "shift_xx", ",", "shift_yy", ",", "stride", "]", ",", "dim", "=", "-", "1", ")", "\n", "all_points", "=", "shifts", ".", "to", "(", "device", ")", "\n", "return", "all_points", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags": [[27, 38], ["torch.zeros", "torch.zeros", "point_generator.PointGenerator._meshgrid"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator._meshgrid"], ["", "def", "valid_flags", "(", "self", ",", "featmap_size", ",", "valid_size", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "feat_h", ",", "feat_w", "=", "featmap_size", "\n", "valid_h", ",", "valid_w", "=", "valid_size", "\n", "assert", "valid_h", "<=", "feat_h", "and", "valid_w", "<=", "feat_w", "\n", "valid_x", "=", "torch", ".", "zeros", "(", "feat_w", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "valid_y", "=", "torch", ".", "zeros", "(", "feat_h", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "valid_x", "[", ":", "valid_w", "]", "=", "1", "\n", "valid_y", "[", ":", "valid_h", "]", "=", "1", "\n", "valid_xx", ",", "valid_yy", "=", "self", ".", "_meshgrid", "(", "valid_x", ",", "valid_y", ")", "\n", "valid", "=", "valid_xx", "&", "valid_yy", "\n", "return", "valid", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.images_to_levels": [[4, 18], ["torch.stack", "level_targets.append"], "function", ["None"], ["\n", "\n", "def", "reduce_loss", "(", "loss", ",", "reduction", ")", ":", "\n", "    ", "\"\"\"Reduce loss as specified.\n\n    Args:\n        loss (Tensor): Elementwise loss tensor.\n        reduction (str): Options are \"none\", \"mean\" and \"sum\".\n\n    Return:\n        Tensor: Reduced loss tensor.\n    \"\"\"", "\n", "reduction_enum", "=", "F", ".", "_Reduction", ".", "get_enum", "(", "reduction", ")", "\n", "# none: 0, elementwise_mean:1, sum: 2", "\n", "if", "reduction_enum", "==", "0", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.anchor_inside_flags": [[20, 47], ["None"], "function", ["None"], ["", "elif", "reduction_enum", "==", "1", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "elif", "reduction_enum", "==", "2", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "\n", "\n", "", "", "def", "weight_reduce_loss", "(", "loss", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "avg_factor", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply element-wise weight and reduce loss.\n\n    Args:\n        loss (Tensor): Element-wise loss.\n        weight (Tensor): Element-wise weights.\n        reduction (str): Same as built-in losses of PyTorch.\n        avg_factor (float): Avarage factor when computing the mean of losses.\n\n    Returns:\n        Tensor: Processed loss values.\n    \"\"\"", "\n", "# if weight is specified, apply element-wise weight", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "loss", "=", "loss", "*", "weight", "\n", "\n", "# if avg_factor is not specified, just reduce the loss", "\n", "", "if", "avg_factor", "is", "None", ":", "\n", "        ", "loss", "=", "reduce_loss", "(", "loss", ",", "reduction", ")", "\n", "", "else", ":", "\n", "# if reduction is mean, then average the loss by avg_factor", "\n", "        ", "if", "reduction", "==", "'mean'", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.utils.calc_region": [[49, 72], ["torch.round().long", "torch.round().long", "torch.round().long", "torch.round().long", "x1.clamp.clamp", "y1.clamp.clamp", "x2.clamp.clamp", "y2.clamp.clamp", "torch.round", "torch.round", "torch.round", "torch.round"], "function", ["None"], ["# if reduction is 'none', then do nothing, otherwise raise an error", "\n", "", "elif", "reduction", "!=", "'none'", ":", "\n", "            ", "raise", "ValueError", "(", "'avg_factor can not be used with reduction=\"sum\"'", ")", "\n", "", "", "return", "loss", "\n", "\n", "\n", "", "def", "weighted_loss", "(", "loss_func", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.average_precision": [[12, 57], ["numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.hstack", "numpy.hstack", "range", "range", "numpy.maximum", "numpy.sum", "range", "ValueError", "numpy.where", "numpy.arange", "precs.max"], "function", ["None"], ["def", "average_precision", "(", "recalls", ",", "precisions", ",", "mode", "=", "'area'", ")", ":", "\n", "    ", "\"\"\"Calculate average precision (for single or multiple scales).\n\n    Args:\n        recalls (ndarray): shape (num_scales, num_dets) or (num_dets, )\n        precisions (ndarray): shape (num_scales, num_dets) or (num_dets, )\n        mode (str): 'area' or '11points', 'area' means calculating the area\n            under precision-recall curve, '11points' means calculating\n            the average precision of recalls at [0, 0.1, ..., 1]\n\n    Returns:\n        float or ndarray: calculated average precision\n    \"\"\"", "\n", "no_scale", "=", "False", "\n", "if", "recalls", ".", "ndim", "==", "1", ":", "\n", "        ", "no_scale", "=", "True", "\n", "recalls", "=", "recalls", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "precisions", "=", "precisions", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "", "assert", "recalls", ".", "shape", "==", "precisions", ".", "shape", "and", "recalls", ".", "ndim", "==", "2", "\n", "num_scales", "=", "recalls", ".", "shape", "[", "0", "]", "\n", "ap", "=", "np", ".", "zeros", "(", "num_scales", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "mode", "==", "'area'", ":", "\n", "        ", "zeros", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "1", ")", ",", "dtype", "=", "recalls", ".", "dtype", ")", "\n", "ones", "=", "np", ".", "ones", "(", "(", "num_scales", ",", "1", ")", ",", "dtype", "=", "recalls", ".", "dtype", ")", "\n", "mrec", "=", "np", ".", "hstack", "(", "(", "zeros", ",", "recalls", ",", "ones", ")", ")", "\n", "mpre", "=", "np", ".", "hstack", "(", "(", "zeros", ",", "precisions", ",", "zeros", ")", ")", "\n", "for", "i", "in", "range", "(", "mpre", ".", "shape", "[", "1", "]", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", ":", ",", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", ":", ",", "i", "-", "1", "]", ",", "mpre", "[", ":", ",", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "mrec", "[", "i", ",", "1", ":", "]", "!=", "mrec", "[", "i", ",", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "ap", "[", "i", "]", "=", "np", ".", "sum", "(", "\n", "(", "mrec", "[", "i", ",", "ind", "+", "1", "]", "-", "mrec", "[", "i", ",", "ind", "]", ")", "*", "mpre", "[", "i", ",", "ind", "+", "1", "]", ")", "\n", "", "", "elif", "mode", "==", "'11points'", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "for", "thr", "in", "np", ".", "arange", "(", "0", ",", "1", "+", "1e-3", ",", "0.1", ")", ":", "\n", "                ", "precs", "=", "precisions", "[", "i", ",", "recalls", "[", "i", ",", ":", "]", ">=", "thr", "]", "\n", "prec", "=", "precs", ".", "max", "(", ")", "if", "precs", ".", "size", ">", "0", "else", "0", "\n", "ap", "[", "i", "]", "+=", "prec", "\n", "", "ap", "/=", "11", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'Unrecognized mode, only \"area\" and \"11points\" are supported'", ")", "\n", "", "if", "no_scale", ":", "\n", "        ", "ap", "=", "ap", "[", "0", "]", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.tpfp_imagenet": [[59, 151], ["numpy.concatenate", "numpy.vstack", "len", "numpy.zeros", "numpy.zeros", "bbox_overlaps.bbox_overlaps", "numpy.minimum", "numpy.argsort", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.ones", "enumerate", "numpy.zeros_like", "range"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["", "def", "tpfp_imagenet", "(", "det_bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "default_iou_thr", "=", "0.5", ",", "\n", "area_ranges", "=", "None", ")", ":", "\n", "    ", "\"\"\"Check if detected bboxes are true positive or false positive.\n\n    Args:\n        det_bbox (ndarray): Detected bboxes of this image, of shape (m, 5).\n        gt_bboxes (ndarray): GT bboxes of this image, of shape (n, 4).\n        gt_bboxes_ignore (ndarray): Ignored gt bboxes of this image,\n            of shape (k, 4). Default: None\n        default_iou_thr (float): IoU threshold to be considered as matched for\n            medium and large bboxes (small ones have special rules).\n            Default: 0.5.\n        area_ranges (list[tuple] | None): Range of bbox areas to be evaluated,\n            in the format [(min1, max1), (min2, max2), ...]. Default: None.\n\n    Returns:\n        tuple[np.ndarray]: (tp, fp) whose elements are 0 and 1. The shape of\n            each array is (num_scales, m).\n    \"\"\"", "\n", "# an indicator of ignored gts", "\n", "gt_ignore_inds", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "zeros", "(", "gt_bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ",", "\n", "np", ".", "ones", "(", "gt_bboxes_ignore", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ")", ")", "\n", "# stack gt_bboxes and gt_bboxes_ignore for convenience", "\n", "gt_bboxes", "=", "np", ".", "vstack", "(", "(", "gt_bboxes", ",", "gt_bboxes_ignore", ")", ")", "\n", "\n", "num_dets", "=", "det_bboxes", ".", "shape", "[", "0", "]", "\n", "num_gts", "=", "gt_bboxes", ".", "shape", "[", "0", "]", "\n", "if", "area_ranges", "is", "None", ":", "\n", "        ", "area_ranges", "=", "[", "(", "None", ",", "None", ")", "]", "\n", "", "num_scales", "=", "len", "(", "area_ranges", ")", "\n", "# tp and fp are of shape (num_scales, num_gts), each row is tp or fp", "\n", "# of a certain scale.", "\n", "tp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "gt_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "if", "area_ranges", "==", "[", "(", "None", ",", "None", ")", "]", ":", "\n", "            ", "fp", "[", "...", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "det_areas", "=", "(", "det_bboxes", "[", ":", ",", "2", "]", "-", "det_bboxes", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "det_bboxes", "[", ":", ",", "3", "]", "-", "det_bboxes", "[", ":", ",", "1", "]", ")", "\n", "for", "i", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "                ", "fp", "[", "i", ",", "(", "det_areas", ">=", "min_area", ")", "&", "(", "det_areas", "<", "max_area", ")", "]", "=", "1", "\n", "", "", "return", "tp", ",", "fp", "\n", "", "ious", "=", "bbox_overlaps", "(", "det_bboxes", ",", "gt_bboxes", "-", "1", ")", "\n", "gt_w", "=", "gt_bboxes", "[", ":", ",", "2", "]", "-", "gt_bboxes", "[", ":", ",", "0", "]", "\n", "gt_h", "=", "gt_bboxes", "[", ":", ",", "3", "]", "-", "gt_bboxes", "[", ":", ",", "1", "]", "\n", "iou_thrs", "=", "np", ".", "minimum", "(", "(", "gt_w", "*", "gt_h", ")", "/", "(", "(", "gt_w", "+", "10.0", ")", "*", "(", "gt_h", "+", "10.0", ")", ")", ",", "\n", "default_iou_thr", ")", "\n", "# sort all detections by scores in descending order", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "det_bboxes", "[", ":", ",", "-", "1", "]", ")", "\n", "for", "k", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "        ", "gt_covered", "=", "np", ".", "zeros", "(", "num_gts", ",", "dtype", "=", "bool", ")", "\n", "# if no area range is specified, gt_area_ignore is all False", "\n", "if", "min_area", "is", "None", ":", "\n", "            ", "gt_area_ignore", "=", "np", ".", "zeros_like", "(", "gt_ignore_inds", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "            ", "gt_areas", "=", "gt_w", "*", "gt_h", "\n", "gt_area_ignore", "=", "(", "gt_areas", "<", "min_area", ")", "|", "(", "gt_areas", ">=", "max_area", ")", "\n", "", "for", "i", "in", "sort_inds", ":", "\n", "            ", "max_iou", "=", "-", "1", "\n", "matched_gt", "=", "-", "1", "\n", "# find best overlapped available gt", "\n", "for", "j", "in", "range", "(", "num_gts", ")", ":", "\n", "# different from PASCAL VOC: allow finding other gts if the", "\n", "# best overlaped ones are already matched by other det bboxes", "\n", "                ", "if", "gt_covered", "[", "j", "]", ":", "\n", "                    ", "continue", "\n", "", "elif", "ious", "[", "i", ",", "j", "]", ">=", "iou_thrs", "[", "j", "]", "and", "ious", "[", "i", ",", "j", "]", ">", "max_iou", ":", "\n", "                    ", "max_iou", "=", "ious", "[", "i", ",", "j", "]", "\n", "matched_gt", "=", "j", "\n", "# there are 4 cases for a det bbox:", "\n", "# 1. it matches a gt, tp = 1, fp = 0", "\n", "# 2. it matches an ignored gt, tp = 0, fp = 0", "\n", "# 3. it matches no gt and within area range, tp = 0, fp = 1", "\n", "# 4. it matches no gt but is beyond area range, tp = 0, fp = 0", "\n", "", "", "if", "matched_gt", ">=", "0", ":", "\n", "                ", "gt_covered", "[", "matched_gt", "]", "=", "1", "\n", "if", "not", "(", "gt_ignore_inds", "[", "matched_gt", "]", "\n", "or", "gt_area_ignore", "[", "matched_gt", "]", ")", ":", "\n", "                    ", "tp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "", "elif", "min_area", "is", "None", ":", "\n", "                ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "bbox", "=", "det_bboxes", "[", "i", ",", ":", "4", "]", "\n", "area", "=", "(", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", ")", "*", "(", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", ")", "\n", "if", "area", ">=", "min_area", "and", "area", "<", "max_area", ":", "\n", "                    ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "", "", "", "return", "tp", ",", "fp", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.tpfp_default": [[153, 238], ["numpy.concatenate", "numpy.vstack", "len", "numpy.zeros", "numpy.zeros", "bbox_overlaps.bbox_overlaps", "bbox_overlaps.bbox_overlaps.max", "bbox_overlaps.bbox_overlaps.argmax", "numpy.argsort", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.ones", "enumerate", "numpy.zeros_like"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["", "def", "tpfp_default", "(", "det_bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "area_ranges", "=", "None", ")", ":", "\n", "    ", "\"\"\"Check if detected bboxes are true positive or false positive.\n\n    Args:\n        det_bbox (ndarray): Detected bboxes of this image, of shape (m, 5).\n        gt_bboxes (ndarray): GT bboxes of this image, of shape (n, 4).\n        gt_bboxes_ignore (ndarray): Ignored gt bboxes of this image,\n            of shape (k, 4). Default: None\n        iou_thr (float): IoU threshold to be considered as matched.\n            Default: 0.5.\n        area_ranges (list[tuple] | None): Range of bbox areas to be evaluated,\n            in the format [(min1, max1), (min2, max2), ...]. Default: None.\n\n    Returns:\n        tuple[np.ndarray]: (tp, fp) whose elements are 0 and 1. The shape of\n            each array is (num_scales, m).\n    \"\"\"", "\n", "# an indicator of ignored gts", "\n", "gt_ignore_inds", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "zeros", "(", "gt_bboxes", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ",", "\n", "np", ".", "ones", "(", "gt_bboxes_ignore", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ")", ")", "\n", "# stack gt_bboxes and gt_bboxes_ignore for convenience", "\n", "gt_bboxes", "=", "np", ".", "vstack", "(", "(", "gt_bboxes", ",", "gt_bboxes_ignore", ")", ")", "\n", "\n", "num_dets", "=", "det_bboxes", ".", "shape", "[", "0", "]", "\n", "num_gts", "=", "gt_bboxes", ".", "shape", "[", "0", "]", "\n", "if", "area_ranges", "is", "None", ":", "\n", "        ", "area_ranges", "=", "[", "(", "None", ",", "None", ")", "]", "\n", "", "num_scales", "=", "len", "(", "area_ranges", ")", "\n", "# tp and fp are of shape (num_scales, num_gts), each row is tp or fp of", "\n", "# a certain scale", "\n", "tp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# if there is no gt bboxes in this image, then all det bboxes", "\n", "# within area range are false positives", "\n", "if", "gt_bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "if", "area_ranges", "==", "[", "(", "None", ",", "None", ")", "]", ":", "\n", "            ", "fp", "[", "...", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "det_areas", "=", "(", "det_bboxes", "[", ":", ",", "2", "]", "-", "det_bboxes", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "det_bboxes", "[", ":", ",", "3", "]", "-", "det_bboxes", "[", ":", ",", "1", "]", ")", "\n", "for", "i", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "                ", "fp", "[", "i", ",", "(", "det_areas", ">=", "min_area", ")", "&", "(", "det_areas", "<", "max_area", ")", "]", "=", "1", "\n", "", "", "return", "tp", ",", "fp", "\n", "\n", "", "ious", "=", "bbox_overlaps", "(", "det_bboxes", ",", "gt_bboxes", ")", "\n", "# for each det, the max iou with all gts", "\n", "ious_max", "=", "ious", ".", "max", "(", "axis", "=", "1", ")", "\n", "# for each det, which gt overlaps most with it", "\n", "ious_argmax", "=", "ious", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "# sort all dets in descending order by scores", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "det_bboxes", "[", ":", ",", "-", "1", "]", ")", "\n", "for", "k", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "        ", "gt_covered", "=", "np", ".", "zeros", "(", "num_gts", ",", "dtype", "=", "bool", ")", "\n", "# if no area range is specified, gt_area_ignore is all False", "\n", "if", "min_area", "is", "None", ":", "\n", "            ", "gt_area_ignore", "=", "np", ".", "zeros_like", "(", "gt_ignore_inds", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "            ", "gt_areas", "=", "(", "gt_bboxes", "[", ":", ",", "2", "]", "-", "gt_bboxes", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "gt_bboxes", "[", ":", ",", "3", "]", "-", "gt_bboxes", "[", ":", ",", "1", "]", ")", "\n", "gt_area_ignore", "=", "(", "gt_areas", "<", "min_area", ")", "|", "(", "gt_areas", ">=", "max_area", ")", "\n", "", "for", "i", "in", "sort_inds", ":", "\n", "            ", "if", "ious_max", "[", "i", "]", ">=", "iou_thr", ":", "\n", "                ", "matched_gt", "=", "ious_argmax", "[", "i", "]", "\n", "if", "not", "(", "gt_ignore_inds", "[", "matched_gt", "]", "\n", "or", "gt_area_ignore", "[", "matched_gt", "]", ")", ":", "\n", "                    ", "if", "not", "gt_covered", "[", "matched_gt", "]", ":", "\n", "                        ", "gt_covered", "[", "matched_gt", "]", "=", "True", "\n", "tp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "else", ":", "\n", "                        ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "# otherwise ignore this detected bbox, tp = 0, fp = 0", "\n", "", "", "", "elif", "min_area", "is", "None", ":", "\n", "                ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "bbox", "=", "det_bboxes", "[", "i", ",", ":", "4", "]", "\n", "area", "=", "(", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", ")", "*", "(", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", ")", "\n", "if", "area", ">=", "min_area", "and", "area", "<", "max_area", ":", "\n", "                    ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "", "", "", "return", "tp", ",", "fp", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.get_cls_results": [[240, 265], ["cls_gts.append", "ann.get", "cls_gts_ignore.append", "cls_gts_ignore.append", "numpy.empty"], "function", ["None"], ["", "def", "get_cls_results", "(", "det_results", ",", "annotations", ",", "class_id", ")", ":", "\n", "    ", "\"\"\"Get det results and gt information of a certain class.\n\n    Args:\n        det_results (list[list]): Same as `eval_map()`.\n        annotations (list[dict]): Same as `eval_map()`.\n        class_id (int): ID of a specific class.\n\n    Returns:\n        tuple[list[np.ndarray]]: detected bboxes, gt bboxes, ignored gt bboxes\n    \"\"\"", "\n", "cls_dets", "=", "[", "img_res", "[", "class_id", "]", "for", "img_res", "in", "det_results", "]", "\n", "cls_gts", "=", "[", "]", "\n", "cls_gts_ignore", "=", "[", "]", "\n", "for", "ann", "in", "annotations", ":", "\n", "        ", "gt_inds", "=", "ann", "[", "'labels'", "]", "==", "class_id", "\n", "cls_gts", ".", "append", "(", "ann", "[", "'bboxes'", "]", "[", "gt_inds", ",", ":", "]", ")", "\n", "\n", "if", "ann", ".", "get", "(", "'labels_ignore'", ",", "None", ")", "is", "not", "None", ":", "\n", "            ", "ignore_inds", "=", "ann", "[", "'labels_ignore'", "]", "==", "class_id", "\n", "cls_gts_ignore", ".", "append", "(", "ann", "[", "'bboxes_ignore'", "]", "[", "ignore_inds", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "cls_gts_ignore", ".", "append", "(", "np", ".", "empty", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "\n", "", "", "return", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.eval_map": [[267, 391], ["len", "len", "multiprocessing.Pool", "range", "multiprocessing.Pool.close", "mean_ap.print_map_summary", "len", "len", "len", "mean_ap.get_cls_results", "multiprocessing.Pool.starmap", "tuple", "numpy.zeros", "enumerate", "numpy.vstack", "numpy.argsort", "numpy.cumsum", "numpy.cumsum", "mean_ap.average_precision", "eval_results.append", "numpy.vstack", "numpy.vstack", "range", "zip", "zip", "numpy.hstack", "numpy.hstack", "numpy.finfo", "numpy.maximum", "numpy.maximum", "num_gts.item.item", "numpy.any", "numpy.array().mean().item", "enumerate", "mean_ap.append", "mean_ap.append", "aps.append", "numpy.sum", "all_ap[].mean", "numpy.array().mean", "range", "range", "numpy.array"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.print_map_summary", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.get_cls_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.average_precision"], ["", "def", "eval_map", "(", "det_results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "dataset", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", "nproc", "=", "4", ")", ":", "\n", "    ", "\"\"\"Evaluate mAP of a dataset.\n\n    Args:\n        det_results (list[list]): [[cls1_det, cls2_det, ...], ...].\n            The outer list indicates images, and the inner list indicates\n            per-class detected bboxes.\n        annotations (list[dict]): Ground truth annotations where each item of\n            the list indicates an image. Keys of annotations are:\n\n            - `bboxes`: numpy array of shape (n, 4)\n            - `labels`: numpy array of shape (n, )\n            - `bboxes_ignore` (optional): numpy array of shape (k, 4)\n            - `labels_ignore` (optional): numpy array of shape (k, )\n        scale_ranges (list[tuple] | None): Range of scales to be evaluated,\n            in the format [(min1, max1), (min2, max2), ...]. A range of\n            (32, 64) means the area range between (32**2, 64**2).\n            Default: None.\n        iou_thr (float): IoU threshold to be considered as matched.\n            Default: 0.5.\n        dataset (list[str] | str | None): Dataset name or dataset classes,\n            there are minor differences in metrics for different datsets, e.g.\n            \"voc07\", \"imagenet_det\", etc. Default: None.\n        logger (logging.Logger | str | None): The way to print the mAP\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n        nproc (int): Processes used for computing TP and FP.\n            Default: 4.\n\n    Returns:\n        tuple: (mAP, [dict, dict, ...])\n    \"\"\"", "\n", "assert", "len", "(", "det_results", ")", "==", "len", "(", "annotations", ")", "\n", "\n", "num_imgs", "=", "len", "(", "det_results", ")", "\n", "num_scales", "=", "len", "(", "scale_ranges", ")", "if", "scale_ranges", "is", "not", "None", "else", "1", "\n", "num_classes", "=", "len", "(", "det_results", "[", "0", "]", ")", "# positive class num", "\n", "area_ranges", "=", "(", "[", "(", "rg", "[", "0", "]", "**", "2", ",", "rg", "[", "1", "]", "**", "2", ")", "for", "rg", "in", "scale_ranges", "]", "\n", "if", "scale_ranges", "is", "not", "None", "else", "None", ")", "\n", "\n", "pool", "=", "Pool", "(", "nproc", ")", "\n", "eval_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "# get gt and det bboxes of this class", "\n", "        ", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", "=", "get_cls_results", "(", "\n", "det_results", ",", "annotations", ",", "i", ")", "\n", "# choose proper function according to datasets to compute tp and fp", "\n", "if", "dataset", "in", "[", "'det'", ",", "'vid'", "]", ":", "\n", "            ", "tpfp_func", "=", "tpfp_imagenet", "\n", "", "else", ":", "\n", "            ", "tpfp_func", "=", "tpfp_default", "\n", "# compute tp and fp for each image with multiple processes", "\n", "", "tpfp", "=", "pool", ".", "starmap", "(", "\n", "tpfp_func", ",", "\n", "zip", "(", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", ",", "\n", "[", "iou_thr", "for", "_", "in", "range", "(", "num_imgs", ")", "]", ",", "\n", "[", "area_ranges", "for", "_", "in", "range", "(", "num_imgs", ")", "]", ")", ")", "\n", "tp", ",", "fp", "=", "tuple", "(", "zip", "(", "*", "tpfp", ")", ")", "\n", "# calculate gt number of each scale", "\n", "# ignored gts or gts beyond the specific scale are not counted", "\n", "num_gts", "=", "np", ".", "zeros", "(", "num_scales", ",", "dtype", "=", "int", ")", "\n", "for", "j", ",", "bbox", "in", "enumerate", "(", "cls_gts", ")", ":", "\n", "            ", "if", "area_ranges", "is", "None", ":", "\n", "                ", "num_gts", "[", "0", "]", "+=", "bbox", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "gt_areas", "=", "(", "bbox", "[", ":", ",", "2", "]", "-", "bbox", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "bbox", "[", ":", ",", "3", "]", "-", "bbox", "[", ":", ",", "1", "]", ")", "\n", "for", "k", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "                    ", "num_gts", "[", "k", "]", "+=", "np", ".", "sum", "(", "(", "gt_areas", ">=", "min_area", ")", "\n", "&", "(", "gt_areas", "<", "max_area", ")", ")", "\n", "# sort all det bboxes by score, also sort tp and fp", "\n", "", "", "", "cls_dets", "=", "np", ".", "vstack", "(", "cls_dets", ")", "\n", "num_dets", "=", "cls_dets", ".", "shape", "[", "0", "]", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "cls_dets", "[", ":", ",", "-", "1", "]", ")", "\n", "tp", "=", "np", ".", "hstack", "(", "tp", ")", "[", ":", ",", "sort_inds", "]", "\n", "fp", "=", "np", ".", "hstack", "(", "fp", ")", "[", ":", ",", "sort_inds", "]", "\n", "# calculate recall and precision with tp and fp", "\n", "tp", "=", "np", ".", "cumsum", "(", "tp", ",", "axis", "=", "1", ")", "\n", "fp", "=", "np", ".", "cumsum", "(", "fp", ",", "axis", "=", "1", ")", "\n", "eps", "=", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", "\n", "recalls", "=", "tp", "/", "np", ".", "maximum", "(", "num_gts", "[", ":", ",", "np", ".", "newaxis", "]", ",", "eps", ")", "\n", "precisions", "=", "tp", "/", "np", ".", "maximum", "(", "(", "tp", "+", "fp", ")", ",", "eps", ")", "\n", "# calculate AP", "\n", "if", "scale_ranges", "is", "None", ":", "\n", "            ", "recalls", "=", "recalls", "[", "0", ",", ":", "]", "\n", "precisions", "=", "precisions", "[", "0", ",", ":", "]", "\n", "num_gts", "=", "num_gts", ".", "item", "(", ")", "\n", "", "mode", "=", "'area'", "if", "dataset", "!=", "'voc07'", "else", "'11points'", "\n", "ap", "=", "average_precision", "(", "recalls", ",", "precisions", ",", "mode", ")", "\n", "eval_results", ".", "append", "(", "{", "\n", "'num_gts'", ":", "num_gts", ",", "\n", "'num_dets'", ":", "num_dets", ",", "\n", "'recall'", ":", "recalls", ",", "\n", "'precision'", ":", "precisions", ",", "\n", "'ap'", ":", "ap", "\n", "}", ")", "\n", "", "pool", ".", "close", "(", ")", "\n", "if", "scale_ranges", "is", "not", "None", ":", "\n", "# shape (num_classes, num_scales)", "\n", "        ", "all_ap", "=", "np", ".", "vstack", "(", "[", "cls_result", "[", "'ap'", "]", "for", "cls_result", "in", "eval_results", "]", ")", "\n", "all_num_gts", "=", "np", ".", "vstack", "(", "\n", "[", "cls_result", "[", "'num_gts'", "]", "for", "cls_result", "in", "eval_results", "]", ")", "\n", "mean_ap", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "if", "np", ".", "any", "(", "all_num_gts", "[", ":", ",", "i", "]", ">", "0", ")", ":", "\n", "                ", "mean_ap", ".", "append", "(", "all_ap", "[", "all_num_gts", "[", ":", ",", "i", "]", ">", "0", ",", "i", "]", ".", "mean", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "mean_ap", ".", "append", "(", "0.0", ")", "\n", "", "", "", "else", ":", "\n", "        ", "aps", "=", "[", "]", "\n", "for", "cls_result", "in", "eval_results", ":", "\n", "            ", "if", "cls_result", "[", "'num_gts'", "]", ">", "0", ":", "\n", "                ", "aps", ".", "append", "(", "cls_result", "[", "'ap'", "]", ")", "\n", "", "", "mean_ap", "=", "np", ".", "array", "(", "aps", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "if", "aps", "else", "0.0", "\n", "\n", "", "print_map_summary", "(", "\n", "mean_ap", ",", "eval_results", ",", "dataset", ",", "area_ranges", ",", "logger", "=", "logger", ")", "\n", "\n", "return", "mean_ap", ",", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.print_map_summary": [[393, 459], ["isinstance", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "range", "len", "mmcv.is_str", "isinstance", "range", "table_data.append", "terminaltables.AsciiTable", "mmcv.utils.print_log", "len", "str", "class_names.get_classes", "mmcv.utils.print_log", "table_data.append", "numpy.array", "range"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.get_classes"], ["", "def", "print_map_summary", "(", "mean_ap", ",", "\n", "results", ",", "\n", "dataset", "=", "None", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "logger", "=", "None", ")", ":", "\n", "    ", "\"\"\"Print mAP and results of each class.\n\n    A table will be printed to show the gts/dets/recall/AP of each class and\n    the mAP.\n\n    Args:\n        mean_ap (float): Calculated from `eval_map()`.\n        results (list[dict]): Calculated from `eval_map()`.\n        dataset (list[str] | str | None): Dataset name or dataset classes.\n        scale_ranges (list[tuple] | None): Range of scales to be evaluated.\n        logger (logging.Logger | str | None): The way to print the mAP\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n    \"\"\"", "\n", "\n", "if", "logger", "==", "'silent'", ":", "\n", "        ", "return", "\n", "\n", "", "if", "isinstance", "(", "results", "[", "0", "]", "[", "'ap'", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "num_scales", "=", "len", "(", "results", "[", "0", "]", "[", "'ap'", "]", ")", "\n", "", "else", ":", "\n", "        ", "num_scales", "=", "1", "\n", "\n", "", "if", "scale_ranges", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "scale_ranges", ")", "==", "num_scales", "\n", "\n", "", "num_classes", "=", "len", "(", "results", ")", "\n", "\n", "recalls", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "aps", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "num_gts", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", ",", "cls_result", "in", "enumerate", "(", "results", ")", ":", "\n", "        ", "if", "cls_result", "[", "'recall'", "]", ".", "size", ">", "0", ":", "\n", "            ", "recalls", "[", ":", ",", "i", "]", "=", "np", ".", "array", "(", "cls_result", "[", "'recall'", "]", ",", "ndmin", "=", "2", ")", "[", ":", ",", "-", "1", "]", "\n", "", "aps", "[", ":", ",", "i", "]", "=", "cls_result", "[", "'ap'", "]", "\n", "num_gts", "[", ":", ",", "i", "]", "=", "cls_result", "[", "'num_gts'", "]", "\n", "\n", "", "if", "dataset", "is", "None", ":", "\n", "        ", "label_names", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "num_classes", ")", "]", "\n", "", "elif", "mmcv", ".", "is_str", "(", "dataset", ")", ":", "\n", "        ", "label_names", "=", "get_classes", "(", "dataset", ")", "\n", "", "else", ":", "\n", "        ", "label_names", "=", "dataset", "\n", "\n", "", "if", "not", "isinstance", "(", "mean_ap", ",", "list", ")", ":", "\n", "        ", "mean_ap", "=", "[", "mean_ap", "]", "\n", "\n", "", "header", "=", "[", "'class'", ",", "'gts'", ",", "'dets'", ",", "'recall'", ",", "'ap'", "]", "\n", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "        ", "if", "scale_ranges", "is", "not", "None", ":", "\n", "            ", "print_log", "(", "f'Scale range {scale_ranges[i]}'", ",", "logger", "=", "logger", ")", "\n", "", "table_data", "=", "[", "header", "]", "\n", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "row_data", "=", "[", "\n", "label_names", "[", "j", "]", ",", "num_gts", "[", "i", ",", "j", "]", ",", "results", "[", "j", "]", "[", "'num_dets'", "]", ",", "\n", "f'{recalls[i, j]:.3f}'", ",", "f'{aps[i, j]:.3f}'", "\n", "]", "\n", "table_data", ".", "append", "(", "row_data", ")", "\n", "", "table_data", ".", "append", "(", "[", "'mAP'", ",", "''", ",", "''", ",", "''", ",", "f'{mean_ap[i]:.3f}'", "]", ")", "\n", "table", "=", "AsciiTable", "(", "table_data", ")", "\n", "table", ".", "inner_footing_row_border", "=", "True", "\n", "print_log", "(", "'\\n'", "+", "table", ".", "table", ",", "logger", "=", "logger", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall._recalls": [[10, 41], ["sum", "numpy.zeros", "enumerate", "numpy.fliplr", "numpy.zeros", "enumerate", "numpy.zeros", "range", "numpy.sort", "[].copy", "numpy.zeros", "range", "numpy.hstack", "float", "numpy.hstack", "[].copy.argmax", "max_ious.argmax", "numpy.arange"], "function", ["None"], ["def", "_recalls", "(", "all_ious", ",", "proposal_nums", ",", "thrs", ")", ":", "\n", "\n", "    ", "img_num", "=", "all_ious", ".", "shape", "[", "0", "]", "\n", "total_gt_num", "=", "sum", "(", "[", "ious", ".", "shape", "[", "0", "]", "for", "ious", "in", "all_ious", "]", ")", "\n", "\n", "_ious", "=", "np", ".", "zeros", "(", "(", "proposal_nums", ".", "size", ",", "total_gt_num", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "k", ",", "proposal_num", "in", "enumerate", "(", "proposal_nums", ")", ":", "\n", "        ", "tmp_ious", "=", "np", ".", "zeros", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "img_num", ")", ":", "\n", "            ", "ious", "=", "all_ious", "[", "i", "]", "[", ":", ",", ":", "proposal_num", "]", ".", "copy", "(", ")", "\n", "gt_ious", "=", "np", ".", "zeros", "(", "(", "ious", ".", "shape", "[", "0", "]", ")", ")", "\n", "if", "ious", ".", "size", "==", "0", ":", "\n", "                ", "tmp_ious", "=", "np", ".", "hstack", "(", "(", "tmp_ious", ",", "gt_ious", ")", ")", "\n", "continue", "\n", "", "for", "j", "in", "range", "(", "ious", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "gt_max_overlaps", "=", "ious", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_ious", "=", "ious", "[", "np", ".", "arange", "(", "0", ",", "ious", ".", "shape", "[", "0", "]", ")", ",", "gt_max_overlaps", "]", "\n", "gt_idx", "=", "max_ious", ".", "argmax", "(", ")", "\n", "gt_ious", "[", "j", "]", "=", "max_ious", "[", "gt_idx", "]", "\n", "box_idx", "=", "gt_max_overlaps", "[", "gt_idx", "]", "\n", "ious", "[", "gt_idx", ",", ":", "]", "=", "-", "1", "\n", "ious", "[", ":", ",", "box_idx", "]", "=", "-", "1", "\n", "", "tmp_ious", "=", "np", ".", "hstack", "(", "(", "tmp_ious", ",", "gt_ious", ")", ")", "\n", "", "_ious", "[", "k", ",", ":", "]", "=", "tmp_ious", "\n", "\n", "", "_ious", "=", "np", ".", "fliplr", "(", "np", ".", "sort", "(", "_ious", ",", "axis", "=", "1", ")", ")", "\n", "recalls", "=", "np", ".", "zeros", "(", "(", "proposal_nums", ".", "size", ",", "thrs", ".", "size", ")", ")", "\n", "for", "i", ",", "thr", "in", "enumerate", "(", "thrs", ")", ":", "\n", "        ", "recalls", "[", ":", ",", "i", "]", "=", "(", "_ious", ">=", "thr", ")", ".", "sum", "(", "axis", "=", "1", ")", "/", "float", "(", "total_gt_num", ")", "\n", "\n", "", "return", "recalls", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.set_recall_param": [[43, 62], ["isinstance", "numpy.array", "isinstance", "numpy.array", "isinstance", "numpy.array", "numpy.array", "isinstance", "numpy.array"], "function", ["None"], ["", "def", "set_recall_param", "(", "proposal_nums", ",", "iou_thrs", ")", ":", "\n", "    ", "\"\"\"Check proposal_nums and iou_thrs and set correct format.\"\"\"", "\n", "if", "isinstance", "(", "proposal_nums", ",", "Sequence", ")", ":", "\n", "        ", "_proposal_nums", "=", "np", ".", "array", "(", "proposal_nums", ")", "\n", "", "elif", "isinstance", "(", "proposal_nums", ",", "int", ")", ":", "\n", "        ", "_proposal_nums", "=", "np", ".", "array", "(", "[", "proposal_nums", "]", ")", "\n", "", "else", ":", "\n", "        ", "_proposal_nums", "=", "proposal_nums", "\n", "\n", "", "if", "iou_thrs", "is", "None", ":", "\n", "        ", "_iou_thrs", "=", "np", ".", "array", "(", "[", "0.5", "]", ")", "\n", "", "elif", "isinstance", "(", "iou_thrs", ",", "Sequence", ")", ":", "\n", "        ", "_iou_thrs", "=", "np", ".", "array", "(", "iou_thrs", ")", "\n", "", "elif", "isinstance", "(", "iou_thrs", ",", "float", ")", ":", "\n", "        ", "_iou_thrs", "=", "np", ".", "array", "(", "[", "iou_thrs", "]", ")", "\n", "", "else", ":", "\n", "        ", "_iou_thrs", "=", "iou_thrs", "\n", "\n", "", "return", "_proposal_nums", ",", "_iou_thrs", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.eval_recalls": [[64, 107], ["len", "recall.set_recall_param", "range", "numpy.array", "recall._recalls", "recall.print_recall_summary", "len", "min", "np.array.append", "numpy.zeros", "bbox_overlaps.bbox_overlaps", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.set_recall_param", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall._recalls", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.print_recall_summary", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["", "def", "eval_recalls", "(", "gts", ",", "\n", "proposals", ",", "\n", "proposal_nums", "=", "None", ",", "\n", "iou_thrs", "=", "0.5", ",", "\n", "logger", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate recalls.\n\n    Args:\n        gts (list[ndarray]): a list of arrays of shape (n, 4)\n        proposals (list[ndarray]): a list of arrays of shape (k, 4) or (k, 5)\n        proposal_nums (int | Sequence[int]): Top N proposals to be evaluated.\n        iou_thrs (float | Sequence[float]): IoU thresholds. Default: 0.5.\n        logger (logging.Logger | str | None): The way to print the recall\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n\n    Returns:\n        ndarray: recalls of different ious and proposal nums\n    \"\"\"", "\n", "\n", "img_num", "=", "len", "(", "gts", ")", "\n", "assert", "img_num", "==", "len", "(", "proposals", ")", "\n", "\n", "proposal_nums", ",", "iou_thrs", "=", "set_recall_param", "(", "proposal_nums", ",", "iou_thrs", ")", "\n", "\n", "all_ious", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "img_num", ")", ":", "\n", "        ", "if", "proposals", "[", "i", "]", ".", "ndim", "==", "2", "and", "proposals", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "            ", "scores", "=", "proposals", "[", "i", "]", "[", ":", ",", "4", "]", "\n", "sort_idx", "=", "np", ".", "argsort", "(", "scores", ")", "[", ":", ":", "-", "1", "]", "\n", "img_proposal", "=", "proposals", "[", "i", "]", "[", "sort_idx", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "img_proposal", "=", "proposals", "[", "i", "]", "\n", "", "prop_num", "=", "min", "(", "img_proposal", ".", "shape", "[", "0", "]", ",", "proposal_nums", "[", "-", "1", "]", ")", "\n", "if", "gts", "[", "i", "]", "is", "None", "or", "gts", "[", "i", "]", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "ious", "=", "np", ".", "zeros", "(", "(", "0", ",", "img_proposal", ".", "shape", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "ious", "=", "bbox_overlaps", "(", "gts", "[", "i", "]", ",", "img_proposal", "[", ":", "prop_num", ",", ":", "4", "]", ")", "\n", "", "all_ious", ".", "append", "(", "ious", ")", "\n", "", "all_ious", "=", "np", ".", "array", "(", "all_ious", ")", "\n", "recalls", "=", "_recalls", "(", "all_ious", ",", "proposal_nums", ",", "iou_thrs", ")", "\n", "\n", "print_recall_summary", "(", "recalls", ",", "proposal_nums", ",", "iou_thrs", ",", "logger", "=", "logger", ")", "\n", "return", "recalls", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.print_recall_summary": [[109, 140], ["numpy.array", "numpy.array", "enumerate", "terminaltables.AsciiTable", "mmcv.utils.print_log", "numpy.arange", "numpy.arange", "iou_thrs[].tolist", "row.insert", "table_data.append", "recalls[].tolist"], "function", ["None"], ["", "def", "print_recall_summary", "(", "recalls", ",", "\n", "proposal_nums", ",", "\n", "iou_thrs", ",", "\n", "row_idxs", "=", "None", ",", "\n", "col_idxs", "=", "None", ",", "\n", "logger", "=", "None", ")", ":", "\n", "    ", "\"\"\"Print recalls in a table.\n\n    Args:\n        recalls (ndarray): calculated from `bbox_recalls`\n        proposal_nums (ndarray or list): top N proposals\n        iou_thrs (ndarray or list): iou thresholds\n        row_idxs (ndarray): which rows(proposal nums) to print\n        col_idxs (ndarray): which cols(iou thresholds) to print\n        logger (logging.Logger | str | None): The way to print the recall\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n    \"\"\"", "\n", "proposal_nums", "=", "np", ".", "array", "(", "proposal_nums", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "iou_thrs", "=", "np", ".", "array", "(", "iou_thrs", ")", "\n", "if", "row_idxs", "is", "None", ":", "\n", "        ", "row_idxs", "=", "np", ".", "arange", "(", "proposal_nums", ".", "size", ")", "\n", "", "if", "col_idxs", "is", "None", ":", "\n", "        ", "col_idxs", "=", "np", ".", "arange", "(", "iou_thrs", ".", "size", ")", "\n", "", "row_header", "=", "[", "''", "]", "+", "iou_thrs", "[", "col_idxs", "]", ".", "tolist", "(", ")", "\n", "table_data", "=", "[", "row_header", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "proposal_nums", "[", "row_idxs", "]", ")", ":", "\n", "        ", "row", "=", "[", "f'{val:.3f}'", "for", "val", "in", "recalls", "[", "row_idxs", "[", "i", "]", ",", "col_idxs", "]", ".", "tolist", "(", ")", "]", "\n", "row", ".", "insert", "(", "0", ",", "num", ")", "\n", "table_data", ".", "append", "(", "row", ")", "\n", "", "table", "=", "AsciiTable", "(", "table_data", ")", "\n", "print_log", "(", "'\\n'", "+", "table", ".", "table", ",", "logger", "=", "logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.plot_num_recall": [[142, 165], ["isinstance", "isinstance", "plt.figure", "plt.plot", "plt.xlabel", "plt.ylabel", "plt.axis", "plt.figure.show", "proposal_nums.tolist", "recalls.tolist", "proposal_nums.max"], "function", ["None"], ["", "def", "plot_num_recall", "(", "recalls", ",", "proposal_nums", ")", ":", "\n", "    ", "\"\"\"Plot Proposal_num-Recalls curve.\n\n    Args:\n        recalls(ndarray or list): shape (k,)\n        proposal_nums(ndarray or list): same shape as `recalls`\n    \"\"\"", "\n", "if", "isinstance", "(", "proposal_nums", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "_proposal_nums", "=", "proposal_nums", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "        ", "_proposal_nums", "=", "proposal_nums", "\n", "", "if", "isinstance", "(", "recalls", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "_recalls", "=", "recalls", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "        ", "_recalls", "=", "recalls", "\n", "\n", "", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "f", "=", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "[", "0", "]", "+", "_proposal_nums", ",", "[", "0", "]", "+", "_recalls", ")", "\n", "plt", ".", "xlabel", "(", "'Proposal num'", ")", "\n", "plt", ".", "ylabel", "(", "'Recall'", ")", "\n", "plt", ".", "axis", "(", "[", "0", ",", "proposal_nums", ".", "max", "(", ")", ",", "0", ",", "1", "]", ")", "\n", "f", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.recall.plot_iou_recall": [[167, 190], ["isinstance", "isinstance", "plt.figure", "plt.plot", "plt.xlabel", "plt.ylabel", "plt.axis", "plt.figure.show", "iou_thrs.tolist", "recalls.tolist", "iou_thrs.min"], "function", ["None"], ["", "def", "plot_iou_recall", "(", "recalls", ",", "iou_thrs", ")", ":", "\n", "    ", "\"\"\"Plot IoU-Recalls curve.\n\n    Args:\n        recalls(ndarray or list): shape (k,)\n        iou_thrs(ndarray or list): same shape as `recalls`\n    \"\"\"", "\n", "if", "isinstance", "(", "iou_thrs", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "_iou_thrs", "=", "iou_thrs", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "        ", "_iou_thrs", "=", "iou_thrs", "\n", "", "if", "isinstance", "(", "recalls", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "_recalls", "=", "recalls", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "        ", "_recalls", "=", "recalls", "\n", "\n", "", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "f", "=", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "_iou_thrs", "+", "[", "1.0", "]", ",", "_recalls", "+", "[", "0.", "]", ")", "\n", "plt", ".", "xlabel", "(", "'IoU'", ")", "\n", "plt", ".", "ylabel", "(", "'Recall'", ")", "\n", "plt", ".", "axis", "(", "[", "iou_thrs", ".", "min", "(", ")", ",", "1", ",", "0", ",", "1", "]", ")", "\n", "f", ".", "show", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStatCat.__init__": [[22, 27], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "iou", "=", "0.0", "\n", "self", ".", "tp", "=", "0", "\n", "self", ".", "fp", "=", "0", "\n", "self", ".", "fn", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStatCat.__iadd__": [[28, 34], ["None"], "methods", ["None"], ["", "def", "__iadd__", "(", "self", ",", "pq_stat_cat", ")", ":", "\n", "        ", "self", ".", "iou", "+=", "pq_stat_cat", ".", "iou", "\n", "self", ".", "tp", "+=", "pq_stat_cat", ".", "tp", "\n", "self", ".", "fp", "+=", "pq_stat_cat", ".", "fp", "\n", "self", ".", "fn", "+=", "pq_stat_cat", ".", "fn", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStat.__init__": [[37, 39], ["collections.defaultdict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pq_per_cat", "=", "defaultdict", "(", "PQStatCat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStat.__getitem__": [[40, 42], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "pq_per_cat", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStat.__iadd__": [[43, 47], ["pq_stat.pq_per_cat.items"], "methods", ["None"], ["", "def", "__iadd__", "(", "self", ",", "pq_stat", ")", ":", "\n", "        ", "for", "label", ",", "pq_stat_cat", "in", "pq_stat", ".", "pq_per_cat", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "pq_per_cat", "[", "label", "]", "+=", "pq_stat_cat", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStat.pq_average": [[48, 76], ["categories.items"], "methods", ["None"], ["", "def", "pq_average", "(", "self", ",", "categories", ",", "isthing", ")", ":", "\n", "        ", "pq", ",", "sq", ",", "rq", ",", "n", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "per_class_results", "=", "{", "}", "\n", "for", "label", ",", "label_info", "in", "categories", ".", "items", "(", ")", ":", "\n", "            ", "if", "isthing", "is", "not", "None", ":", "\n", "                ", "cat_isthing", "=", "label_info", "[", "'isthing'", "]", "==", "1", "\n", "if", "isthing", "!=", "cat_isthing", ":", "\n", "                    ", "continue", "\n", "", "", "iou", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "iou", "\n", "tp", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "tp", "\n", "fp", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "fp", "\n", "fn", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "fn", "\n", "if", "tp", "+", "fp", "+", "fn", "==", "0", ":", "\n", "                ", "per_class_results", "[", "label", "]", "=", "{", "'pq'", ":", "0.0", ",", "'sq'", ":", "0.0", ",", "'rq'", ":", "0.0", "}", "\n", "continue", "\n", "", "n", "+=", "1", "\n", "pq_class", "=", "iou", "/", "(", "tp", "+", "0.5", "*", "fp", "+", "0.5", "*", "fn", ")", "\n", "sq_class", "=", "iou", "/", "tp", "if", "tp", "!=", "0", "else", "0", "\n", "rq_class", "=", "tp", "/", "(", "tp", "+", "0.5", "*", "fp", "+", "0.5", "*", "fn", ")", "\n", "per_class_results", "[", "label", "]", "=", "{", "\n", "'pq'", ":", "pq_class", ",", "'sq'", ":", "sq_class", ",", "'rq'", ":", "rq_class", "\n", "}", "\n", "pq", "+=", "pq_class", "\n", "sq", "+=", "sq_class", "\n", "rq", "+=", "rq_class", "\n", "\n", "", "return", "{", "'pq'", ":", "pq", "/", "n", ",", "'sq'", ":", "sq", "/", "n", ",", "'rq'", ":", "rq", "/", "n", ",", "'n'", ":", "n", "}", ",", "per_class_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.pq_compute_single_core": [[78, 190], ["panoptic_eval.PQStat", "print", "numpy.array", "utils.rgb2id", "numpy.array", "utils.rgb2id", "set", "numpy.unique", "zip", "numpy.unique", "zip", "set", "set", "gt_pred_map.items", "gt_segms.items", "pred_segms.items", "print", "PIL.open", "PIL.open", "set.remove", "len", "KeyError", "utils.rgb2id.astype", "gt_pred_map.get", "len", "os.path.join", "os.path.join", "KeyError", "KeyError", "utils.rgb2id.astype", "gt_pred_map.get", "set.add", "set.add", "gt_pred_map.get", "len", "list"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id"], ["", "", "@", "get_traceback", "\n", "def", "pq_compute_single_core", "(", "proc_id", ",", "\n", "annotation_set", ",", "\n", "gt_folder", ",", "\n", "pred_folder", ",", "\n", "categories", ")", ":", "\n", "    ", "pq_stat", "=", "PQStat", "(", ")", "\n", "\n", "idx", "=", "0", "\n", "for", "gt_ann", ",", "pred_ann", "in", "annotation_set", ":", "\n", "        ", "if", "idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "'Core: {}, {} from {} images processed'", ".", "format", "(", "\n", "proc_id", ",", "idx", ",", "len", "(", "annotation_set", ")", ")", ")", "\n", "", "idx", "+=", "1", "\n", "\n", "pan_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "\n", "os", ".", "path", ".", "join", "(", "gt_folder", ",", "gt_ann", "[", "'file_name'", "]", ")", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "pan_gt", "=", "rgb2id", "(", "pan_gt", ")", "\n", "pan_pred", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "\n", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "pred_ann", "[", "'file_name'", "]", ")", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "pan_pred", "=", "rgb2id", "(", "pan_pred", ")", "\n", "\n", "gt_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "gt_ann", "[", "'segments_info'", "]", "}", "\n", "pred_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "pred_ann", "[", "'segments_info'", "]", "}", "\n", "\n", "# predicted segments area calculation + prediction sanity checks", "\n", "pred_labels_set", "=", "set", "(", "el", "[", "'id'", "]", "for", "el", "in", "pred_ann", "[", "'segments_info'", "]", ")", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "label_cnt", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "            ", "if", "label", "not", "in", "pred_segms", ":", "\n", "                ", "if", "label", "==", "VOID", ":", "\n", "                    ", "continue", "\n", "", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} is '", "\n", "'presented in PNG and not presented in JSON.'", "\n", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "label", ")", ")", "\n", "", "pred_segms", "[", "label", "]", "[", "'area'", "]", "=", "label_cnt", "\n", "pred_labels_set", ".", "remove", "(", "label", ")", "\n", "if", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", "not", "in", "categories", ":", "\n", "                ", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} '", "\n", "'has unknown category_id {}.'", "\n", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "label", ",", "\n", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", ")", ")", "\n", "", "", "if", "len", "(", "pred_labels_set", ")", "!=", "0", ":", "\n", "            ", "raise", "KeyError", "(", "'In the image with ID {} the following segment IDs '", "\n", "'{} are presented in JSON and not presented in PNG.'", "\n", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "list", "(", "pred_labels_set", ")", ")", ")", "\n", "\n", "# confusion matrix calculation", "\n", "", "pan_gt_pred", "=", "pan_gt", ".", "astype", "(", "np", ".", "uint64", ")", "*", "OFFSET", "+", "pan_pred", ".", "astype", "(", "np", ".", "uint64", ")", "\n", "gt_pred_map", "=", "{", "}", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_gt_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "intersection", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "            ", "gt_id", "=", "label", "//", "OFFSET", "\n", "pred_id", "=", "label", "%", "OFFSET", "\n", "gt_pred_map", "[", "(", "gt_id", ",", "pred_id", ")", "]", "=", "intersection", "\n", "\n", "# count all matched pairs", "\n", "", "gt_matched", "=", "set", "(", ")", "\n", "pred_matched", "=", "set", "(", ")", "\n", "for", "label_tuple", ",", "intersection", "in", "gt_pred_map", ".", "items", "(", ")", ":", "\n", "            ", "gt_label", ",", "pred_label", "=", "label_tuple", "\n", "if", "gt_label", "not", "in", "gt_segms", ":", "\n", "                ", "continue", "\n", "", "if", "pred_label", "not", "in", "pred_segms", ":", "\n", "                ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "!=", "pred_segms", "[", "pred_label", "]", "[", "'category_id'", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "union", "=", "pred_segms", "[", "pred_label", "]", "[", "'area'", "]", "+", "gt_segms", "[", "gt_label", "]", "[", "'area'", "]", "-", "intersection", "-", "gt_pred_map", ".", "get", "(", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "iou", "=", "intersection", "/", "union", "\n", "if", "iou", ">", "0.5", ":", "\n", "                ", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "tp", "+=", "1", "\n", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "iou", "+=", "iou", "\n", "gt_matched", ".", "add", "(", "gt_label", ")", "\n", "pred_matched", ".", "add", "(", "pred_label", ")", "\n", "\n", "# count false negatives", "\n", "", "", "crowd_labels_dict", "=", "{", "}", "\n", "for", "gt_label", ",", "gt_info", "in", "gt_segms", ".", "items", "(", ")", ":", "\n", "            ", "if", "gt_label", "in", "gt_matched", ":", "\n", "                ", "continue", "\n", "# crowd segments are ignored", "\n", "", "if", "gt_info", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                ", "crowd_labels_dict", "[", "gt_info", "[", "'category_id'", "]", "]", "=", "gt_label", "\n", "continue", "\n", "", "pq_stat", "[", "gt_info", "[", "'category_id'", "]", "]", ".", "fn", "+=", "1", "\n", "\n", "# count false positives", "\n", "", "for", "pred_label", ",", "pred_info", "in", "pred_segms", ".", "items", "(", ")", ":", "\n", "            ", "if", "pred_label", "in", "pred_matched", ":", "\n", "                ", "continue", "\n", "# intersection of the segment with VOID", "\n", "", "intersection", "=", "gt_pred_map", ".", "get", "(", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "# plus intersection with corresponding CROWD region if it exists", "\n", "if", "pred_info", "[", "'category_id'", "]", "in", "crowd_labels_dict", ":", "\n", "                ", "intersection", "+=", "gt_pred_map", ".", "get", "(", "\n", "(", "crowd_labels_dict", "[", "pred_info", "[", "'category_id'", "]", "]", ",", "pred_label", ")", ",", "\n", "0", ")", "\n", "# predicted segment is ignored if more than half of", "\n", "# the segment correspond to VOID and CROWD regions", "\n", "", "if", "intersection", "/", "pred_info", "[", "'area'", "]", ">", "0.5", ":", "\n", "                ", "continue", "\n", "", "pq_stat", "[", "pred_info", "[", "'category_id'", "]", "]", ".", "fp", "+=", "1", "\n", "", "", "print", "(", "'Core: {}, all {} images processed'", ".", "format", "(", "\n", "proc_id", ",", "len", "(", "annotation_set", ")", ")", ")", "\n", "return", "pq_stat", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.pq_compute": [[192, 267], ["time.time", "print", "print", "print", "print", "print", "print", "print", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "panoptic_eval.PQStat", "mmcv.utils.print_log", "mmcv.utils.print_log", "print", "open", "json.load", "open", "json.load", "gt_json_file.replace", "pred_json_file.replace", "os.path.isdir", "Exception", "os.path.isdir", "Exception", "matched_annotations_list.append", "multiprocessing.Pool.apply_async", "processes.append", "workers.apply_async.get", "panoptic_eval.PQStat.pq_average", "mmcv.utils.print_log", "time.time", "Exception", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.panoptic_eval.PQStat.pq_average"], ["", "def", "pq_compute", "(", "gt_json_file", ",", "\n", "pred_json_file", ",", "\n", "gt_folder", "=", "None", ",", "\n", "pred_folder", "=", "None", ",", "\n", "logger", "=", "None", ")", ":", "\n", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "with", "open", "(", "gt_json_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "gt_json", "=", "json", ".", "load", "(", "f", ")", "\n", "", "with", "open", "(", "pred_json_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "pred_json", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "if", "gt_folder", "is", "None", ":", "\n", "        ", "gt_folder", "=", "gt_json_file", ".", "replace", "(", "'.json'", ",", "''", ")", "\n", "", "if", "pred_folder", "is", "None", ":", "\n", "        ", "pred_folder", "=", "pred_json_file", ".", "replace", "(", "'.json'", ",", "''", ")", "\n", "", "categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "gt_json", "[", "'categories'", "]", "}", "\n", "\n", "print", "(", "\"Evaluation panoptic segmentation metrics:\"", ")", "\n", "print", "(", "\"Ground truth:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "gt_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "gt_json_file", ")", ")", "\n", "print", "(", "\"Prediction:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "pred_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "pred_json_file", ")", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "gt_folder", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Folder {} with ground truth segmentations \"", "\n", "\"doesn't exist\"", ".", "format", "(", "gt_folder", ")", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "pred_folder", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Folder {} with predicted segmentations \"", "\n", "\"doesn't exist\"", ".", "format", "(", "pred_folder", ")", ")", "\n", "\n", "", "pred_annotations", "=", "{", "el", "[", "'image_id'", "]", ":", "el", "for", "el", "in", "pred_json", "[", "'annotations'", "]", "}", "\n", "matched_annotations_list", "=", "[", "]", "\n", "for", "gt_ann", "in", "gt_json", "[", "'annotations'", "]", ":", "\n", "        ", "image_id", "=", "gt_ann", "[", "'image_id'", "]", "\n", "if", "image_id", "not", "in", "pred_annotations", ":", "\n", "            ", "raise", "Exception", "(", "'no prediction for the image '", "\n", "'with id: {}'", ".", "format", "(", "image_id", ")", ")", "\n", "", "matched_annotations_list", ".", "append", "(", "(", "gt_ann", ",", "pred_annotations", "[", "image_id", "]", ")", ")", "\n", "\n", "", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "annotations_split", "=", "np", ".", "array_split", "(", "matched_annotations_list", ",", "cpu_num", ")", "\n", "print", "(", "\"Number of cores: {}, images per core: {}\"", "\n", ".", "format", "(", "cpu_num", ",", "len", "(", "annotations_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "annotation_set", "in", "enumerate", "(", "annotations_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "pq_compute_single_core", ",", "\n", "(", "proc_id", ",", "annotation_set", ",", "\n", "gt_folder", ",", "pred_folder", ",", "categories", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "pq_stat", "=", "PQStat", "(", ")", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "pq_stat", "+=", "p", ".", "get", "(", ")", "\n", "\n", "", "metrics", "=", "[", "(", "\"All\"", ",", "None", ")", ",", "(", "\"Things\"", ",", "True", ")", ",", "(", "\"Stuff\"", ",", "False", ")", "]", "\n", "results", "=", "{", "}", "\n", "for", "name", ",", "isthing", "in", "metrics", ":", "\n", "        ", "results", "[", "name", "]", ",", "per_class_results", "=", "pq_stat", ".", "pq_average", "(", "\n", "categories", ",", "isthing", "=", "isthing", ")", "\n", "if", "name", "==", "'All'", ":", "\n", "            ", "results", "[", "'per_class'", "]", "=", "per_class_results", "\n", "", "", "print_log", "(", "\"{:10s}| {:>5s}  {:>5s}  {:>5s} {:>5s}\"", ".", "format", "(", "\n", "\"\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"N\"", ")", ",", "logger", "=", "logger", ")", "\n", "print_log", "(", "\"-\"", "*", "(", "10", "+", "7", "*", "4", ")", ",", "logger", "=", "logger", ")", "\n", "\n", "for", "name", ",", "_isthing", "in", "metrics", ":", "\n", "        ", "print_log", "(", "\"{:10s}| {:5.1f}  {:5.1f}  {:5.1f} {:5d}\"", ".", "format", "(", "\n", "name", ",", "100", "*", "results", "[", "name", "]", "[", "'pq'", "]", ",", "100", "*", "results", "[", "name", "]", "[", "'sq'", "]", ",", "\n", "100", "*", "results", "[", "name", "]", "[", "'rq'", "]", ",", "results", "[", "name", "]", "[", "'n'", "]", ")", ",", "logger", "=", "logger", ")", "\n", "\n", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.bbox_overlaps.bbox_overlaps": [[4, 49], ["bboxes1.astype.astype", "bboxes2.astype.astype", "numpy.zeros", "range", "numpy.zeros", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["def", "bbox_overlaps", "(", "bboxes1", ",", "bboxes2", ",", "mode", "=", "'iou'", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"Calculate the ious between each bbox of bboxes1 and bboxes2.\n\n    Args:\n        bboxes1(ndarray): shape (n, 4)\n        bboxes2(ndarray): shape (k, 4)\n        mode(str): iou (intersection over union) or iof (intersection\n            over foreground)\n\n    Returns:\n        ious(ndarray): shape (n, k)\n    \"\"\"", "\n", "\n", "assert", "mode", "in", "[", "'iou'", ",", "'iof'", "]", "\n", "\n", "bboxes1", "=", "bboxes1", ".", "astype", "(", "np", ".", "float32", ")", "\n", "bboxes2", "=", "bboxes2", ".", "astype", "(", "np", ".", "float32", ")", "\n", "rows", "=", "bboxes1", ".", "shape", "[", "0", "]", "\n", "cols", "=", "bboxes2", ".", "shape", "[", "0", "]", "\n", "ious", "=", "np", ".", "zeros", "(", "(", "rows", ",", "cols", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "rows", "*", "cols", "==", "0", ":", "\n", "        ", "return", "ious", "\n", "", "exchange", "=", "False", "\n", "if", "bboxes1", ".", "shape", "[", "0", "]", ">", "bboxes2", ".", "shape", "[", "0", "]", ":", "\n", "        ", "bboxes1", ",", "bboxes2", "=", "bboxes2", ",", "bboxes1", "\n", "ious", "=", "np", ".", "zeros", "(", "(", "cols", ",", "rows", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "exchange", "=", "True", "\n", "", "area1", "=", "(", "bboxes1", "[", ":", ",", "2", "]", "-", "bboxes1", "[", ":", ",", "0", "]", ")", "*", "(", "bboxes1", "[", ":", ",", "3", "]", "-", "bboxes1", "[", ":", ",", "1", "]", ")", "\n", "area2", "=", "(", "bboxes2", "[", ":", ",", "2", "]", "-", "bboxes2", "[", ":", ",", "0", "]", ")", "*", "(", "bboxes2", "[", ":", ",", "3", "]", "-", "bboxes2", "[", ":", ",", "1", "]", ")", "\n", "for", "i", "in", "range", "(", "bboxes1", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "x_start", "=", "np", ".", "maximum", "(", "bboxes1", "[", "i", ",", "0", "]", ",", "bboxes2", "[", ":", ",", "0", "]", ")", "\n", "y_start", "=", "np", ".", "maximum", "(", "bboxes1", "[", "i", ",", "1", "]", ",", "bboxes2", "[", ":", ",", "1", "]", ")", "\n", "x_end", "=", "np", ".", "minimum", "(", "bboxes1", "[", "i", ",", "2", "]", ",", "bboxes2", "[", ":", ",", "2", "]", ")", "\n", "y_end", "=", "np", ".", "minimum", "(", "bboxes1", "[", "i", ",", "3", "]", ",", "bboxes2", "[", ":", ",", "3", "]", ")", "\n", "overlap", "=", "np", ".", "maximum", "(", "x_end", "-", "x_start", ",", "0", ")", "*", "np", ".", "maximum", "(", "\n", "y_end", "-", "y_start", ",", "0", ")", "\n", "if", "mode", "==", "'iou'", ":", "\n", "            ", "union", "=", "area1", "[", "i", "]", "+", "area2", "-", "overlap", "\n", "", "else", ":", "\n", "            ", "union", "=", "area1", "[", "i", "]", "if", "not", "exchange", "else", "area2", "\n", "", "union", "=", "np", ".", "maximum", "(", "union", ",", "eps", ")", "\n", "ious", "[", "i", ",", ":", "]", "=", "overlap", "/", "union", "\n", "", "if", "exchange", ":", "\n", "        ", "ious", "=", "ious", ".", "T", "\n", "", "return", "ious", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.wider_face_classes": [[4, 6], ["None"], "function", ["None"], ["def", "wider_face_classes", "(", ")", ":", "\n", "    ", "return", "[", "'face'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.voc_classes": [[8, 13], ["None"], "function", ["None"], ["", "def", "voc_classes", "(", ")", ":", "\n", "    ", "return", "[", "\n", "'aeroplane'", ",", "'bicycle'", ",", "'bird'", ",", "'boat'", ",", "'bottle'", ",", "'bus'", ",", "'car'", ",", "'cat'", ",", "\n", "'chair'", ",", "'cow'", ",", "'diningtable'", ",", "'dog'", ",", "'horse'", ",", "'motorbike'", ",", "'person'", ",", "\n", "'pottedplant'", ",", "'sheep'", ",", "'sofa'", ",", "'train'", ",", "'tvmonitor'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.imagenet_det_classes": [[16, 54], ["None"], "function", ["None"], ["", "def", "imagenet_det_classes", "(", ")", ":", "\n", "    ", "return", "[", "\n", "'accordion'", ",", "'airplane'", ",", "'ant'", ",", "'antelope'", ",", "'apple'", ",", "'armadillo'", ",", "\n", "'artichoke'", ",", "'axe'", ",", "'baby_bed'", ",", "'backpack'", ",", "'bagel'", ",", "'balance_beam'", ",", "\n", "'banana'", ",", "'band_aid'", ",", "'banjo'", ",", "'baseball'", ",", "'basketball'", ",", "'bathing_cap'", ",", "\n", "'beaker'", ",", "'bear'", ",", "'bee'", ",", "'bell_pepper'", ",", "'bench'", ",", "'bicycle'", ",", "'binder'", ",", "\n", "'bird'", ",", "'bookshelf'", ",", "'bow_tie'", ",", "'bow'", ",", "'bowl'", ",", "'brassiere'", ",", "'burrito'", ",", "\n", "'bus'", ",", "'butterfly'", ",", "'camel'", ",", "'can_opener'", ",", "'car'", ",", "'cart'", ",", "'cattle'", ",", "\n", "'cello'", ",", "'centipede'", ",", "'chain_saw'", ",", "'chair'", ",", "'chime'", ",", "'cocktail_shaker'", ",", "\n", "'coffee_maker'", ",", "'computer_keyboard'", ",", "'computer_mouse'", ",", "'corkscrew'", ",", "\n", "'cream'", ",", "'croquet_ball'", ",", "'crutch'", ",", "'cucumber'", ",", "'cup_or_mug'", ",", "'diaper'", ",", "\n", "'digital_clock'", ",", "'dishwasher'", ",", "'dog'", ",", "'domestic_cat'", ",", "'dragonfly'", ",", "\n", "'drum'", ",", "'dumbbell'", ",", "'electric_fan'", ",", "'elephant'", ",", "'face_powder'", ",", "'fig'", ",", "\n", "'filing_cabinet'", ",", "'flower_pot'", ",", "'flute'", ",", "'fox'", ",", "'french_horn'", ",", "'frog'", ",", "\n", "'frying_pan'", ",", "'giant_panda'", ",", "'goldfish'", ",", "'golf_ball'", ",", "'golfcart'", ",", "\n", "'guacamole'", ",", "'guitar'", ",", "'hair_dryer'", ",", "'hair_spray'", ",", "'hamburger'", ",", "\n", "'hammer'", ",", "'hamster'", ",", "'harmonica'", ",", "'harp'", ",", "'hat_with_a_wide_brim'", ",", "\n", "'head_cabbage'", ",", "'helmet'", ",", "'hippopotamus'", ",", "'horizontal_bar'", ",", "'horse'", ",", "\n", "'hotdog'", ",", "'iPod'", ",", "'isopod'", ",", "'jellyfish'", ",", "'koala_bear'", ",", "'ladle'", ",", "\n", "'ladybug'", ",", "'lamp'", ",", "'laptop'", ",", "'lemon'", ",", "'lion'", ",", "'lipstick'", ",", "'lizard'", ",", "\n", "'lobster'", ",", "'maillot'", ",", "'maraca'", ",", "'microphone'", ",", "'microwave'", ",", "'milk_can'", ",", "\n", "'miniskirt'", ",", "'monkey'", ",", "'motorcycle'", ",", "'mushroom'", ",", "'nail'", ",", "'neck_brace'", ",", "\n", "'oboe'", ",", "'orange'", ",", "'otter'", ",", "'pencil_box'", ",", "'pencil_sharpener'", ",", "'perfume'", ",", "\n", "'person'", ",", "'piano'", ",", "'pineapple'", ",", "'ping-pong_ball'", ",", "'pitcher'", ",", "'pizza'", ",", "\n", "'plastic_bag'", ",", "'plate_rack'", ",", "'pomegranate'", ",", "'popsicle'", ",", "'porcupine'", ",", "\n", "'power_drill'", ",", "'pretzel'", ",", "'printer'", ",", "'puck'", ",", "'punching_bag'", ",", "'purse'", ",", "\n", "'rabbit'", ",", "'racket'", ",", "'ray'", ",", "'red_panda'", ",", "'refrigerator'", ",", "\n", "'remote_control'", ",", "'rubber_eraser'", ",", "'rugby_ball'", ",", "'ruler'", ",", "\n", "'salt_or_pepper_shaker'", ",", "'saxophone'", ",", "'scorpion'", ",", "'screwdriver'", ",", "\n", "'seal'", ",", "'sheep'", ",", "'ski'", ",", "'skunk'", ",", "'snail'", ",", "'snake'", ",", "'snowmobile'", ",", "\n", "'snowplow'", ",", "'soap_dispenser'", ",", "'soccer_ball'", ",", "'sofa'", ",", "'spatula'", ",", "\n", "'squirrel'", ",", "'starfish'", ",", "'stethoscope'", ",", "'stove'", ",", "'strainer'", ",", "\n", "'strawberry'", ",", "'stretcher'", ",", "'sunglasses'", ",", "'swimming_trunks'", ",", "'swine'", ",", "\n", "'syringe'", ",", "'table'", ",", "'tape_player'", ",", "'tennis_ball'", ",", "'tick'", ",", "'tie'", ",", "\n", "'tiger'", ",", "'toaster'", ",", "'traffic_light'", ",", "'train'", ",", "'trombone'", ",", "'trumpet'", ",", "\n", "'turtle'", ",", "'tv_or_monitor'", ",", "'unicycle'", ",", "'vacuum'", ",", "'violin'", ",", "\n", "'volleyball'", ",", "'waffle_iron'", ",", "'washer'", ",", "'water_bottle'", ",", "'watercraft'", ",", "\n", "'whale'", ",", "'wine_bottle'", ",", "'zebra'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.imagenet_vid_classes": [[57, 64], ["None"], "function", ["None"], ["", "def", "imagenet_vid_classes", "(", ")", ":", "\n", "    ", "return", "[", "\n", "'airplane'", ",", "'antelope'", ",", "'bear'", ",", "'bicycle'", ",", "'bird'", ",", "'bus'", ",", "'car'", ",", "\n", "'cattle'", ",", "'dog'", ",", "'domestic_cat'", ",", "'elephant'", ",", "'fox'", ",", "'giant_panda'", ",", "\n", "'hamster'", ",", "'horse'", ",", "'lion'", ",", "'lizard'", ",", "'monkey'", ",", "'motorcycle'", ",", "'rabbit'", ",", "\n", "'red_panda'", ",", "'sheep'", ",", "'snake'", ",", "'squirrel'", ",", "'tiger'", ",", "'train'", ",", "'turtle'", ",", "\n", "'watercraft'", ",", "'whale'", ",", "'zebra'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.coco_classes": [[67, 82], ["None"], "function", ["None"], ["", "def", "coco_classes", "(", ")", ":", "\n", "    ", "return", "[", "\n", "'person'", ",", "'bicycle'", ",", "'car'", ",", "'motorcycle'", ",", "'airplane'", ",", "'bus'", ",", "'train'", ",", "\n", "'truck'", ",", "'boat'", ",", "'traffic_light'", ",", "'fire_hydrant'", ",", "'stop_sign'", ",", "\n", "'parking_meter'", ",", "'bench'", ",", "'bird'", ",", "'cat'", ",", "'dog'", ",", "'horse'", ",", "'sheep'", ",", "\n", "'cow'", ",", "'elephant'", ",", "'bear'", ",", "'zebra'", ",", "'giraffe'", ",", "'backpack'", ",", "'umbrella'", ",", "\n", "'handbag'", ",", "'tie'", ",", "'suitcase'", ",", "'frisbee'", ",", "'skis'", ",", "'snowboard'", ",", "\n", "'sports_ball'", ",", "'kite'", ",", "'baseball_bat'", ",", "'baseball_glove'", ",", "'skateboard'", ",", "\n", "'surfboard'", ",", "'tennis_racket'", ",", "'bottle'", ",", "'wine_glass'", ",", "'cup'", ",", "'fork'", ",", "\n", "'knife'", ",", "'spoon'", ",", "'bowl'", ",", "'banana'", ",", "'apple'", ",", "'sandwich'", ",", "'orange'", ",", "\n", "'broccoli'", ",", "'carrot'", ",", "'hot_dog'", ",", "'pizza'", ",", "'donut'", ",", "'cake'", ",", "'chair'", ",", "\n", "'couch'", ",", "'potted_plant'", ",", "'bed'", ",", "'dining_table'", ",", "'toilet'", ",", "'tv'", ",", "\n", "'laptop'", ",", "'mouse'", ",", "'remote'", ",", "'keyboard'", ",", "'cell_phone'", ",", "'microwave'", ",", "\n", "'oven'", ",", "'toaster'", ",", "'sink'", ",", "'refrigerator'", ",", "'book'", ",", "'clock'", ",", "'vase'", ",", "\n", "'scissors'", ",", "'teddy_bear'", ",", "'hair_drier'", ",", "'toothbrush'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.cityscapes_classes": [[85, 89], ["None"], "function", ["None"], ["", "def", "cityscapes_classes", "(", ")", ":", "\n", "    ", "return", "[", "\n", "'person'", ",", "'rider'", ",", "'car'", ",", "'truck'", ",", "'bus'", ",", "'train'", ",", "'motorcycle'", ",", "\n", "'bicycle'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.class_names.get_classes": [[102, 117], ["dataset_aliases.items", "mmcv.is_str", "TypeError", "eval", "ValueError", "type"], "function", ["None"], ["def", "get_classes", "(", "dataset", ")", ":", "\n", "    ", "\"\"\"Get class names of a dataset.\"\"\"", "\n", "alias2name", "=", "{", "}", "\n", "for", "name", ",", "aliases", "in", "dataset_aliases", ".", "items", "(", ")", ":", "\n", "        ", "for", "alias", "in", "aliases", ":", "\n", "            ", "alias2name", "[", "alias", "]", "=", "name", "\n", "\n", "", "", "if", "mmcv", ".", "is_str", "(", "dataset", ")", ":", "\n", "        ", "if", "dataset", "in", "alias2name", ":", "\n", "            ", "labels", "=", "eval", "(", "alias2name", "[", "dataset", "]", "+", "'_classes()'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unrecognized dataset: {dataset}'", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'dataset must a str, but got {type(dataset)}'", ")", "\n", "", "return", "labels", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.__init__": [[19, 27], ["isinstance", "TypeError", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataloader", ",", "interval", "=", "1", ",", "cfg", "=", "None", ",", "**", "eval_kwargs", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "dataloader", ",", "DataLoader", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'dataloader must be a pytorch DataLoader, but got'", "\n", "f' {type(dataloader)}'", ")", "\n", "", "self", ".", "dataloader", "=", "dataloader", "\n", "self", ".", "interval", "=", "interval", "\n", "self", ".", "eval_kwargs", "=", "eval_kwargs", "\n", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.after_train_epoch": [[28, 34], ["single_gpu_test", "eval_hooks.EvalHook.evaluate", "eval_hooks.EvalHook.every_n_epochs"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.single_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "def", "after_train_epoch", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "not", "self", ".", "every_n_epochs", "(", "runner", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "", "from", "mmdet", ".", "apis", "import", "single_gpu_test", "\n", "results", "=", "single_gpu_test", "(", "runner", ".", "model", ",", "self", ".", "dataloader", ",", "show", "=", "False", ")", "\n", "self", ".", "evaluate", "(", "runner", ",", "results", ",", "cfg", "=", "self", ".", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate": [[35, 42], ["eval_hooks.EvalHook.dataloader.dataset.evaluate", "isinstance", "eval_hooks.EvalHook.items"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "def", "evaluate", "(", "self", ",", "runner", ",", "results", ",", "cfg", "=", "None", ")", ":", "\n", "        ", "eval_res", "=", "self", ".", "dataloader", ".", "dataset", ".", "evaluate", "(", "\n", "results", ",", "logger", "=", "runner", ".", "logger", ",", "**", "self", ".", "eval_kwargs", ",", "cfg", "=", "cfg", ")", "\n", "if", "isinstance", "(", "eval_res", ",", "dict", ")", ":", "\n", "            ", "for", "name", ",", "val", "in", "eval_res", ".", "items", "(", ")", ":", "\n", "                ", "runner", ".", "log_buffer", ".", "output", "[", "name", "]", "=", "val", "\n", "", "", "runner", ".", "log_buffer", ".", "ready", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.DistEvalHook.__init__": [[56, 70], ["isinstance", "TypeError", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "dataloader", ",", "\n", "interval", "=", "1", ",", "\n", "gpu_collect", "=", "False", ",", "\n", "cfg", "=", "None", ",", "\n", "**", "eval_kwargs", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "dataloader", ",", "DataLoader", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'dataloader must be a pytorch DataLoader, but got '", "\n", "f'{type(dataloader)}'", ")", "\n", "", "self", ".", "dataloader", "=", "dataloader", "\n", "self", ".", "interval", "=", "interval", "\n", "self", ".", "gpu_collect", "=", "gpu_collect", "\n", "self", ".", "eval_kwargs", "=", "eval_kwargs", "\n", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.DistEvalHook.after_train_epoch": [[71, 83], ["multi_gpu_test", "eval_hooks.DistEvalHook.every_n_epochs", "print", "eval_hooks.DistEvalHook.evaluate", "os.join"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.multi_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "def", "after_train_epoch", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "not", "self", ".", "every_n_epochs", "(", "runner", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "", "from", "mmdet", ".", "apis", "import", "multi_gpu_test", "\n", "results", "=", "multi_gpu_test", "(", "\n", "runner", ".", "model", ",", "\n", "self", ".", "dataloader", ",", "\n", "tmpdir", "=", "osp", ".", "join", "(", "runner", ".", "work_dir", ",", "'.eval_hook'", ")", ",", "\n", "gpu_collect", "=", "self", ".", "gpu_collect", ")", "\n", "if", "runner", ".", "rank", "==", "0", ":", "\n", "            ", "print", "(", "'\\n'", ")", "\n", "self", ".", "evaluate", "(", "runner", ",", "results", ",", "cfg", "=", "self", ".", "cfg", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_flip": [[5, 28], ["bboxes.clone"], "function", ["None"], ["from", "numpy", "import", "random", "\n", "\n", "from", "mmdet", ".", "core", "import", "PolygonMasks", "\n", "from", "mmdet", ".", "core", ".", "evaluation", ".", "bbox_overlaps", "import", "bbox_overlaps", "\n", "from", ".", ".", "builder", "import", "PIPELINES", "\n", "\n", "try", ":", "\n", "    ", "from", "imagecorruptions", "import", "corrupt", "\n", "", "except", "ImportError", ":", "\n", "    ", "corrupt", "=", "None", "\n", "\n", "", "try", ":", "\n", "    ", "import", "albumentations", "\n", "from", "albumentations", "import", "Compose", "\n", "", "except", "ImportError", ":", "\n", "    ", "albumentations", "=", "None", "\n", "Compose", "=", "None", "\n", "\n", "\n", "", "@", "PIPELINES", ".", "register_module", "(", ")", "\n", "class", "Resize", "(", "object", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping": [[30, 40], ["bboxes.new_tensor", "transforms.bbox_flip"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_flip"], []], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_mapping_back": [[42, 52], ["new_bboxes.view", "transforms.bbox_flip", "new_bboxes.view", "new_bboxes.new_tensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox_flip"], []], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi": [[54, 74], ["enumerate", "torch.cat", "rois_list.append", "bboxes.size", "bboxes.new_full", "torch.cat", "bboxes.new_zeros", "bboxes.size"], "function", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "\n", "img_scale", "=", "None", ",", "\n", "multiscale_mode", "=", "'range'", ",", "\n", "ratio_range", "=", "None", ",", "\n", "keep_ratio", "=", "True", ",", "\n", "backend", "=", "'cv2'", ")", ":", "\n", "        ", "if", "img_scale", "is", "None", ":", "\n", "            ", "self", ".", "img_scale", "=", "None", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "img_scale", ",", "list", ")", ":", "\n", "                ", "self", ".", "img_scale", "=", "img_scale", "\n", "", "else", ":", "\n", "                ", "self", ".", "img_scale", "=", "[", "img_scale", "]", "\n", "", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "img_scale", ",", "tuple", ")", "\n", "\n", "", "if", "ratio_range", "is", "not", "None", ":", "\n", "# mode 1: given a scale and a range of image ratio", "\n", "            ", "assert", "len", "(", "self", ".", "img_scale", ")", "==", "1", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.roi2bbox": [[76, 93], ["torch.unique", "rois[].cpu", "bbox_list.append", "img_id.item"], "function", ["None"], ["# mode 2: given multiple scales or a range of scales", "\n", "            ", "assert", "multiscale_mode", "in", "[", "'value'", ",", "'range'", "]", "\n", "\n", "", "self", ".", "backend", "=", "backend", "\n", "self", ".", "multiscale_mode", "=", "multiscale_mode", "\n", "self", ".", "ratio_range", "=", "ratio_range", "\n", "self", ".", "keep_ratio", "=", "keep_ratio", "\n", "\n", "", "@", "staticmethod", "\n", "def", "random_select", "(", "img_scales", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result": [[95, 113], ["isinstance", "numpy.zeros", "bboxes.cpu().numpy.cpu().numpy", "labels.cpu().numpy.cpu().numpy", "range", "range", "bboxes.cpu().numpy.cpu", "labels.cpu().numpy.cpu"], "function", ["None"], ["\n", "\n", "assert", "mmcv", ".", "is_list_of", "(", "img_scales", ",", "tuple", ")", "\n", "scale_idx", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "img_scales", ")", ")", "\n", "img_scale", "=", "img_scales", "[", "scale_idx", "]", "\n", "return", "img_scale", ",", "scale_idx", "\n", "\n", "", "@", "staticmethod", "\n", "def", "random_sample", "(", "img_scales", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.distance2bbox": [[115, 137], ["torch.stack", "x1.clamp.clamp", "y1.clamp.clamp", "x2.clamp.clamp", "y2.clamp.clamp"], "function", ["None"], ["\n", "\n", "assert", "mmcv", ".", "is_list_of", "(", "img_scales", ",", "tuple", ")", "and", "len", "(", "img_scales", ")", "==", "2", "\n", "img_scale_long", "=", "[", "max", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "img_scale_short", "=", "[", "min", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "long_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_long", ")", ",", "\n", "max", "(", "img_scale_long", ")", "+", "1", ")", "\n", "short_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_short", ")", ",", "\n", "max", "(", "img_scale_short", ")", "+", "1", ")", "\n", "img_scale", "=", "(", "long_edge", ",", "short_edge", ")", "\n", "return", "img_scale", ",", "None", "\n", "\n", "", "@", "staticmethod", "\n", "def", "random_sample_ratio", "(", "img_scale", ",", "ratio_range", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2distance": [[139, 161], ["torch.stack", "left.clamp.clamp", "top.clamp.clamp", "right.clamp.clamp", "bottom.clamp.clamp"], "function", ["None"], ["\n", "\n", "assert", "isinstance", "(", "img_scale", ",", "tuple", ")", "and", "len", "(", "img_scale", ")", "==", "2", "\n", "min_ratio", ",", "max_ratio", "=", "ratio_range", "\n", "assert", "min_ratio", "<=", "max_ratio", "\n", "ratio", "=", "np", ".", "random", ".", "random_sample", "(", ")", "*", "(", "max_ratio", "-", "min_ratio", ")", "+", "min_ratio", "\n", "scale", "=", "int", "(", "img_scale", "[", "0", "]", "*", "ratio", ")", ",", "int", "(", "img_scale", "[", "1", "]", "*", "ratio", ")", "\n", "return", "scale", ",", "None", "\n", "\n", "", "def", "_random_scale", "(", "self", ",", "results", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng": [[5, 27], ["isinstance", "numpy.random.RandomState", "numpy.np.float32"], "function", ["None"], ["def", "ensure_rng", "(", "rng", "=", "None", ")", ":", "\n", "    ", "\"\"\"Simple version of the ``kwarray.ensure_rng``\n\n    Args:\n        rng (int | numpy.random.RandomState | None):\n            if None, then defaults to the global rng. Otherwise this can be an\n            integer or a RandomState class\n    Returns:\n        (numpy.random.RandomState) : rng -\n            a numpy random number generator\n\n    References:\n        https://gitlab.kitware.com/computer-vision/kwarray/blob/master/kwarray/util_random.py#L270\n    \"\"\"", "\n", "\n", "if", "rng", "is", "None", ":", "\n", "        ", "rng", "=", "np", ".", "random", ".", "mtrand", ".", "_rand", "\n", "", "elif", "isinstance", "(", "rng", ",", "int", ")", ":", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "rng", ")", "\n", "", "else", ":", "\n", "        ", "rng", "=", "rng", "\n", "", "return", "rng", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.random_boxes": [[29, 64], ["demodata.ensure_rng", "ensure_rng.rand().astype", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "torch.from_numpy", "ensure_rng.rand"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng"], ["", "def", "random_boxes", "(", "num", "=", "1", ",", "scale", "=", "1", ",", "rng", "=", "None", ")", ":", "\n", "    ", "\"\"\"Simple version of ``kwimage.Boxes.random``\n\n    Returns:\n        Tensor: shape (n, 4) in x1, y1, x2, y2 format.\n\n    References:\n        https://gitlab.kitware.com/computer-vision/kwimage/blob/master/kwimage/structs/boxes.py#L1390\n\n    Example:\n        >>> num = 3\n        >>> scale = 512\n        >>> rng = 0\n        >>> boxes = random_boxes(num, scale, rng)\n        >>> print(boxes)\n        tensor([[280.9925, 278.9802, 308.6148, 366.1769],\n                [216.9113, 330.6978, 224.0446, 456.5878],\n                [405.3632, 196.3221, 493.3953, 270.7942]])\n    \"\"\"", "\n", "rng", "=", "ensure_rng", "(", "rng", ")", "\n", "\n", "tlbr", "=", "rng", ".", "rand", "(", "num", ",", "4", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "tl_x", "=", "np", ".", "minimum", "(", "tlbr", "[", ":", ",", "0", "]", ",", "tlbr", "[", ":", ",", "2", "]", ")", "\n", "tl_y", "=", "np", ".", "minimum", "(", "tlbr", "[", ":", ",", "1", "]", ",", "tlbr", "[", ":", ",", "3", "]", ")", "\n", "br_x", "=", "np", ".", "maximum", "(", "tlbr", "[", ":", ",", "0", "]", ",", "tlbr", "[", ":", ",", "2", "]", ")", "\n", "br_y", "=", "np", ".", "maximum", "(", "tlbr", "[", ":", ",", "1", "]", ",", "tlbr", "[", ":", ",", "3", "]", ")", "\n", "\n", "tlbr", "[", ":", ",", "0", "]", "=", "tl_x", "*", "scale", "\n", "tlbr", "[", ":", ",", "1", "]", "=", "tl_y", "*", "scale", "\n", "tlbr", "[", ":", ",", "2", "]", "=", "br_x", "*", "scale", "\n", "tlbr", "[", ":", ",", "3", "]", "=", "br_y", "*", "scale", "\n", "\n", "boxes", "=", "torch", ".", "from_numpy", "(", "tlbr", ")", "\n", "return", "boxes", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner": [[8, 11], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["from", "mmcv", ".", "runner", "import", "get_dist_info", "\n", "from", "mmcv", ".", "utils", "import", "Registry", ",", "build_from_cfg", "\n", "from", "torch", ".", "utils", ".", "data", "import", "DataLoader", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler": [[13, 16], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["\n", "if", "platform", ".", "system", "(", ")", "!=", "'Windows'", ":", "\n", "# https://github.com/pytorch/pytorch/issues/973", "\n", "    ", "import", "resource", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_bbox_coder": [[18, 21], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["hard_limit", "=", "rlimit", "[", "1", "]", "\n", "soft_limit", "=", "min", "(", "4096", ",", "hard_limit", ")", "\n", "resource", ".", "setrlimit", "(", "resource", ".", "RLIMIT_NOFILE", ",", "(", "soft_limit", ",", "hard_limit", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.__init__": [[93, 106], ["dict", "iou_calculators.build_iou_calculator"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.builder.build_iou_calculator"], ["def", "__init__", "(", "self", ",", "\n", "pos_scale", ",", "\n", "neg_scale", ",", "\n", "min_pos_iof", "=", "1e-2", ",", "\n", "ignore_gt_scale", "=", "0.5", ",", "\n", "foreground_dominate", "=", "False", ",", "\n", "iou_calculator", "=", "dict", "(", "type", "=", "'BboxOverlaps2D'", ")", ")", ":", "\n", "        ", "self", ".", "pos_scale", "=", "pos_scale", "\n", "self", ".", "neg_scale", "=", "neg_scale", "\n", "self", ".", "min_pos_iof", "=", "min_pos_iof", "\n", "self", ".", "ignore_gt_scale", "=", "ignore_gt_scale", "\n", "self", ".", "foreground_dominate", "=", "foreground_dominate", "\n", "self", ".", "iou_calculator", "=", "build_iou_calculator", "(", "iou_calculator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.get_gt_priorities": [[107, 124], ["center_region_assigner.bboxes_area", "bboxes_area.sort", "sort_idx.argsort.argsort.argsort"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.bboxes_area"], ["", "def", "get_gt_priorities", "(", "self", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"Get gt priorities according to their areas.\n\n        Smaller gt has higher priority.\n\n        Args:\n            gt_bboxes (Tensor): Ground truth boxes, shape (k, 4).\n\n        Returns:\n            Tensor: The priority of gts so that gts with larger priority is \\\n              more likely to be assigned. Shape (k, )\n        \"\"\"", "\n", "gt_areas", "=", "bboxes_area", "(", "gt_bboxes", ")", "\n", "# Rank all gt bbox areas. Smaller objects has larger priority", "\n", "_", ",", "sort_idx", "=", "gt_areas", ".", "sort", "(", "descending", "=", "True", ")", "\n", "sort_idx", "=", "sort_idx", ".", "argsort", "(", ")", "\n", "return", "sort_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.assign": [[125, 255], ["center_region_assigner.scale_boxes", "center_region_assigner.scale_boxes", "center_region_assigner.is_located_in", "center_region_assigner.CenterRegionAssigner.iou_calculator", "assign_result.AssignResult.AssignResult", "assign_result.AssignResult.AssignResult.set_extra_property", "bboxes.size", "center_region_assigner.CenterRegionAssigner.iou_calculator", "gt_bboxes.size", "bboxes.size", "is_bbox_in_gt_core.new_zeros", "is_bbox_in_gt_core.new_zeros.new_empty", "center_region_assigner.CenterRegionAssigner.get_gt_priorities", "center_region_assigner.CenterRegionAssigner.assign_one_hot_gt_indices", "center_region_assigner.scale_boxes", "center_region_assigner.is_located_in", "is_bbox_in_ignored_gts.any.any.any", "is_bbox_in_gt_core.new_zeros.new_full", "torch.nonzero().squeeze", "is_bbox_in_gt_core.new_zeros.new_empty.clone", "scale_boxes.numel", "torch.nonzero().squeeze.numel", "is_bbox_in_gt_core.new_zeros.new_empty.numel", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.scale_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.scale_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.is_located_in", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.set_extra_property", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.get_gt_priorities", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.assign_one_hot_gt_indices", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.scale_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.is_located_in"], ["", "def", "assign", "(", "self", ",", "bboxes", ",", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "None", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to bboxes.\n\n        This method assigns gts to every bbox (proposal/anchor), each bbox \\\n        will be assigned with -1, or a semi-positive number. -1 means \\\n        negative sample, semi-positive number is the index (0-based) of \\\n        assigned gt.\n\n        Args:\n            bboxes (Tensor): Bounding boxes to be assigned, shape(n, 4).\n            gt_bboxes (Tensor): Groundtruth boxes, shape (k, 4).\n            gt_bboxes_ignore (tensor, optional): Ground truth bboxes that are\n              labelled as `ignored`, e.g., crowd boxes in COCO.\n            gt_labels (tensor, optional): Label of gt_bboxes, shape (num_gts,).\n\n        Returns:\n            :obj:`AssignResult`: The assigned result. Note that \\\n              shadowed_labels of shape (N, 2) is also added as an \\\n              `assign_result` attribute. `shadowed_labels` is a tensor \\\n              composed of N pairs of anchor_ind, class_label], where N \\\n              is the number of anchors that lie in the outer region of a \\\n              gt, anchor_ind is the shadowed anchor index and class_label \\\n              is the shadowed class label.\n\n        Example:\n            >>> self = CenterRegionAssigner(0.2, 0.2)\n            >>> bboxes = torch.Tensor([[0, 0, 10, 10], [10, 10, 20, 20]])\n            >>> gt_bboxes = torch.Tensor([[0, 0, 10, 10]])\n            >>> assign_result = self.assign(bboxes, gt_bboxes)\n            >>> expected_gt_inds = torch.LongTensor([1, 0])\n            >>> assert torch.all(assign_result.gt_inds == expected_gt_inds)\n        \"\"\"", "\n", "# There are in total 5 steps in the pixel assignment", "\n", "# 1. Find core (the center region, say inner 0.2)", "\n", "#     and shadow (the relatively ourter part, say inner 0.2-0.5)", "\n", "#     regions of every gt.", "\n", "# 2. Find all prior bboxes that lie in gt_core and gt_shadow regions", "\n", "# 3. Assign prior bboxes in gt_core with a one-hot id of the gt in", "\n", "#      the image.", "\n", "#    3.1. For overlapping objects, the prior bboxes in gt_core is", "\n", "#           assigned with the object with smallest area", "\n", "# 4. Assign prior bboxes with class label according to its gt id.", "\n", "#    4.1. Assign -1 to prior bboxes lying in shadowed gts", "\n", "#    4.2. Assign positive prior boxes with the corresponding label", "\n", "# 5. Find pixels lying in the shadow of an object and assign them with", "\n", "#      background label, but set the loss weight of its corresponding", "\n", "#      gt to zero.", "\n", "assert", "bboxes", ".", "size", "(", "1", ")", "==", "4", ",", "'bboxes must have size of 4'", "\n", "# 1. Find core positive and shadow region of every gt", "\n", "gt_core", "=", "scale_boxes", "(", "gt_bboxes", ",", "self", ".", "pos_scale", ")", "\n", "gt_shadow", "=", "scale_boxes", "(", "gt_bboxes", ",", "self", ".", "neg_scale", ")", "\n", "\n", "# 2. Find prior bboxes that lie in gt_core and gt_shadow regions", "\n", "bbox_centers", "=", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", "0", ":", "2", "]", ")", "/", "2", "\n", "# The center points lie within the gt boxes", "\n", "is_bbox_in_gt", "=", "is_located_in", "(", "bbox_centers", ",", "gt_bboxes", ")", "\n", "# Only calculate bbox and gt_core IoF. This enables small prior bboxes", "\n", "#   to match large gts", "\n", "bbox_and_gt_core_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "bboxes", ",", "gt_core", ",", "mode", "=", "'iof'", ")", "\n", "# The center point of effective priors should be within the gt box", "\n", "is_bbox_in_gt_core", "=", "is_bbox_in_gt", "&", "(", "\n", "bbox_and_gt_core_overlaps", ">", "self", ".", "min_pos_iof", ")", "# shape (n, k)", "\n", "\n", "is_bbox_in_gt_shadow", "=", "(", "\n", "self", ".", "iou_calculator", "(", "bboxes", ",", "gt_shadow", ",", "mode", "=", "'iof'", ")", ">", "\n", "self", ".", "min_pos_iof", ")", "\n", "# Rule out center effective positive pixels", "\n", "is_bbox_in_gt_shadow", "&=", "(", "~", "is_bbox_in_gt_core", ")", "\n", "\n", "num_gts", ",", "num_bboxes", "=", "gt_bboxes", ".", "size", "(", "0", ")", ",", "bboxes", ".", "size", "(", "0", ")", "\n", "if", "num_gts", "==", "0", "or", "num_bboxes", "==", "0", ":", "\n", "# If no gts exist, assign all pixels to negative", "\n", "            ", "assigned_gt_ids", "=", "is_bbox_in_gt_core", ".", "new_zeros", "(", "(", "num_bboxes", ",", ")", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "pixels_in_gt_shadow", "=", "assigned_gt_ids", ".", "new_empty", "(", "(", "0", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "# Step 3: assign a one-hot gt id to each pixel, and smaller objects", "\n", "#    have high priority to assign the pixel.", "\n", "            ", "sort_idx", "=", "self", ".", "get_gt_priorities", "(", "gt_bboxes", ")", "\n", "assigned_gt_ids", ",", "pixels_in_gt_shadow", "=", "self", ".", "assign_one_hot_gt_indices", "(", "is_bbox_in_gt_core", ",", "\n", "is_bbox_in_gt_shadow", ",", "\n", "gt_priority", "=", "sort_idx", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", "is", "not", "None", "and", "gt_bboxes_ignore", ".", "numel", "(", ")", ">", "0", ":", "\n", "# No ground truth or boxes, return empty assignment", "\n", "            ", "gt_bboxes_ignore", "=", "scale_boxes", "(", "\n", "gt_bboxes_ignore", ",", "scale", "=", "self", ".", "ignore_gt_scale", ")", "\n", "is_bbox_in_ignored_gts", "=", "is_located_in", "(", "bbox_centers", ",", "\n", "gt_bboxes_ignore", ")", "\n", "is_bbox_in_ignored_gts", "=", "is_bbox_in_ignored_gts", ".", "any", "(", "dim", "=", "1", ")", "\n", "assigned_gt_ids", "[", "is_bbox_in_ignored_gts", "]", "=", "-", "1", "\n", "\n", "# 4. Assign prior bboxes with class label according to its gt id.", "\n", "", "assigned_labels", "=", "None", "\n", "shadowed_pixel_labels", "=", "None", "\n", "if", "gt_labels", "is", "not", "None", ":", "\n", "# Default assigned label is the background (-1)", "\n", "            ", "assigned_labels", "=", "assigned_gt_ids", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "-", "1", ")", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assigned_gt_ids", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "assigned_labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "assigned_gt_ids", "[", "pos_inds", "]", "\n", "-", "1", "]", "\n", "# 5. Find pixels lying in the shadow of an object", "\n", "", "shadowed_pixel_labels", "=", "pixels_in_gt_shadow", ".", "clone", "(", ")", "\n", "if", "pixels_in_gt_shadow", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "pixel_idx", ",", "gt_idx", "=", "pixels_in_gt_shadow", "[", ":", ",", "0", "]", ",", "pixels_in_gt_shadow", "[", ":", ",", "1", "]", "\n", "assert", "(", "assigned_gt_ids", "[", "pixel_idx", "]", "!=", "gt_idx", ")", ".", "all", "(", ")", ",", "'Some pixels are dually assigned to ignore and gt!'", "\n", "shadowed_pixel_labels", "[", ":", ",", "1", "]", "=", "gt_labels", "[", "gt_idx", "-", "1", "]", "\n", "override", "=", "(", "\n", "assigned_labels", "[", "pixel_idx", "]", "==", "shadowed_pixel_labels", "[", ":", ",", "1", "]", ")", "\n", "if", "self", ".", "foreground_dominate", ":", "\n", "# When a pixel is both positive and shadowed, set it as pos", "\n", "                    ", "shadowed_pixel_labels", "=", "shadowed_pixel_labels", "[", "~", "override", "]", "\n", "", "else", ":", "\n", "# When a pixel is both pos and shadowed, set it as shadowed", "\n", "                    ", "assigned_labels", "[", "pixel_idx", "[", "override", "]", "]", "=", "-", "1", "\n", "assigned_gt_ids", "[", "pixel_idx", "[", "override", "]", "]", "=", "0", "\n", "\n", "", "", "", "assign_result", "=", "AssignResult", "(", "\n", "num_gts", ",", "assigned_gt_ids", ",", "None", ",", "labels", "=", "assigned_labels", ")", "\n", "# Add shadowed_labels as assign_result property. Shape: (num_shadow, 2)", "\n", "assign_result", ".", "set_extra_property", "(", "'shadowed_labels'", ",", "\n", "shadowed_pixel_labels", ")", "\n", "return", "assign_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.CenterRegionAssigner.assign_one_hot_gt_indices": [[256, 336], ["is_bbox_in_gt_core.new_zeros", "torch.nonzero", "is_bbox_in_gt_core.new_full", "torch.any", "pair_priority[].max", "torch.cat", "torch.arange", "torch.arange.size", "is_bbox_in_gt_core.sum", "torch.nonzero", "torch.cat.numel", "torch.nonzero"], "methods", ["None"], ["", "def", "assign_one_hot_gt_indices", "(", "self", ",", "\n", "is_bbox_in_gt_core", ",", "\n", "is_bbox_in_gt_shadow", ",", "\n", "gt_priority", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign only one gt index to each prior box.\n\n        Gts with large gt_priority are more likely to be assigned.\n\n        Args:\n            is_bbox_in_gt_core (Tensor): Bool tensor indicating the bbox center\n              is in the core area of a gt (e.g. 0-0.2).\n              Shape: (num_prior, num_gt).\n            is_bbox_in_gt_shadow (Tensor): Bool tensor indicating the bbox\n              center is in the shadowed area of a gt (e.g. 0.2-0.5).\n              Shape: (num_prior, num_gt).\n            gt_priority (Tensor): Priorities of gts. The gt with a higher\n              priority is more likely to be assigned to the bbox when the bbox\n              match with multiple gts. Shape: (num_gt, ).\n\n        Returns:\n            tuple: Returns (assigned_gt_inds, shadowed_gt_inds).\n\n                - assigned_gt_inds: The assigned gt index of each prior bbox \\\n                    (i.e. index from 1 to num_gts). Shape: (num_prior, ).\n                - shadowed_gt_inds: shadowed gt indices. It is a tensor of \\\n                    shape (num_ignore, 2) with first column being the \\\n                    shadowed prior bbox indices and the second column the \\\n                    shadowed gt indices (1-based).\n        \"\"\"", "\n", "num_bboxes", ",", "num_gts", "=", "is_bbox_in_gt_core", ".", "shape", "\n", "\n", "if", "gt_priority", "is", "None", ":", "\n", "            ", "gt_priority", "=", "torch", ".", "arange", "(", "\n", "num_gts", ",", "device", "=", "is_bbox_in_gt_core", ".", "device", ")", "\n", "", "assert", "gt_priority", ".", "size", "(", "0", ")", "==", "num_gts", "\n", "# The bigger gt_priority, the more preferable to be assigned", "\n", "# The assigned inds are by default 0 (background)", "\n", "assigned_gt_inds", "=", "is_bbox_in_gt_core", ".", "new_zeros", "(", "(", "num_bboxes", ",", ")", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "# Shadowed bboxes are assigned to be background. But the corresponding", "\n", "#   label is ignored during loss calculation, which is done through", "\n", "#   shadowed_gt_inds", "\n", "shadowed_gt_inds", "=", "torch", ".", "nonzero", "(", "is_bbox_in_gt_shadow", ",", "as_tuple", "=", "False", ")", "\n", "if", "is_bbox_in_gt_core", ".", "sum", "(", ")", "==", "0", ":", "# No gt match", "\n", "            ", "shadowed_gt_inds", "[", ":", ",", "1", "]", "+=", "1", "# 1-based. For consistency issue", "\n", "return", "assigned_gt_inds", ",", "shadowed_gt_inds", "\n", "\n", "# The priority of each prior box and gt pair. If one prior box is", "\n", "#  matched bo multiple gts. Only the pair with the highest priority", "\n", "#  is saved", "\n", "", "pair_priority", "=", "is_bbox_in_gt_core", ".", "new_full", "(", "(", "num_bboxes", ",", "num_gts", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "# Each bbox could match with multiple gts.", "\n", "# The following codes deal with this situation", "\n", "# Matched  bboxes (to any gt). Shape: (num_pos_anchor, )", "\n", "inds_of_match", "=", "torch", ".", "any", "(", "is_bbox_in_gt_core", ",", "dim", "=", "1", ")", "\n", "# The matched gt index of each positive bbox. Length >= num_pos_anchor", "\n", "#   , since one bbox could match multiple gts", "\n", "matched_bbox_gt_inds", "=", "torch", ".", "nonzero", "(", "\n", "is_bbox_in_gt_core", ",", "as_tuple", "=", "False", ")", "[", ":", ",", "1", "]", "\n", "# Assign priority to each bbox-gt pair.", "\n", "pair_priority", "[", "is_bbox_in_gt_core", "]", "=", "gt_priority", "[", "matched_bbox_gt_inds", "]", "\n", "_", ",", "argmax_priority", "=", "pair_priority", "[", "inds_of_match", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "assigned_gt_inds", "[", "inds_of_match", "]", "=", "argmax_priority", "+", "1", "# 1-based", "\n", "# Zero-out the assigned anchor box to filter the shadowed gt indices", "\n", "is_bbox_in_gt_core", "[", "inds_of_match", ",", "argmax_priority", "]", "=", "0", "\n", "# Concat the shadowed indices due to overlapping with that out side of", "\n", "#   effective scale. shape: (total_num_ignore, 2)", "\n", "shadowed_gt_inds", "=", "torch", ".", "cat", "(", "\n", "(", "shadowed_gt_inds", ",", "torch", ".", "nonzero", "(", "\n", "is_bbox_in_gt_core", ",", "as_tuple", "=", "False", ")", ")", ",", "\n", "dim", "=", "0", ")", "\n", "# `is_bbox_in_gt_core` should be changed back to keep arguments intact.", "\n", "is_bbox_in_gt_core", "[", "inds_of_match", ",", "argmax_priority", "]", "=", "1", "\n", "# 1-based shadowed gt indices, to be consistent with `assigned_gt_inds`", "\n", "if", "shadowed_gt_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "shadowed_gt_inds", "[", ":", ",", "1", "]", "+=", "1", "\n", "", "return", "assigned_gt_inds", ",", "shadowed_gt_inds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.scale_boxes": [[9, 34], ["torch.zeros_like", "bboxes.size"], "function", ["None"], ["def", "scale_boxes", "(", "bboxes", ",", "scale", ")", ":", "\n", "    ", "\"\"\"Expand an array of boxes by a given scale.\n\n    Args:\n        bboxes (Tensor): Shape (m, 4)\n        scale (float): The scale factor of bboxes\n\n    Returns:\n        (Tensor): Shape (m, 4). Scaled bboxes\n    \"\"\"", "\n", "assert", "bboxes", ".", "size", "(", "1", ")", "==", "4", "\n", "w_half", "=", "(", "bboxes", "[", ":", ",", "2", "]", "-", "bboxes", "[", ":", ",", "0", "]", ")", "*", ".5", "\n", "h_half", "=", "(", "bboxes", "[", ":", ",", "3", "]", "-", "bboxes", "[", ":", ",", "1", "]", ")", "*", ".5", "\n", "x_c", "=", "(", "bboxes", "[", ":", ",", "2", "]", "+", "bboxes", "[", ":", ",", "0", "]", ")", "*", ".5", "\n", "y_c", "=", "(", "bboxes", "[", ":", ",", "3", "]", "+", "bboxes", "[", ":", ",", "1", "]", ")", "*", ".5", "\n", "\n", "w_half", "*=", "scale", "\n", "h_half", "*=", "scale", "\n", "\n", "boxes_scaled", "=", "torch", ".", "zeros_like", "(", "bboxes", ")", "\n", "boxes_scaled", "[", ":", ",", "0", "]", "=", "x_c", "-", "w_half", "\n", "boxes_scaled", "[", ":", ",", "2", "]", "=", "x_c", "+", "w_half", "\n", "boxes_scaled", "[", ":", ",", "1", "]", "=", "y_c", "-", "h_half", "\n", "boxes_scaled", "[", ":", ",", "3", "]", "=", "y_c", "+", "h_half", "\n", "return", "boxes_scaled", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.is_located_in": [[36, 52], ["points.size", "bboxes.size", "points[].unsqueeze", "bboxes[].unsqueeze", "points[].unsqueeze", "bboxes[].unsqueeze", "points[].unsqueeze", "bboxes[].unsqueeze", "points[].unsqueeze", "bboxes[].unsqueeze"], "function", ["None"], ["", "def", "is_located_in", "(", "points", ",", "bboxes", ")", ":", "\n", "    ", "\"\"\"Are points located in bboxes.\n\n    Args:\n      points (Tensor): Points, shape: (m, 2).\n      bboxes (Tensor): Bounding boxes, shape: (n, 4).\n\n    Return:\n      Tensor: Flags indicating if points are located in bboxes, shape: (m, n).\n    \"\"\"", "\n", "assert", "points", ".", "size", "(", "1", ")", "==", "2", "\n", "assert", "bboxes", ".", "size", "(", "1", ")", "==", "4", "\n", "return", "(", "points", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", ">", "bboxes", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "0", ")", ")", "&", "(", "points", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "<", "bboxes", "[", ":", ",", "2", "]", ".", "unsqueeze", "(", "0", ")", ")", "&", "(", "points", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", ">", "bboxes", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "0", ")", ")", "&", "(", "points", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "<", "bboxes", "[", ":", ",", "3", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.center_region_assigner.bboxes_area": [[54, 68], ["bboxes.size"], "function", ["None"], ["", "def", "bboxes_area", "(", "bboxes", ")", ":", "\n", "    ", "\"\"\"Compute the area of an array of bboxes.\n\n    Args:\n        bboxes (Tensor): The coordinates ox bboxes. Shape: (m, 4)\n\n    Returns:\n        Tensor: Area of the bboxes. Shape: (m, )\n    \"\"\"", "\n", "assert", "bboxes", ".", "size", "(", "1", ")", "==", "4", "\n", "w", "=", "(", "bboxes", "[", ":", ",", "2", "]", "-", "bboxes", "[", ":", ",", "0", "]", ")", "\n", "h", "=", "(", "bboxes", "[", ":", ",", "3", "]", "-", "bboxes", "[", ":", ",", "1", "]", ")", "\n", "areas", "=", "w", "*", "h", "\n", "return", "areas", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.approx_max_iou_assigner.ApproxMaxIoUAssigner.__init__": [[39, 58], ["dict", "iou_calculators.build_iou_calculator"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.builder.build_iou_calculator"], ["def", "__init__", "(", "self", ",", "\n", "pos_iou_thr", ",", "\n", "neg_iou_thr", ",", "\n", "min_pos_iou", "=", ".0", ",", "\n", "gt_max_assign_all", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ",", "\n", "ignore_wrt_candidates", "=", "True", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "gpu_assign_thr", "=", "-", "1", ",", "\n", "iou_calculator", "=", "dict", "(", "type", "=", "'BboxOverlaps2D'", ")", ")", ":", "\n", "        ", "self", ".", "pos_iou_thr", "=", "pos_iou_thr", "\n", "self", ".", "neg_iou_thr", "=", "neg_iou_thr", "\n", "self", ".", "min_pos_iou", "=", "min_pos_iou", "\n", "self", ".", "gt_max_assign_all", "=", "gt_max_assign_all", "\n", "self", ".", "ignore_iof_thr", "=", "ignore_iof_thr", "\n", "self", ".", "ignore_wrt_candidates", "=", "ignore_wrt_candidates", "\n", "self", ".", "gpu_assign_thr", "=", "gpu_assign_thr", "\n", "self", ".", "match_low_quality", "=", "match_low_quality", "\n", "self", ".", "iou_calculator", "=", "build_iou_calculator", "(", "iou_calculator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.approx_max_iou_assigner.ApproxMaxIoUAssigner.assign": [[59, 146], ["squares.size", "gt_bboxes.cpu.cpu.size", "torch.transpose().contiguous().view", "approx_max_iou_assigner.ApproxMaxIoUAssigner.iou_calculator", "approx_max_iou_assigner.ApproxMaxIoUAssigner.view().max", "torch.transpose", "approx_max_iou_assigner.ApproxMaxIoUAssigner.assign_wrt_overlaps", "approxs.cpu.cpu.new", "approx_max_iou_assigner.ApproxMaxIoUAssigner.assign_wrt_overlaps", "approxs.cpu.cpu.cpu", "gt_bboxes.cpu.cpu.cpu", "approx_max_iou_assigner.ApproxMaxIoUAssigner.gt_inds.to", "approx_max_iou_assigner.ApproxMaxIoUAssigner.max_overlaps.to", "torch.transpose().contiguous", "gt_bboxes_ignore.cpu.cpu.cpu", "gt_labels.cpu.cpu.cpu", "approx_max_iou_assigner.ApproxMaxIoUAssigner.view", "gt_bboxes_ignore.cpu.cpu.numel", "squares.numel", "approx_max_iou_assigner.ApproxMaxIoUAssigner.iou_calculator", "approx_max_iou_assigner.ApproxMaxIoUAssigner.max", "approx_max_iou_assigner.ApproxMaxIoUAssigner.iou_calculator", "approx_max_iou_assigner.ApproxMaxIoUAssigner.max", "approx_max_iou_assigner.ApproxMaxIoUAssigner.labels.to", "torch.transpose", "approxs.cpu.cpu.view"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "def", "assign", "(", "self", ",", "\n", "approxs", ",", "\n", "squares", ",", "\n", "approxs_per_octave", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to approxs.\n\n        This method assign a gt bbox to each group of approxs (bboxes),\n        each group of approxs is represent by a base approx (bbox) and\n        will be assigned with -1, or a semi-positive number.\n        background_label (-1) means negative sample,\n        semi-positive number is the index (0-based) of assigned gt.\n        The assignment is done in following steps, the order matters.\n\n        1. assign every bbox to background_label (-1)\n        2. use the max IoU of each group of approxs to assign\n        2. assign proposals whose iou with all gts < neg_iou_thr to background\n        3. for each bbox, if the iou with its nearest gt >= pos_iou_thr,\n           assign it to that bbox\n        4. for each gt bbox, assign its nearest proposals (may be more than\n           one) to itself\n\n        Args:\n            approxs (Tensor): Bounding boxes to be assigned,\n                shape(approxs_per_octave*n, 4).\n            squares (Tensor): Base Bounding boxes to be assigned,\n                shape(n, 4).\n            approxs_per_octave (int): number of approxs per octave\n            gt_bboxes (Tensor): Groundtruth boxes, shape (k, 4).\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n            gt_labels (Tensor, optional): Label of gt_bboxes, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n        \"\"\"", "\n", "num_squares", "=", "squares", ".", "size", "(", "0", ")", "\n", "num_gts", "=", "gt_bboxes", ".", "size", "(", "0", ")", "\n", "\n", "if", "num_squares", "==", "0", "or", "num_gts", "==", "0", ":", "\n", "# No predictions and/or truth, return empty assignment", "\n", "            ", "overlaps", "=", "approxs", ".", "new", "(", "num_gts", ",", "num_squares", ")", "\n", "assign_result", "=", "self", ".", "assign_wrt_overlaps", "(", "overlaps", ",", "gt_labels", ")", "\n", "return", "assign_result", "\n", "\n", "# re-organize anchors by approxs_per_octave x num_squares", "\n", "", "approxs", "=", "torch", ".", "transpose", "(", "\n", "approxs", ".", "view", "(", "num_squares", ",", "approxs_per_octave", ",", "4", ")", ",", "0", ",", "\n", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "assign_on_cpu", "=", "True", "if", "(", "self", ".", "gpu_assign_thr", ">", "0", ")", "and", "(", "\n", "num_gts", ">", "self", ".", "gpu_assign_thr", ")", "else", "False", "\n", "# compute overlap and assign gt on CPU when number of GT is large", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "device", "=", "approxs", ".", "device", "\n", "approxs", "=", "approxs", ".", "cpu", "(", ")", "\n", "gt_bboxes", "=", "gt_bboxes", ".", "cpu", "(", ")", "\n", "if", "gt_bboxes_ignore", "is", "not", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ".", "cpu", "(", ")", "\n", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "                ", "gt_labels", "=", "gt_labels", ".", "cpu", "(", ")", "\n", "", "", "all_overlaps", "=", "self", ".", "iou_calculator", "(", "approxs", ",", "gt_bboxes", ")", "\n", "\n", "overlaps", ",", "_", "=", "all_overlaps", ".", "view", "(", "approxs_per_octave", ",", "num_squares", ",", "\n", "num_gts", ")", ".", "max", "(", "dim", "=", "0", ")", "\n", "overlaps", "=", "torch", ".", "transpose", "(", "overlaps", ",", "0", ",", "1", ")", "\n", "\n", "if", "(", "self", ".", "ignore_iof_thr", ">", "0", "and", "gt_bboxes_ignore", "is", "not", "None", "\n", "and", "gt_bboxes_ignore", ".", "numel", "(", ")", ">", "0", "and", "squares", ".", "numel", "(", ")", ">", "0", ")", ":", "\n", "            ", "if", "self", ".", "ignore_wrt_candidates", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "squares", ",", "gt_bboxes_ignore", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "gt_bboxes_ignore", ",", "squares", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "", "overlaps", "[", ":", ",", "ignore_max_overlaps", ">", "self", ".", "ignore_iof_thr", "]", "=", "-", "1", "\n", "\n", "", "assign_result", "=", "self", ".", "assign_wrt_overlaps", "(", "overlaps", ",", "gt_labels", ")", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "assign_result", ".", "gt_inds", "=", "assign_result", ".", "gt_inds", ".", "to", "(", "device", ")", "\n", "assign_result", ".", "max_overlaps", "=", "assign_result", ".", "max_overlaps", ".", "to", "(", "device", ")", "\n", "if", "assign_result", ".", "labels", "is", "not", "None", ":", "\n", "                ", "assign_result", ".", "labels", "=", "assign_result", ".", "labels", ".", "to", "(", "device", ")", "\n", "", "", "return", "assign_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.base_assigner.BaseAssigner.assign": [[7, 11], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "assign", "(", "self", ",", "bboxes", ",", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "None", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign boxes to either a ground truth boxe or a negative boxes.\"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.__init__": [[40, 59], ["dict", "iou_calculators.build_iou_calculator"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.builder.build_iou_calculator"], ["def", "__init__", "(", "self", ",", "\n", "pos_iou_thr", ",", "\n", "neg_iou_thr", ",", "\n", "min_pos_iou", "=", ".0", ",", "\n", "gt_max_assign_all", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ",", "\n", "ignore_wrt_candidates", "=", "True", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "gpu_assign_thr", "=", "-", "1", ",", "\n", "iou_calculator", "=", "dict", "(", "type", "=", "'BboxOverlaps2D'", ")", ")", ":", "\n", "        ", "self", ".", "pos_iou_thr", "=", "pos_iou_thr", "\n", "self", ".", "neg_iou_thr", "=", "neg_iou_thr", "\n", "self", ".", "min_pos_iou", "=", "min_pos_iou", "\n", "self", ".", "gt_max_assign_all", "=", "gt_max_assign_all", "\n", "self", ".", "ignore_iof_thr", "=", "ignore_iof_thr", "\n", "self", ".", "ignore_wrt_candidates", "=", "ignore_wrt_candidates", "\n", "self", ".", "gpu_assign_thr", "=", "gpu_assign_thr", "\n", "self", ".", "match_low_quality", "=", "match_low_quality", "\n", "self", ".", "iou_calculator", "=", "build_iou_calculator", "(", "iou_calculator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.assign": [[60, 126], ["max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "bboxes.cpu.cpu.cpu", "gt_bboxes.cpu.cpu.cpu", "max_iou_assigner.MaxIoUAssigner.gt_inds.to", "max_iou_assigner.MaxIoUAssigner.max_overlaps.to", "gt_bboxes_ignore.cpu.cpu.cpu", "gt_labels.cpu.cpu.cpu", "gt_bboxes_ignore.cpu.cpu.numel", "bboxes.cpu.cpu.numel", "max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.max", "max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.max", "max_iou_assigner.MaxIoUAssigner.labels.to"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.sampling_result.SamplingResult.to"], ["", "def", "assign", "(", "self", ",", "bboxes", ",", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "None", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to bboxes.\n\n        This method assign a gt bbox to every bbox (proposal/anchor), each bbox\n        will be assigned with -1, or a semi-positive number. -1 means negative\n        sample, semi-positive number is the index (0-based) of assigned gt.\n        The assignment is done in following steps, the order matters.\n\n        1. assign every bbox to the background\n        2. assign proposals whose iou with all gts < neg_iou_thr to 0\n        3. for each bbox, if the iou with its nearest gt >= pos_iou_thr,\n           assign it to that bbox\n        4. for each gt bbox, assign its nearest proposals (may be more than\n           one) to itself\n\n        Args:\n            bboxes (Tensor): Bounding boxes to be assigned, shape(n, 4).\n            gt_bboxes (Tensor): Groundtruth boxes, shape (k, 4).\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n            gt_labels (Tensor, optional): Label of gt_bboxes, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n\n        Example:\n            >>> self = MaxIoUAssigner(0.5, 0.5)\n            >>> bboxes = torch.Tensor([[0, 0, 10, 10], [10, 10, 20, 20]])\n            >>> gt_bboxes = torch.Tensor([[0, 0, 10, 9]])\n            >>> assign_result = self.assign(bboxes, gt_bboxes)\n            >>> expected_gt_inds = torch.LongTensor([1, 0])\n            >>> assert torch.all(assign_result.gt_inds == expected_gt_inds)\n        \"\"\"", "\n", "assign_on_cpu", "=", "True", "if", "(", "self", ".", "gpu_assign_thr", ">", "0", ")", "and", "(", "\n", "gt_bboxes", ".", "shape", "[", "0", "]", ">", "self", ".", "gpu_assign_thr", ")", "else", "False", "\n", "# compute overlap and assign gt on CPU when number of GT is large", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "device", "=", "bboxes", ".", "device", "\n", "bboxes", "=", "bboxes", ".", "cpu", "(", ")", "\n", "gt_bboxes", "=", "gt_bboxes", ".", "cpu", "(", ")", "\n", "if", "gt_bboxes_ignore", "is", "not", "None", ":", "\n", "                ", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ".", "cpu", "(", ")", "\n", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "                ", "gt_labels", "=", "gt_labels", ".", "cpu", "(", ")", "\n", "\n", "", "", "overlaps", "=", "self", ".", "iou_calculator", "(", "gt_bboxes", ",", "bboxes", ")", "\n", "\n", "if", "(", "self", ".", "ignore_iof_thr", ">", "0", "and", "gt_bboxes_ignore", "is", "not", "None", "\n", "and", "gt_bboxes_ignore", ".", "numel", "(", ")", ">", "0", "and", "bboxes", ".", "numel", "(", ")", ">", "0", ")", ":", "\n", "            ", "if", "self", ".", "ignore_wrt_candidates", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "bboxes", ",", "gt_bboxes_ignore", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "gt_bboxes_ignore", ",", "bboxes", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "", "overlaps", "[", ":", ",", "ignore_max_overlaps", ">", "self", ".", "ignore_iof_thr", "]", "=", "-", "1", "\n", "\n", "", "assign_result", "=", "self", ".", "assign_wrt_overlaps", "(", "overlaps", ",", "gt_labels", ")", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "assign_result", ".", "gt_inds", "=", "assign_result", ".", "gt_inds", ".", "to", "(", "device", ")", "\n", "assign_result", ".", "max_overlaps", "=", "assign_result", ".", "max_overlaps", ".", "to", "(", "device", ")", "\n", "if", "assign_result", ".", "labels", "is", "not", "None", ":", "\n", "                ", "assign_result", ".", "labels", "=", "assign_result", ".", "labels", ".", "to", "(", "device", ")", "\n", "", "", "return", "assign_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps": [[127, 213], ["overlaps.new_full", "overlaps.max", "overlaps.max", "isinstance", "assign_result.AssignResult", "overlaps.size", "overlaps.size", "overlaps.new_zeros", "assign_result.AssignResult", "isinstance", "range", "overlaps.new_full.new_full", "torch.nonzero().squeeze", "overlaps.new_full", "torch.nonzero().squeeze.numel", "len", "torch.nonzero"], "methods", ["None"], ["", "def", "assign_wrt_overlaps", "(", "self", ",", "overlaps", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign w.r.t. the overlaps of bboxes with gts.\n\n        Args:\n            overlaps (Tensor): Overlaps between k gt_bboxes and n bboxes,\n                shape(k, n).\n            gt_labels (Tensor, optional): Labels of k gt_bboxes, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n        \"\"\"", "\n", "num_gts", ",", "num_bboxes", "=", "overlaps", ".", "size", "(", "0", ")", ",", "overlaps", ".", "size", "(", "1", ")", "\n", "\n", "# 1. assign -1 by default", "\n", "assigned_gt_inds", "=", "overlaps", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "if", "num_gts", "==", "0", "or", "num_bboxes", "==", "0", ":", "\n", "# No ground truth or boxes, return empty assignment", "\n", "            ", "max_overlaps", "=", "overlaps", ".", "new_zeros", "(", "(", "num_bboxes", ",", ")", ")", "\n", "if", "num_gts", "==", "0", ":", "\n", "# No truth, assign everything to background", "\n", "                ", "assigned_gt_inds", "[", ":", "]", "=", "0", "\n", "", "if", "gt_labels", "is", "None", ":", "\n", "                ", "assigned_labels", "=", "None", "\n", "", "else", ":", "\n", "                ", "assigned_labels", "=", "overlaps", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "\n", "assigned_gt_inds", ",", "\n", "max_overlaps", ",", "\n", "labels", "=", "assigned_labels", ")", "\n", "\n", "# for each anchor, which gt best overlaps with it", "\n", "# for each anchor, the max iou of all gts", "\n", "", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "# for each gt, which anchor best overlaps with it", "\n", "# for each gt, the max iou of all proposals", "\n", "gt_max_overlaps", ",", "gt_argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "\n", "# 2. assign negative: below", "\n", "# the negative inds are set to be 0", "\n", "if", "isinstance", "(", "self", ".", "neg_iou_thr", ",", "float", ")", ":", "\n", "            ", "assigned_gt_inds", "[", "(", "max_overlaps", ">=", "0", ")", "\n", "&", "(", "max_overlaps", "<", "self", ".", "neg_iou_thr", ")", "]", "=", "0", "\n", "", "elif", "isinstance", "(", "self", ".", "neg_iou_thr", ",", "tuple", ")", ":", "\n", "            ", "assert", "len", "(", "self", ".", "neg_iou_thr", ")", "==", "2", "\n", "assigned_gt_inds", "[", "(", "max_overlaps", ">=", "self", ".", "neg_iou_thr", "[", "0", "]", ")", "\n", "&", "(", "max_overlaps", "<", "self", ".", "neg_iou_thr", "[", "1", "]", ")", "]", "=", "0", "\n", "\n", "# 3. assign positive: above positive IoU threshold", "\n", "", "pos_inds", "=", "max_overlaps", ">=", "self", ".", "pos_iou_thr", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "=", "argmax_overlaps", "[", "pos_inds", "]", "+", "1", "\n", "\n", "if", "self", ".", "match_low_quality", ":", "\n", "# Low-quality matching will overwirte the assigned_gt_inds assigned", "\n", "# in Step 3. Thus, the assigned gt might not be the best one for", "\n", "# prediction.", "\n", "# For example, if bbox A has 0.9 and 0.8 iou with GT bbox 1 & 2,", "\n", "# bbox 1 will be assigned as the best target for bbox A in step 3.", "\n", "# However, if GT bbox 2's gt_argmax_overlaps = A, bbox A's", "\n", "# assigned_gt_inds will be overwritten to be bbox B.", "\n", "# This might be the reason that it is not used in ROI Heads.", "\n", "            ", "for", "i", "in", "range", "(", "num_gts", ")", ":", "\n", "                ", "if", "gt_max_overlaps", "[", "i", "]", ">=", "self", ".", "min_pos_iou", ":", "\n", "                    ", "if", "self", ".", "gt_max_assign_all", ":", "\n", "                        ", "max_iou_inds", "=", "overlaps", "[", "i", ",", ":", "]", "==", "gt_max_overlaps", "[", "i", "]", "\n", "assigned_gt_inds", "[", "max_iou_inds", "]", "=", "i", "+", "1", "\n", "", "else", ":", "\n", "                        ", "assigned_gt_inds", "[", "gt_argmax_overlaps", "[", "i", "]", "]", "=", "i", "+", "1", "\n", "\n", "", "", "", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "            ", "assigned_labels", "=", "assigned_gt_inds", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "-", "1", ")", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assigned_gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "assigned_labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "assigned_labels", "=", "None", "\n", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "assigned_gt_inds", ",", "max_overlaps", ",", "labels", "=", "assigned_labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.point_assigner.PointAssigner.__init__": [[19, 22], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "scale", "=", "4", ",", "pos_num", "=", "3", ")", ":", "\n", "        ", "self", ".", "scale", "=", "scale", "\n", "self", ".", "pos_num", "=", "pos_num", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.point_assigner.PointAssigner.assign": [[23, 134], ["torch.log2().int", "torch.clamp", "points.new_zeros", "points.new_full", "torch.arange", "range", "assign_result.AssignResult", "points.new_full", "assign_result.AssignResult", "torch.log2().int.min", "torch.log2().int.max", "float", "torch.topk", "points.new_full.new_full", "torch.nonzero().squeeze", "points.new_full", "torch.log2", "torch.nonzero().squeeze.numel", "torch.nonzero", "torch.log2", "torch.log2"], "methods", ["None"], ["", "def", "assign", "(", "self", ",", "points", ",", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "None", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to points.\n\n        This method assign a gt bbox to every points set, each points set\n        will be assigned with  the background_label (-1), or a label number.\n        -1 is background, and semi-positive number is the index (0-based) of\n        assigned gt.\n        The assignment is done in following steps, the order matters.\n\n        1. assign every points to the background_label (-1)\n        2. A point is assigned to some gt bbox if\n            (i) the point is within the k closest points to the gt bbox\n            (ii) the distance between this point and the gt is smaller than\n                other gt bboxes\n\n        Args:\n            points (Tensor): points to be assigned, shape(n, 3) while last\n                dimension stands for (x, y, stride).\n            gt_bboxes (Tensor): Groundtruth boxes, shape (k, 4).\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n                NOTE: currently unused.\n            gt_labels (Tensor, optional): Label of gt_bboxes, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n        \"\"\"", "\n", "num_points", "=", "points", ".", "shape", "[", "0", "]", "\n", "num_gts", "=", "gt_bboxes", ".", "shape", "[", "0", "]", "\n", "\n", "if", "num_gts", "==", "0", "or", "num_points", "==", "0", ":", "\n", "# If no truth assign everything to the background", "\n", "            ", "assigned_gt_inds", "=", "points", ".", "new_full", "(", "(", "num_points", ",", ")", ",", "\n", "0", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "if", "gt_labels", "is", "None", ":", "\n", "                ", "assigned_labels", "=", "None", "\n", "", "else", ":", "\n", "                ", "assigned_labels", "=", "points", ".", "new_full", "(", "(", "num_points", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "assigned_gt_inds", ",", "None", ",", "labels", "=", "assigned_labels", ")", "\n", "\n", "", "points_xy", "=", "points", "[", ":", ",", ":", "2", "]", "\n", "points_stride", "=", "points", "[", ":", ",", "2", "]", "\n", "points_lvl", "=", "torch", ".", "log2", "(", "\n", "points_stride", ")", ".", "int", "(", ")", "# [3...,4...,5...,6...,7...]", "\n", "lvl_min", ",", "lvl_max", "=", "points_lvl", ".", "min", "(", ")", ",", "points_lvl", ".", "max", "(", ")", "\n", "\n", "# assign gt box", "\n", "gt_bboxes_xy", "=", "(", "gt_bboxes", "[", ":", ",", ":", "2", "]", "+", "gt_bboxes", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "gt_bboxes_wh", "=", "(", "gt_bboxes", "[", ":", ",", "2", ":", "]", "-", "gt_bboxes", "[", ":", ",", ":", "2", "]", ")", ".", "clamp", "(", "min", "=", "1e-6", ")", "\n", "scale", "=", "self", ".", "scale", "\n", "gt_bboxes_lvl", "=", "(", "(", "torch", ".", "log2", "(", "gt_bboxes_wh", "[", ":", ",", "0", "]", "/", "scale", ")", "+", "\n", "torch", ".", "log2", "(", "gt_bboxes_wh", "[", ":", ",", "1", "]", "/", "scale", ")", ")", "/", "2", ")", ".", "int", "(", ")", "\n", "gt_bboxes_lvl", "=", "torch", ".", "clamp", "(", "gt_bboxes_lvl", ",", "min", "=", "lvl_min", ",", "max", "=", "lvl_max", ")", "\n", "\n", "# stores the assigned gt index of each point", "\n", "assigned_gt_inds", "=", "points", ".", "new_zeros", "(", "(", "num_points", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "# stores the assigned gt dist (to this point) of each point", "\n", "assigned_gt_dist", "=", "points", ".", "new_full", "(", "(", "num_points", ",", ")", ",", "float", "(", "'inf'", ")", ")", "\n", "points_range", "=", "torch", ".", "arange", "(", "points", ".", "shape", "[", "0", "]", ")", "\n", "\n", "for", "idx", "in", "range", "(", "num_gts", ")", ":", "\n", "            ", "gt_lvl", "=", "gt_bboxes_lvl", "[", "idx", "]", "\n", "# get the index of points in this level", "\n", "lvl_idx", "=", "gt_lvl", "==", "points_lvl", "\n", "points_index", "=", "points_range", "[", "lvl_idx", "]", "\n", "# get the points in this level", "\n", "lvl_points", "=", "points_xy", "[", "lvl_idx", ",", ":", "]", "\n", "# get the center point of gt", "\n", "gt_point", "=", "gt_bboxes_xy", "[", "[", "idx", "]", ",", ":", "]", "\n", "# get width and height of gt", "\n", "gt_wh", "=", "gt_bboxes_wh", "[", "[", "idx", "]", ",", ":", "]", "\n", "# compute the distance between gt center and", "\n", "#   all points in this level", "\n", "points_gt_dist", "=", "(", "(", "lvl_points", "-", "gt_point", ")", "/", "gt_wh", ")", ".", "norm", "(", "dim", "=", "1", ")", "\n", "# find the nearest k points to gt center in this level", "\n", "min_dist", ",", "min_dist_index", "=", "torch", ".", "topk", "(", "\n", "points_gt_dist", ",", "self", ".", "pos_num", ",", "largest", "=", "False", ")", "\n", "# the index of nearest k points to gt center in this level", "\n", "min_dist_points_index", "=", "points_index", "[", "min_dist_index", "]", "\n", "# The less_than_recorded_index stores the index", "\n", "#   of min_dist that is less then the assigned_gt_dist. Where", "\n", "#   assigned_gt_dist stores the dist from previous assigned gt", "\n", "#   (if exist) to each point.", "\n", "less_than_recorded_index", "=", "min_dist", "<", "assigned_gt_dist", "[", "\n", "min_dist_points_index", "]", "\n", "# The min_dist_points_index stores the index of points satisfy:", "\n", "#   (1) it is k nearest to current gt center in this level.", "\n", "#   (2) it is closer to current gt center than other gt center.", "\n", "min_dist_points_index", "=", "min_dist_points_index", "[", "\n", "less_than_recorded_index", "]", "\n", "# assign the result", "\n", "assigned_gt_inds", "[", "min_dist_points_index", "]", "=", "idx", "+", "1", "\n", "assigned_gt_dist", "[", "min_dist_points_index", "]", "=", "min_dist", "[", "\n", "less_than_recorded_index", "]", "\n", "\n", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "            ", "assigned_labels", "=", "assigned_gt_inds", ".", "new_full", "(", "(", "num_points", ",", ")", ",", "-", "1", ")", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assigned_gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "assigned_labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "assigned_labels", "=", "None", "\n", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "assigned_gt_inds", ",", "None", ",", "labels", "=", "assigned_labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.__init__": [[42, 49], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_gts", ",", "gt_inds", ",", "max_overlaps", ",", "labels", "=", "None", ")", ":", "\n", "        ", "self", ".", "num_gts", "=", "num_gts", "\n", "self", ".", "gt_inds", "=", "gt_inds", "\n", "self", ".", "max_overlaps", "=", "max_overlaps", "\n", "self", ".", "labels", "=", "labels", "\n", "# Interface for possible user-defined properties", "\n", "self", ".", "_extra_properties", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.num_preds": [[50, 54], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_preds", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: the number of predictions in this assignment\"\"\"", "\n", "return", "len", "(", "self", ".", "gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.set_extra_property": [[55, 59], ["None"], "methods", ["None"], ["", "def", "set_extra_property", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "\"\"\"Set user-defined new property.\"\"\"", "\n", "assert", "key", "not", "in", "self", ".", "info", "\n", "self", ".", "_extra_properties", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.get_extra_property": [[60, 63], ["assign_result.AssignResult._extra_properties.get"], "methods", ["None"], ["", "def", "get_extra_property", "(", "self", ",", "key", ")", ":", "\n", "        ", "\"\"\"Get user-defined property.\"\"\"", "\n", "return", "self", ".", "_extra_properties", ".", "get", "(", "key", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.info": [[64, 76], ["basic_info.update"], "methods", ["None"], ["", "@", "property", "\n", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"dict: a dictionary of info about the object\"\"\"", "\n", "basic_info", "=", "{", "\n", "'num_gts'", ":", "self", ".", "num_gts", ",", "\n", "'num_preds'", ":", "self", ".", "num_preds", ",", "\n", "'gt_inds'", ":", "self", ".", "gt_inds", ",", "\n", "'max_overlaps'", ":", "self", ".", "max_overlaps", ",", "\n", "'labels'", ":", "self", ".", "labels", ",", "\n", "}", "\n", "basic_info", ".", "update", "(", "self", ".", "_extra_properties", ")", "\n", "return", "basic_info", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.__nice__": [[77, 95], ["parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "tuple", "tuple", "tuple"], "methods", ["None"], ["", "def", "__nice__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a \"nice\" summary string describing this assign result\"\"\"", "\n", "parts", "=", "[", "]", "\n", "parts", ".", "append", "(", "f'num_gts={self.num_gts!r}'", ")", "\n", "if", "self", ".", "gt_inds", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'gt_inds={self.gt_inds!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "f'gt_inds.shape={tuple(self.gt_inds.shape)!r}'", ")", "\n", "", "if", "self", ".", "max_overlaps", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'max_overlaps={self.max_overlaps!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "'max_overlaps.shape='", "\n", "f'{tuple(self.max_overlaps.shape)!r}'", ")", "\n", "", "if", "self", ".", "labels", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'labels={self.labels!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "f'labels.shape={tuple(self.labels.shape)!r}'", ")", "\n", "", "return", "', '", ".", "join", "(", "parts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random": [[96, 189], ["demodata.ensure_rng", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "cls", "kwargs.get", "demodata.ensure_rng.randint", "demodata.ensure_rng.randint", "torch.zeros", "torch.zeros", "torch.from_numpy", "torch.from_numpy", "min", "demodata.ensure_rng.shuffle", "assigned_idxs.sort", "torch.zeros", "np.arange", "demodata.ensure_rng.shuffle", "torch.from_numpy", "torch.from_numpy", "torch.zeros", "demodata.ensure_rng.rand", "min", "np.where", "torch.from_numpy", "demodata.ensure_rng.randint", "demodata.ensure_rng.rand", "demodata.ensure_rng.rand", "torch.from_numpy.sum", "demodata.ensure_rng.rand", "torch.zeros", "torch.from_numpy", "demodata.ensure_rng.rand", "demodata.ensure_rng.randint"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng"], ["", "@", "classmethod", "\n", "def", "random", "(", "cls", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Create random AssignResult for tests or debugging.\n\n        Args:\n            num_preds: number of predicted boxes\n            num_gts: number of true boxes\n            p_ignore (float): probability of a predicted box assinged to an\n                ignored truth\n            p_assigned (float): probability of a predicted box not being\n                assigned\n            p_use_label (float | bool): with labels or not\n            rng (None | int | numpy.random.RandomState): seed or state\n\n        Returns:\n            :obj:`AssignResult`: Randomly generated assign results.\n\n        Example:\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\n            >>> self = AssignResult.random()\n            >>> print(self.info)\n        \"\"\"", "\n", "from", "mmdet", ".", "core", ".", "bbox", "import", "demodata", "\n", "rng", "=", "demodata", ".", "ensure_rng", "(", "kwargs", ".", "get", "(", "'rng'", ",", "None", ")", ")", "\n", "\n", "num_gts", "=", "kwargs", ".", "get", "(", "'num_gts'", ",", "None", ")", "\n", "num_preds", "=", "kwargs", ".", "get", "(", "'num_preds'", ",", "None", ")", "\n", "p_ignore", "=", "kwargs", ".", "get", "(", "'p_ignore'", ",", "0.3", ")", "\n", "p_assigned", "=", "kwargs", ".", "get", "(", "'p_assigned'", ",", "0.7", ")", "\n", "p_use_label", "=", "kwargs", ".", "get", "(", "'p_use_label'", ",", "0.5", ")", "\n", "num_classes", "=", "kwargs", ".", "get", "(", "'p_use_label'", ",", "3", ")", "\n", "\n", "if", "num_gts", "is", "None", ":", "\n", "            ", "num_gts", "=", "rng", ".", "randint", "(", "0", ",", "8", ")", "\n", "", "if", "num_preds", "is", "None", ":", "\n", "            ", "num_preds", "=", "rng", ".", "randint", "(", "0", ",", "16", ")", "\n", "\n", "", "if", "num_gts", "==", "0", ":", "\n", "            ", "max_overlaps", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_inds", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "if", "p_use_label", "is", "True", "or", "p_use_label", "<", "rng", ".", "rand", "(", ")", ":", "\n", "                ", "labels", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "", "else", ":", "\n", "                ", "labels", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "import", "numpy", "as", "np", "\n", "# Create an overlap for each predicted box", "\n", "max_overlaps", "=", "torch", ".", "from_numpy", "(", "rng", ".", "rand", "(", "num_preds", ")", ")", "\n", "\n", "# Construct gt_inds for each predicted box", "\n", "is_assigned", "=", "torch", ".", "from_numpy", "(", "rng", ".", "rand", "(", "num_preds", ")", "<", "p_assigned", ")", "\n", "# maximum number of assignments constraints", "\n", "n_assigned", "=", "min", "(", "num_preds", ",", "min", "(", "num_gts", ",", "is_assigned", ".", "sum", "(", ")", ")", ")", "\n", "\n", "assigned_idxs", "=", "np", ".", "where", "(", "is_assigned", ")", "[", "0", "]", "\n", "rng", ".", "shuffle", "(", "assigned_idxs", ")", "\n", "assigned_idxs", "=", "assigned_idxs", "[", "0", ":", "n_assigned", "]", "\n", "assigned_idxs", ".", "sort", "(", ")", "\n", "\n", "is_assigned", "[", ":", "]", "=", "0", "\n", "is_assigned", "[", "assigned_idxs", "]", "=", "True", "\n", "\n", "is_ignore", "=", "torch", ".", "from_numpy", "(", "\n", "rng", ".", "rand", "(", "num_preds", ")", "<", "p_ignore", ")", "&", "is_assigned", "\n", "\n", "gt_inds", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n", "true_idxs", "=", "np", ".", "arange", "(", "num_gts", ")", "\n", "rng", ".", "shuffle", "(", "true_idxs", ")", "\n", "true_idxs", "=", "torch", ".", "from_numpy", "(", "true_idxs", ")", "\n", "gt_inds", "[", "is_assigned", "]", "=", "true_idxs", "[", ":", "n_assigned", "]", "\n", "\n", "gt_inds", "=", "torch", ".", "from_numpy", "(", "\n", "rng", ".", "randint", "(", "1", ",", "num_gts", "+", "1", ",", "size", "=", "num_preds", ")", ")", "\n", "gt_inds", "[", "is_ignore", "]", "=", "-", "1", "\n", "gt_inds", "[", "~", "is_assigned", "]", "=", "0", "\n", "max_overlaps", "[", "~", "is_assigned", "]", "=", "0", "\n", "\n", "if", "p_use_label", "is", "True", "or", "p_use_label", "<", "rng", ".", "rand", "(", ")", ":", "\n", "                ", "if", "num_classes", "==", "0", ":", "\n", "                    ", "labels", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "", "else", ":", "\n", "                    ", "labels", "=", "torch", ".", "from_numpy", "(", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since mmdet v2.0", "\n", "# BG cat_id: num_class", "\n", "rng", ".", "randint", "(", "0", ",", "num_classes", ",", "size", "=", "num_preds", ")", ")", "\n", "labels", "[", "~", "is_assigned", "]", "=", "0", "\n", "", "", "else", ":", "\n", "                ", "labels", "=", "None", "\n", "\n", "", "", "self", "=", "cls", "(", "num_gts", ",", "gt_inds", ",", "max_overlaps", ",", "labels", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.add_gt_": [[190, 205], ["torch.arange", "torch.cat", "torch.cat", "torch.cat", "len", "assign_result.AssignResult.max_overlaps.new_ones", "len"], "methods", ["None"], ["", "def", "add_gt_", "(", "self", ",", "gt_labels", ")", ":", "\n", "        ", "\"\"\"Add ground truth as assigned results.\n\n        Args:\n            gt_labels (torch.Tensor): Labels of gt boxes\n        \"\"\"", "\n", "self_inds", "=", "torch", ".", "arange", "(", "\n", "1", ",", "len", "(", "gt_labels", ")", "+", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "gt_labels", ".", "device", ")", "\n", "self", ".", "gt_inds", "=", "torch", ".", "cat", "(", "[", "self_inds", ",", "self", ".", "gt_inds", "]", ")", "\n", "\n", "self", ".", "max_overlaps", "=", "torch", ".", "cat", "(", "\n", "[", "self", ".", "max_overlaps", ".", "new_ones", "(", "len", "(", "gt_labels", ")", ")", ",", "self", ".", "max_overlaps", "]", ")", "\n", "\n", "if", "self", ".", "labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "labels", "=", "torch", ".", "cat", "(", "[", "gt_labels", ",", "self", ".", "labels", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.__init__": [[23, 30], ["dict", "iou_calculators.build_iou_calculator"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.builder.build_iou_calculator"], ["def", "__init__", "(", "self", ",", "\n", "topk", ",", "\n", "iou_calculator", "=", "dict", "(", "type", "=", "'BboxOverlaps2D'", ")", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "topk", "=", "topk", "\n", "self", ".", "iou_calculator", "=", "build_iou_calculator", "(", "iou_calculator", ")", "\n", "self", ".", "ignore_iof_thr", "=", "ignore_iof_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign": [[33, 179], ["atss_assigner.ATSSAssigner.iou_calculator", "atss_assigner.ATSSAssigner.new_full", "torch.stack", "torch.stack", "enumerate", "torch.cat", "candidate_overlaps.mean", "candidate_overlaps.std", "range", "bboxes_cx.view().expand().contiguous().view", "bboxes_cy.view().expand().contiguous().view", "candidate_idxs.view.view.view", "torch.full_like().t().contiguous().view", "overlaps_inf.view().t.view().t.view().t", "overlaps_inf.view().t.view().t.max", "assign_result.AssignResult", "gt_bboxes.size", "bboxes.size", "atss_assigner.ATSSAssigner.new_zeros", "assign_result.AssignResult", "atss_assigner.ATSSAssigner.iou_calculator", "atss_assigner.ATSSAssigner.max", "min", "distances_per_level.topk", "candidate_idxs.view.view.append", "ep_bboxes_cx[].view", "ep_bboxes_cy[].view", "ep_bboxes_cx[].view", "ep_bboxes_cy[].view", "candidate_idxs.view.view.view", "atss_assigner.ATSSAssigner.t().contiguous().view", "atss_assigner.ATSSAssigner.new_full.new_full", "torch.nonzero().squeeze", "atss_assigner.ATSSAssigner.new_full", "gt_bboxes_ignore.numel", "bboxes.numel", "bboxes_cx.view().expand().contiguous", "bboxes_cy.view().expand().contiguous", "torch.stack().min", "torch.full_like().t().contiguous", "is_pos.view", "overlaps_inf.view().t.view().t.view", "torch.nonzero().squeeze.numel", "torch.arange", "atss_assigner.ATSSAssigner.t().contiguous", "torch.nonzero", "bboxes_cx.view().expand", "bboxes_cy.view().expand", "torch.stack", "torch.full_like().t", "atss_assigner.ATSSAssigner.t", "bboxes_cx.view", "bboxes_cy.view", "torch.full_like"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "assign", "(", "self", ",", "\n", "bboxes", ",", "\n", "num_level_bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "None", ",", "\n", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to bboxes.\n\n        The assignment is done in following steps\n\n        1. compute iou between all bbox (bbox of all pyramid levels) and gt\n        2. compute center distance between all bbox and gt\n        3. on each pyramid level, for each gt, select k bbox whose center\n           are closest to the gt center, so we total select k*l bbox as\n           candidates for each gt\n        4. get corresponding iou for the these candidates, and compute the\n           mean and std, set mean + std as the iou threshold\n        5. select these candidates whose iou are greater than or equal to\n           the threshold as postive\n        6. limit the positive sample's center in gt\n\n\n        Args:\n            bboxes (Tensor): Bounding boxes to be assigned, shape(n, 4).\n            num_level_bboxes (List): num of bboxes in each level\n            gt_bboxes (Tensor): Groundtruth boxes, shape (k, 4).\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n            gt_labels (Tensor, optional): Label of gt_bboxes, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n        \"\"\"", "\n", "INF", "=", "100000000", "\n", "bboxes", "=", "bboxes", "[", ":", ",", ":", "4", "]", "\n", "num_gt", ",", "num_bboxes", "=", "gt_bboxes", ".", "size", "(", "0", ")", ",", "bboxes", ".", "size", "(", "0", ")", "\n", "\n", "# compute iou between all bbox and gt", "\n", "overlaps", "=", "self", ".", "iou_calculator", "(", "bboxes", ",", "gt_bboxes", ")", "\n", "\n", "# assign 0 by default", "\n", "assigned_gt_inds", "=", "overlaps", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "\n", "0", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "if", "num_gt", "==", "0", "or", "num_bboxes", "==", "0", ":", "\n", "# No ground truth or boxes, return empty assignment", "\n", "            ", "max_overlaps", "=", "overlaps", ".", "new_zeros", "(", "(", "num_bboxes", ",", ")", ")", "\n", "if", "num_gt", "==", "0", ":", "\n", "# No truth, assign everything to background", "\n", "                ", "assigned_gt_inds", "[", ":", "]", "=", "0", "\n", "", "if", "gt_labels", "is", "None", ":", "\n", "                ", "assigned_labels", "=", "None", "\n", "", "else", ":", "\n", "                ", "assigned_labels", "=", "overlaps", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "", "return", "AssignResult", "(", "\n", "num_gt", ",", "assigned_gt_inds", ",", "max_overlaps", ",", "labels", "=", "assigned_labels", ")", "\n", "\n", "# compute center distance between all bbox and gt", "\n", "", "gt_cx", "=", "(", "gt_bboxes", "[", ":", ",", "0", "]", "+", "gt_bboxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "gt_cy", "=", "(", "gt_bboxes", "[", ":", ",", "1", "]", "+", "gt_bboxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "gt_points", "=", "torch", ".", "stack", "(", "(", "gt_cx", ",", "gt_cy", ")", ",", "dim", "=", "1", ")", "\n", "\n", "bboxes_cx", "=", "(", "bboxes", "[", ":", ",", "0", "]", "+", "bboxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "bboxes_cy", "=", "(", "bboxes", "[", ":", ",", "1", "]", "+", "bboxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "bboxes_points", "=", "torch", ".", "stack", "(", "(", "bboxes_cx", ",", "bboxes_cy", ")", ",", "dim", "=", "1", ")", "\n", "\n", "distances", "=", "(", "bboxes_points", "[", ":", ",", "None", ",", ":", "]", "-", "\n", "gt_points", "[", "None", ",", ":", ",", ":", "]", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", ".", "sqrt", "(", ")", "\n", "\n", "if", "(", "self", ".", "ignore_iof_thr", ">", "0", "and", "gt_bboxes_ignore", "is", "not", "None", "\n", "and", "gt_bboxes_ignore", ".", "numel", "(", ")", ">", "0", "and", "bboxes", ".", "numel", "(", ")", ">", "0", ")", ":", "\n", "            ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "bboxes", ",", "gt_bboxes_ignore", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "ignore_idxs", "=", "ignore_max_overlaps", ">", "self", ".", "ignore_iof_thr", "\n", "distances", "[", "ignore_idxs", ",", ":", "]", "=", "INF", "\n", "assigned_gt_inds", "[", "ignore_idxs", "]", "=", "-", "1", "\n", "\n", "# Selecting candidates based on the center distance", "\n", "", "candidate_idxs", "=", "[", "]", "\n", "start_idx", "=", "0", "\n", "for", "level", ",", "bboxes_per_level", "in", "enumerate", "(", "num_level_bboxes", ")", ":", "\n", "# on each pyramid level, for each gt,", "\n", "# select k bbox whose center are closest to the gt center", "\n", "            ", "end_idx", "=", "start_idx", "+", "bboxes_per_level", "\n", "distances_per_level", "=", "distances", "[", "start_idx", ":", "end_idx", ",", ":", "]", "\n", "selectable_k", "=", "min", "(", "self", ".", "topk", ",", "bboxes_per_level", ")", "\n", "_", ",", "topk_idxs_per_level", "=", "distances_per_level", ".", "topk", "(", "\n", "selectable_k", ",", "dim", "=", "0", ",", "largest", "=", "False", ")", "\n", "candidate_idxs", ".", "append", "(", "topk_idxs_per_level", "+", "start_idx", ")", "\n", "start_idx", "=", "end_idx", "\n", "", "candidate_idxs", "=", "torch", ".", "cat", "(", "candidate_idxs", ",", "dim", "=", "0", ")", "\n", "\n", "# get corresponding iou for the these candidates, and compute the", "\n", "# mean and std, set mean + std as the iou threshold", "\n", "candidate_overlaps", "=", "overlaps", "[", "candidate_idxs", ",", "torch", ".", "arange", "(", "num_gt", ")", "]", "\n", "overlaps_mean_per_gt", "=", "candidate_overlaps", ".", "mean", "(", "0", ")", "\n", "overlaps_std_per_gt", "=", "candidate_overlaps", ".", "std", "(", "0", ")", "\n", "overlaps_thr_per_gt", "=", "overlaps_mean_per_gt", "+", "overlaps_std_per_gt", "\n", "\n", "is_pos", "=", "candidate_overlaps", ">=", "overlaps_thr_per_gt", "[", "None", ",", ":", "]", "\n", "\n", "# limit the positive sample's center in gt", "\n", "for", "gt_idx", "in", "range", "(", "num_gt", ")", ":", "\n", "            ", "candidate_idxs", "[", ":", ",", "gt_idx", "]", "+=", "gt_idx", "*", "num_bboxes", "\n", "", "ep_bboxes_cx", "=", "bboxes_cx", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand", "(", "\n", "num_gt", ",", "num_bboxes", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "ep_bboxes_cy", "=", "bboxes_cy", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand", "(", "\n", "num_gt", ",", "num_bboxes", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "candidate_idxs", "=", "candidate_idxs", ".", "view", "(", "-", "1", ")", "\n", "\n", "# calculate the left, top, right, bottom distance between positive", "\n", "# bbox center and gt side", "\n", "l_", "=", "ep_bboxes_cx", "[", "candidate_idxs", "]", ".", "view", "(", "-", "1", ",", "num_gt", ")", "-", "gt_bboxes", "[", ":", ",", "0", "]", "\n", "t_", "=", "ep_bboxes_cy", "[", "candidate_idxs", "]", ".", "view", "(", "-", "1", ",", "num_gt", ")", "-", "gt_bboxes", "[", ":", ",", "1", "]", "\n", "r_", "=", "gt_bboxes", "[", ":", ",", "2", "]", "-", "ep_bboxes_cx", "[", "candidate_idxs", "]", ".", "view", "(", "-", "1", ",", "num_gt", ")", "\n", "b_", "=", "gt_bboxes", "[", ":", ",", "3", "]", "-", "ep_bboxes_cy", "[", "candidate_idxs", "]", ".", "view", "(", "-", "1", ",", "num_gt", ")", "\n", "is_in_gts", "=", "torch", ".", "stack", "(", "[", "l_", ",", "t_", ",", "r_", ",", "b_", "]", ",", "dim", "=", "1", ")", ".", "min", "(", "dim", "=", "1", ")", "[", "0", "]", ">", "0.01", "\n", "is_pos", "=", "is_pos", "&", "is_in_gts", "\n", "\n", "# if an anchor box is assigned to multiple gts,", "\n", "# the one with the highest IoU will be selected.", "\n", "overlaps_inf", "=", "torch", ".", "full_like", "(", "overlaps", ",", "\n", "-", "INF", ")", ".", "t", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "index", "=", "candidate_idxs", ".", "view", "(", "-", "1", ")", "[", "is_pos", ".", "view", "(", "-", "1", ")", "]", "\n", "overlaps_inf", "[", "index", "]", "=", "overlaps", ".", "t", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "[", "index", "]", "\n", "overlaps_inf", "=", "overlaps_inf", ".", "view", "(", "num_gt", ",", "-", "1", ")", ".", "t", "(", ")", "\n", "\n", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps_inf", ".", "max", "(", "dim", "=", "1", ")", "\n", "assigned_gt_inds", "[", "\n", "max_overlaps", "!=", "-", "INF", "]", "=", "argmax_overlaps", "[", "max_overlaps", "!=", "-", "INF", "]", "+", "1", "\n", "\n", "if", "gt_labels", "is", "not", "None", ":", "\n", "            ", "assigned_labels", "=", "assigned_gt_inds", ".", "new_full", "(", "(", "num_bboxes", ",", ")", ",", "-", "1", ")", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assigned_gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "assigned_labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "assigned_labels", "=", "None", "\n", "", "return", "AssignResult", "(", "\n", "num_gt", ",", "assigned_gt_inds", ",", "max_overlaps", ",", "labels", "=", "assigned_labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.TBLRBBoxCoder.__init__": [[22, 25], ["base_bbox_coder.BaseBBoxCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "normalizer", "=", "4.0", ")", ":", "\n", "        ", "super", "(", "BaseBBoxCoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "normalizer", "=", "normalizer", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.TBLRBBoxCoder.encode": [[26, 44], ["tblr_bbox_coder.bboxes2tblr", "bboxes.size", "gt_bboxes.size", "bboxes.size", "gt_bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.bboxes2tblr"], ["", "def", "encode", "(", "self", ",", "bboxes", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"Get box regression transformation deltas that can be used to\n        transform the ``bboxes`` into the ``gt_bboxes`` in the (top, left,\n        bottom, right) order.\n\n        Args:\n            bboxes (torch.Tensor): source boxes, e.g., object proposals.\n            gt_bboxes (torch.Tensor): target of the transformation, e.g.,\n                ground truth boxes.\n\n        Returns:\n            torch.Tensor: Box transformation deltas\n        \"\"\"", "\n", "assert", "bboxes", ".", "size", "(", "0", ")", "==", "gt_bboxes", ".", "size", "(", "0", ")", "\n", "assert", "bboxes", ".", "size", "(", "-", "1", ")", "==", "gt_bboxes", ".", "size", "(", "-", "1", ")", "==", "4", "\n", "encoded_bboxes", "=", "bboxes2tblr", "(", "\n", "bboxes", ",", "gt_bboxes", ",", "normalizer", "=", "self", ".", "normalizer", ")", "\n", "return", "encoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.TBLRBBoxCoder.decode": [[45, 65], ["tblr_bbox_coder.tblr2bboxes", "pred_bboxes.size", "bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.tblr2bboxes"], ["", "def", "decode", "(", "self", ",", "bboxes", ",", "pred_bboxes", ",", "max_shape", "=", "None", ")", ":", "\n", "        ", "\"\"\"Apply transformation `pred_bboxes` to `boxes`.\n\n        Args:\n            boxes (torch.Tensor): Basic boxes.\n            pred_bboxes (torch.Tensor): Encoded boxes with shape\n            max_shape (tuple[int], optional): Maximum shape of boxes.\n                Defaults to None.\n\n        Returns:\n            torch.Tensor: Decoded boxes.\n        \"\"\"", "\n", "assert", "pred_bboxes", ".", "size", "(", "0", ")", "==", "bboxes", ".", "size", "(", "0", ")", "\n", "decoded_bboxes", "=", "tblr2bboxes", "(", "\n", "bboxes", ",", "\n", "pred_bboxes", ",", "\n", "normalizer", "=", "self", ".", "normalizer", ",", "\n", "max_shape", "=", "max_shape", ")", "\n", "\n", "return", "decoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.bboxes2tblr": [[67, 111], ["gts.split", "torch.cat", "isinstance", "torch.tensor", "priors.size", "gts.size", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "torch.split", "len"], "function", ["None"], ["", "", "def", "bboxes2tblr", "(", "priors", ",", "gts", ",", "normalizer", "=", "4.0", ",", "normalize_by_wh", "=", "True", ")", ":", "\n", "    ", "\"\"\"Encode ground truth boxes to tblr coordinate.\n\n    It first convert the gt coordinate to tblr format,\n     (top, bottom, left, right), relative to prior box centers.\n     The tblr coordinate may be normalized by the side length of prior bboxes\n     if `normalize_by_wh` is specified as True, and it is then normalized by\n     the `normalizer` factor.\n\n    Args:\n        priors (Tensor): Prior boxes in point form\n            Shape: (num_proposals,4).\n        gts (Tensor): Coords of ground truth for each prior in point-form\n            Shape: (num_proposals, 4).\n        normalizer (Sequence[float] | float): normalization parameter of\n            encoded boxes. If it is a list, it has to have length = 4.\n            Default: 4.0\n        normalize_by_wh (bool): Whether to normalize tblr coordinate by the\n            side length (wh) of prior bboxes.\n\n    Return:\n        encoded boxes (Tensor), Shape: (num_proposals, 4)\n    \"\"\"", "\n", "\n", "# dist b/t match center and prior's center", "\n", "if", "not", "isinstance", "(", "normalizer", ",", "float", ")", ":", "\n", "        ", "normalizer", "=", "torch", ".", "tensor", "(", "normalizer", ",", "device", "=", "priors", ".", "device", ")", "\n", "assert", "len", "(", "normalizer", ")", "==", "4", ",", "'Normalizer must have length = 4'", "\n", "", "assert", "priors", ".", "size", "(", "0", ")", "==", "gts", ".", "size", "(", "0", ")", "\n", "prior_centers", "=", "(", "priors", "[", ":", ",", "0", ":", "2", "]", "+", "priors", "[", ":", ",", "2", ":", "4", "]", ")", "/", "2", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "gts", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "top", "=", "prior_centers", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "-", "ymin", "\n", "bottom", "=", "ymax", "-", "prior_centers", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "\n", "left", "=", "prior_centers", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "-", "xmin", "\n", "right", "=", "xmax", "-", "prior_centers", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "\n", "loc", "=", "torch", ".", "cat", "(", "(", "top", ",", "bottom", ",", "left", ",", "right", ")", ",", "dim", "=", "1", ")", "\n", "if", "normalize_by_wh", ":", "\n", "# Normalize tblr by anchor width and height", "\n", "        ", "wh", "=", "priors", "[", ":", ",", "2", ":", "4", "]", "-", "priors", "[", ":", ",", "0", ":", "2", "]", "\n", "w", ",", "h", "=", "torch", ".", "split", "(", "wh", ",", "1", ",", "dim", "=", "1", ")", "\n", "loc", "[", ":", ",", ":", "2", "]", "/=", "h", "# tb is normalized by h", "\n", "loc", "[", ":", ",", "2", ":", "]", "/=", "w", "# lr is normalized by w", "\n", "# Normalize tblr by the given normalization factor", "\n", "", "return", "loc", "/", "normalizer", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.tblr_bbox_coder.tblr2bboxes": [[113, 166], ["loc_decode.split", "torch.cat", "isinstance", "torch.tensor", "priors.size", "tblr.size", "torch.split", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "prior_centers[].unsqueeze", "boxes[].clamp_", "boxes[].clamp_", "boxes[].clamp_", "boxes[].clamp_", "len"], "function", ["None"], ["", "def", "tblr2bboxes", "(", "priors", ",", "\n", "tblr", ",", "\n", "normalizer", "=", "4.0", ",", "\n", "normalize_by_wh", "=", "True", ",", "\n", "max_shape", "=", "None", ")", ":", "\n", "    ", "\"\"\"Decode tblr outputs to prediction boxes.\n\n    The process includes 3 steps: 1) De-normalize tblr coordinates by\n    multiplying it with `normalizer`; 2) De-normalize tblr coordinates by the\n    prior bbox width and height if `normalize_by_wh` is `True`; 3) Convert\n    tblr (top, bottom, left, right) pair relative to the center of priors back\n    to (xmin, ymin, xmax, ymax) coordinate.\n\n    Args:\n        priors (Tensor): Prior boxes in point form (x0, y0, x1, y1)\n          Shape: (n,4).\n        tblr (Tensor): Coords of network output in tblr form\n          Shape: (n, 4).\n        normalizer (Sequence[float] | float): Normalization parameter of\n          encoded boxes. By list, it represents the normalization factors at\n          tblr dims. By float, it is the unified normalization factor at all\n          dims. Default: 4.0\n        normalize_by_wh (bool): Whether the tblr coordinates have been\n          normalized by the side length (wh) of prior bboxes.\n        max_shape (tuple, optional): Shape of the image. Decoded bboxes\n          exceeding which will be clamped.\n\n    Return:\n        encoded boxes (Tensor), Shape: (n, 4)\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "normalizer", ",", "float", ")", ":", "\n", "        ", "normalizer", "=", "torch", ".", "tensor", "(", "normalizer", ",", "device", "=", "priors", ".", "device", ")", "\n", "assert", "len", "(", "normalizer", ")", "==", "4", ",", "'Normalizer must have length = 4'", "\n", "", "assert", "priors", ".", "size", "(", "0", ")", "==", "tblr", ".", "size", "(", "0", ")", "\n", "loc_decode", "=", "tblr", "*", "normalizer", "\n", "prior_centers", "=", "(", "priors", "[", ":", ",", "0", ":", "2", "]", "+", "priors", "[", ":", ",", "2", ":", "4", "]", ")", "/", "2", "\n", "if", "normalize_by_wh", ":", "\n", "        ", "wh", "=", "priors", "[", ":", ",", "2", ":", "4", "]", "-", "priors", "[", ":", ",", "0", ":", "2", "]", "\n", "w", ",", "h", "=", "torch", ".", "split", "(", "wh", ",", "1", ",", "dim", "=", "1", ")", "\n", "loc_decode", "[", ":", ",", ":", "2", "]", "*=", "h", "# tb", "\n", "loc_decode", "[", ":", ",", "2", ":", "]", "*=", "w", "# lr", "\n", "", "top", ",", "bottom", ",", "left", ",", "right", "=", "loc_decode", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "xmin", "=", "prior_centers", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "-", "left", "\n", "xmax", "=", "prior_centers", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "+", "right", "\n", "ymin", "=", "prior_centers", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "-", "top", "\n", "ymax", "=", "prior_centers", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "+", "bottom", "\n", "boxes", "=", "torch", ".", "cat", "(", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "dim", "=", "1", ")", "\n", "if", "max_shape", "is", "not", "None", ":", "\n", "        ", "boxes", "[", ":", ",", "0", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", ")", "\n", "boxes", "[", ":", ",", "1", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", ")", "\n", "boxes", "[", ":", ",", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", ")", "\n", "boxes", "[", ":", ",", "3", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", ")", "\n", "", "return", "boxes", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.base_bbox_coder.BaseBBoxCoder.__init__": [[7, 9], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.base_bbox_coder.BaseBBoxCoder.encode": [[10, 14], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "encode", "(", "self", ",", "bboxes", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"Encode deltas between bboxes and ground truth boxes.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.base_bbox_coder.BaseBBoxCoder.decode": [[15, 20], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "decode", "(", "self", ",", "bboxes", ",", "bboxes_pred", ")", ":", "\n", "        ", "\"\"\"Decode the predicted bboxes according to prediction and base\n        boxes.\"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.pseudo_bbox_coder.PseudoBBoxCoder.__init__": [[9, 11], ["base_bbox_coder.BaseBBoxCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BaseBBoxCoder", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.pseudo_bbox_coder.PseudoBBoxCoder.encode": [[12, 15], ["None"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "bboxes", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: return the given ``bboxes``\"\"\"", "\n", "return", "gt_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.pseudo_bbox_coder.PseudoBBoxCoder.decode": [[16, 19], ["None"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "bboxes", ",", "pred_bboxes", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: return the given ``pred_bboxes``\"\"\"", "\n", "return", "pred_bboxes", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.DeltaXYWHBBoxCoder.__init__": [[23, 29], ["base_bbox_coder.BaseBBoxCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "target_means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "\n", "target_stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ")", ":", "\n", "        ", "super", "(", "BaseBBoxCoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "means", "=", "target_means", "\n", "self", ".", "stds", "=", "target_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.DeltaXYWHBBoxCoder.encode": [[30, 47], ["delta_xywh_bbox_coder.bbox2delta", "bboxes.size", "gt_bboxes.size", "bboxes.size", "gt_bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.bbox2delta"], ["", "def", "encode", "(", "self", ",", "bboxes", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"Get box regression transformation deltas that can be used to\n        transform the ``bboxes`` into the ``gt_bboxes``.\n\n        Args:\n            bboxes (torch.Tensor): Source boxes, e.g., object proposals.\n            gt_bboxes (torch.Tensor): Target of the transformation, e.g.,\n                ground-truth boxes.\n\n        Returns:\n            torch.Tensor: Box transformation deltas\n        \"\"\"", "\n", "\n", "assert", "bboxes", ".", "size", "(", "0", ")", "==", "gt_bboxes", ".", "size", "(", "0", ")", "\n", "assert", "bboxes", ".", "size", "(", "-", "1", ")", "==", "gt_bboxes", ".", "size", "(", "-", "1", ")", "==", "4", "\n", "encoded_bboxes", "=", "bbox2delta", "(", "bboxes", ",", "gt_bboxes", ",", "self", ".", "means", ",", "self", ".", "stds", ")", "\n", "return", "encoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.DeltaXYWHBBoxCoder.decode": [[48, 72], ["delta_xywh_bbox_coder.delta2bbox", "pred_bboxes.size", "bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.delta2bbox"], ["", "def", "decode", "(", "self", ",", "\n", "bboxes", ",", "\n", "pred_bboxes", ",", "\n", "max_shape", "=", "None", ",", "\n", "wh_ratio_clip", "=", "16", "/", "1000", ")", ":", "\n", "        ", "\"\"\"Apply transformation `pred_bboxes` to `boxes`.\n\n        Args:\n            boxes (torch.Tensor): Basic boxes.\n            pred_bboxes (torch.Tensor): Encoded boxes with shape\n            max_shape (tuple[int], optional): Maximum shape of boxes.\n                Defaults to None.\n            wh_ratio_clip (float, optional): The allowed ratio between\n                width and height.\n\n        Returns:\n            torch.Tensor: Decoded boxes.\n        \"\"\"", "\n", "\n", "assert", "pred_bboxes", ".", "size", "(", "0", ")", "==", "bboxes", ".", "size", "(", "0", ")", "\n", "decoded_bboxes", "=", "delta2bbox", "(", "bboxes", ",", "pred_bboxes", ",", "self", ".", "means", ",", "self", ".", "stds", ",", "\n", "max_shape", ",", "wh_ratio_clip", ")", "\n", "\n", "return", "decoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.bbox2delta": [[74, 117], ["proposals.float.float", "gt.float.float", "torch.log", "torch.log", "torch.stack", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.sub_().div_", "proposals.float.size", "gt.float.size", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.sub_"], "function", ["None"], ["", "", "def", "bbox2delta", "(", "proposals", ",", "gt", ",", "means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ")", ":", "\n", "    ", "\"\"\"Compute deltas of proposals w.r.t. gt.\n\n    We usually compute the deltas of x, y, w, h of proposals w.r.t ground\n    truth bboxes to get regression target.\n    This is the inverse function of :func:`delta2bbox`.\n\n    Args:\n        proposals (Tensor): Boxes to be transformed, shape (N, ..., 4)\n        gt (Tensor): Gt bboxes to be used as base, shape (N, ..., 4)\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n\n    Returns:\n        Tensor: deltas with shape (N, 4), where columns represent dx, dy,\n            dw, dh.\n    \"\"\"", "\n", "assert", "proposals", ".", "size", "(", ")", "==", "gt", ".", "size", "(", ")", "\n", "\n", "proposals", "=", "proposals", ".", "float", "(", ")", "\n", "gt", "=", "gt", ".", "float", "(", ")", "\n", "px", "=", "(", "proposals", "[", "...", ",", "0", "]", "+", "proposals", "[", "...", ",", "2", "]", ")", "*", "0.5", "\n", "py", "=", "(", "proposals", "[", "...", ",", "1", "]", "+", "proposals", "[", "...", ",", "3", "]", ")", "*", "0.5", "\n", "pw", "=", "proposals", "[", "...", ",", "2", "]", "-", "proposals", "[", "...", ",", "0", "]", "\n", "ph", "=", "proposals", "[", "...", ",", "3", "]", "-", "proposals", "[", "...", ",", "1", "]", "\n", "\n", "gx", "=", "(", "gt", "[", "...", ",", "0", "]", "+", "gt", "[", "...", ",", "2", "]", ")", "*", "0.5", "\n", "gy", "=", "(", "gt", "[", "...", ",", "1", "]", "+", "gt", "[", "...", ",", "3", "]", ")", "*", "0.5", "\n", "gw", "=", "gt", "[", "...", ",", "2", "]", "-", "gt", "[", "...", ",", "0", "]", "\n", "gh", "=", "gt", "[", "...", ",", "3", "]", "-", "gt", "[", "...", ",", "1", "]", "\n", "\n", "dx", "=", "(", "gx", "-", "px", ")", "/", "pw", "\n", "dy", "=", "(", "gy", "-", "py", ")", "/", "ph", "\n", "dw", "=", "torch", ".", "log", "(", "gw", "/", "pw", ")", "\n", "dh", "=", "torch", ".", "log", "(", "gh", "/", "ph", ")", "\n", "deltas", "=", "torch", ".", "stack", "(", "[", "dx", ",", "dy", ",", "dw", ",", "dh", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "unsqueeze", "(", "0", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "unsqueeze", "(", "0", ")", "\n", "deltas", "=", "deltas", ".", "sub_", "(", "means", ")", ".", "div_", "(", "stds", ")", "\n", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.delta_xywh_bbox_coder.delta2bbox": [[119, 198], ["deltas.new_tensor().view().repeat", "deltas.new_tensor().view().repeat", "numpy.abs", "dw.clamp.clamp", "dh.clamp.clamp", "torch.stack().view", "numpy.log", "dw.clamp.exp", "dh.clamp.exp", "x1.clamp.clamp", "y1.clamp.clamp", "x2.clamp.clamp", "y2.clamp.clamp", "deltas.size", "deltas.new_tensor().view", "deltas.size", "deltas.new_tensor().view", "deltas.size", "torch.stack", "deltas.new_tensor", "deltas.new_tensor"], "function", ["None"], ["", "def", "delta2bbox", "(", "rois", ",", "\n", "deltas", ",", "\n", "means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "\n", "stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ",", "\n", "max_shape", "=", "None", ",", "\n", "wh_ratio_clip", "=", "16", "/", "1000", ")", ":", "\n", "    ", "\"\"\"Apply deltas to shift/scale base boxes.\n\n    Typically the rois are anchor or proposed bounding boxes and the deltas are\n    network outputs used to shift/scale those boxes.\n    This is the inverse function of :func:`bbox2delta`.\n\n    Args:\n        rois (Tensor): Boxes to be transformed. Has shape (N, 4)\n        deltas (Tensor): Encoded offsets with respect to each roi.\n            Has shape (N, 4 * num_classes). Note N = num_anchors * W * H when\n            rois is a grid of anchors. Offset encoding follows [1]_.\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n        max_shape (tuple[int, int]): Maximum bounds for boxes. specifies (H, W)\n        wh_ratio_clip (float): Maximum aspect ratio for boxes.\n\n    Returns:\n        Tensor: Boxes with shape (N, 4), where columns represent\n            tl_x, tl_y, br_x, br_y.\n\n    References:\n        .. [1] https://arxiv.org/abs/1311.2524\n\n    Example:\n        >>> rois = torch.Tensor([[ 0.,  0.,  1.,  1.],\n        >>>                      [ 0.,  0.,  1.,  1.],\n        >>>                      [ 0.,  0.,  1.,  1.],\n        >>>                      [ 5.,  5.,  5.,  5.]])\n        >>> deltas = torch.Tensor([[  0.,   0.,   0.,   0.],\n        >>>                        [  1.,   1.,   1.,   1.],\n        >>>                        [  0.,   0.,   2.,  -1.],\n        >>>                        [ 0.7, -1.9, -0.5,  0.3]])\n        >>> delta2bbox(rois, deltas, max_shape=(32, 32))\n        tensor([[0.0000, 0.0000, 1.0000, 1.0000],\n                [0.1409, 0.1409, 2.8591, 2.8591],\n                [0.0000, 0.3161, 4.1945, 0.6839],\n                [5.0000, 5.0000, 5.0000, 5.0000]])\n    \"\"\"", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "4", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "4", ")", "\n", "denorm_deltas", "=", "deltas", "*", "stds", "+", "means", "\n", "dx", "=", "denorm_deltas", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "dy", "=", "denorm_deltas", "[", ":", ",", "1", ":", ":", "4", "]", "\n", "dw", "=", "denorm_deltas", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "dh", "=", "denorm_deltas", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "max_ratio", "=", "np", ".", "abs", "(", "np", ".", "log", "(", "wh_ratio_clip", ")", ")", "\n", "dw", "=", "dw", ".", "clamp", "(", "min", "=", "-", "max_ratio", ",", "max", "=", "max_ratio", ")", "\n", "dh", "=", "dh", ".", "clamp", "(", "min", "=", "-", "max_ratio", ",", "max", "=", "max_ratio", ")", "\n", "# Compute center of each roi", "\n", "px", "=", "(", "(", "rois", "[", ":", ",", "0", "]", "+", "rois", "[", ":", ",", "2", "]", ")", "*", "0.5", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dx", ")", "\n", "py", "=", "(", "(", "rois", "[", ":", ",", "1", "]", "+", "rois", "[", ":", ",", "3", "]", ")", "*", "0.5", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dy", ")", "\n", "# Compute width/height of each roi", "\n", "pw", "=", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dw", ")", "\n", "ph", "=", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dh", ")", "\n", "# Use exp(network energy) to enlarge/shrink each roi", "\n", "gw", "=", "pw", "*", "dw", ".", "exp", "(", ")", "\n", "gh", "=", "ph", "*", "dh", ".", "exp", "(", ")", "\n", "# Use network energy to shift the center of each roi", "\n", "gx", "=", "px", "+", "pw", "*", "dx", "\n", "gy", "=", "py", "+", "ph", "*", "dy", "\n", "# Convert center-xy/width/height to top-left, bottom-right", "\n", "x1", "=", "gx", "-", "gw", "*", "0.5", "\n", "y1", "=", "gy", "-", "gh", "*", "0.5", "\n", "x2", "=", "gx", "+", "gw", "*", "0.5", "\n", "y2", "=", "gy", "+", "gh", "*", "0.5", "\n", "if", "max_shape", "is", "not", "None", ":", "\n", "        ", "x1", "=", "x1", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", ")", "\n", "y1", "=", "y1", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", ")", "\n", "x2", "=", "x2", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", ")", "\n", "y2", "=", "y2", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", ")", "\n", "", "bboxes", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "dim", "=", "-", "1", ")", ".", "view", "(", "deltas", ".", "size", "(", ")", ")", "\n", "return", "bboxes", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.__init__": [[32, 38], ["base_bbox_coder.BaseBBoxCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__"], ["def", "__init__", "(", "self", ",", "\n", "target_means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "\n", "target_stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ")", ":", "\n", "        ", "super", "(", "BaseBBoxCoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "means", "=", "target_means", "\n", "self", ".", "stds", "=", "target_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode": [[39, 56], ["legacy_delta_xywh_bbox_coder.legacy_bbox2delta", "bboxes.size", "gt_bboxes.size", "bboxes.size", "gt_bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.legacy_bbox2delta"], ["", "def", "encode", "(", "self", ",", "bboxes", ",", "gt_bboxes", ")", ":", "\n", "        ", "\"\"\"Get box regression transformation deltas that can be used to\n        transform the ``bboxes`` into the ``gt_bboxes``.\n\n        Args:\n            bboxes (torch.Tensor): source boxes, e.g., object proposals.\n            gt_bboxes (torch.Tensor): target of the transformation, e.g.,\n                ground-truth boxes.\n\n        Returns:\n            torch.Tensor: Box transformation deltas\n        \"\"\"", "\n", "assert", "bboxes", ".", "size", "(", "0", ")", "==", "gt_bboxes", ".", "size", "(", "0", ")", "\n", "assert", "bboxes", ".", "size", "(", "-", "1", ")", "==", "gt_bboxes", ".", "size", "(", "-", "1", ")", "==", "4", "\n", "encoded_bboxes", "=", "legacy_bbox2delta", "(", "bboxes", ",", "gt_bboxes", ",", "self", ".", "means", ",", "\n", "self", ".", "stds", ")", "\n", "return", "encoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode": [[57, 80], ["legacy_delta_xywh_bbox_coder.legacy_delta2bbox", "pred_bboxes.size", "bboxes.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.legacy_delta2bbox"], ["", "def", "decode", "(", "self", ",", "\n", "bboxes", ",", "\n", "pred_bboxes", ",", "\n", "max_shape", "=", "None", ",", "\n", "wh_ratio_clip", "=", "16", "/", "1000", ")", ":", "\n", "        ", "\"\"\"Apply transformation `pred_bboxes` to `boxes`.\n\n        Args:\n            boxes (torch.Tensor): Basic boxes.\n            pred_bboxes (torch.Tensor): Encoded boxes with shape\n            max_shape (tuple[int], optional): Maximum shape of boxes.\n                Defaults to None.\n            wh_ratio_clip (float, optional): The allowed ratio between\n                width and height.\n\n        Returns:\n            torch.Tensor: Decoded boxes.\n        \"\"\"", "\n", "assert", "pred_bboxes", ".", "size", "(", "0", ")", "==", "bboxes", ".", "size", "(", "0", ")", "\n", "decoded_bboxes", "=", "legacy_delta2bbox", "(", "bboxes", ",", "pred_bboxes", ",", "self", ".", "means", ",", "\n", "self", ".", "stds", ",", "max_shape", ",", "wh_ratio_clip", ")", "\n", "\n", "return", "decoded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.legacy_bbox2delta": [[82, 128], ["proposals.float.float", "gt.float.float", "torch.log", "torch.log", "torch.stack", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.sub_().div_", "proposals.float.size", "gt.float.size", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.sub_"], "function", ["None"], ["", "", "def", "legacy_bbox2delta", "(", "proposals", ",", "\n", "gt", ",", "\n", "means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "\n", "stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ")", ":", "\n", "    ", "\"\"\"Compute deltas of proposals w.r.t. gt in the MMDet V1.x manner.\n\n    We usually compute the deltas of x, y, w, h of proposals w.r.t ground\n    truth bboxes to get regression target.\n    This is the inverse function of `delta2bbox()`\n\n    Args:\n        proposals (Tensor): Boxes to be transformed, shape (N, ..., 4)\n        gt (Tensor): Gt bboxes to be used as base, shape (N, ..., 4)\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n\n    Returns:\n        Tensor: deltas with shape (N, 4), where columns represent dx, dy,\n            dw, dh.\n    \"\"\"", "\n", "assert", "proposals", ".", "size", "(", ")", "==", "gt", ".", "size", "(", ")", "\n", "\n", "proposals", "=", "proposals", ".", "float", "(", ")", "\n", "gt", "=", "gt", ".", "float", "(", ")", "\n", "px", "=", "(", "proposals", "[", "...", ",", "0", "]", "+", "proposals", "[", "...", ",", "2", "]", ")", "*", "0.5", "\n", "py", "=", "(", "proposals", "[", "...", ",", "1", "]", "+", "proposals", "[", "...", ",", "3", "]", ")", "*", "0.5", "\n", "pw", "=", "proposals", "[", "...", ",", "2", "]", "-", "proposals", "[", "...", ",", "0", "]", "+", "1.0", "\n", "ph", "=", "proposals", "[", "...", ",", "3", "]", "-", "proposals", "[", "...", ",", "1", "]", "+", "1.0", "\n", "\n", "gx", "=", "(", "gt", "[", "...", ",", "0", "]", "+", "gt", "[", "...", ",", "2", "]", ")", "*", "0.5", "\n", "gy", "=", "(", "gt", "[", "...", ",", "1", "]", "+", "gt", "[", "...", ",", "3", "]", ")", "*", "0.5", "\n", "gw", "=", "gt", "[", "...", ",", "2", "]", "-", "gt", "[", "...", ",", "0", "]", "+", "1.0", "\n", "gh", "=", "gt", "[", "...", ",", "3", "]", "-", "gt", "[", "...", ",", "1", "]", "+", "1.0", "\n", "\n", "dx", "=", "(", "gx", "-", "px", ")", "/", "pw", "\n", "dy", "=", "(", "gy", "-", "py", ")", "/", "ph", "\n", "dw", "=", "torch", ".", "log", "(", "gw", "/", "pw", ")", "\n", "dh", "=", "torch", ".", "log", "(", "gh", "/", "ph", ")", "\n", "deltas", "=", "torch", ".", "stack", "(", "[", "dx", ",", "dy", ",", "dw", ",", "dh", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "unsqueeze", "(", "0", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "unsqueeze", "(", "0", ")", "\n", "deltas", "=", "deltas", ".", "sub_", "(", "means", ")", ".", "div_", "(", "stds", ")", "\n", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.legacy_delta2bbox": [[130, 213], ["deltas.new_tensor().repeat", "deltas.new_tensor().repeat", "numpy.abs", "dw.clamp.clamp", "dh.clamp.clamp", "torch.stack().view_as", "numpy.log", "dw.clamp.exp", "dh.clamp.exp", "x1.clamp.clamp", "y1.clamp.clamp", "x2.clamp.clamp", "y2.clamp.clamp", "deltas.new_tensor", "deltas.size", "deltas.new_tensor", "deltas.size", "torch.stack"], "function", ["None"], ["", "def", "legacy_delta2bbox", "(", "rois", ",", "\n", "deltas", ",", "\n", "means", "=", "(", "0.", ",", "0.", ",", "0.", ",", "0.", ")", ",", "\n", "stds", "=", "(", "1.", ",", "1.", ",", "1.", ",", "1.", ")", ",", "\n", "max_shape", "=", "None", ",", "\n", "wh_ratio_clip", "=", "16", "/", "1000", ")", ":", "\n", "    ", "\"\"\"Apply deltas to shift/scale base boxes in the MMDet V1.x manner.\n\n    Typically the rois are anchor or proposed bounding boxes and the deltas are\n    network outputs used to shift/scale those boxes.\n    This is the inverse function of `bbox2delta()`\n\n    Args:\n        rois (Tensor): Boxes to be transformed. Has shape (N, 4)\n        deltas (Tensor): Encoded offsets with respect to each roi.\n            Has shape (N, 4 * num_classes). Note N = num_anchors * W * H when\n            rois is a grid of anchors. Offset encoding follows [1]_.\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n        max_shape (tuple[int, int]): Maximum bounds for boxes. specifies (H, W)\n        wh_ratio_clip (float): Maximum aspect ratio for boxes.\n\n    Returns:\n        Tensor: Boxes with shape (N, 4), where columns represent\n            tl_x, tl_y, br_x, br_y.\n\n    References:\n        .. [1] https://arxiv.org/abs/1311.2524\n\n    Example:\n        >>> rois = torch.Tensor([[ 0.,  0.,  1.,  1.],\n        >>>                      [ 0.,  0.,  1.,  1.],\n        >>>                      [ 0.,  0.,  1.,  1.],\n        >>>                      [ 5.,  5.,  5.,  5.]])\n        >>> deltas = torch.Tensor([[  0.,   0.,   0.,   0.],\n        >>>                        [  1.,   1.,   1.,   1.],\n        >>>                        [  0.,   0.,   2.,  -1.],\n        >>>                        [ 0.7, -1.9, -0.5,  0.3]])\n        >>> legacy_delta2bbox(rois, deltas, max_shape=(32, 32))\n        tensor([[0.0000, 0.0000, 1.5000, 1.5000],\n                [0.0000, 0.0000, 5.2183, 5.2183],\n                [0.0000, 0.1321, 7.8891, 0.8679],\n                [5.3967, 2.4251, 6.0033, 3.7749]])\n    \"\"\"", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "4", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "4", ")", "\n", "denorm_deltas", "=", "deltas", "*", "stds", "+", "means", "\n", "dx", "=", "denorm_deltas", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "dy", "=", "denorm_deltas", "[", ":", ",", "1", ":", ":", "4", "]", "\n", "dw", "=", "denorm_deltas", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "dh", "=", "denorm_deltas", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "max_ratio", "=", "np", ".", "abs", "(", "np", ".", "log", "(", "wh_ratio_clip", ")", ")", "\n", "dw", "=", "dw", ".", "clamp", "(", "min", "=", "-", "max_ratio", ",", "max", "=", "max_ratio", ")", "\n", "dh", "=", "dh", ".", "clamp", "(", "min", "=", "-", "max_ratio", ",", "max", "=", "max_ratio", ")", "\n", "# Compute center of each roi", "\n", "px", "=", "(", "(", "rois", "[", ":", ",", "0", "]", "+", "rois", "[", ":", ",", "2", "]", ")", "*", "0.5", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dx", ")", "\n", "py", "=", "(", "(", "rois", "[", ":", ",", "1", "]", "+", "rois", "[", ":", ",", "3", "]", ")", "*", "0.5", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dy", ")", "\n", "# Compute width/height of each roi", "\n", "pw", "=", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", "+", "1.0", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dw", ")", "\n", "ph", "=", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", "+", "1.0", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "dh", ")", "\n", "# Use exp(network energy) to enlarge/shrink each roi", "\n", "gw", "=", "pw", "*", "dw", ".", "exp", "(", ")", "\n", "gh", "=", "ph", "*", "dh", ".", "exp", "(", ")", "\n", "# Use network energy to shift the center of each roi", "\n", "gx", "=", "px", "+", "pw", "*", "dx", "\n", "gy", "=", "py", "+", "ph", "*", "dy", "\n", "# Convert center-xy/width/height to top-left, bottom-right", "\n", "\n", "# The true legacy box coder should +- 0.5 here.", "\n", "# However, current implementation improves the performance when testing", "\n", "# the models trained in MMDetection 1.X (~0.5 bbox AP, 0.2 mask AP)", "\n", "x1", "=", "gx", "-", "gw", "*", "0.5", "\n", "y1", "=", "gy", "-", "gh", "*", "0.5", "\n", "x2", "=", "gx", "+", "gw", "*", "0.5", "\n", "y2", "=", "gy", "+", "gh", "*", "0.5", "\n", "if", "max_shape", "is", "not", "None", ":", "\n", "        ", "x1", "=", "x1", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", "-", "1", ")", "\n", "y1", "=", "y1", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", "-", "1", ")", "\n", "x2", "=", "x2", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "1", "]", "-", "1", ")", "\n", "y2", "=", "y2", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_shape", "[", "0", "]", "-", "1", ")", "\n", "", "bboxes", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "dim", "=", "-", "1", ")", ".", "view_as", "(", "deltas", ")", "\n", "return", "bboxes", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.BboxOverlaps2D.__call__": [[10, 32], ["iou2d_calculator.bbox_overlaps", "bboxes1.size", "bboxes2.size", "bboxes2.size", "bboxes1.size"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps"], ["def", "__call__", "(", "self", ",", "bboxes1", ",", "bboxes2", ",", "mode", "=", "'iou'", ",", "is_aligned", "=", "False", ")", ":", "\n", "        ", "\"\"\"Calculate IoU between 2D bboxes.\n\n        Args:\n            bboxes1 (Tensor): bboxes have shape (m, 4) in <x1, y1, x2, y2>\n                format, or shape (m, 5) in <x1, y1, x2, y2, score> format.\n            bboxes2 (Tensor): bboxes have shape (m, 4) in <x1, y1, x2, y2>\n                format, shape (m, 5) in <x1, y1, x2, y2, score> format, or be\n                empty. If is_aligned is ``True``, then m and n must be equal.\n            mode (str): \"iou\" (intersection over union) or iof (intersection\n                over foreground).\n\n        Returns:\n            ious(Tensor): shape (m, n) if is_aligned == False else shape (m, 1)\n        \"\"\"", "\n", "assert", "bboxes1", ".", "size", "(", "-", "1", ")", "in", "[", "0", ",", "4", ",", "5", "]", "\n", "assert", "bboxes2", ".", "size", "(", "-", "1", ")", "in", "[", "0", ",", "4", ",", "5", "]", "\n", "if", "bboxes2", ".", "size", "(", "-", "1", ")", "==", "5", ":", "\n", "            ", "bboxes2", "=", "bboxes2", "[", "...", ",", ":", "4", "]", "\n", "", "if", "bboxes1", ".", "size", "(", "-", "1", ")", "==", "5", ":", "\n", "            ", "bboxes1", "=", "bboxes1", "[", "...", ",", ":", "4", "]", "\n", "", "return", "bbox_overlaps", "(", "bboxes1", ",", "bboxes2", ",", "mode", ",", "is_aligned", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.BboxOverlaps2D.__repr__": [[33, 37], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a string describing the module\"\"\"", "\n", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "+", "'()'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.iou2d_calculator.bbox_overlaps": [[39, 131], ["bboxes1.size", "bboxes2.size", "torch.max.new_tensor", "torch.max", "torch.max", "torch.min", "torch.max", "torch.min", "bboxes1.size", "bboxes1.size", "bboxes2.size", "bboxes2.size", "bboxes1.new", "bboxes1.new"], "function", ["None"], ["", "", "def", "bbox_overlaps", "(", "bboxes1", ",", "bboxes2", ",", "mode", "=", "'iou'", ",", "is_aligned", "=", "False", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"Calculate overlap between two set of bboxes.\n\n    If ``is_aligned`` is ``False``, then calculate the ious between each bbox\n    of bboxes1 and bboxes2, otherwise the ious between each aligned pair of\n    bboxes1 and bboxes2.\n\n    Args:\n        bboxes1 (Tensor): shape (m, 4) in <x1, y1, x2, y2> format or empty.\n        bboxes2 (Tensor): shape (n, 4) in <x1, y1, x2, y2> format or empty.\n            If is_aligned is ``True``, then m and n must be equal.\n        mode (str): \"iou\" (intersection over union) or iof (intersection over\n            foreground).\n\n    Returns:\n        ious(Tensor): shape (m, n) if is_aligned == False else shape (m, 1)\n\n    Example:\n        >>> bboxes1 = torch.FloatTensor([\n        >>>     [0, 0, 10, 10],\n        >>>     [10, 10, 20, 20],\n        >>>     [32, 32, 38, 42],\n        >>> ])\n        >>> bboxes2 = torch.FloatTensor([\n        >>>     [0, 0, 10, 20],\n        >>>     [0, 10, 10, 19],\n        >>>     [10, 10, 20, 20],\n        >>> ])\n        >>> bbox_overlaps(bboxes1, bboxes2)\n        tensor([[0.5000, 0.0000, 0.0000],\n                [0.0000, 0.0000, 1.0000],\n                [0.0000, 0.0000, 0.0000]])\n\n    Example:\n        >>> empty = torch.FloatTensor([])\n        >>> nonempty = torch.FloatTensor([\n        >>>     [0, 0, 10, 9],\n        >>> ])\n        >>> assert tuple(bbox_overlaps(empty, nonempty).shape) == (0, 1)\n        >>> assert tuple(bbox_overlaps(nonempty, empty).shape) == (1, 0)\n        >>> assert tuple(bbox_overlaps(empty, empty).shape) == (0, 0)\n    \"\"\"", "\n", "\n", "assert", "mode", "in", "[", "'iou'", ",", "'iof'", "]", "\n", "# Either the boxes are empty or the length of boxes's last dimenstion is 4", "\n", "assert", "(", "bboxes1", ".", "size", "(", "-", "1", ")", "==", "4", "or", "bboxes1", ".", "size", "(", "0", ")", "==", "0", ")", "\n", "assert", "(", "bboxes2", ".", "size", "(", "-", "1", ")", "==", "4", "or", "bboxes2", ".", "size", "(", "0", ")", "==", "0", ")", "\n", "\n", "rows", "=", "bboxes1", ".", "size", "(", "0", ")", "\n", "cols", "=", "bboxes2", ".", "size", "(", "0", ")", "\n", "if", "is_aligned", ":", "\n", "        ", "assert", "rows", "==", "cols", "\n", "\n", "", "if", "rows", "*", "cols", "==", "0", ":", "\n", "        ", "return", "bboxes1", ".", "new", "(", "rows", ",", "1", ")", "if", "is_aligned", "else", "bboxes1", ".", "new", "(", "rows", ",", "cols", ")", "\n", "\n", "", "if", "is_aligned", ":", "\n", "        ", "lt", "=", "torch", ".", "max", "(", "bboxes1", "[", ":", ",", ":", "2", "]", ",", "bboxes2", "[", ":", ",", ":", "2", "]", ")", "# [rows, 2]", "\n", "rb", "=", "torch", ".", "min", "(", "bboxes1", "[", ":", ",", "2", ":", "]", ",", "bboxes2", "[", ":", ",", "2", ":", "]", ")", "# [rows, 2]", "\n", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "# [rows, 2]", "\n", "overlap", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "\n", "area1", "=", "(", "bboxes1", "[", ":", ",", "2", "]", "-", "bboxes1", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "bboxes1", "[", ":", ",", "3", "]", "-", "bboxes1", "[", ":", ",", "1", "]", ")", "\n", "\n", "if", "mode", "==", "'iou'", ":", "\n", "            ", "area2", "=", "(", "bboxes2", "[", ":", ",", "2", "]", "-", "bboxes2", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "bboxes2", "[", ":", ",", "3", "]", "-", "bboxes2", "[", ":", ",", "1", "]", ")", "\n", "union", "=", "area1", "+", "area2", "-", "overlap", "\n", "", "else", ":", "\n", "            ", "union", "=", "area1", "\n", "", "", "else", ":", "\n", "        ", "lt", "=", "torch", ".", "max", "(", "bboxes1", "[", ":", ",", "None", ",", ":", "2", "]", ",", "bboxes2", "[", ":", ",", ":", "2", "]", ")", "# [rows, cols, 2]", "\n", "rb", "=", "torch", ".", "min", "(", "bboxes1", "[", ":", ",", "None", ",", "2", ":", "]", ",", "bboxes2", "[", ":", ",", "2", ":", "]", ")", "# [rows, cols, 2]", "\n", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "# [rows, cols, 2]", "\n", "overlap", "=", "wh", "[", ":", ",", ":", ",", "0", "]", "*", "wh", "[", ":", ",", ":", ",", "1", "]", "\n", "area1", "=", "(", "bboxes1", "[", ":", ",", "2", "]", "-", "bboxes1", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "bboxes1", "[", ":", ",", "3", "]", "-", "bboxes1", "[", ":", ",", "1", "]", ")", "\n", "\n", "if", "mode", "==", "'iou'", ":", "\n", "            ", "area2", "=", "(", "bboxes2", "[", ":", ",", "2", "]", "-", "bboxes2", "[", ":", ",", "0", "]", ")", "*", "(", "\n", "bboxes2", "[", ":", ",", "3", "]", "-", "bboxes2", "[", ":", ",", "1", "]", ")", "\n", "union", "=", "area1", "[", ":", ",", "None", "]", "+", "area2", "-", "overlap", "\n", "", "else", ":", "\n", "            ", "union", "=", "area1", "[", ":", ",", "None", "]", "\n", "\n", "", "", "eps", "=", "union", ".", "new_tensor", "(", "[", "eps", "]", ")", "\n", "union", "=", "torch", ".", "max", "(", "union", ",", "eps", ")", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "return", "ious", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.iou_calculators.builder.build_iou_calculator": [[6, 9], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["import", "numpy", "as", "np", "\n", "from", "mmcv", ".", "parallel", "import", "collate", "\n", "from", "mmcv", ".", "runner", "import", "get_dist_info", "\n", "from", "mmcv", ".", "utils", "import", "Registry", ",", "build_from_cfg", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.demo.webcam_demo.parse_args": [[9, 21], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'MMDetection webcam demo'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "type", "=", "str", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'CPU/CUDA device option'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--camera-id'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'camera device id'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--score-thr'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'bbox score threshold'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.demo.webcam_demo.main": [[23, 43], ["webcam_demo.parse_args", "torch.device", "mmdet.apis.init_detector", "cv2.VideoCapture", "print", "cv2.VideoCapture.read", "mmdet.apis.inference_detector", "cv2.waitKey", "mmdet.apis.init_detector.show_result", "ord", "ord"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.init_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.inference_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "args", ".", "device", ")", "\n", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "device", ")", "\n", "\n", "camera", "=", "cv2", ".", "VideoCapture", "(", "args", ".", "camera_id", ")", "\n", "\n", "print", "(", "'Press \"Esc\", \"q\" or \"Q\" to exit.'", ")", "\n", "while", "True", ":", "\n", "        ", "ret_val", ",", "img", "=", "camera", ".", "read", "(", ")", "\n", "result", "=", "inference_detector", "(", "model", ",", "img", ")", "\n", "\n", "ch", "=", "cv2", ".", "waitKey", "(", "1", ")", "\n", "if", "ch", "==", "27", "or", "ch", "==", "ord", "(", "'q'", ")", "or", "ch", "==", "ord", "(", "'Q'", ")", ":", "\n", "            ", "break", "\n", "\n", "", "model", ".", "show_result", "(", "\n", "img", ",", "result", ",", "score_thr", "=", "args", ".", "score_thr", ",", "wait_time", "=", "1", ",", "show", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.demo.image_demo.main": [[6, 23], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mmdet.apis.init_detector", "mmdet.apis.inference_detector", "mmdet.apis.show_result_pyplot"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.init_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.inference_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.show_result_pyplot"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'img'", ",", "help", "=", "'Image file'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Config file'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'Checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--score-thr'", ",", "type", "=", "float", ",", "default", "=", "0.3", ",", "help", "=", "'bbox score threshold'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# build the model from a config file and a checkpoint file", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "args", ".", "device", ")", "\n", "# test a single image", "\n", "result", "=", "inference_detector", "(", "model", ",", "args", ".", "img", ")", "\n", "# show the results", "\n", "show_result_pyplot", "(", "model", ",", "args", ".", "img", ",", "result", ",", "score_thr", "=", "args", ".", "score_thr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.pytorch2onnx.pytorch2onnx": [[20, 88], ["model.cpu().eval", "mmcv.imread", "mmcv.imresize().transpose", "torch.from_numpy().unsqueeze().float", "functools.partial", "register_extra_symbolics", "torch.onnx.export", "print", "mmcv.imnormalize", "onnx.load", "onnx.checker.check_model", "model", "list", "onnxruntime.InferenceSession", "rt.InferenceSession.run", "bbox2result", "numpy.allclose", "print", "model.cpu", "mmcv.imresize", "torch.from_numpy().unsqueeze", "len", "set", "set", "mmcv.imnormalize.detach().numpy", "torch.from_numpy", "mmcv.imnormalize.detach"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2result"], ["", "def", "pytorch2onnx", "(", "model", ",", "\n", "input_img", ",", "\n", "input_shape", ",", "\n", "opset_version", "=", "11", ",", "\n", "show", "=", "False", ",", "\n", "output_file", "=", "'tmp.onnx'", ",", "\n", "verify", "=", "False", ",", "\n", "normalize_cfg", "=", "None", ")", ":", "\n", "    ", "model", ".", "cpu", "(", ")", ".", "eval", "(", ")", "\n", "# read image", "\n", "one_img", "=", "mmcv", ".", "imread", "(", "input_img", ")", "\n", "if", "normalize_cfg", ":", "\n", "        ", "one_img", "=", "mmcv", ".", "imnormalize", "(", "one_img", ",", "normalize_cfg", "[", "'mean'", "]", ",", "\n", "normalize_cfg", "[", "'std'", "]", ")", "\n", "", "one_img", "=", "mmcv", ".", "imresize", "(", "one_img", ",", "input_shape", "[", "2", ":", "]", ")", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "one_img", "=", "torch", ".", "from_numpy", "(", "one_img", ")", ".", "unsqueeze", "(", "0", ")", ".", "float", "(", ")", "\n", "(", "_", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "one_meta", "=", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'pad_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'scale_factor'", ":", "1.0", ",", "\n", "'flip'", ":", "False", "\n", "}", "\n", "# onnx.export does not support kwargs", "\n", "origin_forward", "=", "model", ".", "forward", "\n", "model", ".", "forward", "=", "partial", "(", "\n", "model", ".", "forward", ",", "img_metas", "=", "[", "[", "one_meta", "]", "]", ",", "return_loss", "=", "False", ")", "\n", "# pytorch has some bug in pytorch1.3, we have to fix it", "\n", "# by replacing these existing op", "\n", "register_extra_symbolics", "(", "opset_version", ")", "\n", "torch", ".", "onnx", ".", "export", "(", "\n", "model", ",", "(", "[", "one_img", "]", ")", ",", "\n", "output_file", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "True", ",", "\n", "verbose", "=", "show", ",", "\n", "opset_version", "=", "opset_version", ")", "\n", "model", ".", "forward", "=", "origin_forward", "\n", "print", "(", "f'Successfully exported ONNX model: {output_file}'", ")", "\n", "if", "verify", ":", "\n", "# check by onnx", "\n", "        ", "onnx_model", "=", "onnx", ".", "load", "(", "output_file", ")", "\n", "onnx", ".", "checker", ".", "check_model", "(", "onnx_model", ")", "\n", "\n", "# check the numerical value", "\n", "# get pytorch output", "\n", "pytorch_result", "=", "model", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "return_loss", "=", "False", ")", "\n", "\n", "# get onnx output", "\n", "input_all", "=", "[", "node", ".", "name", "for", "node", "in", "onnx_model", ".", "graph", ".", "input", "]", "\n", "input_initializer", "=", "[", "\n", "node", ".", "name", "for", "node", "in", "onnx_model", ".", "graph", ".", "initializer", "\n", "]", "\n", "net_feed_input", "=", "list", "(", "set", "(", "input_all", ")", "-", "set", "(", "input_initializer", ")", ")", "\n", "assert", "(", "len", "(", "net_feed_input", ")", "==", "1", ")", "\n", "sess", "=", "rt", ".", "InferenceSession", "(", "output_file", ")", "\n", "from", "mmdet", ".", "core", "import", "bbox2result", "\n", "det_bboxes", ",", "det_labels", "=", "sess", ".", "run", "(", "\n", "None", ",", "{", "net_feed_input", "[", "0", "]", ":", "one_img", ".", "detach", "(", ")", ".", "numpy", "(", ")", "}", ")", "\n", "# only compare a part of result", "\n", "bbox_results", "=", "bbox2result", "(", "det_bboxes", ",", "det_labels", ",", "1", ")", "\n", "onnx_results", "=", "bbox_results", "[", "0", "]", "\n", "assert", "np", ".", "allclose", "(", "\n", "pytorch_result", "[", "0", "]", "[", ":", ",", "4", "]", ",", "onnx_results", "[", ":", ",", "4", "]", "\n", ")", ",", "'The outputs are different between Pytorch and ONNX'", "\n", "print", "(", "'The numerical values are same between Pytorch and ONNX'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.pytorch2onnx.parse_args": [[90, 123], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert MMDetection models to ONNX'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'--input-img'", ",", "type", "=", "str", ",", "help", "=", "'Images for input'", ")", "\n", "parser", ".", "add_argument", "(", "'--show'", ",", "action", "=", "'store_true'", ",", "help", "=", "'show onnx graph'", ")", "\n", "parser", ".", "add_argument", "(", "'--output-file'", ",", "type", "=", "str", ",", "default", "=", "'tmp.onnx'", ")", "\n", "parser", ".", "add_argument", "(", "'--opset-version'", ",", "type", "=", "int", ",", "default", "=", "11", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--verify'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'verify the onnx model output against pytorch output'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--shape'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "800", ",", "1216", "]", ",", "\n", "help", "=", "'input image size'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--mean'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "help", "=", "'mean value used for preprocess input data'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--std'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "help", "=", "'variance value used for preprocess input data'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.publish_model.parse_args": [[7, 14], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Process a checkpoint to be published'", ")", "\n", "parser", ".", "add_argument", "(", "'in_file'", ",", "help", "=", "'input checkpoint filename'", ")", "\n", "parser", ".", "add_argument", "(", "'out_file'", ",", "help", "=", "'output checkpoint filename'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.publish_model.process_checkpoint": [[16, 31], ["torch.load", "torch.save", "subprocess.check_output().decode", "out_file.endswith", "subprocess.Popen", "subprocess.check_output"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode"], ["", "def", "process_checkpoint", "(", "in_file", ",", "out_file", ")", ":", "\n", "    ", "checkpoint", "=", "torch", ".", "load", "(", "in_file", ",", "map_location", "=", "'cpu'", ")", "\n", "# remove optimizer for smaller file size", "\n", "if", "'optimizer'", "in", "checkpoint", ":", "\n", "        ", "del", "checkpoint", "[", "'optimizer'", "]", "\n", "# if it is necessary to remove some sensitive data in checkpoint['meta'],", "\n", "# add the code here.", "\n", "", "torch", ".", "save", "(", "checkpoint", ",", "out_file", ")", "\n", "sha", "=", "subprocess", ".", "check_output", "(", "[", "'sha256sum'", ",", "out_file", "]", ")", ".", "decode", "(", ")", "\n", "if", "out_file", ".", "endswith", "(", "'.pth'", ")", ":", "\n", "        ", "out_file_name", "=", "out_file", "[", ":", "-", "4", "]", "\n", "", "else", ":", "\n", "        ", "out_file_name", "=", "out_file", "\n", "", "final_file", "=", "out_file_name", "+", "f'-{sha[:8]}.pth'", "\n", "subprocess", ".", "Popen", "(", "[", "'mv'", ",", "out_file", ",", "final_file", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.publish_model.main": [[33, 36], ["publish_model.parse_args", "publish_model.process_checkpoint"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.publish_model.process_checkpoint"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "process_checkpoint", "(", "args", ".", "in_file", ",", "args", ".", "out_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.makeplot": [[12, 50], ["numpy.vstack", "range", "len", "ps_curve.insert", "matplotlib.figure", "matplotlib.subplot", "range", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.title", "matplotlib.legend", "plt.figure.savefig", "matplotlib.close", "numpy.ones", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "ps_.mean", "numpy.zeros", "len", "plt.subplot.plot", "plt.subplot.fill_between", "ps_.mean", "str"], "function", ["None"], ["def", "makeplot", "(", "rs", ",", "ps", ",", "outDir", ",", "class_name", ",", "iou_type", ")", ":", "\n", "    ", "cs", "=", "np", ".", "vstack", "(", "[", "\n", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ",", "\n", "np", ".", "array", "(", "[", ".31", ",", ".51", ",", ".74", "]", ")", ",", "\n", "np", ".", "array", "(", "[", ".75", ",", ".31", ",", ".30", "]", ")", ",", "\n", "np", ".", "array", "(", "[", ".36", ",", ".90", ",", ".38", "]", ")", ",", "\n", "np", ".", "array", "(", "[", ".50", ",", ".39", ",", ".64", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "1", ",", ".6", ",", "0", "]", ")", "\n", "]", ")", "\n", "areaNames", "=", "[", "'allarea'", ",", "'small'", ",", "'medium'", ",", "'large'", "]", "\n", "types", "=", "[", "'C75'", ",", "'C50'", ",", "'Loc'", ",", "'Sim'", ",", "'Oth'", ",", "'BG'", ",", "'FN'", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "areaNames", ")", ")", ":", "\n", "        ", "area_ps", "=", "ps", "[", "...", ",", "i", ",", "0", "]", "\n", "figure_tile", "=", "iou_type", "+", "'-'", "+", "class_name", "+", "'-'", "+", "areaNames", "[", "i", "]", "\n", "aps", "=", "[", "ps_", ".", "mean", "(", ")", "for", "ps_", "in", "area_ps", "]", "\n", "ps_curve", "=", "[", "\n", "ps_", ".", "mean", "(", "axis", "=", "1", ")", "if", "ps_", ".", "ndim", ">", "1", "else", "ps_", "for", "ps_", "in", "area_ps", "\n", "]", "\n", "ps_curve", ".", "insert", "(", "0", ",", "np", ".", "zeros", "(", "ps_curve", "[", "0", "]", ".", "shape", ")", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "for", "k", "in", "range", "(", "len", "(", "types", ")", ")", ":", "\n", "            ", "ax", ".", "plot", "(", "rs", ",", "ps_curve", "[", "k", "+", "1", "]", ",", "color", "=", "[", "0", ",", "0", ",", "0", "]", ",", "linewidth", "=", "0.5", ")", "\n", "ax", ".", "fill_between", "(", "\n", "rs", ",", "\n", "ps_curve", "[", "k", "]", ",", "\n", "ps_curve", "[", "k", "+", "1", "]", ",", "\n", "color", "=", "cs", "[", "k", "]", ",", "\n", "label", "=", "str", "(", "f'[{aps[k]:.3f}]'", "+", "types", "[", "k", "]", ")", ")", "\n", "", "plt", ".", "xlabel", "(", "'recall'", ")", "\n", "plt", ".", "ylabel", "(", "'precision'", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "1.", ")", "\n", "plt", ".", "ylim", "(", "0", ",", "1.", ")", "\n", "plt", ".", "title", "(", "figure_tile", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "# plt.show()", "\n", "fig", ".", "savefig", "(", "outDir", "+", "f'/{figure_tile}.png'", ")", "\n", "plt", ".", "close", "(", "fig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.analyze_individual_category": [[52, 101], ["print", "copy.deepcopy", "cocoGt.getImgIds", "copy.deepcopy.createIndex", "copy.deepcopy", "copy.deepcopy.getCatIds", "enumerate", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "copy.deepcopy", "enumerate", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "cocoGt.loadCats", "cocoGt.loadCats", "copy.deepcopy", "copy.deepcopy", "select_dt_anns.append"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["", "", "def", "analyze_individual_category", "(", "k", ",", "cocoDt", ",", "cocoGt", ",", "catId", ",", "iou_type", ")", ":", "\n", "    ", "nm", "=", "cocoGt", ".", "loadCats", "(", "catId", ")", "[", "0", "]", "\n", "print", "(", "f'--------------analyzing {k + 1}-{nm[\"name\"]}---------------'", ")", "\n", "ps_", "=", "{", "}", "\n", "dt", "=", "copy", ".", "deepcopy", "(", "cocoDt", ")", "\n", "nm", "=", "cocoGt", ".", "loadCats", "(", "catId", ")", "[", "0", "]", "\n", "imgIds", "=", "cocoGt", ".", "getImgIds", "(", ")", "\n", "dt_anns", "=", "dt", ".", "dataset", "[", "'annotations'", "]", "\n", "select_dt_anns", "=", "[", "]", "\n", "for", "ann", "in", "dt_anns", ":", "\n", "        ", "if", "ann", "[", "'category_id'", "]", "==", "catId", ":", "\n", "            ", "select_dt_anns", ".", "append", "(", "ann", ")", "\n", "", "", "dt", ".", "dataset", "[", "'annotations'", "]", "=", "select_dt_anns", "\n", "dt", ".", "createIndex", "(", ")", "\n", "# compute precision but ignore superclass confusion", "\n", "gt", "=", "copy", ".", "deepcopy", "(", "cocoGt", ")", "\n", "child_catIds", "=", "gt", ".", "getCatIds", "(", "supNms", "=", "[", "nm", "[", "'supercategory'", "]", "]", ")", "\n", "for", "idx", ",", "ann", "in", "enumerate", "(", "gt", ".", "dataset", "[", "'annotations'", "]", ")", ":", "\n", "        ", "if", "(", "ann", "[", "'category_id'", "]", "in", "child_catIds", "\n", "and", "ann", "[", "'category_id'", "]", "!=", "catId", ")", ":", "\n", "            ", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'ignore'", "]", "=", "1", "\n", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'iscrowd'", "]", "=", "1", "\n", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'category_id'", "]", "=", "catId", "\n", "", "", "cocoEval", "=", "COCOeval", "(", "gt", ",", "copy", ".", "deepcopy", "(", "dt", ")", ",", "iou_type", ")", "\n", "cocoEval", ".", "params", ".", "imgIds", "=", "imgIds", "\n", "cocoEval", ".", "params", ".", "maxDets", "=", "[", "100", "]", "\n", "cocoEval", ".", "params", ".", "iouThrs", "=", "[", ".1", "]", "\n", "cocoEval", ".", "params", ".", "useCats", "=", "1", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "ps_supercategory", "=", "cocoEval", ".", "eval", "[", "'precision'", "]", "[", "0", ",", ":", ",", "k", ",", ":", ",", ":", "]", "\n", "ps_", "[", "'ps_supercategory'", "]", "=", "ps_supercategory", "\n", "# compute precision but ignore any class confusion", "\n", "gt", "=", "copy", ".", "deepcopy", "(", "cocoGt", ")", "\n", "for", "idx", ",", "ann", "in", "enumerate", "(", "gt", ".", "dataset", "[", "'annotations'", "]", ")", ":", "\n", "        ", "if", "ann", "[", "'category_id'", "]", "!=", "catId", ":", "\n", "            ", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'ignore'", "]", "=", "1", "\n", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'iscrowd'", "]", "=", "1", "\n", "gt", ".", "dataset", "[", "'annotations'", "]", "[", "idx", "]", "[", "'category_id'", "]", "=", "catId", "\n", "", "", "cocoEval", "=", "COCOeval", "(", "gt", ",", "copy", ".", "deepcopy", "(", "dt", ")", ",", "iou_type", ")", "\n", "cocoEval", ".", "params", ".", "imgIds", "=", "imgIds", "\n", "cocoEval", ".", "params", ".", "maxDets", "=", "[", "100", "]", "\n", "cocoEval", ".", "params", ".", "iouThrs", "=", "[", ".1", "]", "\n", "cocoEval", ".", "params", ".", "useCats", "=", "1", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "ps_allcategory", "=", "cocoEval", ".", "eval", "[", "'precision'", "]", "[", "0", ",", ":", ",", "k", ",", ":", ",", ":", "]", "\n", "ps_", "[", "'ps_allcategory'", "]", "=", "ps_allcategory", "\n", "return", "k", ",", "ps_", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.analyze_results": [[103, 154], ["os.path.dirname", "pycocotools.coco.COCO", "pycocotools.coco.COCO.loadRes", "pycocotools.coco.COCO.getImgIds", "os.path.exists", "print", "os.makedirs", "os.path.dirname", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "numpy.vstack", "pycocotools.coco.COCO.getCatIds", "enumerate", "coco_error_analysis.makeplot", "os.path.exists", "print", "os.makedirs", "copy.deepcopy", "copy.deepcopy", "multiprocessing.Pool", "pool.starmap", "print", "coco_error_analysis.makeplot", "numpy.zeros", "pycocotools.coco.COCO.loadCats", "enumerate"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.makeplot", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.makeplot"], ["", "def", "analyze_results", "(", "res_file", ",", "ann_file", ",", "res_types", ",", "out_dir", ")", ":", "\n", "    ", "for", "res_type", "in", "res_types", ":", "\n", "        ", "assert", "res_type", "in", "[", "'bbox'", ",", "'segm'", "]", "\n", "\n", "", "directory", "=", "os", ".", "path", ".", "dirname", "(", "out_dir", "+", "'/'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "directory", ")", ":", "\n", "        ", "print", "(", "f'-------------create {out_dir}-----------------'", ")", "\n", "os", ".", "makedirs", "(", "directory", ")", "\n", "\n", "", "cocoGt", "=", "COCO", "(", "ann_file", ")", "\n", "cocoDt", "=", "cocoGt", ".", "loadRes", "(", "res_file", ")", "\n", "imgIds", "=", "cocoGt", ".", "getImgIds", "(", ")", "\n", "for", "res_type", "in", "res_types", ":", "\n", "        ", "res_out_dir", "=", "out_dir", "+", "'/'", "+", "res_type", "+", "'/'", "\n", "res_directory", "=", "os", ".", "path", ".", "dirname", "(", "res_out_dir", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "res_directory", ")", ":", "\n", "            ", "print", "(", "f'-------------create {res_out_dir}-----------------'", ")", "\n", "os", ".", "makedirs", "(", "res_directory", ")", "\n", "", "iou_type", "=", "res_type", "\n", "cocoEval", "=", "COCOeval", "(", "\n", "copy", ".", "deepcopy", "(", "cocoGt", ")", ",", "copy", ".", "deepcopy", "(", "cocoDt", ")", ",", "iou_type", ")", "\n", "cocoEval", ".", "params", ".", "imgIds", "=", "imgIds", "\n", "cocoEval", ".", "params", ".", "iouThrs", "=", "[", ".75", ",", ".5", ",", ".1", "]", "\n", "cocoEval", ".", "params", ".", "maxDets", "=", "[", "100", "]", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "ps", "=", "cocoEval", ".", "eval", "[", "'precision'", "]", "\n", "ps", "=", "np", ".", "vstack", "(", "[", "ps", ",", "np", ".", "zeros", "(", "(", "4", ",", "*", "ps", ".", "shape", "[", "1", ":", "]", ")", ")", "]", ")", "\n", "catIds", "=", "cocoGt", ".", "getCatIds", "(", ")", "\n", "recThrs", "=", "cocoEval", ".", "params", ".", "recThrs", "\n", "with", "Pool", "(", "processes", "=", "48", ")", "as", "pool", ":", "\n", "            ", "args", "=", "[", "(", "k", ",", "cocoDt", ",", "cocoGt", ",", "catId", ",", "iou_type", ")", "\n", "for", "k", ",", "catId", "in", "enumerate", "(", "catIds", ")", "]", "\n", "analyze_results", "=", "pool", ".", "starmap", "(", "analyze_individual_category", ",", "args", ")", "\n", "", "for", "k", ",", "catId", "in", "enumerate", "(", "catIds", ")", ":", "\n", "            ", "nm", "=", "cocoGt", ".", "loadCats", "(", "catId", ")", "[", "0", "]", "\n", "print", "(", "f'--------------saving {k + 1}-{nm[\"name\"]}---------------'", ")", "\n", "analyze_result", "=", "analyze_results", "[", "k", "]", "\n", "assert", "k", "==", "analyze_result", "[", "0", "]", "\n", "ps_supercategory", "=", "analyze_result", "[", "1", "]", "[", "'ps_supercategory'", "]", "\n", "ps_allcategory", "=", "analyze_result", "[", "1", "]", "[", "'ps_allcategory'", "]", "\n", "# compute precision but ignore superclass confusion", "\n", "ps", "[", "3", ",", ":", ",", "k", ",", ":", ",", ":", "]", "=", "ps_supercategory", "\n", "# compute precision but ignore any class confusion", "\n", "ps", "[", "4", ",", ":", ",", "k", ",", ":", ",", ":", "]", "=", "ps_allcategory", "\n", "# fill in background and false negative errors and plot", "\n", "ps", "[", "ps", "==", "-", "1", "]", "=", "0", "\n", "ps", "[", "5", ",", ":", ",", "k", ",", ":", ",", ":", "]", "=", "(", "ps", "[", "4", ",", ":", ",", "k", ",", ":", ",", ":", "]", ">", "0", ")", "\n", "ps", "[", "6", ",", ":", ",", "k", ",", ":", ",", ":", "]", "=", "1.0", "\n", "makeplot", "(", "recThrs", ",", "ps", "[", ":", ",", ":", ",", "k", "]", ",", "res_out_dir", ",", "nm", "[", "'name'", "]", ",", "iou_type", ")", "\n", "", "makeplot", "(", "recThrs", ",", "ps", ",", "res_out_dir", ",", "'allclass'", ",", "iou_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.main": [[156, 168], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "coco_error_analysis.analyze_results"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.coco_error_analysis.analyze_results"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", "description", "=", "'COCO Error Analysis Tool'", ")", "\n", "parser", ".", "add_argument", "(", "'result'", ",", "help", "=", "'result file (json format) path'", ")", "\n", "parser", ".", "add_argument", "(", "'out_dir'", ",", "help", "=", "'dir to save analyze result images'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ann'", ",", "\n", "default", "=", "'data/coco/annotations/instances_val2017.json'", ",", "\n", "help", "=", "'annotation file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--types'", ",", "type", "=", "str", ",", "nargs", "=", "'+'", ",", "default", "=", "[", "'bbox'", "]", ",", "help", "=", "'result types'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "analyze_results", "(", "args", ".", "result", ",", "args", ".", "ann", ",", "args", ".", "types", ",", "out_dir", "=", "args", ".", "out_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.print_config.parse_args": [[6, 14], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Print the whole config'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--options'", ",", "nargs", "=", "'+'", ",", "action", "=", "DictAction", ",", "help", "=", "'arguments in dict'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.print_config.main": [[16, 23], ["print_config.parse_args", "mmcv.Config.fromfile", "print", "Config.fromfile.merge_from_dict"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "if", "args", ".", "options", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "merge_from_dict", "(", "args", ".", "options", ")", "\n", "", "print", "(", "f'Config:\\n{cfg.pretty_text}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.get_flops.parse_args": [[14, 25], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a detector'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--shape'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "1280", ",", "800", "]", ",", "\n", "help", "=", "'input image size'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.get_flops.main": [[27, 57], ["get_flops.parse_args", "mmcv.Config.fromfile", "mmdet.models.build_detector", "torch.cuda.is_available", "mmdet.models.build_detector.eval", "hasattr", "get_model_complexity_info", "print", "print", "len", "mmdet.models.build_detector.cuda", "NotImplementedError", "len", "ValueError", "tuple"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector"], ["", "def", "main", "(", ")", ":", "\n", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "if", "len", "(", "args", ".", "shape", ")", "==", "1", ":", "\n", "        ", "input_shape", "=", "(", "3", ",", "args", ".", "shape", "[", "0", "]", ",", "args", ".", "shape", "[", "0", "]", ")", "\n", "", "elif", "len", "(", "args", ".", "shape", ")", "==", "2", ":", "\n", "        ", "input_shape", "=", "(", "3", ",", ")", "+", "tuple", "(", "args", ".", "shape", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'invalid input shape'", ")", "\n", "\n", "", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "model", "=", "build_detector", "(", "\n", "cfg", ".", "model", ",", "train_cfg", "=", "cfg", ".", "train_cfg", ",", "test_cfg", "=", "cfg", ".", "test_cfg", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "if", "hasattr", "(", "model", ",", "'forward_dummy'", ")", ":", "\n", "        ", "model", ".", "forward", "=", "model", ".", "forward_dummy", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\n", "'FLOPs counter is currently not currently supported with {}'", ".", "\n", "format", "(", "model", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n", "", "flops", ",", "params", "=", "get_model_complexity_info", "(", "model", ",", "input_shape", ")", "\n", "split_line", "=", "'='", "*", "30", "\n", "print", "(", "f'{split_line}\\nInput shape: {input_shape}\\n'", "\n", "f'Flops: {flops}\\nParams: {params}\\n{split_line}'", ")", "\n", "print", "(", "'!!!Please be cautious if you use the results in papers. '", "\n", "'You may need to check if all ops are supported and verify that the '", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.cal_train_time": [[10, 31], ["enumerate", "print", "log_dict.keys", "numpy.array", "np.array.mean", "all_times.mean.argmax", "all_times.mean.argmin", "all_times.mean.std", "print", "print", "print", "print", "print", "np.array.append", "np.array.append", "numpy.mean"], "function", ["None"], ["def", "cal_train_time", "(", "log_dicts", ",", "args", ")", ":", "\n", "    ", "for", "i", ",", "log_dict", "in", "enumerate", "(", "log_dicts", ")", ":", "\n", "        ", "print", "(", "f'{\"-\" * 5}Analyze train time of {args.json_logs[i]}{\"-\" * 5}'", ")", "\n", "all_times", "=", "[", "]", "\n", "for", "epoch", "in", "log_dict", ".", "keys", "(", ")", ":", "\n", "            ", "if", "args", ".", "include_outliers", ":", "\n", "                ", "all_times", ".", "append", "(", "log_dict", "[", "epoch", "]", "[", "'time'", "]", ")", "\n", "", "else", ":", "\n", "                ", "all_times", ".", "append", "(", "log_dict", "[", "epoch", "]", "[", "'time'", "]", "[", "1", ":", "]", ")", "\n", "", "", "all_times", "=", "np", ".", "array", "(", "all_times", ")", "\n", "epoch_ave_time", "=", "all_times", ".", "mean", "(", "-", "1", ")", "\n", "slowest_epoch", "=", "epoch_ave_time", ".", "argmax", "(", ")", "\n", "fastest_epoch", "=", "epoch_ave_time", ".", "argmin", "(", ")", "\n", "std_over_epoch", "=", "epoch_ave_time", ".", "std", "(", ")", "\n", "print", "(", "f'slowest epoch {slowest_epoch + 1}, '", "\n", "f'average time is {epoch_ave_time[slowest_epoch]:.4f}'", ")", "\n", "print", "(", "f'fastest epoch {fastest_epoch + 1}, '", "\n", "f'average time is {epoch_ave_time[fastest_epoch]:.4f}'", ")", "\n", "print", "(", "f'time std over epochs is {std_over_epoch:.4f}'", ")", "\n", "print", "(", "f'average iter time: {np.mean(all_times):.4f} s/iter'", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.plot_curve": [[33, 90], ["seaborn.set_style", "len", "enumerate", "matplotlib.switch_backend", "len", "list", "enumerate", "matplotlib.show", "print", "matplotlib.savefig", "matplotlib.cla", "len", "len", "log_dict.keys", "print", "matplotlib.legend", "matplotlib.title", "legend.append", "KeyError", "numpy.arange", "matplotlib.gca", "plt.gca.set_xticks", "matplotlib.xlabel", "matplotlib.plot", "numpy.concatenate", "numpy.concatenate", "matplotlib.xlabel", "matplotlib.plot", "np.concatenate.append", "np.concatenate.append", "max", "numpy.array", "numpy.array", "len"], "function", ["None"], ["", "", "def", "plot_curve", "(", "log_dicts", ",", "args", ")", ":", "\n", "    ", "if", "args", ".", "backend", "is", "not", "None", ":", "\n", "        ", "plt", ".", "switch_backend", "(", "args", ".", "backend", ")", "\n", "", "sns", ".", "set_style", "(", "args", ".", "style", ")", "\n", "# if legend is None, use {filename}_{key} as legend", "\n", "legend", "=", "args", ".", "legend", "\n", "if", "legend", "is", "None", ":", "\n", "        ", "legend", "=", "[", "]", "\n", "for", "json_log", "in", "args", ".", "json_logs", ":", "\n", "            ", "for", "metric", "in", "args", ".", "keys", ":", "\n", "                ", "legend", ".", "append", "(", "f'{json_log}_{metric}'", ")", "\n", "", "", "", "assert", "len", "(", "legend", ")", "==", "(", "len", "(", "args", ".", "json_logs", ")", "*", "len", "(", "args", ".", "keys", ")", ")", "\n", "metrics", "=", "args", ".", "keys", "\n", "\n", "num_metrics", "=", "len", "(", "metrics", ")", "\n", "for", "i", ",", "log_dict", "in", "enumerate", "(", "log_dicts", ")", ":", "\n", "        ", "epochs", "=", "list", "(", "log_dict", ".", "keys", "(", ")", ")", "\n", "for", "j", ",", "metric", "in", "enumerate", "(", "metrics", ")", ":", "\n", "            ", "print", "(", "f'plot curve of {args.json_logs[i]}, metric is {metric}'", ")", "\n", "if", "metric", "not", "in", "log_dict", "[", "epochs", "[", "0", "]", "]", ":", "\n", "                ", "raise", "KeyError", "(", "\n", "f'{args.json_logs[i]} does not contain metric {metric}'", ")", "\n", "\n", "", "if", "'mAP'", "in", "metric", ":", "\n", "                ", "xs", "=", "np", ".", "arange", "(", "1", ",", "max", "(", "epochs", ")", "+", "1", ")", "\n", "ys", "=", "[", "]", "\n", "for", "epoch", "in", "epochs", ":", "\n", "                    ", "ys", "+=", "log_dict", "[", "epoch", "]", "[", "metric", "]", "\n", "", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "ax", ".", "set_xticks", "(", "xs", ")", "\n", "plt", ".", "xlabel", "(", "'epoch'", ")", "\n", "plt", ".", "plot", "(", "xs", ",", "ys", ",", "label", "=", "legend", "[", "i", "*", "num_metrics", "+", "j", "]", ",", "marker", "=", "'o'", ")", "\n", "", "else", ":", "\n", "                ", "xs", "=", "[", "]", "\n", "ys", "=", "[", "]", "\n", "num_iters_per_epoch", "=", "log_dict", "[", "epochs", "[", "0", "]", "]", "[", "'iter'", "]", "[", "-", "1", "]", "\n", "for", "epoch", "in", "epochs", ":", "\n", "                    ", "iters", "=", "log_dict", "[", "epoch", "]", "[", "'iter'", "]", "\n", "if", "log_dict", "[", "epoch", "]", "[", "'mode'", "]", "[", "-", "1", "]", "==", "'val'", ":", "\n", "                        ", "iters", "=", "iters", "[", ":", "-", "1", "]", "\n", "", "xs", ".", "append", "(", "\n", "np", ".", "array", "(", "iters", ")", "+", "(", "epoch", "-", "1", ")", "*", "num_iters_per_epoch", ")", "\n", "ys", ".", "append", "(", "np", ".", "array", "(", "log_dict", "[", "epoch", "]", "[", "metric", "]", "[", ":", "len", "(", "iters", ")", "]", ")", ")", "\n", "", "xs", "=", "np", ".", "concatenate", "(", "xs", ")", "\n", "ys", "=", "np", ".", "concatenate", "(", "ys", ")", "\n", "plt", ".", "xlabel", "(", "'iter'", ")", "\n", "plt", ".", "plot", "(", "\n", "xs", ",", "ys", ",", "label", "=", "legend", "[", "i", "*", "num_metrics", "+", "j", "]", ",", "linewidth", "=", "0.5", ")", "\n", "", "plt", ".", "legend", "(", ")", "\n", "", "if", "args", ".", "title", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "args", ".", "title", ")", "\n", "", "", "if", "args", ".", "out", "is", "None", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'save curve to: {args.out}'", ")", "\n", "plt", ".", "savefig", "(", "args", ".", "out", ")", "\n", "plt", ".", "cla", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.add_plot_parser": [[92, 118], ["subparsers.add_parser", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument"], "function", ["None"], ["", "", "def", "add_plot_parser", "(", "subparsers", ")", ":", "\n", "    ", "parser_plt", "=", "subparsers", ".", "add_parser", "(", "\n", "'plot_curve'", ",", "help", "=", "'parser for plotting curves'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'json_logs'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'path of train log in json format'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--keys'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "'bbox_mAP'", "]", ",", "\n", "help", "=", "'the metric that you want to plot'", ")", "\n", "parser_plt", ".", "add_argument", "(", "'--title'", ",", "type", "=", "str", ",", "help", "=", "'title of figure'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--legend'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'legend of each plot'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--backend'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'backend of plt'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--style'", ",", "type", "=", "str", ",", "default", "=", "'dark'", ",", "help", "=", "'style of plt'", ")", "\n", "parser_plt", ".", "add_argument", "(", "'--out'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.add_time_parser": [[120, 133], ["subparsers.add_parser", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument"], "function", ["None"], ["", "def", "add_time_parser", "(", "subparsers", ")", ":", "\n", "    ", "parser_time", "=", "subparsers", ".", "add_parser", "(", "\n", "'cal_train_time'", ",", "\n", "help", "=", "'parser for computing the average time per training iteration'", ")", "\n", "parser_time", ".", "add_argument", "(", "\n", "'json_logs'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'path of train log in json format'", ")", "\n", "parser_time", ".", "add_argument", "(", "\n", "'--include-outliers'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'include the first value of every epoch when computing '", "\n", "'the average time'", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.parse_args": [[136, 144], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_subparsers", "analyze_logs.add_plot_parser", "analyze_logs.add_time_parser", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.add_plot_parser", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.add_time_parser", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Analyze Json Log'", ")", "\n", "# currently only support plot curve and calculate average train time", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "dest", "=", "'task'", ",", "help", "=", "'task parser'", ")", "\n", "add_plot_parser", "(", "subparsers", ")", "\n", "add_time_parser", "(", "subparsers", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.load_json_logs": [[146, 164], ["zip", "dict", "open", "json.loads", "json.loads.pop", "json.loads.items", "line.strip", "collections.defaultdict", "[].append"], "function", ["None"], ["", "def", "load_json_logs", "(", "json_logs", ")", ":", "\n", "# load and convert json_logs to log_dict, key is epoch, value is a sub dict", "\n", "# keys of sub dict is different metrics, e.g. memory, bbox_mAP", "\n", "# value of sub dict is a list of corresponding values of all iterations", "\n", "    ", "log_dicts", "=", "[", "dict", "(", ")", "for", "_", "in", "json_logs", "]", "\n", "for", "json_log", ",", "log_dict", "in", "zip", "(", "json_logs", ",", "log_dicts", ")", ":", "\n", "        ", "with", "open", "(", "json_log", ",", "'r'", ")", "as", "log_file", ":", "\n", "            ", "for", "line", "in", "log_file", ":", "\n", "                ", "log", "=", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "\n", "# skip lines without `epoch` field", "\n", "if", "'epoch'", "not", "in", "log", ":", "\n", "                    ", "continue", "\n", "", "epoch", "=", "log", ".", "pop", "(", "'epoch'", ")", "\n", "if", "epoch", "not", "in", "log_dict", ":", "\n", "                    ", "log_dict", "[", "epoch", "]", "=", "defaultdict", "(", "list", ")", "\n", "", "for", "k", ",", "v", "in", "log", ".", "items", "(", ")", ":", "\n", "                    ", "log_dict", "[", "epoch", "]", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "", "", "", "", "return", "log_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.main": [[166, 176], ["analyze_logs.parse_args", "analyze_logs.load_json_logs", "json_log.endswith", "eval"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.analyze_logs.load_json_logs"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "json_logs", "=", "args", ".", "json_logs", "\n", "for", "json_log", "in", "json_logs", ":", "\n", "        ", "assert", "json_log", ".", "endswith", "(", "'.json'", ")", "\n", "\n", "", "log_dicts", "=", "load_json_logs", "(", "json_logs", ")", "\n", "\n", "eval", "(", "args", ".", "task", ")", "(", "log_dicts", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.print_coco_results": [[8, 32], ["numpy.zeros", "robustness_eval.print_coco_results._print"], "function", ["None"], ["def", "print_coco_results", "(", "results", ")", ":", "\n", "\n", "    ", "def", "_print", "(", "result", ",", "ap", "=", "1", ",", "iouThr", "=", "None", ",", "areaRng", "=", "'all'", ",", "maxDets", "=", "100", ")", ":", "\n", "        ", "titleStr", "=", "'Average Precision'", "if", "ap", "==", "1", "else", "'Average Recall'", "\n", "typeStr", "=", "'(AP)'", "if", "ap", "==", "1", "else", "'(AR)'", "\n", "iouStr", "=", "'0.50:0.95'", "if", "iouThr", "is", "None", "else", "f'{iouThr:0.2f}'", "\n", "iStr", "=", "f' {titleStr:<18} {typeStr} @[ IoU={iouStr:<9} | '", "\n", "iStr", "+=", "f'area={areaRng:>6s} | maxDets={maxDets:>3d} ] = {result:0.3f}'", "\n", "print", "(", "iStr", ")", "\n", "\n", "", "stats", "=", "np", ".", "zeros", "(", "(", "12", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_print", "(", "results", "[", "0", "]", ",", "1", ")", "\n", "stats", "[", "1", "]", "=", "_print", "(", "results", "[", "1", "]", ",", "1", ",", "iouThr", "=", ".5", ")", "\n", "stats", "[", "2", "]", "=", "_print", "(", "results", "[", "2", "]", ",", "1", ",", "iouThr", "=", ".75", ")", "\n", "stats", "[", "3", "]", "=", "_print", "(", "results", "[", "3", "]", ",", "1", ",", "areaRng", "=", "'small'", ")", "\n", "stats", "[", "4", "]", "=", "_print", "(", "results", "[", "4", "]", ",", "1", ",", "areaRng", "=", "'medium'", ")", "\n", "stats", "[", "5", "]", "=", "_print", "(", "results", "[", "5", "]", ",", "1", ",", "areaRng", "=", "'large'", ")", "\n", "stats", "[", "6", "]", "=", "_print", "(", "results", "[", "6", "]", ",", "0", ",", "maxDets", "=", "1", ")", "\n", "stats", "[", "7", "]", "=", "_print", "(", "results", "[", "7", "]", ",", "0", ",", "maxDets", "=", "10", ")", "\n", "stats", "[", "8", "]", "=", "_print", "(", "results", "[", "8", "]", ",", "0", ")", "\n", "stats", "[", "9", "]", "=", "_print", "(", "results", "[", "9", "]", ",", "0", ",", "areaRng", "=", "'small'", ")", "\n", "stats", "[", "10", "]", "=", "_print", "(", "results", "[", "10", "]", ",", "0", ",", "areaRng", "=", "'medium'", ")", "\n", "stats", "[", "11", "]", "=", "_print", "(", "results", "[", "11", "]", ",", "0", ",", "areaRng", "=", "'large'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_coco_style_results": [[34, 109], ["mmcv.load", "len", "numpy.zeros", "enumerate", "print", "isinstance", "isinstance", "list", "numpy.mean", "numpy.mean", "mmcv.load.keys", "len", "enumerate", "print", "robustness_eval.print_coco_results", "print", "robustness_eval.print_coco_results", "print", "robustness_eval.print_coco_results", "print", "enumerate", "print", "enumerate", "print", "enumerate", "os.basename", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.print_coco_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.print_coco_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.print_coco_results"], ["", "def", "get_coco_style_results", "(", "filename", ",", "\n", "task", "=", "'bbox'", ",", "\n", "metric", "=", "None", ",", "\n", "prints", "=", "'mPC'", ",", "\n", "aggregate", "=", "'benchmark'", ")", ":", "\n", "\n", "    ", "assert", "aggregate", "in", "[", "'benchmark'", ",", "'all'", "]", "\n", "\n", "if", "prints", "==", "'all'", ":", "\n", "        ", "prints", "=", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", "\n", "", "elif", "isinstance", "(", "prints", ",", "str", ")", ":", "\n", "        ", "prints", "=", "[", "prints", "]", "\n", "", "for", "p", "in", "prints", ":", "\n", "        ", "assert", "p", "in", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", "\n", "\n", "", "if", "metric", "is", "None", ":", "\n", "        ", "metrics", "=", "[", "\n", "'AP'", ",", "'AP50'", ",", "'AP75'", ",", "'APs'", ",", "'APm'", ",", "'APl'", ",", "'AR1'", ",", "'AR10'", ",", "'AR100'", ",", "\n", "'ARs'", ",", "'ARm'", ",", "'ARl'", "\n", "]", "\n", "", "elif", "isinstance", "(", "metric", ",", "list", ")", ":", "\n", "        ", "metrics", "=", "metric", "\n", "", "else", ":", "\n", "        ", "metrics", "=", "[", "metric", "]", "\n", "\n", "", "for", "metric_name", "in", "metrics", ":", "\n", "        ", "assert", "metric_name", "in", "[", "\n", "'AP'", ",", "'AP50'", ",", "'AP75'", ",", "'APs'", ",", "'APm'", ",", "'APl'", ",", "'AR1'", ",", "'AR10'", ",", "'AR100'", ",", "\n", "'ARs'", ",", "'ARm'", ",", "'ARl'", "\n", "]", "\n", "\n", "", "eval_output", "=", "mmcv", ".", "load", "(", "filename", ")", "\n", "\n", "num_distortions", "=", "len", "(", "list", "(", "eval_output", ".", "keys", "(", ")", ")", ")", "\n", "results", "=", "np", ".", "zeros", "(", "(", "num_distortions", ",", "6", ",", "len", "(", "metrics", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "for", "corr_i", ",", "distortion", "in", "enumerate", "(", "eval_output", ")", ":", "\n", "        ", "for", "severity", "in", "eval_output", "[", "distortion", "]", ":", "\n", "            ", "for", "metric_j", ",", "metric_name", "in", "enumerate", "(", "metrics", ")", ":", "\n", "                ", "mAP", "=", "eval_output", "[", "distortion", "]", "[", "severity", "]", "[", "task", "]", "[", "metric_name", "]", "\n", "results", "[", "corr_i", ",", "severity", ",", "metric_j", "]", "=", "mAP", "\n", "\n", "", "", "", "P", "=", "results", "[", "0", ",", "0", ",", ":", "]", "\n", "if", "aggregate", "==", "'benchmark'", ":", "\n", "        ", "mPC", "=", "np", ".", "mean", "(", "results", "[", ":", "15", ",", "1", ":", ",", ":", "]", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "mPC", "=", "np", ".", "mean", "(", "results", "[", ":", ",", "1", ":", ",", ":", "]", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "", "rPC", "=", "mPC", "/", "P", "\n", "\n", "print", "(", "f'\\nmodel: {osp.basename(filename)}'", ")", "\n", "if", "metric", "is", "None", ":", "\n", "        ", "if", "'P'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Performance on Clean Data [P] ({task})'", ")", "\n", "print_coco_results", "(", "P", ")", "\n", "", "if", "'mPC'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Mean Performance under Corruption [mPC] ({task})'", ")", "\n", "print_coco_results", "(", "mPC", ")", "\n", "", "if", "'rPC'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Realtive Performance under Corruption [rPC] ({task})'", ")", "\n", "print_coco_results", "(", "rPC", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "'P'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Performance on Clean Data [P] ({task})'", ")", "\n", "for", "metric_i", ",", "metric_name", "in", "enumerate", "(", "metrics", ")", ":", "\n", "                ", "print", "(", "f'{metric_name:5} =  {P[metric_i]:0.3f}'", ")", "\n", "", "", "if", "'mPC'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Mean Performance under Corruption [mPC] ({task})'", ")", "\n", "for", "metric_i", ",", "metric_name", "in", "enumerate", "(", "metrics", ")", ":", "\n", "                ", "print", "(", "f'{metric_name:5} =  {mPC[metric_i]:0.3f}'", ")", "\n", "", "", "if", "'rPC'", "in", "prints", ":", "\n", "            ", "print", "(", "f'Relative Performance under Corruption [rPC] ({task})'", ")", "\n", "for", "metric_i", ",", "metric_name", "in", "enumerate", "(", "metrics", ")", ":", "\n", "                ", "print", "(", "f'{metric_name:5} => {rPC[metric_i] * 100:0.1f} %'", ")", "\n", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_voc_style_results": [[111, 153], ["mmcv.load", "len", "numpy.zeros", "enumerate", "print", "numpy.mean", "isinstance", "list", "numpy.mean", "numpy.mean", "print", "print", "print", "mmcv.load.keys", "os.basename", "range", "numpy.mean", "numpy.mean", "len", "numpy.mean"], "function", ["None"], ["", "def", "get_voc_style_results", "(", "filename", ",", "prints", "=", "'mPC'", ",", "aggregate", "=", "'benchmark'", ")", ":", "\n", "\n", "    ", "assert", "aggregate", "in", "[", "'benchmark'", ",", "'all'", "]", "\n", "\n", "if", "prints", "==", "'all'", ":", "\n", "        ", "prints", "=", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", "\n", "", "elif", "isinstance", "(", "prints", ",", "str", ")", ":", "\n", "        ", "prints", "=", "[", "prints", "]", "\n", "", "for", "p", "in", "prints", ":", "\n", "        ", "assert", "p", "in", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", "\n", "\n", "", "eval_output", "=", "mmcv", ".", "load", "(", "filename", ")", "\n", "\n", "num_distortions", "=", "len", "(", "list", "(", "eval_output", ".", "keys", "(", ")", ")", ")", "\n", "results", "=", "np", ".", "zeros", "(", "(", "num_distortions", ",", "6", ",", "20", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "for", "i", ",", "distortion", "in", "enumerate", "(", "eval_output", ")", ":", "\n", "        ", "for", "severity", "in", "eval_output", "[", "distortion", "]", ":", "\n", "            ", "mAP", "=", "[", "\n", "eval_output", "[", "distortion", "]", "[", "severity", "]", "[", "j", "]", "[", "'ap'", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "eval_output", "[", "distortion", "]", "[", "severity", "]", ")", ")", "\n", "]", "\n", "results", "[", "i", ",", "severity", ",", ":", "]", "=", "mAP", "\n", "\n", "", "", "P", "=", "results", "[", "0", ",", "0", ",", ":", "]", "\n", "if", "aggregate", "==", "'benchmark'", ":", "\n", "        ", "mPC", "=", "np", ".", "mean", "(", "results", "[", ":", "15", ",", "1", ":", ",", ":", "]", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "mPC", "=", "np", ".", "mean", "(", "results", "[", ":", ",", "1", ":", ",", ":", "]", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "", "rPC", "=", "mPC", "/", "P", "\n", "\n", "print", "(", "f'\\nmodel: {osp.basename(filename)}'", ")", "\n", "if", "'P'", "in", "prints", ":", "\n", "        ", "print", "(", "f'Performance on Clean Data [P] in AP50 = {np.mean(P):0.3f}'", ")", "\n", "", "if", "'mPC'", "in", "prints", ":", "\n", "        ", "print", "(", "'Mean Performance under Corruption [mPC] in AP50 = '", "\n", "f'{np.mean(mPC):0.3f}'", ")", "\n", "", "if", "'rPC'", "in", "prints", ":", "\n", "        ", "print", "(", "'Realtive Performance under Corruption [rPC] in % = '", "\n", "f'{np.mean(rPC) * 100:0.1f}'", ")", "\n", "\n", "", "return", "np", ".", "mean", "(", "results", ",", "axis", "=", "2", ",", "keepdims", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results": [[155, 181], ["robustness_eval.get_coco_style_results", "robustness_eval.get_voc_style_results", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_coco_style_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_voc_style_results"], ["", "def", "get_results", "(", "filename", ",", "\n", "dataset", "=", "'coco'", ",", "\n", "task", "=", "'bbox'", ",", "\n", "metric", "=", "None", ",", "\n", "prints", "=", "'mPC'", ",", "\n", "aggregate", "=", "'benchmark'", ")", ":", "\n", "    ", "assert", "dataset", "in", "[", "'coco'", ",", "'voc'", ",", "'cityscapes'", "]", "\n", "\n", "if", "dataset", "in", "[", "'coco'", ",", "'cityscapes'", "]", ":", "\n", "        ", "results", "=", "get_coco_style_results", "(", "\n", "filename", ",", "\n", "task", "=", "task", ",", "\n", "metric", "=", "metric", ",", "\n", "prints", "=", "prints", ",", "\n", "aggregate", "=", "aggregate", ")", "\n", "", "elif", "dataset", "==", "'voc'", ":", "\n", "        ", "if", "task", "!=", "'bbox'", ":", "\n", "            ", "print", "(", "'Only bbox analysis is supported for Pascal VOC'", ")", "\n", "print", "(", "'Will report bbox results\\n'", ")", "\n", "", "if", "metric", "not", "in", "[", "None", ",", "[", "'AP'", "]", ",", "[", "'AP50'", "]", "]", ":", "\n", "            ", "print", "(", "'Only the AP50 metric is supported for Pascal VOC'", ")", "\n", "print", "(", "'Will report AP50 metric\\n'", ")", "\n", "", "results", "=", "get_voc_style_results", "(", "\n", "filename", ",", "prints", "=", "prints", ",", "aggregate", "=", "aggregate", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_distortions_from_file": [[183, 188], ["mmcv.load", "robustness_eval.get_distortions_from_results"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_distortions_from_results"], ["", "def", "get_distortions_from_file", "(", "filename", ")", ":", "\n", "\n", "    ", "eval_output", "=", "mmcv", ".", "load", "(", "filename", ")", "\n", "\n", "return", "get_distortions_from_results", "(", "eval_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_distortions_from_results": [[190, 195], ["enumerate", "distortions.append", "distortion.replace"], "function", ["None"], ["", "def", "get_distortions_from_results", "(", "eval_output", ")", ":", "\n", "    ", "distortions", "=", "[", "]", "\n", "for", "i", ",", "distortion", "in", "enumerate", "(", "eval_output", ")", ":", "\n", "        ", "distortions", ".", "append", "(", "distortion", ".", "replace", "(", "'_'", ",", "' '", ")", ")", "\n", "", "return", "distortions", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.main": [[197, 247], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "robustness_eval.get_results"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", "description", "=", "'Corruption Result Analysis'", ")", "\n", "parser", ".", "add_argument", "(", "'filename'", ",", "help", "=", "'result file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "type", "=", "str", ",", "\n", "choices", "=", "[", "'coco'", ",", "'voc'", ",", "'cityscapes'", "]", ",", "\n", "default", "=", "'coco'", ",", "\n", "help", "=", "'dataset type'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--task'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "choices", "=", "[", "'bbox'", ",", "'segm'", "]", ",", "\n", "default", "=", "[", "'bbox'", "]", ",", "\n", "help", "=", "'task to report'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--metric'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "choices", "=", "[", "\n", "None", ",", "'AP'", ",", "'AP50'", ",", "'AP75'", ",", "'APs'", ",", "'APm'", ",", "'APl'", ",", "'AR1'", ",", "'AR10'", ",", "\n", "'AR100'", ",", "'ARs'", ",", "'ARm'", ",", "'ARl'", "\n", "]", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'metric to report'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--prints'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "choices", "=", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", ",", "\n", "default", "=", "'mPC'", ",", "\n", "help", "=", "'corruption benchmark metric to print'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--aggregate'", ",", "\n", "type", "=", "str", ",", "\n", "choices", "=", "[", "'all'", ",", "'benchmark'", "]", ",", "\n", "default", "=", "'benchmark'", ",", "\n", "help", "=", "'aggregate all results or only those \\\n        for benchmark corruptions'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "for", "task", "in", "args", ".", "task", ":", "\n", "        ", "get_results", "(", "\n", "args", ".", "filename", ",", "\n", "dataset", "=", "args", ".", "dataset", ",", "\n", "task", "=", "task", ",", "\n", "metric", "=", "args", ".", "metric", ",", "\n", "prints", "=", "args", ".", "prints", ",", "\n", "aggregate", "=", "args", ".", "aggregate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.train.parse_args": [[21, 80], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_mutually_exclusive_group", "parser.add_mutually_exclusive_group.add_argument", "parser.add_mutually_exclusive_group.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str", "ValueError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "if", "deterministic", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "\n", "\n", "", "", "def", "train_detector", "(", "model", ",", "\n", "dataset", ",", "\n", "cfg", ",", "\n", "distributed", "=", "False", ",", "\n", "validate", "=", "False", ",", "\n", "timestamp", "=", "None", ",", "\n", "meta", "=", "None", ")", ":", "\n", "    ", "logger", "=", "get_root_logger", "(", "cfg", ".", "log_level", ")", "\n", "\n", "# prepare data loaders", "\n", "dataset", "=", "dataset", "if", "isinstance", "(", "dataset", ",", "(", "list", ",", "tuple", ")", ")", "else", "[", "dataset", "]", "\n", "if", "'imgs_per_gpu'", "in", "cfg", ".", "data", ":", "\n", "        ", "logger", ".", "warning", "(", "'\"imgs_per_gpu\" is deprecated in MMDet V2.0. '", "\n", "'Please use \"samples_per_gpu\" instead'", ")", "\n", "if", "'samples_per_gpu'", "in", "cfg", ".", "data", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "f'Got \"imgs_per_gpu\"={cfg.data.imgs_per_gpu} and '", "\n", "f'\"samples_per_gpu\"={cfg.data.samples_per_gpu}, \"imgs_per_gpu\"'", "\n", "f'={cfg.data.imgs_per_gpu} is used in this experiments'", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "'Automatically set \"samples_per_gpu\"=\"imgs_per_gpu\"='", "\n", "f'{cfg.data.imgs_per_gpu} in this experiments'", ")", "\n", "", "cfg", ".", "data", ".", "samples_per_gpu", "=", "cfg", ".", "data", ".", "imgs_per_gpu", "\n", "\n", "", "data_loaders", "=", "[", "\n", "build_dataloader", "(", "\n", "ds", ",", "\n", "cfg", ".", "data", ".", "samples_per_gpu", ",", "\n", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "# cfg.gpus will be ignored if distributed", "\n", "len", "(", "cfg", ".", "gpu_ids", ")", ",", "\n", "dist", "=", "distributed", ",", "\n", "seed", "=", "cfg", ".", "seed", ")", "for", "ds", "in", "dataset", "\n", "]", "\n", "\n", "# put model on gpus", "\n", "if", "distributed", ":", "\n", "        ", "find_unused_parameters", "=", "cfg", ".", "get", "(", "'find_unused_parameters'", ",", "False", ")", "\n", "# Sets the `find_unused_parameters` parameter in", "\n", "# torch.nn.parallel.DistributedDataParallel", "\n", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ",", "\n", "find_unused_parameters", "=", "find_unused_parameters", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.train.main": [[82, 171], ["train.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "mmcv.mkdir_or_exist", "Config.fromfile.dump", "time.strftime", "os.join", "mmdet.utils.get_root_logger", "dict", "mmdet.utils.collect_env", "mmdet.utils.get_root_logger.info", "mmdet.utils.get_root_logger.info", "mmdet.utils.get_root_logger.info", "mmdet.models.build_detector", "mmdet.apis.train_detector", "Config.fromfile.merge_from_dict", "mmcv.runner.init_dist", "os.abspath", "os.join", "time.localtime", "mmdet.utils.get_root_logger.info", "mmdet.apis.set_random_seed", "mmdet.datasets.build_dataset", "len", "copy.deepcopy", "datasets.append", "dict", "Config.fromfile.get", "os.join", "range", "range", "os.basename", "mmdet.datasets.build_dataset", "mmdet.utils.collect_env.items", "os.splitext", "os.basename", "mmcv.utils.get_git_hash"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.collect_env.collect_env", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.train.train_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.train.set_random_seed", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset"], ["model", ".", "cuda", "(", "cfg", ".", "gpu_ids", "[", "0", "]", ")", ",", "device_ids", "=", "cfg", ".", "gpu_ids", ")", "\n", "\n", "# build runner", "\n", "", "optimizer", "=", "build_optimizer", "(", "model", ",", "cfg", ".", "optimizer", ")", "\n", "runner", "=", "EpochBasedRunner", "(", "\n", "model", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "work_dir", "=", "cfg", ".", "work_dir", ",", "\n", "logger", "=", "logger", ",", "\n", "meta", "=", "meta", ")", "\n", "# an ugly workaround to make .log and .log.json filenames the same", "\n", "runner", ".", "timestamp", "=", "timestamp", "\n", "\n", "# fp16 setting", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "        ", "optimizer_config", "=", "Fp16OptimizerHook", "(", "\n", "**", "cfg", ".", "optimizer_config", ",", "**", "fp16_cfg", ",", "distributed", "=", "distributed", ")", "\n", "", "elif", "distributed", "and", "'type'", "not", "in", "cfg", ".", "optimizer_config", ":", "\n", "        ", "optimizer_config", "=", "OptimizerHook", "(", "**", "cfg", ".", "optimizer_config", ")", "\n", "", "else", ":", "\n", "        ", "optimizer_config", "=", "cfg", ".", "optimizer_config", "\n", "\n", "# register hooks", "\n", "", "runner", ".", "register_training_hooks", "(", "cfg", ".", "lr_config", ",", "optimizer_config", ",", "\n", "cfg", ".", "checkpoint_config", ",", "cfg", ".", "log_config", ",", "\n", "cfg", ".", "get", "(", "'momentum_config'", ",", "None", ")", ")", "\n", "if", "distributed", ":", "\n", "        ", "runner", ".", "register_hook", "(", "DistSamplerSeedHook", "(", ")", ")", "\n", "\n", "# register eval hooks", "\n", "", "if", "validate", ":", "\n", "        ", "val_dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ",", "dict", "(", "test_mode", "=", "True", ")", ")", "\n", "val_dataloader", "=", "build_dataloader", "(", "\n", "val_dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "eval_cfg", "=", "cfg", ".", "get", "(", "'evaluation'", ",", "{", "}", ")", "\n", "eval_hook", "=", "DistEvalHook", "if", "distributed", "else", "EvalHook", "\n", "runner", ".", "register_hook", "(", "eval_hook", "(", "val_dataloader", ",", "cfg", "=", "cfg", ",", "**", "eval_cfg", ")", ")", "\n", "\n", "# user-defined hooks", "\n", "", "if", "cfg", ".", "get", "(", "'custom_hooks'", ",", "None", ")", ":", "\n", "        ", "custom_hooks", "=", "cfg", ".", "custom_hooks", "\n", "assert", "isinstance", "(", "custom_hooks", ",", "list", ")", ",", "f'custom_hooks expect list type, but got {type(custom_hooks)}'", "\n", "for", "hook_cfg", "in", "cfg", ".", "custom_hooks", ":", "\n", "            ", "assert", "isinstance", "(", "hook_cfg", ",", "dict", ")", ",", "'Each item in custom_hooks expects dict type, but got '", "f'{type(hook_cfg)}'", "\n", "hook_cfg", "=", "hook_cfg", ".", "copy", "(", ")", "\n", "priority", "=", "hook_cfg", ".", "pop", "(", "'priority'", ",", "'NORMAL'", ")", "\n", "hook", "=", "build_from_cfg", "(", "hook_cfg", ",", "HOOKS", ")", "\n", "runner", ".", "register_hook", "(", "hook", ",", "priority", "=", "priority", ")", "\n", "\n", "", "", "if", "cfg", ".", "resume_from", ":", "\n", "        ", "runner", ".", "resume", "(", "cfg", ".", "resume_from", ")", "\n", "", "elif", "cfg", ".", "load_from", ":", "\n", "        ", "runner", ".", "load_checkpoint", "(", "cfg", ".", "load_from", ")", "\n", "", "runner", ".", "run", "(", "data_loaders", ",", "cfg", ".", "workflow", ",", "cfg", ".", "total_epochs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_bn": [[10, 21], ["torch.from_numpy", "torch.from_numpy", "state_dict[].size", "torch.zeros", "torch.ones", "converted_names.add", "converted_names.add"], "function", ["None"], ["def", "convert_bn", "(", "blobs", ",", "state_dict", ",", "caffe_name", ",", "torch_name", ",", "converted_names", ")", ":", "\n", "# detectron replace bn with affine channel layer", "\n", "    ", "state_dict", "[", "torch_name", "+", "'.bias'", "]", "=", "torch", ".", "from_numpy", "(", "blobs", "[", "caffe_name", "+", "\n", "'_b'", "]", ")", "\n", "state_dict", "[", "torch_name", "+", "'.weight'", "]", "=", "torch", ".", "from_numpy", "(", "blobs", "[", "caffe_name", "+", "\n", "'_s'", "]", ")", "\n", "bn_size", "=", "state_dict", "[", "torch_name", "+", "'.weight'", "]", ".", "size", "(", ")", "\n", "state_dict", "[", "torch_name", "+", "'.running_mean'", "]", "=", "torch", ".", "zeros", "(", "bn_size", ")", "\n", "state_dict", "[", "torch_name", "+", "'.running_var'", "]", "=", "torch", ".", "ones", "(", "bn_size", ")", "\n", "converted_names", ".", "add", "(", "caffe_name", "+", "'_b'", ")", "\n", "converted_names", ".", "add", "(", "caffe_name", "+", "'_s'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_conv_fc": [[23, 32], ["torch.from_numpy", "converted_names.add", "torch.from_numpy", "converted_names.add"], "function", ["None"], ["", "def", "convert_conv_fc", "(", "blobs", ",", "state_dict", ",", "caffe_name", ",", "torch_name", ",", "\n", "converted_names", ")", ":", "\n", "    ", "state_dict", "[", "torch_name", "+", "'.weight'", "]", "=", "torch", ".", "from_numpy", "(", "blobs", "[", "caffe_name", "+", "\n", "'_w'", "]", ")", "\n", "converted_names", ".", "add", "(", "caffe_name", "+", "'_w'", ")", "\n", "if", "caffe_name", "+", "'_b'", "in", "blobs", ":", "\n", "        ", "state_dict", "[", "torch_name", "+", "'.bias'", "]", "=", "torch", ".", "from_numpy", "(", "blobs", "[", "caffe_name", "+", "\n", "'_b'", "]", ")", "\n", "converted_names", ".", "add", "(", "caffe_name", "+", "'_b'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert": [[34, 70], ["mmcv.load", "collections.OrderedDict", "set", "detectron2pytorch.convert_conv_fc", "detectron2pytorch.convert_bn", "range", "dict", "torch.save", "ValueError", "range", "len", "enumerate", "print", "detectron2pytorch.convert_conv_fc", "detectron2pytorch.convert_bn", "detectron2pytorch.convert_conv_fc", "detectron2pytorch.convert_bn"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_conv_fc", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_bn", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_conv_fc", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_bn", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_conv_fc", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.convert_bn"], ["", "", "def", "convert", "(", "src", ",", "dst", ",", "depth", ")", ":", "\n", "    ", "\"\"\"Convert keys in detectron pretrained ResNet models to pytorch style.\"\"\"", "\n", "# load arch_settings", "\n", "if", "depth", "not", "in", "arch_settings", ":", "\n", "        ", "raise", "ValueError", "(", "'Only support ResNet-50 and ResNet-101 currently'", ")", "\n", "", "block_nums", "=", "arch_settings", "[", "depth", "]", "\n", "# load caffe model", "\n", "caffe_model", "=", "mmcv", ".", "load", "(", "src", ",", "encoding", "=", "'latin1'", ")", "\n", "blobs", "=", "caffe_model", "[", "'blobs'", "]", "if", "'blobs'", "in", "caffe_model", "else", "caffe_model", "\n", "# convert to pytorch style", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "converted_names", "=", "set", "(", ")", "\n", "convert_conv_fc", "(", "blobs", ",", "state_dict", ",", "'conv1'", ",", "'conv1'", ",", "converted_names", ")", "\n", "convert_bn", "(", "blobs", ",", "state_dict", ",", "'res_conv1_bn'", ",", "'bn1'", ",", "converted_names", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "block_nums", ")", "+", "1", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "block_nums", "[", "i", "-", "1", "]", ")", ":", "\n", "            ", "if", "j", "==", "0", ":", "\n", "                ", "convert_conv_fc", "(", "blobs", ",", "state_dict", ",", "f'res{i + 1}_{j}_branch1'", ",", "\n", "f'layer{i}.{j}.downsample.0'", ",", "converted_names", ")", "\n", "convert_bn", "(", "blobs", ",", "state_dict", ",", "f'res{i + 1}_{j}_branch1_bn'", ",", "\n", "f'layer{i}.{j}.downsample.1'", ",", "converted_names", ")", "\n", "", "for", "k", ",", "letter", "in", "enumerate", "(", "[", "'a'", ",", "'b'", ",", "'c'", "]", ")", ":", "\n", "                ", "convert_conv_fc", "(", "blobs", ",", "state_dict", ",", "\n", "f'res{i + 1}_{j}_branch2{letter}'", ",", "\n", "f'layer{i}.{j}.conv{k+1}'", ",", "converted_names", ")", "\n", "convert_bn", "(", "blobs", ",", "state_dict", ",", "\n", "f'res{i + 1}_{j}_branch2{letter}_bn'", ",", "\n", "f'layer{i}.{j}.bn{k + 1}'", ",", "converted_names", ")", "\n", "# check if all layers are converted", "\n", "", "", "", "for", "key", "in", "blobs", ":", "\n", "        ", "if", "key", "not", "in", "converted_names", ":", "\n", "            ", "print", "(", "f'Not Convert: {key}'", ")", "\n", "# save checkpoint", "\n", "", "", "checkpoint", "=", "dict", "(", ")", "\n", "checkpoint", "[", "'state_dict'", "]", "=", "state_dict", "\n", "torch", ".", "save", "(", "checkpoint", ",", "dst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.detectron2pytorch.main": [[72, 79], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "detectron2pytorch.convert"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.convert"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Convert model keys'", ")", "\n", "parser", ".", "add_argument", "(", "'src'", ",", "help", "=", "'src detectron model path'", ")", "\n", "parser", ".", "add_argument", "(", "'dst'", ",", "help", "=", "'save path'", ")", "\n", "parser", ".", "add_argument", "(", "'depth'", ",", "type", "=", "int", ",", "help", "=", "'ResNet model depth'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "convert", "(", "args", ".", "src", ",", "args", ".", "dst", ",", "args", ".", "depth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_stem": [[7, 13], ["model_key.replace", "new_key.replace.replace", "converted_names.add", "print"], "function", ["None"], ["def", "convert_stem", "(", "model_key", ",", "model_weight", ",", "state_dict", ",", "converted_names", ")", ":", "\n", "    ", "new_key", "=", "model_key", ".", "replace", "(", "'stem.conv'", ",", "'conv1'", ")", "\n", "new_key", "=", "new_key", ".", "replace", "(", "'stem.bn'", ",", "'bn1'", ")", "\n", "state_dict", "[", "new_key", "]", "=", "model_weight", "\n", "converted_names", ".", "add", "(", "model_key", ")", "\n", "print", "(", "f'Convert {model_key} to {new_key}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_head": [[15, 20], ["model_key.replace", "converted_names.add", "print"], "function", ["None"], ["", "def", "convert_head", "(", "model_key", ",", "model_weight", ",", "state_dict", ",", "converted_names", ")", ":", "\n", "    ", "new_key", "=", "model_key", ".", "replace", "(", "'head.fc'", ",", "'fc'", ")", "\n", "state_dict", "[", "new_key", "]", "=", "model_weight", "\n", "converted_names", ".", "add", "(", "model_key", ")", "\n", "print", "(", "f'Convert {model_key} to {new_key}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_reslayer": [[22, 52], ["model_key.split", "int", "print", "converted_names.add", "int", "ValueError"], "function", ["None"], ["", "def", "convert_reslayer", "(", "model_key", ",", "model_weight", ",", "state_dict", ",", "converted_names", ")", ":", "\n", "    ", "split_keys", "=", "model_key", ".", "split", "(", "'.'", ")", "\n", "layer", ",", "block", ",", "module", "=", "split_keys", "[", ":", "3", "]", "\n", "block_id", "=", "int", "(", "block", "[", "1", ":", "]", ")", "\n", "layer_name", "=", "f'layer{int(layer[1:])}'", "\n", "block_name", "=", "f'{block_id - 1}'", "\n", "\n", "if", "block_id", "==", "1", "and", "module", "==", "'bn'", ":", "\n", "        ", "new_key", "=", "f'{layer_name}.{block_name}.downsample.1.{split_keys[-1]}'", "\n", "", "elif", "block_id", "==", "1", "and", "module", "==", "'proj'", ":", "\n", "        ", "new_key", "=", "f'{layer_name}.{block_name}.downsample.0.{split_keys[-1]}'", "\n", "", "elif", "module", "==", "'f'", ":", "\n", "        ", "if", "split_keys", "[", "3", "]", "==", "'a_bn'", ":", "\n", "            ", "module_name", "=", "'bn1'", "\n", "", "elif", "split_keys", "[", "3", "]", "==", "'b_bn'", ":", "\n", "            ", "module_name", "=", "'bn2'", "\n", "", "elif", "split_keys", "[", "3", "]", "==", "'c_bn'", ":", "\n", "            ", "module_name", "=", "'bn3'", "\n", "", "elif", "split_keys", "[", "3", "]", "==", "'a'", ":", "\n", "            ", "module_name", "=", "'conv1'", "\n", "", "elif", "split_keys", "[", "3", "]", "==", "'b'", ":", "\n", "            ", "module_name", "=", "'conv2'", "\n", "", "elif", "split_keys", "[", "3", "]", "==", "'c'", ":", "\n", "            ", "module_name", "=", "'conv3'", "\n", "", "new_key", "=", "f'{layer_name}.{block_name}.{module_name}.{split_keys[-1]}'", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Unsupported conversion of key {model_key}'", ")", "\n", "", "print", "(", "f'Convert {model_key} to {new_key}'", ")", "\n", "state_dict", "[", "new_key", "]", "=", "model_weight", "\n", "converted_names", ".", "add", "(", "model_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert": [[54, 78], ["torch.load", "collections.OrderedDict", "set", "blobs.items", "dict", "torch.save", "regnet2mmdet.convert_stem", "print", "regnet2mmdet.convert_head", "key.startswith", "regnet2mmdet.convert_reslayer"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_stem", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.convert_reslayer"], ["", "def", "convert", "(", "src", ",", "dst", ")", ":", "\n", "    ", "\"\"\"Convert keys in pycls pretrained RegNet models to mmdet style.\"\"\"", "\n", "# load caffe model", "\n", "regnet_model", "=", "torch", ".", "load", "(", "src", ")", "\n", "blobs", "=", "regnet_model", "[", "'model_state'", "]", "\n", "# convert to pytorch style", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "converted_names", "=", "set", "(", ")", "\n", "for", "key", ",", "weight", "in", "blobs", ".", "items", "(", ")", ":", "\n", "        ", "if", "'stem'", "in", "key", ":", "\n", "            ", "convert_stem", "(", "key", ",", "weight", ",", "state_dict", ",", "converted_names", ")", "\n", "", "elif", "'head'", "in", "key", ":", "\n", "            ", "convert_head", "(", "key", ",", "weight", ",", "state_dict", ",", "converted_names", ")", "\n", "", "elif", "key", ".", "startswith", "(", "'s'", ")", ":", "\n", "            ", "convert_reslayer", "(", "key", ",", "weight", ",", "state_dict", ",", "converted_names", ")", "\n", "\n", "# check if all layers are converted", "\n", "", "", "for", "key", "in", "blobs", ":", "\n", "        ", "if", "key", "not", "in", "converted_names", ":", "\n", "            ", "print", "(", "f'not converted: {key}'", ")", "\n", "# save checkpoint", "\n", "", "", "checkpoint", "=", "dict", "(", ")", "\n", "checkpoint", "[", "'state_dict'", "]", "=", "state_dict", "\n", "torch", ".", "save", "(", "checkpoint", ",", "dst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.regnet2mmdet.main": [[80, 86], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "regnet2mmdet.convert"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.convert"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Convert model keys'", ")", "\n", "parser", ".", "add_argument", "(", "'src'", ",", "help", "=", "'src detectron model path'", ")", "\n", "parser", ".", "add_argument", "(", "'dst'", ",", "help", "=", "'save path'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "convert", "(", "args", ".", "src", ",", "args", ".", "dst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.benchmark.parse_args": [[15, 28], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'MMDet benchmark a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--log-interval'", ",", "default", "=", "50", ",", "help", "=", "'interval of logging'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--fuse-conv-bn'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether to fuse conv and bn, this will slightly increase'", "\n", "'the inference speed'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.benchmark.main": [[30, 90], ["benchmark.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "mmdet.datasets.build_dataset", "mmdet.datasets.build_dataloader", "mmdet.models.build_detector", "Config.fromfile.get", "mmcv.runner.load_checkpoint", "mmcv.parallel.MMDataParallel", "tools.fuse_conv_bn.fuse_module.eval", "enumerate", "mmdet.core.wrap_fp16_model", "tools.fuse_conv_bn.fuse_module", "torch.cuda.synchronize", "time.perf_counter", "torch.cuda.synchronize", "torch.no_grad", "tools.fuse_conv_bn.fuse_module.", "time.perf_counter", "print", "print"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.wrap_fp16_model"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "", "cfg", ".", "model", ".", "pretrained", "=", "None", "\n", "cfg", ".", "data", ".", "test", ".", "test_mode", "=", "True", "\n", "\n", "# build the dataloader", "\n", "# TODO: support multiple images per gpu (only minor changes are needed)", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "test", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "False", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# build the model and load checkpoint", "\n", "model", "=", "build_detector", "(", "cfg", ".", "model", ",", "train_cfg", "=", "None", ",", "test_cfg", "=", "cfg", ".", "test_cfg", ")", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "        ", "wrap_fp16_model", "(", "model", ")", "\n", "", "load_checkpoint", "(", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "if", "args", ".", "fuse_conv_bn", ":", "\n", "        ", "model", "=", "fuse_module", "(", "model", ")", "\n", "\n", "", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "# the first several iterations may be very slow so skip them", "\n", "num_warmup", "=", "5", "\n", "pure_inf_time", "=", "0", "\n", "\n", "# benchmark with 2000 image and take the average", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "elapsed", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", "\n", "if", "i", ">=", "num_warmup", ":", "\n", "            ", "pure_inf_time", "+=", "elapsed", "\n", "if", "(", "i", "+", "1", ")", "%", "args", ".", "log_interval", "==", "0", ":", "\n", "                ", "fps", "=", "(", "i", "+", "1", "-", "num_warmup", ")", "/", "pure_inf_time", "\n", "print", "(", "f'Done image [{i + 1:<3}/ 2000], fps: {fps:.1f} img / s'", ")", "\n", "\n", "", "", "if", "(", "i", "+", "1", ")", "==", "2000", ":", "\n", "            ", "pure_inf_time", "+=", "elapsed", "\n", "fps", "=", "(", "i", "+", "1", "-", "num_warmup", ")", "/", "pure_inf_time", "\n", "print", "(", "f'Overall fps: {fps:.1f} img / s'", ")", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test.parse_args": [[18, 94], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str", "ValueError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["data_loader", ",", "\n", "show", "=", "False", ",", "\n", "out_dir", "=", "None", ",", "\n", "show_score_thr", "=", "0.3", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "if", "show", "or", "out_dir", ":", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "\n", "for", "img", ",", "img_meta", "in", "zip", "(", "imgs", ",", "img_metas", ")", ":", "\n", "                ", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "\n", "ori_h", ",", "ori_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", ":", "-", "1", "]", "\n", "img_show", "=", "mmcv", ".", "imresize", "(", "img_show", ",", "(", "ori_w", ",", "ori_h", ")", ")", "\n", "\n", "if", "out_dir", ":", "\n", "                    ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "img_meta", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ",", "\n", "score_thr", "=", "show_score_thr", ")", "\n", "\n", "", "", "batch_size", "=", "len", "(", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", ")", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "results", ".", "append", "(", "encode_segms", "(", "[", "result", "]", ",", "dataset", ")", "[", "0", "]", ")", "\n", "", "return", "results", "\n", "\n", "\n", "", "def", "multi_gpu_test", "(", "model", ",", "data_loader", ",", "tmpdir", "=", "None", ",", "gpu_collect", "=", "False", ")", ":", "\n", "    ", "\"\"\"Test model with multiple gpus.\n\n    This method tests model with multiple gpus and collects the results\n    under two different modes: gpu and cpu modes. By setting 'gpu_collect=True'\n    it encodes results to gpu tensors and use gpu communication for results\n    collection. On cpu mode it saves the results on different gpus to 'tmpdir'\n    and collects them by the rank 0 worker.\n\n    Args:\n        model (nn.Module): Model to be tested.\n        data_loader (nn.Dataloader): Pytorch data loader.\n        tmpdir (str): Path of directory to save the temporary results from\n            different gpus under cpu mode.\n        gpu_collect (bool): Option to use either gpu or cpu to collect results.\n\n    Returns:\n        list: The prediction results.\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "", "time", ".", "sleep", "(", "2", ")", "# This line can prevent deadlock problem in some cases.", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "batch_size", "=", "(", "\n", "len", "(", "data", "[", "'img_meta'", "]", ".", "data", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test.main": [[96, 183], ["test.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "Config.fromfile.model.get", "mmdet.datasets.build_dataset", "mmdet.datasets.build_dataloader", "mmdet.models.build_detector", "Config.fromfile.get", "mmcv.runner.load_checkpoint", "mmcv.runner.get_dist_info", "ValueError", "ValueError", "Config.fromfile.merge_from_dict", "Config.fromfile.model.neck.get", "mmcv.runner.init_dist", "mmdet.core.wrap_fp16_model", "mmcv.cnn.fuse_conv_bn", "mmcv.parallel.MMDataParallel", "mmdet.apis.single_gpu_test", "mmcv.parallel.MMDistributedDataParallel", "mmdet.apis.multi_gpu_test", "parse_args.out.endswith", "Config.fromfile.model.neck.rfp_backbone.get", "mmcv.parallel.MMDistributedDataParallel.cuda", "print", "mmcv.dump", "mmdet.datasets.build_dataset.format_results", "Config.fromfile.get().copy", "cfg.get().copy.update", "print", "cfg.get().copy.pop", "dict", "mmdet.datasets.build_dataset.evaluate", "torch.cuda.current_device", "Config.fromfile.get"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.wrap_fp16_model", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.single_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.multi_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.cityscapes.CityscapesDataset.format_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["for", "_", "in", "range", "(", "batch_size", "*", "world_size", ")", ":", "\n", "                ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "results", ".", "append", "(", "encode_segms", "(", "[", "result", "]", ",", "dataset", ")", "[", "0", "]", ")", "\n", "\n", "# collect results from all ranks", "\n", "", "if", "gpu_collect", ":", "\n", "        ", "results", "=", "collect_results_gpu", "(", "results", ",", "len", "(", "dataset", ")", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "collect_results_cpu", "(", "results", ",", "len", "(", "dataset", ")", ",", "tmpdir", ")", "\n", "", "return", "results", "\n", "\n", "", "def", "encode_segms", "(", "results", ",", "dataset", ")", ":", "\n", "    ", "new_results", "=", "[", "]", "\n", "for", "result", "in", "results", ":", "\n", "# encode mask results", "\n", "        ", "if", "isinstance", "(", "result", ",", "tuple", ")", ":", "\n", "            ", "if", "len", "(", "result", ")", "==", "2", ":", "\n", "                ", "bbox_results", ",", "mask_results", "=", "result", "\n", "", "elif", "len", "(", "result", ")", "==", "3", ":", "\n", "                ", "bbox_results", ",", "mask_results", ",", "stuff_results", "=", "result", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong result.'", ")", "\n", "", "encoded_mask_results", "=", "encode_mask_results", "(", "mask_results", ")", "\n", "if", "len", "(", "result", ")", "==", "2", ":", "\n", "                ", "result", "=", "bbox_results", ",", "encoded_mask_results", "\n", "", "elif", "len", "(", "result", ")", "==", "3", ":", "\n", "                ", "stuff_segms", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "dataset", ".", "seg_ids", ")", ")", "]", "\n", "stuff_map", "=", "stuff_results", "[", "'stuff_map'", "]", "\n", "stuff_img_shape", "=", "stuff_results", "[", "'img_shape'", "]", "\n", "stuff_map", "=", "mmcv", ".", "imresize", "(", "stuff_map", ",", "stuff_img_shape", ",", "\n", "interpolation", "=", "'nearest'", ")", "\n", "unique_stuffs", "=", "np", ".", "unique", "(", "stuff_map", ")", "\n", "for", "j", "in", "unique_stuffs", ":", "\n", "                    ", "stuff_class_mask", "=", "(", "stuff_map", "==", "j", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "rle", "=", "mask_util", ".", "encode", "(", "\n", "np", ".", "array", "(", "stuff_class_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "\n", "order", "=", "'F'", ")", ")", "[", "0", "]", "\n", "stuff_segms", "[", "j", "]", ".", "append", "(", "rle", ")", "\n", "", "result", "=", "bbox_results", ",", "encoded_mask_results", ",", "stuff_segms", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong result.'", ")", "\n", "", "", "new_results", ".", "append", "(", "result", ")", "\n", "", "return", "new_results", "\n", "\n", "\n", "", "def", "collect_results_cpu", "(", "result_part", ",", "size", ",", "tmpdir", "=", "None", ")", ":", "\n", "    ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "# create a tmp dir if it is not specified", "\n", "if", "tmpdir", "is", "None", ":", "\n", "        ", "MAX_LEN", "=", "512", "\n", "# 32 is whitespace", "\n", "dir_tensor", "=", "torch", ".", "full", "(", "(", "MAX_LEN", ",", ")", ",", "\n", "32", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "\n", "device", "=", "'cuda'", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "tmpdir", "=", "torch", ".", "tensor", "(", "\n", "bytearray", "(", "tmpdir", ".", "encode", "(", ")", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "dir_tensor", "[", ":", "len", "(", "tmpdir", ")", "]", "=", "tmpdir", "\n", "", "dist", ".", "broadcast", "(", "dir_tensor", ",", "0", ")", "\n", "tmpdir", "=", "dir_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", ".", "decode", "(", ")", ".", "rstrip", "(", ")", "\n", "", "else", ":", "\n", "        ", "mmcv", ".", "mkdir_or_exist", "(", "tmpdir", ")", "\n", "# dump the part result to the dir", "\n", "", "mmcv", ".", "dump", "(", "result_part", ",", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{rank}.pkl'", ")", ")", "\n", "dist", ".", "barrier", "(", ")", "\n", "# collect all parts", "\n", "if", "rank", "!=", "0", ":", "\n", "        ", "return", "None", "\n", "", "else", ":", "\n", "# load results of all parts from tmp dir", "\n", "        ", "part_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "part_file", "=", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{i}.pkl'", ")", "\n", "part_list", ".", "append", "(", "mmcv", ".", "load", "(", "part_file", ")", ")", "\n", "# sort the results", "\n", "", "ordered_results", "=", "[", "]", "\n", "for", "res", "in", "zip", "(", "*", "part_list", ")", ":", "\n", "            ", "ordered_results", ".", "extend", "(", "list", "(", "res", ")", ")", "\n", "# the dataloader may pad some samples", "\n", "", "ordered_results", "=", "ordered_results", "[", ":", "size", "]", "\n", "# remove tmp dir", "\n", "shutil", ".", "rmtree", "(", "tmpdir", ")", "\n", "return", "ordered_results", "\n", "\n", "\n", "", "", "def", "collect_results_gpu", "(", "result_part", ",", "size", ")", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.browse_dataset.parse_args": [[11, 33], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Browse a dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--skip-type'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "'DefaultFormatBundle'", ",", "'Normalize'", ",", "'Collect'", "]", ",", "\n", "help", "=", "'skip some useless pipeline'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output-dir'", ",", "\n", "default", "=", "None", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'If there is no display interface, you can save it'", ")", "\n", "parser", ".", "add_argument", "(", "'--not-show'", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--show-interval'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "999", ",", "\n", "help", "=", "'the interval of show (ms)'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.browse_dataset.retrieve_data_cfg": [[35, 43], ["mmcv.Config.fromfile"], "function", ["None"], ["", "def", "retrieve_data_cfg", "(", "config_path", ",", "skip_type", ")", ":", "\n", "    ", "cfg", "=", "Config", ".", "fromfile", "(", "config_path", ")", "\n", "train_data_cfg", "=", "cfg", ".", "data", ".", "train", "\n", "train_data_cfg", "[", "'pipeline'", "]", "=", "[", "\n", "x", "for", "x", "in", "train_data_cfg", ".", "pipeline", "if", "x", "[", "'type'", "]", "not", "in", "skip_type", "\n", "]", "\n", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.browse_dataset.main": [[45, 65], ["browse_dataset.parse_args", "browse_dataset.retrieve_data_cfg", "mmdet.datasets.builder.build_dataset", "mmcv.ProgressBar", "len", "mmcv.imshow_det_bboxes", "mmcv.ProgressBar.update", "os.path.join", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.browse_dataset.retrieve_data_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "cfg", "=", "retrieve_data_cfg", "(", "args", ".", "config", ",", "args", ".", "skip_type", ")", "\n", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "train", ")", "\n", "\n", "progress_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "item", "in", "dataset", ":", "\n", "        ", "filename", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\n", "Path", "(", "item", "[", "'filename'", "]", ")", ".", "name", "\n", ")", "if", "args", ".", "output_dir", "is", "not", "None", "else", "None", "\n", "mmcv", ".", "imshow_det_bboxes", "(", "\n", "item", "[", "'img'", "]", ",", "\n", "item", "[", "'gt_bboxes'", "]", ",", "\n", "item", "[", "'gt_labels'", "]", "-", "1", ",", "\n", "class_names", "=", "dataset", ".", "CLASSES", ",", "\n", "show", "=", "not", "args", ".", "not_show", ",", "\n", "out_file", "=", "filename", ",", "\n", "wait_time", "=", "args", ".", "show_interval", ")", "\n", "progress_bar", ".", "update", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.is_head": [[10, 16], ["any", "key.startswith"], "function", ["None"], ["def", "is_head", "(", "key", ")", ":", "\n", "    ", "valid_head_list", "=", "[", "\n", "'bbox_head'", ",", "'mask_head'", ",", "'semantic_head'", ",", "'grid_head'", ",", "'mask_iou_head'", "\n", "]", "\n", "\n", "return", "any", "(", "key", ".", "startswith", "(", "h", ")", "for", "h", "in", "valid_head_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.parse_config": [[18, 43], ["tempfile.NamedTemporaryFile", "mmcv.Config.fromfile", "tempfile.NamedTemporaryFile.close", "open", "f.write", "isinstance"], "function", ["None"], ["", "def", "parse_config", "(", "config_strings", ")", ":", "\n", "    ", "temp_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", "\n", "config_path", "=", "f'{temp_file.name}.py'", "\n", "with", "open", "(", "config_path", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "config_strings", ")", "\n", "\n", "", "config", "=", "Config", ".", "fromfile", "(", "config_path", ")", "\n", "is_two_stage", "=", "True", "\n", "is_ssd", "=", "False", "\n", "is_retina", "=", "False", "\n", "reg_cls_agnostic", "=", "False", "\n", "if", "'rpn_head'", "not", "in", "config", ".", "model", ":", "\n", "        ", "is_two_stage", "=", "False", "\n", "# check whether it is SSD", "\n", "if", "config", ".", "model", ".", "bbox_head", ".", "type", "==", "'SSDHead'", ":", "\n", "            ", "is_ssd", "=", "True", "\n", "", "elif", "config", ".", "model", ".", "bbox_head", ".", "type", "==", "'RetinaHead'", ":", "\n", "            ", "is_retina", "=", "True", "\n", "", "", "elif", "isinstance", "(", "config", ".", "model", "[", "'bbox_head'", "]", ",", "list", ")", ":", "\n", "        ", "reg_cls_agnostic", "=", "True", "\n", "", "elif", "'reg_class_agnostic'", "in", "config", ".", "model", ".", "bbox_head", ":", "\n", "        ", "reg_cls_agnostic", "=", "config", ".", "model", ".", "bbox_head", ".", "reg_class_agnostic", "\n", "", "temp_file", ".", "close", "(", ")", "\n", "return", "is_two_stage", ",", "is_ssd", ",", "is_retina", ",", "reg_cls_agnostic", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.reorder_cls_channel": [[45, 65], ["val.dim", "torch.cat", "val.reshape", "torch.cat", "torch.cat.reshape", "val.size", "torch.cat"], "function", ["None"], ["", "def", "reorder_cls_channel", "(", "val", ",", "num_classes", "=", "81", ")", ":", "\n", "# bias", "\n", "    ", "if", "val", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "new_val", "=", "torch", ".", "cat", "(", "(", "val", "[", "1", ":", "]", ",", "val", "[", ":", "1", "]", ")", ",", "dim", "=", "0", ")", "\n", "# weight", "\n", "", "else", ":", "\n", "        ", "out_channels", ",", "in_channels", "=", "val", ".", "shape", "[", ":", "2", "]", "\n", "# conv_cls for softmax output", "\n", "if", "out_channels", "!=", "num_classes", "and", "out_channels", "%", "num_classes", "==", "0", ":", "\n", "            ", "new_val", "=", "val", ".", "reshape", "(", "-", "1", ",", "num_classes", ",", "in_channels", ",", "*", "val", ".", "shape", "[", "2", ":", "]", ")", "\n", "new_val", "=", "torch", ".", "cat", "(", "(", "new_val", "[", ":", ",", "1", ":", "]", ",", "new_val", "[", ":", ",", ":", "1", "]", ")", ",", "dim", "=", "1", ")", "\n", "new_val", "=", "new_val", ".", "reshape", "(", "val", ".", "size", "(", ")", ")", "\n", "# fc_cls", "\n", "", "elif", "out_channels", "==", "num_classes", ":", "\n", "            ", "new_val", "=", "torch", ".", "cat", "(", "(", "val", "[", "1", ":", "]", ",", "val", "[", ":", "1", "]", ")", ",", "dim", "=", "0", ")", "\n", "# agnostic | retina_cls | rpn_cls", "\n", "", "else", ":", "\n", "            ", "new_val", "=", "val", "\n", "\n", "", "", "return", "new_val", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.truncate_cls_channel": [[67, 87], ["val.dim", "new_val.reshape.reshape", "val.size", "val.reshape"], "function", ["None"], ["", "def", "truncate_cls_channel", "(", "val", ",", "num_classes", "=", "81", ")", ":", "\n", "\n", "# bias", "\n", "    ", "if", "val", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "if", "val", ".", "size", "(", "0", ")", "%", "num_classes", "==", "0", ":", "\n", "            ", "new_val", "=", "val", "[", ":", "num_classes", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "new_val", "=", "val", "\n", "# weight", "\n", "", "", "else", ":", "\n", "        ", "out_channels", ",", "in_channels", "=", "val", ".", "shape", "[", ":", "2", "]", "\n", "# conv_logits", "\n", "if", "out_channels", "%", "num_classes", "==", "0", ":", "\n", "            ", "new_val", "=", "val", ".", "reshape", "(", "num_classes", ",", "in_channels", ",", "*", "val", ".", "shape", "[", "2", ":", "]", ")", "[", "1", ":", "]", "\n", "new_val", "=", "new_val", ".", "reshape", "(", "-", "1", ",", "*", "val", ".", "shape", "[", "1", ":", "]", ")", "\n", "# agnostic", "\n", "", "else", ":", "\n", "            ", "new_val", "=", "val", "\n", "\n", "", "", "return", "new_val", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.truncate_reg_channel": [[89, 112], ["val.dim", "new_val.reshape.reshape", "new_val.reshape.reshape", "val.size", "val.reshape", "val.reshape"], "function", ["None"], ["", "def", "truncate_reg_channel", "(", "val", ",", "num_classes", "=", "81", ")", ":", "\n", "# bias", "\n", "    ", "if", "val", ".", "dim", "(", ")", "==", "1", ":", "\n", "# fc_reg|rpn_reg", "\n", "        ", "if", "val", ".", "size", "(", "0", ")", "%", "num_classes", "==", "0", ":", "\n", "            ", "new_val", "=", "val", ".", "reshape", "(", "num_classes", ",", "-", "1", ")", "[", ":", "num_classes", "-", "1", "]", "\n", "new_val", "=", "new_val", ".", "reshape", "(", "-", "1", ")", "\n", "# agnostic", "\n", "", "else", ":", "\n", "            ", "new_val", "=", "val", "\n", "# weight", "\n", "", "", "else", ":", "\n", "        ", "out_channels", ",", "in_channels", "=", "val", ".", "shape", "[", ":", "2", "]", "\n", "# fc_reg|rpn_reg", "\n", "if", "out_channels", "%", "num_classes", "==", "0", ":", "\n", "            ", "new_val", "=", "val", ".", "reshape", "(", "num_classes", ",", "-", "1", ",", "in_channels", ",", "\n", "*", "val", ".", "shape", "[", "2", ":", "]", ")", "[", "1", ":", "]", "\n", "new_val", "=", "new_val", ".", "reshape", "(", "-", "1", ",", "*", "val", ".", "shape", "[", "1", ":", "]", ")", "\n", "# agnostic", "\n", "", "else", ":", "\n", "            ", "new_val", "=", "val", "\n", "\n", "", "", "return", "new_val", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.convert": [[114, 177], ["torch.load", "torch.load.pop", "collections.OrderedDict", "upgrade_model_version.parse_config", "checkpoint.pop.items", "torch.save", "re.search", "re.search", "re.search", "re.search", "re.search", "upgrade_model_version.is_head", "print", "upgrade_model_version.reorder_cls_channel", "print", "upgrade_model_version.truncate_reg_channel", "print", "upgrade_model_version.truncate_cls_channel", "key.replace", "print", "print", "upgrade_model_version.reorder_cls_channel", "re.search.groups"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.parse_config", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.is_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.reorder_cls_channel", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.truncate_reg_channel", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.truncate_cls_channel", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.reorder_cls_channel"], ["", "def", "convert", "(", "in_file", ",", "out_file", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"Convert keys in checkpoints.\n\n    There can be some breaking changes during the development of mmdetection,\n    and this tool is used for upgrading checkpoints trained with old versions\n    to the latest one.\n    \"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "in_file", ")", "\n", "in_state_dict", "=", "checkpoint", ".", "pop", "(", "'state_dict'", ")", "\n", "out_state_dict", "=", "OrderedDict", "(", ")", "\n", "meta_info", "=", "checkpoint", "[", "'meta'", "]", "\n", "is_two_stage", ",", "is_ssd", ",", "is_retina", ",", "reg_cls_agnostic", "=", "parse_config", "(", "\n", "meta_info", "[", "'config'", "]", ")", "\n", "if", "meta_info", "[", "'mmdet_version'", "]", "<=", "'0.5.3'", "and", "is_retina", ":", "\n", "        ", "upgrade_retina", "=", "True", "\n", "", "else", ":", "\n", "        ", "upgrade_retina", "=", "False", "\n", "\n", "", "for", "key", ",", "val", "in", "in_state_dict", ".", "items", "(", ")", ":", "\n", "        ", "new_key", "=", "key", "\n", "new_val", "=", "val", "\n", "if", "is_two_stage", "and", "is_head", "(", "key", ")", ":", "\n", "            ", "new_key", "=", "'roi_head.{}'", ".", "format", "(", "key", ")", "\n", "\n", "# classification", "\n", "", "m", "=", "re", ".", "search", "(", "\n", "r'(conv_cls|retina_cls|rpn_cls|fc_cls|fcos_cls|'", "\n", "r'fovea_cls).(weight|bias)'", ",", "new_key", ")", "\n", "if", "m", "is", "not", "None", ":", "\n", "            ", "print", "(", "f'reorder cls channels of {new_key}'", ")", "\n", "new_val", "=", "reorder_cls_channel", "(", "val", ",", "num_classes", ")", "\n", "\n", "# regression", "\n", "", "m", "=", "re", ".", "search", "(", "r'(fc_reg|rpn_reg).(weight|bias)'", ",", "new_key", ")", "\n", "if", "m", "is", "not", "None", "and", "not", "reg_cls_agnostic", ":", "\n", "            ", "print", "(", "f'truncate regression channels of {new_key}'", ")", "\n", "new_val", "=", "truncate_reg_channel", "(", "val", ",", "num_classes", ")", "\n", "\n", "# mask head", "\n", "", "m", "=", "re", ".", "search", "(", "r'(conv_logits).(weight|bias)'", ",", "new_key", ")", "\n", "if", "m", "is", "not", "None", ":", "\n", "            ", "print", "(", "f'truncate mask prediction channels of {new_key}'", ")", "\n", "new_val", "=", "truncate_cls_channel", "(", "val", ",", "num_classes", ")", "\n", "\n", "", "m", "=", "re", ".", "search", "(", "r'(cls_convs|reg_convs).\\d.(weight|bias)'", ",", "key", ")", "\n", "# Legacy issues in RetinaNet since V1.x", "\n", "# Use ConvModule instead of nn.Conv2d in RetinaNet", "\n", "# cls_convs.0.weight -> cls_convs.0.conv.weight", "\n", "if", "m", "is", "not", "None", "and", "upgrade_retina", ":", "\n", "            ", "param", "=", "m", ".", "groups", "(", ")", "[", "1", "]", "\n", "new_key", "=", "key", ".", "replace", "(", "param", ",", "f'conv.{param}'", ")", "\n", "out_state_dict", "[", "new_key", "]", "=", "val", "\n", "print", "(", "f'rename the name of {key} to {new_key}'", ")", "\n", "continue", "\n", "\n", "", "m", "=", "re", ".", "search", "(", "r'(cls_convs).\\d.(weight|bias)'", ",", "key", ")", "\n", "if", "m", "is", "not", "None", "and", "is_ssd", ":", "\n", "            ", "print", "(", "f'reorder cls channels of {new_key}'", ")", "\n", "new_val", "=", "reorder_cls_channel", "(", "val", ",", "num_classes", ")", "\n", "\n", "", "out_state_dict", "[", "new_key", "]", "=", "new_val", "\n", "", "checkpoint", "[", "'state_dict'", "]", "=", "out_state_dict", "\n", "torch", ".", "save", "(", "checkpoint", ",", "out_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.main": [[179, 190], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "upgrade_model_version.convert"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.upgrade_model_version.convert"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Upgrade model version'", ")", "\n", "parser", ".", "add_argument", "(", "'in_file'", ",", "help", "=", "'input checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'out_file'", ",", "help", "=", "'output checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-classes'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "81", ",", "\n", "help", "=", "'number of classes of the original model'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "convert", "(", "args", ".", "in_file", ",", "args", ".", "out_file", ",", "args", ".", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.coco_eval_with_return": [[24, 64], ["mmcv.is_str", "isinstance", "pycocotools.coco.COCO", "result_file.endswith", "pycocotools.coco.COCO.loadRes", "pycocotools.coco.COCO.getImgIds", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "pycocotools.cocoeval.COCOeval.summarize", "list", "range", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.eval_hooks.EvalHook.evaluate"], ["def", "coco_eval_with_return", "(", "result_files", ",", "\n", "result_types", ",", "\n", "coco", ",", "\n", "max_dets", "=", "(", "100", ",", "300", ",", "1000", ")", ")", ":", "\n", "    ", "for", "res_type", "in", "result_types", ":", "\n", "        ", "assert", "res_type", "in", "[", "'proposal'", ",", "'bbox'", ",", "'segm'", ",", "'keypoints'", "]", "\n", "\n", "", "if", "mmcv", ".", "is_str", "(", "coco", ")", ":", "\n", "        ", "coco", "=", "COCO", "(", "coco", ")", "\n", "", "assert", "isinstance", "(", "coco", ",", "COCO", ")", "\n", "\n", "eval_results", "=", "{", "}", "\n", "for", "res_type", "in", "result_types", ":", "\n", "        ", "result_file", "=", "result_files", "[", "res_type", "]", "\n", "assert", "result_file", ".", "endswith", "(", "'.json'", ")", "\n", "\n", "coco_dets", "=", "coco", ".", "loadRes", "(", "result_file", ")", "\n", "img_ids", "=", "coco", ".", "getImgIds", "(", ")", "\n", "iou_type", "=", "'bbox'", "if", "res_type", "==", "'proposal'", "else", "res_type", "\n", "cocoEval", "=", "COCOeval", "(", "coco", ",", "coco_dets", ",", "iou_type", ")", "\n", "cocoEval", ".", "params", ".", "imgIds", "=", "img_ids", "\n", "if", "res_type", "==", "'proposal'", ":", "\n", "            ", "cocoEval", ".", "params", ".", "useCats", "=", "0", "\n", "cocoEval", ".", "params", ".", "maxDets", "=", "list", "(", "max_dets", ")", "\n", "", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "cocoEval", ".", "summarize", "(", ")", "\n", "if", "res_type", "==", "'segm'", "or", "res_type", "==", "'bbox'", ":", "\n", "            ", "metric_names", "=", "[", "\n", "'AP'", ",", "'AP50'", ",", "'AP75'", ",", "'APs'", ",", "'APm'", ",", "'APl'", ",", "'AR1'", ",", "'AR10'", ",", "\n", "'AR100'", ",", "'ARs'", ",", "'ARm'", ",", "'ARl'", "\n", "]", "\n", "eval_results", "[", "res_type", "]", "=", "{", "\n", "metric_names", "[", "i", "]", ":", "cocoEval", ".", "stats", "[", "i", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "metric_names", ")", ")", "\n", "}", "\n", "", "else", ":", "\n", "            ", "eval_results", "[", "res_type", "]", "=", "cocoEval", ".", "stats", "\n", "\n", "", "", "return", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.voc_eval_with_return": [[66, 91], ["mmcv.load", "mmdet.core.eval_map", "dataset.get_ann_info", "hasattr", "range", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.evaluation.mean_ap.eval_map", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.xml_style.XMLDataset.get_ann_info"], ["", "def", "voc_eval_with_return", "(", "result_file", ",", "\n", "dataset", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "logger", "=", "'print'", ",", "\n", "only_ap", "=", "True", ")", ":", "\n", "    ", "det_results", "=", "mmcv", ".", "load", "(", "result_file", ")", "\n", "annotations", "=", "[", "dataset", ".", "get_ann_info", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", "]", "\n", "if", "hasattr", "(", "dataset", ",", "'year'", ")", "and", "dataset", ".", "year", "==", "2007", ":", "\n", "        ", "dataset_name", "=", "'voc07'", "\n", "", "else", ":", "\n", "        ", "dataset_name", "=", "dataset", ".", "CLASSES", "\n", "", "mean_ap", ",", "eval_results", "=", "eval_map", "(", "\n", "det_results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "iou_thr", "=", "iou_thr", ",", "\n", "dataset", "=", "dataset_name", ",", "\n", "logger", "=", "logger", ")", "\n", "\n", "if", "only_ap", ":", "\n", "        ", "eval_results", "=", "[", "{", "\n", "'ap'", ":", "eval_results", "[", "i", "]", "[", "'ap'", "]", "\n", "}", "for", "i", "in", "range", "(", "len", "(", "eval_results", ")", ")", "]", "\n", "\n", "", "return", "mean_ap", ",", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.single_gpu_test": [[93, 116], ["model.eval", "mmcv.ProgressBar", "enumerate", "len", "isinstance", "results.append", "[].size", "range", "torch.no_grad", "torch.no_grad", "model", "model.module.show_result", "mmdet.core.encode_mask_results", "mmcv.ProgressBar.update"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.cascade_rcnn.CascadeRCNN.show_result", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.utils.encode_mask_results"], ["", "def", "single_gpu_test", "(", "model", ",", "data_loader", ",", "show", "=", "False", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "not", "show", ",", "**", "data", ")", "\n", "\n", "", "if", "show", ":", "\n", "            ", "model", ".", "module", ".", "show_result", "(", "data", ",", "result", ",", "dataset", ".", "img_norm_cfg", ")", "\n", "\n", "# encode mask results", "\n", "", "if", "isinstance", "(", "result", ",", "tuple", ")", ":", "\n", "            ", "bbox_results", ",", "mask_results", "=", "result", "\n", "encoded_mask_results", "=", "encode_mask_results", "(", "mask_results", ")", "\n", "result", "=", "bbox_results", ",", "encoded_mask_results", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "\n", "batch_size", "=", "data", "[", "'img'", "]", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.multi_gpu_test": [[118, 146], ["model.eval", "mmcv.runner.get_dist_info", "enumerate", "test_robustness.collect_results", "mmcv.ProgressBar", "collect_results.append", "collect_results.append", "len", "len", "torch.no_grad", "torch.no_grad", "model", "isinstance", "[].size", "range", "mmdet.core.encode_mask_results", "mmcv.ProgressBar.update"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.collect_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.utils.encode_mask_results"], ["", "def", "multi_gpu_test", "(", "model", ",", "data_loader", ",", "tmpdir", "=", "None", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "# encode mask results", "\n", "if", "isinstance", "(", "result", ",", "tuple", ")", ":", "\n", "                ", "bbox_results", ",", "mask_results", "=", "result", "\n", "encoded_mask_results", "=", "encode_mask_results", "(", "mask_results", ")", "\n", "result", "=", "bbox_results", ",", "encoded_mask_results", "\n", "", "", "results", ".", "append", "(", "result", ")", "\n", "\n", "results", ".", "append", "(", "result", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "batch_size", "=", "data", "[", "'img'", "]", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "for", "_", "in", "range", "(", "batch_size", "*", "world_size", ")", ":", "\n", "                ", "prog_bar", ".", "update", "(", ")", "\n", "\n", "# collect results from all ranks", "\n", "", "", "", "results", "=", "collect_results", "(", "results", ",", "len", "(", "dataset", ")", ",", "tmpdir", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.collect_results": [[148, 188], ["mmcv.runner.get_dist_info", "mmcv.dump", "torch.barrier", "torch.full", "torch.full", "torch.broadcast", "torch.full.cpu().numpy().tobytes().decode().rstrip", "mmcv.mkdir_or_exist", "os.join", "range", "zip", "shutil.rmtree", "tempfile.mkdtemp", "torch.tensor", "torch.tensor", "os.join", "part_list.append", "ordered_results.extend", "bytearray", "torch.full.cpu().numpy().tobytes().decode", "mmcv.load", "list", "torch.tensor.encode", "len", "torch.full.cpu().numpy().tobytes", "torch.full.cpu().numpy", "torch.full.cpu"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["", "def", "collect_results", "(", "result_part", ",", "size", ",", "tmpdir", "=", "None", ")", ":", "\n", "    ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "# create a tmp dir if it is not specified", "\n", "if", "tmpdir", "is", "None", ":", "\n", "        ", "MAX_LEN", "=", "512", "\n", "# 32 is whitespace", "\n", "dir_tensor", "=", "torch", ".", "full", "(", "(", "MAX_LEN", ",", ")", ",", "\n", "32", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "\n", "device", "=", "'cuda'", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "tmpdir", "=", "torch", ".", "tensor", "(", "\n", "bytearray", "(", "tmpdir", ".", "encode", "(", ")", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "dir_tensor", "[", ":", "len", "(", "tmpdir", ")", "]", "=", "tmpdir", "\n", "", "dist", ".", "broadcast", "(", "dir_tensor", ",", "0", ")", "\n", "tmpdir", "=", "dir_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", ".", "decode", "(", ")", ".", "rstrip", "(", ")", "\n", "", "else", ":", "\n", "        ", "mmcv", ".", "mkdir_or_exist", "(", "tmpdir", ")", "\n", "# dump the part result to the dir", "\n", "", "mmcv", ".", "dump", "(", "result_part", ",", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{rank}.pkl'", ")", ")", "\n", "dist", ".", "barrier", "(", ")", "\n", "# collect all parts", "\n", "if", "rank", "!=", "0", ":", "\n", "        ", "return", "None", "\n", "", "else", ":", "\n", "# load results of all parts from tmp dir", "\n", "        ", "part_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "part_file", "=", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{i}.pkl'", ")", "\n", "part_list", ".", "append", "(", "mmcv", ".", "load", "(", "part_file", ")", ")", "\n", "# sort the results", "\n", "", "ordered_results", "=", "[", "]", "\n", "for", "res", "in", "zip", "(", "*", "part_list", ")", ":", "\n", "            ", "ordered_results", ".", "extend", "(", "list", "(", "res", ")", ")", "\n", "# the dataloader may pad some samples", "\n", "", "ordered_results", "=", "ordered_results", "[", ":", "size", "]", "\n", "# remove tmp dir", "\n", "shutil", ".", "rmtree", "(", "tmpdir", ")", "\n", "return", "ordered_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.parse_args": [[190, 259], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'MMDet test detector'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "help", "=", "'output result file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--corruptions'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "'benchmark'", ",", "\n", "choices", "=", "[", "\n", "'all'", ",", "'benchmark'", ",", "'noise'", ",", "'blur'", ",", "'weather'", ",", "'digital'", ",", "\n", "'holdout'", ",", "'None'", ",", "'gaussian_noise'", ",", "'shot_noise'", ",", "'impulse_noise'", ",", "\n", "'defocus_blur'", ",", "'glass_blur'", ",", "'motion_blur'", ",", "'zoom_blur'", ",", "'snow'", ",", "\n", "'frost'", ",", "'fog'", ",", "'brightness'", ",", "'contrast'", ",", "'elastic_transform'", ",", "\n", "'pixelate'", ",", "'jpeg_compression'", ",", "'speckle_noise'", ",", "'gaussian_blur'", ",", "\n", "'spatter'", ",", "'saturate'", "\n", "]", ",", "\n", "help", "=", "'corruptions'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--severities'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ",", "\n", "help", "=", "'corruption severity levels'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--eval'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "choices", "=", "[", "'proposal'", ",", "'proposal_fast'", ",", "'bbox'", ",", "'segm'", ",", "'keypoints'", "]", ",", "\n", "help", "=", "'eval types'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--iou-thr'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "'IoU threshold for pascal voc evaluation'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--summaries'", ",", "\n", "type", "=", "bool", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'Print summaries for every corruption and severity'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--workers'", ",", "type", "=", "int", ",", "default", "=", "32", ",", "help", "=", "'workers per gpu'", ")", "\n", "parser", ".", "add_argument", "(", "'--show'", ",", "action", "=", "'store_true'", ",", "help", "=", "'show results'", ")", "\n", "parser", ".", "add_argument", "(", "'--tmpdir'", ",", "help", "=", "'tmp dir for writing some results'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "'random seed'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--final-prints'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "choices", "=", "[", "'P'", ",", "'mPC'", ",", "'rPC'", "]", ",", "\n", "default", "=", "'mPC'", ",", "\n", "help", "=", "'corruption benchmark metric to print at the end'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--final-prints-aggregate'", ",", "\n", "type", "=", "str", ",", "\n", "choices", "=", "[", "'all'", ",", "'benchmark'", "]", ",", "\n", "default", "=", "'benchmark'", ",", "\n", "help", "=", "'aggregate all results or only those for benchmark corruptions'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.main": [[261, 455], ["test_robustness.parse_args", "mmcv.Config.fromfile", "mmcv.Config.fromfile.get", "mmcv.runner.get_dist_info", "enumerate", "ValueError", "mmcv.runner.init_dist", "mmdet.apis.set_random_seed", "enumerate", "print", "parse_args.out.endswith", "copy.deepcopy", "print", "mmdet.datasets.build_dataset", "mmdet.datasets.build_dataloader", "mmdet.models.build_detector", "mmcv.Config.fromfile.get", "mmcv.runner.load_checkpoint", "robustness_eval.get_results", "robustness_eval.get_results", "dict", "test_data_cfg[].insert", "mmdet.core.wrap_fp16_model", "mmcv.parallel.MMDataParallel", "test_robustness.single_gpu_test", "mmcv.parallel.MMDistributedDataParallel", "test_robustness.multi_gpu_test", "mmcv.dump", "mmcv.dump", "mmcv.parallel.MMDistributedDataParallel.cuda", "os.splitext", "print", "test_robustness.coco_eval_with_return", "print", "torch.cuda.current_device", "torch.cuda.current_device", "os.splitext", "mmcv.runner.obj_from_dict", "test_robustness.voc_eval_with_return", "print", "isinstance", "mmdet.datasets.build_dataset.results2json", "print", "mmdet.datasets.build_dataset.results2json"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.train.set_random_seed", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.robustness_eval.get_results", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.hooks.wrap_fp16_model", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.single_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.multi_gpu_test", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.coco_eval_with_return", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tools.test_robustness.voc_eval_with_return", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.results2json", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.coco.CocoDataset.results2json"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "assert", "args", ".", "out", "or", "args", ".", "show", ",", "(", "'Please specify at least one operation (save or show the results) '", "\n", "'with the argument \"--out\" or \"--show\"'", ")", "\n", "\n", "if", "args", ".", "out", "is", "not", "None", "and", "not", "args", ".", "out", ".", "endswith", "(", "(", "'.pkl'", ",", "'.pickle'", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'The output file must be a pkl file.'", ")", "\n", "\n", "", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "", "cfg", ".", "model", ".", "pretrained", "=", "None", "\n", "cfg", ".", "data", ".", "test", ".", "test_mode", "=", "True", "\n", "if", "args", ".", "workers", "==", "0", ":", "\n", "        ", "args", ".", "workers", "=", "cfg", ".", "data", ".", "workers_per_gpu", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# set random seeds", "\n", "", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "set_random_seed", "(", "args", ".", "seed", ")", "\n", "\n", "", "if", "'all'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "\n", "'gaussian_noise'", ",", "'shot_noise'", ",", "'impulse_noise'", ",", "'defocus_blur'", ",", "\n", "'glass_blur'", ",", "'motion_blur'", ",", "'zoom_blur'", ",", "'snow'", ",", "'frost'", ",", "'fog'", ",", "\n", "'brightness'", ",", "'contrast'", ",", "'elastic_transform'", ",", "'pixelate'", ",", "\n", "'jpeg_compression'", ",", "'speckle_noise'", ",", "'gaussian_blur'", ",", "'spatter'", ",", "\n", "'saturate'", "\n", "]", "\n", "", "elif", "'benchmark'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "\n", "'gaussian_noise'", ",", "'shot_noise'", ",", "'impulse_noise'", ",", "'defocus_blur'", ",", "\n", "'glass_blur'", ",", "'motion_blur'", ",", "'zoom_blur'", ",", "'snow'", ",", "'frost'", ",", "'fog'", ",", "\n", "'brightness'", ",", "'contrast'", ",", "'elastic_transform'", ",", "'pixelate'", ",", "\n", "'jpeg_compression'", "\n", "]", "\n", "", "elif", "'noise'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "'gaussian_noise'", ",", "'shot_noise'", ",", "'impulse_noise'", "]", "\n", "", "elif", "'blur'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "\n", "'defocus_blur'", ",", "'glass_blur'", ",", "'motion_blur'", ",", "'zoom_blur'", "\n", "]", "\n", "", "elif", "'weather'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "'snow'", ",", "'frost'", ",", "'fog'", ",", "'brightness'", "]", "\n", "", "elif", "'digital'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "\n", "'contrast'", ",", "'elastic_transform'", ",", "'pixelate'", ",", "'jpeg_compression'", "\n", "]", "\n", "", "elif", "'holdout'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "'speckle_noise'", ",", "'gaussian_blur'", ",", "'spatter'", ",", "'saturate'", "]", "\n", "", "elif", "'None'", "in", "args", ".", "corruptions", ":", "\n", "        ", "corruptions", "=", "[", "'None'", "]", "\n", "args", ".", "severities", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "corruptions", "=", "args", ".", "corruptions", "\n", "\n", "", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "aggregated_results", "=", "{", "}", "\n", "for", "corr_i", ",", "corruption", "in", "enumerate", "(", "corruptions", ")", ":", "\n", "        ", "aggregated_results", "[", "corruption", "]", "=", "{", "}", "\n", "for", "sev_i", ",", "corruption_severity", "in", "enumerate", "(", "args", ".", "severities", ")", ":", "\n", "# evaluate severity 0 (= no corruption) only once", "\n", "            ", "if", "corr_i", ">", "0", "and", "corruption_severity", "==", "0", ":", "\n", "                ", "aggregated_results", "[", "corruption", "]", "[", "0", "]", "=", "aggregated_results", "[", "corruptions", "[", "0", "]", "]", "[", "0", "]", "\n", "continue", "\n", "\n", "", "test_data_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ".", "data", ".", "test", ")", "\n", "# assign corruption and severity", "\n", "if", "corruption_severity", ">", "0", ":", "\n", "                ", "corruption_trans", "=", "dict", "(", "\n", "type", "=", "'Corrupt'", ",", "\n", "corruption", "=", "corruption", ",", "\n", "severity", "=", "corruption_severity", ")", "\n", "# TODO: hard coded \"1\", we assume that the first step is", "\n", "# loading images, which needs to be fixed in the future", "\n", "test_data_cfg", "[", "'pipeline'", "]", ".", "insert", "(", "1", ",", "corruption_trans", ")", "\n", "\n", "# print info", "\n", "", "print", "(", "f'\\nTesting {corruption} at severity {corruption_severity}'", ")", "\n", "\n", "# build the dataloader", "\n", "# TODO: support multiple images per gpu", "\n", "#       (only minor changes are needed)", "\n", "dataset", "=", "build_dataset", "(", "test_data_cfg", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "workers_per_gpu", "=", "args", ".", "workers", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# build the model and load checkpoint", "\n", "model", "=", "build_detector", "(", "\n", "cfg", ".", "model", ",", "train_cfg", "=", "None", ",", "test_cfg", "=", "cfg", ".", "test_cfg", ")", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "                ", "wrap_fp16_model", "(", "model", ")", "\n", "", "checkpoint", "=", "load_checkpoint", "(", "\n", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "# old versions did not save class info in checkpoints,", "\n", "# this walkaround is for backward compatibility", "\n", "if", "'CLASSES'", "in", "checkpoint", "[", "'meta'", "]", ":", "\n", "                ", "model", ".", "CLASSES", "=", "checkpoint", "[", "'meta'", "]", "[", "'CLASSES'", "]", "\n", "", "else", ":", "\n", "                ", "model", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "\n", "", "if", "not", "distributed", ":", "\n", "                ", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "outputs", "=", "single_gpu_test", "(", "model", ",", "data_loader", ",", "args", ".", "show", ")", "\n", "", "else", ":", "\n", "                ", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ")", "\n", "outputs", "=", "multi_gpu_test", "(", "model", ",", "data_loader", ",", "args", ".", "tmpdir", ")", "\n", "\n", "", "if", "args", ".", "out", "and", "rank", "==", "0", ":", "\n", "                ", "eval_results_filename", "=", "(", "\n", "osp", ".", "splitext", "(", "args", ".", "out", ")", "[", "0", "]", "+", "'_results'", "+", "\n", "osp", ".", "splitext", "(", "args", ".", "out", ")", "[", "1", "]", ")", "\n", "mmcv", ".", "dump", "(", "outputs", ",", "args", ".", "out", ")", "\n", "eval_types", "=", "args", ".", "eval", "\n", "if", "cfg", ".", "dataset_type", "==", "'VOCDataset'", ":", "\n", "                    ", "if", "eval_types", ":", "\n", "                        ", "for", "eval_type", "in", "eval_types", ":", "\n", "                            ", "if", "eval_type", "==", "'bbox'", ":", "\n", "                                ", "test_dataset", "=", "mmcv", ".", "runner", ".", "obj_from_dict", "(", "\n", "cfg", ".", "data", ".", "test", ",", "datasets", ")", "\n", "logger", "=", "'print'", "if", "args", ".", "summaries", "else", "None", "\n", "mean_ap", ",", "eval_results", "=", "voc_eval_with_return", "(", "\n", "args", ".", "out", ",", "test_dataset", ",", "\n", "args", ".", "iou_thr", ",", "logger", ")", "\n", "aggregated_results", "[", "corruption", "]", "[", "\n", "corruption_severity", "]", "=", "eval_results", "\n", "", "else", ":", "\n", "                                ", "print", "(", "'\\nOnly \"bbox\" evaluation \\\n                                is supported for pascal voc'", ")", "\n", "", "", "", "", "else", ":", "\n", "                    ", "if", "eval_types", ":", "\n", "                        ", "print", "(", "f'Starting evaluate {\" and \".join(eval_types)}'", ")", "\n", "if", "eval_types", "==", "[", "'proposal_fast'", "]", ":", "\n", "                            ", "result_file", "=", "args", ".", "out", "\n", "", "else", ":", "\n", "                            ", "if", "not", "isinstance", "(", "outputs", "[", "0", "]", ",", "dict", ")", ":", "\n", "                                ", "result_files", "=", "dataset", ".", "results2json", "(", "\n", "outputs", ",", "args", ".", "out", ")", "\n", "", "else", ":", "\n", "                                ", "for", "name", "in", "outputs", "[", "0", "]", ":", "\n", "                                    ", "print", "(", "f'\\nEvaluating {name}'", ")", "\n", "outputs_", "=", "[", "out", "[", "name", "]", "for", "out", "in", "outputs", "]", "\n", "result_file", "=", "args", ".", "out", "\n", "+", "f'.{name}'", "\n", "result_files", "=", "dataset", ".", "results2json", "(", "\n", "outputs_", ",", "result_file", ")", "\n", "", "", "", "eval_results", "=", "coco_eval_with_return", "(", "\n", "result_files", ",", "eval_types", ",", "dataset", ".", "coco", ")", "\n", "aggregated_results", "[", "corruption", "]", "[", "\n", "corruption_severity", "]", "=", "eval_results", "\n", "", "else", ":", "\n", "                        ", "print", "(", "'\\nNo task was selected for evaluation;'", "\n", "'\\nUse --eval to select a task'", ")", "\n", "\n", "# save results after each evaluation", "\n", "", "", "mmcv", ".", "dump", "(", "aggregated_results", ",", "eval_results_filename", ")", "\n", "\n", "", "", "", "if", "rank", "==", "0", ":", "\n", "# print filan results", "\n", "        ", "print", "(", "'\\nAggregated results:'", ")", "\n", "prints", "=", "args", ".", "final_prints", "\n", "aggregate", "=", "args", ".", "final_prints_aggregate", "\n", "\n", "if", "cfg", ".", "dataset_type", "==", "'VOCDataset'", ":", "\n", "            ", "get_results", "(", "\n", "eval_results_filename", ",", "\n", "dataset", "=", "'voc'", ",", "\n", "prints", "=", "prints", ",", "\n", "aggregate", "=", "aggregate", ")", "\n", "", "else", ":", "\n", "            ", "get_results", "(", "\n", "eval_results_filename", ",", "\n", "dataset", "=", "'coco'", ",", "\n", "prints", "=", "prints", ",", "\n", "aggregate", "=", "aggregate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.2channels2panoptic_coco_format.convert_single_core": [[35, 86], ["enumerate", "print", "numpy.zeros", "mmdet.core.IdGenerator", "numpy.unique", "annotations.append", "PIL.fromarray().save", "print", "numpy.array", "mmdet.core.IdGenerator.get_id_and_color", "segm_info.append", "os.join", "len", "image_info[].rsplit", "PIL.open", "KeyError", "KeyError", "PIL.fromarray", "len", "os.join"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id_and_color"], ["@", "get_traceback", "\n", "def", "convert_single_core", "(", "proc_id", ",", "image_set", ",", "categories", ",", "\n", "source_folder", ",", "segmentations_folder", ",", "VOID", "=", "0", ")", ":", "\n", "    ", "annotations", "=", "[", "]", "\n", "for", "working_idx", ",", "image_info", "in", "enumerate", "(", "image_set", ")", ":", "\n", "        ", "if", "working_idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "\n", "'Core: {}, {} from {} images converted'", ".", "format", "(", "\n", "proc_id", ",", "\n", "working_idx", ",", "\n", "len", "(", "image_set", ")", ")", ")", "\n", "\n", "", "file_name", "=", "'{}.png'", ".", "format", "(", "image_info", "[", "'file_name'", "]", ".", "rsplit", "(", "'.'", ")", "[", "0", "]", ")", "\n", "try", ":", "\n", "            ", "original_format", "=", "np", ".", "array", "(", "\n", "Image", ".", "open", "(", "\n", "osp", ".", "join", "(", "source_folder", ",", "file_name", ")", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "", "except", "IOError", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "'no prediction png file for id: {}'", ".", "format", "(", "\n", "image_info", "[", "'id'", "]", ")", ")", "\n", "\n", "", "pan", "=", "OFFSET", "*", "original_format", "[", ":", ",", ":", ",", "0", "]", "+", "original_format", "[", ":", ",", ":", ",", "1", "]", "\n", "pan_format", "=", "np", ".", "zeros", "(", "\n", "(", "original_format", ".", "shape", "[", "0", "]", ",", "original_format", ".", "shape", "[", "1", "]", ",", "3", ")", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "id_generator", "=", "IdGenerator", "(", "categories", ")", "\n", "\n", "unique_ids", "=", "np", ".", "unique", "(", "pan", ")", "\n", "segm_info", "=", "[", "]", "\n", "for", "el", "in", "unique_ids", ":", "\n", "            ", "sem", "=", "el", "//", "OFFSET", "\n", "if", "sem", "==", "VOID", ":", "\n", "                ", "continue", "\n", "", "if", "sem", "not", "in", "categories", ":", "\n", "                ", "raise", "KeyError", "(", "'Unknown semantic label {}'", ".", "format", "(", "sem", ")", ")", "\n", "", "mask", "=", "pan", "==", "el", "\n", "segment_id", ",", "color", "=", "id_generator", ".", "get_id_and_color", "(", "sem", ")", "\n", "pan_format", "[", "mask", "]", "=", "color", "\n", "segm_info", ".", "append", "(", "{", "\"id\"", ":", "segment_id", ",", "\n", "\"category_id\"", ":", "sem", "}", ")", "\n", "\n", "", "annotations", ".", "append", "(", "{", "'image_id'", ":", "image_info", "[", "'id'", "]", ",", "\n", "'file_name'", ":", "file_name", ",", "\n", "\"segments_info\"", ":", "segm_info", "}", ")", "\n", "\n", "Image", ".", "fromarray", "(", "pan_format", ")", ".", "save", "(", "\n", "osp", ".", "join", "(", "segmentations_folder", ",", "file_name", ")", ")", "\n", "", "print", "(", "'Core: {}, all {} images processed'", ".", "format", "(", "proc_id", ",", "len", "(", "image_set", ")", ")", ")", "\n", "return", "annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.2channels2panoptic_coco_format.converter": [[88, 139], ["time.time", "print", "mmcv.load", "mmcv.load", "print", "print", "print", "print", "print", "print", "print", "print", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "print", "mmcv.dump", "print", "os.isdir", "print", "os.mkdir", "os.mkdir", "multiprocessing.Pool.apply_async", "processes.append", "annotations.extend", "time.time", "predictions_json_file.rsplit", "len", "workers.apply_async.get"], "function", ["None"], ["", "def", "converter", "(", "source_folder", ",", "images_json_file", ",", "categories_json_file", ",", "\n", "segmentations_folder", ",", "predictions_json_file", ",", "\n", "VOID", "=", "0", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "print", "(", "\"Reading image set information from {}\"", ".", "format", "(", "images_json_file", ")", ")", "\n", "\n", "d_coco", "=", "mmcv", ".", "load", "(", "images_json_file", ")", "\n", "images", "=", "d_coco", "[", "'images'", "]", "\n", "\n", "categories_coco", "=", "mmcv", ".", "load", "(", "categories_json_file", ")", "\n", "categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "categories_coco", "}", "\n", "\n", "if", "segmentations_folder", "is", "None", ":", "\n", "        ", "segmentations_folder", "=", "predictions_json_file", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "", "if", "not", "osp", ".", "isdir", "(", "segmentations_folder", ")", ":", "\n", "        ", "print", "(", "\"Creating folder {} for panoptic segmentation PNGs\"", ".", "format", "(", "\n", "segmentations_folder", ")", ")", "\n", "os", ".", "mkdir", "(", "segmentations_folder", ")", "\n", "\n", "", "print", "(", "\"CONVERTING...\"", ")", "\n", "print", "(", "\"2 channels panoptic format:\"", ")", "\n", "print", "(", "\"\\tSource folder: {}\"", ".", "format", "(", "source_folder", ")", ")", "\n", "print", "(", "\"TO\"", ")", "\n", "print", "(", "\"COCO panoptic format:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "segmentations_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "predictions_json_file", ")", ")", "\n", "print", "(", "'\\n'", ")", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "images_split", "=", "np", ".", "array_split", "(", "images", ",", "cpu_num", ")", "\n", "print", "(", "\n", "\"Number of cores: {}, images per core: {}\"", ".", "format", "(", "\n", "cpu_num", ",", "len", "(", "\n", "images_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "image_set", "in", "enumerate", "(", "images_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "convert_single_core", ",", "\n", "(", "proc_id", ",", "image_set", ",", "categories", ",", "\n", "source_folder", ",", "segmentations_folder", ",", "VOID", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "annotations", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "annotations", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "\n", "", "print", "(", "\"Writing final JSON in {}\"", ".", "format", "(", "predictions_json_file", ")", ")", "\n", "d_coco", "[", "'annotations'", "]", "=", "annotations", "\n", "mmcv", ".", "dump", "(", "d_coco", ",", "predictions_json_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.detection2panoptic_coco_format.convert_detection_to_panoptic_coco_format_single_core": [[22, 70], ["mmdet.core.IdGenerator", "enumerate", "print", "numpy.zeros", "numpy.zeros", "coco_detection.getAnnIds", "coco_detection.loadAnns", "annotations_panoptic.append", "PIL.fromarray().save", "print", "coco_detection.loadImgs", "mmdet.core.IdGenerator.get_id_and_color", "coco_detection.annToMask", "ann.pop", "ann.pop", "segments_info.append", "numpy.sum", "Exception", "os.join", "len", "int", "img[].rsplit", "Exception", "PIL.fromarray", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id_and_color"], ["@", "get_traceback", "\n", "def", "convert_detection_to_panoptic_coco_format_single_core", "(", "\n", "proc_id", ",", "coco_detection", ",", "img_ids", ",", "categories", ",", "segmentations_folder", ")", ":", "\n", "    ", "id_generator", "=", "IdGenerator", "(", "categories", ")", "\n", "\n", "annotations_panoptic", "=", "[", "]", "\n", "for", "working_idx", ",", "img_id", "in", "enumerate", "(", "img_ids", ")", ":", "\n", "        ", "if", "working_idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "'Core: {}, {} from {} images processed'", ".", "format", "(", "\n", "proc_id", ",", "working_idx", ",", "len", "(", "img_ids", ")", ")", ")", "\n", "", "img", "=", "coco_detection", ".", "loadImgs", "(", "int", "(", "img_id", ")", ")", "[", "0", "]", "\n", "pan_format", "=", "np", ".", "zeros", "(", "(", "img", "[", "'height'", "]", ",", "img", "[", "'width'", "]", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "overlaps_map", "=", "np", ".", "zeros", "(", "(", "img", "[", "'height'", "]", ",", "img", "[", "'width'", "]", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "\n", "anns_ids", "=", "coco_detection", ".", "getAnnIds", "(", "img_id", ")", "\n", "anns", "=", "coco_detection", ".", "loadAnns", "(", "anns_ids", ")", "\n", "\n", "panoptic_record", "=", "{", "}", "\n", "panoptic_record", "[", "'image_id'", "]", "=", "img_id", "\n", "file_name", "=", "'{}.png'", ".", "format", "(", "img", "[", "'file_name'", "]", ".", "rsplit", "(", "'.'", ")", "[", "0", "]", ")", "\n", "panoptic_record", "[", "'file_name'", "]", "=", "file_name", "\n", "segments_info", "=", "[", "]", "\n", "for", "ann", "in", "anns", ":", "\n", "            ", "if", "ann", "[", "'category_id'", "]", "not", "in", "categories", ":", "\n", "                ", "raise", "Exception", "(", "'Panoptic coco categories file does not '", "\n", "'contain category with id: {}'", ".", "\n", "format", "(", "ann", "[", "'category_id'", "]", ")", ")", "\n", "", "segment_id", ",", "color", "=", "id_generator", ".", "get_id_and_color", "(", "\n", "ann", "[", "'category_id'", "]", ")", "\n", "mask", "=", "coco_detection", ".", "annToMask", "(", "ann", ")", "\n", "overlaps_map", "+=", "mask", "\n", "pan_format", "[", "mask", "==", "1", "]", "=", "color", "\n", "ann", ".", "pop", "(", "'segmentation'", ")", "\n", "ann", ".", "pop", "(", "'image_id'", ")", "\n", "ann", "[", "'id'", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "ann", ")", "\n", "\n", "", "if", "np", ".", "sum", "(", "overlaps_map", ">", "1", ")", "!=", "0", ":", "\n", "            ", "raise", "Exception", "(", "\"Segments for image {} overlap each other.\"", ".", "\n", "format", "(", "img_id", ")", ")", "\n", "", "panoptic_record", "[", "'segments_info'", "]", "=", "segments_info", "\n", "annotations_panoptic", ".", "append", "(", "panoptic_record", ")", "\n", "\n", "Image", ".", "fromarray", "(", "pan_format", ")", ".", "save", "(", "\n", "osp", ".", "join", "(", "segmentations_folder", ",", "file_name", ")", ")", "\n", "\n", "", "print", "(", "'Core: {}, all {} images processed'", ".", "format", "(", "proc_id", ",", "len", "(", "img_ids", ")", ")", ")", "\n", "return", "annotations_panoptic", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.detection2panoptic_coco_format.convert_detection_to_panoptic_coco_format": [[72, 123], ["time.time", "print", "print", "print", "print", "print", "print", "print", "print", "pycocotools.coco.COCO", "pycocotools.coco.COCO.getImgIds", "mmcv.load", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "mmcv.load", "mmcv.dump", "print", "os.isdir", "print", "os.mkdir", "os.mkdir", "multiprocessing.Pool.apply_async", "processes.append", "annotations_coco_panoptic.extend", "time.time", "output_json_file.rsplit", "len", "workers.apply_async.get"], "function", ["None"], ["", "def", "convert_detection_to_panoptic_coco_format", "(", "input_json_file", ",", "\n", "segmentations_folder", ",", "\n", "output_json_file", ",", "\n", "categories_json_file", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "segmentations_folder", "is", "None", ":", "\n", "        ", "segmentations_folder", "=", "output_json_file", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "", "if", "not", "osp", ".", "isdir", "(", "segmentations_folder", ")", ":", "\n", "        ", "print", "(", "\"Creating folder {} for panoptic segmentation PNGs\"", ".", "\n", "format", "(", "segmentations_folder", ")", ")", "\n", "os", ".", "mkdir", "(", "segmentations_folder", ")", "\n", "\n", "", "print", "(", "\"CONVERTING...\"", ")", "\n", "print", "(", "\"COCO detection format:\"", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "input_json_file", ")", ")", "\n", "print", "(", "\"TO\"", ")", "\n", "print", "(", "\"COCO panoptic format\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "segmentations_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "output_json_file", ")", ")", "\n", "print", "(", "'\\n'", ")", "\n", "\n", "coco_detection", "=", "COCO", "(", "input_json_file", ")", "\n", "img_ids", "=", "coco_detection", ".", "getImgIds", "(", ")", "\n", "\n", "categories_list", "=", "mmcv", ".", "load", "(", "categories_json_file", ")", "\n", "categories", "=", "{", "category", "[", "'id'", "]", ":", "category", "for", "category", "in", "categories_list", "}", "\n", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "img_ids_split", "=", "np", ".", "array_split", "(", "img_ids", ",", "cpu_num", ")", "\n", "print", "(", "\"Number of cores: {}, images per core: {}\"", ".", "\n", "format", "(", "cpu_num", ",", "len", "(", "img_ids_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "img_ids", "in", "enumerate", "(", "img_ids_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "\n", "convert_detection_to_panoptic_coco_format_single_core", ",", "\n", "(", "proc_id", ",", "coco_detection", ",", "img_ids", ",", "categories", ",", "\n", "segmentations_folder", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "annotations_coco_panoptic", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "annotations_coco_panoptic", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "\n", "", "d_coco", "=", "mmcv", ".", "load", "(", "input_json_file", ")", "\n", "d_coco", "[", "'annotations'", "]", "=", "annotations_coco_panoptic", "\n", "d_coco", "[", "'categories'", "]", "=", "categories_list", "\n", "mmcv", ".", "dump", "(", "d_coco", ",", "output_json_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.panoptic2semantic_segmentation.extract_semantic_single_core": [[29, 89], ["enumerate", "print", "mmdet.core.rgb2id", "numpy.zeros", "collections.defaultdict", "print", "numpy.array", "PIL.fromarray().save", "collections.defaultdict.items", "len", "PIL.open", "KeyError", "pycocotools.mask.encode", "RLE_per_category[].append", "os.join", "int", "list", "annotation_semantic_seg.append", "len", "os.join", "numpy.asfortranarray", "PIL.fromarray", "len", "pycocotools.mask.merge", "pycocotools.mask.area", "pycocotools.mask.toBbox", "pycocotools.mask.astype"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["@", "get_traceback", "\n", "def", "extract_semantic_single_core", "(", "proc_id", ",", "\n", "annotations_set", ",", "\n", "segmentations_folder", ",", "\n", "output_json_file", ",", "\n", "semantic_seg_folder", ",", "\n", "categories", ",", "\n", "save_as_png", ",", "\n", "things_other", ")", ":", "\n", "    ", "annotation_semantic_seg", "=", "[", "]", "\n", "for", "working_idx", ",", "annotation", "in", "enumerate", "(", "annotations_set", ")", ":", "\n", "        ", "if", "working_idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "'Core: {}, {} from {} images processed'", ".", "\n", "format", "(", "proc_id", ",", "working_idx", ",", "len", "(", "annotations_set", ")", ")", ")", "\n", "", "try", ":", "\n", "            ", "pan_format", "=", "np", ".", "array", "(", "\n", "Image", ".", "open", "(", "osp", ".", "join", "(", "\n", "segmentations_folder", ",", "annotation", "[", "'file_name'", "]", ")", ")", ",", "\n", "dtype", "=", "np", ".", "uint32", "\n", ")", "\n", "", "except", "IOError", ":", "\n", "            ", "raise", "KeyError", "(", "'no prediction png file for id: {}'", ".", "\n", "format", "(", "annotation", "[", "'image_id'", "]", ")", ")", "\n", "\n", "", "pan", "=", "rgb2id", "(", "pan_format", ")", "\n", "semantic", "=", "np", ".", "zeros", "(", "pan", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "RLE_per_category", "=", "defaultdict", "(", "list", ")", "\n", "for", "segm_info", "in", "annotation", "[", "'segments_info'", "]", ":", "\n", "            ", "cat_id", "=", "segm_info", "[", "'category_id'", "]", "\n", "if", "things_other", "and", "categories", "[", "cat_id", "]", "[", "'isthing'", "]", "==", "1", ":", "\n", "                ", "cat_id", "=", "OTHER_CLASS_ID", "\n", "", "mask", "=", "pan", "==", "segm_info", "[", "'id'", "]", "\n", "if", "save_as_png", ":", "\n", "                ", "semantic", "[", "mask", "]", "=", "cat_id", "\n", "", "else", ":", "\n", "                ", "RLE", "=", "COCOmask", ".", "encode", "(", "np", ".", "asfortranarray", "(", "mask", ".", "astype", "(", "'uint8'", ")", ")", ")", "\n", "RLE_per_category", "[", "cat_id", "]", ".", "append", "(", "RLE", ")", "\n", "\n", "", "", "if", "save_as_png", ":", "\n", "            ", "Image", ".", "fromarray", "(", "semantic", ")", ".", "save", "(", "\n", "osp", ".", "join", "(", "semantic_seg_folder", ",", "annotation", "[", "'file_name'", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "for", "cat_id", ",", "RLE_list", "in", "RLE_per_category", ".", "items", "(", ")", ":", "\n", "                ", "if", "len", "(", "RLE_list", ")", "==", "1", ":", "\n", "                    ", "RLE", "=", "RLE_list", "[", "0", "]", "\n", "", "else", ":", "\n", "                    ", "RLE", "=", "COCOmask", ".", "merge", "(", "RLE_list", ")", "\n", "", "semantic_seg_record", "=", "{", "}", "\n", "semantic_seg_record", "[", "\"image_id\"", "]", "=", "annotation", "[", "'image_id'", "]", "\n", "semantic_seg_record", "[", "\"category_id\"", "]", "=", "cat_id", "\n", "semantic_seg_record", "[", "\"segmentation\"", "]", "=", "RLE", "\n", "semantic_seg_record", "[", "\"area\"", "]", "=", "int", "(", "COCOmask", ".", "area", "(", "RLE", ")", ")", "\n", "semantic_seg_record", "[", "\"bbox\"", "]", "=", "list", "(", "COCOmask", ".", "toBbox", "(", "RLE", ")", ")", "\n", "semantic_seg_record", "[", "\"iscrowd\"", "]", "=", "0", "\n", "annotation_semantic_seg", ".", "append", "(", "semantic_seg_record", ")", "\n", "", "", "", "print", "(", "'Core: {}, all {} images processed'", ".", "\n", "format", "(", "proc_id", ",", "len", "(", "annotations_set", ")", ")", ")", "\n", "\n", "return", "annotation_semantic_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.panoptic2semantic_segmentation.extract_semantic": [[91, 176], ["time.time", "mmcv.load", "print", "print", "print", "print", "print", "print", "mmcv.load", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "print", "Exception", "print", "print", "print", "multiprocessing.Pool.apply_async", "processes.append", "annotations_coco_semantic_seg.extend", "enumerate", "mmcv.dump", "time.time", "input_json_file.rsplit", "Exception", "print", "print", "len", "workers.apply_async.get", "category.pop", "category.pop", "categories_coco_semantic_seg.append", "categories_coco_semantic_seg.append", "os.isdir", "print", "os.mkdir", "os.mkdir"], "function", ["None"], ["", "def", "extract_semantic", "(", "input_json_file", ",", "\n", "segmentations_folder", ",", "\n", "output_json_file", ",", "\n", "semantic_seg_folder", ",", "\n", "categories_json_file", ",", "\n", "things_other", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "d_coco", "=", "mmcv", ".", "load", "(", "input_json_file", ")", "\n", "annotations", "=", "d_coco", "[", "'annotations'", "]", "\n", "\n", "if", "segmentations_folder", "is", "None", ":", "\n", "        ", "segmentations_folder", "=", "input_json_file", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "\n", "", "print", "(", "\"EXTRACTING FROM...\"", ")", "\n", "print", "(", "\"COCO panoptic format:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "segmentations_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "input_json_file", ")", ")", "\n", "print", "(", "\"SEMANTIC SEGMENTATION\"", ")", "\n", "\n", "if", "output_json_file", "is", "not", "None", "and", "semantic_seg_folder", "is", "not", "None", ":", "\n", "        ", "raise", "Exception", "(", "\"'--output_json_file' and '--semantic_seg_folder' \"", "\n", "\"options cannot be used together\"", ")", "\n", "\n", "", "save_as_png", "=", "False", "\n", "if", "output_json_file", "is", "None", ":", "\n", "        ", "if", "semantic_seg_folder", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"One of '--output_json_file' and \"", "\n", "\"'--semantic_seg_folder' options must be used \"", "\n", "\"specified\"", ")", "\n", "", "else", ":", "\n", "            ", "save_as_png", "=", "True", "\n", "print", "(", "\"in PNG format:\"", ")", "\n", "print", "(", "\"\\tFolder with semnatic segmentations: {}\"", ".", "\n", "format", "(", "semantic_seg_folder", ")", ")", "\n", "if", "not", "osp", ".", "isdir", "(", "semantic_seg_folder", ")", ":", "\n", "                ", "print", "(", "\"Creating folder {} for semantic segmentation PNGs\"", ".", "\n", "format", "(", "semantic_seg_folder", ")", ")", "\n", "os", ".", "mkdir", "(", "semantic_seg_folder", ")", "\n", "", "", "", "else", ":", "\n", "        ", "print", "(", "\"in COCO detection format:\"", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "output_json_file", ")", ")", "\n", "", "if", "things_other", ":", "\n", "        ", "print", "(", "\"Merging all things categories into 'other' category\"", ")", "\n", "", "print", "(", "'\\n'", ")", "\n", "\n", "categories_list", "=", "mmcv", ".", "load", "(", "categories_json_file", ")", "\n", "categories", "=", "{", "category", "[", "'id'", "]", ":", "category", "for", "category", "in", "categories_list", "}", "\n", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "annotations_split", "=", "np", ".", "array_split", "(", "annotations", ",", "cpu_num", ")", "\n", "print", "(", "\"Number of cores: {}, images per core: {}\"", ".", "\n", "format", "(", "cpu_num", ",", "len", "(", "annotations_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "annotations_set", "in", "enumerate", "(", "annotations_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "extract_semantic_single_core", ",", "\n", "(", "proc_id", ",", "annotations_set", ",", "\n", "segmentations_folder", ",", "\n", "output_json_file", ",", "semantic_seg_folder", ",", "\n", "categories", ",", "save_as_png", ",", "things_other", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "annotations_coco_semantic_seg", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "annotations_coco_semantic_seg", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "\n", "", "if", "not", "save_as_png", ":", "\n", "        ", "for", "idx", ",", "ann", "in", "enumerate", "(", "annotations_coco_semantic_seg", ")", ":", "\n", "            ", "ann", "[", "'id'", "]", "=", "idx", "\n", "", "d_coco", "[", "'annotations'", "]", "=", "annotations_coco_semantic_seg", "\n", "categories_coco_semantic_seg", "=", "[", "]", "\n", "for", "category", "in", "categories_list", ":", "\n", "            ", "if", "things_other", "and", "category", "[", "'isthing'", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "category", ".", "pop", "(", "'isthing'", ")", "\n", "category", ".", "pop", "(", "'color'", ")", "\n", "categories_coco_semantic_seg", ".", "append", "(", "category", ")", "\n", "", "if", "things_other", ":", "\n", "            ", "categories_coco_semantic_seg", ".", "append", "(", "{", "'id'", ":", "OTHER_CLASS_ID", ",", "\n", "'name'", ":", "'other'", ",", "\n", "'supercategory'", ":", "'other'", "}", ")", "\n", "", "d_coco", "[", "'categories'", "]", "=", "categories_coco_semantic_seg", "\n", "mmcv", ".", "dump", "(", "d_coco", ",", "output_json_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.cityscape_panoptic_converter.cityscape_panoptic_converter": [[134, 242], ["out_folder_format.format", "enumerate", "original_folder_format.format", "os.join", "sorted", "enumerate", "mmcv.dump", "mmcv.dump", "os.isdir", "print", "os.mkdir", "os.mkdir", "categories.append", "glob.glob", "numpy.array", "images.append", "numpy.zeros", "mmdet.core.IdGenerator", "numpy.unique", "annotations.append", "PIL.fromarray().save", "out_file_format.format", "print", "PIL.open", "f.split", "f.split", "file_name.rsplit", "mmdet.core.IdGenerator.get_id_and_color", "numpy.sum", "numpy.sum", "numpy.sum", "segm_info.append", "os.path.join", "os.path.join", "len", "numpy.nonzero", "numpy.nonzero", "PIL.fromarray", "int", "int"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.IdGenerator.get_id_and_color"], ["", "", "def", "cityscape_panoptic_converter", "(", "original_folder_format", ",", "\n", "out_folder_format", ",", "\n", "out_file_format", ",", "\n", "category_file", ",", "\n", "data_split", ")", ":", "\n", "    ", "\"\"\"Convert the gt files in original folder to a new panoptic json file\n    and convert the gt png into a new panoptic directory..\n\n    Args:\n        original_folder_format (str): The gt folder for specific data split.\n        out_folder_format (str): The new panoptic folder.\n        out_file_format (str): Json file in coco style to save the annotations.\n        category_file (str): The category file path.\n        data_split (str): The split of data, e.g., ['train', 'val', 'test']\n    \"\"\"", "\n", "out_folder", "=", "out_folder_format", ".", "format", "(", "data_split", ")", "\n", "if", "not", "osp", ".", "isdir", "(", "out_folder", ")", ":", "\n", "        ", "print", "(", "\"Creating folder {} for panoptic segmentation PNGs\"", ".", "\n", "format", "(", "out_folder", ")", ")", "\n", "os", ".", "mkdir", "(", "out_folder", ")", "\n", "\n", "", "categories", "=", "[", "]", "\n", "for", "idx", ",", "el", "in", "enumerate", "(", "labels", ")", ":", "\n", "        ", "if", "el", ".", "ignoreInEval", ":", "\n", "            ", "continue", "\n", "", "categories", ".", "append", "(", "{", "'id'", ":", "el", ".", "id", ",", "\n", "'name'", ":", "el", ".", "name", ",", "\n", "'color'", ":", "el", ".", "color", ",", "\n", "'supercategory'", ":", "el", ".", "category", ",", "\n", "'isthing'", ":", "1", "if", "el", ".", "hasInstances", "else", "0", "}", ")", "\n", "\n", "", "categories_dict", "=", "{", "cat", "[", "'id'", "]", ":", "cat", "for", "cat", "in", "categories", "}", "\n", "\n", "original_folder", "=", "original_folder_format", ".", "format", "(", "data_split", ")", "\n", "glob_pattern", "=", "osp", ".", "join", "(", "original_folder", ",", "'*/*_gtFine_instanceIds.png'", ")", "\n", "file_list", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_pattern", ")", ")", "\n", "\n", "images", "=", "[", "]", "\n", "annotations", "=", "[", "]", "\n", "for", "working_idx", ",", "f", "in", "enumerate", "(", "file_list", ")", ":", "\n", "        ", "if", "working_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "working_idx", ",", "len", "(", "file_list", ")", ")", "\n", "\n", "", "original_format", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "f", ")", ")", "\n", "\n", "dir", "=", "f", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "file_name", "=", "f", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "image_id", "=", "file_name", ".", "rsplit", "(", "'_'", ",", "2", ")", "[", "0", "]", "\n", "image_filename", "=", "'{}/{}_leftImg8bit.png'", ".", "format", "(", "dir", ",", "image_id", ")", "\n", "# image entry, id for image is its filename without extension", "\n", "images", ".", "append", "(", "{", "\"id\"", ":", "image_id", ",", "\n", "\"width\"", ":", "original_format", ".", "shape", "[", "1", "]", ",", "\n", "\"height\"", ":", "original_format", ".", "shape", "[", "0", "]", ",", "\n", "\"file_name\"", ":", "image_filename", "}", ")", "\n", "\n", "pan_format", "=", "np", ".", "zeros", "(", "\n", "(", "original_format", ".", "shape", "[", "0", "]", ",", "original_format", ".", "shape", "[", "1", "]", ",", "3", ")", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "\n", "id_generator", "=", "IdGenerator", "(", "categories_dict", ")", "\n", "\n", "unique_ids", "=", "np", ".", "unique", "(", "original_format", ")", "\n", "segm_info", "=", "[", "]", "\n", "for", "el", "in", "unique_ids", ":", "\n", "            ", "if", "el", "<", "1000", ":", "\n", "                ", "semantic_id", "=", "el", "\n", "is_crowd", "=", "1", "\n", "", "else", ":", "\n", "                ", "semantic_id", "=", "el", "//", "1000", "\n", "is_crowd", "=", "0", "\n", "", "if", "semantic_id", "not", "in", "categories_dict", ":", "\n", "                ", "continue", "\n", "", "if", "categories_dict", "[", "semantic_id", "]", "[", "'isthing'", "]", "==", "0", ":", "\n", "                ", "is_crowd", "=", "0", "\n", "", "mask", "=", "original_format", "==", "el", "\n", "segment_id", ",", "color", "=", "id_generator", ".", "get_id_and_color", "(", "semantic_id", ")", "\n", "pan_format", "[", "mask", "]", "=", "color", "\n", "\n", "area", "=", "np", ".", "sum", "(", "mask", ")", "# segment area computation", "\n", "\n", "# bbox computation for a segment", "\n", "hor", "=", "np", ".", "sum", "(", "mask", ",", "axis", "=", "0", ")", "\n", "hor_idx", "=", "np", ".", "nonzero", "(", "hor", ")", "[", "0", "]", "\n", "x", "=", "hor_idx", "[", "0", "]", "\n", "width", "=", "hor_idx", "[", "-", "1", "]", "-", "x", "+", "1", "\n", "vert", "=", "np", ".", "sum", "(", "mask", ",", "axis", "=", "1", ")", "\n", "vert_idx", "=", "np", ".", "nonzero", "(", "vert", ")", "[", "0", "]", "\n", "y", "=", "vert_idx", "[", "0", "]", "\n", "height", "=", "vert_idx", "[", "-", "1", "]", "-", "y", "+", "1", "\n", "bbox", "=", "[", "x", ",", "y", ",", "width", ",", "height", "]", "\n", "\n", "segm_info", ".", "append", "(", "{", "\"id\"", ":", "int", "(", "segment_id", ")", ",", "\n", "\"category_id\"", ":", "int", "(", "semantic_id", ")", ",", "\n", "\"area\"", ":", "area", ",", "\n", "\"bbox\"", ":", "bbox", ",", "\n", "\"iscrowd\"", ":", "is_crowd", "}", ")", "\n", "\n", "", "annotations", ".", "append", "(", "{", "'image_id'", ":", "image_id", ",", "\n", "'file_name'", ":", "file_name", ",", "\n", "\"segments_info\"", ":", "segm_info", "}", ")", "\n", "\n", "Image", ".", "fromarray", "(", "pan_format", ")", ".", "save", "(", "os", ".", "path", ".", "join", "(", "out_folder", ",", "file_name", ")", ")", "\n", "\n", "", "d", "=", "{", "'images'", ":", "images", ",", "\n", "'annotations'", ":", "annotations", ",", "\n", "'categories'", ":", "categories", ",", "\n", "}", "\n", "mmcv", ".", "dump", "(", "categories", ",", "category_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "mmcv", ".", "dump", "(", "d", ",", "out_file_format", ".", "format", "(", "data_split", ")", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.cityscape_panoptic_converter.main": [[244, 258], ["print", "cityscape_panoptic_converter.cityscape_panoptic_converter"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.cityscape_panoptic_converter.cityscape_panoptic_converter"], ["", "def", "main", "(", ")", ":", "\n", "    ", "data_root", "=", "'/nfsdata1/home/chenqiang/code/panoptic_segmentation/mmdetection/data/cityscape/'", "# noqa", "\n", "original_folder_format", "=", "data_root", "+", "'gtFine/{}/'", "\n", "out_folder_format", "=", "data_root", "+", "'cityscapes_panoptic_{}/'", "\n", "out_file_format", "=", "data_root", "+", "'cityscapes_panoptic_{}.json'", "\n", "category_file", "=", "data_root", "+", "'panoptic_cityscape_categories.json'", "\n", "data_splits", "=", "[", "'val'", "]", "\n", "for", "data_split", "in", "data_splits", ":", "\n", "        ", "print", "(", "'Data split: {}'", ".", "format", "(", "data_split", ")", ")", "\n", "cityscape_panoptic_converter", "(", "original_folder_format", ",", "\n", "out_folder_format", ",", "\n", "out_file_format", ",", "\n", "category_file", ",", "\n", "data_split", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.panoptic2detection_coco_format.convert_panoptic_to_detection_coco_format_single_core": [[25, 62], ["enumerate", "print", "mmdet.core.rgb2id", "print", "numpy.array", "numpy.expand_dims", "segm_info.pop", "annotations_detection.append", "len", "annotation[].rsplit", "PIL.open", "KeyError", "pycocotools.mask.encode", "len", "os.join", "numpy.asfortranarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.utils.panoptic_utils.rgb2id", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["@", "get_traceback", "\n", "def", "convert_panoptic_to_detection_coco_format_single_core", "(", "proc_id", ",", "\n", "annotations_set", ",", "\n", "categories", ",", "\n", "segmentations_folder", ",", "\n", "things_only", ")", ":", "\n", "    ", "annotations_detection", "=", "[", "]", "\n", "for", "working_idx", ",", "annotation", "in", "enumerate", "(", "annotations_set", ")", ":", "\n", "        ", "if", "working_idx", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "'Core: {}, {} from {} images processed'", ".", "\n", "format", "(", "proc_id", ",", "working_idx", ",", "len", "(", "annotations_set", ")", ")", ")", "\n", "\n", "", "file_name", "=", "'{}.png'", ".", "format", "(", "annotation", "[", "'file_name'", "]", ".", "rsplit", "(", "'.'", ")", "[", "0", "]", ")", "\n", "try", ":", "\n", "            ", "pan_format", "=", "np", ".", "array", "(", "\n", "Image", ".", "open", "(", "osp", ".", "join", "(", "segmentations_folder", ",", "file_name", ")", ")", ",", "\n", "dtype", "=", "np", ".", "uint32", ")", "\n", "", "except", "IOError", ":", "\n", "            ", "raise", "KeyError", "(", "'no prediction png file for id: {}'", ".", "\n", "format", "(", "annotation", "[", "'image_id'", "]", ")", ")", "\n", "", "pan", "=", "rgb2id", "(", "pan_format", ")", "\n", "\n", "for", "segm_info", "in", "annotation", "[", "'segments_info'", "]", ":", "\n", "            ", "if", "things_only", "and", "categories", "[", "segm_info", "[", "'category_id'", "]", "]", "[", "'isthing'", "]", "!=", "1", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "pan", "==", "segm_info", "[", "'id'", "]", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask", "=", "np", ".", "expand_dims", "(", "mask", ",", "axis", "=", "2", ")", "\n", "segm_info", ".", "pop", "(", "'id'", ")", "\n", "segm_info", "[", "'image_id'", "]", "=", "annotation", "[", "'image_id'", "]", "\n", "segm_info", "[", "'segmentation'", "]", "=", "COCOmask", ".", "encode", "(", "\n", "np", ".", "asfortranarray", "(", "mask", ")", ")", "[", "0", "]", "\n", "annotations_detection", ".", "append", "(", "segm_info", ")", "\n", "\n", "", "", "print", "(", "'Core: {}, all {} images processed'", ".", "\n", "format", "(", "proc_id", ",", "len", "(", "annotations_set", ")", ")", ")", "\n", "return", "annotations_detection", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.panoptic_converters.panoptic2detection_coco_format.convert_panoptic_to_detection_coco_format": [[64, 124], ["time.time", "print", "print", "print", "print", "print", "print", "print", "print", "print", "mmcv.load", "mmcv.load", "multiprocessing.cpu_count", "numpy.array_split", "print", "multiprocessing.Pool", "enumerate", "enumerate", "mmcv.dump", "print", "print", "multiprocessing.Pool.apply_async", "processes.append", "annotations_coco_detection.extend", "category.pop", "category.pop", "categories_coco_detection.append", "time.time", "input_json_file.rsplit", "len", "workers.apply_async.get"], "function", ["None"], ["", "def", "convert_panoptic_to_detection_coco_format", "(", "input_json_file", ",", "\n", "segmentations_folder", ",", "\n", "output_json_file", ",", "\n", "categories_json_file", ",", "\n", "things_only", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "segmentations_folder", "is", "None", ":", "\n", "        ", "segmentations_folder", "=", "input_json_file", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "\n", "", "print", "(", "\"CONVERTING...\"", ")", "\n", "print", "(", "\"COCO panoptic format:\"", ")", "\n", "print", "(", "\"\\tSegmentation folder: {}\"", ".", "format", "(", "segmentations_folder", ")", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "input_json_file", ")", ")", "\n", "print", "(", "\"TO\"", ")", "\n", "print", "(", "\"COCO detection format\"", ")", "\n", "print", "(", "\"\\tJSON file: {}\"", ".", "format", "(", "output_json_file", ")", ")", "\n", "if", "things_only", ":", "\n", "        ", "print", "(", "\"Saving only segments of things classes.\"", ")", "\n", "", "print", "(", "'\\n'", ")", "\n", "\n", "print", "(", "\"Reading annotation information from {}\"", ".", "format", "(", "input_json_file", ")", ")", "\n", "d_coco", "=", "mmcv", ".", "load", "(", "input_json_file", ")", "\n", "annotations_panoptic", "=", "d_coco", "[", "'annotations'", "]", "\n", "\n", "categories_list", "=", "mmcv", ".", "load", "(", "categories_json_file", ")", "\n", "categories", "=", "{", "category", "[", "'id'", "]", ":", "category", "for", "category", "in", "categories_list", "}", "\n", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "annotations_split", "=", "np", ".", "array_split", "(", "annotations_panoptic", ",", "cpu_num", ")", "\n", "print", "(", "\"Number of cores: {}, images per core: {}\"", ".", "\n", "format", "(", "cpu_num", ",", "len", "(", "annotations_split", "[", "0", "]", ")", ")", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "annotations_set", "in", "enumerate", "(", "annotations_split", ")", ":", "\n", "        ", "p", "=", "workers", ".", "apply_async", "(", "\n", "convert_panoptic_to_detection_coco_format_single_core", ",", "\n", "(", "proc_id", ",", "annotations_set", ",", "categories", ",", "\n", "segmentations_folder", ",", "things_only", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "annotations_coco_detection", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "        ", "annotations_coco_detection", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "", "for", "idx", ",", "ann", "in", "enumerate", "(", "annotations_coco_detection", ")", ":", "\n", "        ", "ann", "[", "'id'", "]", "=", "idx", "\n", "\n", "", "d_coco", "[", "'annotations'", "]", "=", "annotations_coco_detection", "\n", "categories_coco_detection", "=", "[", "]", "\n", "# for category in d_coco['categories']:", "\n", "for", "category", "in", "categories_list", ":", "\n", "        ", "if", "things_only", "and", "category", "[", "'isthing'", "]", "!=", "1", ":", "\n", "            ", "continue", "\n", "", "category", ".", "pop", "(", "'isthing'", ")", "\n", "category", ".", "pop", "(", "'color'", ")", "\n", "categories_coco_detection", ".", "append", "(", "category", ")", "\n", "", "d_coco", "[", "'categories'", "]", "=", "categories_coco_detection", "\n", "mmcv", ".", "dump", "(", "d_coco", ",", "output_json_file", ",", "cls", "=", "MyJsonEncoder", ")", "\n", "\n", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.collect_files": [[11, 26], ["glob.glob", "len", "print", "os.join", "img_file.endswith", "files.append", "len", "len", "len", "len", "len"], "function", ["None"], ["import", "pycocotools", ".", "mask", "as", "maskUtils", "\n", "from", "mmcv", ".", "utils", "import", "print_log", "\n", "\n", "from", ".", "builder", "import", "DATASETS", "\n", "from", ".", "coco", "import", "CocoDataset", "\n", "\n", "\n", "@", "DATASETS", ".", "register_module", "(", ")", "\n", "class", "CityscapesDataset", "(", "CocoDataset", ")", ":", "\n", "\n", "    ", "CLASSES", "=", "(", "'person'", ",", "'rider'", ",", "'car'", ",", "'truck'", ",", "'bus'", ",", "'train'", ",", "'motorcycle'", ",", "\n", "'bicycle'", ")", "\n", "\n", "def", "_filter_imgs", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small or without ground truths.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.collect_annotations": [[28, 37], ["print", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["for", "i", ",", "img_info", "in", "enumerate", "(", "self", ".", "data_infos", ")", ":", "\n", "            ", "img_id", "=", "img_info", "[", "'id'", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "[", "img_id", "]", ")", "\n", "ann_info", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "all_iscrowd", "=", "all", "(", "[", "_", "[", "'iscrowd'", "]", "for", "_", "in", "ann_info", "]", ")", "\n", "if", "self", ".", "filter_empty_gt", "and", "(", "self", ".", "img_ids", "[", "i", "]", "not", "in", "ids_with_ann", "\n", "or", "all_iscrowd", ")", ":", "\n", "                ", "continue", "\n", "", "if", "min", "(", "img_info", "[", "'width'", "]", ",", "img_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.load_img_info": [[39, 82], ["mmcv.imread", "numpy.unique", "os.basename", "dict", "int", "numpy.asarray", "pycocotools.area", "pycocotools.toBbox", "mask_rle[].decode", "dict", "anno_info.append", "os.dirname", "pycocotools.encode", "os.join", "os.join", "maskUtils.toBbox.tolist", "maskUtils.area.tolist", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.decode", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.coder.legacy_delta_xywh_bbox_coder.LegacyDeltaXYWHBBoxCoder.encode"], ["\n", "", "def", "_parse_ann_info", "(", "self", ",", "img_info", ",", "ann_info", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n\n        Args:\n            img_info (dict): Image info of an image.\n            ann_info (list[dict]): Annotation info of an image.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, \\\n                bboxes_ignore, labels, masks, seg_map. \\\n                \"masks\" are already decoded into binary masks.\n        \"\"\"", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_bboxes_ignore", "=", "[", "]", "\n", "gt_masks_ann", "=", "[", "]", "\n", "\n", "for", "i", ",", "ann", "in", "enumerate", "(", "ann_info", ")", ":", "\n", "            ", "if", "ann", ".", "get", "(", "'ignore'", ",", "False", ")", ":", "\n", "                ", "continue", "\n", "", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "if", "ann", "[", "'area'", "]", "<=", "0", "or", "w", "<", "1", "or", "h", "<", "1", ":", "\n", "                ", "continue", "\n", "", "if", "ann", "[", "'category_id'", "]", "not", "in", "self", ".", "cat_ids", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", "\n", "if", "ann", ".", "get", "(", "'iscrowd'", ",", "False", ")", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_labels", ".", "append", "(", "self", ".", "cat2label", "[", "ann", "[", "'category_id'", "]", "]", ")", "\n", "gt_masks_ann", ".", "append", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.cvt_annotations": [[84, 111], ["dict", "mmcv.dump", "image_info.pop", "out_json[].append", "len", "dict.pop", "out_json[].append", "dict", "out_json[].append"], "function", ["None"], ["\n", "", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "\n", "labels", "=", "gt_labels", ",", "\n", "bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "masks", "=", "gt_masks_ann", ",", "\n", "seg_map", "=", "img_info", "[", "'segm_file'", "]", ")", "\n", "\n", "return", "ann", "\n", "\n", "", "def", "results2txt", "(", "self", ",", "results", ",", "outfile_prefix", ")", ":", "\n", "        ", "\"\"\"Dump the detection results to a txt file.\n\n        Args:\n            results (list[list | tuple]): Testing results of the\n                dataset.\n            outfile_prefix (str): The filename prefix of the json files.\n                If the prefix is \"somepath/xxx\",\n                the txt files will be named \"somepath/xxx.txt\".\n\n        Returns:\n            list[str]: Result txt files which contains corresponding \\\n                instance segmentation images.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "import", "cityscapesscripts", ".", "helpers", ".", "labels", "as", "CSLabels", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please run \"pip install citscapesscripts\" to '", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.parse_args": [[113, 124], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "result_files", "=", "[", "]", "\n", "os", ".", "makedirs", "(", "outfile_prefix", ",", "exist_ok", "=", "True", ")", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "self", ")", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "result", "=", "results", "[", "idx", "]", "\n", "filename", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'filename'", "]", "\n", "basename", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "filename", ")", ")", "[", "0", "]", "\n", "pred_txt", "=", "osp", ".", "join", "(", "outfile_prefix", ",", "basename", "+", "'_pred.txt'", ")", "\n", "\n", "bbox_result", ",", "segm_result", "=", "result", "\n", "bboxes", "=", "np", ".", "vstack", "(", "bbox_result", ")", "\n", "# segm results", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.main": [[126, 148], ["cityscapes.parse_args", "mmcv.mkdir_or_exist", "os.join", "os.join", "dict", "dict.items", "print", "mmcv.Timer", "cityscapes.collect_files", "cityscapes.collect_annotations", "cityscapes.cvt_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.collect_files", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.cityscapes.collect_annotations", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.cvt_annotations"], ["# Some detectors use different scores for bbox and mask,", "\n", "# like Mask Scoring R-CNN. Score of segm will be used instead", "\n", "# of bbox score.", "\n", "                ", "segms", "=", "mmcv", ".", "concat_list", "(", "segm_result", "[", "0", "]", ")", "\n", "mask_score", "=", "segm_result", "[", "1", "]", "\n", "", "else", ":", "\n", "# use bbox score for mask score", "\n", "                ", "segms", "=", "mmcv", ".", "concat_list", "(", "segm_result", ")", "\n", "mask_score", "=", "[", "bbox", "[", "-", "1", "]", "for", "bbox", "in", "bboxes", "]", "\n", "", "labels", "=", "[", "\n", "np", ".", "full", "(", "bbox", ".", "shape", "[", "0", "]", ",", "i", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", ",", "bbox", "in", "enumerate", "(", "bbox_result", ")", "\n", "]", "\n", "labels", "=", "np", ".", "concatenate", "(", "labels", ")", "\n", "\n", "assert", "len", "(", "bboxes", ")", "==", "len", "(", "segms", ")", "==", "len", "(", "labels", ")", "\n", "num_instances", "=", "len", "(", "bboxes", ")", "\n", "prog_bar", ".", "update", "(", ")", "\n", "with", "open", "(", "pred_txt", ",", "'w'", ")", "as", "fout", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "                    ", "pred_class", "=", "labels", "[", "i", "]", "\n", "classes", "=", "self", ".", "CLASSES", "[", "pred_class", "]", "\n", "class_id", "=", "CSLabels", ".", "name2label", "[", "classes", "]", ".", "id", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_xml": [[13, 65], ["xml.parse", "ET.parse.getroot", "tree.getroot.find", "int", "int", "tree.getroot.findall", "int", "obj.find", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.zeros", "numpy.zeros", "numpy.array", "root.find.find", "root.find.find", "obj.find", "int", "int", "int", "int", "np.zeros.append", "np.array.append", "np.zeros.append", "np.array.append", "numpy.array", "numpy.array", "np.zeros.astype", "np.array.astype", "np.zeros.astype", "np.array.astype", "obj.find", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find"], "function", ["None"], ["def", "parse_xml", "(", "args", ")", ":", "\n", "    ", "xml_path", ",", "img_path", "=", "args", "\n", "tree", "=", "ET", ".", "parse", "(", "xml_path", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "size", "=", "root", ".", "find", "(", "'size'", ")", "\n", "w", "=", "int", "(", "size", ".", "find", "(", "'width'", ")", ".", "text", ")", "\n", "h", "=", "int", "(", "size", ".", "find", "(", "'height'", ")", ".", "text", ")", "\n", "bboxes", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "bboxes_ignore", "=", "[", "]", "\n", "labels_ignore", "=", "[", "]", "\n", "for", "obj", "in", "root", ".", "findall", "(", "'object'", ")", ":", "\n", "        ", "name", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", "\n", "label", "=", "label_ids", "[", "name", "]", "\n", "difficult", "=", "int", "(", "obj", ".", "find", "(", "'difficult'", ")", ".", "text", ")", "\n", "bnd_box", "=", "obj", ".", "find", "(", "'bndbox'", ")", "\n", "bbox", "=", "[", "\n", "int", "(", "bnd_box", ".", "find", "(", "'xmin'", ")", ".", "text", ")", ",", "\n", "int", "(", "bnd_box", ".", "find", "(", "'ymin'", ")", ".", "text", ")", ",", "\n", "int", "(", "bnd_box", ".", "find", "(", "'xmax'", ")", ".", "text", ")", ",", "\n", "int", "(", "bnd_box", ".", "find", "(", "'ymax'", ")", ".", "text", ")", "\n", "]", "\n", "if", "difficult", ":", "\n", "            ", "bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "labels_ignore", ".", "append", "(", "label", ")", "\n", "", "else", ":", "\n", "            ", "bboxes", ".", "append", "(", "bbox", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "if", "not", "bboxes", ":", "\n", "        ", "bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "labels", "=", "np", ".", "zeros", "(", "(", "0", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "bboxes", "=", "np", ".", "array", "(", "bboxes", ",", "ndmin", "=", "2", ")", "-", "1", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "", "if", "not", "bboxes_ignore", ":", "\n", "        ", "bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "labels_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "bboxes_ignore", "=", "np", ".", "array", "(", "bboxes_ignore", ",", "ndmin", "=", "2", ")", "-", "1", "\n", "labels_ignore", "=", "np", ".", "array", "(", "labels_ignore", ")", "\n", "", "annotation", "=", "{", "\n", "'filename'", ":", "img_path", ",", "\n", "'width'", ":", "w", ",", "\n", "'height'", ":", "h", ",", "\n", "'ann'", ":", "{", "\n", "'bboxes'", ":", "bboxes", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'labels'", ":", "labels", ".", "astype", "(", "np", ".", "int64", ")", ",", "\n", "'bboxes_ignore'", ":", "bboxes_ignore", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'labels_ignore'", ":", "labels_ignore", ".", "astype", "(", "np", ".", "int64", ")", "\n", "}", "\n", "}", "\n", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.cvt_annotations": [[67, 91], ["mmcv.dump", "isinstance", "os.join", "mmcv.list_from_file", "mmcv.track_progress", "annotations.extend", "os.isfile", "print", "os.join", "list", "zip"], "function", ["None"], ["", "def", "cvt_annotations", "(", "devkit_path", ",", "years", ",", "split", ",", "out_file", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "years", ",", "list", ")", ":", "\n", "        ", "years", "=", "[", "years", "]", "\n", "", "annotations", "=", "[", "]", "\n", "for", "year", "in", "years", ":", "\n", "        ", "filelist", "=", "osp", ".", "join", "(", "devkit_path", ",", "\n", "f'VOC{year}/ImageSets/Main/{split}.txt'", ")", "\n", "if", "not", "osp", ".", "isfile", "(", "filelist", ")", ":", "\n", "            ", "print", "(", "f'filelist does not exist: {filelist}, '", "\n", "f'skip voc{year} {split}'", ")", "\n", "return", "\n", "", "img_names", "=", "mmcv", ".", "list_from_file", "(", "filelist", ")", "\n", "xml_paths", "=", "[", "\n", "osp", ".", "join", "(", "devkit_path", ",", "f'VOC{year}/Annotations/{img_name}.xml'", ")", "\n", "for", "img_name", "in", "img_names", "\n", "]", "\n", "img_paths", "=", "[", "\n", "f'VOC{year}/JPEGImages/{img_name}.jpg'", "for", "img_name", "in", "img_names", "\n", "]", "\n", "part_annotations", "=", "mmcv", ".", "track_progress", "(", "parse_xml", ",", "\n", "list", "(", "zip", "(", "xml_paths", ",", "img_paths", ")", ")", ")", "\n", "annotations", ".", "extend", "(", "part_annotations", ")", "\n", "", "mmcv", ".", "dump", "(", "annotations", ",", "out_file", ")", "\n", "return", "annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args": [[93, 100], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert PASCAL VOC annotations to mmdetection format'", ")", "\n", "parser", ".", "add_argument", "(", "'devkit_path'", ",", "help", "=", "'pascal voc devkit path'", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out-dir'", ",", "help", "=", "'output path'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.main": [[102, 136], ["pascal_voc.parse_args", "mmcv.mkdir_or_exist", "os.isdir", "os.isdir", "print", "os.join", "years.append", "os.join", "years.append", "years.append", "IOError", "print", "pascal_voc.cvt_annotations", "isinstance", "print", "pascal_voc.cvt_annotations", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.parse_args", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.cvt_annotations", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.convert_datasets.pascal_voc.cvt_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "devkit_path", "=", "args", ".", "devkit_path", "\n", "out_dir", "=", "args", ".", "out_dir", "if", "args", ".", "out_dir", "else", "devkit_path", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "\n", "years", "=", "[", "]", "\n", "if", "osp", ".", "isdir", "(", "osp", ".", "join", "(", "devkit_path", ",", "'VOC2007'", ")", ")", ":", "\n", "        ", "years", ".", "append", "(", "'2007'", ")", "\n", "", "if", "osp", ".", "isdir", "(", "osp", ".", "join", "(", "devkit_path", ",", "'VOC2012'", ")", ")", ":", "\n", "        ", "years", ".", "append", "(", "'2012'", ")", "\n", "", "if", "'2007'", "in", "years", "and", "'2012'", "in", "years", ":", "\n", "        ", "years", ".", "append", "(", "[", "'2007'", ",", "'2012'", "]", ")", "\n", "", "if", "not", "years", ":", "\n", "        ", "raise", "IOError", "(", "f'The devkit path {devkit_path} contains neither '", "\n", "'\"VOC2007\" nor \"VOC2012\" subfolder'", ")", "\n", "", "for", "year", "in", "years", ":", "\n", "        ", "if", "year", "==", "'2007'", ":", "\n", "            ", "prefix", "=", "'voc07'", "\n", "", "elif", "year", "==", "'2012'", ":", "\n", "            ", "prefix", "=", "'voc12'", "\n", "", "elif", "year", "==", "[", "'2007'", ",", "'2012'", "]", ":", "\n", "            ", "prefix", "=", "'voc0712'", "\n", "", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'trainval'", "]", ":", "\n", "            ", "dataset_name", "=", "prefix", "+", "'_'", "+", "split", "\n", "print", "(", "f'processing {dataset_name} ...'", ")", "\n", "cvt_annotations", "(", "devkit_path", ",", "year", ",", "split", ",", "\n", "osp", ".", "join", "(", "out_dir", ",", "dataset_name", "+", "'.pkl'", ")", ")", "\n", "", "if", "not", "isinstance", "(", "year", ",", "list", ")", ":", "\n", "            ", "dataset_name", "=", "prefix", "+", "'_test'", "\n", "print", "(", "f'processing {dataset_name} ...'", ")", "\n", "cvt_annotations", "(", "devkit_path", ",", "year", ",", "'test'", ",", "\n", "osp", ".", "join", "(", "out_dir", ",", "dataset_name", "+", "'.pkl'", ")", ")", "\n", "", "", "print", "(", "'Done!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.docs.conf.get_version": [[26, 30], ["open", "exec", "locals", "compile", "f.read"], "function", ["None"], ["def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_version.test_version_check": [[4, 16], ["mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version", "mmdet.digit_version"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mmdet.__init__.digit_version"], ["def", "test_version_check", "(", ")", ":", "\n", "    ", "assert", "digit_version", "(", "'1.0.5'", ")", ">", "digit_version", "(", "'1.0.5rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.5'", ")", ">", "digit_version", "(", "'1.0.4rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.5'", ")", ">", "digit_version", "(", "'1.0rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.0'", ")", ">", "digit_version", "(", "'0.6.2'", ")", "\n", "assert", "digit_version", "(", "'1.0.0'", ")", ">", "digit_version", "(", "'0.2.16'", ")", "\n", "assert", "digit_version", "(", "'1.0.5rc0'", ")", ">", "digit_version", "(", "'1.0.0rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.0rc1'", ")", ">", "digit_version", "(", "'1.0.0rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.0rc2'", ")", ">", "digit_version", "(", "'1.0.0rc0'", ")", "\n", "assert", "digit_version", "(", "'1.0.0rc2'", ")", ">", "digit_version", "(", "'1.0.0rc1'", ")", "\n", "assert", "digit_version", "(", "'1.0.1rc1'", ")", ">", "digit_version", "(", "'1.0.0rc1'", ")", "\n", "assert", "digit_version", "(", "'1.0.0'", ")", ">", "digit_version", "(", "'1.0.0rc1'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_fp16.test_cast_tensor_type": [[10, 50], ["torch.FloatTensor", "torch.FloatTensor", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "numpy.array", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "dict", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "mmdet.core.fp16.utils.cast_tensor_type", "isinstance", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.utils.cast_tensor_type"], ["def", "test_cast_tensor_type", "(", ")", ":", "\n", "    ", "inputs", "=", "torch", ".", "FloatTensor", "(", "[", "5.", "]", ")", "\n", "src_type", "=", "torch", ".", "float32", "\n", "dst_type", "=", "torch", ".", "int32", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "src_type", ",", "dst_type", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "torch", ".", "Tensor", ")", "\n", "assert", "outputs", ".", "dtype", "==", "dst_type", "\n", "\n", "inputs", "=", "'tensor'", "\n", "src_type", "=", "str", "\n", "dst_type", "=", "str", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "src_type", ",", "dst_type", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "str", ")", "\n", "\n", "inputs", "=", "np", ".", "array", "(", "[", "5.", "]", ")", "\n", "src_type", "=", "np", ".", "ndarray", "\n", "dst_type", "=", "np", ".", "ndarray", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "src_type", ",", "dst_type", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "np", ".", "ndarray", ")", "\n", "\n", "inputs", "=", "dict", "(", "\n", "tensor_a", "=", "torch", ".", "FloatTensor", "(", "[", "1.", "]", ")", ",", "tensor_b", "=", "torch", ".", "FloatTensor", "(", "[", "2.", "]", ")", ")", "\n", "src_type", "=", "torch", ".", "float32", "\n", "dst_type", "=", "torch", ".", "int32", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "src_type", ",", "dst_type", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "dict", ")", "\n", "assert", "outputs", "[", "'tensor_a'", "]", ".", "dtype", "==", "dst_type", "\n", "assert", "outputs", "[", "'tensor_b'", "]", ".", "dtype", "==", "dst_type", "\n", "\n", "inputs", "=", "[", "torch", ".", "FloatTensor", "(", "[", "1.", "]", ")", ",", "torch", ".", "FloatTensor", "(", "[", "2.", "]", ")", "]", "\n", "src_type", "=", "torch", ".", "float32", "\n", "dst_type", "=", "torch", ".", "int32", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "src_type", ",", "dst_type", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "list", ")", "\n", "assert", "outputs", "[", "0", "]", ".", "dtype", "==", "dst_type", "\n", "assert", "outputs", "[", "1", "]", ".", "dtype", "==", "dst_type", "\n", "\n", "inputs", "=", "5", "\n", "outputs", "=", "cast_tensor_type", "(", "inputs", ",", "None", ",", "None", ")", "\n", "assert", "isinstance", "(", "outputs", ",", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_fp16.test_auto_fp16": [[52, 176], ["ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "pytest.raises", "ExampleObject", "torch.ones", "torch.ones", "ExampleObject.", "mmdet.core.auto_fp16", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.auto_fp16", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.auto_fp16", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.auto_fp16", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.auto_fp16", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.auto_fp16"], ["", "def", "test_auto_fp16", "(", ")", ":", "\n", "\n", "    ", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "# ExampleObject is not a subclass of nn.Module", "\n", "\n", "        ", "class", "ExampleObject", "(", "object", ")", ":", "\n", "\n", "            ", "@", "auto_fp16", "(", ")", "\n", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "model", "=", "ExampleObject", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "model", "(", "input_x", ")", "\n", "\n", "# apply to all input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "            ", "return", "x", ",", "y", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ".", "cuda", "(", ")", ",", "input_y", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "# apply to specified input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "auto_fp16", "(", "apply_to", "=", "(", "'x'", ",", ")", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "            ", "return", "x", ",", "y", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ".", "cuda", "(", ")", ",", "input_y", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "# apply to optional input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "auto_fp16", "(", "apply_to", "=", "(", "'x'", ",", "'y'", ")", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "            ", "return", "x", ",", "y", ",", "z", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_z", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "\n", "input_x", ".", "cuda", "(", ")", ",", "y", "=", "input_y", ".", "cuda", "(", ")", ",", "z", "=", "input_z", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "# out_fp32=True", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "auto_fp16", "(", "apply_to", "=", "(", "'x'", ",", "'y'", ")", ",", "out_fp32", "=", "True", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "            ", "return", "x", ",", "y", ",", "z", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_z", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "\n", "input_x", ".", "cuda", "(", ")", ",", "y", "=", "input_y", ".", "cuda", "(", ")", ",", "z", "=", "input_z", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_fp16.test_force_fp32": [[178, 302], ["ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "ExampleModule", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "ExampleObject.", "ExampleObject.", "torch.cuda.is_available", "torch.cuda.is_available", "pytest.raises", "ExampleObject", "torch.ones", "torch.ones", "ExampleObject.", "mmdet.core.force_fp32", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.force_fp32", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.force_fp32", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.force_fp32", "ExampleObject.cuda", "ExampleObject.", "mmdet.core.force_fp32", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda", "torch.ones.cuda"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.fp16.decorators.force_fp32"], ["", "", "def", "test_force_fp32", "(", ")", ":", "\n", "\n", "    ", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "# ExampleObject is not a subclass of nn.Module", "\n", "\n", "        ", "class", "ExampleObject", "(", "object", ")", ":", "\n", "\n", "            ", "@", "force_fp32", "(", ")", "\n", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "model", "=", "ExampleObject", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "model", "(", "input_x", ")", "\n", "\n", "# apply to all input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "force_fp32", "(", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "            ", "return", "x", ",", "y", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ".", "cuda", "(", ")", ",", "input_y", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "# apply to specified input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "force_fp32", "(", "apply_to", "=", "(", "'x'", ",", ")", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "            ", "return", "x", ",", "y", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ",", "input_y", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", "=", "model", "(", "input_x", ".", "cuda", "(", ")", ",", "input_y", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "# apply to optional input args", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "force_fp32", "(", "apply_to", "=", "(", "'x'", ",", "'y'", ")", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "            ", "return", "x", ",", "y", ",", "z", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_z", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "\n", "input_x", ".", "cuda", "(", ")", ",", "y", "=", "input_y", ".", "cuda", "(", ")", ",", "z", "=", "input_z", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "# out_fp16=True", "\n", "", "class", "ExampleModule", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "        ", "@", "force_fp32", "(", "apply_to", "=", "(", "'x'", ",", "'y'", ")", ",", "out_fp16", "=", "True", ")", "\n", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ",", "z", "=", "None", ")", ":", "\n", "            ", "return", "x", ",", "y", ",", "z", "\n", "\n", "", "", "model", "=", "ExampleModule", "(", ")", "\n", "input_x", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "input_y", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "input_z", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "half", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "float32", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "model", ".", "fp16_enabled", "=", "True", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "input_x", ",", "y", "=", "input_y", ",", "z", "=", "input_z", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "output_x", ",", "output_y", ",", "output_z", "=", "model", "(", "\n", "input_x", ".", "cuda", "(", ")", ",", "y", "=", "input_y", ".", "cuda", "(", ")", ",", "z", "=", "input_z", ".", "cuda", "(", ")", ")", "\n", "assert", "output_x", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_y", ".", "dtype", "==", "torch", ".", "half", "\n", "assert", "output_z", ".", "dtype", "==", "torch", ".", "half", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.AsyncTestCase._run_test_method": [[23, 28], ["method", "asyncio.iscoroutine", "test_async.AsyncTestCase.loop.run_until_complete", "asyncio.wait_for"], "methods", ["None"], ["def", "_run_test_method", "(", "self", ",", "method", ")", ":", "\n", "        ", "result", "=", "method", "(", ")", "\n", "if", "asyncio", ".", "iscoroutine", "(", "result", ")", ":", "\n", "            ", "self", ".", "loop", ".", "run_until_complete", "(", "\n", "asyncio", ".", "wait_for", "(", "result", ",", "timeout", "=", "self", ".", "TEST_TIMEOUT", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_async.MaskRCNNDetector.__init__": [[32, 44], ["mmdet.apis.init_detector"], "methods", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.apis.inference.init_detector"], ["    ", "def", "__init__", "(", "self", ",", "\n", "model_config", ",", "\n", "checkpoint", "=", "None", ",", "\n", "streamqueue_size", "=", "3", ",", "\n", "device", "=", "'cuda:0'", ")", ":", "\n", "\n", "        ", "self", ".", "streamqueue_size", "=", "streamqueue_size", "\n", "self", ".", "device", "=", "device", "\n", "# build the model and load checkpoint", "\n", "self", ".", "model", "=", "init_detector", "(", "\n", "model_config", ",", "checkpoint", "=", "None", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "streamqueue", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner": [[14, 36], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "torch.LongTensor", "torch.all", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["def", "test_max_iou_assigner", "(", ")", ":", "\n", "    ", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "4", "\n", "assert", "len", "(", "assign_result", ".", "labels", ")", "==", "4", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "0", ",", "2", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner_with_ignore": [[38, 63], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.Tensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_max_iou_assigner_with_ignore", "(", ")", ":", "\n", "    ", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "30", ",", "32", ",", "40", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "30", ",", "30", ",", "40", ",", "40", "]", ",", "\n", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "\n", "bboxes", ",", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "0", ",", "2", ",", "-", "1", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner_with_empty_gt": [[65, 82], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_max_iou_assigner_with_empty_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an image might have no true detections.\"\"\"", "\n", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ")", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner_with_empty_boxes": [[84, 106], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.empty", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "len", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_max_iou_assigner_with_empty_boxes", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where a network might predict no boxes.\"\"\"", "\n", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "\n", "\n", "# Test with gt_labels", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "assert", "tuple", "(", "assign_result", ".", "labels", ".", "shape", ")", "==", "(", "0", ",", ")", "\n", "\n", "# Test without gt_labels", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "None", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "assert", "assign_result", ".", "labels", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner_with_empty_boxes_and_ignore": [[108, 140], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.empty", "torch.FloatTensor", "torch.Tensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "len", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_max_iou_assigner_with_empty_boxes_and_ignore", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where a network might predict no boxes and\n    ignore_iof_thr is on.\"\"\"", "\n", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "30", ",", "30", ",", "40", ",", "40", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "\n", "\n", "# Test with gt_labels", "\n", "assign_result", "=", "self", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "assert", "tuple", "(", "assign_result", ".", "labels", ".", "shape", ")", "==", "(", "0", ",", ")", "\n", "\n", "# Test without gt_labels", "\n", "assign_result", "=", "self", ".", "assign", "(", "\n", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "None", ",", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "assert", "assign_result", ".", "labels", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_max_iou_assigner_with_empty_boxes_and_gt": [[142, 152], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.empty", "torch.empty", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_max_iou_assigner_with_empty_boxes_and_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where a network might predict no boxes and no gt.\"\"\"", "\n", "self", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_point_assigner": [[154, 169], ["mmdet.core.bbox.assigners.PointAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.PointAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_point_assigner", "(", ")", ":", "\n", "    ", "self", "=", "PointAssigner", "(", ")", "\n", "points", "=", "torch", ".", "FloatTensor", "(", "[", "# [x, y, stride]", "\n", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "10", ",", "10", ",", "1", "]", ",", "\n", "[", "5", ",", "5", ",", "1", "]", ",", "\n", "[", "32", ",", "32", ",", "1", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "points", ",", "gt_bboxes", ")", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "1", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_point_assigner_with_empty_gt": [[171, 185], ["mmdet.core.bbox.assigners.PointAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.PointAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_point_assigner_with_empty_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an image might have no true detections.\"\"\"", "\n", "self", "=", "PointAssigner", "(", ")", "\n", "points", "=", "torch", ".", "FloatTensor", "(", "[", "# [x, y, stride]", "\n", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "10", ",", "10", ",", "1", "]", ",", "\n", "[", "5", ",", "5", ",", "1", "]", ",", "\n", "[", "32", ",", "32", ",", "1", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "points", ",", "gt_bboxes", ")", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_point_assigner_with_empty_boxes_and_gt": [[187, 194], ["mmdet.core.bbox.assigners.PointAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.PointAssigner.assign", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_point_assigner_with_empty_boxes_and_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an image might predict no points and no gt.\"\"\"", "\n", "self", "=", "PointAssigner", "(", ")", "\n", "points", "=", "torch", ".", "FloatTensor", "(", "[", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "points", ",", "gt_bboxes", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_approx_iou_assigner": [[196, 219], ["mmdet.core.bbox.assigners.ApproxMaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.ApproxMaxIoUAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_approx_iou_assigner", "(", ")", ":", "\n", "    ", "self", "=", "ApproxMaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "approxs_per_octave", "=", "1", "\n", "approxs", "=", "bboxes", "\n", "squares", "=", "bboxes", "\n", "assign_result", "=", "self", ".", "assign", "(", "approxs", ",", "squares", ",", "approxs_per_octave", ",", "\n", "gt_bboxes", ")", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "0", ",", "2", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_approx_iou_assigner_with_empty_gt": [[221, 242], ["mmdet.core.bbox.assigners.ApproxMaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "mmdet.core.bbox.assigners.ApproxMaxIoUAssigner.assign", "torch.LongTensor", "torch.all"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_approx_iou_assigner_with_empty_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an image might have no true detections.\"\"\"", "\n", "self", "=", "ApproxMaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "]", ")", "\n", "approxs_per_octave", "=", "1", "\n", "approxs", "=", "bboxes", "\n", "squares", "=", "bboxes", "\n", "assign_result", "=", "self", ".", "assign", "(", "approxs", ",", "squares", ",", "approxs_per_octave", ",", "\n", "gt_bboxes", ")", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_approx_iou_assigner_with_empty_boxes": [[244, 261], ["mmdet.core.bbox.assigners.ApproxMaxIoUAssigner", "torch.empty", "torch.FloatTensor", "mmdet.core.bbox.assigners.ApproxMaxIoUAssigner.assign", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_approx_iou_assigner_with_empty_boxes", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an network might predict no boxes.\"\"\"", "\n", "self", "=", "ApproxMaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "approxs_per_octave", "=", "1", "\n", "approxs", "=", "bboxes", "\n", "squares", "=", "bboxes", "\n", "assign_result", "=", "self", ".", "assign", "(", "approxs", ",", "squares", ",", "approxs_per_octave", ",", "\n", "gt_bboxes", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_approx_iou_assigner_with_empty_boxes_and_gt": [[263, 277], ["mmdet.core.bbox.assigners.ApproxMaxIoUAssigner", "torch.empty", "torch.empty", "mmdet.core.bbox.assigners.ApproxMaxIoUAssigner.assign", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_approx_iou_assigner_with_empty_boxes_and_gt", "(", ")", ":", "\n", "    ", "\"\"\"Test corner case where an network might predict no boxes and no gt.\"\"\"", "\n", "self", "=", "ApproxMaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "\n", "approxs_per_octave", "=", "1", "\n", "approxs", "=", "bboxes", "\n", "squares", "=", "bboxes", "\n", "assign_result", "=", "self", ".", "assign", "(", "approxs", ",", "squares", ",", "approxs_per_octave", ",", "\n", "gt_bboxes", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_random_assign_result": [[279, 291], ["AssignResult.random", "AssignResult.random", "AssignResult.random", "AssignResult.random", "AssignResult.random", "AssignResult.random", "AssignResult.random", "AssignResult.random"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random"], ["", "def", "test_random_assign_result", "(", ")", ":", "\n", "    ", "\"\"\"Test random instantiation of assign result to catch corner cases.\"\"\"", "\n", "from", "mmdet", ".", "core", ".", "bbox", ".", "assigners", ".", "assign_result", "import", "AssignResult", "\n", "AssignResult", ".", "random", "(", ")", "\n", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "0", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "3", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "3", ",", "num_preds", "=", "3", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "3", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "7", ",", "num_preds", "=", "7", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "7", ",", "num_preds", "=", "64", ")", "\n", "AssignResult", ".", "random", "(", "num_gts", "=", "24", ",", "num_preds", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_center_region_assigner": [[293, 317], ["mmdet.core.bbox.assigners.CenterRegionAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.CenterRegionAssigner.assign", "torch.LongTensor", "torch.all", "test_assigner..get_extra_property", "torch.any", "torch.any", "torch.any", "len", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.get_extra_property"], ["", "def", "test_center_region_assigner", "(", ")", ":", "\n", "    ", "self", "=", "CenterRegionAssigner", "(", "pos_scale", "=", "0.3", ",", "neg_scale", "=", "1", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "[", "8", ",", "8", ",", "9", ",", "\n", "9", "]", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "11", ",", "11", "]", ",", "# match bboxes[0]", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "# match bboxes[1]", "\n", "[", "4.5", ",", "4.5", ",", "5.5", ",", "5.5", "]", ",", "# match bboxes[0] but area is too small", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "# match bboxes[1] and has a smaller area than gt[0]", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", ",", "4", ",", "5", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "3", "\n", "assert", "len", "(", "assign_result", ".", "labels", ")", "==", "3", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "4", ",", "2", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "shadowed_labels", "=", "assign_result", ".", "get_extra_property", "(", "'shadowed_labels'", ")", "\n", "# [8, 8, 9, 9] in the shadowed region of [0, 0, 11, 11] (label: 2)", "\n", "assert", "torch", ".", "any", "(", "shadowed_labels", "==", "torch", ".", "LongTensor", "(", "[", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "# [8, 8, 9, 9] in the shadowed region of [0, 0, 10, 10] (label: 5)", "\n", "assert", "torch", ".", "any", "(", "shadowed_labels", "==", "torch", ".", "LongTensor", "(", "[", "[", "2", ",", "5", "]", "]", ")", ")", "\n", "# [0, 0, 10, 10] is already assigned to [4.5, 4.5, 5.5, 5.5].", "\n", "#   Therefore, [0, 0, 11, 11] (label: 2) is shadowed", "\n", "assert", "torch", ".", "any", "(", "shadowed_labels", "==", "torch", ".", "LongTensor", "(", "[", "[", "0", ",", "2", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_center_region_assigner_with_ignore": [[319, 346], ["mmdet.core.bbox.assigners.CenterRegionAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.CenterRegionAssigner.assign", "torch.LongTensor", "torch.all", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_center_region_assigner_with_ignore", "(", ")", ":", "\n", "    ", "self", "=", "CenterRegionAssigner", "(", "\n", "pos_scale", "=", "0.5", ",", "\n", "neg_scale", "=", "1", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "# match bboxes[0]", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "# match bboxes[1]", "\n", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "# match bboxes[0]", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "2", "\n", "assert", "len", "(", "assign_result", ".", "labels", ")", "==", "2", "\n", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "-", "1", ",", "2", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_center_region_assigner_with_empty_bboxes": [[348, 362], ["mmdet.core.bbox.assigners.CenterRegionAssigner", "torch.empty().float", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.CenterRegionAssigner.assign", "torch.empty", "test_assigner..gt_inds.numel", "test_assigner..labels.numel"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_center_region_assigner_with_empty_bboxes", "(", ")", ":", "\n", "    ", "self", "=", "CenterRegionAssigner", "(", "\n", "pos_scale", "=", "0.5", ",", "\n", "neg_scale", "=", "1", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", ".", "float", "(", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "# match bboxes[0]", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "# match bboxes[1]", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "assign_result", ".", "gt_inds", "is", "None", "or", "assign_result", ".", "gt_inds", ".", "numel", "(", ")", "==", "0", "\n", "assert", "assign_result", ".", "labels", "is", "None", "or", "assign_result", ".", "labels", ".", "numel", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_assigner.test_center_region_assigner_with_empty_gts": [[364, 379], ["mmdet.core.bbox.assigners.CenterRegionAssigner", "torch.FloatTensor", "torch.empty().float", "torch.empty().long", "mmdet.core.bbox.assigners.CenterRegionAssigner.assign", "torch.LongTensor", "torch.all", "len", "torch.empty", "torch.empty"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign"], ["", "def", "test_center_region_assigner_with_empty_gts", "(", ")", ":", "\n", "    ", "self", "=", "CenterRegionAssigner", "(", "\n", "pos_scale", "=", "0.5", ",", "\n", "neg_scale", "=", "1", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", ".", "float", "(", ")", "\n", "gt_labels", "=", "torch", ".", "empty", "(", "(", "0", ",", ")", ")", ".", "long", "(", ")", "\n", "assign_result", "=", "self", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "len", "(", "assign_result", ".", "gt_inds", ")", "==", "2", "\n", "expected_gt_inds", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "0", "]", ")", "\n", "assert", "torch", ".", "all", "(", "assign_result", ".", "gt_inds", "==", "expected_gt_inds", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._get_config_directory": [[9, 22], ["os.path.join", "os.path.dirname", "os.path.exists", "Exception", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["def", "_get_config_directory", "(", ")", ":", "\n", "    ", "\"\"\"Find the predefined detector config directory.\"\"\"", "\n", "try", ":", "\n", "# Assume we are running in the source mmdetection repo", "\n", "        ", "repo_dpath", "=", "dirname", "(", "dirname", "(", "__file__", ")", ")", "\n", "", "except", "NameError", ":", "\n", "# For IPython development when this __file__ is not defined", "\n", "        ", "import", "mmdet", "\n", "repo_dpath", "=", "dirname", "(", "dirname", "(", "mmdet", ".", "__file__", ")", ")", "\n", "", "config_dpath", "=", "join", "(", "repo_dpath", ",", "'configs'", ")", "\n", "if", "not", "exists", "(", "config_dpath", ")", ":", "\n", "        ", "raise", "Exception", "(", "'Cannot find config path'", ")", "\n", "", "return", "config_dpath", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config.test_config_build_detector": [[24, 70], ["test_config._get_config_directory", "print", "list", "print", "glob.glob", "os.path.relpath", "os.path.join", "Config.fromfile", "print", "build_detector", "mmcv.runner.build_optimizer", "isinstance", "os.path.join", "Config.fromfile.model.keys", "test_config._check_roi_head", "p.find", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_directory", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_head"], ["", "def", "test_config_build_detector", "(", ")", ":", "\n", "    ", "\"\"\"Test that all detection models defined in the configs can be\n    initialized.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "print", "(", "f'Found config_dpath = {config_dpath}'", ")", "\n", "\n", "import", "glob", "\n", "config_fpaths", "=", "list", "(", "glob", ".", "glob", "(", "join", "(", "config_dpath", ",", "'**'", ",", "'*.py'", ")", ")", ")", "\n", "config_fpaths", "=", "[", "p", "for", "p", "in", "config_fpaths", "if", "p", ".", "find", "(", "'_base_'", ")", "==", "-", "1", "]", "\n", "config_names", "=", "[", "relpath", "(", "p", ",", "config_dpath", ")", "for", "p", "in", "config_fpaths", "]", "\n", "\n", "print", "(", "f'Using {len(config_names)} config files'", ")", "\n", "\n", "for", "config_fname", "in", "config_names", ":", "\n", "        ", "config_fpath", "=", "join", "(", "config_dpath", ",", "config_fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "\n", "config_mod", ".", "model", "\n", "config_mod", ".", "train_cfg", "\n", "config_mod", ".", "test_cfg", "\n", "print", "(", "f'Building detector, config_fpath = {config_fpath}'", ")", "\n", "\n", "# Remove pretrained keys to allow for testing in an offline environment", "\n", "if", "'pretrained'", "in", "config_mod", ".", "model", ":", "\n", "            ", "config_mod", ".", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "", "detector", "=", "build_detector", "(", "\n", "config_mod", ".", "model", ",", "\n", "train_cfg", "=", "config_mod", ".", "train_cfg", ",", "\n", "test_cfg", "=", "config_mod", ".", "test_cfg", ")", "\n", "assert", "detector", "is", "not", "None", "\n", "\n", "optimizer", "=", "build_optimizer", "(", "detector", ",", "config_mod", ".", "optimizer", ")", "\n", "assert", "isinstance", "(", "optimizer", ",", "torch", ".", "optim", ".", "Optimizer", ")", "\n", "\n", "if", "'roi_head'", "in", "config_mod", ".", "model", ".", "keys", "(", ")", ":", "\n", "# for two stage detector", "\n", "# detectors must have bbox head", "\n", "            ", "assert", "detector", ".", "roi_head", ".", "with_bbox", "and", "detector", ".", "with_bbox", "\n", "assert", "detector", ".", "roi_head", ".", "with_mask", "==", "detector", ".", "with_mask", "\n", "\n", "head_config", "=", "config_mod", ".", "model", "[", "'roi_head'", "]", "\n", "_check_roi_head", "(", "head_config", ",", "detector", ".", "roi_head", ")", "\n", "# else:", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config.test_config_data_pipeline": [[78, 212], ["test_config._get_config_directory", "print", "print", "os.path.join", "Config.fromfile", "Config.fromfile.train_pipeline.pop", "Config.fromfile.train_pipeline.pop", "Config.fromfile.test_pipeline.pop", "Compose", "Compose", "print", "print", "np.random.randint", "config_mod.train_pipeline.pop.get", "dict", "Compose.", "print", "dict", "Compose.", "print", "dict", "Compose.", "print", "dict", "Compose.", "np.random.randint", "mmdet.core.BitmapMasks", "range", "mmdet.core.PolygonMasks", "img.astype.astype", "config_mod.train_pipeline.pop.get", "mmdet.core.PolygonMasks.append", "masks[].append", "masks[].append", "len", "np.array", "np.array", "test_config.test_config_data_pipeline.dummy_masks"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_directory"], ["", "", "", "def", "test_config_data_pipeline", "(", ")", ":", "\n", "    ", "\"\"\"Test whether the data pipeline is valid and can process corner cases.\n\n    CommandLine:\n        xdoctest -m tests/test_config.py test_config_build_data_pipeline\n    \"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "from", "mmdet", ".", "datasets", ".", "pipelines", "import", "Compose", "\n", "import", "numpy", "as", "np", "\n", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "print", "(", "f'Found config_dpath = {config_dpath}'", ")", "\n", "\n", "# Only tests a representative subset of configurations", "\n", "# TODO: test pipelines using Albu, current Albu throw None given empty GT", "\n", "config_names", "=", "[", "\n", "'wider_face/ssd300_wider_face.py'", ",", "\n", "'pascal_voc/ssd300_voc0712.py'", ",", "\n", "'pascal_voc/ssd512_voc0712.py'", ",", "\n", "# 'albu_example/mask_rcnn_r50_fpn_1x.py',", "\n", "'foveabox/fovea_align_r50_fpn_gn-head_mstrain_640-800_4x4_2x_coco.py'", ",", "\n", "'mask_rcnn/mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_coco.py'", ",", "\n", "'mask_rcnn/mask_rcnn_r50_caffe_fpn_mstrain_1x_coco.py'", ",", "\n", "'fp16/mask_rcnn_r50_fpn_fp16_1x_coco.py'", "\n", "]", "\n", "\n", "def", "dummy_masks", "(", "h", ",", "w", ",", "num_obj", "=", "3", ",", "mode", "=", "'bitmap'", ")", ":", "\n", "        ", "assert", "mode", "in", "(", "'polygon'", ",", "'bitmap'", ")", "\n", "if", "mode", "==", "'bitmap'", ":", "\n", "            ", "masks", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "(", "num_obj", ",", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "masks", "=", "BitmapMasks", "(", "masks", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_obj", ")", ":", "\n", "                ", "masks", ".", "append", "(", "[", "]", ")", "\n", "masks", "[", "-", "1", "]", ".", "append", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "min", "(", "h", "-", "1", ",", "w", "-", "1", ")", ",", "(", "8", "+", "4", "*", "i", ",", ")", ")", ")", "\n", "masks", "[", "-", "1", "]", ".", "append", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "min", "(", "h", "-", "1", ",", "w", "-", "1", ")", ",", "(", "10", "+", "4", "*", "i", ",", ")", ")", ")", "\n", "", "masks", "=", "PolygonMasks", "(", "masks", ",", "h", ",", "w", ")", "\n", "", "return", "masks", "\n", "\n", "", "print", "(", "f'Using {len(config_names)} config files'", ")", "\n", "\n", "for", "config_fname", "in", "config_names", ":", "\n", "        ", "config_fpath", "=", "join", "(", "config_dpath", ",", "config_fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "\n", "# remove loading pipeline", "\n", "loading_pipeline", "=", "config_mod", ".", "train_pipeline", ".", "pop", "(", "0", ")", "\n", "loading_ann_pipeline", "=", "config_mod", ".", "train_pipeline", ".", "pop", "(", "0", ")", "\n", "config_mod", ".", "test_pipeline", ".", "pop", "(", "0", ")", "\n", "\n", "train_pipeline", "=", "Compose", "(", "config_mod", ".", "train_pipeline", ")", "\n", "test_pipeline", "=", "Compose", "(", "config_mod", ".", "test_pipeline", ")", "\n", "\n", "print", "(", "f'Building data pipeline, config_fpath = {config_fpath}'", ")", "\n", "\n", "print", "(", "f'Test training data pipeline: \\n{train_pipeline!r}'", ")", "\n", "img", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "255", ",", "size", "=", "(", "888", ",", "666", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "if", "loading_pipeline", ".", "get", "(", "'to_float32'", ",", "False", ")", ":", "\n", "            ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "mode", "=", "'bitmap'", "if", "loading_ann_pipeline", ".", "get", "(", "'poly2mask'", ",", "\n", "True", ")", "else", "'polygon'", "\n", "results", "=", "dict", "(", "\n", "filename", "=", "'test_img.png'", ",", "\n", "ori_filename", "=", "'test_img.png'", ",", "\n", "img", "=", "img", ",", "\n", "img_shape", "=", "img", ".", "shape", ",", "\n", "ori_shape", "=", "img", ".", "shape", ",", "\n", "gt_bboxes", "=", "np", ".", "array", "(", "[", "[", "35.2", ",", "11.7", ",", "39.7", ",", "15.7", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "1", "]", ",", "dtype", "=", "np", ".", "int64", ")", ",", "\n", "gt_masks", "=", "dummy_masks", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ",", "mode", "=", "mode", ")", ",", "\n", ")", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "output_results", "=", "train_pipeline", "(", "results", ")", "\n", "assert", "output_results", "is", "not", "None", "\n", "\n", "print", "(", "f'Test testing data pipeline: \\n{test_pipeline!r}'", ")", "\n", "results", "=", "dict", "(", "\n", "filename", "=", "'test_img.png'", ",", "\n", "ori_filename", "=", "'test_img.png'", ",", "\n", "img", "=", "img", ",", "\n", "img_shape", "=", "img", ".", "shape", ",", "\n", "ori_shape", "=", "img", ".", "shape", ",", "\n", "gt_bboxes", "=", "np", ".", "array", "(", "[", "[", "35.2", ",", "11.7", ",", "39.7", ",", "15.7", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "1", "]", ",", "dtype", "=", "np", ".", "int64", ")", ",", "\n", "gt_masks", "=", "dummy_masks", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ",", "mode", "=", "mode", ")", ",", "\n", ")", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "output_results", "=", "test_pipeline", "(", "results", ")", "\n", "assert", "output_results", "is", "not", "None", "\n", "\n", "# test empty GT", "\n", "print", "(", "'Test empty GT with training data pipeline: '", "\n", "f'\\n{train_pipeline!r}'", ")", "\n", "results", "=", "dict", "(", "\n", "filename", "=", "'test_img.png'", ",", "\n", "ori_filename", "=", "'test_img.png'", ",", "\n", "img", "=", "img", ",", "\n", "img_shape", "=", "img", ".", "shape", ",", "\n", "ori_shape", "=", "img", ".", "shape", ",", "\n", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", ",", "\n", "gt_masks", "=", "dummy_masks", "(", "\n", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ",", "num_obj", "=", "0", ",", "mode", "=", "mode", ")", ",", "\n", ")", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "output_results", "=", "train_pipeline", "(", "results", ")", "\n", "assert", "output_results", "is", "not", "None", "\n", "\n", "print", "(", "f'Test empty GT with testing data pipeline: \\n{test_pipeline!r}'", ")", "\n", "results", "=", "dict", "(", "\n", "filename", "=", "'test_img.png'", ",", "\n", "ori_filename", "=", "'test_img.png'", ",", "\n", "img", "=", "img", ",", "\n", "img_shape", "=", "img", ".", "shape", ",", "\n", "ori_shape", "=", "img", ".", "shape", ",", "\n", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", ",", "\n", "gt_masks", "=", "dummy_masks", "(", "\n", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ",", "num_obj", "=", "0", ",", "mode", "=", "mode", ")", ",", "\n", ")", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "output_results", "=", "test_pipeline", "(", "results", ")", "\n", "assert", "output_results", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_head": [[214, 265], ["test_config._check_roi_extractor", "test_config._check_bbox_head", "test_config._check_mask_head", "test_config._check_roi_extractor", "len", "len", "len", "len", "hasattr", "test_config._check_roi_extractor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_bbox_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_mask_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_extractor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_extractor"], ["", "", "def", "_check_roi_head", "(", "config", ",", "head", ")", ":", "\n", "# check consistency between head_config and roi_head", "\n", "    ", "assert", "config", "[", "'type'", "]", "==", "head", ".", "__class__", ".", "__name__", "\n", "\n", "# check roi_align", "\n", "bbox_roi_cfg", "=", "config", ".", "bbox_roi_extractor", "\n", "bbox_roi_extractor", "=", "head", ".", "bbox_roi_extractor", "\n", "_check_roi_extractor", "(", "bbox_roi_cfg", ",", "bbox_roi_extractor", ")", "\n", "\n", "# check bbox head infos", "\n", "bbox_cfg", "=", "config", ".", "bbox_head", "\n", "bbox_head", "=", "head", ".", "bbox_head", "\n", "_check_bbox_head", "(", "bbox_cfg", ",", "bbox_head", ")", "\n", "\n", "if", "head", ".", "with_mask", ":", "\n", "# check roi_align", "\n", "        ", "if", "config", ".", "mask_roi_extractor", ":", "\n", "            ", "mask_roi_cfg", "=", "config", ".", "mask_roi_extractor", "\n", "mask_roi_extractor", "=", "head", ".", "mask_roi_extractor", "\n", "_check_roi_extractor", "(", "mask_roi_cfg", ",", "mask_roi_extractor", ",", "\n", "bbox_roi_extractor", ")", "\n", "\n", "# check mask head infos", "\n", "", "mask_head", "=", "head", ".", "mask_head", "\n", "mask_cfg", "=", "config", ".", "mask_head", "\n", "_check_mask_head", "(", "mask_cfg", ",", "mask_head", ")", "\n", "\n", "# check arch specific settings, e.g., cascade/htc", "\n", "", "if", "config", "[", "'type'", "]", "in", "[", "'CascadeRoIHead'", ",", "'HybridTaskCascadeRoIHead'", "]", ":", "\n", "        ", "assert", "config", ".", "num_stages", "==", "len", "(", "head", ".", "bbox_head", ")", "\n", "assert", "config", ".", "num_stages", "==", "len", "(", "head", ".", "bbox_roi_extractor", ")", "\n", "\n", "if", "head", ".", "with_mask", ":", "\n", "            ", "assert", "config", ".", "num_stages", "==", "len", "(", "head", ".", "mask_head", ")", "\n", "assert", "config", ".", "num_stages", "==", "len", "(", "head", ".", "mask_roi_extractor", ")", "\n", "\n", "", "", "elif", "config", "[", "'type'", "]", "in", "[", "'MaskScoringRoIHead'", "]", ":", "\n", "        ", "assert", "(", "hasattr", "(", "head", ",", "'mask_iou_head'", ")", "\n", "and", "head", ".", "mask_iou_head", "is", "not", "None", ")", "\n", "mask_iou_cfg", "=", "config", ".", "mask_iou_head", "\n", "mask_iou_head", "=", "head", ".", "mask_iou_head", "\n", "assert", "(", "mask_iou_cfg", ".", "fc_out_channels", "==", "\n", "mask_iou_head", ".", "fc_mask_iou", ".", "in_features", ")", "\n", "\n", "", "elif", "config", "[", "'type'", "]", "in", "[", "'GridRoIHead'", "]", ":", "\n", "        ", "grid_roi_cfg", "=", "config", ".", "grid_roi_extractor", "\n", "grid_roi_extractor", "=", "head", ".", "grid_roi_extractor", "\n", "_check_roi_extractor", "(", "grid_roi_cfg", ",", "grid_roi_extractor", ",", "\n", "bbox_roi_extractor", ")", "\n", "\n", "config", ".", "grid_head", ".", "grid_points", "=", "head", ".", "grid_head", ".", "grid_points", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_roi_extractor": [[267, 292], ["isinstance", "len", "len", "_pair"], "function", ["None"], ["", "", "def", "_check_roi_extractor", "(", "config", ",", "roi_extractor", ",", "prev_roi_extractor", "=", "None", ")", ":", "\n", "    ", "import", "torch", ".", "nn", "as", "nn", "\n", "if", "isinstance", "(", "roi_extractor", ",", "nn", ".", "ModuleList", ")", ":", "\n", "        ", "if", "prev_roi_extractor", ":", "\n", "            ", "prev_roi_extractor", "=", "prev_roi_extractor", "[", "0", "]", "\n", "", "roi_extractor", "=", "roi_extractor", "[", "0", "]", "\n", "\n", "", "assert", "(", "len", "(", "config", ".", "featmap_strides", ")", "==", "len", "(", "roi_extractor", ".", "roi_layers", ")", ")", "\n", "assert", "(", "config", ".", "out_channels", "==", "roi_extractor", ".", "out_channels", ")", "\n", "from", "torch", ".", "nn", ".", "modules", ".", "utils", "import", "_pair", "\n", "assert", "(", "_pair", "(", "config", ".", "roi_layer", ".", "output_size", ")", "==", "\n", "roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "output_size", ")", "\n", "\n", "if", "'use_torchvision'", "in", "config", ".", "roi_layer", ":", "\n", "        ", "assert", "(", "config", ".", "roi_layer", ".", "use_torchvision", "==", "\n", "roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "use_torchvision", ")", "\n", "", "elif", "'aligned'", "in", "config", ".", "roi_layer", ":", "\n", "        ", "assert", "(", "\n", "config", ".", "roi_layer", ".", "aligned", "==", "roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "aligned", ")", "\n", "\n", "", "if", "prev_roi_extractor", ":", "\n", "        ", "assert", "(", "roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "aligned", "==", "\n", "prev_roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "aligned", ")", "\n", "assert", "(", "roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "use_torchvision", "==", "\n", "prev_roi_extractor", ".", "roi_layers", "[", "0", "]", ".", "use_torchvision", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_mask_head": [[294, 315], ["isinstance", "zip", "isinstance", "test_config._check_mask_head", "mask_cfg.get", "hasattr", "test_config._check_mask_head"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_mask_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_mask_head"], ["", "", "def", "_check_mask_head", "(", "mask_cfg", ",", "mask_head", ")", ":", "\n", "    ", "import", "torch", ".", "nn", "as", "nn", "\n", "if", "isinstance", "(", "mask_cfg", ",", "list", ")", ":", "\n", "        ", "for", "single_mask_cfg", ",", "single_mask_head", "in", "zip", "(", "mask_cfg", ",", "mask_head", ")", ":", "\n", "            ", "_check_mask_head", "(", "single_mask_cfg", ",", "single_mask_head", ")", "\n", "", "", "elif", "isinstance", "(", "mask_head", ",", "nn", ".", "ModuleList", ")", ":", "\n", "        ", "for", "single_mask_head", "in", "mask_head", ":", "\n", "            ", "_check_mask_head", "(", "mask_cfg", ",", "single_mask_head", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "mask_cfg", "[", "'type'", "]", "==", "mask_head", ".", "__class__", ".", "__name__", "\n", "assert", "mask_cfg", ".", "in_channels", "==", "mask_head", ".", "in_channels", "\n", "class_agnostic", "=", "mask_cfg", ".", "get", "(", "'class_agnostic'", ",", "False", ")", "\n", "out_dim", "=", "(", "1", "if", "class_agnostic", "else", "mask_cfg", ".", "num_classes", ")", "\n", "if", "hasattr", "(", "mask_head", ",", "'conv_logits'", ")", ":", "\n", "            ", "assert", "(", "mask_cfg", ".", "conv_out_channels", "==", "\n", "mask_head", ".", "conv_logits", ".", "in_channels", ")", "\n", "assert", "mask_head", ".", "conv_logits", ".", "out_channels", "==", "out_dim", "\n", "", "else", ":", "\n", "            ", "assert", "mask_cfg", ".", "fc_out_channels", "==", "mask_head", ".", "fc_logits", ".", "in_features", "\n", "assert", "(", "mask_head", ".", "fc_logits", ".", "out_features", "==", "out_dim", "*", "\n", "mask_head", ".", "output_area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_bbox_head": [[317, 339], ["isinstance", "zip", "isinstance", "test_config._check_bbox_head", "bbox_cfg.get", "bbox_cfg.get", "test_config._check_bbox_head", "bbox_cfg.get"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_bbox_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_bbox_head"], ["", "", "", "def", "_check_bbox_head", "(", "bbox_cfg", ",", "bbox_head", ")", ":", "\n", "    ", "import", "torch", ".", "nn", "as", "nn", "\n", "if", "isinstance", "(", "bbox_cfg", ",", "list", ")", ":", "\n", "        ", "for", "single_bbox_cfg", ",", "single_bbox_head", "in", "zip", "(", "bbox_cfg", ",", "bbox_head", ")", ":", "\n", "            ", "_check_bbox_head", "(", "single_bbox_cfg", ",", "single_bbox_head", ")", "\n", "", "", "elif", "isinstance", "(", "bbox_head", ",", "nn", ".", "ModuleList", ")", ":", "\n", "        ", "for", "single_bbox_head", "in", "bbox_head", ":", "\n", "            ", "_check_bbox_head", "(", "bbox_cfg", ",", "single_bbox_head", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "bbox_cfg", "[", "'type'", "]", "==", "bbox_head", ".", "__class__", ".", "__name__", "\n", "assert", "bbox_cfg", ".", "in_channels", "==", "bbox_head", ".", "in_channels", "\n", "with_cls", "=", "bbox_cfg", ".", "get", "(", "'with_cls'", ",", "True", ")", "\n", "if", "with_cls", ":", "\n", "            ", "fc_out_channels", "=", "bbox_cfg", ".", "get", "(", "'fc_out_channels'", ",", "2048", ")", "\n", "assert", "(", "fc_out_channels", "==", "bbox_head", ".", "fc_cls", ".", "in_features", ")", "\n", "assert", "bbox_cfg", ".", "num_classes", "+", "1", "==", "bbox_head", ".", "fc_cls", ".", "out_features", "\n", "\n", "", "with_reg", "=", "bbox_cfg", ".", "get", "(", "'with_reg'", ",", "True", ")", "\n", "if", "with_reg", ":", "\n", "            ", "out_dim", "=", "(", "4", "if", "bbox_cfg", ".", "reg_class_agnostic", "else", "4", "*", "\n", "bbox_cfg", ".", "num_classes", ")", "\n", "assert", "bbox_head", ".", "fc_reg", ".", "out_features", "==", "out_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_config._check_anchorhead": [[341, 358], ["config.loss_cls.get"], "function", ["None"], ["", "", "", "def", "_check_anchorhead", "(", "config", ",", "head", ")", ":", "\n", "# check consistency between head_config and roi_head", "\n", "    ", "assert", "config", "[", "'type'", "]", "==", "head", ".", "__class__", ".", "__name__", "\n", "assert", "config", ".", "in_channels", "==", "head", ".", "in_channels", "\n", "\n", "num_classes", "=", "(", "\n", "config", ".", "num_classes", "-", "\n", "1", "if", "config", ".", "loss_cls", ".", "get", "(", "'use_sigmoid'", ",", "False", ")", "else", "config", ".", "num_classes", ")", "\n", "if", "config", "[", "'type'", "]", "==", "'ATSSHead'", ":", "\n", "        ", "assert", "(", "config", ".", "feat_channels", "==", "head", ".", "atss_cls", ".", "in_channels", ")", "\n", "assert", "(", "config", ".", "feat_channels", "==", "head", ".", "atss_reg", ".", "in_channels", ")", "\n", "assert", "(", "config", ".", "feat_channels", "==", "head", ".", "atss_centerness", ".", "in_channels", ")", "\n", "", "else", ":", "\n", "        ", "assert", "(", "config", ".", "in_channels", "==", "head", ".", "conv_cls", ".", "in_channels", ")", "\n", "assert", "(", "config", ".", "in_channels", "==", "head", ".", "conv_reg", ".", "in_channels", ")", "\n", "assert", "(", "head", ".", "conv_cls", ".", "out_channels", "==", "num_classes", "*", "head", ".", "num_anchors", ")", "\n", "assert", "head", ".", "fc_reg", ".", "out_channels", "==", "4", "*", "head", ".", "num_anchors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_standard_anchor_generator": [[10, 20], ["dict", "build_anchor_generator"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator"], ["def", "test_standard_anchor_generator", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "core", ".", "anchor", "import", "build_anchor_generator", "\n", "anchor_generator_cfg", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "scales", "=", "[", "8", "]", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "4", ",", "8", "]", ")", "\n", "\n", "anchor_generator", "=", "build_anchor_generator", "(", "anchor_generator_cfg", ")", "\n", "assert", "anchor_generator", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_strides": [[22, 41], ["AnchorGenerator", "AnchorGenerator.grid_anchors", "torch.tensor", "torch.equal", "AnchorGenerator", "AnchorGenerator.grid_anchors", "torch.tensor", "torch.equal"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors"], ["", "def", "test_strides", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "core", "import", "AnchorGenerator", "\n", "# Square strides", "\n", "self", "=", "AnchorGenerator", "(", "[", "10", "]", ",", "[", "1.", "]", ",", "[", "1.", "]", ",", "[", "10", "]", ")", "\n", "anchors", "=", "self", ".", "grid_anchors", "(", "[", "(", "2", ",", "2", ")", "]", ",", "device", "=", "'cpu'", ")", "\n", "\n", "expected_anchors", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5.", ",", "-", "5.", ",", "5.", ",", "5.", "]", ",", "[", "5.", ",", "-", "5.", ",", "15.", ",", "5.", "]", ",", "\n", "[", "-", "5.", ",", "5.", ",", "5.", ",", "15.", "]", ",", "[", "5.", ",", "5.", ",", "15.", ",", "15.", "]", "]", ")", "\n", "\n", "assert", "torch", ".", "equal", "(", "anchors", "[", "0", "]", ",", "expected_anchors", ")", "\n", "\n", "# Different strides in x and y direction", "\n", "self", "=", "AnchorGenerator", "(", "[", "(", "10", ",", "20", ")", "]", ",", "[", "1.", "]", ",", "[", "1.", "]", ",", "[", "10", "]", ")", "\n", "anchors", "=", "self", ".", "grid_anchors", "(", "[", "(", "2", ",", "2", ")", "]", ",", "device", "=", "'cpu'", ")", "\n", "\n", "expected_anchors", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5.", ",", "-", "5.", ",", "5.", ",", "5.", "]", ",", "[", "5.", ",", "-", "5.", ",", "15.", ",", "5.", "]", ",", "\n", "[", "-", "5.", ",", "15.", ",", "5.", ",", "25.", "]", ",", "[", "5.", ",", "15.", ",", "15.", ",", "25.", "]", "]", ")", "\n", "\n", "assert", "torch", ".", "equal", "(", "anchors", "[", "0", "]", ",", "expected_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_ssd_anchor_generator": [[43, 111], ["torch.cuda.is_available", "dict", "build_anchor_generator", "enumerate", "build_anchor_generator.valid_flags", "enumerate", "build_anchor_generator.grid_anchors", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "base_anchor.allclose", "len", "single_level_valid_flag.sum"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors"], ["", "def", "test_ssd_anchor_generator", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "core", ".", "anchor", "import", "build_anchor_generator", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "'cuda'", "\n", "", "else", ":", "\n", "        ", "device", "=", "'cpu'", "\n", "\n", "", "anchor_generator_cfg", "=", "dict", "(", "\n", "type", "=", "'SSDAnchorGenerator'", ",", "\n", "scale_major", "=", "False", ",", "\n", "input_size", "=", "300", ",", "\n", "basesize_ratio_range", "=", "(", "0.15", ",", "0.9", ")", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "100", ",", "300", "]", ",", "\n", "ratios", "=", "[", "[", "2", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", "]", ",", "[", "2", "]", "]", ")", "\n", "\n", "featmap_sizes", "=", "[", "(", "38", ",", "38", ")", ",", "(", "19", ",", "19", ")", ",", "(", "10", ",", "10", ")", ",", "(", "5", ",", "5", ")", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", "]", "\n", "anchor_generator", "=", "build_anchor_generator", "(", "anchor_generator_cfg", ")", "\n", "\n", "# check base anchors", "\n", "expected_base_anchors", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "6.5000", ",", "-", "6.5000", ",", "14.5000", ",", "14.5000", "]", ",", "\n", "[", "-", "11.3704", ",", "-", "11.3704", ",", "19.3704", ",", "19.3704", "]", ",", "\n", "[", "-", "10.8492", ",", "-", "3.4246", ",", "18.8492", ",", "11.4246", "]", ",", "\n", "[", "-", "3.4246", ",", "-", "10.8492", ",", "11.4246", ",", "18.8492", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "14.5000", ",", "-", "14.5000", ",", "30.5000", ",", "30.5000", "]", ",", "\n", "[", "-", "25.3729", ",", "-", "25.3729", ",", "41.3729", ",", "41.3729", "]", ",", "\n", "[", "-", "23.8198", ",", "-", "7.9099", ",", "39.8198", ",", "23.9099", "]", ",", "\n", "[", "-", "7.9099", ",", "-", "23.8198", ",", "23.9099", ",", "39.8198", "]", ",", "\n", "[", "-", "30.9711", ",", "-", "4.9904", ",", "46.9711", ",", "20.9904", "]", ",", "\n", "[", "-", "4.9904", ",", "-", "30.9711", ",", "20.9904", ",", "46.9711", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "33.5000", ",", "-", "33.5000", ",", "65.5000", ",", "65.5000", "]", ",", "\n", "[", "-", "45.5366", ",", "-", "45.5366", ",", "77.5366", ",", "77.5366", "]", ",", "\n", "[", "-", "54.0036", ",", "-", "19.0018", ",", "86.0036", ",", "51.0018", "]", ",", "\n", "[", "-", "19.0018", ",", "-", "54.0036", ",", "51.0018", ",", "86.0036", "]", ",", "\n", "[", "-", "69.7365", ",", "-", "12.5788", ",", "101.7365", ",", "44.5788", "]", ",", "\n", "[", "-", "12.5788", ",", "-", "69.7365", ",", "44.5788", ",", "101.7365", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "44.5000", ",", "-", "44.5000", ",", "108.5000", ",", "108.5000", "]", ",", "\n", "[", "-", "56.9817", ",", "-", "56.9817", ",", "120.9817", ",", "120.9817", "]", ",", "\n", "[", "-", "76.1873", ",", "-", "22.0937", ",", "140.1873", ",", "86.0937", "]", ",", "\n", "[", "-", "22.0937", ",", "-", "76.1873", ",", "86.0937", ",", "140.1873", "]", ",", "\n", "[", "-", "100.5019", ",", "-", "12.1673", ",", "164.5019", ",", "76.1673", "]", ",", "\n", "[", "-", "12.1673", ",", "-", "100.5019", ",", "76.1673", ",", "164.5019", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "53.5000", ",", "-", "53.5000", ",", "153.5000", ",", "153.5000", "]", ",", "\n", "[", "-", "66.2185", ",", "-", "66.2185", ",", "166.2185", ",", "166.2185", "]", ",", "\n", "[", "-", "96.3711", ",", "-", "23.1855", ",", "196.3711", ",", "123.1855", "]", ",", "\n", "[", "-", "23.1855", ",", "-", "96.3711", ",", "123.1855", ",", "196.3711", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "19.5000", ",", "19.5000", ",", "280.5000", ",", "280.5000", "]", ",", "\n", "[", "6.6342", ",", "6.6342", ",", "293.3658", ",", "293.3658", "]", ",", "\n", "[", "-", "34.5549", ",", "57.7226", ",", "334.5549", ",", "242.2774", "]", ",", "\n", "[", "57.7226", ",", "-", "34.5549", ",", "242.2774", ",", "334.5549", "]", "]", ")", ",", "\n", "]", "\n", "base_anchors", "=", "anchor_generator", ".", "base_anchors", "\n", "for", "i", ",", "base_anchor", "in", "enumerate", "(", "base_anchors", ")", ":", "\n", "        ", "assert", "base_anchor", ".", "allclose", "(", "expected_base_anchors", "[", "i", "]", ")", "\n", "\n", "# check valid flags", "\n", "", "expected_valid_pixels", "=", "[", "5776", ",", "2166", ",", "600", ",", "150", ",", "36", ",", "4", "]", "\n", "multi_level_valid_flags", "=", "anchor_generator", ".", "valid_flags", "(", "\n", "featmap_sizes", ",", "(", "300", ",", "300", ")", ",", "device", ")", "\n", "for", "i", ",", "single_level_valid_flag", "in", "enumerate", "(", "multi_level_valid_flags", ")", ":", "\n", "        ", "assert", "single_level_valid_flag", ".", "sum", "(", ")", "==", "expected_valid_pixels", "[", "i", "]", "\n", "\n", "# check number of base anchors for each level", "\n", "", "assert", "anchor_generator", ".", "num_base_anchors", "==", "[", "4", ",", "6", ",", "6", ",", "6", ",", "4", ",", "4", "]", "\n", "\n", "# check anchor generation", "\n", "anchors", "=", "anchor_generator", ".", "grid_anchors", "(", "featmap_sizes", ",", "device", ")", "\n", "assert", "len", "(", "anchors", ")", "==", "6", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_anchor_generator_with_tuples": [[113, 146], ["torch.cuda.is_available", "dict", "build_anchor_generator", "build_anchor_generator.grid_anchors", "dict", "build_anchor_generator", "build_anchor_generator.grid_anchors", "zip", "torch.equal"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.builder.build_anchor_generator", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors"], ["", "def", "test_anchor_generator_with_tuples", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "core", ".", "anchor", "import", "build_anchor_generator", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "'cuda'", "\n", "", "else", ":", "\n", "        ", "device", "=", "'cpu'", "\n", "\n", "", "anchor_generator_cfg", "=", "dict", "(", "\n", "type", "=", "'SSDAnchorGenerator'", ",", "\n", "scale_major", "=", "False", ",", "\n", "input_size", "=", "300", ",", "\n", "basesize_ratio_range", "=", "(", "0.15", ",", "0.9", ")", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "100", ",", "300", "]", ",", "\n", "ratios", "=", "[", "[", "2", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", "]", ",", "[", "2", "]", "]", ")", "\n", "\n", "featmap_sizes", "=", "[", "(", "38", ",", "38", ")", ",", "(", "19", ",", "19", ")", ",", "(", "10", ",", "10", ")", ",", "(", "5", ",", "5", ")", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", "]", "\n", "anchor_generator", "=", "build_anchor_generator", "(", "anchor_generator_cfg", ")", "\n", "anchors", "=", "anchor_generator", ".", "grid_anchors", "(", "featmap_sizes", ",", "device", ")", "\n", "\n", "anchor_generator_cfg_tuples", "=", "dict", "(", "\n", "type", "=", "'SSDAnchorGenerator'", ",", "\n", "scale_major", "=", "False", ",", "\n", "input_size", "=", "300", ",", "\n", "basesize_ratio_range", "=", "(", "0.15", ",", "0.9", ")", ",", "\n", "strides", "=", "[", "(", "8", ",", "8", ")", ",", "(", "16", ",", "16", ")", ",", "(", "32", ",", "32", ")", ",", "(", "64", ",", "64", ")", ",", "(", "100", ",", "100", ")", ",", "(", "300", ",", "300", ")", "]", ",", "\n", "ratios", "=", "[", "[", "2", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", ",", "3", "]", ",", "[", "2", "]", ",", "[", "2", "]", "]", ")", "\n", "\n", "anchor_generator_tuples", "=", "build_anchor_generator", "(", "\n", "anchor_generator_cfg_tuples", ")", "\n", "anchors_tuples", "=", "anchor_generator_tuples", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", ")", "\n", "for", "anchor", ",", "anchor_tuples", "in", "zip", "(", "anchors", ",", "anchors_tuples", ")", ":", "\n", "        ", "assert", "torch", ".", "equal", "(", "anchor", ",", "anchor_tuples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_retina_anchor": [[148, 245], ["torch.cuda.is_available", "dict", "build_head", "enumerate", "build_head.anchor_generator.valid_flags", "enumerate", "build_head.anchor_generator.grid_anchors", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "base_anchor.allclose", "len", "dict", "dict", "single_level_valid_flag.sum"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors"], ["", "", "def", "test_retina_anchor", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "models", "import", "build_head", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "'cuda'", "\n", "", "else", ":", "\n", "        ", "device", "=", "'cpu'", "\n", "\n", "# head configs modified from", "\n", "# configs/nas_fpn/retinanet_r50_fpn_crop640_50e.py", "\n", "", "bbox_head", "=", "dict", "(", "\n", "type", "=", "'RetinaSepBNHead'", ",", "\n", "num_classes", "=", "4", ",", "\n", "num_ins", "=", "5", ",", "\n", "in_channels", "=", "4", ",", "\n", "stacked_convs", "=", "1", ",", "\n", "feat_channels", "=", "4", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "4", ",", "\n", "scales_per_octave", "=", "3", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", ".0", ",", ".0", ",", ".0", ",", ".0", "]", ",", "\n", "target_stds", "=", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ")", ")", "\n", "\n", "retina_head", "=", "build_head", "(", "bbox_head", ")", "\n", "assert", "retina_head", ".", "anchor_generator", "is", "not", "None", "\n", "\n", "# use the featmap sizes in NASFPN setting to test retina head", "\n", "featmap_sizes", "=", "[", "(", "80", ",", "80", ")", ",", "(", "40", ",", "40", ")", ",", "(", "20", ",", "20", ")", ",", "(", "10", ",", "10", ")", ",", "(", "5", ",", "5", ")", "]", "\n", "# check base anchors", "\n", "expected_base_anchors", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "22.6274", ",", "-", "11.3137", ",", "22.6274", ",", "11.3137", "]", ",", "\n", "[", "-", "28.5088", ",", "-", "14.2544", ",", "28.5088", ",", "14.2544", "]", ",", "\n", "[", "-", "35.9188", ",", "-", "17.9594", ",", "35.9188", ",", "17.9594", "]", ",", "\n", "[", "-", "16.0000", ",", "-", "16.0000", ",", "16.0000", ",", "16.0000", "]", ",", "\n", "[", "-", "20.1587", ",", "-", "20.1587", ",", "20.1587", ",", "20.1587", "]", ",", "\n", "[", "-", "25.3984", ",", "-", "25.3984", ",", "25.3984", ",", "25.3984", "]", ",", "\n", "[", "-", "11.3137", ",", "-", "22.6274", ",", "11.3137", ",", "22.6274", "]", ",", "\n", "[", "-", "14.2544", ",", "-", "28.5088", ",", "14.2544", ",", "28.5088", "]", ",", "\n", "[", "-", "17.9594", ",", "-", "35.9188", ",", "17.9594", ",", "35.9188", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "45.2548", ",", "-", "22.6274", ",", "45.2548", ",", "22.6274", "]", ",", "\n", "[", "-", "57.0175", ",", "-", "28.5088", ",", "57.0175", ",", "28.5088", "]", ",", "\n", "[", "-", "71.8376", ",", "-", "35.9188", ",", "71.8376", ",", "35.9188", "]", ",", "\n", "[", "-", "32.0000", ",", "-", "32.0000", ",", "32.0000", ",", "32.0000", "]", ",", "\n", "[", "-", "40.3175", ",", "-", "40.3175", ",", "40.3175", ",", "40.3175", "]", ",", "\n", "[", "-", "50.7968", ",", "-", "50.7968", ",", "50.7968", ",", "50.7968", "]", ",", "\n", "[", "-", "22.6274", ",", "-", "45.2548", ",", "22.6274", ",", "45.2548", "]", ",", "\n", "[", "-", "28.5088", ",", "-", "57.0175", ",", "28.5088", ",", "57.0175", "]", ",", "\n", "[", "-", "35.9188", ",", "-", "71.8376", ",", "35.9188", ",", "71.8376", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "90.5097", ",", "-", "45.2548", ",", "90.5097", ",", "45.2548", "]", ",", "\n", "[", "-", "114.0350", ",", "-", "57.0175", ",", "114.0350", ",", "57.0175", "]", ",", "\n", "[", "-", "143.6751", ",", "-", "71.8376", ",", "143.6751", ",", "71.8376", "]", ",", "\n", "[", "-", "64.0000", ",", "-", "64.0000", ",", "64.0000", ",", "64.0000", "]", ",", "\n", "[", "-", "80.6349", ",", "-", "80.6349", ",", "80.6349", ",", "80.6349", "]", ",", "\n", "[", "-", "101.5937", ",", "-", "101.5937", ",", "101.5937", ",", "101.5937", "]", ",", "\n", "[", "-", "45.2548", ",", "-", "90.5097", ",", "45.2548", ",", "90.5097", "]", ",", "\n", "[", "-", "57.0175", ",", "-", "114.0350", ",", "57.0175", ",", "114.0350", "]", ",", "\n", "[", "-", "71.8376", ",", "-", "143.6751", ",", "71.8376", ",", "143.6751", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "181.0193", ",", "-", "90.5097", ",", "181.0193", ",", "90.5097", "]", ",", "\n", "[", "-", "228.0701", ",", "-", "114.0350", ",", "228.0701", ",", "114.0350", "]", ",", "\n", "[", "-", "287.3503", ",", "-", "143.6751", ",", "287.3503", ",", "143.6751", "]", ",", "\n", "[", "-", "128.0000", ",", "-", "128.0000", ",", "128.0000", ",", "128.0000", "]", ",", "\n", "[", "-", "161.2699", ",", "-", "161.2699", ",", "161.2699", ",", "161.2699", "]", ",", "\n", "[", "-", "203.1873", ",", "-", "203.1873", ",", "203.1873", ",", "203.1873", "]", ",", "\n", "[", "-", "90.5097", ",", "-", "181.0193", ",", "90.5097", ",", "181.0193", "]", ",", "\n", "[", "-", "114.0350", ",", "-", "228.0701", ",", "114.0350", ",", "228.0701", "]", ",", "\n", "[", "-", "143.6751", ",", "-", "287.3503", ",", "143.6751", ",", "287.3503", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "362.0387", ",", "-", "181.0193", ",", "362.0387", ",", "181.0193", "]", ",", "\n", "[", "-", "456.1401", ",", "-", "228.0701", ",", "456.1401", ",", "228.0701", "]", ",", "\n", "[", "-", "574.7006", ",", "-", "287.3503", ",", "574.7006", ",", "287.3503", "]", ",", "\n", "[", "-", "256.0000", ",", "-", "256.0000", ",", "256.0000", ",", "256.0000", "]", ",", "\n", "[", "-", "322.5398", ",", "-", "322.5398", ",", "322.5398", ",", "322.5398", "]", ",", "\n", "[", "-", "406.3747", ",", "-", "406.3747", ",", "406.3747", ",", "406.3747", "]", ",", "\n", "[", "-", "181.0193", ",", "-", "362.0387", ",", "181.0193", ",", "362.0387", "]", ",", "\n", "[", "-", "228.0701", ",", "-", "456.1401", ",", "228.0701", ",", "456.1401", "]", ",", "\n", "[", "-", "287.3503", ",", "-", "574.7006", ",", "287.3503", ",", "574.7006", "]", "]", ")", "\n", "]", "\n", "base_anchors", "=", "retina_head", ".", "anchor_generator", ".", "base_anchors", "\n", "for", "i", ",", "base_anchor", "in", "enumerate", "(", "base_anchors", ")", ":", "\n", "        ", "assert", "base_anchor", ".", "allclose", "(", "expected_base_anchors", "[", "i", "]", ")", "\n", "\n", "# check valid flags", "\n", "", "expected_valid_pixels", "=", "[", "57600", ",", "14400", ",", "3600", ",", "900", ",", "225", "]", "\n", "multi_level_valid_flags", "=", "retina_head", ".", "anchor_generator", ".", "valid_flags", "(", "\n", "featmap_sizes", ",", "(", "640", ",", "640", ")", ",", "device", ")", "\n", "for", "i", ",", "single_level_valid_flag", "in", "enumerate", "(", "multi_level_valid_flags", ")", ":", "\n", "        ", "assert", "single_level_valid_flag", ".", "sum", "(", ")", "==", "expected_valid_pixels", "[", "i", "]", "\n", "\n", "# check number of base anchors for each level", "\n", "", "assert", "retina_head", ".", "anchor_generator", ".", "num_base_anchors", "==", "[", "9", ",", "9", ",", "9", ",", "9", ",", "9", "]", "\n", "\n", "# check anchor generation", "\n", "anchors", "=", "retina_head", ".", "anchor_generator", ".", "grid_anchors", "(", "featmap_sizes", ",", "device", ")", "\n", "assert", "len", "(", "anchors", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_anchor.test_guided_anchor": [[247, 368], ["torch.cuda.is_available", "dict", "build_head", "enumerate", "build_head.approx_anchor_generator.valid_flags", "enumerate", "build_head.square_anchor_generator.grid_anchors", "enumerate", "build_head.square_anchor_generator.grid_anchors", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "base_anchor.allclose", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "base_anchor.allclose", "len", "dict", "dict", "single_level_valid_flag.sum"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_head", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.point_generator.PointGenerator.valid_flags", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.anchor.anchor_generator.AnchorGenerator.grid_anchors"], ["", "def", "test_guided_anchor", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "models", "import", "build_head", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "'cuda'", "\n", "", "else", ":", "\n", "        ", "device", "=", "'cpu'", "\n", "# head configs modified from", "\n", "# configs/guided_anchoring/ga_retinanet_r50_fpn_1x_coco.py", "\n", "", "bbox_head", "=", "dict", "(", "\n", "type", "=", "'GARetinaHead'", ",", "\n", "num_classes", "=", "8", ",", "\n", "in_channels", "=", "4", ",", "\n", "stacked_convs", "=", "1", ",", "\n", "feat_channels", "=", "4", ",", "\n", "approx_anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "4", ",", "\n", "scales_per_octave", "=", "3", ",", "\n", "ratios", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ",", "\n", "square_anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "ratios", "=", "[", "1.0", "]", ",", "\n", "scales", "=", "[", "4", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ")", "\n", "\n", "ga_retina_head", "=", "build_head", "(", "bbox_head", ")", "\n", "assert", "ga_retina_head", ".", "approx_anchor_generator", "is", "not", "None", "\n", "\n", "# use the featmap sizes in NASFPN setting to test ga_retina_head", "\n", "featmap_sizes", "=", "[", "(", "100", ",", "152", ")", ",", "(", "50", ",", "76", ")", ",", "(", "25", ",", "38", ")", ",", "(", "13", ",", "19", ")", ",", "(", "7", ",", "10", ")", "]", "\n", "# check base anchors", "\n", "expected_approxs", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "22.6274", ",", "-", "11.3137", ",", "22.6274", ",", "11.3137", "]", ",", "\n", "[", "-", "28.5088", ",", "-", "14.2544", ",", "28.5088", ",", "14.2544", "]", ",", "\n", "[", "-", "35.9188", ",", "-", "17.9594", ",", "35.9188", ",", "17.9594", "]", ",", "\n", "[", "-", "16.0000", ",", "-", "16.0000", ",", "16.0000", ",", "16.0000", "]", ",", "\n", "[", "-", "20.1587", ",", "-", "20.1587", ",", "20.1587", ",", "20.1587", "]", ",", "\n", "[", "-", "25.3984", ",", "-", "25.3984", ",", "25.3984", ",", "25.3984", "]", ",", "\n", "[", "-", "11.3137", ",", "-", "22.6274", ",", "11.3137", ",", "22.6274", "]", ",", "\n", "[", "-", "14.2544", ",", "-", "28.5088", ",", "14.2544", ",", "28.5088", "]", ",", "\n", "[", "-", "17.9594", ",", "-", "35.9188", ",", "17.9594", ",", "35.9188", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "45.2548", ",", "-", "22.6274", ",", "45.2548", ",", "22.6274", "]", ",", "\n", "[", "-", "57.0175", ",", "-", "28.5088", ",", "57.0175", ",", "28.5088", "]", ",", "\n", "[", "-", "71.8376", ",", "-", "35.9188", ",", "71.8376", ",", "35.9188", "]", ",", "\n", "[", "-", "32.0000", ",", "-", "32.0000", ",", "32.0000", ",", "32.0000", "]", ",", "\n", "[", "-", "40.3175", ",", "-", "40.3175", ",", "40.3175", ",", "40.3175", "]", ",", "\n", "[", "-", "50.7968", ",", "-", "50.7968", ",", "50.7968", ",", "50.7968", "]", ",", "\n", "[", "-", "22.6274", ",", "-", "45.2548", ",", "22.6274", ",", "45.2548", "]", ",", "\n", "[", "-", "28.5088", ",", "-", "57.0175", ",", "28.5088", ",", "57.0175", "]", ",", "\n", "[", "-", "35.9188", ",", "-", "71.8376", ",", "35.9188", ",", "71.8376", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "90.5097", ",", "-", "45.2548", ",", "90.5097", ",", "45.2548", "]", ",", "\n", "[", "-", "114.0350", ",", "-", "57.0175", ",", "114.0350", ",", "57.0175", "]", ",", "\n", "[", "-", "143.6751", ",", "-", "71.8376", ",", "143.6751", ",", "71.8376", "]", ",", "\n", "[", "-", "64.0000", ",", "-", "64.0000", ",", "64.0000", ",", "64.0000", "]", ",", "\n", "[", "-", "80.6349", ",", "-", "80.6349", ",", "80.6349", ",", "80.6349", "]", ",", "\n", "[", "-", "101.5937", ",", "-", "101.5937", ",", "101.5937", ",", "101.5937", "]", ",", "\n", "[", "-", "45.2548", ",", "-", "90.5097", ",", "45.2548", ",", "90.5097", "]", ",", "\n", "[", "-", "57.0175", ",", "-", "114.0350", ",", "57.0175", ",", "114.0350", "]", ",", "\n", "[", "-", "71.8376", ",", "-", "143.6751", ",", "71.8376", ",", "143.6751", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "181.0193", ",", "-", "90.5097", ",", "181.0193", ",", "90.5097", "]", ",", "\n", "[", "-", "228.0701", ",", "-", "114.0350", ",", "228.0701", ",", "114.0350", "]", ",", "\n", "[", "-", "287.3503", ",", "-", "143.6751", ",", "287.3503", ",", "143.6751", "]", ",", "\n", "[", "-", "128.0000", ",", "-", "128.0000", ",", "128.0000", ",", "128.0000", "]", ",", "\n", "[", "-", "161.2699", ",", "-", "161.2699", ",", "161.2699", ",", "161.2699", "]", ",", "\n", "[", "-", "203.1873", ",", "-", "203.1873", ",", "203.1873", ",", "203.1873", "]", ",", "\n", "[", "-", "90.5097", ",", "-", "181.0193", ",", "90.5097", ",", "181.0193", "]", ",", "\n", "[", "-", "114.0350", ",", "-", "228.0701", ",", "114.0350", ",", "228.0701", "]", ",", "\n", "[", "-", "143.6751", ",", "-", "287.3503", ",", "143.6751", ",", "287.3503", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "362.0387", ",", "-", "181.0193", ",", "362.0387", ",", "181.0193", "]", ",", "\n", "[", "-", "456.1401", ",", "-", "228.0701", ",", "456.1401", ",", "228.0701", "]", ",", "\n", "[", "-", "574.7006", ",", "-", "287.3503", ",", "574.7006", ",", "287.3503", "]", ",", "\n", "[", "-", "256.0000", ",", "-", "256.0000", ",", "256.0000", ",", "256.0000", "]", ",", "\n", "[", "-", "322.5398", ",", "-", "322.5398", ",", "322.5398", ",", "322.5398", "]", ",", "\n", "[", "-", "406.3747", ",", "-", "406.3747", ",", "406.3747", ",", "406.3747", "]", ",", "\n", "[", "-", "181.0193", ",", "-", "362.0387", ",", "181.0193", ",", "362.0387", "]", ",", "\n", "[", "-", "228.0701", ",", "-", "456.1401", ",", "228.0701", ",", "456.1401", "]", ",", "\n", "[", "-", "287.3503", ",", "-", "574.7006", ",", "287.3503", ",", "574.7006", "]", "]", ")", "\n", "]", "\n", "approxs", "=", "ga_retina_head", ".", "approx_anchor_generator", ".", "base_anchors", "\n", "for", "i", ",", "base_anchor", "in", "enumerate", "(", "approxs", ")", ":", "\n", "        ", "assert", "base_anchor", ".", "allclose", "(", "expected_approxs", "[", "i", "]", ")", "\n", "\n", "# check valid flags", "\n", "", "expected_valid_pixels", "=", "[", "136800", ",", "34200", ",", "8550", ",", "2223", ",", "630", "]", "\n", "multi_level_valid_flags", "=", "ga_retina_head", ".", "approx_anchor_generator", ".", "valid_flags", "(", "featmap_sizes", ",", "(", "800", ",", "1216", ")", ",", "device", ")", "\n", "for", "i", ",", "single_level_valid_flag", "in", "enumerate", "(", "multi_level_valid_flags", ")", ":", "\n", "        ", "assert", "single_level_valid_flag", ".", "sum", "(", ")", "==", "expected_valid_pixels", "[", "i", "]", "\n", "\n", "# check number of base anchors for each level", "\n", "", "assert", "ga_retina_head", ".", "approx_anchor_generator", ".", "num_base_anchors", "==", "[", "\n", "9", ",", "9", ",", "9", ",", "9", ",", "9", "\n", "]", "\n", "\n", "# check approx generation", "\n", "squares", "=", "ga_retina_head", ".", "square_anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", ")", "\n", "assert", "len", "(", "squares", ")", "==", "5", "\n", "\n", "expected_squares", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "16.", ",", "-", "16.", ",", "16.", ",", "16.", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "32.", ",", "-", "32.", ",", "32.", ",", "32", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "64.", ",", "-", "64.", ",", "64.", ",", "64.", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "128.", ",", "-", "128.", ",", "128.", ",", "128.", "]", "]", ")", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "-", "256.", ",", "-", "256.", ",", "256.", ",", "256.", "]", "]", ")", "\n", "]", "\n", "squares", "=", "ga_retina_head", ".", "square_anchor_generator", ".", "base_anchors", "\n", "for", "i", ",", "base_anchor", "in", "enumerate", "(", "squares", ")", ":", "\n", "        ", "assert", "base_anchor", ".", "allclose", "(", "expected_squares", "[", "i", "]", ")", "\n", "\n", "# square_anchor_generator does not check valid flags", "\n", "# check number of base anchors for each level", "\n", "", "assert", "(", "ga_retina_head", ".", "square_anchor_generator", ".", "num_base_anchors", "==", "[", "\n", "1", ",", "1", ",", "1", ",", "1", ",", "1", "\n", "]", ")", "\n", "\n", "# check square generation", "\n", "anchors", "=", "ga_retina_head", ".", "square_anchor_generator", ".", "grid_anchors", "(", "\n", "featmap_sizes", ",", "device", ")", "\n", "assert", "len", "(", "anchors", ")", "==", "5", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks": [[8, 17], ["numpy.random.randint"], "function", ["None"], ["def", "dummy_raw_bitmap_masks", "(", "size", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        size (tuple): expected shape of dummy masks, (H, W) or (N, H, W)\n\n    Return:\n        ndarray: dummy mask\n    \"\"\"", "\n", "return", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "size", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks": [[19, 33], ["range", "polygons.append", "numpy.random.randint", "numpy.random.uniform", "min"], "function", ["None"], ["", "def", "dummy_raw_polygon_masks", "(", "size", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        size (tuple): expected shape of dummy masks, (N, H, W)\n\n    Return:\n        list[list[ndarray]]: dummy mask\n    \"\"\"", "\n", "num_obj", ",", "heigt", ",", "width", "=", "size", "\n", "polygons", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_obj", ")", ":", "\n", "        ", "num_points", "=", "np", ".", "random", ".", "randint", "(", "5", ")", "*", "2", "+", "6", "\n", "polygons", ".", "append", "(", "[", "np", ".", "random", ".", "uniform", "(", "0", ",", "min", "(", "heigt", ",", "width", ")", ",", "num_points", ")", "]", ")", "\n", "", "return", "polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_bboxes": [[35, 40], ["numpy.random.randint", "numpy.random.randint", "numpy.concatenate().squeeze().astype", "min", "min", "numpy.concatenate().squeeze", "numpy.concatenate"], "function", ["None"], ["", "def", "dummy_bboxes", "(", "num", ",", "max_height", ",", "max_width", ")", ":", "\n", "    ", "x1y1", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "min", "(", "max_height", "//", "2", ",", "max_width", "//", "2", ")", ",", "(", "num", ",", "2", ")", ")", "\n", "wh", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "min", "(", "max_height", "//", "2", ",", "max_width", "//", "2", ")", ",", "(", "num", ",", "2", ")", ")", "\n", "x2y2", "=", "x1y1", "+", "wh", "\n", "return", "np", ".", "concatenate", "(", "[", "x1y1", ",", "x2y2", "]", ",", "axis", "=", "1", ")", ".", "squeeze", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_init": [[42, 75], ["numpy.empty", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "len", "len", "len", "test_masks.dummy_raw_bitmap_masks", "len", "pytest.raises", "mmdet.core.BitmapMasks", "range", "test_masks.dummy_raw_bitmap_masks"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks"], ["", "def", "test_bitmap_mask_init", "(", ")", ":", "\n", "# init with empty ndarray masks", "\n", "    ", "raw_masks", "=", "np", ".", "empty", "(", "(", "0", ",", "28", ",", "28", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "len", "(", "bitmap_masks", ")", "==", "0", "\n", "assert", "bitmap_masks", ".", "height", "==", "28", "\n", "assert", "bitmap_masks", ".", "width", "==", "28", "\n", "\n", "# init with empty list masks", "\n", "raw_masks", "=", "[", "]", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "len", "(", "bitmap_masks", ")", "==", "0", "\n", "assert", "bitmap_masks", ".", "height", "==", "28", "\n", "assert", "bitmap_masks", ".", "width", "==", "28", "\n", "\n", "# init with ndarray masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "len", "(", "bitmap_masks", ")", "==", "3", "\n", "assert", "bitmap_masks", ".", "height", "==", "28", "\n", "assert", "bitmap_masks", ".", "width", "==", "28", "\n", "\n", "# init with list masks contain 3 instances", "\n", "raw_masks", "=", "[", "dummy_raw_bitmap_masks", "(", "(", "28", ",", "28", ")", ")", "for", "_", "in", "range", "(", "3", ")", "]", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "len", "(", "bitmap_masks", ")", "==", "3", "\n", "assert", "bitmap_masks", ".", "height", "==", "28", "\n", "assert", "bitmap_masks", ".", "width", "==", "28", "\n", "\n", "# init with raw masks of unsupported type", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "raw_masks", "=", "[", "[", "dummy_raw_bitmap_masks", "(", "(", "28", ",", "28", ")", ")", "]", "]", "\n", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_rescale": [[77, 96], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.rescale", "numpy.array", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.rescale", "numpy.array", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale"], ["", "", "def", "test_bitmap_mask_rescale", "(", ")", ":", "\n", "# rescale with empty bitmap masks", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "rescaled_masks", "=", "bitmap_masks", ".", "rescale", "(", "(", "56", ",", "72", ")", ")", "\n", "assert", "len", "(", "rescaled_masks", ")", "==", "0", "\n", "assert", "rescaled_masks", ".", "height", "==", "56", "\n", "assert", "rescaled_masks", ".", "width", "==", "56", "\n", "\n", "# rescale with bitmap masks contain 1 instances", "\n", "raw_masks", "=", "np", ".", "array", "(", "[", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "1", ",", "0", ",", "1", "]", "]", "]", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "2", ",", "4", ")", "\n", "rescaled_masks", "=", "bitmap_masks", ".", "rescale", "(", "(", "8", ",", "8", ")", ")", "\n", "assert", "len", "(", "rescaled_masks", ")", "==", "1", "\n", "assert", "rescaled_masks", ".", "height", "==", "4", "\n", "assert", "rescaled_masks", ".", "width", "==", "8", "\n", "truth", "=", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "1", ",", "1", "]", "]", "]", ")", "\n", "assert", "(", "rescaled_masks", ".", "masks", "==", "truth", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_resize": [[98, 119], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.resize", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.resize", "numpy.array", "len", "numpy.diag", "len", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize"], ["", "def", "test_bitmap_mask_resize", "(", ")", ":", "\n", "# resize with empty bitmap masks", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "resized_masks", "=", "bitmap_masks", ".", "resize", "(", "(", "56", ",", "72", ")", ")", "\n", "assert", "len", "(", "resized_masks", ")", "==", "0", "\n", "assert", "resized_masks", ".", "height", "==", "56", "\n", "assert", "resized_masks", ".", "width", "==", "72", "\n", "\n", "# resize with bitmap masks contain 1 instances", "\n", "raw_masks", "=", "np", ".", "diag", "(", "np", ".", "ones", "(", "4", ",", "dtype", "=", "np", ".", "uint8", ")", ")", "[", "np", ".", "newaxis", ",", "...", "]", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "4", ",", "4", ")", "\n", "resized_masks", "=", "bitmap_masks", ".", "resize", "(", "(", "8", ",", "8", ")", ")", "\n", "assert", "len", "(", "resized_masks", ")", "==", "1", "\n", "assert", "resized_masks", ".", "height", "==", "8", "\n", "assert", "resized_masks", ".", "width", "==", "8", "\n", "truth", "=", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", "]", "]", "]", ")", "\n", "assert", "(", "resized_masks", ".", "masks", "==", "truth", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_flip": [[121, 149], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.flip", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.flip", "bitmap_masks.flip.flip", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.flip", "bitmap_masks.flip.flip", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip"], ["", "def", "test_bitmap_mask_flip", "(", ")", ":", "\n", "# flip with empty bitmap masks", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "bitmap_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "assert", "len", "(", "flipped_masks", ")", "==", "0", "\n", "assert", "flipped_masks", ".", "height", "==", "28", "\n", "assert", "flipped_masks", ".", "width", "==", "28", "\n", "\n", "# horizontally flip with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "bitmap_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "flipped_flipped_masks", "=", "flipped_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "assert", "flipped_masks", ".", "masks", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "bitmap_masks", ".", "masks", "==", "flipped_flipped_masks", ".", "masks", ")", ".", "all", "(", ")", "\n", "assert", "(", "flipped_masks", ".", "masks", "==", "raw_masks", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", ".", "all", "(", ")", "\n", "\n", "# vertically flip with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "bitmap_masks", ".", "flip", "(", "flip_direction", "=", "'vertical'", ")", "\n", "flipped_flipped_masks", "=", "flipped_masks", ".", "flip", "(", "flip_direction", "=", "'vertical'", ")", "\n", "assert", "len", "(", "flipped_masks", ")", "==", "3", "\n", "assert", "flipped_masks", ".", "height", "==", "28", "\n", "assert", "flipped_masks", ".", "width", "==", "28", "\n", "assert", "(", "bitmap_masks", ".", "masks", "==", "flipped_flipped_masks", ".", "masks", ")", ".", "all", "(", ")", "\n", "assert", "(", "flipped_masks", ".", "masks", "==", "raw_masks", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_pad": [[151, 168], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.pad", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.pad", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad"], ["", "def", "test_bitmap_mask_pad", "(", ")", ":", "\n", "# pad with empty bitmap masks", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "padded_masks", "=", "bitmap_masks", ".", "pad", "(", "(", "56", ",", "56", ")", ")", "\n", "assert", "len", "(", "padded_masks", ")", "==", "0", "\n", "assert", "padded_masks", ".", "height", "==", "56", "\n", "assert", "padded_masks", ".", "width", "==", "56", "\n", "\n", "# pad with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "padded_masks", "=", "bitmap_masks", ".", "pad", "(", "(", "56", ",", "56", ")", ")", "\n", "assert", "len", "(", "padded_masks", ")", "==", "3", "\n", "assert", "padded_masks", ".", "height", "==", "56", "\n", "assert", "padded_masks", ".", "width", "==", "56", "\n", "assert", "(", "padded_masks", ".", "masks", "[", ":", ",", "28", ":", ",", "28", ":", "]", "==", "0", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_crop": [[170, 194], ["numpy.array", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.crop", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.crop", "len", "len", "pytest.raises", "test_masks.dummy_bboxes", "mmdet.core.BitmapMasks.crop"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop"], ["", "def", "test_bitmap_mask_crop", "(", ")", ":", "\n", "# crop with empty bitmap masks", "\n", "    ", "dummy_bbox", "=", "np", ".", "array", "(", "[", "0", ",", "10", ",", "10", ",", "27", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_masks", "=", "bitmap_masks", ".", "crop", "(", "dummy_bbox", ")", "\n", "assert", "len", "(", "cropped_masks", ")", "==", "0", "\n", "assert", "cropped_masks", ".", "height", "==", "17", "\n", "assert", "cropped_masks", ".", "width", "==", "10", "\n", "\n", "# crop with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_masks", "=", "bitmap_masks", ".", "crop", "(", "dummy_bbox", ")", "\n", "assert", "len", "(", "cropped_masks", ")", "==", "3", "\n", "assert", "cropped_masks", ".", "height", "==", "17", "\n", "assert", "cropped_masks", ".", "width", "==", "10", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "dummy_bbox", "\n", "assert", "(", "cropped_masks", ".", "masks", "==", "raw_masks", "[", ":", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", ")", ".", "all", "(", ")", "\n", "\n", "# crop with invalid bbox", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dummy_bbox", "=", "dummy_bboxes", "(", "2", ",", "28", ",", "28", ")", "\n", "bitmap_masks", ".", "crop", "(", "dummy_bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_crop_and_resize": [[196, 217], ["test_masks.dummy_bboxes", "numpy.random.randint", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.crop_and_resize", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.crop_and_resize", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize"], ["", "", "def", "test_bitmap_mask_crop_and_resize", "(", ")", ":", "\n", "    ", "dummy_bbox", "=", "dummy_bboxes", "(", "5", ",", "28", ",", "28", ")", "\n", "inds", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "3", ",", "(", "5", ",", ")", ")", "\n", "\n", "# crop and resize with empty bitmap masks", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_resized_masks", "=", "bitmap_masks", ".", "crop_and_resize", "(", "\n", "dummy_bbox", ",", "(", "56", ",", "56", ")", ",", "inds", ")", "\n", "assert", "len", "(", "cropped_resized_masks", ")", "==", "0", "\n", "assert", "cropped_resized_masks", ".", "height", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "width", "==", "56", "\n", "\n", "# crop and resize with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_resized_masks", "=", "bitmap_masks", ".", "crop_and_resize", "(", "\n", "dummy_bbox", ",", "(", "56", ",", "56", ")", ",", "inds", ")", "\n", "assert", "len", "(", "cropped_resized_masks", ")", "==", "5", "\n", "assert", "cropped_resized_masks", ".", "height", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "width", "==", "56", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_expand": [[219, 237], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.expand", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.expand", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "test_bitmap_mask_expand", "(", ")", ":", "\n", "# expand with empty bitmap masks", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "expanded_masks", "=", "bitmap_masks", ".", "expand", "(", "56", ",", "56", ",", "12", ",", "14", ")", "\n", "assert", "len", "(", "expanded_masks", ")", "==", "0", "\n", "assert", "expanded_masks", ".", "height", "==", "56", "\n", "assert", "expanded_masks", ".", "width", "==", "56", "\n", "\n", "# expand with bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "expanded_masks", "=", "bitmap_masks", ".", "expand", "(", "56", ",", "56", ",", "12", ",", "14", ")", "\n", "assert", "len", "(", "expanded_masks", ")", "==", "3", "\n", "assert", "expanded_masks", ".", "height", "==", "56", "\n", "assert", "expanded_masks", ".", "width", "==", "56", "\n", "assert", "(", "expanded_masks", ".", "masks", "[", ":", ",", ":", "12", ",", ":", "14", "]", "==", "0", ")", ".", "all", "(", ")", "\n", "assert", "(", "expanded_masks", ".", "masks", "[", ":", ",", "12", "+", "28", ":", ",", "14", "+", "28", ":", "]", "==", "0", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_area": [[239, 251], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.areas.sum", "len", "dummy_raw_bitmap_masks.sum"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks"], ["", "def", "test_bitmap_mask_area", "(", ")", ":", "\n", "# area of empty bitmap mask", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "bitmap_masks", ".", "areas", ".", "sum", "(", ")", "==", "0", "\n", "\n", "# area of bitmap masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "areas", "=", "bitmap_masks", ".", "areas", "\n", "assert", "len", "(", "areas", ")", "==", "3", "\n", "assert", "(", "areas", "==", "raw_masks", ".", "sum", "(", "(", "1", ",", "2", ")", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_to_ndarray": [[253, 268], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.to_ndarray", "isinstance", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.to_ndarray", "isinstance"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_bitmap_mask_to_ndarray", "(", ")", ":", "\n", "# empty bitmap masks to ndarray", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "ndarray_masks", "=", "bitmap_masks", ".", "to_ndarray", "(", ")", "\n", "assert", "isinstance", "(", "ndarray_masks", ",", "np", ".", "ndarray", ")", "\n", "assert", "ndarray_masks", ".", "shape", "==", "(", "0", ",", "28", ",", "28", ")", "\n", "\n", "# bitmap masks contain 3 instances to ndarray", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "ndarray_masks", "=", "bitmap_masks", ".", "to_ndarray", "(", ")", "\n", "assert", "isinstance", "(", "ndarray_masks", ",", "np", ".", "ndarray", ")", "\n", "assert", "ndarray_masks", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "ndarray_masks", "==", "raw_masks", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_to_tensor": [[270, 285], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.to_tensor", "isinstance", "test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks.to_tensor", "isinstance", "bitmap_masks.to_tensor.numpy"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor"], ["", "def", "test_bitmap_mask_to_tensor", "(", ")", ":", "\n", "# empty bitmap masks to tensor", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "tensor_masks", "=", "bitmap_masks", ".", "to_tensor", "(", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cpu'", ")", "\n", "assert", "isinstance", "(", "tensor_masks", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_masks", ".", "shape", "==", "(", "0", ",", "28", ",", "28", ")", "\n", "\n", "# bitmap masks contain 3 instances to tensor", "\n", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "tensor_masks", "=", "bitmap_masks", ".", "to_tensor", "(", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cpu'", ")", "\n", "assert", "isinstance", "(", "tensor_masks", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_masks", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "tensor_masks", ".", "numpy", "(", ")", "==", "raw_masks", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_index": [[287, 292], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "range", "range"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks"], ["", "def", "test_bitmap_mask_index", "(", ")", ":", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "(", "bitmap_masks", "[", "0", "]", ".", "masks", "==", "raw_masks", "[", "0", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "bitmap_masks", "[", "range", "(", "2", ")", "]", ".", "masks", "==", "raw_masks", "[", "range", "(", "2", ")", "]", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_bitmap_mask_iter": [[294, 300], ["test_masks.dummy_raw_bitmap_masks", "mmdet.core.BitmapMasks", "enumerate"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_bitmap_masks"], ["", "def", "test_bitmap_mask_iter", "(", ")", ":", "\n", "    ", "raw_masks", "=", "dummy_raw_bitmap_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "bitmap_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "for", "i", ",", "bitmap_mask", "in", "enumerate", "(", "bitmap_masks", ")", ":", "\n", "        ", "assert", "bitmap_mask", ".", "shape", "==", "(", "28", ",", "28", ")", "\n", "assert", "(", "bitmap_mask", "==", "raw_masks", "[", "i", "]", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_init": [[302, 328], ["mmdet.core.BitmapMasks", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "isinstance", "isinstance", "isinstance", "len", "len", "pytest.raises", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_ndarray", "test_masks.dummy_raw_polygon_masks"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks"], ["", "", "def", "test_polygon_mask_init", "(", ")", ":", "\n", "# init with empty masks", "\n", "    ", "raw_masks", "=", "[", "]", "\n", "polygon_masks", "=", "BitmapMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "len", "(", "polygon_masks", ")", "==", "0", "\n", "assert", "polygon_masks", ".", "height", "==", "28", "\n", "assert", "polygon_masks", ".", "width", "==", "28", "\n", "\n", "# init with masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "isinstance", "(", "polygon_masks", ".", "masks", ",", "list", ")", "\n", "assert", "isinstance", "(", "polygon_masks", ".", "masks", "[", "0", "]", ",", "list", ")", "\n", "assert", "isinstance", "(", "polygon_masks", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "np", ".", "ndarray", ")", "\n", "assert", "len", "(", "polygon_masks", ")", "==", "3", "\n", "assert", "polygon_masks", ".", "height", "==", "28", "\n", "assert", "polygon_masks", ".", "width", "==", "28", "\n", "assert", "polygon_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "\n", "# init with raw masks of unsupported type", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "raw_masks", "=", "[", "[", "[", "]", "]", "]", "\n", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "\n", "raw_masks", "=", "[", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "]", "\n", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_rescale": [[330, 356], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.rescale", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.rescale", "numpy.array", "len", "len", "polygon_masks.rescale.to_ndarray", "numpy.array", "polygon_masks.rescale.to_ndarray", "polygon_masks.rescale.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.rescale", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "", "def", "test_polygon_mask_rescale", "(", ")", ":", "\n", "# rescale with empty polygon masks", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "rescaled_masks", "=", "polygon_masks", ".", "rescale", "(", "(", "56", ",", "72", ")", ")", "\n", "assert", "len", "(", "rescaled_masks", ")", "==", "0", "\n", "assert", "rescaled_masks", ".", "height", "==", "56", "\n", "assert", "rescaled_masks", ".", "width", "==", "56", "\n", "assert", "rescaled_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "56", ",", "56", ")", "\n", "\n", "# rescale with polygon masks contain 3 instances", "\n", "raw_masks", "=", "[", "[", "np", ".", "array", "(", "[", "1", ",", "1", ",", "3", ",", "1", ",", "4", ",", "3", ",", "2", ",", "4", ",", "1", ",", "3", "]", ",", "dtype", "=", "np", ".", "float", ")", "]", "]", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "5", ",", "5", ")", "\n", "rescaled_masks", "=", "polygon_masks", ".", "rescale", "(", "(", "12", ",", "10", ")", ")", "\n", "assert", "len", "(", "rescaled_masks", ")", "==", "1", "\n", "assert", "rescaled_masks", ".", "height", "==", "10", "\n", "assert", "rescaled_masks", ".", "width", "==", "10", "\n", "assert", "rescaled_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "1", ",", "10", ",", "10", ")", "\n", "truth", "=", "np", ".", "array", "(", "\n", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "\n", "np", ".", "uint8", ")", "\n", "assert", "(", "rescaled_masks", ".", "to_ndarray", "(", ")", "==", "truth", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_resize": [[358, 411], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.resize", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.resize", "numpy.array", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.resize", "numpy.array", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.resize", "numpy.stack", "len", "len", "len", "len", "polygon_masks.resize.to_ndarray", "numpy.array", "polygon_masks1.resize.to_ndarray", "numpy.array", "numpy.array", "polygon_masks2.resize.to_ndarray", "polygon_masks3.resize.to_ndarray", "numpy.pad", "polygon_masks1.resize.to_ndarray", "polygon_masks2.resize.to_ndarray", "polygon_masks3.resize.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_mask_resize", "(", ")", ":", "\n", "# resize with empty polygon masks", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "resized_masks", "=", "polygon_masks", ".", "resize", "(", "(", "56", ",", "72", ")", ")", "\n", "assert", "len", "(", "resized_masks", ")", "==", "0", "\n", "assert", "resized_masks", ".", "height", "==", "56", "\n", "assert", "resized_masks", ".", "width", "==", "72", "\n", "assert", "resized_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "56", ",", "72", ")", "\n", "\n", "# resize with polygon masks contain 1 instance 1 part", "\n", "raw_masks1", "=", "[", "[", "np", ".", "array", "(", "[", "1", ",", "1", ",", "3", ",", "1", ",", "4", ",", "3", ",", "2", ",", "4", ",", "1", ",", "3", "]", ",", "dtype", "=", "np", ".", "float", ")", "]", "]", "\n", "polygon_masks1", "=", "PolygonMasks", "(", "raw_masks1", ",", "5", ",", "5", ")", "\n", "resized_masks1", "=", "polygon_masks1", ".", "resize", "(", "(", "10", ",", "10", ")", ")", "\n", "assert", "len", "(", "resized_masks1", ")", "==", "1", "\n", "assert", "resized_masks1", ".", "height", "==", "10", "\n", "assert", "resized_masks1", ".", "width", "==", "10", "\n", "assert", "resized_masks1", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "1", ",", "10", ",", "10", ")", "\n", "truth1", "=", "np", ".", "array", "(", "\n", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "\n", "np", ".", "uint8", ")", "\n", "assert", "(", "resized_masks1", ".", "to_ndarray", "(", ")", "==", "truth1", ")", ".", "all", "(", ")", "\n", "\n", "# resize with polygon masks contain 1 instance 2 part", "\n", "raw_masks2", "=", "[", "[", "\n", "np", ".", "array", "(", "[", "0.", ",", "0.", ",", "1.", ",", "0.", ",", "1.", ",", "1.", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "1.", ",", "1.", ",", "2.", ",", "1.", ",", "2.", ",", "2.", ",", "1.", ",", "2.", "]", ")", "\n", "]", "]", "\n", "polygon_masks2", "=", "PolygonMasks", "(", "raw_masks2", ",", "3", ",", "3", ")", "\n", "resized_masks2", "=", "polygon_masks2", ".", "resize", "(", "(", "6", ",", "6", ")", ")", "\n", "assert", "len", "(", "resized_masks2", ")", "==", "1", "\n", "assert", "resized_masks2", ".", "height", "==", "6", "\n", "assert", "resized_masks2", ".", "width", "==", "6", "\n", "assert", "resized_masks2", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "1", ",", "6", ",", "6", ")", "\n", "truth2", "=", "np", ".", "array", "(", "\n", "[", "[", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "np", ".", "uint8", ")", "\n", "assert", "(", "resized_masks2", ".", "to_ndarray", "(", ")", "==", "truth2", ")", ".", "all", "(", ")", "\n", "\n", "# resize with polygon masks contain 2 instances", "\n", "raw_masks3", "=", "[", "raw_masks1", "[", "0", "]", ",", "raw_masks2", "[", "0", "]", "]", "\n", "polygon_masks3", "=", "PolygonMasks", "(", "raw_masks3", ",", "5", ",", "5", ")", "\n", "resized_masks3", "=", "polygon_masks3", ".", "resize", "(", "(", "10", ",", "10", ")", ")", "\n", "assert", "len", "(", "resized_masks3", ")", "==", "2", "\n", "assert", "resized_masks3", ".", "height", "==", "10", "\n", "assert", "resized_masks3", ".", "width", "==", "10", "\n", "assert", "resized_masks3", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "2", ",", "10", ",", "10", ")", "\n", "truth3", "=", "np", ".", "stack", "(", "[", "truth1", ",", "np", ".", "pad", "(", "truth2", ",", "(", "(", "0", ",", "4", ")", ",", "(", "0", ",", "4", ")", ")", ",", "'constant'", ")", "]", ")", "\n", "assert", "(", "resized_masks3", ".", "to_ndarray", "(", ")", "==", "truth3", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_flip": [[413, 446], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.flip", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.flip", "polygon_masks.flip.flip", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.flip", "polygon_masks.flip.flip", "len", "len", "len", "polygon_masks.flip.to_ndarray", "polygon_masks.flip.to_ndarray", "polygon_masks.flip.to_ndarray", "mmdet.core.PolygonMasks.to_ndarray", "flipped_masks.flip.to_ndarray", "mmdet.core.PolygonMasks.to_ndarray", "flipped_masks.flip.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.flip", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_mask_flip", "(", ")", ":", "\n", "# flip with empty polygon masks", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "polygon_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "assert", "len", "(", "flipped_masks", ")", "==", "0", "\n", "assert", "flipped_masks", ".", "height", "==", "28", "\n", "assert", "flipped_masks", ".", "width", "==", "28", "\n", "assert", "flipped_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "28", ",", "28", ")", "\n", "\n", "# TODO: fixed flip correctness checking after v2.0_coord is merged", "\n", "# horizontally flip with polygon masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "polygon_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "flipped_flipped_masks", "=", "flipped_masks", ".", "flip", "(", "flip_direction", "=", "'horizontal'", ")", "\n", "assert", "len", "(", "flipped_masks", ")", "==", "3", "\n", "assert", "flipped_masks", ".", "height", "==", "28", "\n", "assert", "flipped_masks", ".", "width", "==", "28", "\n", "assert", "flipped_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "polygon_masks", ".", "to_ndarray", "(", ")", "==", "flipped_flipped_masks", ".", "to_ndarray", "(", ")", "\n", ")", ".", "all", "(", ")", "\n", "\n", "# vertically flip with polygon masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "flipped_masks", "=", "polygon_masks", ".", "flip", "(", "flip_direction", "=", "'vertical'", ")", "\n", "flipped_flipped_masks", "=", "flipped_masks", ".", "flip", "(", "flip_direction", "=", "'vertical'", ")", "\n", "assert", "len", "(", "flipped_masks", ")", "==", "3", "\n", "assert", "flipped_masks", ".", "height", "==", "28", "\n", "assert", "flipped_masks", ".", "width", "==", "28", "\n", "assert", "flipped_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "polygon_masks", ".", "to_ndarray", "(", ")", "==", "flipped_flipped_masks", ".", "to_ndarray", "(", ")", "\n", ")", ".", "all", "(", ")", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_crop": [[449, 476], ["numpy.array", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.crop", "mmdet.core.PolygonMasks", "numpy.array", "mmdet.core.PolygonMasks.crop", "numpy.array", "len", "len", "pytest.raises", "test_masks.dummy_bboxes", "mmdet.core.PolygonMasks.crop", "polygon_masks.crop.to_ndarray", "numpy.array", "polygon_masks.crop.to_ndarray", "polygon_masks.crop.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_mask_crop", "(", ")", ":", "\n", "    ", "dummy_bbox", "=", "np", ".", "array", "(", "[", "0", ",", "10", ",", "10", ",", "27", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "# crop with empty polygon masks", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_masks", "=", "polygon_masks", ".", "crop", "(", "dummy_bbox", ")", "\n", "assert", "len", "(", "cropped_masks", ")", "==", "0", "\n", "assert", "cropped_masks", ".", "height", "==", "17", "\n", "assert", "cropped_masks", ".", "width", "==", "10", "\n", "assert", "cropped_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "17", ",", "10", ")", "\n", "\n", "# crop with polygon masks contain 1 instances", "\n", "raw_masks", "=", "[", "[", "np", ".", "array", "(", "[", "1.", ",", "3.", ",", "5.", ",", "1.", ",", "5.", ",", "6.", ",", "1", ",", "6", "]", ")", "]", "]", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "7", ",", "7", ")", "\n", "bbox", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "3", ",", "4", "]", ")", "\n", "cropped_masks", "=", "polygon_masks", ".", "crop", "(", "bbox", ")", "\n", "assert", "len", "(", "cropped_masks", ")", "==", "1", "\n", "assert", "cropped_masks", ".", "height", "==", "4", "\n", "assert", "cropped_masks", ".", "width", "==", "3", "\n", "assert", "cropped_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "1", ",", "4", ",", "3", ")", "\n", "truth", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "1", "]", "]", ")", "\n", "assert", "(", "cropped_masks", ".", "to_ndarray", "(", ")", "==", "truth", ")", ".", "all", "(", ")", "\n", "\n", "# crop with invalid bbox", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dummy_bbox", "=", "dummy_bboxes", "(", "2", ",", "28", ",", "28", ")", "\n", "polygon_masks", ".", "crop", "(", "dummy_bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_pad": [[478, 497], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.pad", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.pad", "len", "len", "polygon_masks.pad.to_ndarray", "polygon_masks.pad.to_ndarray", "polygon_masks.pad.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.pad", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "", "def", "test_polygon_mask_pad", "(", ")", ":", "\n", "# pad with empty polygon masks", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "padded_masks", "=", "polygon_masks", ".", "pad", "(", "(", "56", ",", "56", ")", ")", "\n", "assert", "len", "(", "padded_masks", ")", "==", "0", "\n", "assert", "padded_masks", ".", "height", "==", "56", "\n", "assert", "padded_masks", ".", "width", "==", "56", "\n", "assert", "padded_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "56", ",", "56", ")", "\n", "\n", "# pad with polygon masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "padded_masks", "=", "polygon_masks", ".", "pad", "(", "(", "56", ",", "56", ")", ")", "\n", "assert", "len", "(", "padded_masks", ")", "==", "3", "\n", "assert", "padded_masks", ".", "height", "==", "56", "\n", "assert", "padded_masks", ".", "width", "==", "56", "\n", "assert", "padded_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "3", ",", "56", ",", "56", ")", "\n", "assert", "(", "padded_masks", ".", "to_ndarray", "(", ")", "[", ":", ",", "28", ":", ",", "28", ":", "]", "==", "0", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_expand": [[499, 504], ["pytest.raises", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.expand"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.expand"], ["", "def", "test_polygon_mask_expand", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "polygon_masks", ".", "expand", "(", "56", ",", "56", ",", "10", ",", "17", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_crop_and_resize": [[506, 529], ["test_masks.dummy_bboxes", "numpy.random.randint", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.crop_and_resize", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.crop_and_resize", "len", "len", "polygon_masks.crop_and_resize.to_ndarray", "polygon_masks.crop_and_resize.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_bboxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "", "def", "test_polygon_mask_crop_and_resize", "(", ")", ":", "\n", "    ", "dummy_bbox", "=", "dummy_bboxes", "(", "5", ",", "28", ",", "28", ")", "\n", "inds", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "3", ",", "(", "5", ",", ")", ")", "\n", "\n", "# crop and resize with empty polygon masks", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_resized_masks", "=", "polygon_masks", ".", "crop_and_resize", "(", "\n", "dummy_bbox", ",", "(", "56", ",", "56", ")", ",", "inds", ")", "\n", "assert", "len", "(", "cropped_resized_masks", ")", "==", "0", "\n", "assert", "cropped_resized_masks", ".", "height", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "width", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "0", ",", "56", ",", "56", ")", "\n", "\n", "# crop and resize with polygon masks contain 3 instances", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "cropped_resized_masks", "=", "polygon_masks", ".", "crop_and_resize", "(", "\n", "dummy_bbox", ",", "(", "56", ",", "56", ")", ",", "inds", ")", "\n", "assert", "len", "(", "cropped_resized_masks", ")", "==", "5", "\n", "assert", "cropped_resized_masks", ".", "height", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "width", "==", "56", "\n", "assert", "cropped_resized_masks", ".", "to_ndarray", "(", ")", ".", "shape", "==", "(", "5", ",", "56", ",", "56", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_area": [[531, 546], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "numpy.isclose().all", "mmdet.core.PolygonMasks.areas.sum", "mmdet.core.PolygonMasks.to_bitmap", "len", "numpy.array", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_bitmap"], ["", "def", "test_polygon_mask_area", "(", ")", ":", "\n", "# area of empty polygon masks", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "assert", "polygon_masks", ".", "areas", ".", "sum", "(", ")", "==", "0", "\n", "\n", "# area of polygon masks contain 1 instance", "\n", "# here we hack a case that the gap between the area of bitmap and polygon", "\n", "# is minor", "\n", "raw_masks", "=", "[", "[", "np", ".", "array", "(", "[", "1", ",", "1", ",", "5", ",", "1", ",", "3", ",", "4", "]", ")", "]", "]", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "6", ",", "6", ")", "\n", "polygon_area", "=", "polygon_masks", ".", "areas", "\n", "bitmap_area", "=", "polygon_masks", ".", "to_bitmap", "(", ")", ".", "areas", "\n", "assert", "len", "(", "polygon_area", ")", "==", "1", "\n", "assert", "np", ".", "isclose", "(", "polygon_area", ",", "bitmap_area", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_to_bitmap": [[548, 554], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_bitmap", "mmdet.core.PolygonMasks.to_ndarray", "polygon_masks.to_bitmap.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_bitmap", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_mask_to_bitmap", "(", ")", ":", "\n", "# polygon masks contain 3 instances to bitmap", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "bitmap_masks", "=", "polygon_masks", ".", "to_bitmap", "(", ")", "\n", "assert", "(", "polygon_masks", ".", "to_ndarray", "(", ")", "==", "bitmap_masks", ".", "to_ndarray", "(", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_to_ndarray": [[556, 570], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_ndarray", "isinstance", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_ndarray", "isinstance"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_mask_to_ndarray", "(", ")", ":", "\n", "# empty polygon masks to ndarray", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "ndarray_masks", "=", "polygon_masks", ".", "to_ndarray", "(", ")", "\n", "assert", "isinstance", "(", "ndarray_masks", ",", "np", ".", "ndarray", ")", "\n", "assert", "ndarray_masks", ".", "shape", "==", "(", "0", ",", "28", ",", "28", ")", "\n", "\n", "# polygon masks contain 3 instances to ndarray", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "ndarray_masks", "=", "polygon_masks", ".", "to_ndarray", "(", ")", "\n", "assert", "isinstance", "(", "ndarray_masks", ",", "np", ".", "ndarray", ")", "\n", "assert", "ndarray_masks", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_to_tensor": [[572, 587], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_tensor", "isinstance", "test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks.to_tensor", "isinstance", "polygon_masks.to_tensor.numpy", "mmdet.core.PolygonMasks.to_ndarray"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_tensor", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.mask.structures.PolygonMasks.to_ndarray"], ["", "def", "test_polygon_to_tensor", "(", ")", ":", "\n", "# empty polygon masks to tensor", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "0", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "tensor_masks", "=", "polygon_masks", ".", "to_tensor", "(", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cpu'", ")", "\n", "assert", "isinstance", "(", "tensor_masks", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_masks", ".", "shape", "==", "(", "0", ",", "28", ",", "28", ")", "\n", "\n", "# polygon masks contain 3 instances to tensor", "\n", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "tensor_masks", "=", "polygon_masks", ".", "to_tensor", "(", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cpu'", ")", "\n", "assert", "isinstance", "(", "tensor_masks", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_masks", ".", "shape", "==", "(", "3", ",", "28", ",", "28", ")", "\n", "assert", "(", "tensor_masks", ".", "numpy", "(", ")", "==", "polygon_masks", ".", "to_ndarray", "(", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_index": [[589, 601], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "pytest.raises", "numpy.asarray", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks"], ["", "def", "test_polygon_mask_index", "(", ")", ":", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "# index by integer", "\n", "polygon_masks", "[", "0", "]", "\n", "# index by list", "\n", "polygon_masks", "[", "[", "0", ",", "1", "]", "]", "\n", "# index by ndarray", "\n", "polygon_masks", "[", "np", ".", "asarray", "(", "[", "0", ",", "1", "]", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "# invalid index", "\n", "        ", "polygon_masks", "[", "torch", ".", "Tensor", "(", "[", "1", ",", "2", "]", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.test_polygon_mask_iter": [[603, 608], ["test_masks.dummy_raw_polygon_masks", "mmdet.core.PolygonMasks", "enumerate", "numpy.equal().all", "numpy.equal"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.tests.test_masks.dummy_raw_polygon_masks"], ["", "", "def", "test_polygon_mask_iter", "(", ")", ":", "\n", "    ", "raw_masks", "=", "dummy_raw_polygon_masks", "(", "(", "3", ",", "28", ",", "28", ")", ")", "\n", "polygon_masks", "=", "PolygonMasks", "(", "raw_masks", ",", "28", ",", "28", ")", "\n", "for", "i", ",", "polygon_mask", "in", "enumerate", "(", "polygon_masks", ")", ":", "\n", "        ", "assert", "np", ".", "equal", "(", "polygon_mask", ",", "raw_masks", "[", "i", "]", ")", ".", "all", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_fcos_head_loss": [[11, 68], ["mmcv.Config", "mmdet.models.dense_heads.FCOSHead", "mmdet.models.dense_heads.FCOSHead.forward", "mmdet.models.dense_heads.FCOSHead.loss", "mmdet.models.dense_heads.FCOSHead.loss", "dict", "torch.rand", "torch.empty", "torch.LongTensor", "empty_cls_loss.item", "empty_box_loss.item", "torch.Tensor", "torch.LongTensor", "onegt_cls_loss.item", "onegt_box_loss.item", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["def", "test_fcos_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests fcos head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "train_cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.4", ",", "\n", "min_pos_iou", "=", "0", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "allowed_border", "=", "-", "1", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "# since Focal Loss is not supported on CPU", "\n", "self", "=", "FCOSHead", "(", "\n", "num_classes", "=", "4", ",", "\n", "in_channels", "=", "1", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_sigmoid", "=", "True", ",", "loss_weight", "=", "1.0", ")", ")", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "feat_size", ",", "s", "//", "feat_size", ")", "\n", "for", "feat_size", "in", "[", "4", ",", "8", ",", "16", ",", "32", ",", "64", "]", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", ",", "centerness", "=", "self", ".", "forward", "(", "feat", ")", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "gt_bboxes_ignore", "=", "None", "\n", "empty_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "centerness", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "# When there is no truth, the cls loss should be nonzero but there should", "\n", "# be no box loss.", "\n", "empty_cls_loss", "=", "empty_gt_losses", "[", "'loss_cls'", "]", "\n", "empty_box_loss", "=", "empty_gt_losses", "[", "'loss_bbox'", "]", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "one_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "centerness", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "one_gt_losses", "[", "'loss_cls'", "]", "\n", "onegt_box_loss", "=", "one_gt_losses", "[", "'loss_bbox'", "]", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_anchor_head_loss": [[70, 133], ["mmcv.Config", "mmdet.models.dense_heads.AnchorHead", "mmdet.models.dense_heads.AnchorHead.forward", "mmdet.models.dense_heads.AnchorHead.loss", "sum", "sum", "mmdet.models.dense_heads.AnchorHead.loss", "sum", "sum", "dict", "torch.rand", "torch.empty", "torch.LongTensor", "sum.item", "sum.item", "torch.Tensor", "torch.LongTensor", "sum.item", "sum.item", "range", "dict", "dict", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "test_anchor_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests anchor head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.7", ",", "\n", "neg_iou_thr", "=", "0.3", ",", "\n", "min_pos_iou", "=", "0.3", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "sampler", "=", "dict", "(", "\n", "type", "=", "'RandomSampler'", ",", "\n", "num", "=", "256", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "False", ")", ",", "\n", "allowed_border", "=", "0", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "self", "=", "AnchorHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "1", ",", "train_cfg", "=", "cfg", ")", "\n", "\n", "# Anchor head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "anchor_generator", ".", "strides", ")", ")", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", "=", "self", ".", "forward", "(", "feat", ")", "\n", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "\n", "gt_bboxes_ignore", "=", "None", "\n", "empty_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "# When there is no truth, the cls loss should be nonzero but there should", "\n", "# be no box loss.", "\n", "empty_cls_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "empty_box_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "one_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "onegt_box_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_fsaf_head_loss": [[135, 210], ["dict", "mmcv.Config", "mmdet.models.dense_heads.FSAFHead", "torch.cuda.is_available", "dict", "mmdet.models.dense_heads.FSAFHead.cuda", "mmdet.models.dense_heads.FSAFHead.forward", "mmdet.models.dense_heads.FSAFHead.loss", "sum", "sum", "mmdet.models.dense_heads.FSAFHead.loss", "sum", "sum", "dict", "dict", "dict", "dict", "torch.rand().cuda", "torch.Tensor().cuda", "torch.LongTensor().cuda", "sum.item", "sum.item", "torch.empty().cuda", "torch.LongTensor().cuda", "sum.item", "sum.item", "dict", "range", "torch.rand", "len", "torch.Tensor", "torch.LongTensor", "torch.empty", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "test_fsaf_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests anchor head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "cfg", "=", "dict", "(", "\n", "reg_decoded_bbox", "=", "True", ",", "\n", "anchor_generator", "=", "dict", "(", "\n", "type", "=", "'AnchorGenerator'", ",", "\n", "octave_base_scale", "=", "1", ",", "\n", "scales_per_octave", "=", "1", ",", "\n", "ratios", "=", "[", "1.0", "]", ",", "\n", "strides", "=", "[", "8", ",", "16", ",", "32", ",", "64", ",", "128", "]", ")", ",", "\n", "bbox_coder", "=", "dict", "(", "type", "=", "'TBLRBBoxCoder'", ",", "normalizer", "=", "4.0", ")", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'FocalLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "loss_weight", "=", "1.0", ",", "\n", "reduction", "=", "'none'", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "\n", "type", "=", "'IoULoss'", ",", "eps", "=", "1e-6", ",", "loss_weight", "=", "1.0", ",", "reduction", "=", "'none'", ")", ")", "\n", "\n", "train_cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'CenterRegionAssigner'", ",", "\n", "pos_scale", "=", "0.2", ",", "\n", "neg_scale", "=", "0.2", ",", "\n", "min_pos_iof", "=", "0.01", ")", ",", "\n", "allowed_border", "=", "-", "1", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "head", "=", "FSAFHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "1", ",", "train_cfg", "=", "train_cfg", ",", "**", "cfg", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "head", ".", "cuda", "(", ")", "\n", "# FSAF head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "head", ".", "anchor_generator", ".", "strides", ")", ")", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", "=", "head", ".", "forward", "(", "feat", ")", "\n", "gt_bboxes_ignore", "=", "None", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero", "\n", "#  for random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ".", "cuda", "(", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", ".", "cuda", "(", ")", "]", "\n", "one_gt_losses", "=", "head", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "onegt_box_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n", "# Test that empty ground truth encourages the network to predict bkg", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", ".", "cuda", "(", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", ".", "cuda", "(", ")", "]", "\n", "\n", "empty_gt_losses", "=", "head", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "\n", "gt_labels", ",", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "# When there is no truth, the cls loss should be nonzero but there", "\n", "# should be no box loss.", "\n", "empty_cls_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "empty_box_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_ga_anchor_head_loss": [[212, 296], ["mmcv.Config", "mmdet.models.dense_heads.GuidedAnchorHead", "torch.cuda.is_available", "dict", "mmdet.models.dense_heads.GuidedAnchorHead.cuda", "mmdet.models.dense_heads.GuidedAnchorHead.forward", "mmdet.models.dense_heads.GuidedAnchorHead.loss", "sum", "sum", "mmdet.models.dense_heads.GuidedAnchorHead.loss", "sum", "sum", "torch.rand().cuda", "torch.empty().cuda", "torch.LongTensor().cuda", "sum.item", "sum.item", "torch.Tensor().cuda", "torch.LongTensor().cuda", "sum.item", "sum.item", "dict", "dict", "dict", "dict", "range", "torch.rand", "len", "torch.empty", "torch.LongTensor", "torch.Tensor", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "", "def", "test_ga_anchor_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests anchor head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.7", ",", "\n", "neg_iou_thr", "=", "0.3", ",", "\n", "min_pos_iou", "=", "0.3", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "sampler", "=", "dict", "(", "\n", "type", "=", "'RandomSampler'", ",", "\n", "num", "=", "256", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "False", ")", ",", "\n", "ga_assigner", "=", "dict", "(", "\n", "type", "=", "'ApproxMaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.7", ",", "\n", "neg_iou_thr", "=", "0.3", ",", "\n", "min_pos_iou", "=", "0.3", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "ga_sampler", "=", "dict", "(", "\n", "type", "=", "'RandomSampler'", ",", "\n", "num", "=", "256", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "False", ")", ",", "\n", "allowed_border", "=", "-", "1", ",", "\n", "center_ratio", "=", "0.2", ",", "\n", "ignore_ratio", "=", "0.5", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "head", "=", "GuidedAnchorHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "4", ",", "train_cfg", "=", "cfg", ")", "\n", "\n", "# Anchor head expects a multiple levels of features per image", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "head", ".", "cuda", "(", ")", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "4", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", ".", "cuda", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "head", ".", "approx_anchor_generator", ".", "base_anchors", ")", ")", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", ",", "shape_preds", ",", "loc_preds", "=", "head", ".", "forward", "(", "feat", ")", "\n", "\n", "# Test that empty ground truth encourages the network to predict", "\n", "# background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", ".", "cuda", "(", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", ".", "cuda", "(", ")", "]", "\n", "\n", "gt_bboxes_ignore", "=", "None", "\n", "\n", "empty_gt_losses", "=", "head", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "shape_preds", ",", "\n", "loc_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ",", "\n", "gt_bboxes_ignore", ")", "\n", "\n", "# When there is no truth, the cls loss should be nonzero but there", "\n", "# should be no box loss.", "\n", "empty_cls_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "empty_box_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero", "\n", "# for random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ".", "cuda", "(", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", ".", "cuda", "(", ")", "]", "\n", "one_gt_losses", "=", "head", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "shape_preds", ",", "\n", "loc_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ",", "\n", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "onegt_box_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_bbox_head_loss": [[298, 354], ["mmdet.models.roi_heads.bbox_heads.BBoxHead", "mmcv.Config", "test_heads._dummy_bbox_sampling", "mmdet.models.roi_heads.bbox_heads.BBoxHead.get_targets", "sum", "mmdet.core.bbox2roi", "torch.rand", "mmdet.models.roi_heads.bbox_heads.BBoxHead.forward", "mmdet.models.roi_heads.bbox_heads.BBoxHead.loss", "test_heads._dummy_bbox_sampling", "mmdet.core.bbox2roi", "mmdet.models.roi_heads.bbox_heads.BBoxHead.get_targets", "sum", "torch.rand", "mmdet.models.roi_heads.bbox_heads.BBoxHead.forward", "mmdet.models.roi_heads.bbox_heads.BBoxHead.loss", "torch.Tensor", "dict", "torch.empty", "torch.LongTensor", "test_heads..get", "test_heads..get", "torch.Tensor", "torch.LongTensor", "test_heads..get", "test_heads..get", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._dummy_bbox_sampling", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._dummy_bbox_sampling", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.transforms.bbox2roi", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "", "def", "test_bbox_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests bbox head loss when truth is empty and non-empty.\"\"\"", "\n", "self", "=", "BBoxHead", "(", "in_channels", "=", "8", ",", "roi_feat_size", "=", "3", ")", "\n", "\n", "# Dummy proposals", "\n", "proposal_list", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "228.6326", ",", "153.8874", "]", "]", ")", ",", "\n", "]", "\n", "\n", "target_cfg", "=", "mmcv", ".", "Config", "(", "dict", "(", "pos_weight", "=", "1", ")", ")", "\n", "\n", "# Test bbox loss when truth is empty", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "\n", "sampling_results", "=", "_dummy_bbox_sampling", "(", "proposal_list", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", "\n", "\n", "bbox_targets", "=", "self", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "target_cfg", ")", "\n", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "=", "bbox_targets", "\n", "\n", "# Create dummy features \"extracted\" for each sampled bbox", "\n", "num_sampled", "=", "sum", "(", "len", "(", "res", ".", "bboxes", ")", "for", "res", "in", "sampling_results", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "dummy_feats", "=", "torch", ".", "rand", "(", "num_sampled", ",", "8", "*", "3", "*", "3", ")", "\n", "cls_scores", ",", "bbox_preds", "=", "self", ".", "forward", "(", "dummy_feats", ")", "\n", "\n", "losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "rois", ",", "labels", ",", "label_weights", ",", "\n", "bbox_targets", ",", "bbox_weights", ")", "\n", "assert", "losses", ".", "get", "(", "'loss_cls'", ",", "0", ")", ">", "0", ",", "'cls-loss should be non-zero'", "\n", "assert", "losses", ".", "get", "(", "'loss_bbox'", ",", "0", ")", "==", "0", ",", "'empty gt loss should be zero'", "\n", "\n", "# Test bbox loss when truth is non-empty", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "\n", "sampling_results", "=", "_dummy_bbox_sampling", "(", "proposal_list", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", "\n", "rois", "=", "bbox2roi", "(", "[", "res", ".", "bboxes", "for", "res", "in", "sampling_results", "]", ")", "\n", "\n", "bbox_targets", "=", "self", ".", "get_targets", "(", "sampling_results", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "target_cfg", ")", "\n", "labels", ",", "label_weights", ",", "bbox_targets", ",", "bbox_weights", "=", "bbox_targets", "\n", "\n", "# Create dummy features \"extracted\" for each sampled bbox", "\n", "num_sampled", "=", "sum", "(", "len", "(", "res", ".", "bboxes", ")", "for", "res", "in", "sampling_results", ")", "\n", "dummy_feats", "=", "torch", ".", "rand", "(", "num_sampled", ",", "8", "*", "3", "*", "3", ")", "\n", "cls_scores", ",", "bbox_preds", "=", "self", ".", "forward", "(", "dummy_feats", ")", "\n", "\n", "losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "rois", ",", "labels", ",", "label_weights", ",", "\n", "bbox_targets", ",", "bbox_weights", ")", "\n", "assert", "losses", ".", "get", "(", "'loss_cls'", ",", "0", ")", ">", "0", ",", "'cls-loss should be non-zero'", "\n", "assert", "losses", ".", "get", "(", "'loss_bbox'", ",", "0", ")", ">", "0", ",", "'box-loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_refine_boxes": [[356, 477], ["mmdet.models.roi_heads.bbox_heads.BBoxHead", "print", "test_heads._demodata_refine_boxes", "mmdet.models.roi_heads.bbox_heads.BBoxHead.refine_bboxes", "all", "len", "sum", "print", "map"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._demodata_refine_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox_heads.bbox_head.BBoxHead.refine_bboxes"], ["", "def", "test_refine_boxes", "(", ")", ":", "\n", "    ", "\"\"\"Mirrors the doctest in\n    ``mmdet.models.bbox_heads.bbox_head.BBoxHead.refine_boxes`` but checks for\n    multiple values of n_roi / n_img.\"\"\"", "\n", "self", "=", "BBoxHead", "(", "reg_class_agnostic", "=", "True", ")", "\n", "\n", "test_settings", "=", "[", "\n", "\n", "# Corner case: less rois than images", "\n", "{", "\n", "'n_roi'", ":", "2", ",", "\n", "'n_img'", ":", "4", ",", "\n", "'rng'", ":", "34285940", "\n", "}", ",", "\n", "\n", "# Corner case: no images", "\n", "{", "\n", "'n_roi'", ":", "0", ",", "\n", "'n_img'", ":", "0", ",", "\n", "'rng'", ":", "52925222", "\n", "}", ",", "\n", "\n", "# Corner cases: few images / rois", "\n", "{", "\n", "'n_roi'", ":", "1", ",", "\n", "'n_img'", ":", "1", ",", "\n", "'rng'", ":", "1200281", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "2", ",", "\n", "'n_img'", ":", "1", ",", "\n", "'rng'", ":", "1200282", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "2", ",", "\n", "'n_img'", ":", "2", ",", "\n", "'rng'", ":", "1200283", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "1", ",", "\n", "'n_img'", ":", "2", ",", "\n", "'rng'", ":", "1200284", "\n", "}", ",", "\n", "\n", "# Corner case: no rois few images", "\n", "{", "\n", "'n_roi'", ":", "0", ",", "\n", "'n_img'", ":", "1", ",", "\n", "'rng'", ":", "23955860", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "0", ",", "\n", "'n_img'", ":", "2", ",", "\n", "'rng'", ":", "25830516", "\n", "}", ",", "\n", "\n", "# Corner case: no rois many images", "\n", "{", "\n", "'n_roi'", ":", "0", ",", "\n", "'n_img'", ":", "10", ",", "\n", "'rng'", ":", "671346", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "0", ",", "\n", "'n_img'", ":", "20", ",", "\n", "'rng'", ":", "699807", "\n", "}", ",", "\n", "\n", "# Corner case: cal_similarity num rois and images", "\n", "{", "\n", "'n_roi'", ":", "20", ",", "\n", "'n_img'", ":", "20", ",", "\n", "'rng'", ":", "1200238", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "10", ",", "\n", "'n_img'", ":", "20", ",", "\n", "'rng'", ":", "1200238", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "5", ",", "\n", "'n_img'", ":", "5", ",", "\n", "'rng'", ":", "1200238", "\n", "}", ",", "\n", "\n", "# ----------------------------------", "\n", "# Common case: more rois than images", "\n", "{", "\n", "'n_roi'", ":", "100", ",", "\n", "'n_img'", ":", "1", ",", "\n", "'rng'", ":", "337156", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "150", ",", "\n", "'n_img'", ":", "2", ",", "\n", "'rng'", ":", "275898", "\n", "}", ",", "\n", "{", "\n", "'n_roi'", ":", "500", ",", "\n", "'n_img'", ":", "5", ",", "\n", "'rng'", ":", "4903221", "\n", "}", ",", "\n", "]", "\n", "\n", "for", "demokw", "in", "test_settings", ":", "\n", "        ", "try", ":", "\n", "            ", "n_roi", "=", "demokw", "[", "'n_roi'", "]", "\n", "n_img", "=", "demokw", "[", "'n_img'", "]", "\n", "rng", "=", "demokw", "[", "'rng'", "]", "\n", "\n", "print", "(", "f'Test refine_boxes case: {demokw!r}'", ")", "\n", "tup", "=", "_demodata_refine_boxes", "(", "n_roi", ",", "n_img", ",", "rng", "=", "rng", ")", "\n", "rois", ",", "labels", ",", "bbox_preds", ",", "pos_is_gts", ",", "img_metas", "=", "tup", "\n", "bboxes_list", "=", "self", ".", "refine_bboxes", "(", "rois", ",", "labels", ",", "bbox_preds", ",", "\n", "pos_is_gts", ",", "img_metas", ")", "\n", "assert", "len", "(", "bboxes_list", ")", "==", "n_img", "\n", "assert", "sum", "(", "map", "(", "len", ",", "bboxes_list", ")", ")", "<=", "n_roi", "\n", "assert", "all", "(", "b", ".", "shape", "[", "1", "]", "==", "4", "for", "b", "in", "bboxes_list", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "print", "(", "f'Test failed with demokw={demokw!r}'", ")", "\n", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._demodata_refine_boxes": [[479, 519], ["ensure_rng", "random_boxes", "torch.cat", "ensure_rng.randint", "torch.from_numpy().long", "random_boxes", "kwarray.group_items", "torch.empty", "torch.empty", "ensure_rng.randint", "torch.from_numpy", "torch.from_numpy.numpy", "sum", "ensure_rng.randint().astype", "pytest.skip", "range", "img_ids[].float", "torch.from_numpy", "kwarray.group_items.get", "range", "torch.from_numpy().sort", "torch.from_numpy().long.numpy", "ensure_rng.randint", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.ensure_rng", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.random_boxes", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.demodata.random_boxes"], ["", "", "", "def", "_demodata_refine_boxes", "(", "n_roi", ",", "n_img", ",", "rng", "=", "0", ")", ":", "\n", "    ", "\"\"\"Create random test data for the\n    ``mmdet.models.bbox_heads.bbox_head.BBoxHead.refine_boxes`` method.\"\"\"", "\n", "import", "numpy", "as", "np", "\n", "from", "mmdet", ".", "core", ".", "bbox", ".", "demodata", "import", "random_boxes", "\n", "from", "mmdet", ".", "core", ".", "bbox", ".", "demodata", "import", "ensure_rng", "\n", "try", ":", "\n", "        ", "import", "kwarray", "\n", "", "except", "ImportError", ":", "\n", "        ", "import", "pytest", "\n", "pytest", ".", "skip", "(", "'kwarray is required for this test'", ")", "\n", "", "scale", "=", "512", "\n", "rng", "=", "ensure_rng", "(", "rng", ")", "\n", "img_metas", "=", "[", "{", "'img_shape'", ":", "(", "scale", ",", "scale", ")", "}", "for", "_", "in", "range", "(", "n_img", ")", "]", "\n", "# Create rois in the expected format", "\n", "roi_boxes", "=", "random_boxes", "(", "n_roi", ",", "scale", "=", "scale", ",", "rng", "=", "rng", ")", "\n", "if", "n_img", "==", "0", ":", "\n", "        ", "assert", "n_roi", "==", "0", ",", "'cannot have any rois if there are no images'", "\n", "img_ids", "=", "torch", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "roi_boxes", "=", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "        ", "img_ids", "=", "rng", ".", "randint", "(", "0", ",", "n_img", ",", "(", "n_roi", ",", ")", ")", "\n", "img_ids", "=", "torch", ".", "from_numpy", "(", "img_ids", ")", "\n", "", "rois", "=", "torch", ".", "cat", "(", "[", "img_ids", "[", ":", ",", "None", "]", ".", "float", "(", ")", ",", "roi_boxes", "]", ",", "dim", "=", "1", ")", "\n", "# Create other args", "\n", "labels", "=", "rng", ".", "randint", "(", "0", ",", "2", ",", "(", "n_roi", ",", ")", ")", "\n", "labels", "=", "torch", ".", "from_numpy", "(", "labels", ")", ".", "long", "(", ")", "\n", "bbox_preds", "=", "random_boxes", "(", "n_roi", ",", "scale", "=", "scale", ",", "rng", "=", "rng", ")", "\n", "# For each image, pretend random positive boxes are gts", "\n", "is_label_pos", "=", "(", "labels", ".", "numpy", "(", ")", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "lbl_per_img", "=", "kwarray", ".", "group_items", "(", "is_label_pos", ",", "img_ids", ".", "numpy", "(", ")", ")", "\n", "pos_per_img", "=", "[", "sum", "(", "lbl_per_img", ".", "get", "(", "gid", ",", "[", "]", ")", ")", "for", "gid", "in", "range", "(", "n_img", ")", "]", "\n", "# randomly generate with numpy then sort with torch", "\n", "_pos_is_gts", "=", "[", "\n", "rng", ".", "randint", "(", "0", ",", "2", ",", "(", "npos", ",", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "for", "npos", "in", "pos_per_img", "\n", "]", "\n", "pos_is_gts", "=", "[", "\n", "torch", ".", "from_numpy", "(", "p", ")", ".", "sort", "(", "descending", "=", "True", ")", "[", "0", "]", "for", "p", "in", "_pos_is_gts", "\n", "]", "\n", "return", "rois", ",", "labels", ",", "bbox_preds", ",", "pos_is_gts", ",", "img_metas", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_mask_head_loss": [[521, 583], ["mmdet.models.roi_heads.mask_heads.FCNMaskHead", "test_heads._dummy_bbox_sampling", "np.random.randint", "mmcv.Config", "sum", "torch.rand", "mmdet.models.roi_heads.mask_heads.FCNMaskHead.forward", "mmdet.models.roi_heads.mask_heads.FCNMaskHead.get_targets", "torch.cat", "mmdet.models.roi_heads.mask_heads.FCNMaskHead.loss", "sum", "mmdet.models.roi_heads.mask_heads.MaskIoUHead", "mmdet.models.roi_heads.mask_heads.MaskIoUHead.", "mmdet.models.roi_heads.mask_heads.MaskIoUHead.get_targets", "mmdet.models.roi_heads.mask_heads.MaskIoUHead.loss", "loss_mask_iou[].sum", "torch.Tensor", "torch.Tensor", "torch.LongTensor", "BitmapMasks", "dict", "sum.item", "loss_mask_iou[].sum.item", "len", "range", "range", "test_heads..size", "mask_iou_head.size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._dummy_bbox_sampling", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "test_mask_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Test mask head loss when mask target is empty.\"\"\"", "\n", "self", "=", "FCNMaskHead", "(", "\n", "num_convs", "=", "1", ",", "\n", "roi_feat_size", "=", "6", ",", "\n", "in_channels", "=", "8", ",", "\n", "conv_out_channels", "=", "8", ",", "\n", "num_classes", "=", "8", ")", "\n", "\n", "# Dummy proposals", "\n", "proposal_list", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "228.6326", ",", "153.8874", "]", "]", ")", ",", "\n", "]", "\n", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "sampling_results", "=", "_dummy_bbox_sampling", "(", "proposal_list", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", "\n", "\n", "# create dummy mask", "\n", "import", "numpy", "as", "np", "\n", "from", "mmdet", ".", "core", "import", "BitmapMasks", "\n", "dummy_mask", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "(", "1", ",", "160", ",", "240", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "gt_masks", "=", "[", "BitmapMasks", "(", "dummy_mask", ",", "160", ",", "240", ")", "]", "\n", "\n", "# create dummy train_cfg", "\n", "train_cfg", "=", "mmcv", ".", "Config", "(", "dict", "(", "mask_size", "=", "12", ",", "mask_thr_binary", "=", "0.5", ")", ")", "\n", "\n", "# Create dummy features \"extracted\" for each sampled bbox", "\n", "num_sampled", "=", "sum", "(", "len", "(", "res", ".", "bboxes", ")", "for", "res", "in", "sampling_results", ")", "\n", "dummy_feats", "=", "torch", ".", "rand", "(", "num_sampled", ",", "8", ",", "6", ",", "6", ")", "\n", "\n", "mask_pred", "=", "self", ".", "forward", "(", "dummy_feats", ")", "\n", "mask_targets", "=", "self", ".", "get_targets", "(", "sampling_results", ",", "gt_masks", ",", "train_cfg", ")", "\n", "pos_labels", "=", "torch", ".", "cat", "(", "[", "res", ".", "pos_gt_labels", "for", "res", "in", "sampling_results", "]", ")", "\n", "loss_mask", "=", "self", ".", "loss", "(", "mask_pred", ",", "mask_targets", ",", "pos_labels", ")", "\n", "\n", "onegt_mask_loss", "=", "sum", "(", "loss_mask", "[", "'loss_mask'", "]", ")", "\n", "assert", "onegt_mask_loss", ".", "item", "(", ")", ">", "0", ",", "'mask loss should be non-zero'", "\n", "\n", "# test mask_iou_head", "\n", "mask_iou_head", "=", "MaskIoUHead", "(", "\n", "num_convs", "=", "1", ",", "\n", "num_fcs", "=", "1", ",", "\n", "roi_feat_size", "=", "6", ",", "\n", "in_channels", "=", "8", ",", "\n", "conv_out_channels", "=", "8", ",", "\n", "fc_out_channels", "=", "8", ",", "\n", "num_classes", "=", "8", ")", "\n", "\n", "pos_mask_pred", "=", "mask_pred", "[", "range", "(", "mask_pred", ".", "size", "(", "0", ")", ")", ",", "pos_labels", "]", "\n", "mask_iou_pred", "=", "mask_iou_head", "(", "dummy_feats", ",", "pos_mask_pred", ")", "\n", "pos_mask_iou_pred", "=", "mask_iou_pred", "[", "range", "(", "mask_iou_pred", ".", "size", "(", "0", ")", ")", ",", "pos_labels", "]", "\n", "\n", "mask_iou_targets", "=", "mask_iou_head", ".", "get_targets", "(", "sampling_results", ",", "gt_masks", ",", "\n", "pos_mask_pred", ",", "mask_targets", ",", "\n", "train_cfg", ")", "\n", "loss_mask_iou", "=", "mask_iou_head", ".", "loss", "(", "pos_mask_iou_pred", ",", "mask_iou_targets", ")", "\n", "onegt_mask_iou_loss", "=", "loss_mask_iou", "[", "'loss_mask_iou'", "]", ".", "sum", "(", ")", "\n", "assert", "onegt_mask_iou_loss", ".", "item", "(", ")", ">=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads._dummy_bbox_sampling": [[585, 617], ["torch.rand", "dict", "dict", "mmdet.core.build_assigner", "mmdet.core.build_sampler", "range", "mmdet.core.build_assigner.assign", "mmdet.core.build_sampler.sample", "sampling_results.append", "range"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_assigner", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.bbox.builder.build_sampler", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "_dummy_bbox_sampling", "(", "proposal_list", ",", "gt_bboxes", ",", "gt_labels", ")", ":", "\n", "    ", "\"\"\"Create sample results that can be passed to BBoxHead.get_targets.\"\"\"", "\n", "num_imgs", "=", "1", "\n", "feat", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "3", ",", "3", ")", "\n", "assign_config", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "min_pos_iou", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", "\n", "sampler_config", "=", "dict", "(", "\n", "type", "=", "'RandomSampler'", ",", "\n", "num", "=", "512", ",", "\n", "pos_fraction", "=", "0.25", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ")", "\n", "bbox_assigner", "=", "build_assigner", "(", "assign_config", ")", "\n", "bbox_sampler", "=", "build_sampler", "(", "sampler_config", ")", "\n", "gt_bboxes_ignore", "=", "[", "None", "for", "_", "in", "range", "(", "num_imgs", ")", "]", "\n", "sampling_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "assign_result", "=", "bbox_assigner", ".", "assign", "(", "proposal_list", "[", "i", "]", ",", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_bboxes_ignore", "[", "i", "]", ",", "gt_labels", "[", "i", "]", ")", "\n", "sampling_result", "=", "bbox_sampler", ".", "sample", "(", "\n", "assign_result", ",", "\n", "proposal_list", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "gt_labels", "[", "i", "]", ",", "\n", "feats", "=", "feat", ")", "\n", "sampling_results", ".", "append", "(", "sampling_result", ")", "\n", "\n", "", "return", "sampling_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_corner_head_loss": [[619, 705], ["mmdet.models.dense_heads.CornerHead", "mmdet.models.dense_heads.CornerHead.forward", "mmdet.models.dense_heads.CornerHead.loss", "sum", "sum", "sum", "sum", "mmdet.models.dense_heads.CornerHead.loss", "sum", "sum", "sum", "sum", "zip", "mmdet.models.dense_heads.CornerHead.loss", "sum", "sum", "sum", "sum", "torch.rand", "torch.empty", "torch.LongTensor", "sum.item", "sum.item", "sum.item", "sum.item", "torch.Tensor", "torch.LongTensor", "sum.item", "sum.item", "sum.item", "sum.item", "torch.Tensor", "torch.LongTensor", "sum.item", "sum.item", "sum.item", "sum.item", "range"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "test_corner_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests corner head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "self", "=", "CornerHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "1", ")", "\n", "\n", "# Corner head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "4", ",", "s", "//", "4", ")", "for", "_", "in", "range", "(", "self", ".", "num_feat_levels", ")", "\n", "]", "\n", "tl_heats", ",", "br_heats", ",", "tl_embs", ",", "br_embs", ",", "tl_offs", ",", "br_offs", "=", "self", ".", "forward", "(", "feat", ")", "\n", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "\n", "gt_bboxes_ignore", "=", "None", "\n", "empty_gt_losses", "=", "self", ".", "loss", "(", "tl_heats", ",", "br_heats", ",", "tl_embs", ",", "br_embs", ",", "tl_offs", ",", "\n", "br_offs", ",", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ",", "\n", "gt_bboxes_ignore", ")", "\n", "empty_det_loss", "=", "sum", "(", "empty_gt_losses", "[", "'det_loss'", "]", ")", "\n", "empty_push_loss", "=", "sum", "(", "empty_gt_losses", "[", "'push_loss'", "]", ")", "\n", "empty_pull_loss", "=", "sum", "(", "empty_gt_losses", "[", "'pull_loss'", "]", ")", "\n", "empty_off_loss", "=", "sum", "(", "empty_gt_losses", "[", "'off_loss'", "]", ")", "\n", "assert", "empty_det_loss", ".", "item", "(", ")", ">", "0", ",", "'det loss should be non-zero'", "\n", "assert", "empty_push_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no push loss when there are no true boxes'", ")", "\n", "assert", "empty_pull_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no pull loss when there are no true boxes'", ")", "\n", "assert", "empty_off_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "one_gt_losses", "=", "self", ".", "loss", "(", "tl_heats", ",", "br_heats", ",", "tl_embs", ",", "br_embs", ",", "tl_offs", ",", "\n", "br_offs", ",", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ",", "\n", "gt_bboxes_ignore", ")", "\n", "onegt_det_loss", "=", "sum", "(", "one_gt_losses", "[", "'det_loss'", "]", ")", "\n", "onegt_push_loss", "=", "sum", "(", "one_gt_losses", "[", "'push_loss'", "]", ")", "\n", "onegt_pull_loss", "=", "sum", "(", "one_gt_losses", "[", "'pull_loss'", "]", ")", "\n", "onegt_off_loss", "=", "sum", "(", "one_gt_losses", "[", "'off_loss'", "]", ")", "\n", "assert", "onegt_det_loss", ".", "item", "(", ")", ">", "0", ",", "'det loss should be non-zero'", "\n", "assert", "onegt_push_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no push loss when there are only one true box'", ")", "\n", "assert", "onegt_pull_loss", ".", "item", "(", ")", ">", "0", ",", "'pull loss should be non-zero'", "\n", "assert", "onegt_off_loss", ".", "item", "(", ")", ">", "0", ",", "'off loss should be non-zero'", "\n", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", ",", "\n", "[", "123.6667", ",", "123.8757", ",", "138.6326", ",", "251.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "]", "\n", "\n", "# equalize the corners' embedding value of different objects to make the", "\n", "# push_loss larger than 0", "\n", "gt_bboxes_ind", "=", "(", "gt_bboxes", "[", "0", "]", "//", "4", ")", ".", "int", "(", ")", ".", "tolist", "(", ")", "\n", "for", "tl_emb_feat", ",", "br_emb_feat", "in", "zip", "(", "tl_embs", ",", "br_embs", ")", ":", "\n", "        ", "tl_emb_feat", "[", ":", ",", ":", ",", "gt_bboxes_ind", "[", "0", "]", "[", "1", "]", ",", "\n", "gt_bboxes_ind", "[", "0", "]", "[", "0", "]", "]", "=", "tl_emb_feat", "[", ":", ",", ":", ",", "\n", "gt_bboxes_ind", "[", "1", "]", "[", "1", "]", ",", "\n", "gt_bboxes_ind", "[", "1", "]", "[", "0", "]", "]", "\n", "br_emb_feat", "[", ":", ",", ":", ",", "gt_bboxes_ind", "[", "0", "]", "[", "3", "]", ",", "\n", "gt_bboxes_ind", "[", "0", "]", "[", "2", "]", "]", "=", "br_emb_feat", "[", ":", ",", ":", ",", "\n", "gt_bboxes_ind", "[", "1", "]", "[", "3", "]", ",", "\n", "gt_bboxes_ind", "[", "1", "]", "[", "2", "]", "]", "\n", "\n", "", "two_gt_losses", "=", "self", ".", "loss", "(", "tl_heats", ",", "br_heats", ",", "tl_embs", ",", "br_embs", ",", "tl_offs", ",", "\n", "br_offs", ",", "gt_bboxes", ",", "gt_labels", ",", "img_metas", ",", "\n", "gt_bboxes_ignore", ")", "\n", "twogt_det_loss", "=", "sum", "(", "two_gt_losses", "[", "'det_loss'", "]", ")", "\n", "twogt_push_loss", "=", "sum", "(", "two_gt_losses", "[", "'push_loss'", "]", ")", "\n", "twogt_pull_loss", "=", "sum", "(", "two_gt_losses", "[", "'pull_loss'", "]", ")", "\n", "twogt_off_loss", "=", "sum", "(", "two_gt_losses", "[", "'off_loss'", "]", ")", "\n", "assert", "twogt_det_loss", ".", "item", "(", ")", ">", "0", ",", "'det loss should be non-zero'", "\n", "assert", "twogt_push_loss", ".", "item", "(", ")", ">", "0", ",", "'push loss should be non-zero'", "\n", "assert", "twogt_pull_loss", ".", "item", "(", ")", ">", "0", ",", "'pull loss should be non-zero'", "\n", "assert", "twogt_off_loss", ".", "item", "(", ")", ">", "0", ",", "'off loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_heads.test_corner_head_encode_and_decode_heatmap": [[707, 767], ["mmdet.models.dense_heads.CornerHead", "mmdet.models.dense_heads.CornerHead.get_targets", "torch.zeros", "torch.zeros", "mmdet.models.dense_heads.CornerHead.decode_heatmap", "batch_bboxes.view", "batch_scores.view", "batch_clses.view", "scores[].view.argsort", "bboxes[].view", "scores[].view", "clses[].view", "bboxes[].equal", "clses[].equal", "torch.Tensor", "torch.LongTensor", "torch.rand", "gt_labels[].float", "range", "torch.where", "torch.where"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.get_targets", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.corner_head.CornerHead.decode_heatmap"], ["", "def", "test_corner_head_encode_and_decode_heatmap", "(", ")", ":", "\n", "    ", "\"\"\"Tests corner head generating and decoding the heatmap.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'border'", ":", "(", "0", ",", "0", ",", "0", ",", "0", ")", "\n", "}", "]", "\n", "\n", "gt_bboxes", "=", "[", "torch", ".", "Tensor", "(", "[", "[", "10", ",", "20", ",", "200", ",", "240", "]", "]", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "1", "]", ")", "]", "\n", "\n", "self", "=", "CornerHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "1", ",", "corner_emb_channels", "=", "1", ")", "\n", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "4", ",", "s", "//", "4", ")", "for", "_", "in", "range", "(", "self", ".", "num_feat_levels", ")", "\n", "]", "\n", "\n", "targets", "=", "self", ".", "get_targets", "(", "\n", "gt_bboxes", ",", "\n", "gt_labels", ",", "\n", "feat", "[", "0", "]", ".", "shape", ",", "\n", "img_metas", "[", "0", "]", "[", "'pad_shape'", "]", ",", "\n", "with_corner_emb", "=", "self", ".", "with_corner_emb", ")", "\n", "\n", "gt_tl_heatmap", "=", "targets", "[", "'topleft_heatmap'", "]", "\n", "gt_br_heatmap", "=", "targets", "[", "'bottomright_heatmap'", "]", "\n", "gt_tl_offset", "=", "targets", "[", "'topleft_offset'", "]", "\n", "gt_br_offset", "=", "targets", "[", "'bottomright_offset'", "]", "\n", "embedding", "=", "targets", "[", "'corner_embedding'", "]", "\n", "[", "top", ",", "left", "]", ",", "[", "bottom", ",", "right", "]", "=", "embedding", "[", "0", "]", "[", "0", "]", "\n", "gt_tl_embedding_heatmap", "=", "torch", ".", "zeros", "(", "[", "1", ",", "1", ",", "s", "//", "4", ",", "s", "//", "4", "]", ")", "\n", "gt_br_embedding_heatmap", "=", "torch", ".", "zeros", "(", "[", "1", ",", "1", ",", "s", "//", "4", ",", "s", "//", "4", "]", ")", "\n", "gt_tl_embedding_heatmap", "[", "0", ",", "0", ",", "top", ",", "left", "]", "=", "1", "\n", "gt_br_embedding_heatmap", "[", "0", ",", "0", ",", "bottom", ",", "right", "]", "=", "1", "\n", "\n", "batch_bboxes", ",", "batch_scores", ",", "batch_clses", "=", "self", ".", "decode_heatmap", "(", "\n", "tl_heat", "=", "gt_tl_heatmap", ",", "\n", "br_heat", "=", "gt_br_heatmap", ",", "\n", "tl_off", "=", "gt_tl_offset", ",", "\n", "br_off", "=", "gt_br_offset", ",", "\n", "tl_emb", "=", "gt_tl_embedding_heatmap", ",", "\n", "br_emb", "=", "gt_br_embedding_heatmap", ",", "\n", "img_meta", "=", "img_metas", "[", "0", "]", ",", "\n", "k", "=", "100", ",", "\n", "kernel", "=", "3", ",", "\n", "distance_threshold", "=", "0.5", ")", "\n", "\n", "bboxes", "=", "batch_bboxes", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "scores", "=", "batch_scores", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "clses", "=", "batch_clses", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "idx", "=", "scores", ".", "argsort", "(", "dim", "=", "0", ",", "descending", "=", "True", ")", "\n", "bboxes", "=", "bboxes", "[", "idx", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "scores", "=", "scores", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "clses", "=", "clses", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "\n", "assert", "bboxes", "[", "torch", ".", "where", "(", "scores", ">", "0.05", ")", "]", ".", "equal", "(", "gt_bboxes", "[", "0", "]", ")", "\n", "assert", "clses", "[", "torch", ".", "where", "(", "scores", ">", "0.05", ")", "]", ".", "equal", "(", "gt_labels", "[", "0", "]", ".", "float", "(", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_roi_extractor.test_groie": [[7, 114], ["dict", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor", "torch.tensor", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor.", "dict", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor", "torch.tensor", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor.", "dict", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor", "torch.tensor", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor.", "dict", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor", "torch.tensor", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.Size", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.Size", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.Size", "pytest.raises", "dict", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "pytest.raises", "mmdet.models.roi_heads.roi_extractors.GenericRoIExtractor.", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["None"], ["def", "test_groie", "(", ")", ":", "\n", "# test with pre/post", "\n", "    ", "cfg", "=", "dict", "(", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "2", ")", ",", "\n", "out_channels", "=", "256", ",", "\n", "featmap_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ",", "\n", "pre_cfg", "=", "dict", "(", "\n", "type", "=", "'ConvModule'", ",", "\n", "in_channels", "=", "256", ",", "\n", "out_channels", "=", "256", ",", "\n", "kernel_size", "=", "5", ",", "\n", "padding", "=", "2", ",", "\n", "inplace", "=", "False", ",", "\n", ")", ",", "\n", "post_cfg", "=", "dict", "(", "\n", "type", "=", "'ConvModule'", ",", "\n", "in_channels", "=", "256", ",", "\n", "out_channels", "=", "256", ",", "\n", "kernel_size", "=", "5", ",", "\n", "padding", "=", "2", ",", "\n", "inplace", "=", "False", ")", ")", "\n", "\n", "groie", "=", "GenericRoIExtractor", "(", "**", "cfg", ")", "\n", "\n", "feats", "=", "(", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "200", ",", "336", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "100", ",", "168", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "50", ",", "84", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "25", ",", "42", ")", ")", ",", "\n", ")", "\n", "\n", "rois", "=", "torch", ".", "tensor", "(", "[", "[", "0.0000", ",", "587.8285", ",", "52.1405", ",", "886.2484", ",", "341.5644", "]", "]", ")", "\n", "\n", "res", "=", "groie", "(", "feats", ",", "rois", ")", "\n", "assert", "res", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "7", ",", "7", "]", ")", "\n", "\n", "# test w.o. pre/post", "\n", "cfg", "=", "dict", "(", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "2", ")", ",", "\n", "out_channels", "=", "256", ",", "\n", "featmap_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ")", "\n", "\n", "groie", "=", "GenericRoIExtractor", "(", "**", "cfg", ")", "\n", "\n", "feats", "=", "(", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "200", ",", "336", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "100", ",", "168", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "50", ",", "84", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "25", ",", "42", ")", ")", ",", "\n", ")", "\n", "\n", "rois", "=", "torch", ".", "tensor", "(", "[", "[", "0.0000", ",", "587.8285", ",", "52.1405", ",", "886.2484", ",", "341.5644", "]", "]", ")", "\n", "\n", "res", "=", "groie", "(", "feats", ",", "rois", ")", "\n", "assert", "res", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "7", ",", "7", "]", ")", "\n", "\n", "# test w.o. pre/post concat", "\n", "cfg", "=", "dict", "(", "\n", "aggregation", "=", "'concat'", ",", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "2", ")", ",", "\n", "out_channels", "=", "256", "*", "4", ",", "\n", "featmap_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ")", "\n", "\n", "groie", "=", "GenericRoIExtractor", "(", "**", "cfg", ")", "\n", "\n", "feats", "=", "(", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "200", ",", "336", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "100", ",", "168", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "50", ",", "84", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "25", ",", "42", ")", ")", ",", "\n", ")", "\n", "\n", "rois", "=", "torch", ".", "tensor", "(", "[", "[", "0.0000", ",", "587.8285", ",", "52.1405", ",", "886.2484", ",", "341.5644", "]", "]", ")", "\n", "\n", "res", "=", "groie", "(", "feats", ",", "rois", ")", "\n", "assert", "res", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "7", ",", "7", "]", ")", "\n", "\n", "# test not supported aggregate method", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "cfg", "=", "dict", "(", "\n", "aggregation", "=", "'not support'", ",", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "2", ")", ",", "\n", "out_channels", "=", "1024", ",", "\n", "featmap_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ")", "\n", "_", "=", "GenericRoIExtractor", "(", "**", "cfg", ")", "\n", "\n", "# test concat channels number", "\n", "", "cfg", "=", "dict", "(", "\n", "aggregation", "=", "'concat'", ",", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "2", ")", ",", "\n", "out_channels", "=", "256", "*", "5", ",", "# 256*5 != 256*4", "\n", "featmap_strides", "=", "[", "4", ",", "8", ",", "16", ",", "32", "]", ")", "\n", "\n", "groie", "=", "GenericRoIExtractor", "(", "**", "cfg", ")", "\n", "\n", "feats", "=", "(", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "200", ",", "336", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "100", ",", "168", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "50", ",", "84", ")", ")", ",", "\n", "torch", ".", "rand", "(", "(", "1", ",", "256", ",", "25", ",", "42", ")", ")", ",", "\n", ")", "\n", "\n", "rois", "=", "torch", ".", "tensor", "(", "[", "[", "0.0000", ",", "587.8285", ",", "52.1405", ",", "886.2484", ",", "341.5644", "]", "]", ")", "\n", "\n", "# out_channels does not sum of feat channels", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "_", "=", "groie", "(", "feats", ",", "rois", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_necks.test_fpn": [[8, 202], ["mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN.modules", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "mmdet.models.necks.FPN", "mmdet.models.necks.FPN.", "range", "pytest.raises", "mmdet.models.necks.FPN", "pytest.raises", "mmdet.models.necks.FPN", "pytest.raises", "mmdet.models.necks.FPN", "pytest.raises", "mmdet.models.necks.FPN", "torch.rand", "len", "len", "len", "isinstance", "len", "len", "len", "len", "len", "len", "len", "range", "range", "dict", "dict", "dict", "len"], "function", ["None"], ["def", "test_fpn", "(", ")", ":", "\n", "    ", "\"\"\"Tests fpn.\"\"\"", "\n", "s", "=", "64", "\n", "in_channels", "=", "[", "8", ",", "16", ",", "32", ",", "64", "]", "\n", "feat_sizes", "=", "[", "s", "//", "2", "**", "i", "for", "i", "in", "range", "(", "4", ")", "]", "# [64, 32, 16, 8]", "\n", "out_channels", "=", "8", "\n", "# `num_outs` is not equal to len(in_channels) - start_level", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN", "(", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "2", ")", "\n", "\n", "# `end_level` is larger than len(in_channels) - 1", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN", "(", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "end_level", "=", "4", ",", "\n", "num_outs", "=", "2", ")", "\n", "\n", "# `num_outs` is not equal to end_level - start_level", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN", "(", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "end_level", "=", "3", ",", "\n", "num_outs", "=", "1", ")", "\n", "\n", "# Invalid `add_extra_convs` option", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN", "(", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "'on_xxx'", ",", "\n", "num_outs", "=", "5", ")", "\n", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "num_outs", "=", "5", ")", "\n", "\n", "# FPN expects a multiple levels of features per image", "\n", "feats", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "in_channels", "[", "i", "]", ",", "feat_sizes", "[", "i", "]", ",", "feat_sizes", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "in_channels", ")", ")", "\n", "]", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_input'", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Tests for fpn with no extra convs (pooling is used instead)", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "num_outs", "=", "5", ")", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "assert", "not", "fpn_model", ".", "add_extra_convs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Tests for fpn with lateral bns", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "no_norm_on_lateral", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ",", "\n", "num_outs", "=", "5", ")", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_input'", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "", "bn_exist", "=", "False", "\n", "for", "m", "in", "fpn_model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "            ", "bn_exist", "=", "True", "\n", "", "", "assert", "bn_exist", "\n", "\n", "# Bilinear upsample", "\n", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "upsample_cfg", "=", "dict", "(", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", ",", "\n", "num_outs", "=", "5", ")", "\n", "fpn_model", "(", "feats", ")", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_input'", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Scale factor instead of fixed upsample size upsample", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "start_level", "=", "1", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "upsample_cfg", "=", "dict", "(", "scale_factor", "=", "2", ")", ",", "\n", "num_outs", "=", "5", ")", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Extra convs source is 'inputs'", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "add_extra_convs", "=", "'on_input'", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "5", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_input'", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Extra convs source is 'laterals'", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "add_extra_convs", "=", "'on_lateral'", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "5", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_lateral'", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# Extra convs source is 'outputs'", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "add_extra_convs", "=", "'on_output'", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "5", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_output'", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# extra_convs_on_inputs=False is equal to extra convs source is 'on_output'", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "extra_convs_on_inputs", "=", "False", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "5", ",", "\n", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_output'", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "\n", "# extra_convs_on_inputs=True is equal to extra convs source is 'on_input'", "\n", "", "fpn_model", "=", "FPN", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "add_extra_convs", "=", "True", ",", "\n", "extra_convs_on_inputs", "=", "True", ",", "\n", "start_level", "=", "1", ",", "\n", "num_outs", "=", "5", ",", "\n", ")", "\n", "assert", "fpn_model", ".", "add_extra_convs", "==", "'on_input'", "\n", "outs", "=", "fpn_model", "(", "feats", ")", "\n", "assert", "len", "(", "outs", ")", "==", "fpn_model", ".", "num_outs", "\n", "for", "i", "in", "range", "(", "fpn_model", ".", "num_outs", ")", ":", "\n", "        ", "outs", "[", "i", "]", ".", "shape", "[", "1", "]", "==", "out_channels", "\n", "outs", "[", "i", "]", ".", "shape", "[", "2", "]", "==", "outs", "[", "i", "]", ".", "shape", "[", "3", "]", "==", "s", "//", "(", "2", "**", "i", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block": [[15, 20], ["isinstance"], "function", ["None"], ["def", "is_block", "(", "modules", ")", ":", "\n", "    ", "\"\"\"Check if is ResNet building block.\"\"\"", "\n", "if", "isinstance", "(", "modules", ",", "(", "BasicBlock", ",", "Bottleneck", ",", "BottleneckX", ",", "Bottle2neck", ")", ")", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_norm": [[22, 27], ["isinstance"], "function", ["None"], ["", "def", "is_norm", "(", "modules", ")", ":", "\n", "    ", "\"\"\"Check if is one of the norms.\"\"\"", "\n", "if", "isinstance", "(", "modules", ",", "(", "GroupNorm", ",", "_BatchNorm", ")", ")", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.all_zeros": [[29, 40], ["torch.allclose", "hasattr", "torch.zeros_like", "torch.allclose", "torch.zeros_like"], "function", ["None"], ["", "def", "all_zeros", "(", "modules", ")", ":", "\n", "    ", "\"\"\"Check if the weight(and bias) is all zero.\"\"\"", "\n", "weight_zero", "=", "torch", ".", "allclose", "(", "modules", ".", "weight", ".", "data", ",", "\n", "torch", ".", "zeros_like", "(", "modules", ".", "weight", ".", "data", ")", ")", "\n", "if", "hasattr", "(", "modules", ",", "'bias'", ")", ":", "\n", "        ", "bias_zero", "=", "torch", ".", "allclose", "(", "modules", ".", "bias", ".", "data", ",", "\n", "torch", ".", "zeros_like", "(", "modules", ".", "bias", ".", "data", ")", ")", "\n", "", "else", ":", "\n", "        ", "bias_zero", "=", "True", "\n", "\n", "", "return", "weight_zero", "and", "bias_zero", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.check_norm_state": [[42, 49], ["isinstance"], "function", ["None"], ["", "def", "check_norm_state", "(", "modules", ",", "train_state", ")", ":", "\n", "    ", "\"\"\"Check if norm layer is in correct train state.\"\"\"", "\n", "for", "mod", "in", "modules", ":", "\n", "        ", "if", "isinstance", "(", "mod", ",", "_BatchNorm", ")", ":", "\n", "            ", "if", "mod", ".", "training", "!=", "train_state", ":", "\n", "                ", "return", "False", "\n", "", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnet_basic_block": [[51, 99], ["mmdet.models.backbones.resnet.BasicBlock", "torch.randn", "mmdet.models.backbones.resnet.BasicBlock.", "mmdet.models.backbones.resnet.BasicBlock", "torch.randn", "mmdet.models.backbones.resnet.BasicBlock.", "pytest.raises", "dict", "mmdet.models.backbones.resnet.BasicBlock", "pytest.raises", "mmdet.models.backbones.resnet.BasicBlock", "pytest.raises", "mmdet.models.backbones.resnet.BasicBlock", "torch.Size", "torch.Size", "dict", "dict", "dict", "dict"], "function", ["None"], ["", "def", "test_resnet_basic_block", "(", ")", ":", "\n", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Not implemented yet.", "\n", "        ", "dcn", "=", "dict", "(", "type", "=", "'DCN'", ",", "deform_groups", "=", "1", ",", "fallback_on_stride", "=", "False", ")", "\n", "BasicBlock", "(", "64", ",", "64", ",", "dcn", "=", "dcn", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Not implemented yet.", "\n", "        ", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "BasicBlock", "(", "64", ",", "64", ",", "plugins", "=", "plugins", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Not implemented yet", "\n", "        ", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'GeneralizedAttention'", ",", "\n", "spatial_range", "=", "-", "1", ",", "\n", "num_heads", "=", "8", ",", "\n", "attention_type", "=", "'0010'", ",", "\n", "kv_stride", "=", "2", ")", ",", "\n", "position", "=", "'after_conv2'", ")", "\n", "]", "\n", "BasicBlock", "(", "64", ",", "64", ",", "plugins", "=", "plugins", ")", "\n", "\n", "# test BasicBlock structure and forward", "\n", "", "block", "=", "BasicBlock", "(", "64", ",", "64", ")", "\n", "assert", "block", ".", "conv1", ".", "in_channels", "==", "64", "\n", "assert", "block", ".", "conv1", ".", "out_channels", "==", "64", "\n", "assert", "block", ".", "conv1", ".", "kernel_size", "==", "(", "3", ",", "3", ")", "\n", "assert", "block", ".", "conv2", ".", "in_channels", "==", "64", "\n", "assert", "block", ".", "conv2", ".", "out_channels", "==", "64", "\n", "assert", "block", ".", "conv2", ".", "kernel_size", "==", "(", "3", ",", "3", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test BasicBlock with checkpoint forward", "\n", "block", "=", "BasicBlock", "(", "64", ",", "64", ",", "with_cp", "=", "True", ")", "\n", "assert", "block", ".", "with_cp", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnet_bottleneck": [[101, 234], ["mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "mmdet.models.backbones.resnet.Bottleneck", "mmdet.models.backbones.resnet.Bottleneck", "dict", "mmdet.models.backbones.resnet.Bottleneck", "isinstance", "mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "mmdet.models.backbones.resnet.Bottleneck", "torch.randn", "mmdet.models.backbones.resnet.Bottleneck.", "pytest.raises", "mmdet.models.backbones.resnet.Bottleneck", "pytest.raises", "mmdet.models.backbones.resnet.Bottleneck", "pytest.raises", "mmdet.models.backbones.resnet.Bottleneck", "pytest.raises", "mmdet.models.backbones.resnet.Bottleneck", "torch.Size", "pytest.raises", "mmdet.models.backbones.resnet.Bottleneck", "torch.Size", "dict", "torch.Size", "dict", "torch.Size", "dict", "dict", "dict", "torch.Size", "dict", "dict", "dict", "torch.Size", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["None"], ["", "def", "test_resnet_bottleneck", "(", ")", ":", "\n", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Style must be in ['pytorch', 'caffe']", "\n", "        ", "Bottleneck", "(", "64", ",", "64", ",", "style", "=", "'tensorflow'", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Allowed positions are 'after_conv1', 'after_conv2', 'after_conv3'", "\n", "        ", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv4'", ")", "\n", "]", "\n", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Need to specify different postfix to avoid duplicate plugin name", "\n", "        ", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv3'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "# Plugin type is not supported", "\n", "        ", "plugins", "=", "[", "dict", "(", "cfg", "=", "dict", "(", "type", "=", "'WrongPlugin'", ")", ",", "position", "=", "'after_conv3'", ")", "]", "\n", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "\n", "# Test Bottleneck with checkpoint forward", "\n", "", "block", "=", "Bottleneck", "(", "64", ",", "16", ",", "with_cp", "=", "True", ")", "\n", "assert", "block", ".", "with_cp", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test Bottleneck style", "\n", "block", "=", "Bottleneck", "(", "64", ",", "64", ",", "stride", "=", "2", ",", "style", "=", "'pytorch'", ")", "\n", "assert", "block", ".", "conv1", ".", "stride", "==", "(", "1", ",", "1", ")", "\n", "assert", "block", ".", "conv2", ".", "stride", "==", "(", "2", ",", "2", ")", "\n", "block", "=", "Bottleneck", "(", "64", ",", "64", ",", "stride", "=", "2", ",", "style", "=", "'caffe'", ")", "\n", "assert", "block", ".", "conv1", ".", "stride", "==", "(", "2", ",", "2", ")", "\n", "assert", "block", ".", "conv2", ".", "stride", "==", "(", "1", ",", "1", ")", "\n", "\n", "# Test Bottleneck DCN", "\n", "dcn", "=", "dict", "(", "type", "=", "'DCN'", ",", "deform_groups", "=", "1", ",", "fallback_on_stride", "=", "False", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "Bottleneck", "(", "64", ",", "64", ",", "dcn", "=", "dcn", ",", "conv_cfg", "=", "dict", "(", "type", "=", "'Conv'", ")", ")", "\n", "", "block", "=", "Bottleneck", "(", "64", ",", "64", ",", "dcn", "=", "dcn", ")", "\n", "assert", "isinstance", "(", "block", ".", "conv2", ",", "DeformConv2dPack", ")", "\n", "\n", "# Test Bottleneck forward", "\n", "block", "=", "Bottleneck", "(", "64", ",", "16", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test Bottleneck with 1 ContextBlock after conv3", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "block", "=", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "assert", "block", ".", "context_block", ".", "in_channels", "==", "64", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test Bottleneck with 1 GeneralizedAttention after conv2", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'GeneralizedAttention'", ",", "\n", "spatial_range", "=", "-", "1", ",", "\n", "num_heads", "=", "8", ",", "\n", "attention_type", "=", "'0010'", ",", "\n", "kv_stride", "=", "2", ")", ",", "\n", "position", "=", "'after_conv2'", ")", "\n", "]", "\n", "block", "=", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "assert", "block", ".", "gen_attention_block", ".", "in_channels", "==", "16", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test Bottleneck with 1 GeneralizedAttention after conv2, 1 NonLocal2D", "\n", "# after conv2, 1 ContextBlock after conv3", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'GeneralizedAttention'", ",", "\n", "spatial_range", "=", "-", "1", ",", "\n", "num_heads", "=", "8", ",", "\n", "attention_type", "=", "'0010'", ",", "\n", "kv_stride", "=", "2", ")", ",", "\n", "position", "=", "'after_conv2'", ")", ",", "\n", "dict", "(", "cfg", "=", "dict", "(", "type", "=", "'NonLocal2d'", ")", ",", "position", "=", "'after_conv2'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "block", "=", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "assert", "block", ".", "gen_attention_block", ".", "in_channels", "==", "16", "\n", "assert", "block", ".", "nonlocal_block", ".", "in_channels", "==", "16", "\n", "assert", "block", ".", "context_block", ".", "in_channels", "==", "64", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test Bottleneck with 1 ContextBlock after conv2, 2 ContextBlock after", "\n", "# conv3", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ",", "postfix", "=", "1", ")", ",", "\n", "position", "=", "'after_conv2'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ",", "postfix", "=", "2", ")", ",", "\n", "position", "=", "'after_conv3'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ",", "postfix", "=", "3", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "block", "=", "Bottleneck", "(", "64", ",", "16", ",", "plugins", "=", "plugins", ")", "\n", "assert", "block", ".", "context_block1", ".", "in_channels", "==", "16", "\n", "assert", "block", ".", "context_block2", ".", "in_channels", "==", "64", "\n", "assert", "block", ".", "context_block3", ".", "in_channels", "==", "64", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnet_res_layer": [[236, 290], ["mmdet.models.utils.ResLayer", "range", "range", "torch.randn", "mmdet.models.utils.ResLayer.", "mmdet.models.utils.ResLayer", "range", "torch.randn", "mmdet.models.utils.ResLayer.", "mmdet.models.utils.ResLayer", "range", "torch.randn", "mmdet.models.utils.ResLayer.", "mmdet.models.utils.ResLayer", "isinstance", "range", "torch.randn", "mmdet.models.utils.ResLayer.", "mmdet.models.utils.ResLayer", "range", "torch.randn", "mmdet.models.utils.ResLayer.", "len", "len", "len", "torch.Size", "len", "torch.Size", "len", "torch.Size", "len", "torch.Size", "torch.Size", "len"], "function", ["None"], ["", "def", "test_resnet_res_layer", "(", ")", ":", "\n", "# Test ResLayer of 3 Bottleneck w\\o downsample", "\n", "    ", "layer", "=", "ResLayer", "(", "Bottleneck", ",", "64", ",", "16", ",", "3", ")", "\n", "assert", "len", "(", "layer", ")", "==", "3", "\n", "assert", "layer", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "64", "\n", "assert", "layer", "[", "0", "]", ".", "conv1", ".", "out_channels", "==", "16", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "layer", ")", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "conv1", ".", "in_channels", "==", "64", "\n", "assert", "layer", "[", "i", "]", ".", "conv1", ".", "out_channels", "==", "16", "\n", "", "for", "i", "in", "range", "(", "len", "(", "layer", ")", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "downsample", "is", "None", "\n", "", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "layer", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test ResLayer of 3 Bottleneck with downsample", "\n", "layer", "=", "ResLayer", "(", "Bottleneck", ",", "64", ",", "64", ",", "3", ")", "\n", "assert", "layer", "[", "0", "]", ".", "downsample", "[", "0", "]", ".", "out_channels", "==", "256", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "layer", ")", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "downsample", "is", "None", "\n", "", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "layer", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "\n", "# Test ResLayer of 3 Bottleneck with stride=2", "\n", "layer", "=", "ResLayer", "(", "Bottleneck", ",", "64", ",", "64", ",", "3", ",", "stride", "=", "2", ")", "\n", "assert", "layer", "[", "0", "]", ".", "downsample", "[", "0", "]", ".", "out_channels", "==", "256", "\n", "assert", "layer", "[", "0", "]", ".", "downsample", "[", "0", "]", ".", "stride", "==", "(", "2", ",", "2", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "layer", ")", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "downsample", "is", "None", "\n", "", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "layer", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "28", ",", "28", "]", ")", "\n", "\n", "# Test ResLayer of 3 Bottleneck with stride=2 and average downsample", "\n", "layer", "=", "ResLayer", "(", "Bottleneck", ",", "64", ",", "64", ",", "3", ",", "stride", "=", "2", ",", "avg_down", "=", "True", ")", "\n", "assert", "isinstance", "(", "layer", "[", "0", "]", ".", "downsample", "[", "0", "]", ",", "AvgPool2d", ")", "\n", "assert", "layer", "[", "0", "]", ".", "downsample", "[", "1", "]", ".", "out_channels", "==", "256", "\n", "assert", "layer", "[", "0", "]", ".", "downsample", "[", "1", "]", ".", "stride", "==", "(", "1", ",", "1", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "layer", ")", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "downsample", "is", "None", "\n", "", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "layer", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "28", ",", "28", "]", ")", "\n", "\n", "# Test ResLayer of 3 BasicBlock with stride=2 and downsample_first=False", "\n", "layer", "=", "ResLayer", "(", "BasicBlock", ",", "64", ",", "64", ",", "3", ",", "stride", "=", "2", ",", "downsample_first", "=", "False", ")", "\n", "assert", "layer", "[", "2", "]", ".", "downsample", "[", "0", "]", ".", "out_channels", "==", "64", "\n", "assert", "layer", "[", "2", "]", ".", "downsample", "[", "0", "]", ".", "stride", "==", "(", "2", ",", "2", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "layer", ")", "-", "1", ")", ":", "\n", "        ", "assert", "layer", "[", "i", "]", ".", "downsample", "is", "None", "\n", "", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "layer", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "28", ",", "28", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnest_stem": [[292, 338], ["mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNetV1d.init_weights", "mmdet.models.backbones.ResNetV1d.train", "mmdet.models.backbones.ResNetV1d", "mmdet.models.backbones.ResNetV1d.init_weights", "mmdet.models.backbones.ResNetV1d.train"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train"], ["", "def", "test_resnest_stem", "(", ")", ":", "\n", "# Test default stem_channels", "\n", "    ", "model", "=", "ResNet", "(", "50", ")", "\n", "assert", "model", ".", "stem_channels", "==", "64", "\n", "assert", "model", ".", "conv1", ".", "out_channels", "==", "64", "\n", "assert", "model", ".", "norm1", ".", "num_features", "==", "64", "\n", "\n", "# Test default stem_channels, with base_channels=32", "\n", "model", "=", "ResNet", "(", "50", ",", "base_channels", "=", "32", ")", "\n", "assert", "model", ".", "stem_channels", "==", "32", "\n", "assert", "model", ".", "conv1", ".", "out_channels", "==", "32", "\n", "assert", "model", ".", "norm1", ".", "num_features", "==", "32", "\n", "assert", "model", ".", "layer1", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "32", "\n", "\n", "# Test stem_channels=64", "\n", "model", "=", "ResNet", "(", "50", ",", "stem_channels", "=", "64", ")", "\n", "assert", "model", ".", "stem_channels", "==", "64", "\n", "assert", "model", ".", "conv1", ".", "out_channels", "==", "64", "\n", "assert", "model", ".", "norm1", ".", "num_features", "==", "64", "\n", "assert", "model", ".", "layer1", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "64", "\n", "\n", "# Test stem_channels=64, with base_channels=32", "\n", "model", "=", "ResNet", "(", "50", ",", "stem_channels", "=", "64", ",", "base_channels", "=", "32", ")", "\n", "assert", "model", ".", "stem_channels", "==", "64", "\n", "assert", "model", ".", "conv1", ".", "out_channels", "==", "64", "\n", "assert", "model", ".", "norm1", ".", "num_features", "==", "64", "\n", "assert", "model", ".", "layer1", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "64", "\n", "\n", "# Test stem_channels=128", "\n", "model", "=", "ResNet", "(", "depth", "=", "50", ",", "stem_channels", "=", "128", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "assert", "model", ".", "conv1", ".", "out_channels", "==", "128", "\n", "assert", "model", ".", "layer1", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "128", "\n", "\n", "# Test V1d stem_channels", "\n", "model", "=", "ResNetV1d", "(", "depth", "=", "50", ",", "stem_channels", "=", "128", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "assert", "model", ".", "stem", "[", "0", "]", ".", "out_channels", "==", "64", "\n", "assert", "model", ".", "stem", "[", "1", "]", ".", "num_features", "==", "64", "\n", "assert", "model", ".", "stem", "[", "3", "]", ".", "out_channels", "==", "64", "\n", "assert", "model", ".", "stem", "[", "4", "]", ".", "num_features", "==", "64", "\n", "assert", "model", ".", "stem", "[", "6", "]", ".", "out_channels", "==", "128", "\n", "assert", "model", ".", "stem", "[", "7", "]", ".", "num_features", "==", "128", "\n", "assert", "model", ".", "layer1", "[", "0", "]", ".", "conv1", ".", "in_channels", "==", "128", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnet_backbone": [[340, 652], ["mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "test_backbones.check_norm_state", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "test_backbones.check_norm_state", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "range", "mmdet.models.backbones.ResNetV1d", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "test_backbones.check_norm_state", "mmdet.models.backbones.ResNet.stem.parameters", "range", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.layer1.modules", "mmdet.models.backbones.ResNet.layer2.modules", "mmdet.models.backbones.ResNet.layer3.modules", "mmdet.models.backbones.ResNet.layer4.modules", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.layer1.modules", "mmdet.models.backbones.ResNet.layer2.modules", "mmdet.models.backbones.ResNet.layer3.modules", "mmdet.models.backbones.ResNet.layer4.modules", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "mmdet.models.backbones.ResNetV1d", "mmdet.models.backbones.ResNet.init_weights", "mmdet.models.backbones.ResNet.train", "torch.randn", "mmdet.models.backbones.ResNet.", "torch.randn", "mmdet.models.backbones.ResNet.", "torch.randn", "mmdet.models.backbones.ResNet.", "pytest.raises", "mmdet.models.backbones.ResNet", "pytest.raises", "mmdet.models.backbones.ResNet", "pytest.raises", "dict", "mmdet.models.backbones.ResNet", "pytest.raises", "mmdet.models.backbones.ResNet", "pytest.raises", "mmdet.models.backbones.ResNet", "pytest.raises", "mmdet.models.backbones.ResNet", "pytest.raises", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.init_weights", "pytest.raises", "mmdet.models.backbones.ResNet", "mmdet.models.backbones.ResNet.modules", "mmdet.models.backbones.ResNet.modules", "getattr.parameters", "getattr", "getattr.modules", "getattr.parameters", "len", "getattr", "getattr.modules", "getattr.parameters", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "test_backbones.is_block", "test_backbones.is_norm", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "torch.Size", "torch.Size", "torch.Size", "test_backbones.is_block", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "test_backbones.is_norm", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "dict", "dict", "dict", "test_backbones.is_block", "test_backbones.is_block", "test_backbones.is_block", "test_backbones.is_block", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "dict", "dict", "test_backbones.is_block", "test_backbones.is_block", "test_backbones.is_block", "test_backbones.is_block", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "isinstance", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "dict", "isinstance", "isinstance", "isinstance", "dict", "isinstance", "test_backbones.all_zeros", "isinstance", "dict", "dict", "dict", "hasattr", "hasattr", "hasattr", "dict", "dict", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr", "test_backbones.all_zeros", "dict"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.check_norm_state", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.check_norm_state", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.check_norm_state", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_norm", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_norm", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.all_zeros", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.all_zeros"], ["", "def", "test_resnet_backbone", "(", ")", ":", "\n", "    ", "\"\"\"Test resnet backbone.\"\"\"", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "# ResNet depth should be in [18, 34, 50, 101, 152]", "\n", "        ", "ResNet", "(", "20", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# In ResNet: 1 <= num_stages <= 4", "\n", "        ", "ResNet", "(", "50", ",", "num_stages", "=", "0", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# len(stage_with_dcn) == num_stages", "\n", "        ", "dcn", "=", "dict", "(", "type", "=", "'DCN'", ",", "deform_groups", "=", "1", ",", "fallback_on_stride", "=", "False", ")", "\n", "ResNet", "(", "50", ",", "dcn", "=", "dcn", ",", "stage_with_dcn", "=", "(", "True", ",", ")", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# len(stage_with_plugin) == num_stages", "\n", "        ", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "stages", "=", "(", "False", ",", "True", ",", "True", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "ResNet", "(", "50", ",", "plugins", "=", "plugins", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# In ResNet: 1 <= num_stages <= 4", "\n", "        ", "ResNet", "(", "50", ",", "num_stages", "=", "5", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# len(strides) == len(dilations) == num_stages", "\n", "        ", "ResNet", "(", "50", ",", "strides", "=", "(", "1", ",", ")", ",", "dilations", "=", "(", "1", ",", "1", ")", ",", "num_stages", "=", "3", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "# pretrained must be a string path", "\n", "        ", "model", "=", "ResNet", "(", "50", ")", "\n", "model", ".", "init_weights", "(", "pretrained", "=", "0", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Style must be in ['pytorch', 'caffe']", "\n", "        ", "ResNet", "(", "50", ",", "style", "=", "'tensorflow'", ")", "\n", "\n", "# Test ResNet50 norm_eval=True", "\n", "", "model", "=", "ResNet", "(", "50", ",", "norm_eval", "=", "True", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "assert", "check_norm_state", "(", "model", ".", "modules", "(", ")", ",", "False", ")", "\n", "\n", "# Test ResNet50 with torchvision pretrained weight", "\n", "model", "=", "ResNet", "(", "depth", "=", "50", ",", "norm_eval", "=", "True", ")", "\n", "model", ".", "init_weights", "(", "'torchvision://resnet50'", ")", "\n", "model", ".", "train", "(", ")", "\n", "assert", "check_norm_state", "(", "model", ".", "modules", "(", ")", ",", "False", ")", "\n", "\n", "# Test ResNet50 with first stage frozen", "\n", "frozen_stages", "=", "1", "\n", "model", "=", "ResNet", "(", "50", ",", "frozen_stages", "=", "frozen_stages", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "assert", "model", ".", "norm1", ".", "training", "is", "False", "\n", "for", "layer", "in", "[", "model", ".", "conv1", ",", "model", ".", "norm1", "]", ":", "\n", "        ", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "            ", "assert", "param", ".", "requires_grad", "is", "False", "\n", "", "", "for", "i", "in", "range", "(", "1", ",", "frozen_stages", "+", "1", ")", ":", "\n", "        ", "layer", "=", "getattr", "(", "model", ",", "f'layer{i}'", ")", "\n", "for", "mod", "in", "layer", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "mod", ",", "_BatchNorm", ")", ":", "\n", "                ", "assert", "mod", ".", "training", "is", "False", "\n", "", "", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "            ", "assert", "param", ".", "requires_grad", "is", "False", "\n", "\n", "# Test ResNet50V1d with first stage frozen", "\n", "", "", "model", "=", "ResNetV1d", "(", "depth", "=", "50", ",", "frozen_stages", "=", "frozen_stages", ")", "\n", "assert", "len", "(", "model", ".", "stem", ")", "==", "9", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "check_norm_state", "(", "model", ".", "stem", ",", "False", ")", "\n", "for", "param", "in", "model", ".", "stem", ".", "parameters", "(", ")", ":", "\n", "        ", "assert", "param", ".", "requires_grad", "is", "False", "\n", "", "for", "i", "in", "range", "(", "1", ",", "frozen_stages", "+", "1", ")", ":", "\n", "        ", "layer", "=", "getattr", "(", "model", ",", "f'layer{i}'", ")", "\n", "for", "mod", "in", "layer", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "mod", ",", "_BatchNorm", ")", ":", "\n", "                ", "assert", "mod", ".", "training", "is", "False", "\n", "", "", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "            ", "assert", "param", ".", "requires_grad", "is", "False", "\n", "\n", "# Test ResNet18 forward", "\n", "", "", "model", "=", "ResNet", "(", "18", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "128", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet18 with checkpoint forward", "\n", "model", "=", "ResNet", "(", "18", ",", "with_cp", "=", "True", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "with_cp", "\n", "\n", "# Test ResNet50 with BatchNorm forward", "\n", "", "", "model", "=", "ResNet", "(", "50", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_norm", "(", "m", ")", ":", "\n", "            ", "assert", "isinstance", "(", "m", ",", "_BatchNorm", ")", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet50 with layers 1, 2, 3 out forward", "\n", "model", "=", "ResNet", "(", "50", ",", "out_indices", "=", "(", "0", ",", "1", ",", "2", ")", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "3", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "\n", "# Test ResNet50 with checkpoint forward", "\n", "model", "=", "ResNet", "(", "50", ",", "with_cp", "=", "True", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "with_cp", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet50 with GroupNorm forward", "\n", "model", "=", "ResNet", "(", "\n", "50", ",", "norm_cfg", "=", "dict", "(", "type", "=", "'GN'", ",", "num_groups", "=", "32", ",", "requires_grad", "=", "True", ")", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_norm", "(", "m", ")", ":", "\n", "            ", "assert", "isinstance", "(", "m", ",", "GroupNorm", ")", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet50 with 1 GeneralizedAttention after conv2, 1 NonLocal2D", "\n", "# after conv2, 1 ContextBlock after conv3 in layers 2, 3, 4", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'GeneralizedAttention'", ",", "\n", "spatial_range", "=", "-", "1", ",", "\n", "num_heads", "=", "8", ",", "\n", "attention_type", "=", "'0010'", ",", "\n", "kv_stride", "=", "2", ")", ",", "\n", "stages", "=", "(", "False", ",", "True", ",", "True", ",", "True", ")", ",", "\n", "position", "=", "'after_conv2'", ")", ",", "\n", "dict", "(", "cfg", "=", "dict", "(", "type", "=", "'NonLocal2d'", ")", ",", "position", "=", "'after_conv2'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ")", ",", "\n", "stages", "=", "(", "False", ",", "True", ",", "True", ",", "False", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "model", "=", "ResNet", "(", "50", ",", "plugins", "=", "plugins", ")", "\n", "for", "m", "in", "model", ".", "layer1", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "assert", "not", "hasattr", "(", "m", ",", "'gen_attention_block'", ")", "\n", "assert", "m", ".", "nonlocal_block", ".", "in_channels", "==", "64", "\n", "", "", "for", "m", "in", "model", ".", "layer2", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "nonlocal_block", ".", "in_channels", "==", "128", "\n", "assert", "m", ".", "gen_attention_block", ".", "in_channels", "==", "128", "\n", "assert", "m", ".", "context_block", ".", "in_channels", "==", "512", "\n", "\n", "", "", "for", "m", "in", "model", ".", "layer3", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "nonlocal_block", ".", "in_channels", "==", "256", "\n", "assert", "m", ".", "gen_attention_block", ".", "in_channels", "==", "256", "\n", "assert", "m", ".", "context_block", ".", "in_channels", "==", "1024", "\n", "\n", "", "", "for", "m", "in", "model", ".", "layer4", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "nonlocal_block", ".", "in_channels", "==", "512", "\n", "assert", "m", ".", "gen_attention_block", ".", "in_channels", "==", "512", "\n", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet50 with 1 ContextBlock after conv2, 1 ContextBlock after", "\n", "# conv3 in layers 2, 3, 4", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ",", "postfix", "=", "1", ")", ",", "\n", "stages", "=", "(", "False", ",", "True", ",", "True", ",", "False", ")", ",", "\n", "position", "=", "'after_conv3'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'ContextBlock'", ",", "ratio", "=", "1.", "/", "16", ",", "postfix", "=", "2", ")", ",", "\n", "stages", "=", "(", "False", ",", "True", ",", "True", ",", "False", ")", ",", "\n", "position", "=", "'after_conv3'", ")", "\n", "]", "\n", "\n", "model", "=", "ResNet", "(", "50", ",", "plugins", "=", "plugins", ")", "\n", "for", "m", "in", "model", ".", "layer1", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "assert", "not", "hasattr", "(", "m", ",", "'context_block1'", ")", "\n", "assert", "not", "hasattr", "(", "m", ",", "'context_block2'", ")", "\n", "", "", "for", "m", "in", "model", ".", "layer2", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "assert", "m", ".", "context_block1", ".", "in_channels", "==", "512", "\n", "assert", "m", ".", "context_block2", ".", "in_channels", "==", "512", "\n", "\n", "", "", "for", "m", "in", "model", ".", "layer3", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "assert", "m", ".", "context_block1", ".", "in_channels", "==", "1024", "\n", "assert", "m", ".", "context_block2", ".", "in_channels", "==", "1024", "\n", "\n", "", "", "for", "m", "in", "model", ".", "layer4", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "not", "hasattr", "(", "m", ",", "'context_block'", ")", "\n", "assert", "not", "hasattr", "(", "m", ",", "'context_block1'", ")", "\n", "assert", "not", "hasattr", "(", "m", ",", "'context_block2'", ")", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNet50 zero initialization of residual", "\n", "model", "=", "ResNet", "(", "50", ",", "zero_init_residual", "=", "True", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", ":", "\n", "            ", "assert", "all_zeros", "(", "m", ".", "norm3", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock", ")", ":", "\n", "            ", "assert", "all_zeros", "(", "m", ".", "norm2", ")", "\n", "", "", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test ResNetV1d forward", "\n", "model", "=", "ResNetV1d", "(", "depth", "=", "50", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_renext_bottleneck": [[654, 684], ["mmdet.models.backbones.resnext.Bottleneck", "dict", "mmdet.models.backbones.resnext.Bottleneck", "mmdet.models.backbones.resnext.Bottleneck", "torch.randn", "mmdet.models.backbones.resnext.Bottleneck", "pytest.raises", "mmdet.models.backbones.resnext.Bottleneck", "pytest.raises", "mmdet.models.backbones.resnext.Bottleneck", "torch.Size", "dict"], "function", ["None"], ["", "def", "test_renext_bottleneck", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Style must be in ['pytorch', 'caffe']", "\n", "        ", "BottleneckX", "(", "64", ",", "64", ",", "groups", "=", "32", ",", "base_width", "=", "4", ",", "style", "=", "'tensorflow'", ")", "\n", "\n", "# Test ResNeXt Bottleneck structure", "\n", "", "block", "=", "BottleneckX", "(", "\n", "64", ",", "64", ",", "groups", "=", "32", ",", "base_width", "=", "4", ",", "stride", "=", "2", ",", "style", "=", "'pytorch'", ")", "\n", "assert", "block", ".", "conv2", ".", "stride", "==", "(", "2", ",", "2", ")", "\n", "assert", "block", ".", "conv2", ".", "groups", "==", "32", "\n", "assert", "block", ".", "conv2", ".", "out_channels", "==", "128", "\n", "\n", "# Test ResNeXt Bottleneck with DCN", "\n", "dcn", "=", "dict", "(", "type", "=", "'DCN'", ",", "deform_groups", "=", "1", ",", "fallback_on_stride", "=", "False", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# conv_cfg must be None if dcn is not None", "\n", "        ", "BottleneckX", "(", "\n", "64", ",", "\n", "64", ",", "\n", "groups", "=", "32", ",", "\n", "base_width", "=", "4", ",", "\n", "dcn", "=", "dcn", ",", "\n", "conv_cfg", "=", "dict", "(", "type", "=", "'Conv'", ")", ")", "\n", "", "BottleneckX", "(", "64", ",", "64", ",", "dcn", "=", "dcn", ")", "\n", "\n", "# Test ResNeXt Bottleneck forward", "\n", "block", "=", "BottleneckX", "(", "64", ",", "16", ",", "groups", "=", "32", ",", "base_width", "=", "4", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_resnext_backbone": [[686, 706], ["mmdet.models.backbones.ResNeXt", "mmdet.models.backbones.ResNeXt.modules", "mmdet.models.backbones.ResNeXt.init_weights", "mmdet.models.backbones.ResNeXt.train", "torch.randn", "mmdet.models.backbones.ResNeXt.", "pytest.raises", "mmdet.models.backbones.ResNeXt", "test_backbones.is_block", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block"], ["", "def", "test_resnext_backbone", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "# ResNeXt depth should be in [50, 101, 152]", "\n", "        ", "ResNeXt", "(", "depth", "=", "18", ")", "\n", "\n", "# Test ResNeXt with group 32, base_width 4", "\n", "", "model", "=", "ResNeXt", "(", "depth", "=", "50", ",", "groups", "=", "32", ",", "base_width", "=", "4", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "conv2", ".", "groups", "==", "32", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_regnet_backbone": [[736, 761], ["pytest.mark.parametrize", "mmdet.models.backbones.RegNet", "mmdet.models.backbones.RegNet.init_weights", "mmdet.models.backbones.RegNet.train", "torch.randn", "mmdet.models.backbones.RegNet.", "mmdet.models.backbones.RegNet", "pytest.raises", "mmdet.models.backbones.RegNet", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'arch_name,arch,out_channels'", ",", "regnet_test_data", ")", "\n", "def", "test_regnet_backbone", "(", "arch_name", ",", "arch", ",", "out_channels", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# ResNeXt depth should be in [50, 101, 152]", "\n", "        ", "RegNet", "(", "arch_name", "+", "'233'", ")", "\n", "\n", "# Test RegNet with arch_name", "\n", "", "model", "=", "RegNet", "(", "arch_name", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "0", "]", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "1", "]", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "2", "]", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "3", "]", ",", "7", ",", "7", "]", ")", "\n", "\n", "# Test RegNet with arch", "\n", "model", "=", "RegNet", "(", "arch", ")", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "0", "]", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "1", "]", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "2", "]", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", "[", "3", "]", ",", "7", ",", "7", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_res2net_bottle2neck": [[763, 795], ["mmdet.models.backbones.res2net.Bottle2neck", "dict", "mmdet.models.backbones.res2net.Bottle2neck", "mmdet.models.backbones.res2net.Bottle2neck", "torch.randn", "mmdet.models.backbones.res2net.Bottle2neck.", "pytest.raises", "mmdet.models.backbones.res2net.Bottle2neck", "pytest.raises", "mmdet.models.backbones.res2net.Bottle2neck", "pytest.raises", "mmdet.models.backbones.res2net.Bottle2neck", "torch.Size", "dict"], "function", ["None"], ["", "def", "test_res2net_bottle2neck", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Style must be in ['pytorch', 'caffe']", "\n", "        ", "Bottle2neck", "(", "64", ",", "64", ",", "base_width", "=", "26", ",", "scales", "=", "4", ",", "style", "=", "'tensorflow'", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# Scale must be larger than 1", "\n", "        ", "Bottle2neck", "(", "64", ",", "64", ",", "base_width", "=", "26", ",", "scales", "=", "1", ",", "style", "=", "'pytorch'", ")", "\n", "\n", "# Test Res2Net Bottle2neck structure", "\n", "", "block", "=", "Bottle2neck", "(", "\n", "64", ",", "64", ",", "base_width", "=", "26", ",", "stride", "=", "2", ",", "scales", "=", "4", ",", "style", "=", "'pytorch'", ")", "\n", "assert", "block", ".", "scales", "==", "4", "\n", "\n", "# Test Res2Net Bottle2neck with DCN", "\n", "dcn", "=", "dict", "(", "type", "=", "'DCN'", ",", "deform_groups", "=", "1", ",", "fallback_on_stride", "=", "False", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# conv_cfg must be None if dcn is not None", "\n", "        ", "Bottle2neck", "(", "\n", "64", ",", "\n", "64", ",", "\n", "base_width", "=", "26", ",", "\n", "scales", "=", "4", ",", "\n", "dcn", "=", "dcn", ",", "\n", "conv_cfg", "=", "dict", "(", "type", "=", "'Conv'", ")", ")", "\n", "", "Bottle2neck", "(", "64", ",", "64", ",", "dcn", "=", "dcn", ")", "\n", "\n", "# Test Res2Net Bottle2neck forward", "\n", "block", "=", "Bottle2neck", "(", "64", ",", "16", ",", "base_width", "=", "26", ",", "scales", "=", "4", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "56", ",", "56", ")", "\n", "x_out", "=", "block", "(", "x", ")", "\n", "assert", "x_out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "56", ",", "56", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_res2net_backbone": [[797, 817], ["mmdet.models.backbones.Res2Net", "mmdet.models.backbones.Res2Net.modules", "mmdet.models.backbones.Res2Net.init_weights", "mmdet.models.backbones.Res2Net.train", "torch.randn", "mmdet.models.backbones.Res2Net.", "pytest.raises", "mmdet.models.backbones.Res2Net", "test_backbones.is_block", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.is_block"], ["", "def", "test_res2net_backbone", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "# Res2Net depth should be in [50, 101, 152]", "\n", "        ", "Res2Net", "(", "depth", "=", "18", ")", "\n", "\n", "# Test Res2Net with scales 4, base_width 26", "\n", "", "model", "=", "Res2Net", "(", "depth", "=", "50", ",", "scales", "=", "4", ",", "base_width", "=", "26", ")", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_block", "(", "m", ")", ":", "\n", "            ", "assert", "m", ".", "scales", "==", "4", "\n", "", "", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "4", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "56", ",", "56", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "28", ",", "28", "]", ")", "\n", "assert", "feat", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1024", ",", "14", ",", "14", "]", ")", "\n", "assert", "feat", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "2048", ",", "7", ",", "7", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_backbones.test_hourglass_backbone": [[819, 857], ["mmdet.models.backbones.hourglass.HourglassNet", "mmdet.models.backbones.hourglass.HourglassNet.init_weights", "mmdet.models.backbones.hourglass.HourglassNet.train", "torch.randn", "mmdet.models.backbones.hourglass.HourglassNet.", "mmdet.models.backbones.hourglass.HourglassNet", "mmdet.models.backbones.hourglass.HourglassNet.init_weights", "mmdet.models.backbones.hourglass.HourglassNet.train", "torch.randn", "mmdet.models.backbones.hourglass.HourglassNet.", "pytest.raises", "mmdet.models.backbones.hourglass.HourglassNet", "pytest.raises", "mmdet.models.backbones.hourglass.HourglassNet", "pytest.raises", "mmdet.models.backbones.hourglass.HourglassNet", "len", "torch.Size", "len", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.backbones.resnet.ResNet.train"], ["", "def", "test_hourglass_backbone", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# HourglassNet's num_stacks should larger than 0", "\n", "        ", "HourglassNet", "(", "num_stacks", "=", "0", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# len(stage_channels) should equal len(stage_blocks)", "\n", "        ", "HourglassNet", "(", "\n", "stage_channels", "=", "[", "256", ",", "256", ",", "384", ",", "384", ",", "384", "]", ",", "\n", "stage_blocks", "=", "[", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "4", "]", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# len(stage_channels) should lagrer than downsample_times", "\n", "        ", "HourglassNet", "(", "\n", "downsample_times", "=", "5", ",", "\n", "stage_channels", "=", "[", "256", ",", "256", ",", "384", ",", "384", ",", "384", "]", ",", "\n", "stage_blocks", "=", "[", "2", ",", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "\n", "# Test HourglassNet-52", "\n", "", "model", "=", "HourglassNet", "(", "num_stacks", "=", "1", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "511", ",", "511", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "1", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "128", ",", "128", "]", ")", "\n", "\n", "# Test HourglassNet-104", "\n", "model", "=", "HourglassNet", "(", "num_stacks", "=", "2", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "511", ",", "511", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "len", "(", "feat", ")", "==", "2", "\n", "assert", "feat", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "128", ",", "128", "]", ")", "\n", "assert", "feat", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "128", ",", "128", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_pisa_heads.test_pisa_retinanet_head_loss": [[8, 73], ["mmcv.Config", "mmdet.models.dense_heads.PISARetinaHead", "mmdet.models.dense_heads.PISARetinaHead.forward", "mmdet.models.dense_heads.PISARetinaHead.loss", "empty_gt_losses[].sum", "empty_gt_losses[].sum", "mmdet.models.dense_heads.PISARetinaHead.loss", "one_gt_losses[].sum", "one_gt_losses[].sum", "dict", "torch.rand", "torch.empty", "torch.LongTensor", "empty_gt_losses[].sum.item", "empty_gt_losses[].sum.item", "torch.Tensor", "torch.LongTensor", "one_gt_losses[].sum.item", "one_gt_losses[].sum.item", "range", "dict", "dict", "dict", "dict", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["def", "test_pisa_retinanet_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests pisa retinanet head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.7", ",", "\n", "neg_iou_thr", "=", "0.3", ",", "\n", "min_pos_iou", "=", "0.3", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "sampler", "=", "dict", "(", "\n", "type", "=", "'RandomSampler'", ",", "\n", "num", "=", "256", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "False", ")", ",", "\n", "isr", "=", "dict", "(", "k", "=", "2.", ",", "bias", "=", "0.", ")", ",", "\n", "carl", "=", "dict", "(", "k", "=", "1.", ",", "bias", "=", "0.2", ")", ",", "\n", "allowed_border", "=", "0", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "self", "=", "PISARetinaHead", "(", "num_classes", "=", "4", ",", "in_channels", "=", "1", ",", "train_cfg", "=", "cfg", ")", "\n", "\n", "# Anchor head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "anchor_generator", ".", "strides", ")", ")", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", "=", "self", ".", "forward", "(", "feat", ")", "\n", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "\n", "gt_bboxes_ignore", "=", "None", "\n", "empty_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "# When there is no truth, the cls loss should be nonzero but there should", "\n", "# be no box loss.", "\n", "empty_cls_loss", "=", "empty_gt_losses", "[", "'loss_cls'", "]", ".", "sum", "(", ")", "\n", "empty_box_loss", "=", "empty_gt_losses", "[", "'loss_bbox'", "]", ".", "sum", "(", ")", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "one_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "one_gt_losses", "[", "'loss_cls'", "]", ".", "sum", "(", ")", "\n", "onegt_box_loss", "=", "one_gt_losses", "[", "'loss_bbox'", "]", ".", "sum", "(", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_pisa_heads.test_pisa_ssd_head_loss": [[75, 148], ["mmcv.Config", "dict", "mmdet.models.dense_heads.PISASSDHead", "mmdet.models.dense_heads.PISASSDHead.forward", "mmdet.models.dense_heads.PISASSDHead.loss", "sum", "sum", "mmdet.models.dense_heads.PISASSDHead.loss", "sum", "sum", "dict", "torch.rand", "torch.empty", "torch.LongTensor", "sum.item", "sum.item", "torch.Tensor", "torch.LongTensor", "sum.item", "sum.item", "range", "dict", "dict", "dict", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.reppoints_head.RepPointsHead.loss"], ["", "def", "test_pisa_ssd_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests pisa ssd head loss when truth is empty and non-empty.\"\"\"", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "min_pos_iou", "=", "0.", ",", "\n", "ignore_iof_thr", "=", "-", "1", ",", "\n", "gt_max_assign_all", "=", "False", ")", ",", "\n", "isr", "=", "dict", "(", "k", "=", "2.", ",", "bias", "=", "0.", ")", ",", "\n", "carl", "=", "dict", "(", "k", "=", "1.", ",", "bias", "=", "0.2", ")", ",", "\n", "smoothl1_beta", "=", "1.", ",", "\n", "allowed_border", "=", "-", "1", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "neg_pos_ratio", "=", "3", ",", "\n", "debug", "=", "False", ")", ")", "\n", "ssd_anchor_generator", "=", "dict", "(", "\n", "type", "=", "'SSDAnchorGenerator'", ",", "\n", "scale_major", "=", "False", ",", "\n", "input_size", "=", "300", ",", "\n", "strides", "=", "[", "1", "]", ",", "\n", "ratios", "=", "(", "[", "2", "]", ",", ")", ",", "\n", "basesize_ratio_range", "=", "(", "0.15", ",", "0.9", ")", ")", "\n", "self", "=", "PISASSDHead", "(", "\n", "num_classes", "=", "4", ",", "\n", "in_channels", "=", "(", "1", ",", ")", ",", "\n", "train_cfg", "=", "cfg", ",", "\n", "anchor_generator", "=", "ssd_anchor_generator", ")", "\n", "\n", "# Anchor head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "anchor_generator", ".", "strides", ")", ")", "\n", "]", "\n", "cls_scores", ",", "bbox_preds", "=", "self", ".", "forward", "(", "feat", ")", "\n", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "\n", "gt_bboxes_ignore", "=", "None", "\n", "empty_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "# When there is no truth, the cls loss should be nonzero but there should", "\n", "# be no box loss.", "\n", "empty_cls_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "empty_box_loss", "=", "sum", "(", "empty_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "# SSD is special, #pos:#neg = 1: 3, so empth gt will also lead loss cls = 0", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", "==", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "one_gt_losses", "=", "self", ".", "loss", "(", "cls_scores", ",", "bbox_preds", ",", "gt_bboxes", ",", "gt_labels", ",", "\n", "img_metas", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_cls'", "]", ")", "\n", "onegt_box_loss", "=", "sum", "(", "one_gt_losses", "[", "'loss_bbox'", "]", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_pisa_heads.test_pisa_roi_head_loss": [[150, 245], ["mmcv.Config", "dict", "dict", "mmdet.models.roi_heads.PISARoIHead", "mmdet.models.roi_heads.PISARoIHead.forward_train", "empty_gt_losses[].sum", "empty_gt_losses[].sum", "mmdet.models.roi_heads.PISARoIHead.forward_train", "one_gt_losses[].sum", "one_gt_losses[].sum", "dict", "torch.rand", "torch.Tensor", "torch.empty", "torch.LongTensor", "empty_gt_losses[].sum.item", "empty_gt_losses[].sum.item", "torch.Tensor", "torch.LongTensor", "one_gt_losses[].sum.item", "one_gt_losses[].sum.item", "dict", "dict", "dict", "dict", "range", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.dense_heads.base_dense_head.BaseDenseHead.forward_train"], ["", "def", "test_pisa_roi_head_loss", "(", ")", ":", "\n", "    ", "\"\"\"Tests pisa roi head loss when truth is empty and non-empty.\"\"\"", "\n", "train_cfg", "=", "mmcv", ".", "Config", "(", "\n", "dict", "(", "\n", "assigner", "=", "dict", "(", "\n", "type", "=", "'MaxIoUAssigner'", ",", "\n", "pos_iou_thr", "=", "0.7", ",", "\n", "neg_iou_thr", "=", "0.3", ",", "\n", "min_pos_iou", "=", "0.3", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ")", ",", "\n", "sampler", "=", "dict", "(", "\n", "type", "=", "'ScoreHLRSampler'", ",", "\n", "num", "=", "4", ",", "\n", "pos_fraction", "=", "0.25", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "k", "=", "0.5", ",", "\n", "bias", "=", "0.", ")", ",", "\n", "isr", "=", "dict", "(", "k", "=", "2.", ",", "bias", "=", "0.", ")", ",", "\n", "carl", "=", "dict", "(", "k", "=", "1.", ",", "bias", "=", "0.2", ")", ",", "\n", "allowed_border", "=", "0", ",", "\n", "pos_weight", "=", "-", "1", ",", "\n", "debug", "=", "False", ")", ")", "\n", "\n", "bbox_roi_extractor", "=", "dict", "(", "\n", "type", "=", "'SingleRoIExtractor'", ",", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ",", "sampling_ratio", "=", "0", ")", ",", "\n", "out_channels", "=", "1", ",", "\n", "featmap_strides", "=", "[", "1", "]", ")", "\n", "\n", "bbox_head", "=", "dict", "(", "\n", "type", "=", "'Shared2FCBBoxHead'", ",", "\n", "in_channels", "=", "1", ",", "\n", "fc_out_channels", "=", "2", ",", "\n", "roi_feat_size", "=", "7", ",", "\n", "num_classes", "=", "4", ",", "\n", "bbox_coder", "=", "dict", "(", "\n", "type", "=", "'DeltaXYWHBBoxCoder'", ",", "\n", "target_means", "=", "[", "0.", ",", "0.", ",", "0.", ",", "0.", "]", ",", "\n", "target_stds", "=", "[", "0.1", ",", "0.1", ",", "0.2", ",", "0.2", "]", ")", ",", "\n", "reg_class_agnostic", "=", "False", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_sigmoid", "=", "False", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_bbox", "=", "dict", "(", "type", "=", "'L1Loss'", ",", "loss_weight", "=", "1.0", ")", ")", "\n", "\n", "self", "=", "PISARoIHead", "(", "bbox_roi_extractor", ",", "bbox_head", ",", "train_cfg", "=", "train_cfg", ")", "\n", "\n", "s", "=", "256", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "s", ",", "s", ",", "3", ")", ",", "\n", "'scale_factor'", ":", "1", ",", "\n", "'pad_shape'", ":", "(", "s", ",", "s", ",", "3", ")", "\n", "}", "]", "\n", "\n", "# Anchor head expects a multiple levels of features per image", "\n", "feat", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "1", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ",", "s", "//", "(", "2", "**", "(", "i", "+", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ")", "\n", "]", "\n", "\n", "proposal_list", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "22.6667", ",", "22.8757", ",", "238.6326", ",", "151.8874", "]", ",", "[", "0", ",", "3", ",", "5", ",", "7", "]", "]", ")", "\n", "]", "\n", "\n", "# Test that empty ground truth encourages the network to predict background", "\n", "gt_bboxes", "=", "[", "torch", ".", "empty", "(", "(", "0", ",", "4", ")", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "]", ")", "]", "\n", "gt_bboxes_ignore", "=", "None", "\n", "\n", "empty_gt_losses", "=", "self", ".", "forward_train", "(", "feat", ",", "img_metas", ",", "proposal_list", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "\n", "gt_bboxes_ignore", ")", "\n", "\n", "# When there is no truth, the cls loss should be nonzero but there should", "\n", "# be no box loss.", "\n", "empty_cls_loss", "=", "empty_gt_losses", "[", "'loss_cls'", "]", ".", "sum", "(", ")", "\n", "empty_box_loss", "=", "empty_gt_losses", "[", "'loss_bbox'", "]", ".", "sum", "(", ")", "\n", "assert", "empty_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "empty_box_loss", ".", "item", "(", ")", "==", "0", ",", "(", "\n", "'there should be no box loss when there are no true boxes'", ")", "\n", "\n", "# When truth is non-empty then both cls and box loss should be nonzero for", "\n", "# random inputs", "\n", "gt_bboxes", "=", "[", "\n", "torch", ".", "Tensor", "(", "[", "[", "23.6667", ",", "23.8757", ",", "238.6326", ",", "151.8874", "]", "]", ")", ",", "\n", "]", "\n", "gt_labels", "=", "[", "torch", ".", "LongTensor", "(", "[", "2", "]", ")", "]", "\n", "\n", "one_gt_losses", "=", "self", ".", "forward_train", "(", "feat", ",", "img_metas", ",", "proposal_list", ",", "\n", "gt_bboxes", ",", "gt_labels", ",", "gt_bboxes_ignore", ")", "\n", "onegt_cls_loss", "=", "one_gt_losses", "[", "'loss_cls'", "]", ".", "sum", "(", ")", "\n", "onegt_box_loss", "=", "one_gt_losses", "[", "'loss_bbox'", "]", ".", "sum", "(", ")", "\n", "assert", "onegt_cls_loss", ".", "item", "(", ")", ">", "0", ",", "'cls loss should be non-zero'", "\n", "assert", "onegt_box_loss", ".", "item", "(", ")", ">", "0", ",", "'box loss should be non-zero'", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_directory": [[10, 23], ["os.path.join", "os.path.dirname", "os.path.exists", "Exception", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["def", "_get_config_directory", "(", ")", ":", "\n", "    ", "\"\"\"Find the predefined detector config directory.\"\"\"", "\n", "try", ":", "\n", "# Assume we are running in the source mmdetection repo", "\n", "        ", "repo_dpath", "=", "dirname", "(", "dirname", "(", "dirname", "(", "__file__", ")", ")", ")", "\n", "", "except", "NameError", ":", "\n", "# For IPython development when this __file__ is not defined", "\n", "        ", "import", "mmdet", "\n", "repo_dpath", "=", "dirname", "(", "dirname", "(", "mmdet", ".", "__file__", ")", ")", "\n", "", "config_dpath", "=", "join", "(", "repo_dpath", ",", "'configs'", ")", "\n", "if", "not", "exists", "(", "config_dpath", ")", ":", "\n", "        ", "raise", "Exception", "(", "'Cannot find config path'", ")", "\n", "", "return", "config_dpath", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_module": [[25, 32], ["test_forward._get_config_directory", "os.path.join", "Config.fromfile"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_directory"], ["", "def", "_get_config_module", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Load a configuration as a python module.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "config_fpath", "=", "join", "(", "config_dpath", ",", "fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "return", "config_mod", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg": [[34, 46], ["test_forward._get_config_module", "copy.deepcopy", "mmcv.Config", "mmcv.Config", "copy.deepcopy", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_config_module"], ["", "def", "_get_detector_cfg", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Grab configs necessary to create a detector.\n\n    These are deep copied to allow for safe modification of parameters without\n    influencing other tests.\n    \"\"\"", "\n", "import", "mmcv", "\n", "config", "=", "_get_config_module", "(", "fname", ")", "\n", "model", "=", "copy", ".", "deepcopy", "(", "config", ".", "model", ")", "\n", "train_cfg", "=", "mmcv", ".", "Config", "(", "copy", ".", "deepcopy", "(", "config", ".", "train_cfg", ")", ")", "\n", "test_cfg", "=", "mmcv", ".", "Config", "(", "copy", ".", "deepcopy", "(", "config", ".", "test_cfg", ")", ")", "\n", "return", "model", ",", "train_cfg", ",", "test_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward.test_rpn_forward": [[48, 76], ["test_forward._get_detector_cfg", "build_detector", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "torch.no_grad", "zip", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "def", "test_rpn_forward", "(", ")", ":", "\n", "    ", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "\n", "'rpn/rpn_r50_fpn_1x_coco.py'", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "# Test forward train", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "img_metas", ",", "gt_bboxes", "=", "gt_bboxes", ",", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward.test_single_stage_forward_gpu": [[78, 128], ["pytest.mark.parametrize", "test_forward._get_detector_cfg", "build_detector", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "detector.cuda.cuda", "imgs.cuda.cuda", "detector.cuda.forward", "isinstance", "torch.cuda.is_available", "pytest.skip", "b.cuda", "g.cuda", "torch.no_grad", "zip", "detector.cuda.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "\n", "[", "\n", "'retinanet/retinanet_r50_fpn_1x_coco.py'", ",", "\n", "'guided_anchoring/ga_retinanet_r50_fpn_1x_coco.py'", ",", "\n", "'ghm/retinanet_ghm_r50_fpn_1x_coco.py'", ",", "\n", "'fcos/fcos_center_r50_caffe_fpn_gn-head_4x4_1x_coco.py'", ",", "\n", "'foveabox/fovea_align_r50_fpn_gn-head_4x4_2x_coco.py'", ",", "\n", "# 'free_anchor/retinanet_free_anchor_r50_fpn_1x_coco.py',", "\n", "# 'atss/atss_r50_fpn_1x_coco.py',  # not ready for topk", "\n", "'reppoints/reppoints_moment_r50_fpn_1x_coco.py'", "\n", "]", ")", "\n", "def", "test_single_stage_forward_gpu", "(", "cfg_file", ")", ":", "\n", "    ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "import", "pytest", "\n", "pytest", ".", "skip", "(", "'test requires GPU and torch+cuda'", ")", "\n", "\n", "", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", "\n", "\n", "input_shape", "=", "(", "2", ",", "3", ",", "224", ",", "224", ")", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "detector", "=", "detector", ".", "cuda", "(", ")", "\n", "imgs", "=", "imgs", ".", "cuda", "(", ")", "\n", "# Test forward train", "\n", "gt_bboxes", "=", "[", "b", ".", "cuda", "(", ")", "for", "b", "in", "mm_inputs", "[", "'gt_bboxes'", "]", "]", "\n", "gt_labels", "=", "[", "g", ".", "cuda", "(", ")", "for", "g", "in", "mm_inputs", "[", "'gt_labels'", "]", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward.test_faster_rcnn_ohem_forward": [[130, 171], ["test_forward._get_detector_cfg", "build_detector", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "build_detector._parse_losses", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "build_detector._parse_losses", "float", "float", "loss.item", "loss.item"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses"], ["", "", "", "def", "test_faster_rcnn_ohem_forward", "(", ")", ":", "\n", "    ", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "\n", "'faster_rcnn/faster_rcnn_r50_fpn_ohem_1x_coco.py'", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "256", ",", "256", ")", "\n", "\n", "# Test forward train with a non-empty truth batch", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ",", "num_items", "=", "[", "10", "]", ")", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "gt_labels", "=", "mm_inputs", "[", "'gt_labels'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "loss", ",", "_", "=", "detector", ".", "_parse_losses", "(", "losses", ")", "\n", "assert", "float", "(", "loss", ".", "item", "(", ")", ")", ">", "0", "\n", "\n", "# Test forward train with an empty truth batch", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ",", "num_items", "=", "[", "0", "]", ")", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "gt_labels", "=", "mm_inputs", "[", "'gt_labels'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "loss", ",", "_", "=", "detector", ".", "_parse_losses", "(", "losses", ")", "\n", "assert", "float", "(", "loss", ".", "item", "(", ")", ")", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward.test_two_stage_forward": [[174, 237], ["pytest.mark.parametrize", "test_forward._get_detector_cfg", "build_detector", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "build_detector._parse_losses", "loss.requires_grad_", "loss.backward", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "build_detector._parse_losses", "loss.requires_grad_", "loss.backward", "float", "float", "torch.no_grad", "zip", "loss.item", "loss.item", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.detectors.base.BaseDetector._parse_losses", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'cascade_rcnn/cascade_mask_rcnn_r50_fpn_1x_coco.py'", ",", "\n", "'mask_rcnn/mask_rcnn_r50_fpn_1x_coco.py'", ",", "\n", "'grid_rcnn/grid_rcnn_r50_fpn_gn-head_2x_coco.py'", ",", "\n", "'ms_rcnn/ms_rcnn_r50_fpn_1x_coco.py'", "\n", "]", ")", "\n", "def", "test_two_stage_forward", "(", "cfg_file", ")", ":", "\n", "    ", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "256", ",", "256", ")", "\n", "\n", "# Test forward train with a non-empty truth batch", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ",", "num_items", "=", "[", "10", "]", ")", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "gt_labels", "=", "mm_inputs", "[", "'gt_labels'", "]", "\n", "gt_masks", "=", "mm_inputs", "[", "'gt_masks'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "gt_masks", "=", "gt_masks", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "loss", ",", "_", "=", "detector", ".", "_parse_losses", "(", "losses", ")", "\n", "loss", ".", "requires_grad_", "(", "True", ")", "\n", "assert", "float", "(", "loss", ".", "item", "(", ")", ")", ">", "0", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Test forward train with an empty truth batch", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ",", "num_items", "=", "[", "0", "]", ")", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "gt_labels", "=", "mm_inputs", "[", "'gt_labels'", "]", "\n", "gt_masks", "=", "mm_inputs", "[", "'gt_masks'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "gt_masks", "=", "gt_masks", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "loss", ",", "_", "=", "detector", ".", "_parse_losses", "(", "losses", ")", "\n", "loss", ".", "requires_grad_", "(", "True", ")", "\n", "assert", "float", "(", "loss", ".", "item", "(", ")", ")", ">", "0", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward.test_single_stage_forward_cpu": [[239, 273], ["pytest.mark.parametrize", "test_forward._get_detector_cfg", "build_detector", "test_forward._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "torch.no_grad", "zip", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.losses.smooth_l1_loss.L1Loss.forward"], ["", "", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "[", "'ghm/retinanet_ghm_r50_fpn_1x_coco.py'", ",", "'ssd/ssd300_coco.py'", "]", ")", "\n", "def", "test_single_stage_forward_cpu", "(", "cfg_file", ")", ":", "\n", "    ", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "# Test forward train", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "gt_labels", "=", "mm_inputs", "[", "'gt_labels'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "return_loss", "=", "True", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._demo_mm_inputs": [[275, 341], ["numpy.random.RandomState", "np.random.RandomState.rand", "range", "numpy.random.randint", "gt_masks.append", "np.random.RandomState.randint", "gt_bboxes.append", "gt_labels.append", "BitmapMasks", "torch.FloatTensor().requires_grad_", "range", "np.random.RandomState.randint", "np.random.RandomState.rand", "numpy.vstack", "torch.FloatTensor", "torch.LongTensor", "len", "torch.FloatTensor"], "function", ["None"], ["", "", "", "def", "_demo_mm_inputs", "(", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", ",", "\n", "num_items", "=", "None", ",", "num_classes", "=", "10", ")", ":", "# yapf: disable", "\n", "    ", "\"\"\"Create a superset of inputs needed to run test or train batches.\n\n    Args:\n        input_shape (tuple):\n            input batch dimensions\n\n        num_items (None | List[int]):\n            specifies the number of boxes in each batch item\n\n        num_classes (int):\n            number of different labels a box might have\n    \"\"\"", "\n", "from", "mmdet", ".", "core", "import", "BitmapMasks", "\n", "\n", "(", "N", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "\n", "imgs", "=", "rng", ".", "rand", "(", "*", "input_shape", ")", "\n", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'pad_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'scale_factor'", ":", "1.0", ",", "\n", "'flip'", ":", "False", ",", "\n", "}", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_masks", "=", "[", "]", "\n", "\n", "for", "batch_idx", "in", "range", "(", "N", ")", ":", "\n", "        ", "if", "num_items", "is", "None", ":", "\n", "            ", "num_boxes", "=", "rng", ".", "randint", "(", "1", ",", "10", ")", "\n", "", "else", ":", "\n", "            ", "num_boxes", "=", "num_items", "[", "batch_idx", "]", "\n", "\n", "", "cx", ",", "cy", ",", "bw", ",", "bh", "=", "rng", ".", "rand", "(", "num_boxes", ",", "4", ")", ".", "T", "\n", "\n", "tl_x", "=", "(", "(", "cx", "*", "W", ")", "-", "(", "W", "*", "bw", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "W", ")", "\n", "tl_y", "=", "(", "(", "cy", "*", "H", ")", "-", "(", "H", "*", "bh", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "H", ")", "\n", "br_x", "=", "(", "(", "cx", "*", "W", ")", "+", "(", "W", "*", "bw", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "W", ")", "\n", "br_y", "=", "(", "(", "cy", "*", "H", ")", "+", "(", "H", "*", "bh", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "H", ")", "\n", "\n", "boxes", "=", "np", ".", "vstack", "(", "[", "tl_x", ",", "tl_y", ",", "br_x", ",", "br_y", "]", ")", ".", "T", "\n", "class_idxs", "=", "rng", ".", "randint", "(", "1", ",", "num_classes", ",", "size", "=", "num_boxes", ")", "\n", "\n", "gt_bboxes", ".", "append", "(", "torch", ".", "FloatTensor", "(", "boxes", ")", ")", "\n", "gt_labels", ".", "append", "(", "torch", ".", "LongTensor", "(", "class_idxs", ")", ")", "\n", "\n", "", "mask", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "(", "len", "(", "boxes", ")", ",", "H", ",", "W", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "gt_masks", ".", "append", "(", "BitmapMasks", "(", "mask", ",", "H", ",", "W", ")", ")", "\n", "\n", "mm_inputs", "=", "{", "\n", "'imgs'", ":", "torch", ".", "FloatTensor", "(", "imgs", ")", ".", "requires_grad_", "(", "True", ")", ",", "\n", "'img_metas'", ":", "img_metas", ",", "\n", "'gt_bboxes'", ":", "gt_bboxes", ",", "\n", "'gt_labels'", ":", "gt_labels", ",", "\n", "'gt_bboxes_ignore'", ":", "None", ",", "\n", "'gt_masks'", ":", "gt_masks", ",", "\n", "}", "\n", "return", "mm_inputs", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_losses.test_ce_loss": [[7, 32], ["dict", "mmdet.models.build_loss", "torch.Tensor", "torch.Tensor().long", "torch.allclose", "dict", "mmdet.models.build_loss", "torch.allclose", "pytest.raises", "dict", "mmdet.models.build_loss", "mmdet.models.build_loss.", "torch.tensor", "mmdet.models.build_loss.", "torch.tensor", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_loss"], ["def", "test_ce_loss", "(", ")", ":", "\n", "# use_mask and use_sigmoid cannot be true at the same time", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "loss_cfg", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_mask", "=", "True", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "1.0", ")", "\n", "build_loss", "(", "loss_cfg", ")", "\n", "\n", "# test loss with class weights", "\n", "", "loss_cls_cfg", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "False", ",", "\n", "class_weight", "=", "[", "0.8", ",", "0.2", "]", ",", "\n", "loss_weight", "=", "1.0", ")", "\n", "loss_cls", "=", "build_loss", "(", "loss_cls_cfg", ")", "\n", "fake_pred", "=", "torch", ".", "Tensor", "(", "[", "[", "100", ",", "-", "100", "]", "]", ")", "\n", "fake_label", "=", "torch", ".", "Tensor", "(", "[", "1", "]", ")", ".", "long", "(", ")", "\n", "assert", "torch", ".", "allclose", "(", "loss_cls", "(", "fake_pred", ",", "fake_label", ")", ",", "torch", ".", "tensor", "(", "40.", ")", ")", "\n", "\n", "loss_cls_cfg", "=", "dict", "(", "\n", "type", "=", "'CrossEntropyLoss'", ",", "use_sigmoid", "=", "False", ",", "loss_weight", "=", "1.0", ")", "\n", "loss_cls", "=", "build_loss", "(", "loss_cls_cfg", ")", "\n", "assert", "torch", ".", "allclose", "(", "loss_cls", "(", "fake_pred", ",", "fake_label", ")", ",", "torch", ".", "tensor", "(", "200.", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_losses.test_accuracy": [[34, 90], ["torch.empty", "torch.empty", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "torch.Tensor", "torch.Tensor().long", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "torch.Tensor().long", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "mmdet.models.Accuracy", "torch.Tensor().long", "mmdet.models.Accuracy.", "mmdet.models.Accuracy", "torch.Tensor().long", "mmdet.models.Accuracy.", "accuracy.item", "accuracy.item", "accuracy.item", "accuracy.item", "pytest.raises", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "pytest.raises", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "pytest.raises", "torch.Tensor().long", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "pytest.raises", "mmdet.models.Accuracy", "mmdet.models.Accuracy.", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "a.item", "torch.Tensor"], "function", ["None"], ["", "def", "test_accuracy", "(", ")", ":", "\n", "# test for empty pred", "\n", "    ", "pred", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "label", "=", "torch", ".", "empty", "(", "0", ")", "\n", "accuracy", "=", "Accuracy", "(", "topk", "=", "1", ")", "\n", "acc", "=", "accuracy", "(", "pred", ",", "label", ")", "\n", "assert", "acc", ".", "item", "(", ")", "==", "0", "\n", "\n", "pred", "=", "torch", ".", "Tensor", "(", "[", "[", "0.2", ",", "0.3", ",", "0.6", ",", "0.5", "]", ",", "[", "0.1", ",", "0.1", ",", "0.2", ",", "0.6", "]", ",", "\n", "[", "0.9", ",", "0.0", ",", "0.0", ",", "0.1", "]", ",", "[", "0.4", ",", "0.7", ",", "0.1", ",", "0.1", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.99", ",", "0", "]", "]", ")", "\n", "# test for top1", "\n", "true_label", "=", "torch", ".", "Tensor", "(", "[", "2", ",", "3", ",", "0", ",", "1", ",", "2", "]", ")", ".", "long", "(", ")", "\n", "accuracy", "=", "Accuracy", "(", "topk", "=", "1", ")", "\n", "acc", "=", "accuracy", "(", "pred", ",", "true_label", ")", "\n", "assert", "acc", ".", "item", "(", ")", "==", "100", "\n", "\n", "# test for top1 with score thresh=0.8", "\n", "true_label", "=", "torch", ".", "Tensor", "(", "[", "2", ",", "3", ",", "0", ",", "1", ",", "2", "]", ")", ".", "long", "(", ")", "\n", "accuracy", "=", "Accuracy", "(", "topk", "=", "1", ",", "thresh", "=", "0.8", ")", "\n", "acc", "=", "accuracy", "(", "pred", ",", "true_label", ")", "\n", "assert", "acc", ".", "item", "(", ")", "==", "40", "\n", "\n", "# test for top2", "\n", "accuracy", "=", "Accuracy", "(", "topk", "=", "2", ")", "\n", "label", "=", "torch", ".", "Tensor", "(", "[", "3", ",", "2", ",", "0", ",", "0", ",", "2", "]", ")", ".", "long", "(", ")", "\n", "acc", "=", "accuracy", "(", "pred", ",", "label", ")", "\n", "assert", "acc", ".", "item", "(", ")", "==", "100", "\n", "\n", "# test for both top1 and top2", "\n", "accuracy", "=", "Accuracy", "(", "topk", "=", "(", "1", ",", "2", ")", ")", "\n", "true_label", "=", "torch", ".", "Tensor", "(", "[", "2", ",", "3", ",", "0", ",", "1", ",", "2", "]", ")", ".", "long", "(", ")", "\n", "acc", "=", "accuracy", "(", "pred", ",", "true_label", ")", "\n", "for", "a", "in", "acc", ":", "\n", "        ", "assert", "a", ".", "item", "(", ")", "==", "100", "\n", "\n", "# topk is larger than pred class number", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "accuracy", "=", "Accuracy", "(", "topk", "=", "5", ")", "\n", "accuracy", "(", "pred", ",", "true_label", ")", "\n", "\n", "# wrong topk type", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "accuracy", "=", "Accuracy", "(", "topk", "=", "'wrong type'", ")", "\n", "accuracy", "(", "pred", ",", "true_label", ")", "\n", "\n", "# label size is larger than required", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label", "=", "torch", ".", "Tensor", "(", "[", "2", ",", "3", ",", "0", ",", "1", ",", "2", ",", "0", "]", ")", ".", "long", "(", ")", "# size mismatch", "\n", "accuracy", "=", "Accuracy", "(", ")", "\n", "accuracy", "(", "pred", ",", "label", ")", "\n", "\n", "# wrong pred dimension", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "accuracy", "=", "Accuracy", "(", ")", "\n", "accuracy", "(", "pred", "[", ":", ",", ":", ",", "None", "]", ",", "true_label", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_resize": [[14, 80], ["dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.imread", "copy.deepcopy", "mmcv.utils.build_from_cfg.", "numpy.equal().all", "transform.pop", "transform.pop", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "numpy.equal().all", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "os.join", "os.dirname", "numpy.equal", "numpy.equal", "os.join", "dict", "os.dirname"], "function", ["None"], ["def", "test_resize", "(", ")", ":", "\n", "# test assertion if img_scale is a list", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'Resize'", ",", "img_scale", "=", "[", "1333", ",", "800", "]", ",", "keep_ratio", "=", "True", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion if len(img_scale) while ratio_range is not None", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'Resize'", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", ",", "(", "1333", ",", "600", ")", "]", ",", "\n", "ratio_range", "=", "(", "0.9", ",", "1.1", ")", ",", "\n", "keep_ratio", "=", "True", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid multiscale_mode", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'Resize'", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", ",", "(", "1333", ",", "600", ")", "]", ",", "\n", "keep_ratio", "=", "True", ",", "\n", "multiscale_mode", "=", "'2333'", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion if both scale and scale_factor are setted", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "load", "=", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", "\n", "load", "=", "build_from_cfg", "(", "load", ",", "PIPELINES", ")", "\n", "transform", "=", "dict", "(", "type", "=", "'Resize'", ",", "img_scale", "=", "(", "1333", ",", "800", ")", ",", "keep_ratio", "=", "True", ")", "\n", "transform", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "load", "(", "results", ")", "\n", "results", "[", "'scale'", "]", "=", "(", "1333", ",", "800", ")", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "results", "=", "transform", "(", "results", ")", "\n", "\n", "", "transform", "=", "dict", "(", "type", "=", "'Resize'", ",", "img_scale", "=", "(", "1333", ",", "800", ")", ",", "keep_ratio", "=", "True", ")", "\n", "resize_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img2'", "]", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", ",", "'img2'", "]", "\n", "\n", "results", "=", "resize_module", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "\n", "results", ".", "pop", "(", "'scale'", ")", "\n", "results", ".", "pop", "(", "'scale_factor'", ")", "\n", "transform", "=", "dict", "(", "\n", "type", "=", "'Resize'", ",", "\n", "img_scale", "=", "(", "1280", ",", "800", ")", ",", "\n", "multiscale_mode", "=", "'value'", ",", "\n", "keep_ratio", "=", "False", ")", "\n", "resize_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "resize_module", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "assert", "results", "[", "'img_shape'", "]", "==", "(", "800", ",", "1280", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_flip": [[82, 117], ["dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.imread", "copy.deepcopy", "copy.deepcopy", "mmcv.utils.build_from_cfg.", "numpy.equal().all", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "numpy.equal().all", "numpy.equal().all", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "os.join", "os.dirname", "numpy.equal", "numpy.equal", "numpy.equal"], "function", ["None"], ["", "def", "test_flip", "(", ")", ":", "\n", "# test assertion for invalid flip_ratio", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'RandomFlip'", ",", "flip_ratio", "=", "1.5", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid direction", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomFlip'", ",", "flip_ratio", "=", "1", ",", "direction", "=", "'horizonta'", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "transform", "=", "dict", "(", "type", "=", "'RandomFlip'", ",", "flip_ratio", "=", "1", ")", "\n", "flip_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "original_img", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img2'", "]", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", ",", "'img2'", "]", "\n", "\n", "results", "=", "flip_module", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "\n", "flip_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "flip_module", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "assert", "np", ".", "equal", "(", "original_img", ",", "results", "[", "'img'", "]", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_random_crop": [[119, 165], ["dict", "mmcv.imread", "test_transform.test_random_crop.create_random_bboxes"], "function", ["None"], ["", "def", "test_random_crop", "(", ")", ":", "\n", "# test assertion for invalid random crop", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'RandomCrop'", ",", "crop_size", "=", "(", "-", "1", ",", "0", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# TODO: add img_fields test", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", ",", "'gt_bboxes_ignore'", "]", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "\n", "def", "create_random_bboxes", "(", "num_bboxes", ",", "img_w", ",", "img_h", ")", ":", "\n", "        ", "bboxes_left_top", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "0.5", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes_right_bottom", "=", "np", ".", "random", ".", "uniform", "(", "0.5", ",", "1", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes", "=", "np", ".", "concatenate", "(", "(", "bboxes_left_top", ",", "bboxes_right_bottom", ")", ",", "1", ")", "\n", "bboxes", "=", "(", "bboxes", "*", "np", ".", "array", "(", "[", "img_w", ",", "img_h", ",", "img_w", ",", "img_h", "]", ")", ")", ".", "astype", "(", "\n", "np", ".", "int", ")", "\n", "return", "bboxes", "\n", "\n", "", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "gt_bboxes", "=", "create_random_bboxes", "(", "8", ",", "w", ",", "h", ")", "\n", "gt_bboxes_ignore", "=", "create_random_bboxes", "(", "2", ",", "w", ",", "h", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "gt_bboxes", "\n", "results", "[", "'gt_bboxes_ignore'", "]", "=", "gt_bboxes_ignore", "\n", "transform", "=", "dict", "(", "type", "=", "'RandomCrop'", ",", "crop_size", "=", "(", "h", "-", "20", ",", "w", "-", "20", ")", ")", "\n", "crop_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "crop_module", "(", "results", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "[", ":", "2", "]", "==", "(", "h", "-", "20", ",", "w", "-", "20", ")", "\n", "# All bboxes should be reserved after crop", "\n", "assert", "results", "[", "'img_shape'", "]", "[", ":", "2", "]", "==", "(", "h", "-", "20", ",", "w", "-", "20", ")", "\n", "assert", "results", "[", "'gt_bboxes'", "]", ".", "shape", "[", "0", "]", "==", "8", "\n", "assert", "results", "[", "'gt_bboxes_ignore'", "]", ".", "shape", "[", "0", "]", "==", "2", "\n", "\n", "def", "area", "(", "bboxes", ")", ":", "\n", "        ", "return", "np", ".", "prod", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "-", "bboxes", "[", ":", ",", "0", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "assert", "(", "area", "(", "results", "[", "'gt_bboxes'", "]", ")", "<=", "area", "(", "gt_bboxes", ")", ")", ".", "all", "(", ")", "\n", "assert", "(", "area", "(", "results", "[", "'gt_bboxes_ignore'", "]", ")", "<=", "area", "(", "gt_bboxes_ignore", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_min_iou_random_crop": [[167, 215], ["dict", "mmcv.imread", "test_transform.test_random_crop.create_random_bboxes"], "function", ["None"], ["", "def", "test_min_iou_random_crop", "(", ")", ":", "\n", "\n", "    ", "def", "create_random_bboxes", "(", "num_bboxes", ",", "img_w", ",", "img_h", ")", ":", "\n", "        ", "bboxes_left_top", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "0.5", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes_right_bottom", "=", "np", ".", "random", ".", "uniform", "(", "0.5", ",", "1", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes", "=", "np", ".", "concatenate", "(", "(", "bboxes_left_top", ",", "bboxes_right_bottom", ")", ",", "1", ")", "\n", "bboxes", "=", "(", "bboxes", "*", "np", ".", "array", "(", "[", "img_w", ",", "img_h", ",", "img_w", ",", "img_h", "]", ")", ")", ".", "astype", "(", "\n", "np", ".", "int", ")", "\n", "return", "bboxes", "\n", "\n", "", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'gt_bboxes'", ",", "'gt_bboxes_ignore'", "]", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "gt_bboxes", "=", "create_random_bboxes", "(", "1", ",", "w", ",", "h", ")", "\n", "gt_bboxes_ignore", "=", "create_random_bboxes", "(", "1", ",", "w", ",", "h", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "gt_bboxes", "\n", "results", "[", "'gt_bboxes_ignore'", "]", "=", "gt_bboxes_ignore", "\n", "transform", "=", "dict", "(", "type", "=", "'MinIoURandomCrop'", ")", "\n", "crop_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# Test for img_fields", "\n", "results_test", "=", "copy", ".", "deepcopy", "(", "results", ")", "\n", "results_test", "[", "'img1'", "]", "=", "results_test", "[", "'img'", "]", "\n", "results_test", "[", "'img_fields'", "]", "=", "[", "'img'", ",", "'img1'", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "crop_module", "(", "results_test", ")", "\n", "", "results", "=", "crop_module", "(", "results", ")", "\n", "patch", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "results", "[", "'img_shape'", "]", "[", "1", "]", ",", "results", "[", "'img_shape'", "]", "[", "0", "]", "]", ")", "\n", "ious", "=", "bbox_overlaps", "(", "patch", ".", "reshape", "(", "-", "1", ",", "4", ")", ",", "\n", "results", "[", "'gt_bboxes'", "]", ")", ".", "reshape", "(", "-", "1", ")", "\n", "ious_ignore", "=", "bbox_overlaps", "(", "\n", "patch", ".", "reshape", "(", "-", "1", ",", "4", ")", ",", "results", "[", "'gt_bboxes_ignore'", "]", ")", ".", "reshape", "(", "-", "1", ")", "\n", "mode", "=", "crop_module", ".", "mode", "\n", "if", "mode", "==", "1", ":", "\n", "        ", "assert", "np", ".", "equal", "(", "results", "[", "'gt_bboxes'", "]", ",", "gt_bboxes", ")", ".", "all", "(", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'gt_bboxes_ignore'", "]", ",", "gt_bboxes_ignore", ")", ".", "all", "(", ")", "\n", "", "else", ":", "\n", "        ", "assert", "(", "ious", ">=", "mode", ")", ".", "all", "(", ")", "\n", "assert", "(", "ious_ignore", ">=", "mode", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_pad": [[217, 255], ["dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.imread", "copy.deepcopy", "copy.deepcopy", "dict.", "numpy.equal().all", "numpy.equal().all", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "dict.", "numpy.equal().all", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "os.join", "os.dirname", "numpy.equal", "numpy.equal", "numpy.equal"], "function", ["None"], ["", "", "def", "test_pad", "(", ")", ":", "\n", "# test assertion if both size_divisor and size is None", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'Pad'", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "transform", "=", "dict", "(", "type", "=", "'Pad'", ",", "size_divisor", "=", "32", ")", "\n", "transform", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "original_img", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img2'", "]", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", ",", "'img2'", "]", "\n", "\n", "results", "=", "transform", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "# original img already divisible by 32", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "original_img", ")", ".", "all", "(", ")", "\n", "img_shape", "=", "results", "[", "'img'", "]", ".", "shape", "\n", "assert", "img_shape", "[", "0", "]", "%", "32", "==", "0", "\n", "assert", "img_shape", "[", "1", "]", "%", "32", "==", "0", "\n", "\n", "resize_transform", "=", "dict", "(", "\n", "type", "=", "'Resize'", ",", "img_scale", "=", "(", "1333", ",", "800", ")", ",", "keep_ratio", "=", "True", ")", "\n", "resize_module", "=", "build_from_cfg", "(", "resize_transform", ",", "PIPELINES", ")", "\n", "results", "=", "resize_module", "(", "results", ")", "\n", "results", "=", "transform", "(", "results", ")", "\n", "img_shape", "=", "results", "[", "'img'", "]", ".", "shape", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "assert", "img_shape", "[", "0", "]", "%", "32", "==", "0", "\n", "assert", "img_shape", "[", "1", "]", "%", "32", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_normalize": [[257, 284], ["dict", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.imread", "copy.deepcopy", "copy.deepcopy", "mmcv.utils.build_from_cfg.", "numpy.equal().all", "numpy.array", "numpy.array", "numpy.allclose", "os.join", "os.dirname", "numpy.equal"], "function", ["None"], ["", "def", "test_normalize", "(", ")", ":", "\n", "    ", "img_norm_cfg", "=", "dict", "(", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ")", "\n", "transform", "=", "dict", "(", "type", "=", "'Normalize'", ",", "**", "img_norm_cfg", ")", "\n", "transform", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "original_img", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img2'", "]", "=", "copy", ".", "deepcopy", "(", "img", ")", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'scale_factor'", "]", "=", "1.0", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", ",", "'img2'", "]", "\n", "\n", "results", "=", "transform", "(", "results", ")", "\n", "assert", "np", ".", "equal", "(", "results", "[", "'img'", "]", ",", "results", "[", "'img2'", "]", ")", ".", "all", "(", ")", "\n", "\n", "mean", "=", "np", ".", "array", "(", "img_norm_cfg", "[", "'mean'", "]", ")", "\n", "std", "=", "np", ".", "array", "(", "img_norm_cfg", "[", "'std'", "]", ")", "\n", "converted_img", "=", "(", "original_img", "[", "...", ",", ":", ":", "-", "1", "]", "-", "mean", ")", "/", "std", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ",", "converted_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_albu_transform": [[286, 308], ["dict", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "os.join", "dict", "os.dirname", "dict"], "function", ["None"], ["", "def", "test_albu_transform", "(", ")", ":", "\n", "    ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "\n", "# Define simple pipeline", "\n", "load", "=", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", "\n", "load", "=", "build_from_cfg", "(", "load", ",", "PIPELINES", ")", "\n", "\n", "albu_transform", "=", "dict", "(", "\n", "type", "=", "'Albu'", ",", "transforms", "=", "[", "dict", "(", "type", "=", "'ChannelShuffle'", ",", "p", "=", "1", ")", "]", ")", "\n", "albu_transform", "=", "build_from_cfg", "(", "albu_transform", ",", "PIPELINES", ")", "\n", "\n", "normalize", "=", "dict", "(", "type", "=", "'Normalize'", ",", "mean", "=", "[", "0", "]", "*", "3", ",", "std", "=", "[", "0", "]", "*", "3", ",", "to_rgb", "=", "True", ")", "\n", "normalize", "=", "build_from_cfg", "(", "normalize", ",", "PIPELINES", ")", "\n", "\n", "# Execute transforms", "\n", "results", "=", "load", "(", "results", ")", "\n", "results", "=", "albu_transform", "(", "results", ")", "\n", "results", "=", "normalize", "(", "results", ")", "\n", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "float32", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_random_center_crop_pad": [[310, 454], ["dict", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "copy.deepcopy", "test_transform.test_random_crop.create_random_bboxes"], "function", ["None"], ["", "def", "test_random_center_crop_pad", "(", ")", ":", "\n", "# test assertion for invalid crop_size while test_mode=False", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "(", "-", "1", ",", "0", ")", ",", "\n", "test_mode", "=", "False", ",", "\n", "test_pad_mode", "=", "None", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid ratios while test_mode=False", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "(", "511", ",", "511", ")", ",", "\n", "ratios", "=", "(", "1.0", ")", ",", "\n", "test_mode", "=", "False", ",", "\n", "test_pad_mode", "=", "None", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid mean, std and to_rgb", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "(", "511", ",", "511", ")", ",", "\n", "mean", "=", "None", ",", "\n", "std", "=", "None", ",", "\n", "to_rgb", "=", "None", ",", "\n", "test_mode", "=", "False", ",", "\n", "test_pad_mode", "=", "None", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid crop_size while test_mode=True", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "(", "511", ",", "511", ")", ",", "\n", "ratios", "=", "None", ",", "\n", "border", "=", "None", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "True", ",", "\n", "test_pad_mode", "=", "(", "'logical_or'", ",", "127", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid ratios while test_mode=True", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "None", ",", "\n", "ratios", "=", "(", "0.9", ",", "1.0", ",", "1.1", ")", ",", "\n", "border", "=", "None", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "True", ",", "\n", "test_pad_mode", "=", "(", "'logical_or'", ",", "127", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid border while test_mode=True", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "None", ",", "\n", "ratios", "=", "None", ",", "\n", "border", "=", "128", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "True", ",", "\n", "test_pad_mode", "=", "(", "'logical_or'", ",", "127", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion for invalid test_pad_mode while test_mode=True", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "None", ",", "\n", "ratios", "=", "None", ",", "\n", "border", "=", "None", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "True", ",", "\n", "test_pad_mode", "=", "(", "'do_nothing'", ",", "100", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "\n", "load", "=", "dict", "(", "type", "=", "'LoadImageFromFile'", ",", "to_float32", "=", "True", ")", "\n", "load", "=", "build_from_cfg", "(", "load", ",", "PIPELINES", ")", "\n", "results", "=", "load", "(", "results", ")", "\n", "test_results", "=", "copy", ".", "deepcopy", "(", "results", ")", "\n", "\n", "def", "create_random_bboxes", "(", "num_bboxes", ",", "img_w", ",", "img_h", ")", ":", "\n", "        ", "bboxes_left_top", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "0.5", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes_right_bottom", "=", "np", ".", "random", ".", "uniform", "(", "0.5", ",", "1", ",", "size", "=", "(", "num_bboxes", ",", "2", ")", ")", "\n", "bboxes", "=", "np", ".", "concatenate", "(", "(", "bboxes_left_top", ",", "bboxes_right_bottom", ")", ",", "1", ")", "\n", "bboxes", "=", "(", "bboxes", "*", "np", ".", "array", "(", "[", "img_w", ",", "img_h", ",", "img_w", ",", "img_h", "]", ")", ")", ".", "astype", "(", "\n", "np", ".", "int", ")", "\n", "return", "bboxes", "\n", "\n", "", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "gt_bboxes", "=", "create_random_bboxes", "(", "8", ",", "w", ",", "h", ")", "\n", "gt_bboxes_ignore", "=", "create_random_bboxes", "(", "2", ",", "w", ",", "h", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "gt_bboxes", "\n", "results", "[", "'gt_bboxes_ignore'", "]", "=", "gt_bboxes_ignore", "\n", "train_transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "(", "h", "-", "20", ",", "w", "-", "20", ")", ",", "\n", "ratios", "=", "(", "1.0", ",", ")", ",", "\n", "border", "=", "128", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "False", ",", "\n", "test_pad_mode", "=", "None", ")", "\n", "crop_module", "=", "build_from_cfg", "(", "train_transform", ",", "PIPELINES", ")", "\n", "train_results", "=", "crop_module", "(", "results", ")", "\n", "assert", "train_results", "[", "'img'", "]", ".", "shape", "[", ":", "2", "]", "==", "(", "h", "-", "20", ",", "w", "-", "20", ")", "\n", "# All bboxes should be reserved after crop", "\n", "assert", "train_results", "[", "'pad_shape'", "]", "[", ":", "2", "]", "==", "(", "h", "-", "20", ",", "w", "-", "20", ")", "\n", "assert", "train_results", "[", "'gt_bboxes'", "]", ".", "shape", "[", "0", "]", "==", "8", "\n", "assert", "train_results", "[", "'gt_bboxes_ignore'", "]", ".", "shape", "[", "0", "]", "==", "2", "\n", "\n", "test_transform", "=", "dict", "(", "\n", "type", "=", "'RandomCenterCropPad'", ",", "\n", "crop_size", "=", "None", ",", "\n", "ratios", "=", "None", ",", "\n", "border", "=", "None", ",", "\n", "mean", "=", "[", "123.675", ",", "116.28", ",", "103.53", "]", ",", "\n", "std", "=", "[", "58.395", ",", "57.12", ",", "57.375", "]", ",", "\n", "to_rgb", "=", "True", ",", "\n", "test_mode", "=", "True", ",", "\n", "test_pad_mode", "=", "(", "'logical_or'", ",", "127", ")", ")", "\n", "crop_module", "=", "build_from_cfg", "(", "test_transform", ",", "PIPELINES", ")", "\n", "\n", "test_results", "=", "crop_module", "(", "test_results", ")", "\n", "assert", "test_results", "[", "'img'", "]", ".", "shape", "[", ":", "2", "]", "==", "(", "h", "|", "127", ",", "w", "|", "127", ")", "\n", "assert", "test_results", "[", "'pad_shape'", "]", "[", ":", "2", "]", "==", "(", "h", "|", "127", ",", "w", "|", "127", ")", "\n", "assert", "'border'", "in", "test_results", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_multi_scale_flip_aug": [[456, 547], ["dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.imread", "dict.", "dict", "mmcv.utils.build_from_cfg", "dict.", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg", "dict.", "isinstance", "isinstance", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "os.join", "copy.deepcopy", "len", "copy.deepcopy", "len", "mmcv.Config.fromfile", "mmcv.utils.build_from_cfg.", "len", "len", "[].data[].tolist", "os.dirname", "os.join", "dict", "dict", "dict", "os.dirname", "dict", "dict", "dict", "dict"], "function", ["None"], ["", "def", "test_multi_scale_flip_aug", "(", ")", ":", "\n", "# test assertion if give both scale_factor and img_scale", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "scale_factor", "=", "1.0", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", "]", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ")", "]", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion if both scale_factor and img_scale are None", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "scale_factor", "=", "None", ",", "\n", "img_scale", "=", "None", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ")", "]", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion if img_scale is not tuple or list of tuple", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "img_scale", "=", "[", "1333", ",", "800", "]", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ")", "]", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "# test assertion if flip_direction is not str or list of str", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", "]", ",", "\n", "flip_direction", "=", "1", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ")", "]", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "scale_transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", ",", "(", "1333", ",", "640", ")", "]", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ",", "keep_ratio", "=", "True", ")", "]", ")", "\n", "transform", "=", "build_from_cfg", "(", "scale_transform", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "# Set initial values for default meta_keys", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "\n", "scale_results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "len", "(", "scale_results", "[", "'img'", "]", ")", "==", "2", "\n", "assert", "scale_results", "[", "'img'", "]", "[", "0", "]", ".", "shape", "==", "(", "750", ",", "1333", ",", "3", ")", "\n", "assert", "scale_results", "[", "'img_shape'", "]", "[", "0", "]", "==", "(", "750", ",", "1333", ",", "3", ")", "\n", "assert", "scale_results", "[", "'img'", "]", "[", "1", "]", ".", "shape", "==", "(", "640", ",", "1138", ",", "3", ")", "\n", "assert", "scale_results", "[", "'img_shape'", "]", "[", "1", "]", "==", "(", "640", ",", "1138", ",", "3", ")", "\n", "\n", "scale_factor_transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "scale_factor", "=", "[", "0.8", ",", "1.0", ",", "1.2", "]", ",", "\n", "transforms", "=", "[", "dict", "(", "type", "=", "'Resize'", ",", "keep_ratio", "=", "False", ")", "]", ")", "\n", "transform", "=", "build_from_cfg", "(", "scale_factor_transform", ",", "PIPELINES", ")", "\n", "scale_factor_results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "len", "(", "scale_factor_results", "[", "'img'", "]", ")", "==", "3", "\n", "assert", "scale_factor_results", "[", "'img'", "]", "[", "0", "]", ".", "shape", "==", "(", "230", ",", "409", ",", "3", ")", "\n", "assert", "scale_factor_results", "[", "'img_shape'", "]", "[", "0", "]", "==", "(", "230", ",", "409", ",", "3", ")", "\n", "assert", "scale_factor_results", "[", "'img'", "]", "[", "1", "]", ".", "shape", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "scale_factor_results", "[", "'img_shape'", "]", "[", "1", "]", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "scale_factor_results", "[", "'img'", "]", "[", "2", "]", ".", "shape", "==", "(", "345", ",", "614", ",", "3", ")", "\n", "assert", "scale_factor_results", "[", "'img_shape'", "]", "[", "2", "]", "==", "(", "345", ",", "614", ",", "3", ")", "\n", "\n", "# test pipeline of coco_detection", "\n", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "load_cfg", ",", "multi_scale_cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "\n", "'configs/_base_/datasets/coco_detection.py'", ")", ".", "test_pipeline", "\n", "load", "=", "build_from_cfg", "(", "load_cfg", ",", "PIPELINES", ")", "\n", "transform", "=", "build_from_cfg", "(", "multi_scale_cfg", ",", "PIPELINES", ")", "\n", "results", "=", "transform", "(", "load", "(", "results", ")", ")", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "1", "\n", "assert", "len", "(", "results", "[", "'img_metas'", "]", ")", "==", "1", "\n", "assert", "isinstance", "(", "results", "[", "'img'", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "results", "[", "'img_metas'", "]", "[", "0", "]", ",", "mmcv", ".", "parallel", ".", "DataContainer", ")", "\n", "assert", "results", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "'ori_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "results", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "'img_shape'", "]", "==", "(", "750", ",", "1333", ",", "3", ")", "\n", "assert", "results", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "'pad_shape'", "]", "==", "(", "768", ",", "1344", ",", "3", ")", "\n", "assert", "results", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "'scale_factor'", "]", ".", "tolist", "(", ")", "==", "[", "\n", "2.603515625", ",", "2.6041667461395264", ",", "2.603515625", ",", "2.6041667461395264", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_transform.test_cutout": [[550, 614], ["dict", "mmcv.imread", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "pytest.raises", "dict", "mmcv.utils.build_from_cfg", "os.join", "copy.deepcopy", "cutout_result[].sum", "mmcv.imread.sum", "copy.deepcopy", "cutout_result[].sum", "mmcv.imread.sum", "copy.deepcopy", "cutout_result[].sum", "mmcv.imread.sum", "copy.deepcopy", "cutout_result[].sum", "mmcv.imread.sum", "os.dirname"], "function", ["None"], ["", "def", "test_cutout", "(", ")", ":", "\n", "# test n_holes", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "(", "5", ",", "3", ")", ",", "cutout_shape", "=", "(", "8", ",", "8", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "(", "3", ",", "4", ",", "5", ")", ",", "cutout_shape", "=", "(", "8", ",", "8", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "# test cutout_shape and cutout_ratio", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "1", ",", "cutout_shape", "=", "8", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "1", ",", "cutout_ratio", "=", "0.2", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "# either of cutout_shape and cutout_ratio should be given", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "1", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transform", "=", "dict", "(", "\n", "type", "=", "'CutOut'", ",", "\n", "n_holes", "=", "1", ",", "\n", "cutout_shape", "=", "(", "2", ",", "2", ")", ",", "\n", "cutout_ratio", "=", "(", "0.4", ",", "0.4", ")", ")", "\n", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "", "results", "=", "dict", "(", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data/color.jpg'", ")", ",", "'color'", ")", "\n", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'pad_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "\n", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "1", ",", "cutout_shape", "=", "(", "10", ",", "10", ")", ")", "\n", "cutout_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "cutout_result", "=", "cutout_module", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "cutout_result", "[", "'img'", "]", ".", "sum", "(", ")", "<", "img", ".", "sum", "(", ")", "\n", "\n", "transform", "=", "dict", "(", "type", "=", "'CutOut'", ",", "n_holes", "=", "1", ",", "cutout_ratio", "=", "(", "0.8", ",", "0.8", ")", ")", "\n", "cutout_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "cutout_result", "=", "cutout_module", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "cutout_result", "[", "'img'", "]", ".", "sum", "(", ")", "<", "img", ".", "sum", "(", ")", "\n", "\n", "transform", "=", "dict", "(", "\n", "type", "=", "'CutOut'", ",", "\n", "n_holes", "=", "(", "2", ",", "4", ")", ",", "\n", "cutout_shape", "=", "[", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", "]", ",", "\n", "fill_in", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "cutout_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "cutout_result", "=", "cutout_module", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "cutout_result", "[", "'img'", "]", ".", "sum", "(", ")", ">", "img", ".", "sum", "(", ")", "\n", "\n", "transform", "=", "dict", "(", "\n", "type", "=", "'CutOut'", ",", "\n", "n_holes", "=", "1", ",", "\n", "cutout_ratio", "=", "(", "0.8", ",", "0.8", ")", ",", "\n", "fill_in", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "cutout_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "cutout_result", "=", "cutout_module", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "cutout_result", "[", "'img'", "]", ".", "sum", "(", ")", ">", "img", ".", "sum", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_loading.TestLoading.setup_class": [[12, 15], ["os.join", "os.dirname"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "setup_class", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "data_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_loading.TestLoading.test_load_img": [[16, 57], ["dict", "mmdet.datasets.pipelines.LoadImageFromFile", "mmdet.datasets.pipelines.LoadImageFromFile.", "dict", "mmdet.datasets.pipelines.LoadImageFromFile", "mmdet.datasets.pipelines.LoadImageFromFile.", "mmdet.datasets.pipelines.LoadImageFromFile", "mmdet.datasets.pipelines.LoadImageFromFile.", "dict", "mmdet.datasets.pipelines.LoadImageFromFile", "mmdet.datasets.pipelines.LoadImageFromFile.", "mmdet.datasets.pipelines.LoadImageFromFile", "mmdet.datasets.pipelines.LoadImageFromFile.", "copy.deepcopy", "os.join", "repr", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "dict", "dict", "dict"], "methods", ["None"], ["", "def", "test_load_img", "(", "self", ")", ":", "\n", "        ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "self", ".", "data_prefix", ",", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "transform", "=", "LoadImageFromFile", "(", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'filename'", "]", "==", "osp", ".", "join", "(", "self", ".", "data_prefix", ",", "'color.jpg'", ")", "\n", "assert", "results", "[", "'ori_filename'", "]", "==", "'color.jpg'", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "uint8", "\n", "assert", "results", "[", "'img_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "results", "[", "'ori_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "repr", "(", "transform", ")", "==", "transform", ".", "__class__", ".", "__name__", "+", "\"(to_float32=False, color_type='color', \"", "+", "\"file_client_args={'backend': 'disk'})\"", "\n", "\n", "# no img_prefix", "\n", "results", "=", "dict", "(", "\n", "img_prefix", "=", "None", ",", "img_info", "=", "dict", "(", "filename", "=", "'tests/data/color.jpg'", ")", ")", "\n", "transform", "=", "LoadImageFromFile", "(", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'filename'", "]", "==", "'tests/data/color.jpg'", "\n", "assert", "results", "[", "'ori_filename'", "]", "==", "'tests/data/color.jpg'", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "\n", "# to_float32", "\n", "transform", "=", "LoadImageFromFile", "(", "to_float32", "=", "True", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "float32", "\n", "\n", "# gray image", "\n", "results", "=", "dict", "(", "\n", "img_prefix", "=", "self", ".", "data_prefix", ",", "img_info", "=", "dict", "(", "filename", "=", "'gray.jpg'", ")", ")", "\n", "transform", "=", "LoadImageFromFile", "(", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "288", ",", "512", ",", "3", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "uint8", "\n", "\n", "transform", "=", "LoadImageFromFile", "(", "color_type", "=", "'unchanged'", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "288", ",", "512", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "uint8", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_loading.TestLoading.test_load_multi_channel_img": [[58, 78], ["dict", "mmdet.datasets.pipelines.LoadMultiChannelImageFromFiles", "mmdet.datasets.pipelines.LoadMultiChannelImageFromFiles.", "copy.deepcopy", "repr", "dict", "os.join", "os.join"], "methods", ["None"], ["", "def", "test_load_multi_channel_img", "(", "self", ")", ":", "\n", "        ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "self", ".", "data_prefix", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "[", "'color.jpg'", ",", "'color.jpg'", "]", ")", ")", "\n", "transform", "=", "LoadMultiChannelImageFromFiles", "(", ")", "\n", "results", "=", "transform", "(", "copy", ".", "deepcopy", "(", "results", ")", ")", "\n", "assert", "results", "[", "'filename'", "]", "==", "[", "\n", "osp", ".", "join", "(", "self", ".", "data_prefix", ",", "'color.jpg'", ")", ",", "\n", "osp", ".", "join", "(", "self", ".", "data_prefix", ",", "'color.jpg'", ")", "\n", "]", "\n", "assert", "results", "[", "'ori_filename'", "]", "==", "[", "'color.jpg'", ",", "'color.jpg'", "]", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "288", ",", "512", ",", "3", ",", "2", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "np", ".", "uint8", "\n", "assert", "results", "[", "'img_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ",", "2", ")", "\n", "assert", "results", "[", "'ori_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ",", "2", ")", "\n", "assert", "results", "[", "'pad_shape'", "]", "==", "(", "288", ",", "512", ",", "3", ",", "2", ")", "\n", "assert", "results", "[", "'scale_factor'", "]", "==", "1.0", "\n", "assert", "repr", "(", "transform", ")", "==", "transform", ".", "__class__", ".", "__name__", "+", "\"(to_float32=False, color_type='unchanged', \"", "+", "\"file_client_args={'backend': 'disk'})\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_random_sampler": [[8, 42], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.Tensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.RandomSampler", "mmdet.core.bbox.samplers.RandomSampler.sample", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["def", "test_random_sampler", "(", ")", ":", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "30", ",", "30", ",", "40", ",", "40", "]", ",", "\n", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "sampler", "=", "RandomSampler", "(", "\n", "num", "=", "10", ",", "pos_fraction", "=", "0.5", ",", "neg_pos_ub", "=", "-", "1", ",", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_random_sampler_empty_gt": [[44, 68], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.empty", "torch.empty().long", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.RandomSampler", "mmdet.core.bbox.samplers.RandomSampler.sample", "len", "len", "len", "len", "torch.empty"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "test_random_sampler_empty_gt", "(", ")", ":", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_labels", "=", "torch", ".", "empty", "(", "0", ",", ")", ".", "long", "(", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "sampler", "=", "RandomSampler", "(", "\n", "num", "=", "10", ",", "pos_fraction", "=", "0.5", ",", "neg_pos_ub", "=", "-", "1", ",", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_random_sampler_empty_pred": [[70, 92], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.empty", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.RandomSampler", "mmdet.core.bbox.samplers.RandomSampler.sample", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "test_random_sampler_empty_pred", "(", ")", ":", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "bboxes", ",", "gt_bboxes", ",", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "sampler", "=", "RandomSampler", "(", "\n", "num", "=", "10", ",", "pos_fraction", "=", "0.5", ",", "neg_pos_ub", "=", "-", "1", ",", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler._context_for_ohem": [[94, 108], ["sys.path.insert", "_get_detector_cfg", "dirname", "build_detector", "dirname", "dirname"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_models.test_forward._get_detector_cfg", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector"], ["", "def", "_context_for_ohem", "(", ")", ":", "\n", "    ", "import", "sys", "\n", "from", "os", ".", "path", "import", "dirname", "\n", "sys", ".", "path", ".", "insert", "(", "0", ",", "dirname", "(", "dirname", "(", "dirname", "(", "__file__", ")", ")", ")", ")", "\n", "from", "test_forward", "import", "_get_detector_cfg", "\n", "\n", "model", ",", "train_cfg", ",", "test_cfg", "=", "_get_detector_cfg", "(", "\n", "'faster_rcnn/faster_rcnn_r50_fpn_ohem_1x_coco.py'", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmdet", ".", "models", "import", "build_detector", "\n", "context", "=", "build_detector", "(", "\n", "model", ",", "train_cfg", "=", "train_cfg", ",", "test_cfg", "=", "test_cfg", ")", ".", "roi_head", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_ohem_sampler": [[110, 153], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.Tensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "test_sampler._context_for_ohem", "mmdet.core.bbox.samplers.OHEMSampler", "mmdet.core.bbox.samplers.OHEMSampler.sample", "torch.rand", "len", "len", "len", "len", "int", "int"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler._context_for_ohem", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "test_ohem_sampler", "(", ")", ":", "\n", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "9", "]", ",", "\n", "[", "0", ",", "10", ",", "10", ",", "19", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "30", ",", "30", ",", "40", ",", "40", "]", ",", "\n", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "context", "=", "_context_for_ohem", "(", ")", "\n", "\n", "sampler", "=", "OHEMSampler", "(", "\n", "num", "=", "10", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "context", "=", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "feats", "=", "[", "torch", ".", "rand", "(", "1", ",", "256", ",", "int", "(", "2", "**", "i", ")", ",", "int", "(", "2", "**", "i", ")", ")", "for", "i", "in", "[", "6", ",", "5", ",", "4", ",", "3", ",", "2", "]", "]", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_ohem_sampler_empty_gt": [[155, 194], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.FloatTensor", "torch.empty", "torch.LongTensor", "torch.Tensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "test_sampler._context_for_ohem", "mmdet.core.bbox.samplers.OHEMSampler", "mmdet.core.bbox.samplers.OHEMSampler.sample", "torch.rand", "len", "len", "len", "len", "int", "int"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler._context_for_ohem", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "test_ohem_sampler_empty_gt", "(", ")", ":", "\n", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "context", "=", "_context_for_ohem", "(", ")", "\n", "\n", "sampler", "=", "OHEMSampler", "(", "\n", "num", "=", "10", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "context", "=", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "feats", "=", "[", "torch", ".", "rand", "(", "1", ",", "256", ",", "int", "(", "2", "**", "i", ")", ",", "int", "(", "2", "**", "i", ")", ")", "for", "i", "in", "[", "6", ",", "5", ",", "4", ",", "3", ",", "2", "]", "]", "\n", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_ohem_sampler_empty_pred": [[196, 234], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "torch.empty", "torch.FloatTensor", "torch.LongTensor", "torch.Tensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "test_sampler._context_for_ohem", "mmdet.core.bbox.samplers.OHEMSampler", "mmdet.core.bbox.samplers.OHEMSampler.sample", "torch.rand", "len", "len", "len", "len", "int", "int"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler._context_for_ohem", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "def", "test_ohem_sampler_empty_pred", "(", ")", ":", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "2", ",", "3", "]", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "\n", "context", "=", "_context_for_ohem", "(", ")", "\n", "\n", "sampler", "=", "OHEMSampler", "(", "\n", "num", "=", "10", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "context", "=", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ")", "\n", "\n", "feats", "=", "[", "torch", ".", "rand", "(", "1", ",", "256", ",", "int", "(", "2", "**", "i", ")", ",", "int", "(", "2", "**", "i", ")", ")", "for", "i", "in", "[", "6", ",", "5", ",", "4", ",", "3", ",", "2", "]", "]", "\n", "\n", "sample_result", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_random_sample_result": [[236, 248], ["SamplingResult.random", "SamplingResult.random", "SamplingResult.random", "SamplingResult.random", "SamplingResult.random", "SamplingResult.random", "SamplingResult.random", "range", "SamplingResult.random"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.assign_result.AssignResult.random"], ["", "def", "test_random_sample_result", "(", ")", ":", "\n", "    ", "from", "mmdet", ".", "core", ".", "bbox", ".", "samplers", ".", "sampling_result", "import", "SamplingResult", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "0", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "3", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "3", ",", "num_preds", "=", "3", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "0", ",", "num_preds", "=", "3", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "7", ",", "num_preds", "=", "7", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "7", ",", "num_preds", "=", "64", ")", "\n", "SamplingResult", ".", "random", "(", "num_gts", "=", "24", ",", "num_preds", "=", "3", ")", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "SamplingResult", ".", "random", "(", "rng", "=", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler.test_score_hlr_sampler_empty_pred": [[250, 330], ["mmdet.core.bbox.assigners.MaxIoUAssigner", "test_sampler._context_for_ohem", "mmdet.core.bbox.samplers.ScoreHLRSampler", "torch.Tensor", "torch.empty", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.ScoreHLRSampler.sample", "torch.FloatTensor", "torch.empty", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.ScoreHLRSampler.sample", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "mmdet.core.bbox.assigners.MaxIoUAssigner.assign", "mmdet.core.bbox.samplers.ScoreHLRSampler.sample", "torch.rand", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "int", "int"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_sampler._context_for_ohem", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.assigners.atss_assigner.ATSSAssigner.assign", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "", "def", "test_score_hlr_sampler_empty_pred", "(", ")", ":", "\n", "    ", "assigner", "=", "MaxIoUAssigner", "(", "\n", "pos_iou_thr", "=", "0.5", ",", "\n", "neg_iou_thr", "=", "0.5", ",", "\n", "ignore_iof_thr", "=", "0.5", ",", "\n", "ignore_wrt_candidates", "=", "False", ",", "\n", ")", "\n", "context", "=", "_context_for_ohem", "(", ")", "\n", "sampler", "=", "ScoreHLRSampler", "(", "\n", "num", "=", "10", ",", "\n", "pos_fraction", "=", "0.5", ",", "\n", "context", "=", "context", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ")", "\n", "gt_bboxes_ignore", "=", "torch", ".", "Tensor", "(", "[", "]", ")", "\n", "feats", "=", "[", "torch", ".", "rand", "(", "1", ",", "256", ",", "int", "(", "2", "**", "i", ")", ",", "int", "(", "2", "**", "i", ")", ")", "for", "i", "in", "[", "6", ",", "5", ",", "4", ",", "3", ",", "2", "]", "]", "\n", "\n", "# empty bbox", "\n", "bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "2", ",", "3", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "sample_result", ",", "_", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_inds", ")", "==", "0", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n", "# empty gt", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "sample_result", ",", "_", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "assert", "len", "(", "sample_result", ".", "pos_inds", ")", "==", "0", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "\n", "# non-empty input", "\n", "bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_bboxes", "=", "torch", ".", "FloatTensor", "(", "[", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "\n", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "\n", "[", "5", ",", "5", ",", "15", ",", "15", "]", ",", "\n", "[", "32", ",", "32", ",", "38", ",", "42", "]", ",", "\n", "]", ")", "\n", "gt_labels", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "2", ",", "3", "]", ")", "\n", "assign_result", "=", "assigner", ".", "assign", "(", "\n", "bboxes", ",", "\n", "gt_bboxes", ",", "\n", "gt_bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "sample_result", ",", "_", "=", "sampler", ".", "sample", "(", "\n", "assign_result", ",", "bboxes", ",", "gt_bboxes", ",", "gt_labels", ",", "feats", "=", "feats", ")", "\n", "assert", "len", "(", "sample_result", ".", "pos_bboxes", ")", "==", "len", "(", "sample_result", ".", "pos_inds", ")", "\n", "assert", "len", "(", "sample_result", ".", "neg_bboxes", ")", "==", "len", "(", "sample_result", ".", "neg_inds", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.model_aug_test_template": [[12, 41], ["mmcv.Config.fromfile", "mmdet.models.build_detector", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg.", "mmdet.models.build_detector.eval", "mmcv.utils.build_from_cfg.", "len", "len", "mmcv.parallel.collate", "torch.no_grad", "mmdet.models.build_detector.", "os.join", "dict", "os.dirname", "mmcv.parallel.collate"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector"], ["def", "model_aug_test_template", "(", "cfg_file", ")", ":", "\n", "# get config", "\n", "    ", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "cfg_file", ")", "\n", "# init model", "\n", "cfg", ".", "model", ".", "pretrained", "=", "None", "\n", "model", "=", "build_detector", "(", "cfg", ".", "model", ",", "train_cfg", "=", "None", ",", "test_cfg", "=", "cfg", ".", "test_cfg", ")", "\n", "\n", "# init test pipeline and set aug test", "\n", "load_cfg", ",", "multi_scale_cfg", "=", "cfg", ".", "test_pipeline", "\n", "multi_scale_cfg", "[", "'flip'", "]", "=", "True", "\n", "multi_scale_cfg", "[", "'img_scale'", "]", "=", "[", "(", "1333", ",", "800", ")", ",", "(", "800", ",", "600", ")", ",", "(", "640", ",", "480", ")", "]", "\n", "\n", "load", "=", "build_from_cfg", "(", "load_cfg", ",", "PIPELINES", ")", "\n", "transform", "=", "build_from_cfg", "(", "multi_scale_cfg", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "results", "=", "transform", "(", "load", "(", "results", ")", ")", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "6", "\n", "assert", "len", "(", "results", "[", "'img_metas'", "]", ")", "==", "6", "\n", "\n", "results", "[", "'img'", "]", "=", "[", "collate", "(", "[", "x", "]", ")", "for", "x", "in", "results", "[", "'img'", "]", "]", "\n", "results", "[", "'img_metas'", "]", "=", "[", "collate", "(", "[", "x", "]", ")", ".", "data", "[", "0", "]", "for", "x", "in", "results", "[", "'img_metas'", "]", "]", "\n", "# aug test the model", "\n", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "aug_result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "results", ")", "\n", "", "return", "aug_result", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.test_aug_test_size": [[43, 66], ["dict", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "len", "os.join", "dict", "os.dirname"], "function", ["None"], ["", "def", "test_aug_test_size", "(", ")", ":", "\n", "    ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "\n", "# Define simple pipeline", "\n", "load", "=", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", "\n", "load", "=", "build_from_cfg", "(", "load", ",", "PIPELINES", ")", "\n", "\n", "# get config", "\n", "transform", "=", "dict", "(", "\n", "type", "=", "'MultiScaleFlipAug'", ",", "\n", "transforms", "=", "[", "]", ",", "\n", "img_scale", "=", "[", "(", "1333", ",", "800", ")", ",", "(", "800", ",", "600", ")", ",", "(", "640", ",", "480", ")", "]", ",", "\n", "flip", "=", "True", ",", "\n", "flip_direction", "=", "[", "'horizontal'", ",", "'vertical'", "]", ")", "\n", "multi_aug_test_module", "=", "build_from_cfg", "(", "transform", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "load", "(", "results", ")", "\n", "results", "=", "multi_aug_test_module", "(", "load", "(", "results", ")", ")", "\n", "# len([\"original\", \"horizontal\", \"vertical\"]) *", "\n", "# len([(1333, 800), (800, 600), (640, 480)])", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "9", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.test_cascade_rcnn_aug_test": [[68, 72], ["test_models_aug_test.model_aug_test_template", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.model_aug_test_template"], ["", "def", "test_cascade_rcnn_aug_test", "(", ")", ":", "\n", "    ", "aug_result", "=", "model_aug_test_template", "(", "\n", "'configs/cascade_rcnn/cascade_rcnn_r50_fpn_1x_coco.py'", ")", "\n", "assert", "len", "(", "aug_result", ")", "==", "80", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.test_mask_rcnn_aug_test": [[74, 80], ["test_models_aug_test.model_aug_test_template", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.model_aug_test_template"], ["", "def", "test_mask_rcnn_aug_test", "(", ")", ":", "\n", "    ", "aug_result", "=", "model_aug_test_template", "(", "\n", "'configs/mask_rcnn/mask_rcnn_r50_fpn_1x_coco.py'", ")", "\n", "assert", "len", "(", "aug_result", ")", "==", "2", "\n", "assert", "len", "(", "aug_result", "[", "0", "]", ")", "==", "80", "\n", "assert", "len", "(", "aug_result", "[", "1", "]", ")", "==", "80", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.test_htc_aug_test": [[82, 87], ["test_models_aug_test.model_aug_test_template", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.model_aug_test_template"], ["", "def", "test_htc_aug_test", "(", ")", ":", "\n", "    ", "aug_result", "=", "model_aug_test_template", "(", "'configs/htc/htc_r50_fpn_1x_coco.py'", ")", "\n", "assert", "len", "(", "aug_result", ")", "==", "2", "\n", "assert", "len", "(", "aug_result", "[", "0", "]", ")", "==", "80", "\n", "assert", "len", "(", "aug_result", "[", "1", "]", ")", "==", "80", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_models_aug_test.test_cornernet_aug_test": [[89, 119], ["mmcv.Config.fromfile", "mmdet.models.build_detector", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg.", "mmdet.models.build_detector.eval", "mmcv.utils.build_from_cfg.", "len", "len", "mmcv.parallel.collate", "torch.no_grad", "mmdet.models.build_detector.", "len", "os.join", "dict", "os.dirname", "mmcv.parallel.collate"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.models.builder.build_detector"], ["", "def", "test_cornernet_aug_test", "(", ")", ":", "\n", "# get config", "\n", "    ", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "\n", "'configs/cornernet/cornernet_hourglass104_mstest_10x5_210e_coco.py'", ")", "\n", "# init model", "\n", "cfg", ".", "model", ".", "pretrained", "=", "None", "\n", "model", "=", "build_detector", "(", "cfg", ".", "model", ",", "train_cfg", "=", "None", ",", "test_cfg", "=", "cfg", ".", "test_cfg", ")", "\n", "\n", "# init test pipeline and set aug test", "\n", "load_cfg", ",", "multi_scale_cfg", "=", "cfg", ".", "test_pipeline", "\n", "multi_scale_cfg", "[", "'flip'", "]", "=", "True", "\n", "multi_scale_cfg", "[", "'scale_factor'", "]", "=", "[", "0.5", ",", "1.0", ",", "2.0", "]", "\n", "\n", "load", "=", "build_from_cfg", "(", "load_cfg", ",", "PIPELINES", ")", "\n", "transform", "=", "build_from_cfg", "(", "multi_scale_cfg", ",", "PIPELINES", ")", "\n", "\n", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "results", "=", "transform", "(", "load", "(", "results", ")", ")", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "6", "\n", "assert", "len", "(", "results", "[", "'img_metas'", "]", ")", "==", "6", "\n", "\n", "results", "[", "'img'", "]", "=", "[", "collate", "(", "[", "x", "]", ")", "for", "x", "in", "results", "[", "'img'", "]", "]", "\n", "results", "[", "'img_metas'", "]", "=", "[", "collate", "(", "[", "x", "]", ")", ".", "data", "[", "0", "]", "for", "x", "in", "results", "[", "'img_metas'", "]", "]", "\n", "# aug test the model", "\n", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "aug_result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "results", ")", "\n", "", "assert", "len", "(", "aug_result", ")", "==", "80", "\n", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_dataset.test_custom_classes_override_default": [[13, 87], ["pytest.mark.parametrize", "mmdet.datasets.DATASETS.get", "unittest.mock.MagicMock", "DATASETS.get.", "DATASETS.get.", "DATASETS.get.", "DATASETS.get.", "tempfile.NamedTemporaryFile", "DATASETS.get.", "tempfile.NamedTemporaryFile.close", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "open", "f.write", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "unittest.mock.MagicMock"], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'dataset'", ",", "\n", "[", "'CocoDataset'", ",", "'VOCDataset'", ",", "'CityscapesDataset'", "]", ")", "\n", "def", "test_custom_classes_override_default", "(", "dataset", ")", ":", "\n", "    ", "dataset_class", "=", "DATASETS", ".", "get", "(", "dataset", ")", "\n", "dataset_class", ".", "load_annotations", "=", "MagicMock", "(", ")", "\n", "if", "dataset", "in", "[", "'CocoDataset'", ",", "'CityscapesDataset'", "]", ":", "\n", "        ", "dataset_class", ".", "coco", "=", "MagicMock", "(", ")", "\n", "dataset_class", ".", "cat_ids", "=", "MagicMock", "(", ")", "\n", "\n", "", "original_classes", "=", "dataset_class", ".", "CLASSES", "\n", "\n", "# Test setting classes as a tuple", "\n", "custom_dataset", "=", "dataset_class", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "\n", "pipeline", "=", "[", "]", ",", "\n", "classes", "=", "(", "'bus'", ",", "'car'", ")", ",", "\n", "test_mode", "=", "True", ",", "\n", "img_prefix", "=", "'VOC2007'", "if", "dataset", "==", "'VOCDataset'", "else", "''", ")", "\n", "\n", "assert", "custom_dataset", ".", "CLASSES", "!=", "original_classes", "\n", "assert", "custom_dataset", ".", "CLASSES", "==", "(", "'bus'", ",", "'car'", ")", "\n", "assert", "custom_dataset", ".", "custom_classes", "\n", "\n", "# Test setting classes as a list", "\n", "custom_dataset", "=", "dataset_class", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "\n", "pipeline", "=", "[", "]", ",", "\n", "classes", "=", "[", "'bus'", ",", "'car'", "]", ",", "\n", "test_mode", "=", "True", ",", "\n", "img_prefix", "=", "'VOC2007'", "if", "dataset", "==", "'VOCDataset'", "else", "''", ")", "\n", "\n", "assert", "custom_dataset", ".", "CLASSES", "!=", "original_classes", "\n", "assert", "custom_dataset", ".", "CLASSES", "==", "[", "'bus'", ",", "'car'", "]", "\n", "assert", "custom_dataset", ".", "custom_classes", "\n", "\n", "# Test overriding not a subset", "\n", "custom_dataset", "=", "dataset_class", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "\n", "pipeline", "=", "[", "]", ",", "\n", "classes", "=", "[", "'foo'", "]", ",", "\n", "test_mode", "=", "True", ",", "\n", "img_prefix", "=", "'VOC2007'", "if", "dataset", "==", "'VOCDataset'", "else", "''", ")", "\n", "\n", "assert", "custom_dataset", ".", "CLASSES", "!=", "original_classes", "\n", "assert", "custom_dataset", ".", "CLASSES", "==", "[", "'foo'", "]", "\n", "assert", "custom_dataset", ".", "custom_classes", "\n", "\n", "# Test default behavior", "\n", "custom_dataset", "=", "dataset_class", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "\n", "pipeline", "=", "[", "]", ",", "\n", "classes", "=", "None", ",", "\n", "test_mode", "=", "True", ",", "\n", "img_prefix", "=", "'VOC2007'", "if", "dataset", "==", "'VOCDataset'", "else", "''", ")", "\n", "\n", "assert", "custom_dataset", ".", "CLASSES", "==", "original_classes", "\n", "assert", "not", "custom_dataset", ".", "custom_classes", "\n", "\n", "# Test sending file path", "\n", "import", "tempfile", "\n", "tmp_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", "\n", "with", "open", "(", "tmp_file", ".", "name", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'bus\\ncar\\n'", ")", "\n", "", "custom_dataset", "=", "dataset_class", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "\n", "pipeline", "=", "[", "]", ",", "\n", "classes", "=", "tmp_file", ".", "name", ",", "\n", "test_mode", "=", "True", ",", "\n", "img_prefix", "=", "'VOC2007'", "if", "dataset", "==", "'VOCDataset'", "else", "''", ")", "\n", "tmp_file", ".", "close", "(", ")", "\n", "\n", "assert", "custom_dataset", ".", "CLASSES", "!=", "original_classes", "\n", "assert", "custom_dataset", ".", "CLASSES", "==", "[", "'bus'", ",", "'car'", "]", "\n", "assert", "custom_dataset", ".", "custom_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_dataset.test_dataset_wrapper": [[89, 158], ["unittest.mock.MagicMock", "unittest.mock.MagicMock", "mmdet.datasets.CustomDataset", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "mmdet.datasets.CustomDataset", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "mmdet.datasets.ConcatDataset", "mmdet.datasets.RepeatDataset", "collections.defaultdict", "collections.defaultdict.items", "numpy.mean", "numpy.cumsum", "mmdet.datasets.ClassBalancedDataset", "numpy.random.randint", "numpy.random.randint().tolist", "numpy.random.randint().tolist", "mmdet.datasets.ConcatDataset.get_cat_ids", "mmdet.datasets.ConcatDataset.get_cat_ids", "len", "mmdet.datasets.RepeatDataset.get_cat_ids", "mmdet.datasets.RepeatDataset.get_cat_ids", "mmdet.datasets.RepeatDataset.get_cat_ids", "len", "set", "list", "max", "set", "max", "repeat_factors.append", "len", "len", "unittest.mock.MagicMock", "numpy.random.randint", "unittest.mock.MagicMock", "numpy.random.randint", "len", "len", "len", "len", "collections.defaultdict.values", "math.sqrt", "collections.defaultdict.items", "math.ceil", "bisect.bisect_right", "numpy.random.randint", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "def", "test_dataset_wrapper", "(", ")", ":", "\n", "    ", "CustomDataset", ".", "load_annotations", "=", "MagicMock", "(", ")", "\n", "CustomDataset", ".", "__getitem__", "=", "MagicMock", "(", "side_effect", "=", "lambda", "idx", ":", "idx", ")", "\n", "dataset_a", "=", "CustomDataset", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "pipeline", "=", "[", "]", ",", "test_mode", "=", "True", ",", "img_prefix", "=", "''", ")", "\n", "len_a", "=", "10", "\n", "cat_ids_list_a", "=", "[", "\n", "np", ".", "random", ".", "randint", "(", "0", ",", "80", ",", "num", ")", ".", "tolist", "(", ")", "\n", "for", "num", "in", "np", ".", "random", ".", "randint", "(", "1", ",", "20", ",", "len_a", ")", "\n", "]", "\n", "dataset_a", ".", "data_infos", "=", "MagicMock", "(", ")", "\n", "dataset_a", ".", "data_infos", ".", "__len__", ".", "return_value", "=", "len_a", "\n", "dataset_a", ".", "get_cat_ids", "=", "MagicMock", "(", "\n", "side_effect", "=", "lambda", "idx", ":", "cat_ids_list_a", "[", "idx", "]", ")", "\n", "dataset_b", "=", "CustomDataset", "(", "\n", "ann_file", "=", "MagicMock", "(", ")", ",", "pipeline", "=", "[", "]", ",", "test_mode", "=", "True", ",", "img_prefix", "=", "''", ")", "\n", "len_b", "=", "20", "\n", "cat_ids_list_b", "=", "[", "\n", "np", ".", "random", ".", "randint", "(", "0", ",", "80", ",", "num", ")", ".", "tolist", "(", ")", "\n", "for", "num", "in", "np", ".", "random", ".", "randint", "(", "1", ",", "20", ",", "len_b", ")", "\n", "]", "\n", "dataset_b", ".", "data_infos", "=", "MagicMock", "(", ")", "\n", "dataset_b", ".", "data_infos", ".", "__len__", ".", "return_value", "=", "len_b", "\n", "dataset_b", ".", "get_cat_ids", "=", "MagicMock", "(", "\n", "side_effect", "=", "lambda", "idx", ":", "cat_ids_list_b", "[", "idx", "]", ")", "\n", "\n", "concat_dataset", "=", "ConcatDataset", "(", "[", "dataset_a", ",", "dataset_b", "]", ")", "\n", "assert", "concat_dataset", "[", "5", "]", "==", "5", "\n", "assert", "concat_dataset", "[", "25", "]", "==", "15", "\n", "assert", "concat_dataset", ".", "get_cat_ids", "(", "5", ")", "==", "cat_ids_list_a", "[", "5", "]", "\n", "assert", "concat_dataset", ".", "get_cat_ids", "(", "25", ")", "==", "cat_ids_list_b", "[", "15", "]", "\n", "assert", "len", "(", "concat_dataset", ")", "==", "len", "(", "dataset_a", ")", "+", "len", "(", "dataset_b", ")", "\n", "\n", "repeat_dataset", "=", "RepeatDataset", "(", "dataset_a", ",", "10", ")", "\n", "assert", "repeat_dataset", "[", "5", "]", "==", "5", "\n", "assert", "repeat_dataset", "[", "15", "]", "==", "5", "\n", "assert", "repeat_dataset", "[", "27", "]", "==", "7", "\n", "assert", "repeat_dataset", ".", "get_cat_ids", "(", "5", ")", "==", "cat_ids_list_a", "[", "5", "]", "\n", "assert", "repeat_dataset", ".", "get_cat_ids", "(", "15", ")", "==", "cat_ids_list_a", "[", "5", "]", "\n", "assert", "repeat_dataset", ".", "get_cat_ids", "(", "27", ")", "==", "cat_ids_list_a", "[", "7", "]", "\n", "assert", "len", "(", "repeat_dataset", ")", "==", "10", "*", "len", "(", "dataset_a", ")", "\n", "\n", "category_freq", "=", "defaultdict", "(", "int", ")", "\n", "for", "cat_ids", "in", "cat_ids_list_a", ":", "\n", "        ", "cat_ids", "=", "set", "(", "cat_ids", ")", "\n", "for", "cat_id", "in", "cat_ids", ":", "\n", "            ", "category_freq", "[", "cat_id", "]", "+=", "1", "\n", "", "", "for", "k", ",", "v", "in", "category_freq", ".", "items", "(", ")", ":", "\n", "        ", "category_freq", "[", "k", "]", "=", "v", "/", "len", "(", "cat_ids_list_a", ")", "\n", "\n", "", "mean_freq", "=", "np", ".", "mean", "(", "list", "(", "category_freq", ".", "values", "(", ")", ")", ")", "\n", "repeat_thr", "=", "mean_freq", "\n", "\n", "category_repeat", "=", "{", "\n", "cat_id", ":", "max", "(", "1.0", ",", "math", ".", "sqrt", "(", "repeat_thr", "/", "cat_freq", ")", ")", "\n", "for", "cat_id", ",", "cat_freq", "in", "category_freq", ".", "items", "(", ")", "\n", "}", "\n", "\n", "repeat_factors", "=", "[", "]", "\n", "for", "cat_ids", "in", "cat_ids_list_a", ":", "\n", "        ", "cat_ids", "=", "set", "(", "cat_ids", ")", "\n", "repeat_factor", "=", "max", "(", "{", "category_repeat", "[", "cat_id", "]", "for", "cat_id", "in", "cat_ids", "}", ")", "\n", "repeat_factors", ".", "append", "(", "math", ".", "ceil", "(", "repeat_factor", ")", ")", "\n", "", "repeat_factors_cumsum", "=", "np", ".", "cumsum", "(", "repeat_factors", ")", "\n", "repeat_factor_dataset", "=", "ClassBalancedDataset", "(", "dataset_a", ",", "repeat_thr", ")", "\n", "assert", "len", "(", "repeat_factor_dataset", ")", "==", "repeat_factors_cumsum", "[", "-", "1", "]", "\n", "for", "idx", "in", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "repeat_factor_dataset", ")", ",", "3", ")", ":", "\n", "        ", "assert", "repeat_factor_dataset", "[", "idx", "]", "==", "bisect", ".", "bisect_right", "(", "\n", "repeat_factors_cumsum", ",", "idx", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.chensnathan_SpatialFlow.test_data.test_formatting.test_default_format_bundle": [[8, 24], ["dict", "dict", "mmcv.utils.build_from_cfg", "dict", "mmcv.utils.build_from_cfg", "mmcv.utils.build_from_cfg.", "mmcv.utils.build_from_cfg.", "os.join", "dict", "os.dirname"], "function", ["None"], ["def", "test_default_format_bundle", "(", ")", ":", "\n", "    ", "results", "=", "dict", "(", "\n", "img_prefix", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "__file__", ")", ",", "'../data'", ")", ",", "\n", "img_info", "=", "dict", "(", "filename", "=", "'color.jpg'", ")", ")", "\n", "load", "=", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", "\n", "load", "=", "build_from_cfg", "(", "load", ",", "PIPELINES", ")", "\n", "bundle", "=", "dict", "(", "type", "=", "'DefaultFormatBundle'", ")", "\n", "bundle", "=", "build_from_cfg", "(", "bundle", ",", "PIPELINES", ")", "\n", "results", "=", "load", "(", "results", ")", "\n", "assert", "'pad_shape'", "not", "in", "results", "\n", "assert", "'scale_factor'", "not", "in", "results", "\n", "assert", "'img_norm_cfg'", "not", "in", "results", "\n", "results", "=", "bundle", "(", "results", ")", "\n", "assert", "'pad_shape'", "in", "results", "\n", "assert", "'scale_factor'", "in", "results", "\n", "assert", "'img_norm_cfg'", "in", "results", "\n", "", ""]]}