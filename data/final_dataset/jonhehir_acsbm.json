{"home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.SimulationSetting.__post_init__": [[32, 35], ["acsbm.models.NodeDataDistribution.uniform_for_model"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.uniform_for_model"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "ndd", "is", "None", ":", "\n", "            ", "self", ".", "ndd", "=", "models", ".", "NodeDataDistribution", ".", "uniform_for_model", "(", "self", ".", "base_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.SimulationSetting.model_at": [[36, 45], ["numpy.copy", "copy.copy", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.log"], ["", "", "def", "model_at", "(", "self", ",", "n", ":", "int", ")", "->", "models", ".", "MultiCovariateModel", ":", "\n", "# add log-scale sparsity if called for (do not mutate base_model!)", "\n", "        ", "if", "self", ".", "sparsity", ">", "0", ":", "\n", "            ", "B", "=", "np", ".", "copy", "(", "self", ".", "base_model", ".", "B", ")", "\n", "model", "=", "copy", ".", "copy", "(", "self", ".", "base_model", ")", "\n", "model", ".", "B", "=", "B", "-", "np", ".", "log", "(", "n", "**", "self", ".", "sparsity", ")", "\n", "return", "model", "\n", "\n", "", "return", "self", ".", "base_model", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.SimulationSetting.hash": [[46, 62], ["hashlib.sha1", "hashlib.sha1.hexdigest", "numpy.array", "hashlib.sha1.update", "simulator.SimulationSetting.base_model.flatten_covariate", "a.tobytes"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.flatten_covariate"], ["", "def", "hash", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Quick-and-dirty way to try to ensure that repeated runs that claim to be\n        the same setting truly are the same.\n        \"\"\"", "\n", "h", "=", "hashlib", ".", "sha1", "(", ")", "\n", "data", "=", "[", "\n", "self", ".", "base_model", ".", "B", ",", "\n", "self", ".", "base_model", ".", "flatten_covariate", "(", ")", ".", "beta_matrix", ",", "\n", "self", ".", "ndd", ".", "pmf", ",", "\n", "np", ".", "array", "(", "[", "self", ".", "sparsity", "]", ")", "\n", "]", "\n", "for", "a", "in", "data", ":", "\n", "            ", "h", ".", "update", "(", "a", ".", "tobytes", "(", ")", ")", "\n", "\n", "", "return", "h", ".", "hexdigest", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.run_simulation": [[139, 173], ["numpy.random.seed", "setting.model_at", "timeit.default_timer", "acsbm.estimation.initial_cluster", "timeit.default_timer", "acsbm.estimation.reconcile_clusters", "acsbm.utils.label_accuracy", "timeit.default_timer", "acsbm.estimation.estimate", "len", "range", "data.extend", "acsbm.generation.generate_network", "timeit.default_timer", "timeit.default_timer", "datetime.datetime.now", "setting.hash", "data.append", "data.append", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.SimulationSetting.model_at", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.initial_cluster", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.reconcile_clusters", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.label_accuracy", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.estimate", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_network", "home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.SimulationSetting.hash"], ["def", "run_simulation", "(", "name", ":", "str", ",", "n", ":", "int", ")", ":", "\n", "# generate random seed explicitly each time", "\n", "    ", "np", ".", "random", ".", "seed", "(", ")", "\n", "\n", "setting", "=", "settings", "[", "name", "]", "\n", "model", "=", "setting", ".", "model_at", "(", "n", ")", "\n", "try", ":", "\n", "        ", "net", "=", "generation", ".", "generate_network", "(", "model", ",", "setting", ".", "ndd", ",", "n", ")", "\n", "", "except", "generation", ".", "NetworkTooSmallError", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Skipping simulation due to NetworkTooSmallError.\"", ")", "\n", "return", "None", "\n", "\n", "", "start", "=", "timer", "(", ")", "\n", "ic_result", "=", "estimation", ".", "initial_cluster", "(", "net", ",", "model", ".", "n_communities", ",", "net", ".", "n_blocks", ")", "\n", "mid", "=", "timer", "(", ")", "\n", "c_result", "=", "estimation", ".", "reconcile_clusters", "(", "net", ",", "ic_result", ")", "\n", "c1_time", "=", "mid", "-", "start", "\n", "c2_time", "=", "timer", "(", ")", "-", "mid", "\n", "\n", "accuracy", "=", "label_accuracy", "(", "net", ".", "theta", ",", "c_result", ".", "theta", ")", "\n", "\n", "start", "=", "timer", "(", ")", "\n", "e_result", "=", "estimation", ".", "estimate", "(", "net", ",", "c_result", ")", "\n", "e_time", "=", "timer", "(", ")", "-", "start", "\n", "\n", "data", "=", "[", "name", ",", "datetime", ".", "datetime", ".", "now", "(", ")", ",", "setting", ".", "hash", "(", ")", ",", "setting", ".", "sparsity", ",", "n", ",", "net", ".", "n_edges", ",", "c1_time", ",", "c2_time", ",", "e_time", ",", "accuracy", "]", "\n", "n_covariates", "=", "len", "(", "model", ".", "covariates", ")", "\n", "for", "i", "in", "range", "(", "n_covariates", ")", ":", "\n", "        ", "data", ".", "append", "(", "model", ".", "covariates", "[", "i", "]", ".", "beta_matrix", "[", "0", ",", "0", "]", ")", "\n", "data", ".", "append", "(", "e_result", ".", "coefficients", "[", "i", "]", ")", "\n", "", "blanks", "=", "[", "''", "]", "*", "(", "MAX_COVARIATES", "-", "n_covariates", ")", "*", "2", "\n", "data", ".", "extend", "(", "blanks", ")", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.src.simulator.print_result": [[174, 177], ["print", "str"], "function", ["None"], ["", "def", "print_result", "(", "result", ")", ":", "\n", "    ", "if", "result", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"\\t\"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "result", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.Covariate.simple": [[14, 17], ["models.Covariate", "numpy.eye"], "methods", ["None"], ["@", "classmethod", "\n", "def", "simple", "(", "cls", ",", "beta", ":", "float", ",", "L", ":", "int", ")", ":", "\n", "        ", "return", "Covariate", "(", "beta_matrix", "=", "beta", "*", "np", ".", "eye", "(", "L", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.Covariate.n_levels": [[18, 21], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_levels", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "beta_matrix", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.Covariate.combine": [[22, 24], ["models.Covariate", "utils.kron_combine"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.kron_combine"], ["", "def", "combine", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "Covariate", "(", "beta_matrix", "=", "kron_combine", "(", "self", ".", "beta_matrix", ",", "other", ".", "beta_matrix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.inverse": [[34, 36], ["models.LinkFunction._statsmodels_link.inverse"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.inverse"], ["def", "inverse", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "_statsmodels_link", ".", "inverse", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.identity": [[37, 40], ["models.LinkFunction", "statsmodels.links.identity"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.identity"], ["", "@", "classmethod", "\n", "def", "identity", "(", "cls", ")", ":", "\n", "        ", "return", "LinkFunction", "(", "sm_families", ".", "links", ".", "identity", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.log": [[41, 44], ["models.LinkFunction", "statsmodels.links.log"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.log"], ["", "@", "classmethod", "\n", "def", "log", "(", "cls", ")", ":", "\n", "        ", "return", "LinkFunction", "(", "sm_families", ".", "links", ".", "log", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.logit": [[45, 48], ["models.LinkFunction", "statsmodels.links.logit"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.logit"], ["", "@", "classmethod", "\n", "def", "logit", "(", "cls", ")", ":", "\n", "        ", "return", "LinkFunction", "(", "sm_families", ".", "links", ".", "logit", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.probit": [[49, 52], ["models.LinkFunction", "statsmodels.links.probit"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.probit"], ["", "@", "classmethod", "\n", "def", "probit", "(", "cls", ")", ":", "\n", "        ", "return", "LinkFunction", "(", "sm_families", ".", "links", ".", "probit", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.n_communities": [[60, 63], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "n_communities", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "B", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.flatten_covariate": [[64, 69], ["functools.reduce", "x.combine"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.Covariate.combine"], ["", "def", "flatten_covariate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return a single covariate whose beta_matrix reflects the combined effects of all covariates\n        \"\"\"", "\n", "return", "functools", ".", "reduce", "(", "lambda", "x", ",", "y", ":", "x", ".", "combine", "(", "y", ")", ",", "self", ".", "covariates", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.flatten_Z": [[70, 84], ["Z.copy", "reversed", "Z.copy.sum", "range"], "methods", ["None"], ["", "def", "flatten_Z", "(", "self", ",", "Z", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Map each covariate combination to a unique scalar\n        Essentially tuple_id, but implemented in numpy instead.\n        \"\"\"", "\n", "levels", "=", "[", "c", ".", "n_levels", "for", "c", "in", "self", ".", "covariates", "]", "\n", "multiplier", "=", "0", "\n", "Z2", "=", "Z", ".", "copy", "(", ")", "\n", "for", "i", "in", "reversed", "(", "range", "(", "Z2", ".", "shape", "[", "1", "]", ")", ")", ":", "\n", "            ", "if", "multiplier", ">", "0", ":", "\n", "                ", "Z2", "[", ":", ",", "i", "]", "*=", "multiplier", "\n", "", "multiplier", "+=", "levels", "[", "i", "]", "\n", "\n", "", "return", "Z2", ".", "sum", "(", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.B_tilde": [[85, 89], ["models.MultiCovariateModel.flatten_covariate", "utils.kron_combine", "models.MultiCovariateModel.link.inverse"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.flatten_covariate", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.kron_combine", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.LinkFunction.inverse"], ["", "def", "B_tilde", "(", "self", ")", ":", "\n", "        ", "flattened", "=", "self", ".", "flatten_covariate", "(", ")", "\n", "M", "=", "kron_combine", "(", "self", ".", "B", ",", "flattened", ".", "beta_matrix", ")", "\n", "return", "self", ".", "link", ".", "inverse", "(", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.__init__": [[98, 100], ["numpy.sum"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pmf", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "self", ".", "pmf", "=", "pmf", "/", "np", ".", "sum", "(", "pmf", ")", "# normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.draw": [[101, 108], ["list", "numpy.random.default_rng.choice", "numpy.random.default_rng", "numpy.ndindex", "models.NodeDataDistribution.pmf.reshape", "len"], "methods", ["None"], ["", "def", "draw", "(", "self", ",", "n", ":", "int", ",", "random_state", ":", "np", ".", "random", ".", "Generator", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "random_state", "is", "None", ":", "\n", "            ", "random_state", "=", "np", ".", "random", ".", "default_rng", "(", ")", "\n", "\n", "", "all_indices", "=", "list", "(", "np", ".", "ndindex", "(", "*", "self", ".", "pmf", ".", "shape", ")", ")", "\n", "data", "=", "random_state", ".", "choice", "(", "all_indices", ",", "n", ",", "p", "=", "self", ".", "pmf", ".", "reshape", "(", "len", "(", "all_indices", ")", ",", ")", ")", "\n", "return", "data", "[", ":", ",", "0", "]", ",", "data", "[", ":", ",", "1", ":", "]", "# theta, Z", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution._model_shape": [[109, 112], ["tuple"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_model_shape", "(", "cls", ",", "model", ":", "MultiCovariateModel", ")", "->", "tuple", "[", "int", "]", ":", "\n", "        ", "return", "tuple", "(", "[", "model", ".", "n_communities", "]", "+", "[", "c", ".", "n_levels", "for", "c", "in", "model", ".", "covariates", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.uniform_for_model": [[113, 116], ["models.NodeDataDistribution", "numpy.ones", "cls._model_shape"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution._model_shape"], ["", "@", "classmethod", "\n", "def", "uniform_for_model", "(", "cls", ",", "model", ":", "MultiCovariateModel", ")", ":", "\n", "        ", "return", "NodeDataDistribution", "(", "np", ".", "ones", "(", "cls", ".", "_model_shape", "(", "model", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.random_for_model": [[117, 123], ["models.NodeDataDistribution", "numpy.random.default_rng().beta", "cls._model_shape", "numpy.random.default_rng"], "methods", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution._model_shape"], ["", "@", "classmethod", "\n", "def", "random_for_model", "(", "cls", ",", "model", ":", "MultiCovariateModel", ")", ":", "\n", "        ", "\"\"\"\n        An arbitrary random, non-uniform distribution\n        \"\"\"", "\n", "return", "NodeDataDistribution", "(", "np", ".", "random", ".", "default_rng", "(", ")", ".", "beta", "(", "2", ",", "3", ",", "cls", ".", "_model_shape", "(", "model", ")", ")", "+", "0.05", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.count_connections": [[37, 60], ["numpy.zeros", "zip", "numpy.maximum", "max", "A.nonzero", "min", "max"], "function", ["None"], ["", "def", "count_connections", "(", "A", ":", "Any", ",", "memberships", ":", "list", "[", "int", "]", ",", "dtype", ":", "Any", "=", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Count the number of connections, broken down by block memberships\n\n    This is primarily used to estimate B_tilde.\n\n    Params:\n\n    - `A`: sparse adjacency matrix\n    - `memberships`: 0-indexed block memberships (e.g., theta_tilde)\n    - `dtype` (optional): dtype to return (default: `int`)\n    \"\"\"", "\n", "n_blocks", "=", "max", "(", "memberships", ")", "+", "1", "\n", "counts", "=", "np", ".", "zeros", "(", "(", "n_blocks", ",", "n_blocks", ")", ",", "dtype", "=", "dtype", ")", "\n", "\n", "for", "idx_1", ",", "idx_2", "in", "zip", "(", "*", "A", ".", "nonzero", "(", ")", ")", ":", "\n", "        ", "if", "idx_1", ">", "idx_2", ":", "\n", "            ", "continue", "# don't double-count edges!", "\n", "\n", "", "t1", ",", "t2", "=", "memberships", "[", "idx_1", "]", ",", "memberships", "[", "idx_2", "]", "\n", "counts", "[", "min", "(", "t1", ",", "t2", ")", ",", "max", "(", "t1", ",", "t2", ")", "]", "+=", "1", "\n", "\n", "", "return", "np", ".", "maximum", "(", "counts", ",", "counts", ".", "T", ")", "# symmetrize, since lower triangle is zero", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.count_dyads": [[61, 86], ["collections.Counter", "numpy.zeros", "range", "numpy.maximum", "max", "range"], "function", ["None"], ["", "def", "count_dyads", "(", "memberships", ":", "list", "[", "int", "]", ",", "dtype", ":", "Any", "=", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate the dyad counts for each pair of blocks.\n\n    Params:\n\n    - `memberships`: 0-indexed block memberships (e.g., theta_tilde)\n    - `dtype` (optional): dtype to return (default: `int`)\n    \"\"\"", "\n", "n_blocks", "=", "max", "(", "memberships", ")", "+", "1", "\n", "est_block_sizes", "=", "Counter", "(", "memberships", ")", "\n", "\n", "counts", "=", "np", ".", "zeros", "(", "(", "n_blocks", ",", "n_blocks", ")", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# 1 <= i <= j <= n_blocks", "\n", "for", "i", "in", "range", "(", "n_blocks", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", ",", "n_blocks", ")", ":", "\n", "            ", "if", "i", "==", "j", ":", "\n", "# on-diagonal block: (n choose 2) dyads", "\n", "                ", "counts", "[", "i", ",", "j", "]", "=", "est_block_sizes", "[", "i", "]", "*", "(", "est_block_sizes", "[", "i", "]", "-", "1", ")", "//", "2", "\n", "", "else", ":", "\n", "# off-digonal block: (m x n) dyads", "\n", "                ", "counts", "[", "i", ",", "j", "]", "=", "est_block_sizes", "[", "i", "]", "*", "est_block_sizes", "[", "j", "]", "\n", "\n", "", "", "", "return", "np", ".", "maximum", "(", "counts", ",", "counts", ".", "T", ")", "# symmetrize, since lower triangle is zero", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.scaled_embeddings": [[87, 100], ["numpy.multiply", "scipy.linalg.eigh", "scipy.sparse.linalg.eigsh", "numpy.abs"], "function", ["None"], ["", "def", "scaled_embeddings", "(", "M", ":", "Any", ",", "d", ":", "int", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Return scaled embeddings (of dimension `d`) from matrix `M`\n\n    `M` can be a sparse adjacency matrix or a dense estimate of SBM probabilities (e.g., `B_tilde`)\n\n    If `d` is not specified, `M.shape[0]` is used.\n    \"\"\"", "\n", "if", "d", "is", "None", ":", "\n", "        ", "l", ",", "U", "=", "linalg", ".", "eigh", "(", "M", ")", "\n", "", "else", ":", "\n", "        ", "l", ",", "U", "=", "sparse", ".", "linalg", ".", "eigsh", "(", "M", ",", "d", ")", "\n", "", "return", "np", ".", "multiply", "(", "np", ".", "abs", "(", "l", ")", "**", "0.5", ",", "U", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.initial_cluster": [[101, 141], ["estimation.scaled_embeddings", "collections.defaultdict", "range", "range", "estimation.NetworkInitialClusterResult", "max", "len", "S[].append", "sklearn.mixture.GaussianMixture().fit", "GaussianMixture().fit.predict", "enumerate", "range", "utils.tuple_id", "len", "sklearn.mixture.GaussianMixture"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.scaled_embeddings", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.tuple_id"], ["", "def", "initial_cluster", "(", "net", ":", "generation", ".", "GeneratedNetwork", ",", "k", ":", "int", ",", "d", ":", "int", ")", "->", "NetworkInitialClusterResult", ":", "\n", "    ", "\"\"\"\n    ACSBM Clustering Part 1:\n    Recover theta_tilde (up to a permutation)\n\n    Params:\n\n    - `net`: generated network\n    - `k`: number of latent communities\n    - `d`: embedding dimension\n    \"\"\"", "\n", "# recode covariate:", "\n", "# (Within the context of this function, we pretend it's just a flattened covariate.", "\n", "Z", "=", "net", ".", "Z_tilde", "\n", "n_z", "=", "max", "(", "Z", ")", "+", "1", "\n", "\n", "# get embeddings", "\n", "X", "=", "scaled_embeddings", "(", "net", ".", "A", ",", "d", ")", "\n", "\n", "# partition nodes by covariate", "\n", "S", "=", "defaultdict", "(", "list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "Z", ")", ")", ":", "\n", "        ", "S", "[", "Z", "[", "i", "]", "]", ".", "append", "(", "i", ")", "\n", "\n", "# cluster per covariate level", "\n", "# also: build initial theta_tilde (arbitrary order)", "\n", "", "labels", "=", "{", "}", "\n", "theta_tilde", "=", "[", "0", "for", "_", "in", "range", "(", "len", "(", "Z", ")", ")", "]", "\n", "for", "z", "in", "range", "(", "n_z", ")", ":", "\n", "        ", "clusters", "=", "GaussianMixture", "(", "n_components", "=", "k", ")", ".", "fit", "(", "X", "[", "S", "[", "z", "]", ",", ":", "]", ")", "\n", "labels", "[", "z", "]", "=", "clusters", ".", "predict", "(", "X", "[", "S", "[", "z", "]", ",", ":", "]", ")", "\n", "\n", "for", "i_S", ",", "i_Z", "in", "enumerate", "(", "S", "[", "z", "]", ")", ":", "\n", "            ", "theta_tilde", "[", "i_Z", "]", "=", "tuple_id", "(", "(", "labels", "[", "z", "]", "[", "i_S", "]", ",", "z", ")", ",", "(", "k", ",", "n_z", ")", ")", "\n", "\n", "", "", "return", "NetworkInitialClusterResult", "(", "\n", "k", "=", "k", ",", "\n", "partitions", "=", "S", ",", "\n", "labels", "=", "labels", ",", "\n", "theta_tilde", "=", "theta_tilde", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.reconcile_clusters": [[143, 188], ["estimation.count_connections", "numpy.maximum", "estimation.scaled_embeddings", "range", "range", "estimation.invert_permutation", "estimation.NetworkClusterResult", "max", "estimation.count_dyads", "positions.append", "estimation.invert_permutation", "range", "enumerate", "utils.tuple_id", "estimation.optimal_matching", "range", "range", "utils.tuple_id", "utils.tuple_id", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.count_connections", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.scaled_embeddings", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.invert_permutation", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.count_dyads", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.invert_permutation", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.tuple_id", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.optimal_matching", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.tuple_id", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.tuple_id"], ["", "def", "reconcile_clusters", "(", "net", ":", "generation", ".", "GeneratedNetwork", ",", "initial_cluster", ":", "NetworkInitialClusterResult", ")", "->", "NetworkClusterResult", ":", "\n", "    ", "\"\"\"\n    ACSBM Clustering Parts 2 and 3:    \n    Given an initial clustering (which separately clusters over the partitioned network),\n    reconcile clusterings into a single set of clusters\n    \"\"\"", "\n", "Z", "=", "net", ".", "Z_tilde", "\n", "n_z", "=", "max", "(", "Z", ")", "+", "1", "\n", "k", ",", "S", ",", "labels", "=", "initial_cluster", ".", "k", ",", "initial_cluster", ".", "partitions", ",", "initial_cluster", ".", "labels", "\n", "theta_tilde", "=", "initial_cluster", ".", "theta_tilde", "\n", "\n", "# estimate B_tilde, X_B", "\n", "B_tilde", "=", "count_connections", "(", "net", ".", "A", ",", "theta_tilde", ",", "dtype", "=", "float", ")", "\n", "B_tilde", "/=", "np", ".", "maximum", "(", "count_dyads", "(", "theta_tilde", ")", ",", "1", ")", "\n", "X_B", "=", "scaled_embeddings", "(", "B_tilde", ")", "\n", "\n", "# group estimated positions by covariate", "\n", "positions", "=", "[", "]", "\n", "for", "z", "in", "range", "(", "n_z", ")", ":", "\n", "        ", "rows", "=", "[", "tuple_id", "(", "(", "j", ",", "z", ")", ",", "(", "k", ",", "n_z", ")", ")", "for", "j", "in", "range", "(", "k", ")", "]", "\n", "positions", ".", "append", "(", "X_B", "[", "rows", ",", ":", "]", ")", "\n", "\n", "# find optimal matching of clusters, invert to create lookups", "\n", "", "cluster_map", "=", "[", "invert_permutation", "(", "m", ")", "for", "m", "in", "optimal_matching", "(", "positions", ")", "]", "\n", "\n", "# reconcile permutations for final labels", "\n", "reorder", "=", "[", "0", "for", "_", "in", "range", "(", "k", "*", "len", "(", "S", ")", ")", "]", "# old theta_tilde value => sorted theta_tilde value", "\n", "theta", "=", "[", "0", "for", "_", "in", "range", "(", "len", "(", "Z", ")", ")", "]", "# reconciled labels", "\n", "for", "z", "in", "range", "(", "n_z", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "k", ")", ":", "\n", "            ", "theta_tilde_old", "=", "tuple_id", "(", "(", "j", ",", "z", ")", ",", "(", "k", ",", "n_z", ")", ")", "\n", "theta_tilde_new", "=", "tuple_id", "(", "(", "cluster_map", "[", "z", "]", "[", "j", "]", ",", "z", ")", ",", "(", "k", ",", "n_z", ")", ")", "\n", "reorder", "[", "theta_tilde_old", "]", "=", "theta_tilde_new", "\n", "\n", "", "for", "i_S", ",", "i_Z", "in", "enumerate", "(", "S", "[", "z", "]", ")", ":", "\n", "            ", "theta", "[", "i_Z", "]", "=", "cluster_map", "[", "z", "]", "[", "labels", "[", "z", "]", "[", "i_S", "]", "]", "\n", "\n", "# reorder theta_tilde, B_tilde", "\n", "", "", "reorder_inv", "=", "invert_permutation", "(", "reorder", ")", "\n", "theta_tilde", "=", "[", "reorder", "[", "x", "]", "for", "x", "in", "theta_tilde", "]", "\n", "B_tilde", "=", "B_tilde", "[", "reorder_inv", ",", ":", "]", "\n", "B_tilde", "=", "B_tilde", "[", ":", ",", "reorder_inv", "]", "\n", "\n", "return", "NetworkClusterResult", "(", "\n", "k", "=", "k", ",", "theta", "=", "theta", ",", "theta_tilde", "=", "theta_tilde", ",", "B_tilde", "=", "B_tilde", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.optimal_matching": [[190, 213], ["len", "best_matching.append", "range", "list", "scipy.optimize.linear_sum_assignment", "best_matching.append", "range", "opt.tolist", "scipy.spatial.distance_matrix"], "function", ["None"], ["", "def", "optimal_matching", "(", "positions", ":", "list", "[", "np", ".", "ndarray", "]", ")", "->", "list", "[", "list", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Returns a 2D array [matching_1, ... matching_k]:\n    Each entry gives indices mapping the cluster labels from the 0-th level\n    to the i-th level\n\n    Params:\n\n    - `positions`: list of position arrays per covariate level\n    \"\"\"", "\n", "l", "=", "len", "(", "positions", ")", "\n", "k", "=", "positions", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "best_matching", "=", "[", "]", "\n", "best_matching", ".", "append", "(", "list", "(", "range", "(", "k", ")", ")", ")", "# mapping level 0 => level 0 is just the identity", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "l", ")", ":", "\n", "        ", "_", ",", "opt", "=", "optimize", ".", "linear_sum_assignment", "(", "\n", "spatial", ".", "distance_matrix", "(", "positions", "[", "0", "]", ",", "positions", "[", "i", "]", ")", "**", "2", "\n", ")", "\n", "best_matching", ".", "append", "(", "opt", ".", "tolist", "(", ")", ")", "\n", "\n", "", "return", "best_matching", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.invert_permutation": [[214, 221], ["sorted", "enumerate"], "function", ["None"], ["", "def", "invert_permutation", "(", "p", ")", ":", "\n", "    ", "\"\"\"\n    Given a permutation p with entries 0..(n-1) in any order,\n    return the permutation p^-1 with entries 0..(n-1) such that\n    p^-1 [ p [i] ] = i for any i in 0..(n-1).\n    \"\"\"", "\n", "return", "[", "x", "[", "0", "]", "for", "x", "in", "sorted", "(", "enumerate", "(", "p", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.estimate": [[222, 280], ["len", "estimation.count_dyads", "numpy.rint", "numpy.zeros", "numpy.zeros", "numpy.triu_indices", "len", "numpy.zeros", "range", "statsmodels.genmod.generalized_linear_model.GLM", "statsmodels.genmod.generalized_linear_model.GLM.fit", "numpy.zeros", "estimation.NetworkEstimationResult", "max", "range", "numpy.sum", "range", "utils.from_tuple_id", "utils.from_tuple_id", "numpy.array", "numpy.hstack", "statsmodels.Binomial", "numpy.triu_indices_from", "numpy.tril_indices_from", "min", "max", "numpy.where", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.count_dyads", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.from_tuple_id", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.from_tuple_id"], ["", "def", "estimate", "(", "net", ":", "generation", ".", "GeneratedNetwork", ",", "cluster_result", ":", "NetworkClusterResult", ")", "->", "NetworkEstimationResult", ":", "\n", "    ", "\"\"\"\n    Estimate B matrix and coefficients of ACSBM model (assuming simple covariates only) via GLM\n    \"\"\"", "\n", "theta_tilde", "=", "cluster_result", ".", "theta_tilde", "\n", "n_communities", "=", "cluster_result", ".", "k", "\n", "n_blocks", "=", "max", "(", "theta_tilde", ")", "+", "1", "\n", "n_covariates", "=", "len", "(", "net", ".", "model", ".", "covariates", ")", "\n", "\n", "dyad_count", "=", "count_dyads", "(", "theta_tilde", ")", "\n", "connections", "=", "np", ".", "rint", "(", "cluster_result", ".", "B_tilde", "*", "dyad_count", ")", "\n", "\n", "# see from_tuple_id, which maps block index back to (theta, z_1, ... z_P)", "\n", "tuple_levels", "=", "[", "n_communities", "]", "+", "[", "c", ".", "n_levels", "for", "c", "in", "net", ".", "model", ".", "covariates", "]", "\n", "\n", "n_block_pairs", "=", "n_blocks", "*", "(", "n_blocks", "+", "1", ")", "//", "2", "\n", "covariate_indicators", "=", "np", ".", "zeros", "(", "(", "n_block_pairs", ",", "n_covariates", ")", ")", "\n", "response", "=", "np", ".", "zeros", "(", "(", "n_block_pairs", ",", "2", ")", ")", "\n", "# base block indicators: complicated since we only want params for the upper triangle of B", "\n", "B_idx", "=", "np", ".", "triu_indices", "(", "n_communities", ")", "\n", "n_base_blocks", "=", "len", "(", "B_idx", "[", "0", "]", ")", "\n", "B_idx_lookup", "=", "{", "(", "B_idx", "[", "0", "]", "[", "i", "]", ",", "B_idx", "[", "1", "]", "[", "i", "]", ")", ":", "i", "for", "i", "in", "range", "(", "n_base_blocks", ")", "}", "\n", "base_block_indicators", "=", "np", ".", "zeros", "(", "(", "n_block_pairs", ",", "n_base_blocks", ")", ")", "\n", "\n", "# Step 1: Build response and indicator matrices for regression", "\n", "# 1 <= i <= j <= n_blocks", "\n", "row", "=", "0", "\n", "for", "i", "in", "range", "(", "n_blocks", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", ",", "n_blocks", ")", ":", "\n", "            ", "t_i", "=", "from_tuple_id", "(", "i", ",", "tuple_levels", ")", "\n", "t_j", "=", "from_tuple_id", "(", "j", ",", "tuple_levels", ")", "\n", "base_block", "=", "(", "min", "(", "t_i", "[", "0", "]", ",", "t_j", "[", "0", "]", ")", ",", "max", "(", "t_i", "[", "0", "]", ",", "t_j", "[", "0", "]", ")", ")", "# again, upper triangle commplications", "\n", "base_block_id", "=", "B_idx_lookup", "[", "base_block", "]", "\n", "base_block_indicators", "[", "row", ",", "base_block_id", "]", "=", "1", "\n", "ind", "=", "np", ".", "where", "(", "np", ".", "array", "(", "t_i", ")", "==", "np", ".", "array", "(", "t_j", ")", ",", "1", ",", "0", ")", "[", "1", ":", "]", "# covariate match indicators", "\n", "covariate_indicators", "[", "row", ",", ":", "]", "=", "ind", "\n", "response", "[", "row", ",", ":", "]", "=", "np", ".", "array", "(", "[", "connections", "[", "i", ",", "j", "]", ",", "dyad_count", "[", "i", ",", "j", "]", "-", "connections", "[", "i", ",", "j", "]", "]", ")", "\n", "\n", "row", "+=", "1", "\n", "\n", "# Step 2: Fit GLM to estimate coefficients", "\n", "", "", "non_empty", "=", "np", ".", "sum", "(", "response", "[", ":", ",", "]", ",", "axis", "=", "1", ")", ">", "0", "\n", "model", "=", "sm_GLM", "(", "\n", "response", "[", "non_empty", ",", ":", "]", ",", "\n", "np", ".", "hstack", "(", "[", "base_block_indicators", ",", "covariate_indicators", "]", ")", "[", "non_empty", ",", ":", "]", ",", "\n", "family", "=", "sm_families", ".", "Binomial", "(", "link", "=", "net", ".", "model", ".", "link", ".", "_statsmodels_link", ")", "\n", ")", "\n", "results", "=", "model", ".", "fit", "(", ")", "\n", "coef", "=", "results", ".", "params", "[", "n_base_blocks", ":", "]", "\n", "\n", "# Step 3: Assemble B_hat, the estimation of B", "\n", "B_hat", "=", "np", ".", "zeros", "(", "(", "n_communities", ",", "n_communities", ")", ")", "\n", "B_hat", "[", "np", ".", "triu_indices_from", "(", "B_hat", ")", "]", "=", "results", ".", "params", "[", "0", ":", "n_base_blocks", "]", "\n", "B_hat", "[", "np", ".", "tril_indices_from", "(", "B_hat", ")", "]", "=", "results", ".", "params", "[", "0", ":", "n_base_blocks", "]", "[", ":", ":", "-", "1", "]", "\n", "\n", "return", "NetworkEstimationResult", "(", "\n", "B_hat", "=", "B_hat", ",", "\n", "coefficients", "=", "coef", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.GeneratedNetwork.n_blocks": [[24, 27], ["len"], "methods", ["None"], ["@", "property", "\n", "def", "n_blocks", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "block_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.GeneratedNetwork.n_nodes": [[28, 31], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_nodes", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "A", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.GeneratedNetwork.n_edges": [[32, 35], ["generation.GeneratedNetwork.A.count_nonzero"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_edges", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "A", ".", "count_nonzero", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_sparse_block": [[37, 52], ["scipy.sparse.random", "scipy.stats.binom.rvs().item", "RuntimeError", "scipy.sparse.triu", "scipy.sparse.triu().transpose", "scipy.stats.binom.rvs", "scipy.sparse.triu"], "function", ["None"], ["", "", "def", "generate_sparse_block", "(", "size", ",", "prob", ",", "symmetric", "=", "False", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generates a random block of binary entries where each entry is 1 w.p. prob\n    If symmetric=True, returns a symmetric block with a zero on the diagonal.\n    \"\"\"", "\n", "density", "=", "stats", ".", "binom", ".", "rvs", "(", "size", "[", "0", "]", "*", "size", "[", "1", "]", ",", "prob", ",", "size", "=", "1", ",", "random_state", "=", "random_state", ")", ".", "item", "(", ")", "/", "(", "size", "[", "0", "]", "*", "size", "[", "1", "]", ")", "\n", "m", "=", "sparse", ".", "random", "(", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "density", ",", "random_state", "=", "random_state", ")", "\n", "m", ".", "data", "[", ":", "]", "=", "1", "\n", "\n", "if", "symmetric", ":", "\n", "        ", "if", "size", "[", "0", "]", "!=", "size", "[", "1", "]", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"symmetric matrix must be square\"", ")", "\n", "", "m", "=", "sparse", ".", "triu", "(", "m", ",", "k", "=", "1", ")", "+", "sparse", ".", "triu", "(", "m", ",", "k", "=", "1", ")", ".", "transpose", "(", ")", "\n", "\n", "", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_sparse_sbm": [[53, 72], ["len", "range", "scipy.sparse.bmat", "range", "range", "generation.generate_sparse_block", "range", "[].transpose"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_sparse_block"], ["", "def", "generate_sparse_sbm", "(", "block_sizes", ",", "block_probs", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generate a stochastic block model using fixed block sizes and connectivity matrix\n    \"\"\"", "\n", "k", "=", "len", "(", "block_sizes", ")", "\n", "blocks", "=", "[", "[", "None", "for", "i", "in", "range", "(", "k", ")", "]", "for", "j", "in", "range", "(", "k", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", ",", "k", ")", ":", "\n", "            ", "blocks", "[", "i", "]", "[", "j", "]", "=", "generate_sparse_block", "(", "\n", "(", "block_sizes", "[", "i", "]", ",", "block_sizes", "[", "j", "]", ")", ",", "\n", "block_probs", "[", "i", ",", "j", "]", ",", "\n", "symmetric", "=", "(", "i", "==", "j", ")", ",", "\n", "random_state", "=", "random_state", "\n", ")", "\n", "if", "i", "<", "j", ":", "\n", "                ", "blocks", "[", "j", "]", "[", "i", "]", "=", "blocks", "[", "i", "]", "[", "j", "]", ".", "transpose", "(", ")", "\n", "\n", "", "", "", "return", "sparse", ".", "bmat", "(", "blocks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_network": [[73, 92], ["ndd.draw", "model.flatten_Z", "numpy.prod", "collections.Counter", "generation.GeneratedNetwork", "len", "generation.NetworkTooSmallError", "range", "collections.Counter.keys", "generation.generate_sparse_sbm", "model.B_tilde", "numpy.argsort", "numpy.argsort", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.NodeDataDistribution.draw", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.flatten_Z", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_sparse_sbm", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.B_tilde"], ["", "def", "generate_network", "(", "model", ":", "models", ".", "MultiCovariateModel", ",", "ndd", ":", "models", ".", "NodeDataDistribution", ",", "n", ":", "int", ",", "random_state", ":", "np", ".", "random", ".", "RandomState", "=", "None", ")", "->", "GeneratedNetwork", ":", "\n", "    ", "theta", ",", "Z", "=", "ndd", ".", "draw", "(", "n", ",", "random_state", "=", "random_state", ")", "\n", "Z_tilde", "=", "model", ".", "flatten_Z", "(", "Z", ")", "\n", "L_tilde", "=", "np", ".", "prod", "(", "[", "c", ".", "n_levels", "for", "c", "in", "model", ".", "covariates", "]", ")", "\n", "theta_tilde", "=", "L_tilde", "*", "theta", "+", "Z_tilde", "# same as applying tuple_id(...) over rows", "\n", "counts", "=", "Counter", "(", "theta_tilde", ")", "\n", "block_sizes", "=", "[", "counts", "[", "i", "]", "for", "i", "in", "range", "(", "model", ".", "n_communities", "*", "L_tilde", ")", "]", "\n", "\n", "# This could probably be handled more gracefully...", "\n", "if", "len", "(", "counts", ".", "keys", "(", ")", ")", "<", "model", ".", "n_communities", "*", "L_tilde", ":", "\n", "        ", "raise", "NetworkTooSmallError", "(", "\"Generated network does not have a node of every type. Consider using a larger n.\"", ")", "\n", "\n", "", "return", "GeneratedNetwork", "(", "\n", "A", "=", "generate_sparse_sbm", "(", "block_sizes", ",", "model", ".", "B_tilde", "(", ")", ",", "random_state", "=", "random_state", ")", ",", "\n", "theta", "=", "theta", "[", "np", ".", "argsort", "(", "theta_tilde", ")", "]", ",", "\n", "Z", "=", "Z", "[", "np", ".", "argsort", "(", "theta_tilde", ")", ",", ":", "]", ",", "\n", "Z_tilde", "=", "Z_tilde", "[", "np", ".", "argsort", "(", "theta_tilde", ")", "]", ",", "\n", "block_sizes", "=", "block_sizes", ",", "\n", "model", "=", "model", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.kron_combine": [[8, 14], ["numpy.kron", "numpy.kron", "numpy.ones", "numpy.ones"], "function", ["None"], ["def", "kron_combine", "(", "A", ":", "np", ".", "ndarray", ",", "B", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    kron(A, 11^T) + kron(11^T, B)\n    Note: This is not the same as a Kronecker sum, which uses identities in place of the ones matrices.\n    \"\"\"", "\n", "return", "np", ".", "kron", "(", "A", ",", "np", ".", "ones", "(", "B", ".", "shape", ")", ")", "+", "np", ".", "kron", "(", "np", ".", "ones", "(", "A", ".", "shape", ")", ",", "B", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.tuple_id": [[15, 34], ["list", "reversed", "sum", "range", "len"], "function", ["None"], ["", "def", "tuple_id", "(", "t", ":", "Iterable", "[", "int", "]", ",", "levels", ":", "Iterable", "[", "int", "]", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    A bijection that maps a tuple of ints to a scalar integer\n    Example with levels = (2, 3):\n    (0, 0) -> 0\n    (0, 1) -> 1\n    (0, 2) -> 2\n    (1, 0) -> 3\n    (1, 1) -> 4\n    (1, 2) -> 5\n    \"\"\"", "\n", "values", "=", "list", "(", "t", ")", "\n", "multiplier", "=", "0", "\n", "for", "i", "in", "reversed", "(", "range", "(", "len", "(", "values", ")", ")", ")", ":", "\n", "        ", "if", "multiplier", ">", "0", ":", "\n", "            ", "values", "[", "i", "]", "*=", "multiplier", "\n", "", "multiplier", "+=", "levels", "[", "i", "]", "\n", "\n", "", "return", "sum", "(", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.from_tuple_id": [[35, 45], ["reversed", "tuple", "range", "entries.append", "reversed", "len"], "function", ["None"], ["", "def", "from_tuple_id", "(", "id", ":", "int", ",", "levels", ":", "Iterable", "[", "int", "]", ")", "->", "tuple", "[", "int", "]", ":", "\n", "    ", "\"\"\"\n    Inverse of tuple_id\n    \"\"\"", "\n", "entries", "=", "[", "]", "\n", "for", "i", "in", "reversed", "(", "range", "(", "len", "(", "levels", ")", ")", ")", ":", "\n", "        ", "remainder", "=", "id", "%", "levels", "[", "i", "]", "\n", "entries", ".", "append", "(", "remainder", ")", "\n", "id", "=", "id", "//", "levels", "[", "i", "]", "\n", "", "return", "tuple", "(", "reversed", "(", "entries", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.label_accuracy": [[46, 60], ["itertools.permutations", "max", "range", "max", "sklearn.metrics.accuracy_score"], "function", ["None"], ["", "def", "label_accuracy", "(", "labels", ":", "Iterable", "[", "int", "]", ",", "truth", ":", "Iterable", "[", "int", "]", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    max(accuracy) over the set of all label permutations\n    truth should be an list of 0-indexed integer labels of length n\n    \"\"\"", "\n", "accuracy", "=", "0", "\n", "k", "=", "max", "(", "truth", ")", "+", "1", "# number of labels", "\n", "\n", "# This is not optimal, but we're using small k, so it's no biggie.", "\n", "for", "p", "in", "itertools", ".", "permutations", "(", "range", "(", "k", ")", ")", ":", "\n", "        ", "compare", "=", "[", "p", "[", "t", "]", "for", "t", "in", "truth", "]", "\n", "accuracy", "=", "max", "(", "accuracy", ",", "metrics", ".", "accuracy_score", "(", "labels", ",", "compare", ")", ")", "\n", "\n", "", "return", "accuracy", "\n", "", ""]], "home.repos.pwc.inspect_result.jonhehir_acsbm.examples.examples.rng": [[14, 16], ["numpy.random.default_rng"], "function", ["None"], ["def", "rng", "(", "seed", ":", "int", "=", "123", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "default_rng", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonhehir_acsbm.examples.examples.run_simulation": [[17, 64], ["acsbm.generation.generate_network", "len", "matplotlib.pyplot.matshow", "matplotlib.pyplot.title", "matplotlib.pyplot.colorbar", "timeit.default_timer", "acsbm.estimation.initial_cluster", "timeit.default_timer", "acsbm.estimation.reconcile_clusters", "timeit.default_timer", "examples.rng", "matplotlib.pyplot.matshow", "matplotlib.pyplot.title", "model.B_tilde", "numpy.zeros_like", "print", "print", "timeit.default_timer", "acsbm.estimation.estimate", "timeit.default_timer", "matplotlib.pyplot.matshow", "matplotlib.pyplot.title", "matplotlib.pyplot.colorbar", "matplotlib.pyplot.matshow", "matplotlib.pyplot.title", "matplotlib.pyplot.colorbar", "print", "print", "generation.generate_network.A.toarray", "acsbm.utils.label_accuracy"], "function", ["home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.generation.generate_network", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.initial_cluster", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.reconcile_clusters", "home.repos.pwc.inspect_result.jonhehir_acsbm.examples.examples.rng", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.models.MultiCovariateModel.B_tilde", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.estimation.estimate", "home.repos.pwc.inspect_result.jonhehir_acsbm.acsbm.utils.label_accuracy"], ["", "def", "run_simulation", "(", "model", ",", "ndd", ",", "n", ",", "ignore_covariates", "=", "False", ",", "ignore_communities", "=", "False", ",", "seed_rng", "=", "True", ")", ":", "\n", "    ", "random_state", "=", "rng", "(", ")", "if", "seed_rng", "else", "None", "\n", "\n", "net", "=", "generation", ".", "generate_network", "(", "model", ",", "ndd", ",", "n", ",", "random_state", "=", "random_state", ")", "\n", "\n", "k", "=", "1", "if", "ignore_communities", "else", "model", ".", "n_communities", "\n", "d", "=", "len", "(", "net", ".", "block_sizes", ")", "\n", "\n", "# Show model, network", "\n", "if", "n", "<=", "1000", ":", "\n", "        ", "plt", ".", "matshow", "(", "net", ".", "A", ".", "toarray", "(", ")", ")", "\n", "plt", ".", "title", "(", "\"Adjacency Matrix\"", ")", "\n", "", "plt", ".", "matshow", "(", "model", ".", "B_tilde", "(", ")", ")", "\n", "plt", ".", "title", "(", "\"B_tilde (true)\"", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "\n", "# Ignore covariates?", "\n", "if", "ignore_covariates", ":", "\n", "        ", "net", ".", "Z_tilde", "=", "np", ".", "zeros_like", "(", "net", ".", "Z_tilde", ")", "\n", "\n", "# Cluster!", "\n", "", "start", "=", "timer", "(", ")", "\n", "ic_result", "=", "estimation", ".", "initial_cluster", "(", "net", ",", "k", ",", "d", ")", "\n", "mid", "=", "timer", "(", ")", "\n", "c_result", "=", "estimation", ".", "reconcile_clusters", "(", "net", ",", "ic_result", ")", "\n", "end", "=", "timer", "(", ")", "\n", "\n", "# Report clustering accuracy only if not ignoring communities (in which case accuracy is meaningless)", "\n", "if", "not", "ignore_communities", ":", "\n", "        ", "print", "(", "f\"Accuracy: {utils.label_accuracy(c_result.theta, net.theta)}\"", ")", "\n", "print", "(", "f\"Clustering Time: {mid-start} + {end-mid} = {end-start}\"", ")", "\n", "\n", "# Estimate coefficients (unless ignoring covariates)", "\n", "", "if", "not", "ignore_covariates", ":", "\n", "        ", "start", "=", "timer", "(", ")", "\n", "e_result", "=", "estimation", ".", "estimate", "(", "net", ",", "c_result", ")", "\n", "end", "=", "timer", "(", ")", "\n", "\n", "plt", ".", "matshow", "(", "c_result", ".", "B_tilde", ")", "\n", "plt", ".", "title", "(", "\"B_tilde (estimated)\"", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "matshow", "(", "e_result", ".", "B_hat", ")", "\n", "plt", ".", "title", "(", "\"B (estimated)\"", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "\n", "print", "(", "f\"Coefficients: {e_result.coefficients}\"", ")", "\n", "print", "(", "f\"Estimation Time: {end-start}\"", ")", "\n", "", "", ""]]}