{"home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.demo.circle_simulator_func": [[16, 35], ["range", "numpy.ravel", "numpy.any", "numpy.array", "numpy.power", "Y.append", "f.append", "numpy.array().reshape", "numpy.array().reshape", "numpy.linalg.norm", "zip", "numpy.array", "numpy.array"], "function", ["None"], ["def", "circle_simulator_func", "(", "X", ",", "power", "=", "2", ")", ":", "\n", "    ", "circle_centers", "=", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", "\n", "circle_radii", "=", "[", ".5", ",", ".5", "]", "\n", "num_points", "=", "X", ".", "shape", "[", "0", "]", "\n", "Y", "=", "[", "]", "\n", "f", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_points", ")", ":", "\n", "        ", "x", "=", "np", ".", "ravel", "(", "X", "[", "i", ",", ":", "]", ")", "\n", "hits", "=", "[", "np", ".", "linalg", ".", "norm", "(", "c", "-", "x", ")", "<=", "r", "for", "(", "c", ",", "r", ")", "in", "zip", "(", "circle_centers", ",", "circle_radii", ")", "]", "\n", "feasibility", "=", "np", ".", "any", "(", "hits", ")", "\n", "opt_goal", "=", "np", ".", "array", "(", "x", ")", "\n", "if", "hits", "[", "0", "]", ":", "\n", "            ", "opt_goal", "+=", "[", "0", ",", ".5", "]", "\n", "", "if", "hits", "[", "1", "]", ":", "\n", "            ", "opt_goal", "+=", "[", ".5", ",", "0", "]", "\n", "", "opt_goal", "=", "np", ".", "power", "(", "opt_goal", ",", "power", ")", "\n", "Y", ".", "append", "(", "opt_goal", ")", "\n", "f", ".", "append", "(", "feasibility", ")", "\n", "", "return", "(", "np", ".", "array", "(", "Y", ")", ".", "reshape", "(", "num_points", ",", "2", ")", ",", "np", ".", "array", "(", "f", ")", ".", "reshape", "(", "num_points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.demo.circle_pareto_func": [[37, 39], ["numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.linspace().reshape", "numpy.linspace().reshape", "numpy.array().reshape", "numpy.array().reshape", "numpy.linspace", "numpy.linspace", "numpy.array", "numpy.array", "numpy.sqrt", "numpy.sqrt", "numpy.linspace().reshape", "numpy.linspace().reshape", "numpy.linspace", "numpy.linspace"], "function", ["None"], ["", "def", "circle_pareto_func", "(", "N", ")", ":", "\n", "    ", "return", "np", ".", "concatenate", "(", "(", "np", ".", "concatenate", "(", "(", "np", ".", "linspace", "(", "0", ",", ".5", ",", "N", ")", ".", "reshape", "(", "N", ",", "1", ")", ",", "np", ".", "linspace", "(", "1", ",", "1.5", ",", "N", ")", ".", "reshape", "(", "N", ",", "1", ")", ")", ")", ",", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "np", ".", "sqrt", "(", ".25", "-", "(", "np", ".", "linspace", "(", "0", ",", ".5", ",", "N", ")", ".", "reshape", "(", "N", ",", "1", ")", "-", "0", ")", "**", "2", ")", "+", "1", ")", ".", "reshape", "(", "N", ",", "1", ")", ",", "np", ".", "array", "(", "np", ".", "sqrt", "(", ".25", "-", "(", "np", ".", "linspace", "(", "1", ",", "1.5", ",", "N", ")", ".", "reshape", "(", "N", ",", "1", ")", "-", "1", ")", "**", "2", ")", "+", "0", ")", ".", "reshape", "(", "N", ",", "1", ")", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.demo.circle_callback_func": [[41, 86], ["matplotlib.figure", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.title", "matplotlib.show", "numpy.linspace", "numpy.meshgrid", "parallel_opt().reshape", "matplotlib.contourf", "demo.circle_pareto_func", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.plot", "numpy.linspace", "numpy.array", "demo.circle_callback_func.parallel_opt"], "function", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.demo.circle_pareto_func"], ["", "def", "circle_callback_func", "(", "sampler", ",", "X", ",", "Y", ",", "f", ",", "iteration", ")", ":", "\n", "# options", "\n", "    ", "grid_resolution", "=", "20", "\n", "figsize", "=", "(", "10", ",", "10", ")", "\n", "show_true_pareto", "=", "True", "\n", "show_path", "=", "True", "\n", "workers", "=", "1", "\n", "\n", "# plot", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "if", "grid_resolution", ">", "0", ":", "\n", "        ", "x_grid", "=", "np", ".", "linspace", "(", "sampler", ".", "_X_limits", "[", "0", "]", "[", "0", "]", ",", "sampler", ".", "_X_limits", "[", "0", "]", "[", "1", "]", ",", "grid_resolution", ")", "\n", "y_grid", "=", "np", ".", "linspace", "(", "sampler", ".", "_X_limits", "[", "1", "]", "[", "0", "]", ",", "sampler", ".", "_X_limits", "[", "1", "]", "[", "1", "]", ",", "grid_resolution", ")", ".", "T", "\n", "x_grid", ",", "y_grid", "=", "np", ".", "meshgrid", "(", "x_grid", ",", "y_grid", ")", "\n", "Z", "=", "np", ".", "c_", "[", "x_grid", ".", "ravel", "(", ")", ",", "y_grid", ".", "ravel", "(", ")", "]", "\n", "def", "parallel_opt", "(", "Z", ")", ":", "\n", "            ", "opt", "=", "[", "]", "\n", "for", "z", "in", "Z", ":", "\n", "                ", "if", "sampler", ".", "_opt_func", "is", "not", "None", ":", "\n", "                    ", "opt", ".", "append", "(", "sampler", ".", "_opt_func", "(", "z", ".", "ravel", "(", ")", ",", "workers", "=", "workers", ")", ")", "\n", "", "else", ":", "\n", "                    ", "opt", ".", "append", "(", "0", ")", "\n", "", "", "return", "np", ".", "array", "(", "opt", ")", "\n", "", "utility", "=", "parallel_opt", "(", "Z", ")", ".", "reshape", "(", "x_grid", ".", "shape", ")", "\n", "plt", ".", "contourf", "(", "x_grid", ",", "y_grid", ",", "utility", ",", "cmap", "=", "\"coolwarm\"", ",", "alpha", "=", ".25", ")", "\n", "", "if", "show_true_pareto", ":", "\n", "        ", "X_true_pareto", "=", "circle_pareto_func", "(", "N", "=", "512", ")", "\n", "plt", ".", "scatter", "(", "X_true_pareto", "[", ":", ",", "0", "]", ",", "X_true_pareto", "[", ":", ",", "1", "]", ",", "c", "=", "'c'", ",", "s", "=", "15", ")", "\n", "", "plt", ".", "scatter", "(", "X", "[", "f", "==", "0", ",", "0", "]", ",", "X", "[", "f", "==", "0", ",", "1", "]", ",", "c", "=", "'r'", ")", "\n", "plt", ".", "scatter", "(", "X", "[", "f", "==", "1", ",", "0", "]", ",", "X", "[", "f", "==", "1", ",", "1", "]", ",", "c", "=", "'g'", ")", "\n", "X_pareto", "=", "X", "[", "f", "==", "1", ",", ":", "]", "[", "sampler", ".", "_is_pareto_efficient", "(", "Y", "[", "f", "==", "1", ",", ":", "]", ")", ",", ":", "]", "\n", "plt", ".", "scatter", "(", "X_pareto", "[", ":", ",", "0", "]", ",", "X_pareto", "[", ":", ",", "1", "]", ",", "c", "=", "'b'", ")", "\n", "plt", ".", "scatter", "(", "X", "[", ":", "sampler", ".", "_initial_samples", ",", "0", "]", ",", "X", "[", ":", "sampler", ".", "_initial_samples", ",", "1", "]", ",", "facecolor", "=", "'none'", ",", "edgecolor", "=", "'k'", ",", "s", "=", "110", ")", "\n", "if", "iteration", "is", "not", "None", ":", "\n", "        ", "plt", ".", "scatter", "(", "X", "[", "-", "sampler", ".", "_virtual_iterations", ":", ",", "0", "]", ",", "X", "[", "-", "sampler", ".", "_virtual_iterations", ":", ",", "1", "]", ",", "facecolor", "=", "'none'", ",", "edgecolor", "=", "'c'", ",", "marker", "=", "'s'", ",", "s", "=", "110", ")", "\n", "", "if", "show_path", ":", "\n", "        ", "plt", ".", "plot", "(", "X", "[", "sampler", ".", "_initial_samples", ":", ",", "0", "]", ",", "X", "[", "sampler", ".", "_initial_samples", ":", ",", "1", "]", ",", "c", "=", "'b'", ",", "alpha", "=", ".05", ")", "\n", "", "plt", ".", "xlim", "(", "-", "2", ",", "2", ")", "\n", "plt", ".", "ylim", "(", "-", "2", ",", "2", ")", "\n", "title", "=", "\"[initial sampling]\"", "if", "iteration", "is", "None", "else", "\"[iteration {:d}]\"", ".", "format", "(", "iteration", ")", "\n", "plt", ".", "title", "(", "title", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# return test callback result", "\n", "return", "iteration", "", "", ""]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.__init__": [[26, 31], ["sklearn.base.BaseEstimator.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model_constructor", ",", "predict_fun", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_model_constructor", "=", "model_constructor", "\n", "self", ".", "_predict_fun", "=", "predict_fun", "\n", "self", ".", "_kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.fit": [[32, 39], ["sklearn.multioutput.MultiOutputRegressor", "sklearn.multioutput.MultiOutputRegressor", "sklearn.multioutput.MultiOutputRegressor", "sklearn.multioutput.MultiOutputRegressor", "models.AdvancedMultiOutputRegressor._model.fit", "models.AdvancedMultiOutputRegressor._model_constructor"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "self", ".", "_X", "=", "X", "\n", "self", ".", "_y", "=", "y", "\n", "self", ".", "_y_dim", "=", "y", ".", "shape", "[", "1", "]", "\n", "self", ".", "_model", "=", "MultiOutputRegressor", "(", "self", ".", "_model_constructor", "(", "**", "self", ".", "_kwargs", ")", ")", "\n", "self", ".", "_model", ".", "fit", "(", "X", ",", "y", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.predict": [[40, 50], ["sklearn.utils.validation.check_is_fitted", "sklearn.utils.validation.check_is_fitted", "sklearn.utils.validation.check_is_fitted", "sklearn.utils.validation.check_is_fitted", "models.AdvancedMultiOutputRegressor._model.predict", "numpy.stack", "numpy.stack", "list", "list", "estimator.predict", "models.AdvancedMultiOutputRegressor._predict_fun", "range", "range"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ",", "return_std", "=", "False", ")", ":", "\n", "        ", "check_is_fitted", "(", "self", ",", "[", "'_X'", ",", "'_y'", "]", ")", "\n", "if", "not", "return_std", ":", "\n", "            ", "predictions", "=", "self", ".", "_model", ".", "predict", "(", "X", ")", "\n", "", "else", ":", "\n", "            ", "estimator_predictions", "=", "[", "estimator", ".", "predict", "(", "X", ",", "return_std", "=", "True", ")", "if", "self", ".", "_predict_fun", "is", "None", "else", "self", ".", "_predict_fun", "(", "estimator", ",", "X", ")", "for", "estimator", "in", "self", ".", "_model", ".", "estimators_", "]", "\n", "mu", "=", "np", ".", "stack", "(", "list", "(", "estimator_predictions", "[", "i", "]", "[", "0", "]", "for", "i", "in", "range", "(", "self", ".", "_y_dim", ")", ")", ",", "axis", "=", "1", ")", "\n", "sigma", "=", "np", ".", "stack", "(", "list", "(", "estimator_predictions", "[", "i", "]", "[", "1", "]", "for", "i", "in", "range", "(", "self", ".", "_y_dim", ")", ")", ",", "axis", "=", "1", ")", "\n", "predictions", "=", "mu", ",", "sigma", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.score": [[51, 53], ["models.AdvancedMultiOutputRegressor._model.score"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.score"], ["", "def", "score", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "return", "self", ".", "_model", ".", "score", "(", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.get_params": [[54, 56], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ",", "deep", "=", "True", ")", ":", "\n", "        ", "return", "{", "\"kwargs\"", ":", "self", ".", "_kwargs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.AdvancedMultiOutputRegressor.set_params": [[57, 61], ["parameters.items", "setattr"], "methods", ["None"], ["", "def", "set_params", "(", "self", ",", "**", "parameters", ")", ":", "\n", "        ", "for", "parameter", ",", "value", "in", "parameters", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "parameter", ",", "value", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.MultivariateGPR.__init__": [[64, 66], ["models.AdvancedMultiOutputRegressor.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "GaussianProcessRegressor", ",", "None", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.Y_Model_GPR.__init__": [[69, 73], ["sampling.RegressionModel.__init__", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "sklearn.Matern", "sklearn.Matern", "sklearn.Matern", "sklearn.Matern", "sklearn.StandardScaler", "sklearn.StandardScaler", "sklearn.StandardScaler", "sklearn.StandardScaler", "models.MultivariateGPR"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernel", "=", "1.0", "*", "kernels", ".", "Matern", "(", ")", ",", "n_restarts_optimizer", "=", "5", ",", "random_state", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_model", "=", "Pipeline", "(", "[", "(", "'Yscaler'", ",", "preprocessing", ".", "StandardScaler", "(", ")", ")", ",", "\n", "(", "'Yreg'", ",", "MultivariateGPR", "(", "kernel", "=", "kernel", ",", "random_state", "=", "random_state", ",", "n_restarts_optimizer", "=", "n_restarts_optimizer", ")", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.Y_Model_GPR.fit": [[74, 76], ["models.Y_Model_GPR._model.fit"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "self", ".", "_model", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.Y_Model_GPR.predict": [[77, 79], ["models.Y_Model_GPR._model.predict"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ",", "return_std", ")", ":", "\n", "        ", "return", "self", ".", "_model", ".", "predict", "(", "X", ",", "return_std", "=", "return_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.f_Model_SVM.__init__": [[82, 87], ["dict", "sampling.ClassificationModel.__init__", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline", "numpy.logspace", "numpy.logspace", "sklearn.StandardScaler", "sklearn.StandardScaler", "sklearn.StandardScaler", "sklearn.StandardScaler", "sklearn.GridSearchCV", "sklearn.GridSearchCV", "sklearn.GridSearchCV", "sklearn.GridSearchCV", "sklearn.SVC", "sklearn.SVC", "sklearn.SVC", "sklearn.SVC", "sklearn.StratifiedKFold", "sklearn.StratifiedKFold", "sklearn.StratifiedKFold", "sklearn.StratifiedKFold"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernel", "=", "'rbf'", ",", "cv_dict", "=", "dict", "(", "C", "=", "np", ".", "logspace", "(", "-", "1", ",", "3", ",", "10", ")", ",", "gamma", "=", "np", ".", "logspace", "(", "-", "1", ",", "3", ",", "10", ")", ")", ",", "n_splits", "=", "3", ",", "random_state", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_model", "=", "Pipeline", "(", "[", "(", "'fscaler'", ",", "preprocessing", ".", "StandardScaler", "(", ")", ")", ",", "\n", "(", "'fclf'", ",", "model_selection", ".", "GridSearchCV", "(", "svm", ".", "SVC", "(", "kernel", "=", "kernel", ",", "random_state", "=", "random_state", ",", "probability", "=", "True", ")", ",", "\n", "cv_dict", ",", "cv", "=", "model_selection", ".", "StratifiedKFold", "(", "n_splits", "=", "n_splits", ",", "shuffle", "=", "True", ",", "random_state", "=", "random_state", ")", ")", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.f_Model_SVM.fit": [[88, 90], ["models.f_Model_SVM._model.fit"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "f", ")", ":", "\n", "        ", "self", ".", "_model", ".", "fit", "(", "X", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.f_Model_SVM.predict": [[91, 93], ["models.f_Model_SVM._model.predict"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "self", ".", "_model", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.models.f_Model_SVM.predict_true_proba": [[94, 96], ["[].ravel", "models.f_Model_SVM._model.predict_proba"], "methods", ["None"], ["", "def", "predict_true_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "self", ".", "_model", ".", "predict_proba", "(", "X", ")", "[", ":", ",", "1", "]", ".", "ravel", "(", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.RegressionModel.__init__": [[76, 78], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.RegressionModel.fit": [[79, 96], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "\"\"\"Train estimator.\n        \n        Is called at least once before any prediction.\n        \n        Parameters\n        ----------\n        \n        X : ndarray of shape (n_samples, X_dim)\n            Array of features (estimator inputs).\n            \n        Y : ndarray of shape (n_samples, Y_dim)\n            Array of regression values (estimator targets).\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.RegressionModel.predict": [[97, 126], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ",", "X", ",", "return_std", ")", ":", "\n", "        ", "\"\"\"Estimator prediction.\n         \n        It is assumed that the predictive distribution is a Gaussian specified \n        by a mean and a standard deviation.\n        \n        Parameters\n        ----------\n        \n        X : ndarray of shape (n_query_points, X_dim)\n            Query points where the estimator is evaluated.\n        \n        return_std : bool\n            If set to True, return both the means and the standard deviations.\n            If set to False, only return the means.\n            \n        Returns\n        -------\n        \n        Y_mu : ndarray of shape (n_query_points, Y_dim)\n            Mean of the predictive distribution at the query points.\n            \n        Y_sigma : ndarray of shape (n_query_points, Y_dim)\n           Standard deviation of the predictive distribution at the query \n           points. Covariances are not returned.\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.__init__": [[134, 136], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit": [[137, 156], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "fit", "(", "self", ",", "X", ",", "f", ")", ":", "\n", "        ", "\"\"\"Train estimator.\n        \n        Is called at least once before any prediction. The class labels can be \n        either True or False and are automatically converted to integers \n        before the training.\n        \n        Parameters\n        ----------\n        \n        X : ndarray of shape (n_samples, X_dim)\n            Array of features (estimator inputs).\n            \n        f : ndarray of shape (n_samples,)\n            Array of binary classification labels (estimator targets).\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict": [[157, 175], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Classifier prediction.\n        \n        Parameters\n        ----------\n        \n        X : ndarray of shape (n_query_points, X_dim)\n            Query points where the estimator is evaluated.\n            \n        Returns\n        -------\n        \n        f : ndarray of shape (n_query_points,)\n            Predicted labels at the query points.\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict_true_proba": [[176, 198], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict_true_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Classifier probability prediction.\n        \n        Returns the predicted probability of a True label at the respective \n        query points.\n        \n        Parameters\n        ----------\n        \n        X : ndarray of shape (n_query_points, X_dim)\n            Query points where the estimator is evaluated.\n            \n        Returns\n        -------\n        \n        p : ndarray of shape (n_query_points,)\n            Predicted probability for a True label at the query points. It is \n            assumed that ``0 <= p <= 1``.\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.__init__": [[342, 368], ["dict", "dict", "numpy.asarray().tolist", "numpy.asarray().tolist", "int", "int", "int", "dict", "dict", "bool", "bool", "dict", "dict", "sampling.AdaptiveSampler._init_properties", "sampling.AdaptiveSampler._verify_self", "int", "int", "numpy.asarray().tolist", "numpy.asarray", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._init_properties", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._verify_self"], ["def", "__init__", "(", "self", ",", "simulation_func", ",", "X_limits", ",", "Y_ref", ",", "iterations", ",", "Y_model", ",", "f_model", ",", "initial_samples", "=", "0", ",", "virtual_iterations", "=", "1", ",", "initial_sampling_func", "=", "\"random\"", ",", "utility_parameter_options", "=", "dict", "(", ")", ",", "decision_parameter_options", "=", "dict", "(", ")", ",", "X_initial_sample_limits", "=", "None", ",", "callback_func", "=", "None", ",", "stopping_condition_func", "=", "None", ",", "seed", "=", "None", ",", "verbose", "=", "False", ",", "save_memory_flag", "=", "False", ")", ":", "\n", "        ", "self", ".", "_dtype_X", "=", "np", ".", "float64", "\n", "self", ".", "_dtype_Y", "=", "np", ".", "float64", "\n", "self", ".", "_dtype_f", "=", "np", ".", "int64", "\n", "self", ".", "_f_values_dict", "=", "{", "False", ":", "int", "(", "False", ")", ",", "True", ":", "int", "(", "True", ")", "}", "\n", "self", ".", "_simulation_func", "=", "simulation_func", "\n", "self", ".", "_X_limits", "=", "np", ".", "asarray", "(", "X_limits", ",", "dtype", "=", "self", ".", "_dtype_X", ")", ".", "tolist", "(", ")", "\n", "self", ".", "_Y_ref", "=", "np", ".", "asarray", "(", "Y_ref", ",", "dtype", "=", "self", ".", "_dtype_Y", ")", ".", "tolist", "(", ")", "\n", "self", ".", "_iterations", "=", "int", "(", "iterations", ")", "\n", "self", ".", "_Y_model", "=", "Y_model", "\n", "self", ".", "_f_model", "=", "f_model", "\n", "self", ".", "_initial_samples", "=", "int", "(", "initial_samples", ")", "\n", "self", ".", "_virtual_iterations", "=", "int", "(", "virtual_iterations", ")", "\n", "self", ".", "_initial_sampling_func", "=", "initial_sampling_func", "\n", "self", ".", "_utility_parameter_options", "=", "dict", "(", "utility_parameter_options", ")", "\n", "self", ".", "_decision_parameter_options", "=", "dict", "(", "decision_parameter_options", ")", "\n", "self", ".", "_X_initial_sample_limits", "=", "np", ".", "asarray", "(", "X_initial_sample_limits", ",", "dtype", "=", "np", ".", "float64", ")", ".", "tolist", "(", ")", "if", "X_initial_sample_limits", "is", "not", "None", "else", "self", ".", "_X_limits", "\n", "self", ".", "_callback_func", "=", "callback_func", "\n", "self", ".", "_stopping_condition_func", "=", "stopping_condition_func", "\n", "self", ".", "_seed", "=", "seed", "\n", "self", ".", "_verbose", "=", "bool", "(", "verbose", ")", "\n", "self", ".", "_save_memory_flag", "=", "bool", "(", "save_memory_flag", ")", "\n", "self", ".", "_default_utility_parameters", "=", "dict", "(", "entropy_weight", "=", "1", ",", "optimization_weight", "=", "1", ",", "repulsion_weight", "=", "1", ",", "repulsion_gamma", "=", "1", ",", "repulsion_distance_func", "=", "\"default\"", ",", "evi_gamma", "=", "1", ",", "sector_cutoff", "=", "1", ")", "\n", "self", ".", "_default_decision_parameters", "=", "dict", "(", "popsize", "=", "15", ",", "maxiter", "=", "1000", ",", "tol", "=", ".01", ",", "atol", "=", ".05", ",", "polish", "=", "True", ",", "polish_extratol", "=", ".1", ",", "polish_maxfun", "=", "100", ",", "de_workers", "=", "-", "1", ",", "polish_workers", "=", "-", "1", ")", "\n", "self", ".", "_init_properties", "(", ")", "\n", "self", ".", "_verify_self", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.info": [[369, 374], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"Current sampling information.\"\"\"", "\n", "\n", "return", "self", ".", "_info", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.opt_func": [[375, 380], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "opt_func", "(", "self", ")", ":", "\n", "        ", "\"\"\"Current optimization function.\"\"\"", "\n", "\n", "return", "self", ".", "_opt_func", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._init_properties": [[381, 386], ["dict"], "methods", ["None"], ["", "def", "_init_properties", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize sampler properties (called in ``__init__``).\"\"\"", "\n", "\n", "self", ".", "_info", "=", "dict", "(", ")", "\n", "self", ".", "_opt_func", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._verify_self": [[388, 413], ["callable", "ValueError", "ValueError", "isinstance", "ValueError", "isinstance", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "numpy.array", "len", "type", "callable", "len", "len", "callable", "callable", "type", "type", "numpy.array", "len", "numpy.iinfo", "numpy.iinfo"], "methods", ["None"], ["", "def", "_verify_self", "(", "self", ")", ":", "\n", "        ", "\"\"\"Verify certain sampler attributes (called in ``__init__``).\"\"\"", "\n", "\n", "if", "not", "callable", "(", "self", ".", "_simulation_func", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: simulation_func is not a callable.\"", ")", "\n", "", "if", "np", ".", "array", "(", "self", ".", "_X_limits", ")", ".", "size", "!=", "len", "(", "self", ".", "_X_limits", ")", "*", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: invalid X_limits shape.\"", ")", "\n", "", "if", "not", "isinstance", "(", "self", ".", "_Y_model", ",", "RegressionModel", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: Y_model is not a RegressionModel.\"", ")", "\n", "", "if", "not", "isinstance", "(", "self", ".", "_f_model", ",", "ClassificationModel", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: f_model is not a ClassificationModel.\"", ")", "\n", "", "if", "self", ".", "_virtual_iterations", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: virtual_iterations must be 1 or more.\"", ")", "\n", "", "if", "type", "(", "self", ".", "_initial_sampling_func", ")", "is", "not", "str", "and", "not", "callable", "(", "self", ".", "_initial_sampling_func", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: initial_sampling_func of invalid type.\"", ")", "\n", "", "if", "np", ".", "array", "(", "self", ".", "_X_initial_sample_limits", ")", ".", "size", "!=", "len", "(", "self", ".", "_X_initial_sample_limits", ")", "*", "2", "or", "len", "(", "self", ".", "_X_initial_sample_limits", ")", "!=", "len", "(", "self", ".", "_X_limits", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: invalid X_initial_sample_limits shape.\"", ")", "\n", "", "if", "self", ".", "_callback_func", "is", "not", "None", "and", "not", "callable", "(", "self", ".", "_callback_func", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: callback_func of invalid type.\"", ")", "\n", "", "if", "self", ".", "_stopping_condition_func", "is", "not", "None", "and", "not", "callable", "(", "self", ".", "_stopping_condition_func", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: stopping_condition_func of invalid type.\"", ")", "\n", "", "if", "self", ".", "_seed", "is", "not", "None", "and", "type", "(", "self", ".", "_seed", ")", "is", "not", "int", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: seed of invalid type.\"", ")", "\n", "", "if", "type", "(", "self", ".", "_seed", ")", "is", "int", "and", "not", "(", "self", ".", "_seed", ">=", "0", "and", "self", ".", "_seed", "<", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Verification error: seed not in the valid range [0, {}).\"", ".", "format", "(", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_X": [[414, 418], ["numpy.asarray().reshape", "numpy.asarray"], "methods", ["None"], ["", "", "def", "_convert_X", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Convert feature data into a standard format.\"\"\"", "\n", "\n", "return", "np", ".", "asarray", "(", "X", ",", "dtype", "=", "self", ".", "_dtype_X", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "_X_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_Y": [[419, 423], ["numpy.asarray().reshape", "numpy.asarray"], "methods", ["None"], ["", "def", "_convert_Y", "(", "self", ",", "Y", ")", ":", "\n", "        ", "\"\"\"Convert goal data into a standard format.\"\"\"", "\n", "\n", "return", "np", ".", "asarray", "(", "Y", ",", "dtype", "=", "self", ".", "_dtype_Y", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "_Y_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_f": [[424, 428], ["numpy.asarray().ravel", "numpy.asarray", "numpy.vectorize", "f.astype"], "methods", ["None"], ["", "def", "_convert_f", "(", "self", ",", "f", ")", ":", "\n", "        ", "\"\"\"Convert feasibility data into a standard format.\"\"\"", "\n", "\n", "return", "np", ".", "asarray", "(", "np", ".", "vectorize", "(", "self", ".", "_f_values_dict", ".", "get", ")", "(", "f", ".", "astype", "(", "bool", ")", ")", ",", "dtype", "=", "self", ".", "_dtype_f", ")", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.initial_sampling_random_uniform": [[429, 436], ["numpy.random.RandomState", "numpy.concatenate", "numpy.concatenate.reshape", "numpy.random.RandomState.uniform().reshape", "numpy.random.RandomState.uniform"], "methods", ["None"], ["", "def", "initial_sampling_random_uniform", "(", "self", ",", "initial_samples", ",", "X_initial_sample_limits", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Create a random initial design of experiments within the given \n        limits of the feature space.\"\"\"", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "X_init", "=", "np", ".", "concatenate", "(", "[", "rng", ".", "uniform", "(", "limits", "[", "0", "]", ",", "limits", "[", "1", "]", ",", "initial_samples", ")", ".", "reshape", "(", "initial_samples", ",", "1", ")", "for", "limits", "in", "X_initial_sample_limits", "]", ",", "axis", "=", "1", ")", "\n", "return", "X_init", ".", "reshape", "(", "-", "1", ",", "self", ".", "_X_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.initial_sampling_factorial": [[437, 451], ["int", "itertools.product", "numpy.asarray().reshape", "numpy.ceil", "numpy.asarray().reshape.append", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "numpy.asarray", "numpy.linspace"], "methods", ["None"], ["", "def", "initial_sampling_factorial", "(", "self", ",", "initial_samples", ",", "X_initial_sample_limits", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Create an initial factorial design of experiments. If no full \n        factorial design is possible, a random subsampling is used.\"\"\"", "\n", "\n", "X_init", "=", "[", "]", "\n", "suggestions_per_dimension", "=", "int", "(", "(", "np", ".", "ceil", "(", "initial_samples", "**", "(", "1", "/", "self", ".", "_X_dim", ")", ")", ")", ")", "\n", "for", "x", "in", "product", "(", "*", "[", "np", ".", "linspace", "(", "limits", "[", "0", "]", ",", "limits", "[", "1", "]", ",", "suggestions_per_dimension", ")", "for", "limits", "in", "X_initial_sample_limits", "]", ")", ":", "\n", "            ", "X_init", ".", "append", "(", "x", ")", "\n", "", "X_init", "=", "np", ".", "asarray", "(", "X_init", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "_X_dim", ")", "\n", "if", "X_init", ".", "shape", "[", "0", "]", ">", "initial_samples", ":", "\n", "            ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "rng", ".", "shuffle", "(", "X_init", ")", "\n", "X_init", "=", "X_init", "[", ":", "initial_samples", ",", ":", "]", "\n", "", "return", "X_init", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._is_pareto_efficient": [[452, 469], ["numpy.arange", "len", "numpy.any", "comparison_func", "numpy.sum"], "methods", ["None"], ["", "def", "_is_pareto_efficient", "(", "self", ",", "costs", ",", "exclude_duplicates", "=", "True", ")", ":", "\n", "        ", "\"\"\"Determine Pareto-efficient indices of a cost vector. Note: Assume \n        maximization. Exclude duplicates by default.\"\"\"", "\n", "\n", "if", "exclude_duplicates", ":", "\n", "            ", "comparison_func", "=", "lambda", "c1", ",", "c2", ":", "c1", ">", "c2", "\n", "", "else", ":", "\n", "            ", "comparison_func", "=", "lambda", "c1", ",", "c2", ":", "c1", ">=", "c2", "\n", "", "is_efficient", "=", "np", ".", "arange", "(", "costs", ".", "shape", "[", "0", "]", ")", "\n", "next_point_index", "=", "0", "\n", "while", "next_point_index", "<", "len", "(", "costs", ")", ":", "\n", "            ", "nondominated_point_mask", "=", "np", ".", "any", "(", "comparison_func", "(", "costs", ",", "costs", "[", "next_point_index", "]", ")", ",", "axis", "=", "1", ")", "\n", "nondominated_point_mask", "[", "next_point_index", "]", "=", "True", "\n", "is_efficient", "=", "is_efficient", "[", "nondominated_point_mask", "]", "\n", "costs", "=", "costs", "[", "nondominated_point_mask", "]", "\n", "next_point_index", "=", "np", ".", "sum", "(", "nondominated_point_mask", "[", ":", "next_point_index", "]", ")", "+", "1", "\n", "", "return", "is_efficient", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._create_pareto_grid_cached": [[470, 488], ["numpy.array", "numpy.full", "numpy.array.reshape", "numpy.full.reshape", "numpy.prod", "list", "range", "itertools.product", "numpy.all", "itertools.product", "numpy.logical_or.reduce", "len", "len", "len", "numpy.all", "range", "range", "range"], "methods", ["None"], ["", "def", "_create_pareto_grid_cached", "(", "self", ",", "Y_grid_lines", ",", "Y_grid_scale", ",", "Y_pareto", ",", "Y_ref", ",", "Y_dim", ")", ":", "\n", "        ", "\"\"\"Create a Pareto grid. Note: Grid functions with best speed but also \n        large memory requirements (grid is fully stored in memory).\"\"\"", "\n", "\n", "# Build grid and grid mask", "\n", "grid", "=", "np", ".", "array", "(", "list", "(", "product", "(", "*", "Y_grid_lines", ")", ")", ",", "dtype", "=", "np", ".", "float64", ")", "# contains actual grid points", "\n", "grid_mask", "=", "np", ".", "full", "(", "grid", ".", "shape", ",", "False", ",", "dtype", "=", "np", ".", "bool", ")", "# grid point domination: true, when dominated", "\n", "grid_mask", "[", "np", ".", "logical_or", ".", "reduce", "(", "[", "np", ".", "all", "(", "grid", "<", "Y_pareto", "[", "idx", ",", ":", "]", ",", "axis", "=", "1", ")", "for", "idx", "in", "range", "(", "Y_pareto", ".", "shape", "[", "0", "]", ")", "]", ")", "]", "=", "True", "\n", "Y_grid", "=", "grid", ".", "reshape", "(", "*", "[", "len", "(", "Y_grid_lines", "[", "d", "]", ")", "for", "d", "in", "range", "(", "Y_dim", ")", "]", ",", "Y_dim", ")", "\n", "Y_grid_mask", "=", "grid_mask", ".", "reshape", "(", "*", "[", "len", "(", "Y_grid_lines", "[", "d", "]", ")", "for", "d", "in", "range", "(", "Y_dim", ")", "]", ",", "Y_dim", ")", "\n", "Y_grid_size", "=", "np", ".", "prod", "(", "[", "len", "(", "line", ")", "for", "line", "in", "Y_grid_lines", "]", ")", "\n", "\n", "# Build functions    ", "\n", "grid_lens_iterator_list", "=", "[", "range", "(", "d", "-", "1", ")", "for", "d", "in", "Y_grid", ".", "shape", "[", ":", "-", "1", "]", "]", "\n", "Y_grid_idx_iter_func", "=", "lambda", ":", "product", "(", "*", "grid_lens_iterator_list", ")", "\n", "Y_grid_map_func", "=", "lambda", "idx", ":", "Y_grid", "[", "idx", "]", "\n", "Y_grid_dom_func", "=", "lambda", "idx_nodim", ":", "np", ".", "all", "(", "Y_grid_mask", "[", "idx_nodim", "]", ")", "\n", "return", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._create_pareto_grid_runtime": [[489, 500], ["numpy.prod", "range", "itertools.product", "numpy.logical_or.reduce", "len", "len", "numpy.all", "range", "numpy.array().reshape", "numpy.array", "Y_grid_map_func", "range", "list"], "methods", ["None"], ["", "def", "_create_pareto_grid_runtime", "(", "self", ",", "Y_grid_lines", ",", "Y_grid_scale", ",", "Y_pareto", ",", "Y_ref", ",", "Y_dim", ")", ":", "\n", "        ", "\"\"\"Create a Pareto grid. Note: Grid functions with very small memory \n        requirements (store almost nothing in memory). Is also a bit slower.\"\"\"", "\n", "\n", "# Build functions", "\n", "line_lens_iterator_list", "=", "[", "range", "(", "len", "(", "line", ")", "-", "1", ")", "for", "line", "in", "Y_grid_lines", "]", "\n", "Y_grid_idx_iter_func", "=", "lambda", ":", "product", "(", "*", "line_lens_iterator_list", ")", "\n", "Y_grid_map_func", "=", "lambda", "idx", ":", "Y_grid_lines", "[", "idx", "[", "-", "1", "]", "]", "[", "idx", "[", ":", "-", "1", "]", "[", "idx", "[", "-", "1", "]", "]", "]", "\n", "Y_grid_dom_func", "=", "lambda", "idx_nodim", ":", "np", ".", "logical_or", ".", "reduce", "(", "[", "np", ".", "all", "(", "np", ".", "array", "(", "[", "Y_grid_map_func", "(", "list", "(", "idx_nodim", ")", "+", "[", "d", "]", ")", "for", "d", "in", "range", "(", "Y_dim", ")", "]", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "<", "Y_pareto", "[", "idx", ",", ":", "]", ",", "axis", "=", "1", ")", "for", "idx", "in", "range", "(", "Y_pareto", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "Y_grid_size", "=", "np", ".", "prod", "(", "[", "len", "(", "line", ")", "for", "line", "in", "Y_grid_lines", "]", ")", "\n", "return", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_start_idx": [[501, 506], ["tuple"], "methods", ["None"], ["", "def", "_pareto_grid_map_idx_nodim_to_start_idx", "(", "self", ",", "idx_nodim", ",", "d", ")", ":", "\n", "        ", "\"\"\"Helper functions to map indices for a Pareto grid. Map to the start \n        index.\"\"\"", "\n", "\n", "return", "tuple", "(", "idx", "for", "idx", "in", "idx_nodim", ")", "+", "(", "d", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_stop_idx": [[507, 512], ["tuple", "numpy.array", "numpy.array", "range"], "methods", ["None"], ["", "def", "_pareto_grid_map_idx_nodim_to_stop_idx", "(", "self", ",", "Y_dim", ",", "idx_nodim", ",", "d", ")", ":", "\n", "        ", "\"\"\"Helper functions to map indices for a Pareto grid. Map to the stop \n        index.\"\"\"", "\n", "\n", "return", "tuple", "(", "np", ".", "array", "(", "idx_nodim", ")", "+", "np", ".", "array", "(", "[", "1", "if", "k", "==", "d", "else", "0", "for", "k", "in", "range", "(", "Y_dim", ")", "]", ")", ")", "+", "(", "d", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._create_pareto_grid": [[513, 590], ["numpy.asarray", "numpy.asarray", "numpy.any", "range", "range", "range", "numpy.any", "Exception", "numpy.max", "numpy.concatenate", "numpy.ones", "numpy.copy", "Y_dset.append", "range", "Y_grid_lines[].append", "Exception", "creator_func", "range", "Exception", "numpy.ones", "numpy.asarray.reshape", "range", "numpy.asarray.reshape", "numpy.max.reshape", "Y_grid_lines[].append", "len", "len", "len", "Y_set[].argsort", "numpy.where", "numpy.any"], "methods", ["None"], ["", "def", "_create_pareto_grid", "(", "self", ",", "creator_func", ",", "Y_pareto", ",", "Y_ref", ",", "Y_dim", ",", "cut_ref_violation", ",", "scale", "=", "True", ")", ":", "\n", "        ", "\"\"\"Create a non-uniform grid for Pareto volume calculations (Pareto \n        grid). Note: Assume maximization. The resulting grid is asymmetric \n        when ``np.any(Y_ref == Y_pareto)`` due to the exclusion of zero area \n        grid sectors, otherwise it's symmetric.\"\"\"", "\n", "\n", "# Remarks:", "\n", "#", "\n", "# Arguments:", "\n", "# creator_func: (Y_grid_lines, Y_grid_scale, Y_pareto, Y_ref, Y_dim) -> return values", "\n", "# Y_pareto, Y_ref, Y_dim: properties of the grid", "\n", "# cut_ref_violation: flag, defines whether points lower than Y_ref are cut off or an exception is raised", "\n", "#", "\n", "# Return values:", "\n", "# Y_grid_idx_iter_func: () -> iterator. Iterate over all possible idx_nodim = [line1 index, ... linen index]", "\n", "# Y_grid_map_func: (idx) -> float. Extract grid point from index: idx -> Y_grid[idx], where idx = [line1 index, ... linen index, Y index]", "\n", "# Y_grid_dom_func: (idx) -> float. Check if grid point is dominated (=True): idx_nodim -> np.all(Y_grid_mask[idx_nodim]), where idx_nodim = [line1 index, ... linen index]", "\n", "# Y_grid_scale: np.array of floats defining the grid axis scales", "\n", "# Y_grid_size: size of grid (i.e., number of elements in grid)\"\"\"", "\n", "\n", "# Prepare", "\n", "Y_pareto", "=", "np", ".", "asarray", "(", "Y_pareto", ")", "\n", "Y_ref", "=", "np", ".", "asarray", "(", "Y_ref", ")", "\n", "if", "Y_dim", "!=", "Y_ref", ".", "size", "or", "(", "Y_dim", "!=", "Y_pareto", ".", "shape", "[", "1", "]", "and", "Y_pareto", ".", "size", ">", "0", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Invalid dimensions: Y_dim = {}, Y_ref.shape = {}, Y_pareto.shape = {}!\"", ".", "format", "(", "Y_dim", ",", "Y_ref", ".", "shape", ",", "Y_pareto", ".", "shape", ")", ")", "\n", "", "if", "np", ".", "any", "(", "Y_ref", ">", "Y_pareto", ")", ":", "\n", "            ", "if", "cut_ref_violation", ":", "\n", "                ", "for", "p", "in", "range", "(", "Y_pareto", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "Y_pareto", "[", "p", ",", ":", "]", "[", "Y_ref", ">", "Y_pareto", "[", "p", ",", ":", "]", "]", "=", "Y_ref", "[", "Y_ref", ">", "Y_pareto", "[", "p", ",", ":", "]", "]", "# cut all violation points to the correct Y_ref limits", "\n", "", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Invalid reference point: {} > {}, but Y_ref <= Y_pareto required!\"", ".", "format", "(", "Y_ref", ",", "Y_pareto", "[", "np", ".", "where", "(", "np", ".", "any", "(", "Y_ref", ">", "Y_pareto", ",", "axis", "=", "1", ")", ")", "]", ")", ")", "\n", "\n", "# Non-vanishing pareto set", "\n", "", "", "if", "Y_pareto", ".", "size", ">", "0", ":", "\n", "# Rescaling", "\n", "            ", "Y_max", "=", "np", ".", "max", "(", "Y_pareto", ",", "axis", "=", "0", ")", "\n", "if", "scale", ":", "\n", "                ", "Y_grid_scale", "=", "Y_max", "-", "Y_ref", "\n", "Y_grid_scale", "[", "Y_grid_scale", "==", "0", "]", "=", "1", "# Fall back to unit scaling where we hit the reference point (this should be a very rare case)", "\n", "Y_pareto", "=", "Y_pareto", "/", "Y_grid_scale", "\n", "Y_max", "=", "Y_max", "/", "Y_grid_scale", "\n", "Y_ref", "=", "Y_ref", "/", "Y_grid_scale", "\n", "", "else", ":", "\n", "                ", "Y_grid_scale", "=", "np", ".", "ones", "(", "Y_dim", ")", "# use unit scaling", "\n", "\n", "# Create point cloud", "\n", "", "Y_set", "=", "np", ".", "concatenate", "(", "(", "Y_pareto", ",", "Y_ref", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "Y_max", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ")", "\n", "\n", "# Vanishing pareto set (is not used since Y_mu, Y_sigma cannot be retrieved without data)", "\n", "", "else", ":", "\n", "# Rescaling: use unit scaling", "\n", "            ", "Y_grid_scale", "=", "np", ".", "ones", "(", "Y_dim", ")", "\n", "\n", "# Create point cloud", "\n", "Y_set", "=", "np", ".", "copy", "(", "Y_ref", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "# Create sorted edge points", "\n", "", "Y_dset", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "Y_dim", ")", ":", "\n", "            ", "Y_dset", ".", "append", "(", "Y_set", "[", "Y_set", "[", ":", ",", "d", "]", ".", "argsort", "(", ")", "]", "[", ":", ",", "d", "]", ")", "\n", "\n", "# Create lines", "\n", "", "Y_grid_lines", "=", "[", "[", "]", "for", "_", "in", "range", "(", "Y_dim", ")", "]", "\n", "for", "idx", "in", "range", "(", "Y_set", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "d", "in", "range", "(", "Y_dim", ")", ":", "\n", "                ", "if", "len", "(", "Y_grid_lines", "[", "d", "]", ")", "==", "0", "or", "Y_grid_lines", "[", "d", "]", "[", "-", "1", "]", "<", "Y_dset", "[", "d", "]", "[", "idx", "]", ":", "\n", "                    ", "Y_grid_lines", "[", "d", "]", ".", "append", "(", "Y_dset", "[", "d", "]", "[", "idx", "]", ")", "\n", "", "", "", "for", "d", "in", "range", "(", "Y_dim", ")", ":", "\n", "            ", "Y_grid_lines", "[", "d", "]", ".", "append", "(", "np", ".", "inf", ")", "\n", "", "if", "np", ".", "any", "(", "[", "len", "(", "line", ")", "<", "2", "for", "line", "in", "Y_grid_lines", "]", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Invalid Y_grid_lines with shape = {}!\"", ".", "format", "(", "[", "len", "(", "line", ")", "for", "line", "in", "Y_grid_lines", "]", ")", ")", "\n", "\n", "# Compile and return functions", "\n", "", "if", "creator_func", "is", "not", "None", ":", "\n", "            ", "return", "creator_func", "(", "Y_grid_lines", ",", "Y_grid_scale", ",", "Y_pareto", ",", "Y_ref", ",", "Y_dim", ")", "\n", "", "else", ":", "\n", "            ", "return", "Y_grid_lines", ",", "Y_grid_scale", ",", "Y_pareto", ",", "Y_ref", ",", "Y_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._expected_non_dominated_volume_improvement": [[591, 703], ["numpy.sum", "numpy.zeros", "numpy.isposinf", "numpy.zeros", "Exception", "numpy.zeros", "Y_grid_dom_func", "range", "numpy.ones", "range", "Y_grid_idx_iter_func", "numpy.any", "numpy.zeros", "enumerate", "ProcessingPool", "ProcessingPool.map", "numpy.heaviside", "numpy.heaviside", "sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_start_idx", "sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_stop_idx", "a_sector.append", "b_sector.append", "numpy.zeros", "range", "sampling.AdaptiveSampler._expected_non_dominated_volume_improvement.gaussian_integral_linear"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_start_idx", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._pareto_grid_map_idx_nodim_to_stop_idx"], ["", "", "def", "_expected_non_dominated_volume_improvement", "(", "self", ",", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", ",", "Y_mu", ",", "Y_sigma", ",", "allow_outliers", "=", "True", ",", "workers", "=", "1", ")", ":", "\n", "        ", "\"\"\"Calculate the expected improvement of the non-dominated Pareto \n        volume.\"\"\"", "\n", "\n", "# Define helper functions", "\n", "theta0", "=", ".5", "\n", "def", "gaussian_integral_linear", "(", "mu", ",", "sigma", ",", "a", ",", "b", ",", "ref", ")", ":", "\n", "            ", "result", "=", "np", ".", "zeros", "(", "mu", ".", "shape", ")", "\n", "mu0", "=", "mu", "[", "sigma", "==", "0", "]", "\n", "mu1", "=", "mu", "[", "sigma", "!=", "0", "]", "\n", "sigma1", "=", "sigma", "[", "sigma", "!=", "0", "]", "\n", "if", "np", ".", "isposinf", "(", "b", ")", ":", "\n", "                ", "result", "[", "sigma", "==", "0", "]", "=", "(", "mu0", "-", "ref", ")", "*", "np", ".", "heaviside", "(", "mu0", "-", "a", ",", "theta0", ")", "\n", "result", "[", "sigma", "!=", "0", "]", "=", "(", "ref", "-", "mu1", ")", "/", "2", "*", "(", "erf", "(", "(", "a", "-", "mu1", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", "-", "1", ")", "+", "sigma", "/", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "*", "(", "np", ".", "exp", "(", "-", "(", "a", "-", "mu1", ")", "**", "2", "/", "(", "2", "*", "sigma1", "**", "2", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "result", "[", "sigma", "==", "0", "]", "=", "(", "mu0", "-", "ref", ")", "*", "np", ".", "heaviside", "(", "b", "-", "mu0", ",", "theta0", ")", "*", "np", ".", "heaviside", "(", "mu0", "-", "a", ",", "theta0", ")", "\n", "result", "[", "sigma", "!=", "0", "]", "=", "(", "ref", "-", "mu1", ")", "/", "2", "*", "(", "erf", "(", "(", "a", "-", "mu1", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", "-", "erf", "(", "(", "b", "-", "mu1", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", ")", "+", "sigma1", "/", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "*", "(", "np", ".", "exp", "(", "-", "(", "a", "-", "mu1", ")", "**", "2", "/", "(", "2", "*", "sigma1", "**", "2", ")", ")", "-", "np", ".", "exp", "(", "-", "(", "b", "-", "mu1", ")", "**", "2", "/", "(", "2", "*", "sigma1", "**", "2", ")", ")", ")", "# TODO: invalid value encountered in multiply", "\n", "", "return", "result", "\n", "", "def", "gaussian_integral_const", "(", "mu", ",", "sigma", ",", "a", ",", "b", ")", ":", "\n", "            ", "result", "=", "np", ".", "zeros", "(", "mu", ".", "shape", ")", "\n", "mu0", "=", "mu", "[", "sigma", "==", "0", "]", "\n", "mu1", "=", "mu", "[", "sigma", "!=", "0", "]", "\n", "sigma1", "=", "sigma", "[", "sigma", "!=", "0", "]", "\n", "result", "[", "sigma", "==", "0", "]", "=", "np", ".", "heaviside", "(", "b", "-", "mu0", ",", "theta0", ")", "*", "np", ".", "heaviside", "(", "mu0", "-", "a", ",", "theta0", ")", "\n", "result", "[", "sigma", "!=", "0", "]", "=", "1", "/", "2", "*", "(", "erf", "(", "(", "b", "-", "mu1", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", "-", "erf", "(", "(", "a", "-", "mu1", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", ")", "# TODO: invalid value encountered in true_divide", "\n", "return", "result", "\n", "\n", "# Setup", "\n", "", "if", "self", ".", "_Y_dim", "!=", "Y_mu", ".", "shape", "[", "1", "]", "or", "Y_grid_scale", ".", "size", "!=", "Y_mu", ".", "shape", "[", "1", "]", "or", "Y_mu", ".", "shape", "[", "1", "]", "!=", "Y_sigma", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "Exception", "(", "\"Invalid dimensions: Y_dim = {}, Y_grid_scale.size = {}, Y_mu.shape = {}, Y_sigma.shape = {}!\"", ".", "format", "(", "self", ".", "_Y_dim", ",", "Y_grid_scale", ".", "size", ",", "Y_mu", ".", "shape", ",", "Y_sigma", ".", "shape", ")", ")", "\n", "", "num_points", "=", "Y_mu", ".", "shape", "[", "0", "]", "\n", "Y_mu", "=", "Y_mu", "/", "Y_grid_scale", "\n", "Y_sigma", "=", "Y_sigma", "/", "Y_grid_scale", "\n", "sector_hit_sigma", "=", "self", ".", "_utility_parameters", "[", "'sector_cutoff'", "]", "\n", "\n", "# Loop function", "\n", "def", "sector_vol", "(", "sector_idx_array_nodim", ")", ":", "\n", "# Volume definition for this sector", "\n", "            ", "sector_vol", "=", "np", ".", "zeros", "(", "num_points", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "if", "Y_grid_dom_func", "(", "sector_idx_array_nodim", ")", ":", "\n", "                ", "return", "sector_vol", "# sector is dominated", "\n", "\n", "# Calculate sectors", "\n", "\n", "# 0) Prepare sector", "\n", "", "a_sector", "=", "[", "]", "\n", "b_sector", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                ", "idx_array_start", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_start_idx", "(", "sector_idx_array_nodim", ",", "d", ")", "\n", "idx_array_stop", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_stop_idx", "(", "self", ".", "_Y_dim", ",", "sector_idx_array_nodim", ",", "d", ")", "\n", "a_sector", ".", "append", "(", "Y_grid_map_func", "(", "idx_array_start", ")", ")", "\n", "b_sector", ".", "append", "(", "Y_grid_map_func", "(", "idx_array_stop", ")", ")", "\n", "\n", "# 1) New method: check sector contribution and skip if neglectable", "\n", "", "if", "sector_hit_sigma", ">", "0", ":", "\n", "                ", "sector_distances", "=", "np", ".", "zeros", "(", "(", "num_points", ",", "self", ".", "_Y_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# distance in each dimension", "\n", "for", "d", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                    ", "outlier_idx", "=", "np", ".", "logical_or", "(", "a_sector", "[", "d", "]", ">", "Y_mu", "[", ":", ",", "d", "]", ",", "Y_mu", "[", ":", ",", "d", "]", ">", "b_sector", "[", "d", "]", ")", "# lies not within a and b limits", "\n", "border_distances", "=", "np", ".", "concatenate", "(", "(", "np", ".", "abs", "(", "a_sector", "[", "d", "]", "-", "Y_mu", "[", ":", ",", "d", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "np", ".", "abs", "(", "b_sector", "[", "d", "]", "-", "Y_mu", "[", ":", ",", "d", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "border_distance", "=", "np", ".", "min", "(", "border_distances", ",", "axis", "=", "1", ")", "\n", "sector_distances", "[", "outlier_idx", ",", "d", "]", "=", "border_distance", "[", "outlier_idx", "]", "\n", "#sector_hit_idx = np.all(sector_hit_sigma*Y_sigma > sector_distances, axis=1) # alternative box method", "\n", "", "Y_sigma", "[", "Y_sigma", "==", "0", "]", "=", "np", ".", "inf", "# handle division by zero; TODO: verify this approach", "\n", "sector_hit_idx", "=", "np", ".", "linalg", ".", "norm", "(", "sector_distances", "/", "Y_sigma", ",", "axis", "=", "1", ",", "ord", "=", "self", ".", "_Y_dim", ")", "<", "sector_hit_sigma", "# ellipsoid method", "\n", "if", "not", "np", ".", "any", "(", "sector_hit_idx", ")", ":", "\n", "                    ", "return", "sector_vol", "# skip sector if no Y_mu+-Y_sigma hits the sector (Note: this introduces an uncertainty)", "\n", "\n", "# 2) Active sector calculation", "\n", "", "", "active_sector_vol", "=", "np", ".", "ones", "(", "num_points", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "d", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                ", "pv", "=", "gaussian_integral_linear", "(", "Y_mu", "[", ":", ",", "d", "]", ",", "Y_sigma", "[", ":", ",", "d", "]", ",", "a_sector", "[", "d", "]", ",", "b_sector", "[", "d", "]", ",", "a_sector", "[", "d", "]", ")", "\n", "active_sector_vol", "*=", "pv", "\n", "", "sector_vol", "+=", "active_sector_vol", "\n", "\n", "# 3) Subsectors calculation", "\n", "for", "sub_sector_idx_array_nodim", "in", "Y_grid_idx_iter_func", "(", ")", ":", "\n", "                ", "if", "Y_grid_dom_func", "(", "sub_sector_idx_array_nodim", ")", "or", "np", ".", "any", "(", "np", ".", "array", "(", "sub_sector_idx_array_nodim", ")", ">", "np", ".", "array", "(", "sector_idx_array_nodim", ")", ")", "or", "np", ".", "all", "(", "np", ".", "array", "(", "sub_sector_idx_array_nodim", ")", "==", "np", ".", "array", "(", "sector_idx_array_nodim", ")", ")", ":", "\n", "                    ", "continue", "# subsector is either dominated or not a subsector in the first place", "\n", "", "active_sector_vol", "=", "np", ".", "ones", "(", "num_points", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "d", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                    ", "idx_array_start", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_start_idx", "(", "sub_sector_idx_array_nodim", ",", "d", ")", "\n", "a", "=", "Y_grid_map_func", "(", "idx_array_start", ")", "\n", "if", "sub_sector_idx_array_nodim", "[", "d", "]", "==", "sector_idx_array_nodim", "[", "d", "]", ":", "\n", "                        ", "pv", "=", "gaussian_integral_linear", "(", "Y_mu", "[", ":", ",", "d", "]", ",", "Y_sigma", "[", ":", ",", "d", "]", ",", "a_sector", "[", "d", "]", ",", "b_sector", "[", "d", "]", ",", "a", ")", "\n", "", "else", ":", "\n", "                        ", "idx_array_stop", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_stop_idx", "(", "self", ".", "_Y_dim", ",", "sub_sector_idx_array_nodim", ",", "d", ")", "\n", "b", "=", "Y_grid_map_func", "(", "idx_array_stop", ")", "\n", "pv", "=", "(", "b", "-", "a", ")", "*", "gaussian_integral_const", "(", "Y_mu", "[", ":", ",", "d", "]", ",", "Y_sigma", "[", ":", ",", "d", "]", ",", "a_sector", "[", "d", "]", ",", "b_sector", "[", "d", "]", ")", "\n", "", "active_sector_vol", "*=", "pv", "\n", "", "sector_vol", "+=", "active_sector_vol", "\n", "\n", "# Return gained sector volume", "\n", "", "return", "sector_vol", "\n", "\n", "# Check for outliers (i.e. predicted expecation value worse than Y_ref) if requested", "\n", "", "if", "not", "allow_outliers", ":", "\n", "            ", "Y_ref", "=", "self", ".", "_Y_ref", "/", "Y_grid_scale", "\n", "if", "np", ".", "any", "(", "Y_mu", "<", "Y_ref", ")", ":", "\n", "                ", "raise", "Exception", "(", "\"Invalid prediction (Y_mu < Y_ref): {} < {} (with rescaling {})!\"", ".", "format", "(", "Y_mu", "*", "Y_grid_scale", ",", "Y_ref", "*", "Y_grid_scale", ",", "Y_grid_scale", ")", ")", "\n", "\n", "# Calculate volume by traversing each sector of the grid using the loop function", "\n", "# Use either sequential or parallel computing", "\n", "", "", "if", "workers", "==", "1", "or", "not", "__POOL_AVAILABLE__", ":", "\n", "            ", "sector_vol_list", "=", "np", ".", "zeros", "(", "(", "Y_grid_size", ",", "num_points", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "grid_idx", ",", "sector_idx_array_nodim", "in", "enumerate", "(", "Y_grid_idx_iter_func", "(", ")", ")", ":", "\n", "                ", "sector_vol_list", "[", "grid_idx", ",", ":", "]", "=", "sector_vol", "(", "sector_idx_array_nodim", ")", "\n", "", "", "else", ":", "\n", "            ", "pool", "=", "ProcessingPool", "(", "None", "if", "workers", "==", "-", "1", "else", "workers", ")", "\n", "sector_vol_list", "=", "pool", ".", "map", "(", "sector_vol", ",", "Y_grid_idx_iter_func", "(", ")", ")", "\n", "", "non_dominated_volume", "=", "np", ".", "sum", "(", "sector_vol_list", ",", "axis", "=", "0", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "return", "non_dominated_volume", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._total_dominated_volume": [[704, 734], ["numpy.sum", "Y_grid_dom_func", "numpy.zeros", "enumerate", "ProcessingPool", "ProcessingPool.map", "numpy.prod", "range", "Y_grid_idx_iter_func", "sampling.AdaptiveSampler._total_dominated_volume.sector_dom_vol"], "methods", ["None"], ["", "def", "_total_dominated_volume", "(", "self", ",", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", ",", "workers", "=", "1", ")", ":", "\n", "        ", "\"\"\"Calculate the total Pareto-dominated volume. Note: Return total \n        unscaled dominated volume (i.e., with removed scaling).\"\"\"", "\n", "\n", "# Loop function", "\n", "def", "sector_dom_vol", "(", "idx_array_nodim", ")", ":", "\n", "            ", "if", "Y_grid_dom_func", "(", "idx_array_nodim", ")", ":", "# sector only contributes if it is dominated", "\n", "                ", "sector_dominated_volume", "=", "1", "\n", "for", "d", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                    ", "idx_array_start", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_start_idx", "(", "idx_array_nodim", ",", "d", ")", "\n", "idx_array_stop", "=", "self", ".", "_pareto_grid_map_idx_nodim_to_stop_idx", "(", "self", ".", "_Y_dim", ",", "idx_array_nodim", ",", "d", ")", "\n", "a", "=", "Y_grid_map_func", "(", "idx_array_start", ")", "\n", "b", "=", "Y_grid_map_func", "(", "idx_array_stop", ")", "\n", "sector_dominated_volume", "*=", "(", "b", "-", "a", ")", "\n", "", "return", "sector_dominated_volume", "\n", "", "return", "0", "\n", "\n", "# Calculate total dominanted volume by traversing each sector of the grid using the loop function", "\n", "# Use either sequential or parallel computing", "\n", "", "if", "workers", "==", "1", "or", "not", "__POOL_AVAILABLE__", ":", "\n", "            ", "sector_dom_vol_list", "=", "np", ".", "zeros", "(", "Y_grid_size", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "grid_idx", ",", "idx_array_nodim", "in", "enumerate", "(", "Y_grid_idx_iter_func", "(", ")", ")", ":", "\n", "                ", "sector_dom_vol_list", "[", "grid_idx", "]", "=", "sector_dom_vol", "(", "idx_array_nodim", ")", "\n", "", "", "else", ":", "\n", "            ", "pool", "=", "ProcessingPool", "(", "None", "if", "workers", "==", "-", "1", "else", "workers", ")", "\n", "sector_dom_vol_list", "=", "pool", ".", "map", "(", "sector_dom_vol", ",", "Y_grid_idx_iter_func", "(", ")", ")", "\n", "", "total_dominated_volume", "=", "np", ".", "sum", "(", "sector_dom_vol_list", ",", "axis", "=", "0", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# Rescale and return result", "\n", "return", "total_dominated_volume", "*", "np", ".", "prod", "(", "Y_grid_scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._pareto_not_dominated_probability": [[735, 794], ["numpy.zeros", "numpy.heaviside", "numpy.zeros", "numpy.heaviside", "ProcessingPool", "numpy.prod", "numpy.zeros", "range", "numpy.prod", "numpy.ones", "numpy.zeros", "numpy.zeros", "range", "numpy.sum", "scipy.special.erf", "scipy.special.erf", "itertools.combinations", "sampling.AdaptiveSampler._pareto_not_dominated_probability.p_nd"], "methods", ["None"], ["", "def", "_pareto_not_dominated_probability", "(", "self", ",", "Y_pareto", ",", "Y_mu", ",", "Y_sigma", ",", "workers", "=", "1", ")", ":", "\n", "        ", "\"\"\"Calculate probability of being not Pareto-dominated. Note: Assume \n        maximization. Assume a ``Y_estimator`` with Gaussian probability \n        distribution.\"\"\"", "\n", "\n", "# Define helper functions", "\n", "theta0", "=", ".5", "\n", "def", "p_nd", "(", "mu", ",", "sigma", ",", "y", ")", ":", "\n", "            ", "result", "=", "np", ".", "zeros", "(", "mu", ".", "shape", ")", "\n", "mu0", "=", "mu", "[", "sigma", "==", "0", "]", "\n", "mu1", "=", "mu", "[", "sigma", "!=", "0", "]", "\n", "sigma1", "=", "sigma", "[", "sigma", "!=", "0", "]", "\n", "result", "[", "sigma", "==", "0", "]", "=", "np", ".", "heaviside", "(", "y", "-", "mu0", ",", "theta0", ")", "\n", "result", "[", "sigma", "!=", "0", "]", "=", "(", "1", "+", "erf", "(", "(", "mu1", "-", "y", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", ")", "/", "2", "\n", "return", "result", "\n", "", "def", "p_d", "(", "mu", ",", "sigma", ",", "y", ")", ":", "\n", "            ", "result", "=", "np", ".", "zeros", "(", "mu", ".", "shape", ")", "\n", "mu0", "=", "mu", "[", "sigma", "==", "0", "]", "\n", "mu1", "=", "mu", "[", "sigma", "!=", "0", "]", "\n", "sigma1", "=", "sigma", "[", "sigma", "!=", "0", "]", "\n", "result", "[", "sigma", "==", "0", "]", "=", "np", ".", "heaviside", "(", "mu0", "-", "y", ",", "theta0", ")", "\n", "result", "[", "sigma", "!=", "0", "]", "=", "(", "1", "-", "erf", "(", "(", "mu1", "-", "y", ")", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma1", ")", ")", ")", "/", "2", "\n", "return", "result", "\n", "\n", "# Setup", "\n", "", "num_points", "=", "Y_mu", ".", "shape", "[", "0", "]", "\n", "num_pareto", "=", "Y_pareto", ".", "shape", "[", "0", "]", "\n", "if", "workers", "!=", "1", "and", "__POOL_AVAILABLE__", ":", "\n", "            ", "pool", "=", "ProcessingPool", "(", "None", "if", "workers", "==", "-", "1", "else", "workers", ")", "\n", "\n", "# Loop function core", "\n", "", "def", "probability_sum", "(", "index_list", ",", "probability_d", ",", "probability_nd", ")", ":", "\n", "            ", "return", "np", ".", "prod", "(", "[", "probability_d", "[", ":", ",", "-", "i", "-", "1", "]", "if", "i", "<", "0", "else", "probability_nd", "[", ":", ",", "i", "-", "1", "]", "for", "i", "in", "index_list", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# Non-vanishing pareto set", "\n", "", "if", "num_pareto", ">", "0", ":", "\n", "            ", "probability_list", "=", "np", ".", "zeros", "(", "(", "num_pareto", ",", "num_points", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "index_lists", "=", "[", "x", "for", "x", "in", "combinations", "(", "np", ".", "concatenate", "(", "(", "np", ".", "linspace", "(", "1", ",", "self", ".", "_Y_dim", ",", "self", ".", "_Y_dim", ",", "dtype", "=", "np", ".", "int32", ")", ",", "np", ".", "linspace", "(", "-", "1", ",", "-", "self", ".", "_Y_dim", ",", "self", ".", "_Y_dim", ",", "dtype", "=", "np", ".", "int32", ")", ")", ")", ",", "r", "=", "self", ".", "_Y_dim", ")", "if", "np", ".", "any", "(", "np", ".", "array", "(", "x", ")", ">", "0", ")", "and", "np", ".", "unique", "(", "np", ".", "abs", "(", "x", ")", ")", ".", "size", "==", "len", "(", "x", ")", "]", "\n", "for", "y_idx", "in", "range", "(", "num_pareto", ")", ":", "\n", "                ", "probability_nd", "=", "np", ".", "zeros", "(", "(", "num_points", ",", "self", ".", "_Y_dim", ")", ")", "\n", "probability_d", "=", "np", ".", "zeros", "(", "(", "num_points", ",", "self", ".", "_Y_dim", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "_Y_dim", ")", ":", "\n", "                    ", "probability_nd", "[", ":", ",", "i", "]", "=", "p_nd", "(", "Y_mu", "[", ":", ",", "i", "]", ",", "Y_sigma", "[", ":", ",", "i", "]", ",", "Y_pareto", "[", "y_idx", ",", "i", "]", ")", "\n", "probability_d", "[", ":", ",", "i", "]", "=", "p_d", "(", "Y_mu", "[", ":", ",", "i", "]", ",", "Y_sigma", "[", ":", ",", "i", "]", ",", "Y_pareto", "[", "y_idx", ",", "i", "]", ")", "\n", "", "if", "workers", "==", "1", "or", "not", "__POOL_AVAILABLE__", ":", "\n", "                    ", "p_sum_list", "=", "np", ".", "zeros", "(", "(", "len", "(", "index_lists", ")", ",", "num_points", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "idx", ",", "index_list", "in", "enumerate", "(", "index_lists", ")", ":", "\n", "                        ", "p_sum_list", "[", "idx", ",", ":", "]", "=", "probability_sum", "(", "index_list", ",", "probability_d", ",", "probability_nd", ")", "\n", "", "", "else", ":", "\n", "                    ", "loop_fun", "=", "lambda", "index_list", ":", "probability_sum", "(", "index_list", ",", "probability_d", ",", "probability_nd", ")", "\n", "p_sum_list", "=", "pool", ".", "map", "(", "loop_fun", ",", "index_lists", ")", "\n", "", "probability_list", "[", "y_idx", ",", ":", "]", "=", "np", ".", "sum", "(", "p_sum_list", ",", "axis", "=", "0", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "", "probability", "=", "np", ".", "prod", "(", "probability_list", ",", "axis", "=", "0", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# Vanishing pareto set (is not used since Y_mu, Y_sigma cannot be retrieved without data)", "\n", "", "else", ":", "\n", "            ", "probability", "=", "np", ".", "ones", "(", "num_points", ")", "\n", "\n", "", "return", "probability", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._probability_feasible": [[795, 800], ["sampling.AdaptiveSampler._f_model.predict_true_proba"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict_true_proba"], ["", "def", "_probability_feasible", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Prediction of the feasibility probability using the previously \n        trained classifier.\"\"\"", "\n", "\n", "return", "self", ".", "_f_model", ".", "predict_true_proba", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._optutility_func": [[801, 876], ["numpy.asarray().reshape", "sampling.AdaptiveSampler._optutility_func.clip"], "methods", ["None"], ["", "def", "_optutility_func", "(", "self", ",", "X", ",", "X_r_explored_scaled", ",", "Y_pareto", ",", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", ",", "repulsion_transformation_func", ",", "repulsion_distance_func", ",", "workers", "=", "1", ")", ":", "\n", "        ", "\"\"\"Base function for the utility calculation. Note: Assume \n        maximization. Assume a ``Y_estimator`` with Gaussian probability \n        distribution. Assume a single sample ``X``.\"\"\"", "\n", "\n", "# options", "\n", "tol", "=", "1e-5", "\n", "allow_outliers", "=", "True", "\n", "catch_nan_input", "=", "True", "\n", "\n", "# setup", "\n", "X", "=", "np", ".", "asarray", "(", "X", ")", ".", "reshape", "(", "1", ",", "self", ".", "_X_dim", ")", "\n", "if", "catch_nan_input", "and", "np", ".", "any", "(", "np", ".", "isnan", "(", "X", ")", ")", ":", "\n", "            ", "return", "np", ".", "array", "(", "0", ")", ".", "ravel", "(", ")", "\n", "", "num_points", "=", "X", ".", "shape", "[", "0", "]", "\n", "s", "=", "self", ".", "_utility_parameters", "[", "'entropy_weight'", "]", "\n", "o", "=", "self", ".", "_utility_parameters", "[", "'optimization_weight'", "]", "\n", "r", "=", "self", ".", "_utility_parameters", "[", "'repulsion_weight'", "]", "\n", "evi_gamma", "=", "self", ".", "_utility_parameters", "[", "'evi_gamma'", "]", "\n", "\n", "# clipping wrapper function", "\n", "def", "clip", "(", "value", ",", "tol", ",", "name", ")", ":", "\n", "            ", "if", "np", ".", "any", "(", "value", "<", "0", "-", "tol", ")", "or", "np", ".", "any", "(", "value", ">", "1", "+", "tol", ")", ":", "\n", "                ", "np", ".", "set_printoptions", "(", "suppress", "=", "True", ",", "precision", "=", "10", ")", "\n", "raise", "Exception", "(", "\"incorrect value for '{}': {} +- {}.\"", ".", "format", "(", "name", ",", "value", ",", "tol", ")", ")", "\n", "", "return", "np", ".", "clip", "(", "value", ",", "0", ",", "1", ")", "\n", "\n", "# calculate", "\n", "", "if", "self", ".", "_Y_model_is_ready", ":", "\n", "            ", "try", ":", "\n", "                ", "Y_mu", ",", "Y_sigma", "=", "self", ".", "_Y_model", ".", "predict", "(", "X", ",", "return_std", "=", "True", ")", "\n", "Y_mu", "=", "Y_mu", ".", "reshape", "(", "1", ",", "self", ".", "_Y_dim", ")", "\n", "Y_sigma", "=", "Y_sigma", ".", "reshape", "(", "1", ",", "self", ".", "_Y_dim", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "raise", "Exception", "(", "\"Estimator cannot predict mu, sigma: '{}'.\"", ".", "format", "(", "e", ")", ")", "\n", "", "if", "o", "!=", "0", ":", "\n", "                ", "expected_vol", "=", "self", ".", "_expected_non_dominated_volume_improvement", "(", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", ",", "Y_mu", ",", "Y_sigma", ",", "allow_outliers", "=", "allow_outliers", ",", "workers", "=", "workers", ")", "# [0,inf]", "\n", "", "else", ":", "\n", "                ", "expected_vol", "=", "np", ".", "zeros", "(", "num_points", ")", "# values not needed", "\n", "", "if", "s", "!=", "0", "or", "r", "!=", "0", ":", "\n", "                ", "p_not_dominated", "=", "self", ".", "_pareto_not_dominated_probability", "(", "Y_pareto", ",", "Y_mu", ",", "Y_sigma", ",", "workers", "=", "workers", ")", "# [0,1]", "\n", "", "else", ":", "\n", "                ", "p_not_dominated", "=", "np", ".", "zeros", "(", "num_points", ")", "# values not needed", "\n", "", "", "else", ":", "\n", "            ", "expected_vol", "=", "np", ".", "zeros", "(", "num_points", ")", "# no improvement without prediction", "\n", "p_not_dominated", "=", "np", ".", "ones", "(", "num_points", ")", "# nothing is dominated", "\n", "", "if", "evi_gamma", "is", "not", "None", ":", "\n", "            ", "expected_vol_gain", "=", "1", "-", "np", ".", "exp", "(", "-", "evi_gamma", "*", "np", ".", "clip", "(", "expected_vol", ",", "0", ",", "np", ".", "inf", ")", ")", "# [0,1]", "\n", "", "else", ":", "\n", "            ", "expected_vol_gain", "=", "np", ".", "clip", "(", "expected_vol", ",", "0", ",", "np", ".", "inf", ")", "# DEBUG [0,inf]", "\n", "", "try", ":", "\n", "            ", "p_feasible", "=", "self", ".", "_probability_feasible", "(", "X", ")", "# [0,1]", "\n", "entropy", "=", "-", "np", ".", "sum", "(", "[", "p", "*", "np", ".", "log", "(", "p", ")", "if", "(", "p", ">", "0", ")", "else", "0.0", "for", "p", "in", "p_feasible", "]", ")", "/", "np", ".", "log", "(", "2", ")", "# [0,1]", "\n", "", "except", ":", "\n", "            ", "p_feasible", "=", "1", "# assume total feasibility if no prediction is available", "\n", "entropy", "=", ".5", "\n", "", "if", "r", "!=", "0", ":", "\n", "            ", "if", "X_r_explored_scaled", ".", "size", ">", "0", ":", "\n", "                ", "X_r_scaled", "=", "repulsion_transformation_func", "(", "X", ")", "\n", "min_distance", "=", "np", ".", "array", "(", "[", "np", ".", "min", "(", "repulsion_distance_func", "(", "X_r_scaled", "[", "idx", ",", ":", "]", ",", "X_r_explored_scaled", ")", ")", "for", "idx", "in", "range", "(", "num_points", ")", "]", ")", "# [0,1]", "\n", "repulsion", "=", "min_distance", "#[0,1]", "\n", "", "else", ":", "\n", "                ", "repulsion", "=", "1", "# no distance available", "\n", "", "", "else", ":", "\n", "            ", "repulsion", "=", "1", "# values not needed", "\n", "", "S", "=", "entropy", "*", "p_not_dominated", "# [0,1]", "\n", "O", "=", "expected_vol_gain", "*", "p_feasible", "# [0,1]", "\n", "R", "=", "repulsion", "*", "p_not_dominated", "# [0,1]", "\n", "\n", "# finalize results", "\n", "S", "=", "clip", "(", "S", ",", "tol", ",", "\"S\"", ")", "\n", "O", "=", "clip", "(", "O", ",", "tol", ",", "\"O\"", ")", "\n", "R", "=", "clip", "(", "R", ",", "tol", ",", "\"R\"", ")", "\n", "utility", "=", "(", "s", "*", "S", "+", "o", "*", "O", "+", "r", "*", "R", ")", "/", "(", "s", "+", "o", "+", "r", ")", "\n", "return", "np", ".", "array", "(", "utility", ")", ".", "ravel", "(", ")", "# [0,1]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._opt_func_provider": [[877, 932], ["numpy.array", "numpy.array", "callable", "numpy.concatenate", "sampling.AdaptiveSampler._opt_func_provider.repulsion_transformation_func"], "methods", ["None"], ["", "def", "_opt_func_provider", "(", "self", ",", "X", ",", "Y", ",", "f", ",", "X_virtual", ",", "Y_virtual", ",", "f_virtual", ")", ":", "\n", "        ", "\"\"\"Provide a utility function for the adaptive sampling decision.\"\"\"", "\n", "\n", "# Options", "\n", "cut_ref_violation", "=", "True", "# set to False for debugging", "\n", "grid_scaling", "=", "True", "\n", "\n", "# Prepare", "\n", "data_min", "=", "np", ".", "array", "(", "[", "limits", "[", "0", "]", "for", "limits", "in", "self", ".", "_X_limits", "]", ")", "\n", "data_max", "=", "np", ".", "array", "(", "[", "limits", "[", "1", "]", "for", "limits", "in", "self", ".", "_X_limits", "]", ")", "\n", "feature_range", "=", "[", "0", ",", "1", "]", "\n", "X_r_scale", "=", "(", "feature_range", "[", "1", "]", "-", "feature_range", "[", "0", "]", ")", "/", "(", "data_max", "-", "data_min", ")", "\n", "X_r_shift", "=", "feature_range", "[", "0", "]", "-", "data_min", "*", "X_r_scale", "\n", "def", "repulsion_transformation_func", "(", "X", ")", ":", "\n", "            ", "return", "X", "*", "X_r_scale", "+", "X_r_shift", "\n", "", "if", "X_virtual", ".", "size", ">", "0", ":", "\n", "            ", "X_explored", "=", "np", ".", "concatenate", "(", "(", "X", ",", "X_virtual", ")", ")", "\n", "", "else", ":", "\n", "            ", "X_explored", "=", "X", "\n", "", "if", "X_explored", ".", "size", ">", "0", ":", "\n", "           ", "X_r_explored_scaled", "=", "repulsion_transformation_func", "(", "X_explored", ")", "\n", "", "else", ":", "\n", "           ", "X_r_explored_scaled", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "self", ".", "_dtype_X", ")", ".", "reshape", "(", "0", ",", "self", ".", "_X_dim", ")", "\n", "", "if", "Y_virtual", ".", "size", ">", "0", ":", "\n", "            ", "Y_total", "=", "np", ".", "concatenate", "(", "(", "Y", ",", "Y_virtual", ")", ")", "\n", "", "else", ":", "\n", "            ", "Y_total", "=", "Y", "\n", "", "if", "f_virtual", ".", "size", ">", "0", ":", "\n", "            ", "f_total", "=", "np", ".", "concatenate", "(", "(", "f", ",", "f_virtual", ")", ")", "\n", "", "else", ":", "\n", "            ", "f_total", "=", "f", "\n", "", "Y_feasible", "=", "Y_total", "[", "f_total", "!=", "self", ".", "_f_values_dict", "[", "False", "]", "]", "\n", "if", "Y_feasible", ".", "size", ">", "0", ":", "\n", "            ", "Y_pareto", "=", "Y_feasible", "[", "self", ".", "_is_pareto_efficient", "(", "Y_feasible", ")", ",", ":", "]", "\n", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", "=", "self", ".", "_create_pareto_grid", "(", "self", ".", "_grid_creator_func", ",", "Y_pareto", ",", "self", ".", "_Y_ref", ",", "self", ".", "_Y_dim", ",", "cut_ref_violation", "=", "cut_ref_violation", ",", "scale", "=", "grid_scaling", ")", "\n", "", "else", ":", "\n", "            ", "Y_pareto", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "self", ".", "_dtype_Y", ")", ".", "reshape", "(", "0", ",", "self", ".", "_Y_dim", ")", "\n", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", "=", "None", ",", "None", ",", "None", ",", "None", ",", "None", "# not used", "\n", "", "repulsion_gamma", "=", "self", ".", "_utility_parameters", "[", "'repulsion_gamma'", "]", "\n", "if", "callable", "(", "self", ".", "_utility_parameters", "[", "'repulsion_distance_func'", "]", ")", ":", "\n", "            ", "repulsion_distance_func", "=", "self", ".", "_utility_parameters", "[", "'repulsion_distance_func'", "]", "\n", "", "elif", "self", ".", "_utility_parameters", "[", "'repulsion_distance_func'", "]", "==", "\"default\"", ":", "\n", "            ", "min_limits_point_scaled", "=", "repulsion_transformation_func", "(", "np", ".", "min", "(", "self", ".", "_X_limits", ",", "axis", "=", "1", ")", ".", "reshape", "(", "1", ",", "self", ".", "_X_dim", ")", ")", "\n", "max_limits_point_scaled", "=", "repulsion_transformation_func", "(", "np", ".", "max", "(", "self", ".", "_X_limits", ",", "axis", "=", "1", ")", ".", "reshape", "(", "1", ",", "self", ".", "_X_dim", ")", ")", "\n", "maximum_distance", "=", "np", ".", "linalg", ".", "norm", "(", "min_limits_point_scaled", "-", "max_limits_point_scaled", ")", "**", "2", "\n", "def", "default_repulsion_distance_func", "(", "x", ",", "y", ")", ":", "\n", "# note: distance funct for step (2), where: (1) perform scaling of x and y with X_r_scaler, (2) mapping: 1 - e(-gamma||x-y||^2) with scaled x and scaled y    ", "\n", "                ", "return", "(", "1", "-", "np", ".", "exp", "(", "-", "repulsion_gamma", "*", "np", ".", "linalg", ".", "norm", "(", "x", "-", "y", ",", "axis", "=", "-", "1", ")", "**", "2", ")", ")", "/", "(", "1", "-", "np", ".", "exp", "(", "-", "repulsion_gamma", "*", "maximum_distance", ")", ")", "#[0,1]", "\n", "", "repulsion_distance_func", "=", "default_repulsion_distance_func", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"repulsion distance function unspecified: '{}'\"", ".", "format", "(", "self", ".", "_utility_parameters", "[", "'repulsion_distance_func'", "]", ")", ")", "\n", "\n", "# Finish", "\n", "", "opt_func", "=", "lambda", "X", ",", "workers", ":", "-", "self", ".", "_optutility_func", "(", "X", ",", "X_r_explored_scaled", ",", "Y_pareto", ",", "Y_grid_idx_iter_func", ",", "Y_grid_map_func", ",", "Y_grid_dom_func", ",", "Y_grid_scale", ",", "Y_grid_size", ",", "repulsion_transformation_func", ",", "repulsion_distance_func", ",", "workers", ")", "# mind the negative sign for minimization", "\n", "return", "opt_func", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._sampling_decision": [[933, 978], ["sampling.AdaptiveSampler._rng.randint", "numpy.random.seed", "scipy.optimize.differential_evolution", "numpy.round", "numpy.array", "dict", "numpy.random.seed", "scipy.optimize.minimize", "numpy.array().reshape", "numpy.all", "numpy.all", "Exception", "zip", "numpy.iinfo", "ProcessingPool", "numpy.any", "numpy.copy", "numpy.array", "numpy.isnan"], "methods", ["None"], ["", "def", "_sampling_decision", "(", "self", ",", "opt_func", ")", ":", "\n", "        ", "\"\"\"Minimize ``opt_func`` to determine a single adaptive sampling \n        suggestion.\"\"\"", "\n", "\n", "# TODO: provide alternative optimization strategies", "\n", "\n", "bounds", "=", "[", "(", "l", ",", "u", ")", "for", "(", "l", ",", "u", ")", "in", "zip", "(", "[", "limits", "[", "0", "]", "for", "limits", "in", "self", ".", "_X_limits", "]", ",", "[", "limits", "[", "1", "]", "for", "limits", "in", "self", ".", "_X_limits", "]", ")", "]", "\n", "seed", "=", "self", ".", "_rng", ".", "randint", "(", "0", ",", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ")", "\n", "x_precision", "=", "12", "# try to omit rounding errors by fixing the precision of the result (e.g., bounds can be violated due to rounding errors)", "\n", "popsize", "=", "self", ".", "_decision_parameters", "[", "'popsize'", "]", "\n", "maxiter", "=", "self", ".", "_decision_parameters", "[", "'maxiter'", "]", "\n", "tol", "=", "self", ".", "_decision_parameters", "[", "'tol'", "]", "\n", "atol", "=", "self", ".", "_decision_parameters", "[", "'atol'", "]", "\n", "polish", "=", "self", ".", "_decision_parameters", "[", "'polish'", "]", "\n", "polish_extratol", "=", "self", ".", "_decision_parameters", "[", "'polish_extratol'", "]", "\n", "polish_maxfun", "=", "self", ".", "_decision_parameters", "[", "'polish_maxfun'", "]", "\n", "workers", "=", "self", ".", "_decision_parameters", "[", "'de_workers'", "]", "\n", "polish_workers", "=", "self", ".", "_decision_parameters", "[", "'polish_workers'", "]", "\n", "if", "workers", "==", "1", "or", "not", "__POOL_AVAILABLE__", ":", "\n", "            ", "worker_runner", "=", "1", "\n", "", "else", ":", "\n", "            ", "worker_runner", "=", "ProcessingPool", "(", "None", "if", "workers", "==", "-", "1", "else", "workers", ")", ".", "map", "\n", "", "updating", "=", "'deferred'", "# makes multi-worker result compatible with single worker result (originally 'immediate' for workers=1)", "\n", "args", "=", "(", "1", ",", ")", "# use 1 worker to evaluate opt_func", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "opt_result", "=", "optimize", ".", "differential_evolution", "(", "func", "=", "opt_func", ",", "bounds", "=", "bounds", ",", "args", "=", "args", ",", "popsize", "=", "popsize", ",", "maxiter", "=", "maxiter", ",", "tol", "=", "tol", ",", "atol", "=", "atol", ",", "polish", "=", "False", ",", "seed", "=", "seed", ",", "updating", "=", "updating", ",", "workers", "=", "worker_runner", ")", "\n", "if", "polish", ":", "\n", "            ", "polish_method", "=", "'L-BFGS-B'", "\n", "polish_options", "=", "dict", "(", "ftol", "=", "polish_extratol", "*", "tol", ",", "maxfun", "=", "polish_maxfun", ")", "# default for direct polish from optimize.differential_evolution: ftol = 2.220446049250313e-09, maxfun = 15000", "\n", "polished_args", "=", "(", "polish_workers", ",", ")", "# use 1 or more workers to evaluate opt_func", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "polished_opt_result", "=", "optimize", ".", "minimize", "(", "fun", "=", "opt_func", ",", "x0", "=", "np", ".", "copy", "(", "opt_result", ".", "x", ")", ",", "args", "=", "polished_args", ",", "method", "=", "polish_method", ",", "bounds", "=", "bounds", ",", "options", "=", "polish_options", ")", "\n", "opt_result", ".", "nfev", "+=", "polished_opt_result", ".", "nfev", "\n", "if", "polished_opt_result", ".", "fun", "<", "opt_result", ".", "fun", ":", "\n", "                ", "opt_result", ".", "fun", "=", "polished_opt_result", ".", "fun", "\n", "opt_result", ".", "x", "=", "polished_opt_result", ".", "x", "\n", "opt_result", ".", "jac", "=", "polished_opt_result", ".", "jac", "\n", "", "", "else", ":", "\n", "            ", "polished_opt_result", "=", "None", "# for consistency in exception only", "\n", "", "x", "=", "np", ".", "round", "(", "np", ".", "array", "(", "opt_result", ".", "x", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "x_precision", ")", "\n", "bounds", "=", "np", ".", "array", "(", "bounds", ")", "\n", "if", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "x", ")", ")", "and", "np", ".", "all", "(", "x", ">=", "bounds", "[", ":", ",", "0", "]", ")", "and", "np", ".", "all", "(", "x", "<=", "bounds", "[", ":", ",", "1", "]", ")", ":", "# valid if x is not nan and lies within bounds", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Sampling decision failed: x = {}, bounds = {}, opt_result = {}, polished_opt_result = {}!\"", ".", "format", "(", "x", ",", "bounds", ",", "opt_result", ",", "polished_opt_result", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_simulation": [[979, 991], ["time.time", "sampling.AdaptiveSampler._simulation_func", "numpy.array", "numpy.array", "time.time", "sampling.AdaptiveSampler._convert_Y", "sampling.AdaptiveSampler._convert_f", "numpy.logical_or"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_Y", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_f"], ["", "", "def", "_evaluate_simulation", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Evaluate the goal function and the binary feasibility of one or \n        more features ``X`` by executing ``_simulation_func``. Also measure \n        the required calculation time.\"\"\"", "\n", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "Y", ",", "f", "=", "self", ".", "_simulation_func", "(", "X", ",", "**", "self", ".", "_kwargs", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "-", "t", "\n", "Y", "=", "np", ".", "array", "(", "Y", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "f", "=", "np", ".", "array", "(", "f", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "Y", "[", "np", ".", "logical_or", "(", "f", "==", "self", ".", "_f_values_dict", "[", "False", "]", ",", "f", "==", "np", ".", "nan", ")", "]", "=", "np", ".", "nan", "\n", "return", "self", ".", "_convert_Y", "(", "Y", ")", ",", "self", ".", "_convert_f", "(", "f", ")", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._update_estimator": [[992, 1007], ["sampling.AdaptiveSampler._f_model.fit", "sampling.AdaptiveSampler._Y_model.fit"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.fit"], ["", "def", "_update_estimator", "(", "self", ",", "X", ",", "Y", ",", "f", ")", ":", "\n", "        ", "\"\"\"Update the internal estimators for the goal function (regressor) \n        and the binary feasibility (classifier).\"\"\"", "\n", "\n", "if", "self", ".", "_update_Y_estimator_flag", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "_Y_model", ".", "fit", "(", "X", "[", "f", "!=", "self", ".", "_f_values_dict", "[", "False", "]", "]", ",", "Y", "[", "f", "!=", "self", ".", "_f_values_dict", "[", "False", "]", "]", ")", "\n", "self", ".", "_Y_model_is_ready", "=", "True", "\n", "", "except", ":", "\n", "                ", "self", ".", "_Y_model_is_ready", "=", "False", "\n", "", "", "try", ":", "\n", "            ", "self", ".", "_f_model", ".", "fit", "(", "X", ",", "f", ")", "\n", "self", ".", "_f_model_is_ready", "=", "True", "\n", "", "except", ":", "\n", "            ", "self", ".", "_f_model_is_ready", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._estimate_simulation": [[1008, 1022], ["sampling.AdaptiveSampler._Y_model.predict().reshape", "sampling.AdaptiveSampler._f_model.predict().reshape", "sampling.AdaptiveSampler._convert_Y", "sampling.AdaptiveSampler._convert_f", "numpy.full", "numpy.full", "sampling.AdaptiveSampler._Y_model.predict", "sampling.AdaptiveSampler._f_model.predict"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_Y", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_f", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.ClassificationModel.predict"], ["", "", "def", "_estimate_simulation", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predict the goal function and the binary feasibility of one or more \n        features ``X`` based on the previously trained estimators.\"\"\"", "\n", "\n", "num_points", "=", "X", ".", "shape", "[", "0", "]", "\n", "try", ":", "\n", "            ", "Y", "=", "self", ".", "_Y_model", ".", "predict", "(", "X", ",", "return_std", "=", "False", ")", ".", "reshape", "(", "num_points", ",", "-", "1", ")", "\n", "", "except", ":", "\n", "            ", "Y", "=", "np", ".", "full", "(", "(", "num_points", ",", "self", ".", "_Y_dim", ")", ",", "np", ".", "nan", ")", "\n", "", "try", ":", "\n", "            ", "f", "=", "self", ".", "_f_model", ".", "predict", "(", "X", ")", ".", "reshape", "(", "num_points", ")", "\n", "", "except", ":", "\n", "            ", "f", "=", "np", ".", "full", "(", "(", "num_points", ")", ",", "np", ".", "nan", ")", "\n", "", "return", "self", ".", "_convert_Y", "(", "Y", ")", ",", "self", ".", "_convert_f", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_initial_sampling": [[1023, 1036], ["callable", "sampling.AdaptiveSampler._convert_X", "sampling.AdaptiveSampler._initial_sampling_func", "sampling.AdaptiveSampler.initial_sampling_random_uniform", "sampling.AdaptiveSampler.initial_sampling_factorial", "ValueError"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_X", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.initial_sampling_random_uniform", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.initial_sampling_factorial"], ["", "def", "_evaluate_initial_sampling", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Perform the intital sampling at the start of the adaptive sampling \n        run by executing ``_initial_sampling_func``.\"\"\"", "\n", "\n", "if", "callable", "(", "self", ".", "_initial_sampling_func", ")", ":", "\n", "            ", "X_init", "=", "self", ".", "_initial_sampling_func", "(", "self", ".", "_initial_samples", ",", "self", ".", "_X_initial_sample_limits", ",", "seed", ")", "\n", "", "elif", "self", ".", "_initial_sampling_func", "==", "\"random\"", ":", "\n", "            ", "X_init", "=", "self", ".", "initial_sampling_random_uniform", "(", "self", ".", "_initial_samples", ",", "self", ".", "_X_initial_sample_limits", ",", "seed", ")", "\n", "", "elif", "self", ".", "_initial_sampling_func", "==", "\"factorial\"", ":", "\n", "            ", "X_init", "=", "self", ".", "initial_sampling_factorial", "(", "self", ".", "_initial_samples", ",", "self", ".", "_X_initial_sample_limits", ",", "seed", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"initial sampling function unspecified: '{}'\"", ".", "format", "(", "self", ".", "_initial_sampling_func", ")", ")", "\n", "", "return", "self", ".", "_convert_X", "(", "X_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_callback": [[1037, 1047], ["time.time", "sampling.AdaptiveSampler.info[].append", "time.time", "sampling.AdaptiveSampler._callback_func"], "methods", ["None"], ["", "def", "_evaluate_callback", "(", "self", ",", "X", ",", "Y", ",", "f", ",", "iteration", ")", ":", "\n", "        ", "\"\"\"Evalutate the callback function by executing ``_callback_func``. \n        The function is evaluated in each iteration step of the adaptive \n        sampling run. Also measure the runtime.\"\"\"", "\n", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "if", "self", ".", "_callback_func", "is", "not", "None", ":", "\n", "            ", "self", ".", "info", "[", "'callback_results'", "]", ".", "append", "(", "self", ".", "_callback_func", "(", "self", ",", "X", ",", "Y", ",", "f", ",", "iteration", ")", ")", "\n", "", "t", "=", "time", ".", "time", "(", ")", "-", "t", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_stopping_condition": [[1048, 1060], ["time.time", "sampling.AdaptiveSampler._stopping_condition_func", "time.time"], "methods", ["None"], ["", "def", "_evaluate_stopping_condition", "(", "self", ",", "X", ",", "Y", ",", "f", ")", ":", "\n", "        ", "\"\"\"Evalutate the stopping criterion by executing \n        ``_stopping_condition_func``. A positive return value prematurely \n        stops the main adaptive sampling loop. Also measure the runtime.\"\"\"", "\n", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "if", "self", ".", "_stopping_condition_func", "is", "not", "None", ":", "\n", "            ", "stop_flag", "=", "self", ".", "_stopping_condition_func", "(", "X", ",", "Y", ",", "f", ")", "\n", "", "else", ":", "\n", "            ", "stop_flag", "=", "False", "\n", "", "t", "=", "time", ".", "time", "(", ")", "-", "t", "\n", "return", "stop_flag", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._initialize_sampling": [[1061, 1082], ["datetime.datetime.now().timestamp", "len", "len", "numpy.random.RandomState", "dict", "sampling.AdaptiveSampler._default_utility_parameters.copy", "sampling.AdaptiveSampler._utility_parameters.update", "sampling.AdaptiveSampler._default_decision_parameters.copy", "sampling.AdaptiveSampler._decision_parameters.update", "datetime.datetime.now"], "methods", ["None"], ["", "def", "_initialize_sampling", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Prepare an adaptive sampling run.\"\"\"", "\n", "\n", "self", ".", "_info", "[", "'start_timestamp'", "]", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "timestamp", "(", ")", "\n", "self", ".", "_kwargs", "=", "kwargs", "\n", "self", ".", "_X_dim", "=", "len", "(", "self", ".", "_X_limits", ")", "\n", "self", ".", "_Y_dim", "=", "len", "(", "self", ".", "_Y_ref", ")", "\n", "self", ".", "_rng", "=", "np", ".", "random", ".", "RandomState", "(", "self", ".", "_seed", ")", "\n", "self", ".", "_info", "=", "dict", "(", "simulation_time", "=", "0", ",", "callback_time", "=", "0", ",", "condition_time", "=", "0", ",", "stop_flag", "=", "False", ",", "evaluation_batches", "=", "[", "]", ",", "evaluation_batches_time", "=", "[", "]", ",", "callback_results", "=", "[", "]", ",", "initial_samples", "=", "self", ".", "_initial_samples", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "self", ".", "_opt_func", "=", "None", "\n", "self", ".", "_update_Y_estimator_flag", "=", "True", "\n", "self", ".", "_Y_model_is_ready", "=", "False", "\n", "self", ".", "_f_model_is_ready", "=", "False", "\n", "if", "self", ".", "_save_memory_flag", ":", "\n", "            ", "self", ".", "_grid_creator_func", "=", "self", ".", "_create_pareto_grid_runtime", "\n", "", "else", ":", "\n", "            ", "self", ".", "_grid_creator_func", "=", "self", ".", "_create_pareto_grid_cached", "\n", "", "self", ".", "_utility_parameters", "=", "self", ".", "_default_utility_parameters", ".", "copy", "(", ")", "\n", "self", ".", "_utility_parameters", ".", "update", "(", "**", "self", ".", "_utility_parameter_options", ")", "\n", "self", ".", "_decision_parameters", "=", "self", ".", "_default_decision_parameters", ".", "copy", "(", ")", "\n", "self", ".", "_decision_parameters", ".", "update", "(", "**", "self", ".", "_decision_parameter_options", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._initial_sampling": [[1083, 1099], ["sampling.log_wrapper", "time.time", "sampling.AdaptiveSampler._rng.randint", "sampling.AdaptiveSampler._evaluate_initial_sampling", "sampling.AdaptiveSampler._info[].append", "sampling.AdaptiveSampler._info[].append", "sampling.AdaptiveSampler._evaluate_simulation", "sampling.AdaptiveSampler._evaluate_callback", "sampling.log_wrapper", "time.time", "numpy.iinfo"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.log_wrapper", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_initial_sampling", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_simulation", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_callback", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.log_wrapper"], ["", "def", "_initial_sampling", "(", "self", ")", ":", "\n", "        ", "\"\"\"Perform the initial sampling for an adaptive sampling run.\"\"\"", "\n", "\n", "log_wrapper", "(", "self", ".", "_verbose", ",", "20", ",", "\"[initial sampling start]\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "seed", "=", "self", ".", "_rng", ".", "randint", "(", "0", ",", "np", ".", "iinfo", "(", "np", ".", "int32", ")", ".", "max", ")", "\n", "X", "=", "self", ".", "_evaluate_initial_sampling", "(", "seed", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "-", "t", "\n", "self", ".", "_info", "[", "'evaluation_batches'", "]", ".", "append", "(", "X", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "_info", "[", "'evaluation_batches_time'", "]", ".", "append", "(", "t", ")", "\n", "Y", ",", "f", ",", "t_sim", "=", "self", ".", "_evaluate_simulation", "(", "X", ")", "\n", "self", ".", "_info", "[", "'simulation_time'", "]", "+=", "t_sim", "\n", "t_callback", "=", "self", ".", "_evaluate_callback", "(", "X", ",", "Y", ",", "f", ",", "None", ")", "\n", "self", ".", "_info", "[", "'callback_time'", "]", "+=", "t_callback", "\n", "log_wrapper", "(", "self", ".", "_verbose", ",", "20", ",", "\"[initial sampling end] new points = {:d}\"", ".", "format", "(", "f", ".", "size", ")", ")", "\n", "return", "X", ",", "Y", ",", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._adaptive_sampling_loop": [[1100, 1143], ["range", "time.time", "sampling.log_wrapper", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "sampling.AdaptiveSampler._update_estimator", "range", "sampling.AdaptiveSampler._info[].append", "sampling.AdaptiveSampler._info[].append", "sampling.AdaptiveSampler._evaluate_simulation", "numpy.any", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "sampling.AdaptiveSampler._evaluate_callback", "sampling.AdaptiveSampler._evaluate_stopping_condition", "sampling.log_wrapper", "sampling.AdaptiveSampler._opt_func_provider", "sampling.AdaptiveSampler._convert_X", "numpy.concatenate", "time.time", "numpy.array", "numpy.array", "numpy.array", "sampling.AdaptiveSampler._sampling_decision", "sampling.AdaptiveSampler._estimate_simulation", "numpy.concatenate", "numpy.concatenate", "numpy.unique"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.log_wrapper", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._update_estimator", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_simulation", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_callback", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._evaluate_stopping_condition", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.log_wrapper", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._opt_func_provider", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._convert_X", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._sampling_decision", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._estimate_simulation"], ["", "def", "_adaptive_sampling_loop", "(", "self", ",", "X", ",", "Y", ",", "f", ")", ":", "\n", "        ", "\"\"\"Run the main adaptive sampling loop, which consists of an outer \n        loop (iterate over all sampling iterations) and an inner loop (iterate \n        over all virtual sampling iterations). In each iteration, the callback \n        function is executed. The outer loop is stopped prematurely as soon as \n        the stopping criterion is positive.\n        \"\"\"", "\n", "\n", "iteration", "=", "None", "\n", "for", "iteration", "in", "range", "(", "self", ".", "_iterations", ")", ":", "\n", "            ", "t", "=", "time", ".", "time", "(", ")", "\n", "log_wrapper", "(", "self", ".", "_verbose", ",", "20", ",", "\"[iteration {:d} start] f distribution = {}, total points = {:d}\"", ".", "format", "(", "iteration", ",", "{", "f_", ":", "f", "[", "f", "==", "f_", "]", ".", "size", "for", "f_", "in", "np", ".", "unique", "(", "f", ")", "}", ",", "f", ".", "size", ")", ")", "\n", "X_virtual", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "self", ".", "_dtype_X", ")", ".", "reshape", "(", "0", ",", "self", ".", "_X_dim", ")", "\n", "Y_virtual", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "self", ".", "_dtype_Y", ")", ".", "reshape", "(", "0", ",", "self", ".", "_Y_dim", ")", "\n", "f_virtual", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "self", ".", "_dtype_f", ")", ".", "reshape", "(", "0", ")", "\n", "self", ".", "_update_estimator", "(", "X", ",", "Y", ",", "f", ")", "\n", "for", "virtual_iteration", "in", "range", "(", "self", ".", "_virtual_iterations", ")", ":", "\n", "                ", "self", ".", "_opt_func", "=", "self", ".", "_opt_func_provider", "(", "X", ",", "Y", ",", "f", ",", "X_virtual", ",", "Y_virtual", ",", "f_virtual", ")", "\n", "X_suggestion", "=", "self", ".", "_convert_X", "(", "self", ".", "_sampling_decision", "(", "self", ".", "_opt_func", ")", ")", "\n", "X_virtual", "=", "np", ".", "concatenate", "(", "(", "X_virtual", ",", "X_suggestion", ")", ")", "\n", "if", "virtual_iteration", "<", "self", ".", "_virtual_iterations", "-", "1", ":", "\n", "                    ", "Y_estimate", ",", "f_estimate", "=", "self", ".", "_estimate_simulation", "(", "X_suggestion", ")", "\n", "Y_virtual", "=", "np", ".", "concatenate", "(", "(", "Y_virtual", ",", "Y_estimate", ")", ")", "\n", "f_virtual", "=", "np", ".", "concatenate", "(", "(", "f_virtual", ",", "f_estimate", ")", ")", "\n", "", "", "t", "=", "time", ".", "time", "(", ")", "-", "t", "\n", "self", ".", "_info", "[", "'evaluation_batches'", "]", ".", "append", "(", "X_virtual", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "_info", "[", "'evaluation_batches_time'", "]", ".", "append", "(", "t", ")", "\n", "Y_sample", ",", "f_sample", ",", "t_sim", "=", "self", ".", "_evaluate_simulation", "(", "X_virtual", ")", "\n", "self", ".", "_info", "[", "'simulation_time'", "]", "+=", "t_sim", "\n", "self", ".", "_update_Y_estimator_flag", "=", "np", ".", "any", "(", "f_sample", ")", "\n", "X", "=", "np", ".", "concatenate", "(", "(", "X", ",", "X_virtual", ")", ")", "\n", "Y", "=", "np", ".", "concatenate", "(", "(", "Y", ",", "Y_sample", ")", ")", "\n", "f", "=", "np", ".", "concatenate", "(", "(", "f", ",", "f_sample", ")", ")", "\n", "t_callback", "=", "self", ".", "_evaluate_callback", "(", "X", ",", "Y", ",", "f", ",", "iteration", ")", "\n", "self", ".", "_info", "[", "'callback_time'", "]", "+=", "t_callback", "\n", "stop_flag", ",", "t_stop", "=", "self", ".", "_evaluate_stopping_condition", "(", "X", ",", "Y", ",", "f", ")", "\n", "self", ".", "_info", "[", "'condition_time'", "]", "+=", "t_stop", "\n", "log_wrapper", "(", "self", ".", "_verbose", ",", "20", ",", "\"[iteration {:d} end] new points = {:d}\"", ".", "format", "(", "iteration", ",", "f_sample", ".", "size", ")", ")", "\n", "if", "stop_flag", ":", "\n", "                ", "self", ".", "_info", "[", "'stop_flag'", "]", "=", "True", "\n", "break", "\n", "", "", "self", ".", "_info", "[", "'iteration'", "]", "=", "iteration", "\n", "return", "X", ",", "Y", ",", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._finalize_sampling": [[1144, 1148], ["datetime.datetime.now().timestamp", "datetime.datetime.now"], "methods", ["None"], ["", "def", "_finalize_sampling", "(", "self", ")", ":", "\n", "       ", "\"\"\"Finish an adaptive sampling run.\"\"\"", "\n", "\n", "self", ".", "_info", "[", "'end_timestamp'", "]", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "timestamp", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler.sample": [[1149, 1181], ["sampling.AdaptiveSampler._initialize_sampling", "sampling.AdaptiveSampler._initial_sampling", "sampling.AdaptiveSampler._adaptive_sampling_loop", "sampling.AdaptiveSampler._finalize_sampling"], "methods", ["home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._initialize_sampling", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._initial_sampling", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._adaptive_sampling_loop", "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.AdaptiveSampler._finalize_sampling"], ["", "def", "sample", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Start sampling.\n         \n        Perform an adaptive sampling with this sampler and return the sampled \n        results.\n        \n        Parameters\n        ----------\n        \n        kwargs : dict, optional\n            Any additional fixed parameters needed to completely specify \n            ``simulation_func``.\n            \n        Returns\n        -------\n        \n        X : ndarray of shape (n_samples, X_dim)\n            Resulting array of sampled features.\n            \n        Y : ndarray of shape (n_samples, Y_dim)\n            Resulting array of corresponding goals from the simulation.\n            \n        f : ndarray of shape (n_samples,)\n            Resulting array of corresponding binary feasibilities from the \n            simulation.    \n        \"\"\"", "\n", "\n", "self", ".", "_initialize_sampling", "(", "**", "kwargs", ")", "\n", "X", ",", "Y", ",", "f", "=", "self", ".", "_initial_sampling", "(", ")", "\n", "X", ",", "Y", ",", "f", "=", "self", ".", "_adaptive_sampling_loop", "(", "X", ",", "Y", ",", "f", ")", "\n", "self", ".", "_finalize_sampling", "(", ")", "\n", "return", "X", ",", "Y", ",", "f", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RaoulHeese_adasamp-pareto.None.sampling.log_wrapper": [[42, 68], ["logging.log", "print", "print", "int", "str", "str"], "function", ["None"], ["", "def", "log_wrapper", "(", "verbose", ",", "level", ",", "msg", ")", ":", "\n", "    ", "\"\"\"Wrapper to savely log messages.\n     \n    Use the ``logging`` module if enabled and use ``print`` otherwise.\n    \n    Parameters\n    ----------\n    \n    verbose : bool\n        Set to True to log messages.\n        \n    level : int\n        Logging level for the ``logging`` module.\n    \n    msg : str\n        Actual message to log.\n    \"\"\"", "\n", "\n", "if", "verbose", ":", "\n", "        ", "try", ":", "\n", "            ", "if", "__LOGGING_ENABLED__", ":", "\n", "                ", "logging", ".", "log", "(", "int", "(", "level", ")", ",", "str", "(", "msg", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "str", "(", "msg", ")", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "e", ")", "\n", "\n"]]}