{"home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_emb": [[5, 19], ["open", "int", "str().strip", "open.close", "len", "str().strip.split", "str().strip", "open.readline().split", "str", "word.lower", "numpy.fromstring", "open.readline", "str", "open.readline", "word.lower", "open.readline"], "function", ["None"], ["def", "read_emb", "(", "emb_path", ")", ":", "\n", "    ", "file", "=", "open", "(", "emb_path", ",", "mode", "=", "'r'", ",", "encoding", "=", "'utf-8'", ",", "errors", "=", "\"replace\"", ")", "\n", "dim", "=", "int", "(", "file", ".", "readline", "(", ")", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "\n", "word_vec_dict", "=", "{", "}", "\n", "line", "=", "str", "(", "file", ".", "readline", "(", ")", ")", ".", "strip", "(", ")", "\n", "while", "len", "(", "line", ")", ">", "1", ":", "\n", "        ", "word", ",", "vec", "=", "line", ".", "split", "(", "' '", ",", "1", ")", "\n", "if", "word", ".", "lower", "(", ")", "not", "in", "word_vec_dict", ":", "\n", "            ", "word_vec_dict", "[", "word", ".", "lower", "(", ")", "]", "=", "np", ".", "fromstring", "(", "vec", ",", "sep", "=", "' '", ",", "dtype", "=", "float", ")", "\n", "", "else", ":", "\n", "            ", "None", "# print(\"already\", word)", "\n", "", "line", "=", "str", "(", "file", ".", "readline", "(", ")", ")", ".", "strip", "(", ")", "\n", "", "file", ".", "close", "(", ")", "\n", "return", "word_vec_dict", ",", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_m_analogy_set": [[21, 30], ["open", "str().strip", "len", "str().strip.split", "str().strip", "str", "file_in.readline", "left.lower", "right.lower", "str", "file_in.readline"], "function", ["None"], ["", "def", "read_m_analogy_set", "(", "file_path", ")", ":", "\n", "    ", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "file_in", ":", "\n", "        ", "line", "=", "str", "(", "file_in", ".", "readline", "(", ")", ")", ".", "strip", "(", ")", "\n", "words", "=", "[", "]", "\n", "while", "len", "(", "line", ")", ">", "1", ":", "\n", "            ", "left", ",", "right", "=", "line", ".", "split", "(", ")", "\n", "words", "=", "words", "+", "[", "left", ".", "lower", "(", ")", ",", "right", ".", "lower", "(", ")", "]", "\n", "line", "=", "str", "(", "file_in", ".", "readline", "(", ")", ")", ".", "strip", "(", ")", "\n", "", "", "return", "words", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.filter_x_embs": [[32, 43], ["numpy.empty", "numpy.empty", "range", "len", "len", "len", "numpy.vstack", "numpy.vstack"], "function", ["None"], ["", "def", "filter_x_embs", "(", "X_word_vec_dict", ",", "Y_word_vec_dict", ",", "X_analogy_words", ",", "Y_analogy_words", ",", "dim", ")", ":", "\n", "    ", "assert", "len", "(", "X_analogy_words", ")", "==", "len", "(", "Y_analogy_words", ")", "\n", "\n", "X_mat", "=", "np", ".", "empty", "(", "(", "0", ",", "dim", ")", ",", "dtype", "=", "float", ")", "\n", "Y_mat", "=", "np", ".", "empty", "(", "(", "0", ",", "dim", ")", ",", "dtype", "=", "float", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "X_analogy_words", ")", ")", ":", "\n", "        ", "if", "(", "X_analogy_words", "[", "i", "]", "in", "X_word_vec_dict", ")", "and", "(", "Y_analogy_words", "[", "i", "]", "in", "Y_word_vec_dict", ")", ":", "\n", "            ", "X_mat", "=", "np", ".", "vstack", "(", "[", "X_mat", ",", "X_word_vec_dict", "[", "X_analogy_words", "[", "i", "]", "]", "]", ")", "\n", "Y_mat", "=", "np", ".", "vstack", "(", "[", "Y_mat", ",", "Y_word_vec_dict", "[", "Y_analogy_words", "[", "i", "]", "]", "]", ")", "\n", "", "", "return", "X_mat", ",", "Y_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.preprocess_emb": [[45, 56], ["emb_mat.mean", "numpy.sqrt", "len"], "function", ["None"], ["", "def", "preprocess_emb", "(", "emb_mat", ")", ":", "\n", "    ", "mu", "=", "emb_mat", ".", "mean", "(", "0", ")", "\n", "\n", "# mean centring", "\n", "emb_mat0", "=", "emb_mat", "-", "mu", "\n", "\n", "# row-wise L2 norm", "\n", "norm", "=", "np", ".", "sqrt", "(", "(", "emb_mat0", "**", "2.", ")", ".", "sum", "(", ")", ")", "/", "len", "(", "emb_mat", ")", "\n", "\n", "# scale to equal (unit) norm", "\n", "return", "emb_mat0", "/", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.main": [[58, 70], ["get_emb.read_m_analogy_set", "get_emb.read_m_analogy_set", "get_emb.read_emb", "get_emb.read_emb", "get_emb.filter_x_embs", "numpy.save", "numpy.save", "get_emb.preprocess_emb", "get_emb.preprocess_emb"], "function", ["home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_m_analogy_set", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_m_analogy_set", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_emb", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.read_emb", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.filter_x_embs", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.preprocess_emb", "home.repos.pwc.inspect_result.pzoom522_xanlg.None.get_emb.preprocess_emb"], ["", "def", "main", "(", "input_list", ")", ":", "\n", "    ", "[", "A_emb_path", ",", "B_emb_path", ",", "A_analogy_path", ",", "B_analogy_path", ",", "A_mat_path", ",", "B_mat_path", "]", "=", "input_list", "\n", "A_analogy_words", "=", "read_m_analogy_set", "(", "A_analogy_path", ")", "\n", "B_analogy_words", "=", "read_m_analogy_set", "(", "B_analogy_path", ")", "\n", "\n", "A_word_vec_dict", ",", "A_dim", "=", "read_emb", "(", "A_emb_path", ")", "\n", "B_word_vec_dict", ",", "B_dim", "=", "read_emb", "(", "B_emb_path", ")", "\n", "\n", "A_mat", ",", "B_mat", "=", "filter_x_embs", "(", "A_word_vec_dict", ",", "B_word_vec_dict", ",", "A_analogy_words", ",", "B_analogy_words", ",", "A_dim", ")", "\n", "\n", "np", ".", "save", "(", "A_mat_path", ",", "preprocess_emb", "(", "A_mat", ")", ")", "\n", "np", ".", "save", "(", "B_mat_path", ",", "preprocess_emb", "(", "B_mat", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.validate_analogy.transport": [[7, 28], ["scipy.optimize.fmin", "validate_analogy.transport.dist"], "function", ["None"], ["def", "transport", "(", "start_mat", ",", "end_mat", ",", "metric", ")", ":", "\n", "    ", "def", "dist", "(", "x", ",", "metric_arg", ")", ":", "\n", "        ", "x", "=", "np", ".", "reshape", "(", "x", ",", "(", "1", ",", "-", "1", ")", ")", "\n", "loss", "=", "42", "\n", "if", "metric_arg", "==", "'l1'", ":", "\n", "            ", "loss", "=", "np", ".", "sqrt", "(", "np", ".", "abs", "(", "offset_mat", "-", "x", ")", ".", "sum", "(", ")", ")", "/", "len", "(", "offset_mat", ")", "\n", "", "elif", "metric_arg", "==", "'l2'", ":", "\n", "            ", "loss", "=", "np", ".", "sqrt", "(", "(", "(", "offset_mat", "-", "x", ")", "**", "2", ")", ".", "sum", "(", ")", ")", "/", "len", "(", "offset_mat", ")", "\n", "", "elif", "metric_arg", "==", "'cos'", ":", "\n", "            ", "dot_sum", "=", "np", ".", "sum", "(", "x", "*", "offset_mat", ",", "axis", "=", "1", ")", "\n", "mod_x", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "x", "**", "2", ")", ")", "\n", "mod_mat", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "offset_mat", "**", "2", ")", ")", "\n", "loss", "=", "np", ".", "mean", "(", "1", "-", "dot_sum", "/", "(", "mod_x", "*", "mod_mat", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'illegal metric!'", ")", "\n", "# print(loss)", "\n", "", "return", "loss", "\n", "\n", "", "offset_mat", "=", "start_mat", "-", "end_mat", "\n", "minimum", "=", "optimize", ".", "fmin", "(", "dist", ",", "np", ".", "mean", "(", "offset_mat", ",", "axis", "=", "0", ")", ",", "args", "=", "(", "metric", ",", ")", ",", "xtol", "=", "0.0001", ",", "ftol", "=", "0.0001", ",", "disp", "=", "False", ")", "\n", "return", "dist", "(", "minimum", ",", "metric", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pzoom522_xanlg.None.linear_map.procrustes": [[5, 110], ["X.mean", "Y.mean", "numpy.sqrt", "numpy.sqrt", "numpy.dot", "numpy.linalg.svd", "numpy.dot", "s.sum", "numpy.concatenate", "len", "numpy.linalg.det", "numpy.dot", "numpy.sqrt", "numpy.zeros", "numpy.dot", "numpy.dot", "numpy.sum", "numpy.square", "Y.dot"], "function", ["None"], ["def", "procrustes", "(", "X", ",", "Y", ",", "scaling", "=", "True", ",", "reflection", "=", "'best'", ")", ":", "\n", "    ", "\"\"\"\n    A port of MATLAB's `procrustes` function to Numpy.\n    Partly copied from: https://stackoverflow.com/a/18927641.\n\n    Procrustes analysis determines a linear transformation (translation,\n    reflection, orthogonal rotation and scaling) of the points in Y to best\n    conform them to the points in matrix X, using the sum of squared errors\n    as the goodness of fit criterion.\n\n        d, Z, [tform] = procrustes(X, Y)\n\n    Inputs:\n    ------------\n    X, Y\n        matrices of target and input coordinates. they must have equal\n        numbers of  points (rows), but Y may have fewer dimensions\n        (columns) than X.\n\n    scaling\n        if False, the scaling component of the transformation is forced\n        to 1\n\n    reflection\n        if 'best' (default), the transformation solution may or may not\n        include a reflection component, depending on which fits the data\n        best. setting reflection to True or False forces a solution with\n        reflection or no reflection respectively.\n\n    Outputs\n    ------------\n    d\n        the residual sum of squared errors, normalized according to a\n        measure of the scale of X, ((X - X.mean(0))**2).sum()\n\n    Z\n        the matrix of transformed Y-values\n\n    tform\n        a dict specifying the rotation, translation and scaling that\n        maps X --> Y\n\n    \"\"\"", "\n", "\n", "n", ",", "m", "=", "X", ".", "shape", "\n", "ny", ",", "my", "=", "Y", ".", "shape", "\n", "\n", "muX", "=", "X", ".", "mean", "(", "0", ")", "\n", "muY", "=", "Y", ".", "mean", "(", "0", ")", "\n", "\n", "X0", "=", "X", "-", "muX", "\n", "Y0", "=", "Y", "-", "muY", "\n", "\n", "ssX", "=", "(", "X0", "**", "2.", ")", ".", "sum", "(", ")", "\n", "ssY", "=", "(", "Y0", "**", "2.", ")", ".", "sum", "(", ")", "\n", "\n", "# centred Frobenius norm", "\n", "normX", "=", "np", ".", "sqrt", "(", "ssX", ")", "\n", "normY", "=", "np", ".", "sqrt", "(", "ssY", ")", "\n", "\n", "# scale to equal (unit) norm", "\n", "X0", "/=", "normX", "\n", "Y0", "/=", "normY", "\n", "\n", "if", "my", "<", "m", ":", "\n", "        ", "Y0", "=", "np", ".", "concatenate", "(", "(", "Y0", ",", "np", ".", "zeros", "(", "n", ",", "m", "-", "my", ")", ")", ",", "0", ")", "\n", "\n", "# optimum rotation matrix of Y", "\n", "", "A", "=", "np", ".", "dot", "(", "X0", ".", "T", ",", "Y0", ")", "\n", "U", ",", "s", ",", "Vt", "=", "np", ".", "linalg", ".", "svd", "(", "A", ",", "full_matrices", "=", "False", ")", "\n", "V", "=", "Vt", ".", "T", "\n", "T", "=", "np", ".", "dot", "(", "V", ",", "U", ".", "T", ")", "\n", "\n", "if", "reflection", "!=", "'best'", ":", "\n", "\n", "# does the current solution use a reflection?", "\n", "        ", "have_reflection", "=", "np", ".", "linalg", ".", "det", "(", "T", ")", "<", "0", "\n", "\n", "# if that's not what was specified, force another reflection", "\n", "if", "reflection", "!=", "have_reflection", ":", "\n", "            ", "V", "[", ":", ",", "-", "1", "]", "*=", "-", "1", "\n", "s", "[", "-", "1", "]", "*=", "-", "1", "\n", "T", "=", "np", ".", "dot", "(", "V", ",", "U", ".", "T", ")", "\n", "\n", "", "", "traceTA", "=", "s", ".", "sum", "(", ")", "\n", "\n", "if", "scaling", ":", "\n", "\n", "# optimum scaling of Y", "\n", "        ", "b", "=", "traceTA", "*", "normX", "/", "normY", "\n", "\n", "# standarised distance between X and b*Y*T + c", "\n", "d", "=", "1", "-", "traceTA", "**", "2", "\n", "\n", "# transformed coords", "\n", "Z", "=", "normX", "*", "traceTA", "*", "np", ".", "dot", "(", "Y0", ",", "T", ")", "+", "muX", "\n", "\n", "", "else", ":", "\n", "        ", "b", "=", "1", "\n", "d", "=", "1", "+", "ssY", "/", "ssX", "-", "2", "*", "traceTA", "*", "normY", "/", "normX", "\n", "Z", "=", "normY", "*", "np", ".", "dot", "(", "Y0", ",", "T", ")", "+", "muX", "\n", "\n", "# transformation values", "\n", "", "tform", "=", "{", "'rotation'", ":", "T", ",", "'scale'", ":", "b", "}", "\n", "return", "-", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "X", "-", "(", "b", "*", "Y", ".", "dot", "(", "T", ")", ")", ")", ")", ")", "/", "len", "(", "X", ")", "# d, Z, tform", "\n", "\n"]]}