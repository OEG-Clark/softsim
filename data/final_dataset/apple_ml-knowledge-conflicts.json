{"home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.generate_substitutions.generate_substitutions": [[26, 50], ["src.classes.qadataset.QADataset.load", "inspect.signature().parameters.values", "sub_fn", "os.makedirs", "os.path.basename().split", "os.path.dirname", "open", "json.dump", "outf.write", "json.dump", "outf.write", "os.path.basename", "inspect.signature", "ex.json_dump", "vars", "vars"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.load", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_dump"], ["def", "generate_substitutions", "(", "args", ")", ":", "\n", "    ", "\"\"\"Initialize the preprocessed dataset and substitution function, then apply \n    the latter to the former, and save the output as JSONLINES file (one example per line).\n    \"\"\"", "\n", "dset_name", "=", "os", ".", "path", ".", "basename", "(", "args", ".", "inpath", ")", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "preprocessed_dataset", "=", "QADataset", ".", "load", "(", "dset_name", ")", "\n", "\n", "sub_fn", "=", "SUBSTITUTION_FNS", "[", "args", ".", "substitution", "]", "\n", "# Only pass in the arguments from args that are identically named in the function signature", "\n", "params", "=", "inspect", ".", "signature", "(", "sub_fn", ")", ".", "parameters", ".", "values", "(", ")", "\n", "sub_exs", "=", "sub_fn", "(", "\n", "preprocessed_dataset", ",", "\n", "args", ".", "wikidata", ",", "\n", "**", "{", "p", ".", "name", ":", "vars", "(", "args", ")", "[", "p", ".", "name", "]", "for", "p", "in", "params", "if", "p", ".", "name", "in", "vars", "(", "args", ")", "}", ",", "\n", ")", "\n", "\n", "# Write final substitution set to args.outpath", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "outpath", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "args", ".", "outpath", ",", "\"w\"", ")", "as", "outf", ":", "\n", "        ", "json", ".", "dump", "(", "{", "\"dataset\"", ":", "f\"{dset_name}-{args.substitution}\"", "}", ",", "outf", ")", "\n", "outf", ".", "write", "(", "\"\\n\"", ")", "\n", "for", "ex", "in", "sub_exs", ":", "\n", "            ", "json", ".", "dump", "(", "ex", ".", "json_dump", "(", "save_full", "=", "args", ".", "save_full", ")", ",", "outf", ")", "\n", "outf", ".", "write", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.alias_substitution_fn": [[17, 93], ["print", "print", "print", "list", "ex.get_example_answer_type", "substitution_fns.create_new_example", "substitution_fns.alias_substitution_fn.sub_fn"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.create_new_example"], ["def", "alias_substitution_fn", "(", "\n", "dset", ":", "QADataset", ",", "\n", "wikidata_info_path", ":", "str", ",", "\n", "replace_every", ":", "bool", ",", "\n", "max_aliases", ":", "int", ",", "\n", "category", ":", "str", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Derives a new dataset of modified examples, where the original answer has been replaced\n    with one of it's own wikidata aliases.\n\n    Args:\n        dset: The original QADataset\n        wikidata_info_path: A path to a mapping from wikidata ID to a dictionary of\n            wikidata info (see extract_wikidata_info.py for details).\n        replace_every: If True, replace every original answer in the substitution examples context, otherwise replace just the primary one.\n        max_aliases: How many new (modified) examples to create from one original example. Each one\n            will replace the original answer with one of it's aliases, up to min(max_aliases, the number of available aliases).\n        category: This limits substitution generation to only use original examples with this answer type category. \n            `ALL` is an option.\n    \"\"\"", "\n", "\n", "def", "sub_fn", "(", "ex", ":", "QAExample", ")", ":", "\n", "        ", "\"\"\"Derive all modified examples from one original example.\"\"\"", "\n", "# Determine which aliases are valid substitutions", "\n", "# Store these as Dict[alias_text --> GoldAnswer] so we can retrieve the info for each alias", "\n", "gold_answer_texts", "=", "[", "ga", ".", "text", "for", "ga", "in", "ex", ".", "gold_answers", "]", "\n", "alias_to_info", "=", "{", "\n", "alias", ":", "ga", "for", "ga", "in", "ex", ".", "gold_answers", "if", "ga", ".", "aliases", "for", "alias", "in", "ga", ".", "aliases", "\n", "}", "\n", "valid_aliases", "=", "list", "(", "set", "(", "alias_to_info", ".", "keys", "(", ")", ")", "-", "set", "(", "gold_answer_texts", ")", ")", "\n", "sub_exs", "=", "[", "\n", "# As the sub_answer is an alias we expect the metadata to be mostly the same as the original answer", "\n", "create_new_example", "(", "\n", "ex", "=", "ex", ",", "\n", "new_id", "=", "f\"alias-sub-{idx}\"", ",", "\n", "answer_text", "=", "alias", ",", "\n", "ner_label", "=", "alias_to_info", "[", "alias", "]", ".", "ner_label", ",", "\n", "kb_id", "=", "alias_to_info", "[", "alias", "]", ".", "kb_id", ",", "\n", "wikidata_label", "=", "alias_to_info", "[", "alias", "]", ".", "wikidata_label", ",", "\n", "aliases", "=", "[", "alias_to_info", "[", "alias", "]", ".", "text", "]", ",", "\n", "wikidata_types", "=", "alias_to_info", "[", "alias", "]", ".", "wikidata_types", ",", "\n", "wikipedia_page", "=", "alias_to_info", "[", "alias", "]", ".", "wikipedia_page", ",", "\n", "popularity", "=", "alias_to_info", "[", "alias", "]", ".", "popularity", ",", "\n", "answer_type", "=", "alias_to_info", "[", "alias", "]", ".", "answer_type", ",", "\n", "replace_every_original_answer", "=", "replace_every", ",", "\n", ")", "\n", "for", "idx", ",", "alias", "in", "enumerate", "(", "valid_aliases", ")", "\n", "]", "\n", "return", "sub_exs", "\n", "\n", "", "new_exs", ",", "num_alias_dist", "=", "[", "]", ",", "[", "]", "\n", "for", "ex", "in", "dset", ".", "examples", ":", "\n", "        ", "ex_answer_type", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "(", "\n", "category", ".", "lower", "(", ")", "==", "\"all\"", "\n", "or", "(", "\n", "category", ".", "lower", "(", ")", "==", "\"nonnumeric\"", "\n", "and", "category", "not", "in", "[", "None", ",", "\"DATE\"", ",", "\"NUMERIC\"", "]", "\n", ")", "\n", "or", "category", ".", "lower", "(", ")", "==", "ex_answer_type", ".", "lower", "(", ")", "\n", ")", ":", "\n", "            ", "alias_exs", "=", "sub_fn", "(", "ex", ")", "\n", "# If not 0 then we select a subset of aliased substitution examples", "\n", "if", "max_aliases", ":", "\n", "                ", "alias_exs", "=", "alias_exs", "[", ":", "max_aliases", "]", "\n", "", "new_exs", ".", "extend", "(", "alias_exs", ")", "\n", "num_alias_dist", ".", "append", "(", "len", "(", "alias_exs", ")", ")", "\n", "\n", "", "", "print", "(", "\n", "f\"Num New Examples Generated per Original Example (using max-aliases={max_aliases}, category={category})): {Counter(num_alias_dist)}\"", "\n", ")", "\n", "print", "(", "\n", "f\"NB: The quantity of zeros reflects how many examples do not have wikidata IDs to draw aliases from.\"", "\n", ")", "\n", "print", "(", "f\"Finished Alias Substitution.\"", ")", "\n", "return", "new_exs", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.corpus_substitution_fn": [[95, 161], ["substitution_fns.group_answers_by_answer_type", "collections.Counter", "print", "print", "print", "ex.get_example_answer_type", "ex.get_example_answer_type", "range", "ex.get_example_answer_type", "substitution_fns.select_random_non_identical_answer", "substitution_fns.create_new_example", "new_exs.append", "substitution_fns.alias_substitution_fn.sub_fn"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.group_answers_by_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.select_random_non_identical_answer", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.create_new_example"], ["", "def", "corpus_substitution_fn", "(", "\n", "dset", ":", "QADataset", ",", "\n", "wikidata_info_path", ":", "str", ",", "\n", "replace_every", ":", "bool", ",", "\n", "num_samples", ":", "int", ",", "\n", "category", ":", "str", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Derives a new dataset of modified examples, where the original answer has been replaced\n    by another answer of the same `type` drawn randomly from the corpus of answers in the original dataset.\n    This substitution function maintains the same distribution of answers as the original dataset.\n\n    Args:\n        dset: The original QADataset\n        wikidata_info_path: A path to a mapping from wikidata ID to a dictionary of\n            wikidata info (see extract_wikidata_info.py for details).\n        replace_every: If True, replace every original answer in the substitution examples context, otherwise replace just the primary one.\n        num_samples: How many new (modified) examples to create from one original example.\n        category: This limits substitution generation to only use original examples with this answer type category. \n            `ALL` is an option.\n    \"\"\"", "\n", "# generate a corpus of substitute answers, keyed by answer type", "\n", "answer_corpus_by_groups", "=", "group_answers_by_answer_type", "(", "dset", ")", "\n", "\n", "def", "sub_fn", "(", "ex", ":", "QAExample", ")", ":", "\n", "        ", "\"\"\"Derive all modified examples from one original example.\"\"\"", "\n", "new_exs", "=", "[", "]", "\n", "ex_ans_typ", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "ex_ans_typ", "is", "not", "None", ":", "\n", "            ", "for", "idx", "in", "range", "(", "num_samples", ")", ":", "\n", "                ", "sub_answer", "=", "select_random_non_identical_answer", "(", "\n", "ex", ",", "answer_corpus_by_groups", "[", "ex_ans_typ", "]", "\n", ")", "\n", "new_ex", "=", "create_new_example", "(", "\n", "ex", "=", "ex", ",", "\n", "new_id", "=", "f\"corpus-sub-{idx}\"", ",", "\n", "answer_text", "=", "sub_answer", ".", "text", ",", "\n", "ner_label", "=", "sub_answer", ".", "ner_label", ",", "\n", "kb_id", "=", "sub_answer", ".", "kb_id", ",", "\n", "wikidata_label", "=", "sub_answer", ".", "wikidata_label", ",", "\n", "aliases", "=", "sub_answer", ".", "aliases", ",", "\n", "wikidata_types", "=", "sub_answer", ".", "wikidata_types", ",", "\n", "wikipedia_page", "=", "sub_answer", ".", "wikipedia_page", ",", "\n", "popularity", "=", "sub_answer", ".", "popularity", ",", "\n", "answer_type", "=", "sub_answer", ".", "answer_type", ",", "\n", "replace_every_original_answer", "=", "replace_every", ",", "\n", ")", "\n", "new_exs", ".", "append", "(", "new_ex", ")", "\n", "", "", "return", "new_exs", "\n", "\n", "", "new_exs", "=", "[", "]", "\n", "for", "ex", "in", "dset", ".", "examples", ":", "\n", "        ", "ex_answer_type", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "ex_answer_type", "is", "not", "None", ":", "\n", "            ", "if", "category", ".", "lower", "(", ")", "==", "\"all\"", "or", "category", ".", "lower", "(", ")", "==", "ex_answer_type", ".", "lower", "(", ")", ":", "\n", "                ", "exs", "=", "sub_fn", "(", "ex", ")", "\n", "new_exs", ".", "extend", "(", "exs", ")", "\n", "\n", "", "", "", "group_counter", "=", "Counter", "(", "[", "ex", ".", "get_example_answer_type", "(", ")", "for", "ex", "in", "new_exs", "]", ")", "\n", "print", "(", "\n", "f\"Num New Examples Generated by Answer Type Group (using num-samples={num_samples}, category={category}): {group_counter}\"", "\n", ")", "\n", "print", "(", "\n", "f\"NB: Not all original examples can be substituted, if their answer type is not discernable, or one of the 5 high-confidence identified by this NER model.\"", "\n", ")", "\n", "print", "(", "f\"Finished Corpus Substitution.\"", ")", "\n", "return", "new_exs", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.popularity_substitution_fn": [[163, 236], ["substitution_fns.bin_wikidata_entities_by_popularity", "print", "range", "ex.get_example_answer_type", "len", "random.choice", "substitution_fns.create_new_example", "new_exs.append", "list", "substitution_fns.alias_substitution_fn.sub_fn"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.bin_wikidata_entities_by_popularity", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.create_new_example"], ["", "def", "popularity_substitution_fn", "(", "\n", "dset", ":", "QADataset", ",", "\n", "wikidata_info_path", ":", "str", ",", "\n", "replace_every", ":", "bool", ",", "\n", "num_bins", ":", "int", ",", "\n", "max_ents_per_pop", ":", "int", ",", "\n", "category", ":", "str", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Derives a new dataset of modified examples, where the original answer has been replaced\n    by a Wikidata entity of the same type, but with varying popularity. This\n    substitution first splits all Wikidata entities into bins of equal sizes\n    where each bin contains entities with similar popularities. For an original\n    instance, we create a new substituted instance for each bin by sampling an entity from each bin.\n    If `num_bins` is 1, then this function just samples from all of Wikidata.\n    This substitution only operates on human answers since the notion of popularity\n    for other answer types (e.g., dates) is ill-defined.\n\n    Args:\n        dset: The original QADataset\n        wikidata_info_path: ``str`` A path to a mapping from wikidata ID to a\n        dictionary of wikidata info (see extract_wikidata_info.py for details).\n        replace_every: If True, replace every original answer in the substitution examples context, otherwise replace just the primary one.\n        num_bins: ``int`` The number of bins which Wikidata entities are split into.\n            Each bin contains an equal number of Wikidata entities group by\n            popularity values. For each original instance, we create a substituted\n            instance for each bin by sampling an entity from the bin.\")\n        max_ents_per_pop: ``int`` The number of entities to keep per popularity value\n        category: This limits substitution generation to only use original examples with this \n            answer type category. `ALL` is an option. `PERSON` is the default for popularity\n            substitution as it yields the most reliable values.\n    \"\"\"", "\n", "\n", "def", "sub_fn", "(", "ex", ":", "QAExample", ",", "wikidata_popularity_bins", ":", "typing", ".", "List", "[", "typing", ".", "Dict", "]", ")", ":", "\n", "        ", "\"\"\"Derive all modified examples from one original example.\"\"\"", "\n", "new_exs", "=", "[", "]", "\n", "\n", "for", "bin_id", "in", "range", "(", "len", "(", "wikidata_popularity_bins", ")", ")", ":", "\n", "            ", "sub_qid", "=", "random", ".", "choice", "(", "list", "(", "wikidata_popularity_bins", "[", "bin_id", "]", ".", "keys", "(", ")", ")", ")", "\n", "sub_qid_info", "=", "wikidata_popularity_bins", "[", "bin_id", "]", "[", "sub_qid", "]", "\n", "\n", "new_ex", "=", "create_new_example", "(", "\n", "ex", "=", "ex", ",", "\n", "new_id", "=", "f\"pop-sub-{bin_id}\"", ",", "\n", "answer_text", "=", "sub_qid_info", "[", "\"label\"", "]", ",", "\n", "ner_label", "=", "None", ",", "\n", "kb_id", "=", "sub_qid", ",", "\n", "wikidata_label", "=", "sub_qid_info", "[", "\"label\"", "]", ",", "\n", "aliases", "=", "sub_qid_info", "[", "\"aliases\"", "]", ",", "\n", "wikidata_types", "=", "sub_qid_info", "[", "\"entity_types\"", "]", ",", "\n", "wikipedia_page", "=", "sub_qid_info", "[", "\"wikipedia_page\"", "]", ",", "\n", "popularity", "=", "sub_qid_info", "[", "\"popularity\"", "]", ",", "\n", "answer_type", "=", "None", ",", "\n", "replace_every_original_answer", "=", "replace_every", ",", "\n", ")", "\n", "new_exs", ".", "append", "(", "new_ex", ")", "\n", "", "return", "new_exs", "\n", "\n", "", "wikidata_popularity_bins", "=", "bin_wikidata_entities_by_popularity", "(", "\n", "wikidata_info_path", "=", "wikidata_info_path", ",", "\n", "max_ents_per_pop", "=", "max_ents_per_pop", ",", "\n", "num_bins", "=", "num_bins", ",", "\n", ")", "\n", "\n", "new_exs", "=", "[", "]", "\n", "for", "ex", "in", "dset", ".", "examples", ":", "\n", "        ", "ex_answer_type", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "ex_answer_type", "is", "not", "None", ":", "\n", "            ", "if", "category", ".", "lower", "(", ")", "==", "\"all\"", "or", "category", ".", "lower", "(", ")", "==", "ex_answer_type", ".", "lower", "(", ")", ":", "\n", "                ", "exs", "=", "sub_fn", "(", "ex", ",", "wikidata_popularity_bins", ")", "\n", "new_exs", ".", "extend", "(", "exs", ")", "\n", "\n", "", "", "", "print", "(", "f\"Finished Popularity Substitution, yielding {len(new_exs)} new examples.\"", ")", "\n", "return", "new_exs", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.type_swap_substitution_fn": [[238, 317], ["substitution_fns.group_answers_by_answer_type", "list", "collections.Counter", "print", "print", "print", "group_answers_by_answer_type.keys", "ex.get_example_answer_type", "ex.get_example_answer_type", "range", "substitution_fns.select_random_non_identical_answer", "substitution_fns.create_new_example", "new_exs.append", "ex.get_example_answer_type", "ex.original_example.get_example_answer_type", "category.lower", "category.lower", "ex.get_example_answer_type.lower", "substitution_fns.alias_substitution_fn.sub_fn"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.group_answers_by_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.select_random_non_identical_answer", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.create_new_example", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type"], ["", "def", "type_swap_substitution_fn", "(", "\n", "dset", ":", "QADataset", ",", "\n", "wikidata_info_path", ":", "str", ",", "\n", "replace_every", ":", "bool", ",", "\n", "num_samples", ":", "int", ",", "\n", "category", ":", "str", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Derives a new dataset of modified examples, where the original answer has been replaced\n    by another answer of a different `type` drawn randomly from the corpus of answers in the original dataset.\n    This substitution function is the same as corpus_substitution_fn except the answer types are different\n    rather than the same.\n\n    Args:\n        dset: The original QADataset\n        wikidata_info_path: A path to a mapping from wikidata ID to a dictionary of\n            wikidata info (see extract_wikidata_info.py for details).\n        replace_every: If True, replace every original answer in the substitution examples context, otherwise replace just the primary one.\n        num_samples: How many new (modified) examples to create from one original example.\n        category: This limits substitution generation to only use original examples with this answer type category. \n            `ALL` is an option.\n    \"\"\"", "\n", "# generate a corpus of substitute answers, keyed by answer type", "\n", "answer_corpus_by_groups", "=", "group_answers_by_answer_type", "(", "dset", ")", "\n", "group_types", "=", "list", "(", "answer_corpus_by_groups", ".", "keys", "(", ")", ")", "\n", "\n", "def", "sub_fn", "(", "ex", ":", "QAExample", ",", "target_group", ":", "str", ")", ":", "\n", "        ", "\"\"\"Derive all modified examples from one original example.\"\"\"", "\n", "new_exs", "=", "[", "]", "\n", "ex_ans_typ", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "ex_ans_typ", "is", "not", "None", ":", "\n", "            ", "for", "idx", "in", "range", "(", "num_samples", ")", ":", "\n", "                ", "sub_answer", "=", "select_random_non_identical_answer", "(", "\n", "ex", ",", "answer_corpus_by_groups", "[", "target_group", "]", "\n", ")", "\n", "new_ex", "=", "create_new_example", "(", "\n", "ex", "=", "ex", ",", "\n", "new_id", "=", "f\"type-swap-sub-{idx}\"", ",", "\n", "answer_text", "=", "sub_answer", ".", "text", ",", "\n", "ner_label", "=", "sub_answer", ".", "ner_label", ",", "\n", "kb_id", "=", "sub_answer", ".", "kb_id", ",", "\n", "wikidata_label", "=", "sub_answer", ".", "wikidata_label", ",", "\n", "aliases", "=", "sub_answer", ".", "aliases", ",", "\n", "wikidata_types", "=", "sub_answer", ".", "wikidata_types", ",", "\n", "wikipedia_page", "=", "sub_answer", ".", "wikipedia_page", ",", "\n", "popularity", "=", "sub_answer", ".", "popularity", ",", "\n", "answer_type", "=", "sub_answer", ".", "answer_type", ",", "\n", "replace_every_original_answer", "=", "replace_every", ",", "\n", ")", "\n", "new_exs", ".", "append", "(", "new_ex", ")", "\n", "", "", "return", "new_exs", "\n", "\n", "", "new_exs", "=", "[", "]", "\n", "for", "ex", "in", "dset", ".", "examples", ":", "\n", "        ", "ex_answer_type", "=", "ex", ".", "get_example_answer_type", "(", ")", "\n", "if", "ex_answer_type", "is", "not", "None", ":", "\n", "            ", "if", "category", ".", "lower", "(", ")", "==", "\"all\"", "or", "category", ".", "lower", "(", ")", "==", "ex_answer_type", ".", "lower", "(", ")", ":", "\n", "                ", "for", "target_group", "in", "group_types", ":", "\n", "                    ", "if", "target_group", "==", "ex", ".", "get_example_answer_type", "(", ")", ":", "\n", "                        ", "continue", "\n", "", "exs", "=", "sub_fn", "(", "ex", ",", "target_group", ")", "\n", "new_exs", ".", "extend", "(", "exs", ")", "\n", "\n", "", "", "", "", "group_counter", "=", "Counter", "(", "\n", "[", "\n", "(", "\n", "ex", ".", "get_example_answer_type", "(", ")", ",", "\n", "ex", ".", "original_example", ".", "get_example_answer_type", "(", ")", ",", "\n", ")", "\n", "for", "ex", "in", "new_exs", "\n", "]", "\n", ")", "\n", "print", "(", "\n", "f\"Num New Examples Generated by Answer Type Group (using num-samples={num_samples}, category={category})): {group_counter}\"", "\n", ")", "\n", "print", "(", "\n", "f\"NB: Not all original examples can be substituted, if their answer type is not discernable, or one of the 5 high-confidence identified by this NER model.\"", "\n", ")", "\n", "print", "(", "f\"Finished Type Swap Substitution.\"", ")", "\n", "return", "new_exs", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.create_new_example": [[324, 367], ["copy.deepcopy", "src.classes.answer.Answer", "copy.deepcopy.apply_substitution"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.apply_substitution"], ["", "def", "create_new_example", "(", "\n", "ex", ":", "QAExample", ",", "\n", "new_id", ":", "str", ",", "\n", "answer_text", ":", "str", ",", "\n", "ner_label", ":", "str", ",", "\n", "kb_id", ":", "str", ",", "\n", "wikidata_label", ":", "str", ",", "\n", "aliases", ":", "typing", ".", "List", "[", "str", "]", ",", "\n", "wikidata_types", ":", "typing", ".", "List", "[", "str", "]", ",", "\n", "wikipedia_page", ":", "str", ",", "\n", "popularity", ":", "int", ",", "\n", "answer_type", ":", "str", ",", "\n", "replace_every_original_answer", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Creates a new example from the original example, given the specified new metadata. Copies the \n    original example, initializes a new answer, and applies the answer substitution to the example.\n    \n    Args:\n        ex: The original example\n        other args: See the Answer init function in src/classes/answer.py for full details.\n        replace_every_original_answer: If False, only replace the main gold answer that appears\n            in the text, otherwise replace all valid gold answers that appear in the text.\n    \"\"\"", "\n", "sub_ex", "=", "copy", ".", "deepcopy", "(", "ex", ")", "\n", "sub_answer", "=", "Answer", "(", "\n", "text", "=", "answer_text", ",", "\n", "spans", "=", "None", ",", "\n", "ner_label", "=", "ner_label", ",", "\n", "kb_id", "=", "kb_id", ",", "\n", "wikidata_label", "=", "wikidata_label", ",", "\n", "aliases", "=", "aliases", ",", "\n", "wikidata_types", "=", "wikidata_types", ",", "\n", "wikipedia_page", "=", "wikipedia_page", ",", "\n", "popularity", "=", "popularity", ",", "\n", "answer_type", "=", "answer_type", ",", "\n", ")", "\n", "sub_ex", ".", "apply_substitution", "(", "\n", "sub_answer", ",", "\n", "ex", ",", "\n", "new_id", ",", "\n", "replace_every_original_answer", "=", "replace_every_original_answer", ",", "\n", ")", "\n", "return", "sub_ex", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.group_answers_by_answer_type": [[369, 377], ["collections.defaultdict"], "function", ["None"], ["", "def", "group_answers_by_answer_type", "(", "dset", ":", "QADataset", ")", ":", "\n", "    ", "\"\"\"Reorganizes a QADataset into a mapping from answer type to member answers.\"\"\"", "\n", "group_to_answer_sets", "=", "defaultdict", "(", "dict", ")", "\n", "for", "ex", "in", "dset", ".", "examples", ":", "\n", "        ", "for", "answer", "in", "ex", ".", "gold_answers", ":", "\n", "            ", "if", "answer", ".", "answer_type", ":", "\n", "                ", "group_to_answer_sets", "[", "answer", ".", "answer_type", "]", "[", "answer", ".", "text", "]", "=", "answer", "\n", "", "", "", "return", "group_to_answer_sets", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.select_random_non_identical_answer": [[379, 388], ["list", "src.utils.normalize_text", "sample_set.keys", "random.choice", "src.utils.normalize_text"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.normalize_text", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.normalize_text"], ["", "def", "select_random_non_identical_answer", "(", "ex", ":", "QAExample", ",", "sample_set", ":", "typing", ".", "List", "[", "str", "]", ")", ":", "\n", "    ", "\"\"\"Randomly samples an answer from `sample_set` that is non-identical to the gold answers\n    currently represented in the QAExample.\"\"\"", "\n", "norm_gold_answers", "=", "{", "normalize_text", "(", "ga", ".", "text", ")", ":", "ga", "for", "ga", "in", "ex", ".", "gold_answers", "}", "\n", "sample_keys", "=", "list", "(", "sample_set", ".", "keys", "(", ")", ")", "\n", "sub_key", "=", "None", "\n", "while", "not", "sub_key", "or", "normalize_text", "(", "sub_key", ")", "in", "norm_gold_answers", ":", "\n", "        ", "sub_key", "=", "random", ".", "choice", "(", "sample_keys", ")", "\n", "", "return", "sample_set", "[", "sub_key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.substitution_fns.bin_wikidata_entities_by_popularity": [[390, 440], ["list", "collections.defaultdict", "list", "sorted", "gzip.open", "json.load", "json.load.keys", "json.load.keys", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.load"], ["", "def", "bin_wikidata_entities_by_popularity", "(", "\n", "wikidata_info_path", ":", "str", ",", "num_bins", ":", "int", ",", "max_ents_per_pop", ":", "int", "=", "10", "\n", ")", ":", "\n", "    ", "\"\"\"Groups a list of Wikidata entities with the specified entity type into one of\n    `num_bins` equally sized bins based on entitye popularity. We only include\n    entities with the type \"Q5\" which is the Wikidata entity\n\n    Args:\n        wikidata_info_path: ``str`` Path to a .json.gz file containing Wikidata entity information\n        num_bins: ``int`` The number of bins to do the grouping\n        entity_type: ``str`` The entity type to do the grouping on. By default,\n            we only include entities with the type \"Q5\" which is the Wikidata entity\n        max_ents_per_pop: ``int`` The number of entities to keep per popularity value\n\n    Returns:\n        entity_popularity_bins: ``List[Dict]`` Returns a list where each list\n        corresponds to a bin. Within each list if a dictionary with entity information.\n    \"\"\"", "\n", "with", "gzip", ".", "open", "(", "wikidata_info_path", ",", "\"r\"", ")", "as", "reader", ":", "\n", "        ", "wikidata_info", "=", "json", ".", "load", "(", "reader", ")", "\n", "\n", "# Delete entities without the desired entity type", "\n", "", "for", "kb_id", "in", "list", "(", "wikidata_info", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "\"Q5\"", "not", "in", "wikidata_info", "[", "kb_id", "]", "[", "\"entity_types\"", "]", ":", "\n", "            ", "del", "wikidata_info", "[", "kb_id", "]", "\n", "\n", "# If there are multiple entities with the same pop, we only keep the first", "\n", "# `max_ents_per_pop`. This ensures that when we group entities into", "\n", "# equally sized bins, that we don't have too much bleeding where", "\n", "# entities with the same popularity are in different bins", "\n", "", "", "num_ents_per_pop", "=", "defaultdict", "(", "int", ")", "\n", "for", "kb_id", "in", "list", "(", "wikidata_info", ".", "keys", "(", ")", ")", ":", "\n", "        ", "pop", "=", "wikidata_info", "[", "kb_id", "]", "[", "\"popularity\"", "]", "\n", "if", "num_ents_per_pop", "[", "pop", "]", ">=", "max_ents_per_pop", ":", "\n", "            ", "del", "wikidata_info", "[", "kb_id", "]", "\n", "", "num_ents_per_pop", "[", "pop", "]", "+=", "1", "\n", "\n", "# Sort entity IDs (QID) by their popularity", "\n", "# type(entities) = List[str]", "\n", "", "kb_ids", "=", "sorted", "(", "wikidata_info", ",", "key", "=", "lambda", "x", ":", "wikidata_info", "[", "x", "]", "[", "\"popularity\"", "]", ")", "\n", "\n", "# Split list of entities into a list (of len `num_bins`) of list of entities", "\n", "# type(entity_popularity_bins) = List[Dict]", "\n", "bin_size", "=", "len", "(", "kb_ids", ")", "//", "num_bins", "+", "1", "\n", "entity_popularity_bins", "=", "[", "\n", "{", "kb_id", ":", "wikidata_info", "[", "kb_id", "]", "for", "kb_id", "in", "kb_ids", "[", "i", ":", "i", "+", "bin_size", "]", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "kb_ids", ")", ",", "bin_size", ")", "\n", "]", "\n", "\n", "return", "entity_popularity_bins", "\n", "", ""]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_label": [[31, 36], ["None"], "function", ["None"], ["", "def", "extract_label", "(", "line", ")", ":", "\n", "    ", "\"\"\"Extracts the English label (canonical name) for an entity\"\"\"", "\n", "if", "\"en\"", "in", "line", "[", "\"labels\"", "]", ":", "\n", "        ", "return", "line", "[", "\"labels\"", "]", "[", "\"en\"", "]", "[", "\"value\"", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_aliases": [[38, 43], ["None"], "function", ["None"], ["", "def", "extract_aliases", "(", "line", ")", ":", "\n", "    ", "\"\"\"Extracts alternative English names for an entity\"\"\"", "\n", "if", "\"en\"", "in", "line", "[", "\"aliases\"", "]", ":", "\n", "        ", "return", "[", "d", "[", "\"value\"", "]", "for", "d", "in", "line", "[", "\"aliases\"", "]", "[", "\"en\"", "]", "]", "\n", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_entity_types": [[45, 53], ["entity_types.append"], "function", ["None"], ["", "def", "extract_entity_types", "(", "line", ")", ":", "\n", "    ", "\"\"\"Extracts the entity type for an entity\"\"\"", "\n", "entity_types", "=", "[", "]", "\n", "if", "\"P31\"", "in", "line", "[", "\"claims\"", "]", ":", "\n", "        ", "for", "d", "in", "line", "[", "\"claims\"", "]", "[", "\"P31\"", "]", ":", "\n", "            ", "if", "\"mainsnak\"", "in", "d", "and", "\"datavalue\"", "in", "d", "[", "\"mainsnak\"", "]", ":", "\n", "                ", "entity_types", ".", "append", "(", "d", "[", "\"mainsnak\"", "]", "[", "\"datavalue\"", "]", "[", "\"value\"", "]", "[", "\"id\"", "]", ")", "\n", "", "", "", "return", "entity_types", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_wikipedia_page": [[55, 60], ["[].strip().replace", "[].strip"], "function", ["None"], ["", "def", "extract_wikipedia_page", "(", "line", ")", ":", "\n", "    ", "\"\"\"Extracts the Wikipedia page for an entity\"\"\"", "\n", "if", "\"sitelinks\"", "in", "line", "and", "\"enwiki\"", "in", "line", "[", "\"sitelinks\"", "]", ":", "\n", "        ", "return", "line", "[", "\"sitelinks\"", "]", "[", "\"enwiki\"", "]", "[", "\"title\"", "]", ".", "strip", "(", ")", ".", "replace", "(", "\" \"", ",", "\"_\"", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_popularities": [[62, 84], ["collections.defaultdict", "print", "bz2.open", "tqdm.tqdm", "line.strip().split.strip().split", "int", "len", "line.strip().split.strip", "len"], "function", ["None"], ["", "def", "extract_popularities", "(", "popularity_dump", ")", ":", "\n", "    ", "\"\"\"Iterate through the Wikipedia popularity dump without decompressing\n    it, storing each English Wikipedia page's number of page views.\n\n    Args:\n        popularity_dump: ``str`` A path to a .BZ2 file containing Wikipedia\n        page views for a day.\n\n    Returns:\n        wiki_popularity: ``dict`` Maps from a Wikipedia page to the daily\n        page view count.\n    \"\"\"", "\n", "wiki_popularity", "=", "collections", ".", "defaultdict", "(", "int", ")", "\n", "with", "bz2", ".", "open", "(", "popularity_dump", ",", "\"rt\"", ")", "as", "bz_file", ":", "\n", "# Each line corresponds to the number of page views for a Wikipedia page", "\n", "        ", "for", "line", "in", "tqdm", ".", "tqdm", "(", "bz_file", ",", "desc", "=", "\"Loading Wikipedia popularity values\"", ")", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "# Skip lines w/o right len or Wikipedia pages that aren't in English", "\n", "if", "len", "(", "line", ")", "==", "6", "and", "line", "[", "0", "]", "==", "\"en.wikipedia\"", ":", "\n", "                ", "wiki_popularity", "[", "line", "[", "1", "]", "]", "+=", "int", "(", "line", "[", "4", "]", ")", "\n", "", "", "", "print", "(", "f\"Found {len(wiki_popularity)} English Wikipedia pages\"", ")", "\n", "return", "wiki_popularity", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_entity_information": [[86, 153], ["src.utils.BasicTimer", "extract_wikidata_info.extract_popularities", "os.makedirs", "gzip.open", "gzip.open.write", "gzip.open.close", "src.utils.BasicTimer.finish", "os.path.dirname", "bz2.open", "tqdm.tqdm", "json.loads.strip", "json.loads", "extract_wikidata_info.extract_label", "extract_wikidata_info.extract_aliases", "extract_wikidata_info.extract_entity_types", "extract_wikidata_info.extract_wikipedia_page", "extract_popularities.get", "gzip.open.write", "gzip.open.write", "json.dumps", "json.dumps"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_popularities", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.finish", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_label", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_aliases", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_entity_types", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_wikipedia_page"], ["", "def", "extract_entity_information", "(", "popularity_dump", ",", "wikidata_dump", ",", "output_file", ")", ":", "\n", "    ", "\"\"\"For each Wikidata entity in the Wikidata dump, we extract out it's entity\n    type, associated Wikipedia page (used for popularity), all aliases\n    for the entity, and popularity of the entity's Wikipedia page, then write\n    this information into a JSON file. We write each dictionary of entity\n    information in it's own line for easy readability.\n\n    Args:\n        popularity_dump: ``str``: Path to the Wikipedia popularity dump\n        wikidata_dump: ``str`` Path to the Wikidata dump\n        output_file: ``str`` Output JSON file\n    \"\"\"", "\n", "timer", "=", "BasicTimer", "(", "f\"Extracting Wikidata entities information\"", ")", "\n", "# Iterate through the Wikipedia popularity dump without decompressing it,", "\n", "# storing each English Wikipedia page's number of page views.", "\n", "wiki_popularity", "=", "extract_popularities", "(", "popularity_dump", ")", "\n", "\n", "# Iterate through the Wikidata dump without decompressing it", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "output_file", ")", ",", "exist_ok", "=", "True", ")", "\n", "writer", "=", "gzip", ".", "open", "(", "output_file", ",", "\"wb\"", ")", "\n", "\n", "with", "bz2", ".", "open", "(", "wikidata_dump", ",", "\"rt\"", ")", "as", "bz_file", ":", "\n", "        ", "lines_written", "=", "0", "\n", "# Each line corresponds to a dictionary about a Wikidata entity", "\n", "for", "line", "in", "tqdm", ".", "tqdm", "(", "bz_file", ",", "desc", "=", "\"Processing Wikidata\"", ",", "smoothing", "=", "0", ")", ":", "\n", "# The first and last lines of this file are list delimiters, skip these.", "\n", "# We also add a hack that checks if the entity has an English Wikipedia", "\n", "# page. If not, we skip the line (and thus the JSON loading which is slow)", "\n", "# Removing this hack does not change the resulting file.", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "==", "\"[\"", "or", "line", "==", "\"]\"", "or", "'\"enwiki\"'", "not", "in", "line", ":", "\n", "                ", "continue", "\n", "\n", "# Remove last character (comma), then decode", "\n", "", "line", "=", "json", ".", "loads", "(", "line", "[", ":", "-", "1", "]", ")", "\n", "\n", "# For each line, extract out relevant Wikidata information", "\n", "label", "=", "extract_label", "(", "line", ")", "\n", "aliases", "=", "extract_aliases", "(", "line", ")", "\n", "entity_types", "=", "extract_entity_types", "(", "line", ")", "\n", "wikipedia_page", "=", "extract_wikipedia_page", "(", "line", ")", "\n", "popularity", "=", "wiki_popularity", ".", "get", "(", "wikipedia_page", ")", "\n", "\n", "# Skip if no entity type, label, or popularity value", "\n", "if", "label", "is", "None", "or", "popularity", "is", "None", "or", "entity_types", "==", "[", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "entity_dict", "=", "{", "\n", "\"label\"", ":", "label", ",", "\n", "\"aliases\"", ":", "aliases", ",", "\n", "\"entity_types\"", ":", "entity_types", ",", "\n", "\"wikipedia_page\"", ":", "wikipedia_page", ",", "\n", "\"popularity\"", ":", "popularity", ",", "\n", "}", "\n", "\n", "# Write extracted dictionary into a JSON format, one line at a time", "\n", "if", "lines_written", ">", "0", ":", "\n", "                ", "writer", ".", "write", "(", "b\",\\n\"", ")", "\n", "", "writer", ".", "write", "(", "\n", "f\"{json.dumps(line['id'])}: \"", "\n", "f\"{json.dumps(entity_dict, ensure_ascii=False)}\"", ".", "encode", "(", ")", "\n", ")", "\n", "lines_written", "+=", "1", "\n", "\n", "", "", "writer", ".", "write", "(", "b\"\\n}\"", ")", "\n", "writer", ".", "close", "(", ")", "\n", "timer", ".", "finish", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.main": [[155, 188], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "extract_wikidata_info.extract_entity_information"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.extract_wikidata_info.extract_entity_information"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"\n    For each Wikidata entity in the Wikidata dump, we extract out it's entity\n    type, associated Wikipedia page (used for popularity), all aliases\n    for the entity, and popularity of the entity's Wikipedia page, then write\n    this information into a compressed JSON file. We write each dictionary of entity\n    information in it's own line for easy readability.\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-w\"", ",", "\n", "\"--wikidata_dump\"", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"Compressed .json.bz2 Wikidata dump for information extraction\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\n", "\"--popularity_dump\"", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"Compressed .bz2 Wikipedia popularity dump\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\n", "\"--output_file\"", ",", "\n", "default", "=", "\"wikidata/entity_info.json.gz\"", ",", "\n", "help", "=", "\"Output compressed JSON file for writing Wikidata entity information.\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "extract_entity_information", "(", "\n", "popularity_dump", "=", "args", ".", "popularity_dump", ",", "\n", "wikidata_dump", "=", "args", ".", "wikidata_dump", ",", "\n", "output_file", "=", "args", ".", "output_file", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.load_dataset.load_and_preprocess_dataset": [[29, 33], ["dataset_class.new", "dataset_class.new.preprocess"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.new", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.preprocess"], ["def", "load_and_preprocess_dataset", "(", "args", ")", ":", "\n", "    ", "dataset_class", ",", "url_or_path", "=", "DATASETS", "[", "args", ".", "dataset", "]", "\n", "dataset", "=", "dataset_class", ".", "new", "(", "args", ".", "dataset", ",", "url_or_path", ")", "\n", "dataset", ".", "preprocess", "(", "args", ".", "wikidata", ",", "args", ".", "ner_model", ",", "args", ".", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.__init__": [[67, 74], ["round", "round", "print", "time.time", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ")", "->", "None", ":", "\n", "        ", "self", ".", "_name", "=", "name", "\n", "self", ".", "_running", "=", "True", "\n", "self", ".", "_total", "=", "0.0", "\n", "self", ".", "_start", "=", "round", "(", "time", ".", "time", "(", ")", ",", "2", ")", "\n", "self", ".", "_interval_time", "=", "round", "(", "time", ".", "time", "(", ")", ",", "2", ")", "\n", "print", "(", "f\"Timer [{self._name}] starting now\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.reset": [[75, 80], ["round", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "reset", "(", "self", ")", "->", "\"BasicTimer\"", ":", "\n", "        ", "self", ".", "_running", "=", "True", "\n", "self", ".", "_total", "=", "0", "\n", "self", ".", "_start", "=", "round", "(", "time", ".", "time", "(", ")", ",", "2", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.interval": [[81, 86], ["utils.BasicTimer._to_hms", "print", "round", "round", "time.time", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer._to_hms", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "interval", "(", "self", ",", "intervalName", ":", "str", ")", ":", "\n", "        ", "intervalTime", "=", "self", ".", "_to_hms", "(", "round", "(", "time", ".", "time", "(", ")", "-", "self", ".", "_interval_time", ",", "2", ")", ")", "\n", "print", "(", "f\"Timer [{self._name}] interval [{intervalName}]: {intervalTime}\"", ")", "\n", "self", ".", "_interval_time", "=", "round", "(", "time", ".", "time", "(", ")", ",", "2", ")", "\n", "return", "intervalTime", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.stop": [[87, 92], ["round", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "stop", "(", "self", ")", "->", "\"BasicTimer\"", ":", "\n", "        ", "if", "self", ".", "_running", ":", "\n", "            ", "self", ".", "_running", "=", "False", "\n", "self", ".", "_total", "+=", "round", "(", "time", ".", "time", "(", ")", "-", "self", ".", "_start", ",", "2", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.resume": [[93, 98], ["round", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "resume", "(", "self", ")", "->", "\"BasicTimer\"", ":", "\n", "        ", "if", "not", "self", ".", "_running", ":", "\n", "            ", "self", ".", "_running", "=", "True", "\n", "self", ".", "_start", "=", "round", "(", "time", ".", "time", "(", ")", ",", "2", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time": [[99, 103], ["round", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "time", "(", "self", ")", "->", "float", ":", "\n", "        ", "if", "self", ".", "_running", ":", "\n", "            ", "return", "round", "(", "self", ".", "_total", "+", "time", ".", "time", "(", ")", "-", "self", ".", "_start", ",", "2", ")", "\n", "", "return", "self", ".", "_total", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.finish": [[104, 110], ["print", "round", "utils.BasicTimer._to_hms", "time.time"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer._to_hms", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.time"], ["", "def", "finish", "(", "self", ")", "->", "None", ":", "\n", "        ", "if", "self", ".", "_running", ":", "\n", "            ", "self", ".", "_running", "=", "False", "\n", "self", ".", "_total", "+=", "round", "(", "time", ".", "time", "(", ")", "-", "self", ".", "_start", ",", "2", ")", "\n", "elapsed", "=", "self", ".", "_to_hms", "(", "self", ".", "_total", ")", "\n", "", "print", "(", "f\"Timer [{self._name}] finished in {elapsed}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer._to_hms": [[111, 115], ["divmod", "divmod"], "methods", ["None"], ["", "def", "_to_hms", "(", "self", ",", "seconds", ":", "float", ")", "->", "str", ":", "\n", "        ", "m", ",", "s", "=", "divmod", "(", "seconds", ",", "60", ")", "\n", "h", ",", "m", "=", "divmod", "(", "m", ",", "60", ")", "\n", "return", "\"%dh %02dm %02ds\"", "%", "(", "h", ",", "m", ",", "s", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.argparse_str2bool": [[11, 21], ["isinstance", "v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "argparse_str2bool", "(", "v", ")", ":", "\n", "    ", "\"\"\"Infers whether an argparse input indicates True or False.\"\"\"", "\n", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "        ", "return", "v", "\n", "", "if", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"y\"", ",", "\"1\"", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "\"no\"", ",", "\"false\"", ",", "\"f\"", ",", "\"n\"", ",", "\"0\"", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "\"Boolean value expected.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.run_ner_linking": [[23, 42], ["spacy.load", "tqdm.tqdm", "spacy.load.", "datum.append", "e.kb_id_[].isnumeric"], "function", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.load"], ["", "", "def", "run_ner_linking", "(", "texts", ":", "typing", ".", "List", "[", "str", "]", ",", "ner_model_path", ":", "str", ")", ":", "\n", "    ", "\"\"\"Loads and runs the Named Entity Recognition + Entity Linking model on all `texts`, \n    saving their named entity labels and Wikidata IDs if found.\n    \"\"\"", "\n", "nlp", "=", "spacy", ".", "load", "(", "ner_model_path", ")", "\n", "\n", "text_to_info", "=", "{", "}", "\n", "for", "text", "in", "tqdm", "(", "texts", ",", "desc", "=", "\"Running Named Entity Linking\"", ")", ":", "\n", "        ", "doc", "=", "nlp", "(", "text", ")", "\n", "datum", "=", "[", "]", "\n", "for", "e", "in", "doc", ".", "ents", ":", "\n", "            ", "kb_id", "=", "(", "\n", "e", ".", "kb_id_", "if", "\"Q\"", "==", "e", ".", "kb_id_", "[", "0", "]", "and", "e", ".", "kb_id_", "[", "1", ":", "]", ".", "isnumeric", "(", ")", "else", "None", "\n", ")", "\n", "datum", ".", "append", "(", "\n", "{", "\"text\"", ":", "e", ".", "text", ",", "\"label\"", ":", "e", ".", "label_", ",", "\"id\"", ":", "kb_id", ",", "}", "\n", ")", "\n", "", "text_to_info", "[", "text", "]", "=", "datum", "\n", "", "return", "text_to_info", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.normalize_text": [[44, 62], ["utils.normalize_text.white_space_fix"], "function", ["None"], ["", "def", "normalize_text", "(", "s", ")", ":", "\n", "    ", "\"\"\"Lower text and remove punctuation, articles and extra whitespace.\"\"\"", "\n", "\n", "def", "remove_articles", "(", "text", ")", ":", "\n", "        ", "regex", "=", "re", ".", "compile", "(", "r\"\\b(a|an|the)\\b\"", ",", "re", ".", "UNICODE", ")", "\n", "return", "re", ".", "sub", "(", "regex", ",", "\" \"", ",", "text", ")", "\n", "\n", "", "def", "white_space_fix", "(", "text", ")", ":", "\n", "        ", "return", "\" \"", ".", "join", "(", "text", ".", "split", "(", ")", ")", "\n", "\n", "", "def", "remove_punc", "(", "text", ")", ":", "\n", "        ", "exclude", "=", "set", "(", "string", ".", "punctuation", ")", "\n", "return", "\"\"", ".", "join", "(", "ch", "for", "ch", "in", "text", "if", "ch", "not", "in", "exclude", ")", "\n", "\n", "", "def", "lower", "(", "text", ")", ":", "\n", "        ", "return", "text", ".", "lower", "(", ")", "\n", "\n", "", "return", "white_space_fix", "(", "remove_articles", "(", "remove_punc", "(", "lower", "(", "s", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.__init__": [[12, 42], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "uid", ":", "str", ",", "\n", "query", ":", "str", ",", "\n", "context", ":", "str", ",", "\n", "gold_answers", ":", "typing", ".", "List", "[", "Answer", "]", ",", "\n", "is_substitute", ":", "bool", "=", "False", ",", "\n", "metadata", ":", "typing", ".", "Dict", "[", "str", ",", "str", "]", "=", "None", ",", "\n", "original_example", ":", "\"QAExample\"", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Do not invoke directly. Use `new` or `json_load`.\n\n        Fields:\n            uid: A unique identifier for this example.\n            query: The query. \n            context: The context passage.\n            gold_answers: A list of `Answer` objects, that represent gold answers to the question.\n            is_substitute: Whether or not this example is the original or a substitute.\n            metadata: Any additional info the user can populate here.\n            original_example: If this example is a substitute, then this field oints to the \n                full original example.\n        \"\"\"", "\n", "self", ".", "uid", "=", "uid", "\n", "self", ".", "query", "=", "query", "\n", "self", ".", "context", "=", "context", "\n", "self", ".", "gold_answers", "=", "gold_answers", "\n", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "is_substitute", "=", "is_substitute", "\n", "self", ".", "original_example", "=", "original_example", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.new": [[43, 70], ["cls", "cls._find_answer_in_context", "gold_answers.append", "src.classes.answer.Answer"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample._find_answer_in_context"], ["", "@", "classmethod", "\n", "def", "new", "(", "\n", "cls", ",", "\n", "uid", ":", "str", ",", "\n", "query", ":", "str", ",", "\n", "context", ":", "str", ",", "\n", "answers", ":", "typing", ".", "List", "[", "str", "]", ",", "\n", "is_substitute", ":", "bool", "=", "False", ",", "\n", "metadata", ":", "typing", ".", "Dict", "[", "str", ",", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiates and returns a new QAExample.\n\n        Given textual answers, it finds them in the context and instantiates them \n        as `Answer` objects.\n        \"\"\"", "\n", "gold_answers", "=", "[", "]", "\n", "for", "text", "in", "answers", ":", "\n", "            ", "context_spans", "=", "cls", ".", "_find_answer_in_context", "(", "text", ",", "context", ")", "\n", "gold_answers", ".", "append", "(", "Answer", "(", "text", ",", "spans", "=", "context_spans", ")", ")", "\n", "", "return", "cls", "(", "\n", "uid", "=", "uid", ",", "\n", "query", "=", "query", ",", "\n", "context", "=", "context", ",", "\n", "gold_answers", "=", "gold_answers", ",", "\n", "is_substitute", "=", "is_substitute", ",", "\n", "metadata", "=", "metadata", ",", "\n", "original_example", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.json_load": [[72, 84], ["json.loads", "cls", "src.classes.answer.Answer.json_load"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_load"], ["", "@", "classmethod", "\n", "def", "json_load", "(", "cls", ",", "json_obj", ")", ":", "\n", "        ", "\"\"\"Loads a json dump of a QAExample. Call this after `self.json_dump`.\"\"\"", "\n", "obj", "=", "json", ".", "loads", "(", "json_obj", ")", "\n", "return", "cls", "(", "\n", "uid", "=", "obj", "[", "\"uid\"", "]", ",", "\n", "query", "=", "obj", "[", "\"query\"", "]", ",", "\n", "context", "=", "obj", "[", "\"context\"", "]", ",", "\n", "gold_answers", "=", "[", "Answer", ".", "json_load", "(", "ga_obj", ")", "for", "ga_obj", "in", "obj", "[", "\"gold_answers\"", "]", "]", ",", "\n", "is_substitute", "=", "obj", "[", "\"is_substitute\"", "]", ",", "\n", "metadata", "=", "obj", "[", "\"metadata\"", "]", ",", "\n", "original_example", "=", "obj", "[", "\"original_example\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample._find_answer_in_context": [[86, 97], ["m.start", "m.end", "re.finditer", "re.escape", "context.lower", "answer_text.lower"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_find_answer_in_context", "(", "cls", ",", "answer_text", ":", "str", ",", "context", ":", "str", ")", ":", "\n", "        ", "\"\"\"Finds all instances of the `answer_text` in the context passage.\n        \n        Returns a list of (start index, end index) tuples.\n        \"\"\"", "\n", "context_spans", "=", "[", "\n", "(", "m", ".", "start", "(", ")", ",", "m", ".", "end", "(", ")", ")", "\n", "for", "m", "in", "re", ".", "finditer", "(", "re", ".", "escape", "(", "answer_text", ".", "lower", "(", ")", ")", ",", "context", ".", "lower", "(", ")", ")", "\n", "]", "\n", "return", "context_spans", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.json_dump": [[98, 118], ["ga.json_dump", "qaexample.QAExample.original_example.json_dump"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_dump", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_dump"], ["", "def", "json_dump", "(", "self", ",", "save_full", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Creates a json dump of this QAExample.\n        \n        save_full: whether to save all of the original example, or just it's `uid`.\n        \"\"\"", "\n", "save_obj", "=", "{", "\n", "\"uid\"", ":", "self", ".", "uid", ",", "\n", "\"query\"", ":", "self", ".", "query", ",", "\n", "\"context\"", ":", "self", ".", "context", ",", "\n", "\"metadata\"", ":", "self", ".", "metadata", ",", "\n", "\"is_substitute\"", ":", "self", ".", "is_substitute", ",", "\n", "\"gold_answers\"", ":", "[", "ga", ".", "json_dump", "(", ")", "for", "ga", "in", "self", ".", "gold_answers", "]", ",", "\n", "\"original_example\"", ":", "None", ",", "\n", "}", "\n", "if", "self", ".", "original_example", ":", "\n", "            ", "if", "save_full", ":", "\n", "                ", "save_obj", "[", "\"original_example\"", "]", "=", "self", ".", "original_example", ".", "json_dump", "(", ")", "\n", "", "else", ":", "\n", "                ", "save_obj", "[", "\"original_example\"", "]", "=", "self", ".", "original_example", ".", "uid", "\n", "", "", "return", "save_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.apply_substitution": [[119, 148], ["qaexample.QAExample.update_context_with_substitution", "qaexample.QAExample._find_answer_in_context"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.update_context_with_substitution", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample._find_answer_in_context"], ["", "def", "apply_substitution", "(", "\n", "self", ",", "\n", "sub_answer", ":", "Answer", ",", "\n", "original_example", ":", "\"QAExample\"", ",", "\n", "sub_type", ":", "str", ",", "\n", "replace_every_original_answer", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Applies the substitution to this example, modifying it's own uid, context \n        and gold answers.\n\n        Args:\n            sub_answer: The new Answer object that is replacing the existing gold_answers\n            original_example: A copy of the original example to be saved\n            sub_type: a prefix that represents this type of substitution, saved as part of the new\n                uid.\n            replace_every_original_answer: If False, only replace the main gold answer that appears\n                in the text, otherwise replace all valid gold answers that appear in the text.\n        \"\"\"", "\n", "# update uid", "\n", "self", ".", "uid", "=", "f\"{sub_type}_{self.uid}\"", "\n", "# update context", "\n", "self", ".", "update_context_with_substitution", "(", "\n", "sub_answer", ",", "replace_every_original_answer", "=", "replace_every_original_answer", "\n", ")", "\n", "# update new answer with spans", "\n", "spans", "=", "self", ".", "_find_answer_in_context", "(", "sub_answer", ".", "text", ",", "self", ".", "context", ")", "\n", "self", ".", "gold_answers", "=", "[", "sub_answer", "]", "\n", "self", ".", "is_substitute", "=", "True", "\n", "self", ".", "original_example", "=", "original_example", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.update_context_with_substitution": [[149, 167], ["set", "replace_spans.extend", "qaexample.QAExample.context.replace", "qaexample.QAExample._find_answer_in_context", "a.is_answer_in_context"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample._find_answer_in_context", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.is_answer_in_context"], ["", "def", "update_context_with_substitution", "(", "\n", "self", ",", "sub_answer", ":", "Answer", ",", "replace_every_original_answer", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"Replace all found instances of the answer in the context.\"\"\"", "\n", "replace_spans", "=", "[", "]", "\n", "replace_answers", "=", "(", "\n", "self", ".", "gold_answers", "\n", "if", "replace_every_original_answer", "\n", "else", "[", "a", "for", "a", "in", "self", ".", "gold_answers", "if", "a", ".", "is_answer_in_context", "(", ")", "]", "[", "0", "]", "\n", ")", "\n", "for", "orig_answer", "in", "self", ".", "gold_answers", ":", "\n", "            ", "replace_spans", ".", "extend", "(", "\n", "self", ".", "_find_answer_in_context", "(", "orig_answer", ".", "text", ",", "self", ".", "context", ")", "\n", ")", "\n", "# Find and replace all string variants that correspond to the original answer in the context", "\n", "", "replace_strs", "=", "set", "(", "[", "self", ".", "context", "[", "span", "[", "0", "]", ":", "span", "[", "1", "]", "]", "for", "span", "in", "replace_spans", "]", ")", "\n", "for", "replace_str", "in", "replace_strs", ":", "\n", "            ", "self", ".", "context", "=", "self", ".", "context", ".", "replace", "(", "replace_str", ",", "sub_answer", ".", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_answers_in_context": [[168, 171], ["ga.is_answer_in_context"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.is_answer_in_context"], ["", "", "def", "get_answers_in_context", "(", "self", ")", ":", "\n", "        ", "\"\"\"Find all gold answers that appear in the context passage, excluding those that don't.\"\"\"", "\n", "return", "[", "ga", "for", "ga", "in", "self", ".", "gold_answers", "if", "ga", ".", "is_answer_in_context", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type": [[172, 183], ["collections.Counter", "collections.Counter.most_common"], "methods", ["None"], ["", "def", "get_example_answer_type", "(", "self", ")", ":", "\n", "        ", "\"\"\"For an example with multiple answers (potentially of different types) this function\n        decides what type of answer the query likely needs for substitutions.\n        \"\"\"", "\n", "answer_type_counts", "=", "Counter", "(", "\n", "[", "answer", ".", "answer_type", "for", "answer", "in", "self", ".", "gold_answers", "if", "answer", ".", "answer_type", "]", "\n", ")", "\n", "most_common_types", "=", "answer_type_counts", ".", "most_common", "(", "1", ")", "\n", "if", "most_common_types", ":", "\n", "            ", "return", "most_common_types", "[", "0", "]", "[", "0", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.__repr__": [[184, 186], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.uid} | {self.query} | {self.context[:100]} ...\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.__init__": [[22, 42], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", ",", "\n", "original_path", ":", "str", ",", "\n", "preprocessed_path", ":", "str", ",", "\n", "examples", ":", "typing", ".", "List", "[", "QAExample", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Do not invoke directly. Use `new` or `load`.\n        \n        Fields:\n            name: The name of the dataset --- also used to derive the save path.\n            original_path: The original path of the unprocessed data.\n            preprocessed_path: The path to the data after processing and saving.\n            examples: A list of QAExamples in this dataset. This field is populated by\n                `self.read_original_dataset` and later augmented by `self.preprocess`.\n        \"\"\"", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "original_path", "=", "original_path", "\n", "self", ".", "preprocessed_path", "=", "preprocessed_path", "\n", "self", ".", "examples", "=", "examples", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.new": [[43, 59], ["os.path.exists", "cls._get_norm_dataset_path", "cls", "os.path.join", "cls._download", "os.path.basename().split", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._get_norm_dataset_path", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._download"], ["", "@", "classmethod", "\n", "def", "new", "(", "cls", ",", "name", ":", "str", ",", "url_or_path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Returns a new QADataset object.\n\n        Args:\n            name: Identifying name of this dataset.\n            url_or_path: Either the URL to download from, or the local path to read from.\n        \"\"\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "url_or_path", ")", ":", "\n", "            ", "original_path", "=", "url_or_path", "\n", "", "else", ":", "\n", "            ", "file_suffix", "=", "\".\"", ".", "join", "(", "os", ".", "path", ".", "basename", "(", "url_or_path", ")", ".", "split", "(", "\".\"", ")", "[", "1", ":", "]", ")", "\n", "original_path", "=", "os", ".", "path", ".", "join", "(", "ORIG_DATA_DIR", ",", "f\"{name}.{file_suffix}\"", ")", "\n", "cls", ".", "_download", "(", "name", ",", "url_or_path", ",", "original_path", ")", "\n", "", "preprocessed_path", "=", "cls", ".", "_get_norm_dataset_path", "(", "name", ")", "\n", "return", "cls", "(", "name", ",", "original_path", ",", "preprocessed_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.load": [[60, 79], ["cls._get_norm_dataset_path", "os.path.exists", "print", "cls", "gzip.open", "json.loads", "inf.readline", "src.classes.qaexample.QAExample.json_load", "inf.readlines", "len"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._get_norm_dataset_path", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_load"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Loads and returns a QADataset object that has already been \n        `self.preprocess` and `self.save()`d\n\n        Args:\n            name: Identifying name of this dataset.\n        \"\"\"", "\n", "preprocessed_path", "=", "cls", ".", "_get_norm_dataset_path", "(", "name", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "\n", "preprocessed_path", "\n", ")", ",", "f\"Preprocessed dataset should be at {preprocessed_path}.\"", "\n", "with", "gzip", ".", "open", "(", "preprocessed_path", ",", "\"r\"", ")", "as", "inf", ":", "\n", "            ", "header", "=", "json", ".", "loads", "(", "inf", ".", "readline", "(", ")", ")", "\n", "assert", "header", "[", "\"dataset\"", "]", "==", "name", "\n", "examples", "=", "[", "QAExample", ".", "json_load", "(", "l", ")", "for", "l", "in", "inf", ".", "readlines", "(", ")", "]", "\n", "\n", "", "print", "(", "f\"Read {len(examples)} examples from {preprocessed_path}\"", ")", "\n", "return", "cls", "(", "name", ",", "header", "[", "\"original_path\"", "]", ",", "preprocessed_path", ",", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._get_norm_dataset_path": [[80, 84], ["os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_norm_dataset_path", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Formats the path to the normalized/preprocessed data.\"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "NORM_DATA_DIR", ",", "f\"{name}.jsonl.gz\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._download": [[85, 92], ["os.path.exists", "os.makedirs", "print", "wget.download", "os.path.dirname"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_download", "(", "cls", ",", "name", ":", "str", ",", "url", ":", "str", ",", "dest_path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Downloads the original dataset from `url` to `dest_path`.\"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dest_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "dest_path", ")", ",", "exist_ok", "=", "True", ")", "\n", "print", "(", "f\"Downloading Original Dataset: {name}\"", ")", "\n", "wget", ".", "download", "(", "url", ",", "dest_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.save": [[93, 103], ["os.makedirs", "print", "os.path.dirname", "gzip.open", "json.dump", "outf.write", "json.dump", "outf.write", "ex.json_dump"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_dump"], ["", "", "def", "save", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save the preprocessed dataset to JSONL.GZ file. Can be loaded using `self.load()`.\"\"\"", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "self", ".", "preprocessed_path", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "gzip", ".", "open", "(", "self", ".", "preprocessed_path", ",", "\"wt\"", ")", "as", "outf", ":", "\n", "            ", "json", ".", "dump", "(", "{", "\"dataset\"", ":", "self", ".", "name", ",", "\"original_path\"", ":", "self", ".", "original_path", "}", ",", "outf", ")", "\n", "outf", ".", "write", "(", "\"\\n\"", ")", "\n", "for", "ex", "in", "self", ".", "examples", ":", "\n", "                ", "json", ".", "dump", "(", "ex", ".", "json_dump", "(", ")", ",", "outf", ")", "\n", "outf", ".", "write", "(", "\"\\n\"", ")", "\n", "", "", "print", "(", "f\"Saved preprocessed dataset to {self.preprocessed_path}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.read_original_dataset": [[104, 111], ["None"], "methods", ["None"], ["", "def", "read_original_dataset", "(", "self", ",", "file_path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Reads the original/raw dataset into a List of QAExamples.\n        \n        NB: This is to be implemented by QADataset subclasses, for the specific \n        dataset they represent.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.preprocess": [[112, 139], ["src.utils.BasicTimer", "qadataset.QADataset.read_original_dataset", "print", "qadataset.QADataset.label_entities", "src.utils.BasicTimer.interval", "qadataset.QADataset.wikidata_linking", "src.utils.BasicTimer.interval", "qadataset.QADataset._report_dataset_stats", "qadataset.QADataset.save", "src.utils.BasicTimer.finish", "len"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.MRQANaturalQuetsionsDataset.read_original_dataset", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.label_entities", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.interval", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.wikidata_linking", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.interval", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._report_dataset_stats", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.save", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.BasicTimer.finish"], ["", "def", "preprocess", "(", "\n", "self", ",", "wikidata_info_path", ":", "str", ",", "ner_model_path", ":", "str", ",", "debug", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"Read the original dataset, normalize its format and preprocess it. This includes\n        running the NER model on the answers, and linking those to wikidata for additional\n        metadata that can be used in the logic of answer subsitution functions.\n\n        Args:\n            wikidata_info_path: Path to the wikidata entity info saved from Step 1.\n            ner_model_path: Path to our SpaCy NER model, downloaded during setup.\n            debug: If true, only sample 500 examples to quickly check everything runs end-t-end.\n        \"\"\"", "\n", "timer", "=", "BasicTimer", "(", "f\"{self.name} Preprocessing\"", ")", "\n", "examples", "=", "self", ".", "read_original_dataset", "(", "self", ".", "original_path", ")", "\n", "if", "debug", ":", "# Look at just a subset of examples if debugging", "\n", "            ", "examples", "=", "examples", "[", ":", "500", "]", "\n", "", "print", "(", "f\"Processing {len(examples)} Examples...\"", ")", "\n", "\n", "self", ".", "label_entities", "(", "examples", ",", "ner_model_path", ")", "\n", "timer", ".", "interval", "(", "\"Labelling and Linking Named Entities\"", ")", "\n", "self", ".", "wikidata_linking", "(", "examples", ",", "wikidata_info_path", ")", "\n", "timer", ".", "interval", "(", "\"Wikidata and Popularity Linking\"", ")", "\n", "self", ".", "examples", "=", "examples", "\n", "\n", "self", ".", "_report_dataset_stats", "(", ")", "\n", "self", ".", "save", "(", ")", "\n", "timer", ".", "finish", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.label_entities": [[140, 152], ["src.utils.run_ner_linking", "answer.is_equivalent", "answer.update_ner_info"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.src.utils.run_ner_linking", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.is_equivalent", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.update_ner_info"], ["", "def", "label_entities", "(", "self", ",", "examples", ":", "typing", ".", "List", "[", "QAExample", "]", ",", "ner_model_path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Populate each answer with the NER labels and wikidata ID, if found.\"\"\"", "\n", "all_answers", "=", "[", "answer", ".", "text", "for", "ex", "in", "examples", "for", "answer", "in", "ex", ".", "gold_answers", "]", "\n", "answers_to_info", "=", "run_ner_linking", "(", "all_answers", ",", "ner_model_path", ")", "\n", "\n", "for", "ex", "in", "examples", ":", "\n", "            ", "for", "answer", "in", "ex", ".", "gold_answers", ":", "\n", "# for each match found within the answer", "\n", "                ", "for", "ner_info", "in", "answers_to_info", "[", "answer", ".", "text", "]", ":", "\n", "                    ", "if", "answer", ".", "is_equivalent", "(", "ner_info", "[", "\"text\"", "]", ")", ":", "\n", "                        ", "answer", ".", "update_ner_info", "(", "\n", "ner_info", "[", "\"label\"", "]", ",", "ner_info", "[", "\"id\"", "]", "\n", ")", "# update answer", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.wikidata_linking": [[154, 165], ["gzip.open", "json.load", "answer.update_wikidata_info"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.load", "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.update_wikidata_info"], ["", "", "", "", "", "def", "wikidata_linking", "(", "\n", "self", ",", "examples", ":", "typing", ".", "List", "[", "QAExample", "]", ",", "wikidata_info_path", ":", "str", "\n", ")", ":", "\n", "        ", "\"\"\"Using the answer's wikidata IDs (if found), extracts wikidata metadata.\"\"\"", "\n", "with", "gzip", ".", "open", "(", "wikidata_info_path", ",", "\"r\"", ")", "as", "inf", ":", "\n", "            ", "wikidata_info", "=", "json", ".", "load", "(", "inf", ")", "\n", "\n", "", "for", "ex", "in", "examples", ":", "\n", "            ", "for", "answer", "in", "ex", ".", "gold_answers", ":", "\n", "                ", "if", "answer", ".", "kb_id", "in", "wikidata_info", ":", "\n", "                    ", "answer", ".", "update_wikidata_info", "(", "**", "wikidata_info", "[", "answer", ".", "kb_id", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset._report_dataset_stats": [[166, 178], ["collections.defaultdict", "print", "print", "print", "collections.defaultdict.items", "print", "grouped_examples[].append", "print", "len", "len", "ex.get_example_answer_type"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qaexample.QAExample.get_example_answer_type"], ["", "", "", "", "def", "_report_dataset_stats", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reports basic statistics on what is contained in a preprocessed dataset.\"\"\"", "\n", "grouped_examples", "=", "defaultdict", "(", "list", ")", "\n", "for", "ex", "in", "self", ".", "examples", ":", "\n", "            ", "grouped_examples", "[", "ex", ".", "get_example_answer_type", "(", ")", "]", ".", "append", "(", "ex", ")", "\n", "\n", "", "print", "(", "\"Dataset Statistics\"", ")", "\n", "print", "(", "\"-------------------------------------------\"", ")", "\n", "print", "(", "f\"Total Examples = {len(self.examples)}\"", ")", "\n", "for", "group", ",", "ex_list", "in", "grouped_examples", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "f\"Answer Type: {group} | Size of Group: {len(ex_list)}\"", ")", "\n", "", "print", "(", "\"-------------------------------------------\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.MRQANaturalQuetsionsDataset.read_original_dataset": [[186, 211], ["gzip.open", "json.loads", "json.loads", "file_handle.readline", "examples.append", "src.classes.qaexample.QAExample.new"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.qadataset.QADataset.new"], ["def", "read_original_dataset", "(", "self", ",", "file_path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Reads the original/raw dataset into a List of QAExamples.\n        \n        Args:\n            file_path: Local path to the dataset.\n\n        Returns:\n            List[QAExample]\n        \"\"\"", "\n", "examples", "=", "[", "]", "\n", "with", "gzip", ".", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "file_handle", ":", "\n", "            ", "header", "=", "json", ".", "loads", "(", "file_handle", ".", "readline", "(", ")", ")", "[", "\"header\"", "]", "\n", "for", "entry", "in", "file_handle", ":", "\n", "                ", "entry", "=", "json", ".", "loads", "(", "entry", ")", "\n", "for", "qa", "in", "entry", "[", "\"qas\"", "]", ":", "\n", "                    ", "examples", ".", "append", "(", "\n", "QAExample", ".", "new", "(", "\n", "uid", "=", "qa", "[", "\"qid\"", "]", ",", "\n", "query", "=", "qa", "[", "\"question\"", "]", ",", "\n", "context", "=", "entry", "[", "\"context\"", "]", ",", "\n", "answers", "=", "qa", "[", "\"answers\"", "]", ",", "\n", "metadata", "=", "{", "}", ",", "# NB: Put any metadata you wish saved here.", "\n", ")", "\n", ")", "\n", "", "", "", "return", "examples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.__init__": [[7, 53], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "text", ":", "str", ",", "\n", "spans", ":", "typing", ".", "List", "[", "typing", ".", "Tuple", "[", "int", ",", "int", "]", "]", "=", "None", ",", "\n", "ner_label", ":", "str", "=", "None", ",", "\n", "kb_id", ":", "str", "=", "None", ",", "\n", "wikidata_label", ":", "str", "=", "None", ",", "\n", "aliases", ":", "typing", ".", "List", "[", "str", "]", "=", "None", ",", "\n", "wikidata_types", ":", "typing", ".", "List", "[", "str", "]", "=", "None", ",", "\n", "wikipedia_page", ":", "str", "=", "None", ",", "\n", "popularity", ":", "str", "=", "None", ",", "\n", "answer_type", ":", "str", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Fields:\n            text: The raw, unchanged answer text.\n            spans: The start and end character spans of this Answer in the context \n                passage of it's QAExample.\n            ner_label: The Named Entity category label given to this Answer by the NER model.\n                Will often be `None` if no category assigned.\n            kb_id: The knowledge base ID, in this case Wikidata ID found by \n                the NER/Entity Linker model. Will often be `None` if not found.\n            wikidata_label: The official Wikidata name corresponding to the found Wikidata ID.\n            aliases: The official Wikidata aliases for the text associated with this Wikidata ID.\n            wikidata_types: List of Wikidata entity types associated with this Wikidata ID.\n            wikipedia_page: The Wikipedia page associated with this Wikidata ID.\n            popularity: The popularity, measured in daily page views, associated with this \n                Wikidata ID.\n            answer_type: The answer type derived by `_select_answer_type`, using NER and Wikidata\n                metadata. This field is used to ensure some substitutions are \"type-preserving\",\n                i.e. the chosen substitute answer is a coherent replacement in the context.\n        \"\"\"", "\n", "self", ".", "text", "=", "text", "\n", "self", ".", "spans", "=", "spans", "\n", "self", ".", "ner_label", "=", "ner_label", "\n", "self", ".", "kb_id", "=", "kb_id", "\n", "\n", "# Fields supplied by Wikidata Entity Info (from Stage 2) if self.kb_id identified.", "\n", "self", ".", "wikidata_label", "=", "wikidata_label", "\n", "self", ".", "aliases", "=", "aliases", "\n", "self", ".", "wikidata_types", "=", "wikidata_types", "\n", "self", ".", "wikipedia_page", "=", "wikipedia_page", "\n", "self", ".", "popularity", "=", "popularity", "\n", "\n", "# Derived from `ner_label` and `wikidata_types`", "\n", "self", ".", "answer_type", "=", "answer_type", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.update_ner_info": [[54, 58], ["None"], "methods", ["None"], ["", "def", "update_ner_info", "(", "self", ",", "ner_label", ":", "str", ",", "kb_id", ":", "str", ")", ":", "\n", "        ", "\"\"\"Updates the Answer fields with info found by the NER+EL model.\"\"\"", "\n", "self", ".", "ner_label", "=", "ner_label", "\n", "self", ".", "kb_id", "=", "kb_id", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.update_wikidata_info": [[59, 75], ["answer.Answer._select_answer_type", "etype.lower"], "methods", ["home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer._select_answer_type"], ["", "def", "update_wikidata_info", "(", "\n", "self", ",", "\n", "label", ":", "str", "=", "None", ",", "\n", "aliases", ":", "typing", ".", "List", "[", "str", "]", "=", "None", ",", "\n", "entity_types", ":", "typing", ".", "List", "[", "str", "]", "=", "None", ",", "\n", "wikipedia_page", ":", "str", "=", "None", ",", "\n", "popularity", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Updates the Answer fields with Wikidata entity info, if there is a Wikidata ID.\"\"\"", "\n", "self", ".", "wikidata_label", "=", "label", "\n", "self", ".", "aliases", "=", "aliases", "\n", "self", ".", "wikidata_types", "=", "[", "etype", ".", "lower", "(", ")", "for", "etype", "in", "entity_types", "]", "\n", "self", ".", "wikipedia_page", "=", "wikipedia_page", "\n", "self", ".", "popularity", "=", "popularity", "\n", "\n", "self", ".", "answer_type", "=", "self", ".", "_select_answer_type", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.is_equivalent": [[76, 83], ["t.lower", "answer.Answer.text.lower"], "methods", ["None"], ["", "def", "is_equivalent", "(", "self", ",", "t", ":", "str", ")", ":", "\n", "        ", "\"\"\"Checks if this Answer is textually equivalent to some other string.\"\"\"", "\n", "if", "t", "==", "self", ".", "text", ":", "\n", "            ", "return", "True", "\n", "", "if", "t", ".", "lower", "(", ")", "==", "self", ".", "text", ".", "lower", "(", ")", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.is_answer_in_context": [[84, 89], ["None"], "methods", ["None"], ["", "def", "is_answer_in_context", "(", "self", ")", ":", "\n", "        ", "\"\"\"Checks if this Answer appears in the context.\"\"\"", "\n", "if", "self", ".", "spans", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer._select_answer_type": [[90, 111], ["None"], "methods", ["None"], ["", "def", "_select_answer_type", "(", "self", ")", ":", "\n", "        ", "\"\"\"Assigns this Answer a category/type. This type is used by substitution functions to \n        ensure the resulting substitution is coherent, or type-preserving.\n\n        NB: This function can be edited by the user if they have their own NER model, or another\n            set of answer types / substitutions they wish to analyze.\n        \"\"\"", "\n", "answer_type", "=", "None", "\n", "if", "self", ".", "ner_label", "==", "\"PERSON\"", ":", "\n", "            ", "answer_type", "=", "\"PERSON\"", "\n", "", "elif", "self", ".", "ner_label", "==", "\"DATE\"", "or", "(", "\n", "self", ".", "ner_label", "==", "\"CARDINAL\"", "and", "\"year\"", "in", "self", ".", "wikidata_types", "\n", ")", ":", "\n", "            ", "answer_type", "=", "\"DATE\"", "\n", "", "elif", "self", ".", "ner_label", "in", "[", "\"CARDINAL\"", ",", "\"QUANTITY\"", "]", ":", "\n", "            ", "answer_type", "=", "\"NUMERIC\"", "\n", "", "elif", "self", ".", "ner_label", "in", "[", "\"GPE\"", ",", "\"LOC\"", "]", ":", "\n", "            ", "answer_type", "=", "\"LOCATION\"", "\n", "", "elif", "self", ".", "ner_label", "==", "\"ORG\"", ":", "\n", "            ", "answer_type", "=", "\"ORGANIZATION\"", "\n", "", "return", "answer_type", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_dump": [[112, 114], ["None"], "methods", ["None"], ["", "def", "json_dump", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__dict__", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.json_load": [[115, 119], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "json_load", "(", "cls", ",", "obj", ":", "typing", ".", "Dict", "[", "str", ",", "typing", ".", "Any", "]", ")", ":", "\n", "        ", "\"\"\"Loads this object from a Json Dict.\"\"\"", "\n", "return", "cls", "(", "**", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.apple_ml-knowledge-conflicts.classes.answer.Answer.__repr__": [[120, 122], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'Text: \"{self.text}\" | Spans: {self.spans} | Label: {self.ner_label} | WikidataID: {self.kb_id}'", "\n", "", "", ""]]}