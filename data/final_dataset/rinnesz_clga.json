{"home.repos.pwc.inspect_result.rinnesz_clga.None.train_GCA.train": [[20, 51], ["model.train", "optimizer.zero_grad", "train_GCA.train.drop_edge"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge"], ["def", "train", "(", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "def", "drop_edge", "(", "idx", ":", "int", ")", ":", "\n", "        ", "global", "drop_weights", "\n", "\n", "if", "param", "[", "'drop_scheme'", "]", "==", "'uniform'", ":", "\n", "            ", "return", "dropout_adj", "(", "data", ".", "edge_index", ",", "p", "=", "param", "[", "f'drop_edge_rate_{idx}'", "]", ")", "[", "0", "]", "\n", "", "elif", "param", "[", "'drop_scheme'", "]", "in", "[", "'degree'", ",", "'evc'", ",", "'pr'", "]", ":", "\n", "            ", "return", "drop_edge_weighted", "(", "data", ".", "edge_index", ",", "drop_weights", ",", "p", "=", "param", "[", "f'drop_edge_rate_{idx}'", "]", ",", "threshold", "=", "0.7", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "f'undefined drop scheme: {param[\"drop_scheme\"]}'", ")", "\n", "\n", "", "", "edge_index_1", "=", "drop_edge", "(", "1", ")", "\n", "edge_index_2", "=", "drop_edge", "(", "2", ")", "\n", "x_1", "=", "drop_feature", "(", "data", ".", "x", ",", "param", "[", "'drop_feature_rate_1'", "]", ")", "\n", "x_2", "=", "drop_feature", "(", "data", ".", "x", ",", "param", "[", "'drop_feature_rate_2'", "]", ")", "\n", "\n", "if", "param", "[", "'drop_scheme'", "]", "in", "[", "'pr'", ",", "'degree'", ",", "'evc'", "]", ":", "\n", "        ", "x_1", "=", "drop_feature_weighted", "(", "data", ".", "x", ",", "feature_weights", ",", "param", "[", "'drop_feature_rate_1'", "]", ")", "\n", "x_2", "=", "drop_feature_weighted", "(", "data", ".", "x", ",", "feature_weights", ",", "param", "[", "'drop_feature_rate_2'", "]", ")", "\n", "\n", "", "z1", "=", "model", "(", "x_1", ",", "edge_index_1", ")", "\n", "z2", "=", "model", "(", "x_2", ",", "edge_index_2", ")", "\n", "\n", "loss", "=", "model", ".", "loss", "(", "z1", ",", "z2", ",", "batch_size", "=", "None", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.train_GCA.test": [[53, 70], ["model.eval", "model", "pGRACE.eval.MulticlassEvaluator", "nni.report_final_result", "pGRACE.eval.log_regression", "ValueError", "nni.report_intermediate_result", "pGRACE.eval.log_regression"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.log_regression", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.log_regression"], ["", "def", "test", "(", "final", "=", "False", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "z", "=", "model", "(", "data", ".", "x", ",", "data", ".", "edge_index", ")", "\n", "evaluator", "=", "MulticlassEvaluator", "(", ")", "\n", "if", "args", ".", "dataset", "==", "'Cora'", ":", "\n", "        ", "acc", "=", "log_regression", "(", "z", ",", "data", ",", "evaluator", ",", "split", "=", "'cora'", ",", "num_epochs", "=", "3000", ")", "[", "'acc'", "]", "\n", "", "elif", "args", ".", "dataset", "==", "'CiteSeer'", ":", "\n", "        ", "acc", "=", "log_regression", "(", "z", ",", "data", ",", "evaluator", ",", "split", "=", "'citeseer'", ",", "num_epochs", "=", "3000", ")", "[", "'acc'", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Please check the split first!'", ")", "\n", "\n", "", "if", "final", "and", "use_nni", ":", "\n", "        ", "nni", ".", "report_final_result", "(", "acc", ")", "\n", "", "elif", "use_nni", ":", "\n", "        ", "nni", ".", "report_intermediate_result", "(", "acc", ")", "\n", "\n", "", "return", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.baseline_attacks.attack_model": [[19, 49], ["int", "int", "deeprobust.graph.global_attack.Metattack().to", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "deeprobust.graph.global_attack.DICE", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "deeprobust.graph.global_attack.Metattack", "deeprobust.graph.global_attack.Random", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "deeprobust.graph.utils.preprocess", "deeprobust.graph.global_attack.MinMax().to", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "scipy.sparse.csr_matrix", "deeprobust.graph.utils.preprocess", "deeprobust.graph.global_attack.PGDAttack().to", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "deeprobust.graph.global_attack.MinMax", "scipy.sparse.csr_matrix", "deeprobust.graph.global_attack.NodeEmbeddingAttack", "deeprobust.graph.global_attack.NodeEmbeddingAttack.attack", "ValueError", "deeprobust.graph.global_attack.PGDAttack"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.preprocess", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.preprocess", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack"], ["def", "attack_model", "(", "name", ",", "adj", ",", "features", ",", "labels", ",", "device", ")", ":", "\n", "    ", "if", "args", ".", "rate", "<", "1", ":", "\n", "        ", "n_perturbation", "=", "int", "(", "args", ".", "rate", "*", "dataset", ".", "data", ".", "num_edges", "/", "2", ")", "\n", "", "else", ":", "\n", "        ", "n_perturbation", "=", "int", "(", "args", ".", "rate", ")", "\n", "", "if", "name", "==", "'metattack'", ":", "\n", "        ", "model", "=", "Metattack", "(", "surrogate", ",", "nnodes", "=", "adj", ".", "shape", "[", "0", "]", ",", "feature_shape", "=", "features", ".", "shape", ",", "\n", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "device", ",", "lambda_", "=", "0", ")", ".", "to", "(", "device", ")", "\n", "model", ".", "attack", "(", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_unlabeled", ",", "\n", "n_perturbations", "=", "n_perturbation", ",", "ll_constraint", "=", "False", ")", "\n", "", "elif", "name", "==", "'dice'", ":", "\n", "        ", "model", "=", "DICE", "(", ")", "\n", "model", ".", "attack", "(", "adj", ",", "labels", ",", "n_perturbations", "=", "n_perturbation", ")", "\n", "", "elif", "name", "==", "'random'", ":", "\n", "        ", "model", "=", "Random", "(", ")", "\n", "model", ".", "attack", "(", "adj", ",", "n_perturbations", "=", "n_perturbation", ")", "\n", "", "elif", "name", "==", "'minmax'", ":", "\n", "        ", "adj", ",", "features", ",", "labels", "=", "preprocess", "(", "adj", ",", "csr_matrix", "(", "features", ")", ",", "labels", ",", "preprocess_adj", "=", "False", ")", "# conver to tensor", "\n", "model", "=", "MinMax", "(", "surrogate", ",", "nnodes", "=", "adj", ".", "shape", "[", "0", "]", ",", "loss_type", "=", "'CE'", ",", "device", "=", "device", ")", ".", "to", "(", "device", ")", "\n", "model", ".", "attack", "(", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "n_perturbations", "=", "n_perturbation", ")", "\n", "", "elif", "name", "==", "'pgd'", ":", "\n", "        ", "adj", ",", "features", ",", "labels", "=", "preprocess", "(", "adj", ",", "csr_matrix", "(", "features", ")", ",", "labels", ",", "preprocess_adj", "=", "False", ")", "# conver to tensor", "\n", "model", "=", "PGDAttack", "(", "surrogate", ",", "nnodes", "=", "adj", ".", "shape", "[", "0", "]", ",", "loss_type", "=", "'CE'", ",", "device", "=", "device", ")", ".", "to", "(", "device", ")", "\n", "model", ".", "attack", "(", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "n_perturbations", "=", "n_perturbation", ")", "\n", "", "elif", "name", "==", "'nodeembeddingattack'", ":", "\n", "        ", "model", "=", "NodeEmbeddingAttack", "(", ")", "\n", "model", ".", "attack", "(", "adj", ",", "attack_type", "=", "'remove'", ",", "n_perturbations", "=", "n_perturbation", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Invalid name of the attack method!'", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.train_LP.train": [[18, 48], ["model.train", "optimizer.zero_grad", "train_LP.train.drop_edge"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge"], ["def", "train", "(", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "def", "drop_edge", "(", "idx", ":", "int", ")", ":", "\n", "        ", "global", "drop_weights", "\n", "if", "param", "[", "'drop_scheme'", "]", "in", "[", "'uniform'", ",", "'degree'", ",", "'evc'", ",", "'pr'", "]", ":", "\n", "            ", "return", "drop_edge_weighted", "(", "train_edge_index", ",", "drop_weights", ",", "p", "=", "param", "[", "f'drop_edge_rate_{idx}'", "]", ",", "threshold", "=", "0.7", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "f'undefined drop scheme: {param[\"drop_scheme\"]}'", ")", "\n", "\n", "", "", "edge_index_1", "=", "drop_edge", "(", "1", ")", "\n", "edge_index_2", "=", "drop_edge", "(", "2", ")", "\n", "edge_sp_adj_1", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_1", ",", "\n", "torch", ".", "ones", "(", "edge_index_1", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "[", "data", ".", "num_nodes", ",", "data", ".", "num_nodes", "]", ")", ".", "to", "(", "device", ")", "\n", "edge_sp_adj_2", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_2", ",", "\n", "torch", ".", "ones", "(", "edge_index_2", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "[", "data", ".", "num_nodes", ",", "data", ".", "num_nodes", "]", ")", ".", "to", "(", "device", ")", "\n", "edge_adj_1", "=", "edge_sp_adj_1", ".", "to_dense", "(", ")", "\n", "edge_adj_2", "=", "edge_sp_adj_2", ".", "to_dense", "(", ")", "\n", "\n", "x_1", "=", "data", ".", "x", "\n", "x_2", "=", "data", ".", "x", "\n", "\n", "z1", "=", "model", "(", "x_1", ",", "edge_adj_1", ",", "sparse", "=", "False", ")", "\n", "z2", "=", "model", "(", "x_2", ",", "edge_adj_2", ",", "sparse", "=", "False", ")", "\n", "\n", "loss", "=", "model", ".", "loss", "(", "z1", ",", "z2", ",", "batch_size", "=", "1024", "if", "args", ".", "dataset", "==", "'Coauthor-Phy'", "else", "None", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.train_LP.test": [[50, 63], ["model.eval", "model", "pGRACE.eval.LPEvaluator", "pGRACE.eval.link_prediction", "nni.report_final_result", "nni.report_intermediate_result"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.link_prediction"], ["", "def", "test", "(", "final", "=", "False", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "z", "=", "model", "(", "data", ".", "x", ",", "train_edge_index", ")", "\n", "\n", "evaluator", "=", "LPEvaluator", "(", ")", "\n", "auc", "=", "link_prediction", "(", "z", ",", "data", ".", "edge_index", ",", "train_edge_index", ",", "val_edge_index", ",", "test_edge_index", ",", "data", ".", "num_nodes", ",", "evaluator", ",", "\n", "num_epochs", "=", "3000", ")", "[", "'auc'", "]", "\n", "if", "final", "and", "use_nni", ":", "\n", "        ", "nni", ".", "report_final_result", "(", "auc", ")", "\n", "", "elif", "use_nni", ":", "\n", "        ", "nni", ".", "report_intermediate_result", "(", "auc", ")", "\n", "\n", "", "return", "auc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.process_isolated_nodes.process_isolated_nodes": [[4, 14], ["torch_geometric.utils.contains_isolated_nodes", "torch_geometric.utils.remove_isolated_nodes", "range", "edge_index[].item", "new_edge_index[].item"], "function", ["None"], ["def", "process_isolated_nodes", "(", "edge_index", ")", ":", "\n", "    ", "if", "contains_isolated_nodes", "(", "edge_index", ")", ":", "\n", "        ", "new_edge_index", ",", "_", ",", "mask", "=", "remove_isolated_nodes", "(", "edge_index", ")", "\n", "mapping", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "edge_index", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "if", "edge_index", "[", "0", ",", "i", "]", "!=", "new_edge_index", "[", "0", ",", "i", "]", ":", "\n", "                ", "mapping", "[", "new_edge_index", "[", "0", ",", "i", "]", ".", "item", "(", ")", "]", "=", "edge_index", "[", "0", ",", "i", "]", ".", "item", "(", ")", "\n", "", "", "return", "new_edge_index", ",", "mapping", ",", "mask", "\n", "", "else", ":", "\n", "        ", "return", "edge_index", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.process_isolated_nodes.restore_isolated_ndoes": [[16, 23], ["range", "new_edge_index[].item", "new_edge_index[].item", "new_edge_index[].item", "new_edge_index[].item"], "function", ["None"], ["", "", "def", "restore_isolated_ndoes", "(", "new_edge_index", ",", "mapping", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "new_edge_index", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "new_edge_index", "[", "0", ",", "i", "]", ".", "item", "(", ")", "in", "mapping", ":", "\n", "            ", "new_edge_index", "[", "0", ",", "i", "]", "=", "mapping", "[", "new_edge_index", "[", "0", ",", "i", "]", ".", "item", "(", ")", "]", "\n", "", "if", "new_edge_index", "[", "1", ",", "i", "]", ".", "item", "(", ")", "in", "mapping", ":", "\n", "            ", "new_edge_index", "[", "1", ",", "i", "]", "=", "mapping", "[", "new_edge_index", "[", "1", ",", "i", "]", ".", "item", "(", ")", "]", "\n", "", "", "return", "new_edge_index", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.__init__": [[19, 30], ["torch.nn.modules.module.Module.__init__", "dataset.data.to"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "dataset", ",", "param", ",", "device", ")", ":", "\n", "        ", "super", "(", "Metacl", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "None", "\n", "self", ".", "optimizer", "=", "None", "\n", "self", ".", "param", "=", "param", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "data", "=", "dataset", ".", "data", ".", "to", "(", "device", ")", "\n", "self", ".", "drop_weights", "=", "None", "\n", "self", ".", "feature_weights", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge": [[31, 39], ["torch_geometric.utils.dropout_adj", "pGRACE.functional.drop_edge_weighted", "Exception"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_edge_weighted"], ["", "def", "drop_edge", "(", "self", ",", "p", ")", ":", "\n", "        ", "if", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'uniform'", ":", "\n", "            ", "return", "dropout_adj", "(", "self", ".", "data", ".", "edge_index", ",", "p", "=", "p", ")", "[", "0", "]", "\n", "", "elif", "self", ".", "param", "[", "'drop_scheme'", "]", "in", "[", "'degree'", ",", "'evc'", ",", "'pr'", "]", ":", "\n", "            ", "return", "drop_edge_weighted", "(", "self", ".", "data", ".", "edge_index", ",", "self", ".", "drop_weights", ",", "p", "=", "p", ",", "\n", "threshold", "=", "0.7", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "f'undefined drop scheme: {param[\"drop_scheme\"]}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.train_gcn": [[40, 62], ["CLGA.Metacl.model.train", "CLGA.Metacl.optimizer.zero_grad", "CLGA.Metacl.drop_edge", "CLGA.Metacl.drop_edge", "pGRACE.functional.drop_feature", "pGRACE.functional.drop_feature", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "CLGA.Metacl.model", "CLGA.Metacl.model", "CLGA.Metacl.model.loss", "CLGA.Metacl.backward", "CLGA.Metacl.optimizer.step", "CLGA.Metacl.item", "torch.ones().to", "torch.ones().to", "pGRACE.functional.drop_feature_weighted", "pGRACE.functional.drop_feature_weighted", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature_weighted", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature_weighted"], ["", "", "def", "train_gcn", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "edge_index_1", "=", "self", ".", "drop_edge", "(", "self", ".", "param", "[", "'drop_edge_rate_1'", "]", ")", "\n", "edge_index_2", "=", "self", ".", "drop_edge", "(", "self", ".", "param", "[", "'drop_edge_rate_2'", "]", ")", "\n", "x_1", "=", "drop_feature", "(", "self", ".", "data", ".", "x", ",", "self", ".", "param", "[", "'drop_feature_rate_1'", "]", ")", "\n", "x_2", "=", "drop_feature", "(", "self", ".", "data", ".", "x", ",", "self", ".", "param", "[", "'drop_feature_rate_2'", "]", ")", "\n", "edge_sp_adj_1", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_1", ",", "\n", "torch", ".", "ones", "(", "edge_index_1", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "[", "self", ".", "data", ".", "num_nodes", ",", "self", ".", "data", ".", "num_nodes", "]", ")", "\n", "edge_sp_adj_2", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_2", ",", "\n", "torch", ".", "ones", "(", "edge_index_2", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "[", "self", ".", "data", ".", "num_nodes", ",", "self", ".", "data", ".", "num_nodes", "]", ")", "\n", "if", "self", ".", "param", "[", "'drop_scheme'", "]", "in", "[", "'pr'", ",", "'degree'", ",", "'evc'", "]", ":", "\n", "            ", "x_1", "=", "drop_feature_weighted", "(", "self", ".", "data", ".", "x", ",", "self", ".", "feature_weights", ",", "self", ".", "param", "[", "'drop_feature_rate_1'", "]", ")", "\n", "x_2", "=", "drop_feature_weighted", "(", "self", ".", "data", ".", "x", ",", "self", ".", "feature_weights", ",", "self", ".", "param", "[", "'drop_feature_rate_2'", "]", ")", "\n", "", "z1", "=", "self", ".", "model", "(", "x_1", ",", "edge_sp_adj_1", ",", "sparse", "=", "True", ")", "\n", "z2", "=", "self", ".", "model", "(", "x_2", ",", "edge_sp_adj_2", ",", "sparse", "=", "True", ")", "\n", "loss", "=", "self", ".", "model", ".", "loss", "(", "z1", ",", "z2", ",", "batch_size", "=", "None", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.compute_drop_weights": [[63, 94], ["pGRACE.functional.degree_drop_weights().to", "torch_geometric.utils.to_undirected", "torch_geometric.utils.degree", "pGRACE.functional.pr_drop_weights().to", "pGRACE.functional.feature_drop_weights_dense().to", "pGRACE.functional.feature_drop_weights().to", "pGRACE.utils.compute_pr", "pGRACE.functional.degree_drop_weights", "pGRACE.functional.evc_drop_weights().to", "pGRACE.functional.feature_drop_weights_dense().to", "pGRACE.functional.feature_drop_weights().to", "pGRACE.utils.eigenvector_centrality", "torch.ones().to", "pGRACE.functional.pr_drop_weights", "pGRACE.functional.feature_drop_weights_dense", "pGRACE.functional.feature_drop_weights", "pGRACE.functional.feature_drop_weights_dense().to", "pGRACE.functional.feature_drop_weights().to", "pGRACE.functional.evc_drop_weights", "pGRACE.functional.feature_drop_weights_dense", "pGRACE.functional.feature_drop_weights", "torch.ones", "pGRACE.functional.feature_drop_weights_dense", "pGRACE.functional.feature_drop_weights", "CLGA.Metacl.data.x.size"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.compute_pr", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.degree_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.eigenvector_centrality", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.pr_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights_dense", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.evc_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights_dense", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights_dense", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights"], ["", "def", "compute_drop_weights", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'degree'", ":", "\n", "            ", "self", ".", "drop_weights", "=", "degree_drop_weights", "(", "self", ".", "data", ".", "edge_index", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "elif", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'pr'", ":", "\n", "            ", "self", ".", "drop_weights", "=", "pr_drop_weights", "(", "self", ".", "data", ".", "edge_index", ",", "aggr", "=", "'sink'", ",", "k", "=", "200", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "elif", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'evc'", ":", "\n", "            ", "self", ".", "drop_weights", "=", "evc_drop_weights", "(", "self", ".", "data", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop_weights", "=", "None", "\n", "\n", "", "if", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'degree'", ":", "\n", "            ", "edge_index_", "=", "to_undirected", "(", "self", ".", "data", ".", "edge_index", ")", "\n", "node_deg", "=", "degree", "(", "edge_index_", "[", "1", "]", ")", "\n", "if", "self", ".", "args", ".", "dataset", "==", "'WikiCS'", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights_dense", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_deg", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_deg", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "elif", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'pr'", ":", "\n", "            ", "node_pr", "=", "compute_pr", "(", "self", ".", "data", ".", "edge_index", ")", "\n", "if", "self", ".", "args", ".", "dataset", "==", "'WikiCS'", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights_dense", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_pr", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_pr", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "elif", "self", ".", "param", "[", "'drop_scheme'", "]", "==", "'evc'", ":", "\n", "            ", "node_evc", "=", "eigenvector_centrality", "(", "self", ".", "data", ")", "\n", "if", "self", ".", "args", ".", "dataset", "==", "'WikiCS'", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights_dense", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_evc", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "feature_weights", "=", "feature_drop_weights", "(", "self", ".", "data", ".", "x", ",", "node_c", "=", "node_evc", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "feature_weights", "=", "torch", ".", "ones", "(", "(", "self", ".", "data", ".", "x", ".", "size", "(", "1", ")", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.inner_train": [[95, 106], ["differentiable_models.gcn.GCN", "differentiable_models.model.GRACE().to", "torch.optim.Adam", "CLGA.Metacl.compute_drop_weights", "range", "pGRACE.utils.get_activation", "CLGA.Metacl.model.parameters", "CLGA.Metacl.train_gcn", "differentiable_models.model.GRACE"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.compute_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.get_activation", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_gcn"], ["", "", "def", "inner_train", "(", "self", ")", ":", "\n", "        ", "encoder", "=", "GCN", "(", "self", ".", "dataset", ".", "num_features", ",", "self", ".", "param", "[", "'num_hidden'", "]", ",", "get_activation", "(", "self", ".", "param", "[", "'activation'", "]", ")", ")", "\n", "self", ".", "model", "=", "GRACE", "(", "encoder", ",", "self", ".", "param", "[", "'num_hidden'", "]", ",", "self", ".", "param", "[", "'num_proj_hidden'", "]", ",", "self", ".", "param", "[", "'tau'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "param", "[", "'learning_rate'", "]", ",", "\n", "weight_decay", "=", "self", ".", "param", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "compute_drop_weights", "(", ")", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "param", "[", "'num_epochs'", "]", "+", "1", ")", ":", "\n", "            ", "loss", "=", "self", ".", "train_gcn", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.compute_gradient": [[107, 132], ["CLGA.Metacl.model.eval", "CLGA.Metacl.compute_drop_weights", "CLGA.Metacl.drop_edge", "CLGA.Metacl.drop_edge", "pGRACE.functional.drop_feature", "pGRACE.functional.drop_feature", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor.to_dense", "torch.sparse.FloatTensor.to_dense", "CLGA.Metacl.model", "CLGA.Metacl.model", "CLGA.Metacl.model.loss", "CLGA.Metacl.backward", "torch.ones().to", "torch.ones().to", "pGRACE.functional.drop_feature_weighted", "pGRACE.functional.drop_feature_weighted", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.compute_drop_weights", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.drop_edge", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.loss", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature_weighted", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature_weighted"], ["", "", "def", "compute_gradient", "(", "self", ",", "pe1", ",", "pe2", ",", "pf1", ",", "pf2", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "compute_drop_weights", "(", ")", "\n", "edge_index_1", "=", "self", ".", "drop_edge", "(", "pe1", ")", "\n", "edge_index_2", "=", "self", ".", "drop_edge", "(", "pe2", ")", "\n", "x_1", "=", "drop_feature", "(", "self", ".", "data", ".", "x", ",", "pf1", ")", "\n", "x_2", "=", "drop_feature", "(", "self", ".", "data", ".", "x", ",", "pf2", ")", "\n", "edge_sp_adj_1", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_1", ",", "\n", "torch", ".", "ones", "(", "edge_index_1", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "[", "self", ".", "data", ".", "num_nodes", ",", "self", ".", "data", ".", "num_nodes", "]", ")", "\n", "edge_sp_adj_2", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index_2", ",", "\n", "torch", ".", "ones", "(", "edge_index_2", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "[", "self", ".", "data", ".", "num_nodes", ",", "self", ".", "data", ".", "num_nodes", "]", ")", "\n", "if", "self", ".", "param", "[", "'drop_scheme'", "]", "in", "[", "'pr'", ",", "'degree'", ",", "'evc'", "]", ":", "\n", "            ", "x_1", "=", "drop_feature_weighted", "(", "self", ".", "data", ".", "x", ",", "self", ".", "feature_weights", ",", "pf1", ")", "\n", "x_2", "=", "drop_feature_weighted", "(", "self", ".", "data", ".", "x", ",", "self", ".", "feature_weights", ",", "pf2", ")", "\n", "", "edge_adj_1", "=", "edge_sp_adj_1", ".", "to_dense", "(", ")", "\n", "edge_adj_2", "=", "edge_sp_adj_2", ".", "to_dense", "(", ")", "\n", "edge_adj_1", ".", "requires_grad", "=", "True", "\n", "edge_adj_2", ".", "requires_grad", "=", "True", "\n", "z1", "=", "self", ".", "model", "(", "x_1", ",", "edge_adj_1", ",", "sparse", "=", "False", ")", "\n", "z2", "=", "self", ".", "model", "(", "x_2", ",", "edge_adj_2", ",", "sparse", "=", "False", ")", "\n", "loss", "=", "self", ".", "model", ".", "loss", "(", "z1", ",", "z2", ",", "batch_size", "=", "None", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "return", "edge_adj_1", ".", "grad", ",", "edge_adj_2", ".", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.attack": [[133, 188], ["torch.sparse.FloatTensor", "torch.sparse.FloatTensor.to_dense", "print", "print", "torch.sparse.FloatTensor.to_dense.to", "torch.ones().to", "len", "int", "time.time", "CLGA.Metacl.inner_train", "CLGA.Metacl.compute_gradient", "grad_sum.view", "torch.abs", "torch.abs.sort", "time.time", "print", "torch.sparse.FloatTensor.to_dense.to", "pickle.dump", "print", "torch.sparse.FloatTensor.to_dense.to", "pickle.dump", "print", "int", "int", "torch_geometric.utils.dense_to_sparse", "torch.ones", "len", "int", "len", "len", "adj_sp.to_dense.to.to", "open", "len", "int", "len", "len", "adj_sp.to_dense.to.to", "open", "perturbed_edges.append", "perturbed_edges.append", "len", "int", "int", "torch.device", "int", "int", "torch.device", "perturbed_edges.append", "perturbed_edges.append", "len", "int"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.inner_train", "home.repos.pwc.inspect_result.rinnesz_clga.None.CLGA.Metacl.compute_gradient", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "attack", "(", "self", ")", ":", "\n", "        ", "perturbed_edges", "=", "[", "]", "\n", "num_total_edges", "=", "self", ".", "data", ".", "num_edges", "\n", "adj_sp", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "self", ".", "data", ".", "edge_index", ",", "torch", ".", "ones", "(", "self", ".", "data", ".", "edge_index", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "[", "self", ".", "data", ".", "num_nodes", ",", "self", ".", "data", ".", "num_nodes", "]", ")", "\n", "adj", "=", "adj_sp", ".", "to_dense", "(", ")", "\n", "\n", "print", "(", "'Begin perturbing.....'", ")", "\n", "# save three poisoned adj when the perturbation rate reaches 1%, 5%, 10%", "\n", "while", "len", "(", "perturbed_edges", ")", "<", "int", "(", "0.10", "*", "num_total_edges", ")", ":", "\n", "            ", "if", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.01", "*", "num_total_edges", ")", "or", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.01", "*", "num_total_edges", ")", "-", "1", "or", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.01", "*", "num_total_edges", ")", "-", "2", ":", "\n", "                ", "output_adj", "=", "adj", ".", "to", "(", "device", ")", "\n", "pkl", ".", "dump", "(", "output_adj", ".", "to", "(", "torch", ".", "device", "(", "'cpu'", ")", ")", ",", "open", "(", "'poisoned_adj/%s_CLGA_0.010000_adj.pkl'", "%", "args", ".", "dataset", ",", "'wb'", ")", ")", "\n", "print", "(", "'---1% poisoned adjacency matrix saved---'", ")", "\n", "", "if", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.05", "*", "num_total_edges", ")", "or", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.05", "*", "num_total_edges", ")", "-", "1", "or", "len", "(", "perturbed_edges", ")", "==", "int", "(", "0.05", "*", "num_total_edges", ")", "-", "2", ":", "\n", "                ", "output_adj", "=", "adj", ".", "to", "(", "device", ")", "\n", "pkl", ".", "dump", "(", "output_adj", ".", "to", "(", "torch", ".", "device", "(", "'cpu'", ")", ")", ",", "open", "(", "'poisoned_adj/%s_CLGA_0.050000_adj.pkl'", "%", "args", ".", "dataset", ",", "'wb'", ")", ")", "\n", "print", "(", "'---5% perturbed adjacency matrix saved---'", ")", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "inner_train", "(", ")", "\n", "adj_1_grad", ",", "adj_2_grad", "=", "self", ".", "compute_gradient", "(", "self", ".", "param", "[", "'drop_edge_rate_1'", "]", ",", "self", ".", "param", "[", "'drop_edge_rate_2'", "]", ",", "self", ".", "param", "[", "'drop_feature_rate_1'", "]", ",", "self", ".", "param", "[", "'drop_feature_rate_2'", "]", ")", "\n", "grad_sum", "=", "adj_1_grad", "+", "adj_2_grad", "\n", "grad_sum_1d", "=", "grad_sum", ".", "view", "(", "-", "1", ")", "\n", "grad_sum_1d_abs", "=", "torch", ".", "abs", "(", "grad_sum_1d", ")", "\n", "values", ",", "indices", "=", "grad_sum_1d_abs", ".", "sort", "(", "descending", "=", "True", ")", "\n", "i", "=", "-", "1", "\n", "while", "True", ":", "\n", "                ", "i", "+=", "1", "\n", "index", "=", "int", "(", "indices", "[", "i", "]", ")", "\n", "row", "=", "int", "(", "index", "/", "self", ".", "data", ".", "num_nodes", ")", "\n", "column", "=", "index", "%", "self", ".", "data", ".", "num_nodes", "\n", "if", "[", "row", ",", "column", "]", "in", "perturbed_edges", ":", "\n", "                    ", "continue", "\n", "", "if", "grad_sum_1d", "[", "index", "]", "<", "0", "and", "adj", "[", "row", ",", "column", "]", "==", "1", ":", "\n", "                    ", "adj", "[", "row", ",", "column", "]", "=", "0", "\n", "adj", "[", "column", ",", "row", "]", "=", "0", "\n", "perturbed_edges", ".", "append", "(", "[", "row", ",", "column", "]", ")", "\n", "perturbed_edges", ".", "append", "(", "[", "column", ",", "row", "]", ")", "\n", "break", "\n", "", "elif", "grad_sum_1d", "[", "index", "]", ">", "0", "and", "adj", "[", "row", ",", "column", "]", "==", "0", ":", "\n", "                    ", "adj", "[", "row", ",", "column", "]", "=", "1", "\n", "adj", "[", "column", ",", "row", "]", "=", "1", "\n", "perturbed_edges", ".", "append", "(", "[", "row", ",", "column", "]", ")", "\n", "perturbed_edges", ".", "append", "(", "[", "column", ",", "row", "]", ")", "\n", "break", "\n", "", "", "self", ".", "data", ".", "edge_index", "=", "dense_to_sparse", "(", "adj", ")", "[", "0", "]", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'Perturbing edges: %d/%d. Finished in %.2fs'", "%", "(", "len", "(", "perturbed_edges", ")", "/", "2", ",", "int", "(", "0.10", "*", "num_total_edges", ")", "/", "2", ",", "end", "-", "start", ")", ")", "\n", "", "print", "(", "'Number of perturbed edges: %d'", "%", "(", "len", "(", "perturbed_edges", ")", "/", "2", ")", ")", "\n", "output_adj", "=", "adj", ".", "to", "(", "device", ")", "\n", "return", "output_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.SimpleParam.__init__": [[11, 17], ["dict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "local_dir", ":", "str", "=", "'param'", ",", "default", ":", "Optional", "[", "dict", "]", "=", "None", ")", ":", "\n", "        ", "if", "default", "is", "None", ":", "\n", "            ", "default", "=", "dict", "(", ")", "\n", "\n", "", "self", ".", "local_dir", "=", "local_dir", "\n", "self", ".", "default", "=", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.SimpleParam.__call__": [[18, 41], ["source.startswith", "Exception", "source.split", "os.join", "os.join.endswith", "nni.get_next_parameter", "len", "sp.parse_json", "sp.preprocess_nni", "os.join.endswith", "os.join.endswith", "sp.parse_yaml", "Exception"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.parse_json", "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.preprocess_nni", "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.parse_yaml"], ["", "def", "__call__", "(", "self", ",", "source", ":", "str", ",", "preprocess", ":", "str", "=", "'none'", ")", ":", "\n", "        ", "if", "source", "==", "'nni'", ":", "\n", "            ", "return", "{", "**", "self", ".", "default", ",", "**", "nni", ".", "get_next_parameter", "(", ")", "}", "\n", "", "if", "source", ".", "startswith", "(", "'local'", ")", ":", "\n", "            ", "ts", "=", "source", ".", "split", "(", "':'", ")", "\n", "assert", "len", "(", "ts", ")", "==", "2", ",", "'local parameter file should be specified in a form of `local:FILE_NAME`'", "\n", "path", "=", "ts", "[", "-", "1", "]", "\n", "path", "=", "osp", ".", "join", "(", "self", ".", "local_dir", ",", "path", ")", "\n", "if", "path", ".", "endswith", "(", "'.json'", ")", ":", "\n", "                ", "loaded", "=", "parse_json", "(", "path", ")", "\n", "", "elif", "path", ".", "endswith", "(", "'.yaml'", ")", "or", "path", ".", "endswith", "(", "'.yml'", ")", ":", "\n", "                ", "loaded", "=", "parse_yaml", "(", "path", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "'Invalid file name. Should end with .yaml or .json.'", ")", "\n", "\n", "", "if", "preprocess", "==", "'nni'", ":", "\n", "                ", "loaded", "=", "preprocess_nni", "(", "loaded", ")", "\n", "\n", "", "return", "{", "**", "self", ".", "default", ",", "**", "loaded", "}", "\n", "", "if", "source", "==", "'default'", ":", "\n", "            ", "return", "self", ".", "default", "\n", "\n", "", "raise", "Exception", "(", "'invalid source'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.preprocess_nni": [[43, 55], ["key.split", "sp.preprocess_nni.process_key"], "function", ["None"], ["", "", "def", "preprocess_nni", "(", "params", ":", "dict", ")", ":", "\n", "    ", "def", "process_key", "(", "key", ":", "str", ")", ":", "\n", "        ", "xs", "=", "key", ".", "split", "(", "'/'", ")", "\n", "if", "len", "(", "xs", ")", "==", "3", ":", "\n", "            ", "return", "xs", "[", "1", "]", "\n", "", "elif", "len", "(", "xs", ")", "==", "1", ":", "\n", "            ", "return", "key", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Unexpected param name '", "+", "key", ")", "\n", "\n", "", "", "return", "{", "\n", "process_key", "(", "k", ")", ":", "v", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.parse_yaml": [[58, 61], ["open().read", "yaml.load", "open"], "function", ["None"], ["", "def", "parse_yaml", "(", "path", ":", "str", ")", ":", "\n", "    ", "content", "=", "open", "(", "path", ")", ".", "read", "(", ")", "\n", "return", "yaml", ".", "load", "(", "content", ",", "Loader", "=", "yaml", ".", "Loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.simple_param.sp.parse_json": [[63, 66], ["open().read", "json.loads", "open"], "function", ["None"], ["", "def", "parse_json", "(", "path", ":", "str", ")", ":", "\n", "    ", "content", "=", "open", "(", "path", ")", ".", "read", "(", ")", "\n", "return", "json", ".", "loads", "(", "content", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.black_box.load_victim_model": [[9, 45], ["os.exists", "black_box.train_victim_model", "os.join", "deeprobust.graph.defense.GCN", "deeprobust.graph.defense.GCN.load_state_dict", "deeprobust.graph.defense.GCN.to", "deeprobust.graph.defense.GCN.eval", "torch.load", "os.dirname", "data.labels.max().item", "data.labels.max"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.black_box.train_victim_model", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval"], ["def", "load_victim_model", "(", "data", ",", "model_name", "=", "'gcn'", ",", "device", "=", "'cpu'", ",", "file_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"load_victim_model.\n\n    Parameters\n    ----------\n    data : deeprobust.graph.Dataset\n        graph data\n    model_name : str\n        victime model name, e.g. ('gcn', 'deepwalk') But currently it only\n        supports gcn as victim model.\n    device : str\n        'cpu' or 'cuda'\n    file_path :\n        if given, the victim model will be loaded from this path.\n    \"\"\"", "\n", "\n", "assert", "model_name", "==", "'gcn'", ",", "'Currently only support gcn as victim model...'", "\n", "if", "file_path", "is", "None", ":", "\n", "# file_path = f'results/saved_models/{data.name}/{model_name}_checkpoint'", "\n", "        ", "file_path", "=", "'results/saved_models/{0}/{1}_checkpoint'", ".", "format", "(", "data", ".", "name", ",", "model_name", ")", "\n", "", "else", ":", "\n", "        ", "file_path", "=", "osp", ".", "join", "(", "file_path", ",", "'{}_checkpoint'", ".", "format", "(", "model_name", ")", ")", "\n", "\n", "# Setup victim model", "\n", "", "if", "osp", ".", "exists", "(", "file_path", ")", ":", "\n", "        ", "victim_model", "=", "GCN", "(", "nfeat", "=", "data", ".", "features", ".", "shape", "[", "1", "]", ",", "nclass", "=", "data", ".", "labels", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", ",", "\n", "nhid", "=", "16", ",", "dropout", "=", "0.5", ",", "weight_decay", "=", "5e-4", ",", "device", "=", "device", ")", "\n", "\n", "victim_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "file_path", ",", "map_location", "=", "device", ")", ")", "\n", "victim_model", ".", "to", "(", "device", ")", "\n", "victim_model", ".", "eval", "(", ")", "\n", "return", "victim_model", "\n", "\n", "", "victim_model", "=", "train_victim_model", "(", "data", "=", "data", ",", "model_name", "=", "model_name", ",", "\n", "device", "=", "device", ",", "file_path", "=", "osp", ".", "dirname", "(", "file_path", ")", ")", "\n", "return", "victim_model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.black_box.train_victim_model": [[46, 75], ["deeprobust.graph.utils.preprocess", "deeprobust.graph.defense.GCN", "adj.to.to", "features.to.to", "labels.to.to", "victim_model.to.to", "victim_model.to.fit", "torch.save", "victim_model.to.eval", "os.exists", "os.system", "os.system", "victim_model.to.state_dict", "os.join", "labels.to.max().item", "labels.to.max"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.preprocess", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval"], ["", "def", "train_victim_model", "(", "data", ",", "model_name", "=", "'gcn'", ",", "file_path", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"Train the victim model (target classifer) and save the model\n    Note that the attacker can only do black query to this model.\n    \"\"\"", "\n", "\n", "if", "file_path", "is", "None", ":", "\n", "        ", "file_path", "=", "'results/saved_models/%s/'", "%", "data", ".", "name", "\n", "\n", "", "adj", ",", "features", ",", "labels", "=", "data", ".", "adj", ",", "data", ".", "features", ",", "data", ".", "labels", "\n", "idx_train", ",", "idx_val", ",", "idx_test", "=", "data", ".", "idx_train", ",", "data", ".", "idx_val", ",", "data", ".", "idx_test", "\n", "nfeat", "=", "features", ".", "shape", "[", "1", "]", "\n", "adj", ",", "features", ",", "labels", "=", "preprocess", "(", "adj", ",", "features", ",", "labels", ",", "preprocess_adj", "=", "False", ")", "\n", "\n", "# Setup victim model", "\n", "victim_model", "=", "GCN", "(", "nfeat", "=", "features", ".", "shape", "[", "1", "]", ",", "nclass", "=", "labels", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", ",", "\n", "nhid", "=", "16", ",", "dropout", "=", "0.5", ",", "weight_decay", "=", "5e-4", ",", "device", "=", "device", ")", "\n", "\n", "adj", "=", "adj", ".", "to", "(", "device", ")", "\n", "features", "=", "features", ".", "to", "(", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "device", ")", "\n", "victim_model", "=", "victim_model", ".", "to", "(", "device", ")", "\n", "victim_model", ".", "fit", "(", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", ")", "\n", "\n", "# save the model", "\n", "if", "not", "osp", ".", "exists", "(", "file_path", ")", ":", "\n", "        ", "os", ".", "system", "(", "'mkdir -p %s'", "%", "file_path", ")", "\n", "", "torch", ".", "save", "(", "victim_model", ".", "state_dict", "(", ")", ",", "osp", ".", "join", "(", "file_path", ",", "model_name", "+", "'_checkpoint'", ")", ")", "\n", "victim_model", ".", "eval", "(", ")", "\n", "return", "victim_model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.visualization.degree_dist": [[8, 41], ["clean_adj.sum", "perturbed_adj.sum", "matplotlib.subplots", "seaborn.distplot", "seaborn.distplot", "ax1.grid", "matplotlib.legend", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.savefig", "matplotlib.show", "os.path.exists", "os.mkdir"], "function", ["None"], ["def", "degree_dist", "(", "clean_adj", ",", "perturbed_adj", ",", "savename", "=", "'degree_dist.pdf'", ")", ":", "\n", "    ", "\"\"\"Plot degree distributnio on clean and perturbed graphs.\n\n    Parameters\n    ----------\n    clean_adj: sp.csr_matrix\n        adjancecy matrix of the clean graph\n    perturbed_adj: sp.csr_matrix\n        adjancecy matrix of the perturbed graph\n    savename: str\n        filename to be saved\n\n    Returns\n    -------\n    None\n\n    \"\"\"", "\n", "clean_degree", "=", "clean_adj", ".", "sum", "(", "1", ")", "\n", "perturbed_degree", "=", "perturbed_adj", ".", "sum", "(", "1", ")", "\n", "fig", ",", "ax1", "=", "plt", ".", "subplots", "(", ")", "\n", "sns", ".", "distplot", "(", "clean_degree", ",", "label", "=", "'Clean Graph'", ",", "norm_hist", "=", "False", ",", "ax", "=", "ax1", ")", "\n", "sns", ".", "distplot", "(", "perturbed_degree", ",", "label", "=", "'Perturbed Graph'", ",", "norm_hist", "=", "False", ",", "ax", "=", "ax1", ")", "\n", "ax1", ".", "grid", "(", "False", ")", "\n", "plt", ".", "legend", "(", "prop", "=", "{", "'size'", ":", "18", "}", ")", "\n", "plt", ".", "ylabel", "(", "'Density Distribution'", ",", "fontsize", "=", "18", ")", "\n", "plt", ".", "xlabel", "(", "'Node degree'", ",", "fontsize", "=", "18", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "14", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "14", ")", "\n", "# plt.title(f'Feature difference of adjacency after {attack}-attack')", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'figures/'", ")", ":", "\n", "       ", "os", ".", "mkdir", "(", "'figures'", ")", "\n", "", "plt", ".", "savefig", "(", "'figures/%s'", "%", "savename", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.visualization.feature_diff": [[42, 76], ["matplotlib.subplots", "seaborn.distplot", "seaborn.distplot", "ax1.grid", "matplotlib.legend", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.savefig", "matplotlib.show", "visualization._get_diff", "visualization._get_diff", "os.path.exists", "os.mkdir"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.visualization._get_diff", "home.repos.pwc.inspect_result.rinnesz_clga.graph.visualization._get_diff"], ["", "def", "feature_diff", "(", "clean_adj", ",", "perturbed_adj", ",", "features", ",", "savename", "=", "'feature_diff.pdf'", ")", ":", "\n", "    ", "\"\"\"Plot feature difference on clean and perturbed graphs.\n\n    Parameters\n    ----------\n    clean_adj: sp.csr_matrix\n        adjancecy matrix of the clean graph\n    perturbed_adj: sp.csr_matrix\n        adjancecy matrix of the perturbed graph\n    features: sp.csr_matrix or np.array\n        node features\n    savename: str\n        filename to be saved\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "\n", "fig", ",", "ax1", "=", "plt", ".", "subplots", "(", ")", "\n", "sns", ".", "distplot", "(", "_get_diff", "(", "clean_adj", ",", "features", ")", ",", "label", "=", "'Normal Edges'", ",", "norm_hist", "=", "True", ",", "ax", "=", "ax1", ")", "\n", "delta_adj", "=", "perturbed_adj", "-", "clean_adj", "\n", "delta_adj", "[", "delta_adj", "<", "0", "]", "=", "0", "\n", "sns", ".", "distplot", "(", "_get_diff", "(", "delta_adj", ",", "features", ")", ",", "label", "=", "'Adversarial Edges'", ",", "norm_hist", "=", "True", ",", "ax", "=", "ax1", ")", "\n", "ax1", ".", "grid", "(", "False", ")", "\n", "plt", ".", "legend", "(", "prop", "=", "{", "'size'", ":", "18", "}", ")", "\n", "plt", ".", "ylabel", "(", "'Density Distribution'", ",", "fontsize", "=", "18", ")", "\n", "plt", ".", "xlabel", "(", "'Feature Difference Between Connected Nodes'", ",", "fontsize", "=", "18", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "14", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "14", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'figures/'", ")", ":", "\n", "       ", "os", ".", "mkdir", "(", "'figures'", ")", "\n", "", "plt", ".", "savefig", "(", "'figures/%s'", "%", "savename", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.visualization._get_diff": [[78, 91], ["scipy.issparse", "tqdm.tqdm", "numpy.array", "adj.sum().tolist", "numpy.sum", "diff.append", "adj.nonzero", "adj.sum", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "_get_diff", "(", "adj", ",", "features", ")", ":", "\n", "    ", "isSparse", "=", "sp", ".", "issparse", "(", "features", ")", "\n", "edges", "=", "np", ".", "array", "(", "adj", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "row_degree", "=", "adj", ".", "sum", "(", "0", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "diff", "=", "[", "]", "\n", "for", "edge", "in", "tqdm", "(", "edges", ")", ":", "\n", "        ", "n1", "=", "edge", "[", "0", "]", "\n", "n2", "=", "edge", "[", "1", "]", "\n", "if", "n1", ">", "n2", ":", "\n", "            ", "continue", "\n", "", "d", "=", "np", ".", "sum", "(", "(", "features", "[", "n1", "]", "/", "np", ".", "sqrt", "(", "row_degree", "[", "n1", "]", ")", "-", "features", "[", "n2", "]", "/", "np", ".", "sqrt", "(", "row_degree", "[", "n2", "]", ")", ")", ".", "power", "(", "2", ")", ")", "\n", "diff", ".", "append", "(", "d", ")", "\n", "", "return", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.encode_onehot": [[9, 25], ["numpy.eye", "labels.max"], "function", ["None"], ["def", "encode_onehot", "(", "labels", ")", ":", "\n", "    ", "\"\"\"Convert label to onehot format.\n\n    Parameters\n    ----------\n    labels : numpy.array\n        node labels\n\n    Returns\n    -------\n    numpy.array\n        onehot labels\n    \"\"\"", "\n", "eye", "=", "np", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.tensor2onehot": [[26, 44], ["torch.eye", "torch.eye", "torch.eye", "onehot_mx.to", "labels.max"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "tensor2onehot", "(", "labels", ")", ":", "\n", "    ", "\"\"\"Convert label tensor to label onehot tensor.\n\n    Parameters\n    ----------\n    labels : torch.LongTensor\n        node labels\n\n    Returns\n    -------\n    torch.LongTensor\n        onehot labels tensor\n\n    \"\"\"", "\n", "\n", "eye", "=", "torch", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", ".", "to", "(", "labels", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.preprocess": [[45, 81], ["torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "utils.normalize_adj", "utils.normalize_feature", "utils.sparse_mx_to_torch_sparse_tensor", "utils.sparse_mx_to_torch_sparse_tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor.to", "torch.FloatTensor.to", "torch.LongTensor.to", "numpy.array", "torch.FloatTensor.todense", "torch.FloatTensor.todense"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_feature", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "preprocess", "(", "adj", ",", "features", ",", "labels", ",", "preprocess_adj", "=", "False", ",", "preprocess_feature", "=", "False", ",", "sparse", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"Convert adj, features, labels from array or sparse matrix to\n    torch Tensor, and normalize the input data.\n\n    Parameters\n    ----------\n    adj : scipy.sparse.csr_matrix\n        the adjacency matrix.\n    features : scipy.sparse.csr_matrix\n        node features\n    labels : numpy.array\n        node labels\n    preprocess_adj : bool\n        whether to normalize the adjacency matrix\n    preprocess_feature : bool\n        whether to normalize the feature matrix\n    sparse : bool\n       whether to return sparse tensor\n    device : str\n        'cpu' or 'cuda'\n    \"\"\"", "\n", "\n", "if", "preprocess_adj", ":", "\n", "        ", "adj", "=", "normalize_adj", "(", "adj", ")", "\n", "\n", "", "if", "preprocess_feature", ":", "\n", "        ", "features", "=", "normalize_feature", "(", "features", ")", "\n", "\n", "", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "if", "sparse", ":", "\n", "        ", "adj", "=", "sparse_mx_to_torch_sparse_tensor", "(", "adj", ")", "\n", "features", "=", "sparse_mx_to_torch_sparse_tensor", "(", "features", ")", "\n", "", "else", ":", "\n", "        ", "features", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "features", ".", "todense", "(", ")", ")", ")", "\n", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ".", "todense", "(", ")", ")", "\n", "", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor": [[82, 111], ["scipy.issparse", "scipy.issparse", "utils.sparse_mx_to_torch_sparse_tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "utils.sparse_mx_to_torch_sparse_tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "numpy.array", "torch.FloatTensor.to", "torch.FloatTensor.to", "torch.FloatTensor.to", "torch.FloatTensor.to", "torch.LongTensor.to"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "to_tensor", "(", "adj", ",", "features", ",", "labels", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"Convert adj, features, labels from array or sparse matrix to\n    torch Tensor.\n\n    Parameters\n    ----------\n    adj : scipy.sparse.csr_matrix\n        the adjacency matrix.\n    features : scipy.sparse.csr_matrix\n        node features\n    labels : numpy.array\n        node labels\n    device : str\n        'cpu' or 'cuda'\n    \"\"\"", "\n", "if", "sp", ".", "issparse", "(", "adj", ")", ":", "\n", "        ", "adj", "=", "sparse_mx_to_torch_sparse_tensor", "(", "adj", ")", "\n", "", "else", ":", "\n", "        ", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ")", "\n", "", "if", "sp", ".", "issparse", "(", "features", ")", ":", "\n", "        ", "features", "=", "sparse_mx_to_torch_sparse_tensor", "(", "features", ")", "\n", "", "else", ":", "\n", "        ", "features", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "features", ")", ")", "\n", "\n", "", "if", "labels", "is", "None", ":", "\n", "        ", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_feature": [[112, 133], ["numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot", "type", "mx.tolil.tolil", "mx.tolil.sum", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "", "def", "normalize_feature", "(", "mx", ")", ":", "\n", "    ", "\"\"\"Row-normalize sparse matrix\n\n    Parameters\n    ----------\n    mx : scipy.sparse.csr_matrix\n        matrix to be normalized\n\n    Returns\n    -------\n    scipy.sprase.lil_matrix\n        normalized matrix\n    \"\"\"", "\n", "if", "type", "(", "mx", ")", "is", "not", "sp", ".", "lil", ".", "lil_matrix", ":", "\n", "        ", "mx", "=", "mx", ".", "tolil", "(", ")", "\n", "", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj": [[134, 162], ["numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot", "mx.tolil.dot", "type", "mx.tolil.tolil", "mx.tolil.sum", "scipy.eye", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "def", "normalize_adj", "(", "mx", ")", ":", "\n", "    ", "\"\"\"Normalize sparse adjacency matrix,\n    A' = (D + I)^-1/2 * ( A + I ) * (D + I)^-1/2\n    Row-normalize sparse matrix\n\n    Parameters\n    ----------\n    mx : scipy.sparse.csr_matrix\n        matrix to be normalized\n\n    Returns\n    -------\n    scipy.sprase.lil_matrix\n        normalized matrix\n    \"\"\"", "\n", "\n", "# TODO: maybe using coo format would be better?", "\n", "if", "type", "(", "mx", ")", "is", "not", "sp", ".", "lil", ".", "lil_matrix", ":", "\n", "        ", "mx", "=", "mx", ".", "tolil", "(", ")", "\n", "", "if", "mx", "[", "0", ",", "0", "]", "==", "0", ":", "\n", "        ", "mx", "=", "mx", "+", "sp", ".", "eye", "(", "mx", ".", "shape", "[", "0", "]", ")", "\n", "", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", "/", "2", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "mx", "=", "mx", ".", "dot", "(", "r_mat_inv", ")", "\n", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_sparse_tensor": [[163, 182], ["adj._indices", "adj._values", "adj.size", "utils..", "scatter_add", "scatter_add.pow", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "float"], "function", ["None"], ["", "def", "normalize_sparse_tensor", "(", "adj", ",", "fill_value", "=", "1", ")", ":", "\n", "    ", "\"\"\"Normalize sparse tensor. Need to import torch_scatter\n    \"\"\"", "\n", "edge_index", "=", "adj", ".", "_indices", "(", ")", "\n", "edge_weight", "=", "adj", ".", "_values", "(", ")", "\n", "num_nodes", "=", "adj", ".", "size", "(", "0", ")", "\n", "edge_index", ",", "edge_weight", "=", "add_self_loops", "(", "\n", "edge_index", ",", "edge_weight", ",", "fill_value", ",", "num_nodes", ")", "\n", "\n", "row", ",", "col", "=", "edge_index", "\n", "from", "torch_scatter", "import", "scatter_add", "\n", "deg", "=", "scatter_add", "(", "edge_weight", ",", "row", ",", "dim", "=", "0", ",", "dim_size", "=", "num_nodes", ")", "\n", "deg_inv_sqrt", "=", "deg", ".", "pow", "(", "-", "0.5", ")", "\n", "deg_inv_sqrt", "[", "deg_inv_sqrt", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "\n", "values", "=", "deg_inv_sqrt", "[", "row", "]", "*", "edge_weight", "*", "deg_inv_sqrt", "[", "col", "]", "\n", "\n", "shape", "=", "adj", ".", "shape", "\n", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index", ",", "values", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.add_self_loops": [[183, 198], ["torch.arange", "torch.arange", "torch.arange", "loop_index.unsqueeze().repeat.unsqueeze().repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.new_full", "torch.cat", "torch.cat", "torch.cat", "loop_index.unsqueeze().repeat.unsqueeze", "torch.cat.numel", "torch.cat.size"], "function", ["None"], ["", "def", "add_self_loops", "(", "edge_index", ",", "edge_weight", "=", "None", ",", "fill_value", "=", "1", ",", "num_nodes", "=", "None", ")", ":", "\n", "# num_nodes = maybe_num_nodes(edge_index, num_nodes)", "\n", "\n", "    ", "loop_index", "=", "torch", ".", "arange", "(", "0", ",", "num_nodes", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "device", "=", "edge_index", ".", "device", ")", "\n", "loop_index", "=", "loop_index", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ")", "\n", "\n", "if", "edge_weight", "is", "not", "None", ":", "\n", "        ", "assert", "edge_weight", ".", "numel", "(", ")", "==", "edge_index", ".", "size", "(", "1", ")", "\n", "loop_weight", "=", "edge_weight", ".", "new_full", "(", "(", "num_nodes", ",", ")", ",", "fill_value", ")", "\n", "edge_weight", "=", "torch", ".", "cat", "(", "[", "edge_weight", ",", "loop_weight", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "edge_index", "=", "torch", ".", "cat", "(", "[", "edge_index", ",", "loop_index", "]", ",", "dim", "=", "1", ")", "\n", "\n", "return", "edge_index", ",", "edge_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor": [[199, 221], ["utils.to_scipy", "utils.normalize_adj", "sparse_mx_to_torch_sparse_tensor().to", "normalize_adj.sum", "mx.sum.pow().flatten", "torch.diag", "torch.diag", "torch.diag", "torch.eye().to", "torch.eye().to", "torch.eye().to", "utils.sparse_mx_to_torch_sparse_tensor", "mx.sum.pow", "torch.isinf", "torch.isinf", "torch.isinf", "torch.eye", "torch.eye", "torch.eye"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor"], ["", "def", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "False", ")", ":", "\n", "    ", "\"\"\"Normalize adjacency tensor matrix.\n    \"\"\"", "\n", "# device = torch.device(\"cuda\" if adj.is_cuda else \"cpu\")", "\n", "device", "=", "adj", ".", "device", "\n", "if", "sparse", ":", "\n", "# warnings.warn('If you find the training process is too slow, you can uncomment line 207 in deeprobust/graph/utils.py. Note that you need to install torch_sparse')", "\n", "# TODO if this is too slow, uncomment the following code,", "\n", "# but you need to install torch_scatter", "\n", "# return normalize_sparse_tensor(adj)", "\n", "        ", "adj", "=", "to_scipy", "(", "adj", ")", "\n", "mx", "=", "normalize_adj", "(", "adj", ")", "\n", "return", "sparse_mx_to_torch_sparse_tensor", "(", "mx", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "mx", "=", "adj", "+", "torch", ".", "eye", "(", "adj", ".", "shape", "[", "0", "]", ")", ".", "to", "(", "device", ")", "\n", "rowsum", "=", "mx", ".", "sum", "(", "1", ")", "\n", "r_inv", "=", "rowsum", ".", "pow", "(", "-", "1", "/", "2", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "torch", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "torch", ".", "diag", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", "@", "mx", "\n", "mx", "=", "mx", "@", "r_mat_inv", "\n", "", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj": [[222, 234], ["r_mat_inv.dot.tolil", "numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot", "r_mat_inv.dot.sum", "scipy.eye", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "def", "degree_normalize_adj", "(", "mx", ")", ":", "\n", "    ", "\"\"\"Row-normalize sparse matrix\"\"\"", "\n", "mx", "=", "mx", ".", "tolil", "(", ")", "\n", "if", "mx", "[", "0", ",", "0", "]", "==", "0", ":", "\n", "        ", "mx", "=", "mx", "+", "sp", ".", "eye", "(", "mx", ".", "shape", "[", "0", "]", ")", "\n", "", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "# mx = mx.dot(r_mat_inv)", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_sparse_tensor": [[235, 254], ["adj._indices", "adj._values", "adj.size", "utils..", "scatter_add", "scatter_add.pow", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "float"], "function", ["None"], ["", "def", "degree_normalize_sparse_tensor", "(", "adj", ",", "fill_value", "=", "1", ")", ":", "\n", "    ", "\"\"\"degree_normalize_sparse_tensor.\n    \"\"\"", "\n", "edge_index", "=", "adj", ".", "_indices", "(", ")", "\n", "edge_weight", "=", "adj", ".", "_values", "(", ")", "\n", "num_nodes", "=", "adj", ".", "size", "(", "0", ")", "\n", "\n", "edge_index", ",", "edge_weight", "=", "add_self_loops", "(", "\n", "edge_index", ",", "edge_weight", ",", "fill_value", ",", "num_nodes", ")", "\n", "\n", "row", ",", "col", "=", "edge_index", "\n", "from", "torch_scatter", "import", "scatter_add", "\n", "deg", "=", "scatter_add", "(", "edge_weight", ",", "row", ",", "dim", "=", "0", ",", "dim_size", "=", "num_nodes", ")", "\n", "deg_inv_sqrt", "=", "deg", ".", "pow", "(", "-", "1", ")", "\n", "deg_inv_sqrt", "[", "deg_inv_sqrt", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "\n", "values", "=", "deg_inv_sqrt", "[", "row", "]", "*", "edge_weight", "\n", "shape", "=", "adj", ".", "shape", "\n", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index", ",", "values", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj_tensor": [[255, 273], ["torch.device", "torch.device", "torch.device", "utils.to_scipy", "utils.degree_normalize_adj", "sparse_mx_to_torch_sparse_tensor().to", "degree_normalize_adj.sum", "mx.sum.pow().flatten", "torch.diag", "torch.diag", "torch.diag", "torch.eye().to", "torch.eye().to", "torch.eye().to", "utils.sparse_mx_to_torch_sparse_tensor", "mx.sum.pow", "torch.isinf", "torch.isinf", "torch.isinf", "torch.eye", "torch.eye", "torch.eye"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor"], ["", "def", "degree_normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", ":", "\n", "    ", "\"\"\"degree_normalize_adj_tensor.\n    \"\"\"", "\n", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "adj", ".", "is_cuda", "else", "\"cpu\"", ")", "\n", "if", "sparse", ":", "\n", "# return  degree_normalize_sparse_tensor(adj)", "\n", "        ", "adj", "=", "to_scipy", "(", "adj", ")", "\n", "mx", "=", "degree_normalize_adj", "(", "adj", ")", "\n", "return", "sparse_mx_to_torch_sparse_tensor", "(", "mx", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "mx", "=", "adj", "+", "torch", ".", "eye", "(", "adj", ".", "shape", "[", "0", "]", ")", ".", "to", "(", "device", ")", "\n", "rowsum", "=", "mx", ".", "sum", "(", "1", ")", "\n", "r_inv", "=", "rowsum", ".", "pow", "(", "-", "1", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "torch", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "torch", ".", "diag", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", "@", "mx", "\n", "", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy": [[274, 297], ["[].type_as", "[].type_as.eq().double", "correct.sum.sum", "hasattr", "type", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "[].type_as.eq", "output.max"], "function", ["None"], ["", "def", "accuracy", "(", "output", ",", "labels", ")", ":", "\n", "    ", "\"\"\"Return accuracy of output compared to labels.\n\n    Parameters\n    ----------\n    output : torch.Tensor\n        output from model\n    labels : torch.Tensor or numpy.array\n        node labels\n\n    Returns\n    -------\n    float\n        accuracy\n    \"\"\"", "\n", "if", "not", "hasattr", "(", "labels", ",", "'__len__'", ")", ":", "\n", "        ", "labels", "=", "[", "labels", "]", "\n", "", "if", "type", "(", "labels", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "        ", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "", "preds", "=", "output", ".", "max", "(", "1", ")", "[", "1", "]", ".", "type_as", "(", "labels", ")", "\n", "correct", "=", "preds", ".", "eq", "(", "labels", ")", ".", "double", "(", ")", "\n", "correct", "=", "correct", ".", "sum", "(", ")", "\n", "return", "correct", "/", "len", "(", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.loss_acc": [[298, 308], ["[].type_as", "torch.nll_loss", "type", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "[].type_as.eq().double", "output.max", "[].type_as.eq", "correct.sum", "len"], "function", ["None"], ["", "def", "loss_acc", "(", "output", ",", "labels", ",", "targets", ",", "avg_loss", "=", "True", ")", ":", "\n", "    ", "if", "type", "(", "labels", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "        ", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "", "preds", "=", "output", ".", "max", "(", "1", ")", "[", "1", "]", ".", "type_as", "(", "labels", ")", "\n", "correct", "=", "preds", ".", "eq", "(", "labels", ")", ".", "double", "(", ")", "[", "targets", "]", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", "[", "targets", "]", ",", "labels", "[", "targets", "]", ",", "reduction", "=", "'mean'", "if", "avg_loss", "else", "'none'", ")", "\n", "\n", "if", "avg_loss", ":", "\n", "        ", "return", "loss", ",", "correct", ".", "sum", "(", ")", "/", "len", "(", "targets", ")", "\n", "", "return", "loss", ",", "correct", "\n", "# correct = correct.sum()", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.classification_margin": [[311, 333], ["torch.exp", "torch.exp", "torch.exp", "probs[].clone", "torch.exp.argmax"], "function", ["None"], ["", "def", "classification_margin", "(", "output", ",", "true_label", ")", ":", "\n", "    ", "\"\"\"Calculate classification margin for outputs.\n    `probs_true_label - probs_best_second_class`\n\n    Parameters\n    ----------\n    output: torch.Tensor\n        output vector (1 dimension)\n    true_label: int\n        true label for this node\n\n    Returns\n    -------\n    list\n        classification margin for this node\n    \"\"\"", "\n", "\n", "probs", "=", "torch", ".", "exp", "(", "output", ")", "\n", "probs_true_label", "=", "probs", "[", "true_label", "]", ".", "clone", "(", ")", "\n", "probs", "[", "true_label", "]", "=", "0", "\n", "probs_best_second_class", "=", "probs", "[", "probs", ".", "argmax", "(", ")", "]", "\n", "return", "(", "probs_true_label", "-", "probs_best_second_class", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor": [[334, 342], ["sparse_mx.tocoo().astype.tocoo().astype", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.cat.t", "torch.Size", "torch.Size", "torch.Size", "sparse_mx.tocoo().astype.tocoo", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "function", ["None"], ["", "def", "sparse_mx_to_torch_sparse_tensor", "(", "sparse_mx", ")", ":", "\n", "    ", "\"\"\"Convert a scipy sparse matrix to a torch sparse tensor.\"\"\"", "\n", "sparse_mx", "=", "sparse_mx", ".", "tocoo", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "sparserow", "=", "torch", ".", "LongTensor", "(", "sparse_mx", ".", "row", ")", ".", "unsqueeze", "(", "1", ")", "\n", "sparsecol", "=", "torch", ".", "LongTensor", "(", "sparse_mx", ".", "col", ")", ".", "unsqueeze", "(", "1", ")", "\n", "sparseconcat", "=", "torch", ".", "cat", "(", "(", "sparserow", ",", "sparsecol", ")", ",", "1", ")", "\n", "sparsedata", "=", "torch", ".", "FloatTensor", "(", "sparse_mx", ".", "data", ")", "\n", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "sparseconcat", ".", "t", "(", ")", ",", "sparsedata", ",", "torch", ".", "Size", "(", "sparse_mx", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy": [[353, 363], ["utils.is_sparse_tensor", "tensor._values", "tensor._indices", "scipy.csr_matrix", "tensor.nonzero().t", "scipy.csr_matrix", "tensor._values.cpu().numpy", "tensor.nonzero().t.cpu().numpy", "tensor.nonzero", "tensor._values.cpu().numpy", "tensor.nonzero().t.cpu().numpy", "tensor._values.cpu", "tensor.nonzero().t.cpu", "tensor._values.cpu", "tensor.nonzero().t.cpu"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor"], ["", "def", "to_scipy", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Convert a dense/sparse tensor to scipy matrix\"\"\"", "\n", "if", "is_sparse_tensor", "(", "tensor", ")", ":", "\n", "        ", "values", "=", "tensor", ".", "_values", "(", ")", "\n", "indices", "=", "tensor", ".", "_indices", "(", ")", "\n", "return", "sp", ".", "csr_matrix", "(", "(", "values", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "shape", "=", "tensor", ".", "shape", ")", "\n", "", "else", ":", "\n", "        ", "indices", "=", "tensor", ".", "nonzero", "(", ")", ".", "t", "(", ")", "\n", "values", "=", "tensor", "[", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", "]", "\n", "return", "sp", ".", "csr_matrix", "(", "(", "values", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "shape", "=", "tensor", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor": [[364, 382], ["None"], "function", ["None"], ["", "", "def", "is_sparse_tensor", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Check if a tensor is sparse tensor.\n\n    Parameters\n    ----------\n    tensor : torch.Tensor\n        given tensor\n\n    Returns\n    -------\n    bool\n        whether a tensor is sparse tensor\n    \"\"\"", "\n", "# if hasattr(tensor, 'nnz'):", "\n", "if", "tensor", ".", "layout", "==", "torch", ".", "sparse_coo", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_train_val_test": [[383, 433], ["numpy.arange", "sklearn.model_selection.train_test_split", "sklearn.model_selection.train_test_split", "numpy.random.seed"], "function", ["None"], ["", "", "def", "get_train_val_test", "(", "nnodes", ",", "val_size", "=", "0.1", ",", "test_size", "=", "0.8", ",", "stratify", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"This setting follows nettack/mettack, where we split the nodes\n    into 10% training, 10% validation and 80% testing data\n\n    Parameters\n    ----------\n    nnodes : int\n        number of nodes in total\n    val_size : float\n        size of validation set\n    test_size : float\n        size of test set\n    stratify :\n        data is expected to split in a stratified fashion. So stratify should be labels.\n    seed : int or None\n        random seed\n\n    Returns\n    -------\n    idx_train :\n        node training indices\n    idx_val :\n        node validation indices\n    idx_test :\n        node test indices\n    \"\"\"", "\n", "\n", "assert", "stratify", "is", "not", "None", ",", "'stratify cannot be None!'", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "idx", "=", "np", ".", "arange", "(", "nnodes", ")", "\n", "train_size", "=", "1", "-", "val_size", "-", "test_size", "\n", "idx_train_and_val", ",", "idx_test", "=", "train_test_split", "(", "idx", ",", "\n", "random_state", "=", "None", ",", "\n", "train_size", "=", "train_size", "+", "val_size", ",", "\n", "test_size", "=", "test_size", ",", "\n", "stratify", "=", "stratify", ")", "\n", "\n", "if", "stratify", "is", "not", "None", ":", "\n", "        ", "stratify", "=", "stratify", "[", "idx_train_and_val", "]", "\n", "\n", "", "idx_train", ",", "idx_val", "=", "train_test_split", "(", "idx_train_and_val", ",", "\n", "random_state", "=", "None", ",", "\n", "train_size", "=", "(", "train_size", "/", "(", "train_size", "+", "val_size", ")", ")", ",", "\n", "test_size", "=", "(", "val_size", "/", "(", "train_size", "+", "val_size", ")", ")", ",", "\n", "stratify", "=", "stratify", ")", "\n", "\n", "return", "idx_train", ",", "idx_val", ",", "idx_test", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_train_test": [[434, 469], ["numpy.arange", "sklearn.model_selection.train_test_split", "numpy.random.seed"], "function", ["None"], ["", "def", "get_train_test", "(", "nnodes", ",", "test_size", "=", "0.8", ",", "stratify", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"This function returns training and test set without validation.\n    It can be used for settings of different label rates.\n\n    Parameters\n    ----------\n    nnodes : int\n        number of nodes in total\n    test_size : float\n        size of test set\n    stratify :\n        data is expected to split in a stratified fashion. So stratify should be labels.\n    seed : int or None\n        random seed\n\n    Returns\n    -------\n    idx_train :\n        node training indices\n    idx_test :\n        node test indices\n    \"\"\"", "\n", "assert", "stratify", "is", "not", "None", ",", "'stratify cannot be None!'", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "idx", "=", "np", ".", "arange", "(", "nnodes", ")", "\n", "train_size", "=", "1", "-", "test_size", "\n", "idx_train", ",", "idx_test", "=", "train_test_split", "(", "idx", ",", "random_state", "=", "None", ",", "\n", "train_size", "=", "train_size", ",", "\n", "test_size", "=", "test_size", ",", "\n", "stratify", "=", "stratify", ")", "\n", "\n", "return", "idx_train", ",", "idx_test", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_train_val_test_gcn": [[470, 509], ["numpy.arange", "range", "numpy.random.permutation", "numpy.random.seed", "len", "labels.max", "numpy.random.permutation", "numpy.hstack().astype", "numpy.hstack().astype", "numpy.hstack", "numpy.hstack"], "function", ["None"], ["", "def", "get_train_val_test_gcn", "(", "labels", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"This setting follows gcn, where we randomly sample 20 instances for each class\n    as training data, 500 instances as validation data, 1000 instances as test data.\n    Note here we are not using fixed splits. When random seed changes, the splits\n    will also change.\n\n    Parameters\n    ----------\n    labels : numpy.array\n        node labels\n    seed : int or None\n        random seed\n\n    Returns\n    -------\n    idx_train :\n        node training indices\n    idx_val :\n        node validation indices\n    idx_test :\n        node test indices\n    \"\"\"", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "idx", "=", "np", ".", "arange", "(", "len", "(", "labels", ")", ")", "\n", "nclass", "=", "labels", ".", "max", "(", ")", "+", "1", "\n", "idx_train", "=", "[", "]", "\n", "idx_unlabeled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nclass", ")", ":", "\n", "        ", "labels_i", "=", "idx", "[", "labels", "==", "i", "]", "\n", "labels_i", "=", "np", ".", "random", ".", "permutation", "(", "labels_i", ")", "\n", "idx_train", "=", "np", ".", "hstack", "(", "(", "idx_train", ",", "labels_i", "[", ":", "20", "]", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "idx_unlabeled", "=", "np", ".", "hstack", "(", "(", "idx_unlabeled", ",", "labels_i", "[", "20", ":", "]", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "", "idx_unlabeled", "=", "np", ".", "random", ".", "permutation", "(", "idx_unlabeled", ")", "\n", "idx_val", "=", "idx_unlabeled", "[", ":", "500", "]", "\n", "idx_test", "=", "idx_unlabeled", "[", "500", ":", "1500", "]", "\n", "return", "idx_train", ",", "idx_val", ",", "idx_test", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_train_test_labelrate": [[510, 518], ["int", "print", "utils.get_splits_each_class", "labels.max", "round", "len"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_splits_each_class"], ["", "def", "get_train_test_labelrate", "(", "labels", ",", "label_rate", ")", ":", "\n", "    ", "\"\"\"Get train test according to given label rate.\n    \"\"\"", "\n", "nclass", "=", "labels", ".", "max", "(", ")", "+", "1", "\n", "train_size", "=", "int", "(", "round", "(", "len", "(", "labels", ")", "*", "label_rate", "/", "nclass", ")", ")", "\n", "print", "(", "\"=== train_size = %s ===\"", "%", "train_size", ")", "\n", "idx_train", ",", "idx_val", ",", "idx_test", "=", "get_splits_each_class", "(", "labels", ",", "train_size", "=", "train_size", ")", "\n", "return", "idx_train", ",", "idx_test", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_splits_each_class": [[519, 536], ["numpy.arange", "range", "len", "labels.max", "numpy.random.permutation", "numpy.hstack().astype", "numpy.hstack().astype", "numpy.hstack().astype", "numpy.random.permutation", "numpy.random.permutation", "numpy.random.permutation", "numpy.hstack", "numpy.hstack", "numpy.hstack"], "function", ["None"], ["", "def", "get_splits_each_class", "(", "labels", ",", "train_size", ")", ":", "\n", "    ", "\"\"\"We randomly sample n instances for class, where n = train_size.\n    \"\"\"", "\n", "idx", "=", "np", ".", "arange", "(", "len", "(", "labels", ")", ")", "\n", "nclass", "=", "labels", ".", "max", "(", ")", "+", "1", "\n", "idx_train", "=", "[", "]", "\n", "idx_val", "=", "[", "]", "\n", "idx_test", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nclass", ")", ":", "\n", "        ", "labels_i", "=", "idx", "[", "labels", "==", "i", "]", "\n", "labels_i", "=", "np", ".", "random", ".", "permutation", "(", "labels_i", ")", "\n", "idx_train", "=", "np", ".", "hstack", "(", "(", "idx_train", ",", "labels_i", "[", ":", "train_size", "]", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "idx_val", "=", "np", ".", "hstack", "(", "(", "idx_val", ",", "labels_i", "[", "train_size", ":", "2", "*", "train_size", "]", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "idx_test", "=", "np", ".", "hstack", "(", "(", "idx_test", ",", "labels_i", "[", "2", "*", "train_size", ":", "]", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "", "return", "np", ".", "random", ".", "permutation", "(", "idx_train", ")", ",", "np", ".", "random", ".", "permutation", "(", "idx_val", ")", ",", "np", ".", "random", ".", "permutation", "(", "idx_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.unravel_index": [[538, 542], ["None"], "function", ["None"], ["", "def", "unravel_index", "(", "index", ",", "array_shape", ")", ":", "\n", "    ", "rows", "=", "index", "//", "array_shape", "[", "1", "]", "\n", "cols", "=", "index", "%", "array_shape", "[", "1", "]", "\n", "return", "rows", ",", "cols", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_degree_squence": [[544, 549], ["adj.sum", "torch.sum().to_dense", "torch.sum"], "function", ["None"], ["", "def", "get_degree_squence", "(", "adj", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "return", "adj", ".", "sum", "(", "0", ")", "\n", "", "except", ":", "\n", "        ", "return", "ts", ".", "sum", "(", "adj", ",", "dim", "=", "1", ")", ".", "to_dense", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.likelihood_ratio_filter": [[550, 598], ["int", "original_adjacency.sum", "modified_adjacency.sum", "torch.cat", "torch.cat", "torch.cat", "utils.degree_sequence_log_likelihood", "utils.degree_sequence_log_likelihood", "utils.degree_sequence_log_likelihood", "utils.updated_log_likelihood_for_edge_changes", "utils.compute_alpha", "utils.compute_log_likelihood", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros.t", "allowed_edges.cpu().numpy().astype", "allowed_edges.numpy().astype", "allowed_edges.cpu().numpy", "allowed_edges.numpy", "allowed_edges.cpu"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_sequence_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_sequence_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_sequence_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.updated_log_likelihood_for_edge_changes", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood"], ["", "", "def", "likelihood_ratio_filter", "(", "node_pairs", ",", "modified_adjacency", ",", "original_adjacency", ",", "d_min", ",", "threshold", "=", "0.004", ")", ":", "\n", "    ", "\"\"\"\n    Filter the input node pairs based on the likelihood ratio test proposed by Z\u00fcgner et al. 2018, see\n    https://dl.acm.org/citation.cfm?id=3220078. In essence, for each node pair return 1 if adding/removing the edge\n    between the two nodes does not violate the unnoticeability constraint, and return 0 otherwise. Assumes unweighted\n    and undirected graphs.\n    \"\"\"", "\n", "\n", "N", "=", "int", "(", "modified_adjacency", ".", "shape", "[", "0", "]", ")", "\n", "# original_degree_sequence = get_degree_squence(original_adjacency)", "\n", "# current_degree_sequence = get_degree_squence(modified_adjacency)", "\n", "original_degree_sequence", "=", "original_adjacency", ".", "sum", "(", "0", ")", "\n", "current_degree_sequence", "=", "modified_adjacency", ".", "sum", "(", "0", ")", "\n", "\n", "concat_degree_sequence", "=", "torch", ".", "cat", "(", "(", "current_degree_sequence", ",", "original_degree_sequence", ")", ")", "\n", "\n", "# Compute the log likelihood values of the original, modified, and combined degree sequences.", "\n", "ll_orig", ",", "alpha_orig", ",", "n_orig", ",", "sum_log_degrees_original", "=", "degree_sequence_log_likelihood", "(", "original_degree_sequence", ",", "d_min", ")", "\n", "ll_current", ",", "alpha_current", ",", "n_current", ",", "sum_log_degrees_current", "=", "degree_sequence_log_likelihood", "(", "current_degree_sequence", ",", "d_min", ")", "\n", "\n", "ll_comb", ",", "alpha_comb", ",", "n_comb", ",", "sum_log_degrees_combined", "=", "degree_sequence_log_likelihood", "(", "concat_degree_sequence", ",", "d_min", ")", "\n", "\n", "# Compute the log likelihood ratio", "\n", "current_ratio", "=", "-", "2", "*", "ll_comb", "+", "2", "*", "(", "ll_orig", "+", "ll_current", ")", "\n", "\n", "# Compute new log likelihood values that would arise if we add/remove the edges corresponding to each node pair.", "\n", "new_lls", ",", "new_alphas", ",", "new_ns", ",", "new_sum_log_degrees", "=", "updated_log_likelihood_for_edge_changes", "(", "node_pairs", ",", "\n", "modified_adjacency", ",", "d_min", ")", "\n", "\n", "# Combination of the original degree distribution with the distributions corresponding to each node pair.", "\n", "n_combined", "=", "n_orig", "+", "new_ns", "\n", "new_sum_log_degrees_combined", "=", "sum_log_degrees_original", "+", "new_sum_log_degrees", "\n", "alpha_combined", "=", "compute_alpha", "(", "n_combined", ",", "new_sum_log_degrees_combined", ",", "d_min", ")", "\n", "new_ll_combined", "=", "compute_log_likelihood", "(", "n_combined", ",", "alpha_combined", ",", "new_sum_log_degrees_combined", ",", "d_min", ")", "\n", "new_ratios", "=", "-", "2", "*", "new_ll_combined", "+", "2", "*", "(", "new_lls", "+", "ll_orig", ")", "\n", "\n", "# Allowed edges are only those for which the resulting likelihood ratio measure is < than the threshold", "\n", "allowed_edges", "=", "new_ratios", "<", "threshold", "\n", "\n", "if", "allowed_edges", ".", "is_cuda", ":", "\n", "        ", "filtered_edges", "=", "node_pairs", "[", "allowed_edges", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "]", "\n", "", "else", ":", "\n", "        ", "filtered_edges", "=", "node_pairs", "[", "allowed_edges", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "]", "\n", "\n", "", "allowed_mask", "=", "torch", ".", "zeros", "(", "modified_adjacency", ".", "shape", ")", "\n", "allowed_mask", "[", "filtered_edges", ".", "T", "]", "=", "1", "\n", "allowed_mask", "+=", "allowed_mask", ".", "t", "(", ")", "\n", "return", "allowed_mask", ",", "current_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_sequence_log_likelihood": [[600, 616], ["len", "utils.compute_alpha", "utils.compute_log_likelihood", "torch.log().sum", "torch.log().sum", "torch.log().sum", "numpy.log().sum", "d_min.item", "torch.log", "torch.log", "torch.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood"], ["", "def", "degree_sequence_log_likelihood", "(", "degree_sequence", ",", "d_min", ")", ":", "\n", "    ", "\"\"\"\n    Compute the (maximum) log likelihood of the Powerlaw distribution fit on a degree distribution.\n    \"\"\"", "\n", "\n", "# Determine which degrees are to be considered, i.e. >= d_min.", "\n", "D_G", "=", "degree_sequence", "[", "(", "degree_sequence", ">=", "d_min", ".", "item", "(", ")", ")", "]", "\n", "try", ":", "\n", "        ", "sum_log_degrees", "=", "torch", ".", "log", "(", "D_G", ")", ".", "sum", "(", ")", "\n", "", "except", ":", "\n", "        ", "sum_log_degrees", "=", "np", ".", "log", "(", "D_G", ")", ".", "sum", "(", ")", "\n", "", "n", "=", "len", "(", "D_G", ")", "\n", "\n", "alpha", "=", "compute_alpha", "(", "n", ",", "sum_log_degrees", ",", "d_min", ")", "\n", "ll", "=", "compute_log_likelihood", "(", "n", ",", "alpha", ",", "sum_log_degrees", ",", "d_min", ")", "\n", "return", "ll", ",", "alpha", ",", "n", ",", "sum_log_degrees", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.updated_log_likelihood_for_edge_changes": [[617, 639], ["adjacency_matrix.sum", "torch.log().sum", "torch.log().sum", "torch.log().sum", "len", "utils.update_sum_log_degrees", "utils.compute_alpha", "utils.compute_log_likelihood", "torch.log", "torch.log", "torch.log", "d_min.item"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.update_sum_log_degrees", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood"], ["", "def", "updated_log_likelihood_for_edge_changes", "(", "node_pairs", ",", "adjacency_matrix", ",", "d_min", ")", ":", "\n", "    ", "\"\"\" Adopted from https://github.com/danielzuegner/nettack\n    \"\"\"", "\n", "# For each node pair find out whether there is an edge or not in the input adjacency matrix.", "\n", "\n", "edge_entries_before", "=", "adjacency_matrix", "[", "node_pairs", ".", "T", "]", "\n", "degree_sequence", "=", "adjacency_matrix", ".", "sum", "(", "1", ")", "\n", "D_G", "=", "degree_sequence", "[", "degree_sequence", ">=", "d_min", ".", "item", "(", ")", "]", "\n", "sum_log_degrees", "=", "torch", ".", "log", "(", "D_G", ")", ".", "sum", "(", ")", "\n", "n", "=", "len", "(", "D_G", ")", "\n", "deltas", "=", "-", "2", "*", "edge_entries_before", "+", "1", "\n", "d_edges_before", "=", "degree_sequence", "[", "node_pairs", "]", "\n", "\n", "d_edges_after", "=", "degree_sequence", "[", "node_pairs", "]", "+", "deltas", "[", ":", ",", "None", "]", "\n", "\n", "# Sum the log of the degrees after the potential changes which are >= d_min", "\n", "sum_log_degrees_after", ",", "new_n", "=", "update_sum_log_degrees", "(", "sum_log_degrees", ",", "n", ",", "d_edges_before", ",", "d_edges_after", ",", "d_min", ")", "\n", "# Updated estimates of the Powerlaw exponents", "\n", "new_alpha", "=", "compute_alpha", "(", "new_n", ",", "sum_log_degrees_after", ",", "d_min", ")", "\n", "# Updated log likelihood values for the Powerlaw distributions", "\n", "new_ll", "=", "compute_log_likelihood", "(", "new_n", ",", "new_alpha", ",", "sum_log_degrees_after", ",", "d_min", ")", "\n", "return", "new_ll", ",", "new_alpha", ",", "new_n", ",", "sum_log_degrees_after", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.update_sum_log_degrees": [[641, 657], ["new_n.float.float", "old_in_range.float", "new_in_range.float", "torch.log().sum", "torch.log().sum", "torch.log().sum", "torch.log().sum", "torch.log().sum", "torch.log().sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["None"], ["", "def", "update_sum_log_degrees", "(", "sum_log_degrees_before", ",", "n_old", ",", "d_old", ",", "d_new", ",", "d_min", ")", ":", "\n", "# Find out whether the degrees before and after the change are above the threshold d_min.", "\n", "    ", "old_in_range", "=", "d_old", ">=", "d_min", "\n", "new_in_range", "=", "d_new", ">=", "d_min", "\n", "d_old_in_range", "=", "d_old", "*", "old_in_range", ".", "float", "(", ")", "\n", "d_new_in_range", "=", "d_new", "*", "new_in_range", ".", "float", "(", ")", "\n", "\n", "# Update the sum by subtracting the old values and then adding the updated logs of the degrees.", "\n", "sum_log_degrees_after", "=", "sum_log_degrees_before", "-", "(", "torch", ".", "log", "(", "torch", ".", "clamp", "(", "d_old_in_range", ",", "min", "=", "1", ")", ")", ")", ".", "sum", "(", "1", ")", "+", "(", "torch", ".", "log", "(", "torch", ".", "clamp", "(", "d_new_in_range", ",", "min", "=", "1", ")", ")", ")", ".", "sum", "(", "1", ")", "\n", "\n", "# Update the number of degrees >= d_min", "\n", "\n", "new_n", "=", "n_old", "-", "(", "old_in_range", "!=", "0", ")", ".", "sum", "(", "1", ")", "+", "(", "new_in_range", "!=", "0", ")", ".", "sum", "(", "1", ")", "\n", "new_n", "=", "new_n", ".", "float", "(", ")", "\n", "return", "sum_log_degrees_after", ",", "new_n", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.compute_alpha": [[658, 664], ["torch.log", "torch.log", "torch.log", "numpy.log"], "function", ["None"], ["", "def", "compute_alpha", "(", "n", ",", "sum_log_degrees", ",", "d_min", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "alpha", "=", "1", "+", "n", "/", "(", "sum_log_degrees", "-", "n", "*", "torch", ".", "log", "(", "d_min", "-", "0.5", ")", ")", "\n", "", "except", ":", "\n", "        ", "alpha", "=", "1", "+", "n", "/", "(", "sum_log_degrees", "-", "n", "*", "np", ".", "log", "(", "d_min", "-", "0.5", ")", ")", "\n", "", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.compute_log_likelihood": [[665, 673], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "numpy.log", "numpy.log"], "function", ["None"], ["", "def", "compute_log_likelihood", "(", "n", ",", "alpha", ",", "sum_log_degrees", ",", "d_min", ")", ":", "\n", "# Log likelihood under alpha", "\n", "    ", "try", ":", "\n", "        ", "ll", "=", "n", "*", "torch", ".", "log", "(", "alpha", ")", "+", "n", "*", "alpha", "*", "torch", ".", "log", "(", "d_min", ")", "+", "(", "alpha", "+", "1", ")", "*", "sum_log_degrees", "\n", "", "except", ":", "\n", "        ", "ll", "=", "n", "*", "np", ".", "log", "(", "alpha", ")", "+", "n", "*", "alpha", "*", "np", ".", "log", "(", "d_min", ")", "+", "(", "alpha", "+", "1", ")", "*", "sum_log_degrees", "\n", "\n", "", "return", "ll", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.ravel_multiple_indices": [[674, 696], ["None"], "function", ["None"], ["", "def", "ravel_multiple_indices", "(", "ixs", ",", "shape", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    \"Flattens\" multiple 2D input indices into indices on the flattened matrix, similar to np.ravel_multi_index.\n    Does the same as ravel_index but for multiple indices at once.\n    Parameters\n    ----------\n    ixs: array of ints shape (n, 2)\n        The array of n indices that will be flattened.\n\n    shape: list or tuple of ints of length 2\n        The shape of the corresponding matrix.\n\n    Returns\n    -------\n    array of n ints between 0 and shape[0]*shape[1]-1\n        The indices on the flattened matrix corresponding to the 2D input indices.\n\n    \"\"\"", "\n", "if", "reverse", ":", "\n", "        ", "return", "ixs", "[", ":", ",", "1", "]", "*", "shape", "[", "1", "]", "+", "ixs", "[", ":", ",", "0", "]", "\n", "\n", "", "return", "ixs", "[", ":", ",", "0", "]", "*", "shape", "[", "1", "]", "+", "ixs", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.visualize": [[697, 704], ["make_dot().view", "make_dot"], "function", ["None"], ["", "def", "visualize", "(", "your_var", ")", ":", "\n", "    ", "\"\"\"visualize computation graph\"\"\"", "\n", "from", "graphviz", "import", "Digraph", "\n", "import", "torch", "\n", "from", "torch", ".", "autograd", "import", "Variable", "\n", "from", "torchviz", "import", "make_dot", "\n", "make_dot", "(", "your_var", ")", ".", "view", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.reshape_mx": [[705, 708], ["mx.nonzero", "scipy.csr_matrix"], "function", ["None"], ["", "def", "reshape_mx", "(", "mx", ",", "shape", ")", ":", "\n", "    ", "indices", "=", "mx", ".", "nonzero", "(", ")", "\n", "return", "sp", ".", "csr_matrix", "(", "(", "mx", ".", "data", ",", "(", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", ")", ")", ",", "shape", "=", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.__init__": [[62, 81], ["deeprobust.graph.global_attack.BaseAttack.__init__", "torch.nn.parameter.Parameter", "topology_attack.PGDAttack.adj_changes.data.fill_", "torch.FloatTensor", "int"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "loss_type", "=", "'CE'", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "PGDAttack", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "\n", "assert", "attack_features", "or", "attack_structure", ",", "'attack_features or attack_structure cannot be both False'", "\n", "\n", "self", ".", "loss_type", "=", "loss_type", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "\n", "if", "attack_structure", ":", "\n", "            ", "assert", "nnodes", "is", "not", "None", ",", "'Please give nnodes='", "\n", "self", ".", "adj_changes", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "int", "(", "nnodes", "*", "(", "nnodes", "-", "1", ")", "/", "2", ")", ")", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "", "if", "attack_features", ":", "\n", "            ", "assert", "True", ",", "'Topology Attack does not support attack feature'", "\n", "\n", "", "self", ".", "complementary", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.attack": [[82, 130], ["scipy.issparse", "deeprobust.graph.utils.to_tensor", "victim_model.eval", "tqdm.tqdm.tqdm", "topology_attack.PGDAttack.random_sample", "topology_attack.PGDAttack.get_modified_adj().detach", "topology_attack.PGDAttack.check_adj_tensor", "range", "topology_attack.PGDAttack.get_modified_adj", "deeprobust.graph.utils.normalize_adj_tensor", "victim_model", "topology_attack.PGDAttack._loss", "topology_attack.PGDAttack.projection", "torch.autograd.grad", "topology_attack.PGDAttack.adj_changes.data.add_", "topology_attack.PGDAttack.adj_changes.data.add_", "topology_attack.PGDAttack.get_modified_adj", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.random_sample", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.check_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj"], ["", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "n_perturbations", ",", "epochs", "=", "200", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        epochs:\n            number of training epochs\n\n        \"\"\"", "\n", "\n", "victim_model", "=", "self", ".", "surrogate", "\n", "\n", "self", ".", "sparse_features", "=", "sp", ".", "issparse", "(", "ori_features", ")", "\n", "ori_adj", ",", "ori_features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "victim_model", ".", "eval", "(", ")", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "epochs", ")", ")", ":", "\n", "            ", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "output", "=", "victim_model", "(", "ori_features", ",", "adj_norm", ")", "\n", "# loss = F.nll_loss(output[idx_train], labels[idx_train])", "\n", "loss", "=", "self", ".", "_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "adj_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "self", ".", "adj_changes", ")", "[", "0", "]", "\n", "\n", "if", "self", ".", "loss_type", "==", "'CE'", ":", "\n", "                ", "lr", "=", "200", "/", "np", ".", "sqrt", "(", "t", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "add_", "(", "lr", "*", "adj_grad", ")", "\n", "\n", "", "if", "self", ".", "loss_type", "==", "'CW'", ":", "\n", "                ", "lr", "=", "0.1", "/", "np", ".", "sqrt", "(", "t", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "add_", "(", "lr", "*", "adj_grad", ")", "\n", "\n", "", "self", ".", "projection", "(", "n_perturbations", ")", "\n", "\n", "", "self", ".", "random_sample", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "idx_train", ",", "n_perturbations", ")", "\n", "self", ".", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", ".", "detach", "(", ")", "\n", "self", ".", "check_adj_tensor", "(", "self", ".", "modified_adj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.random_sample": [[132, 155], ["torch.no_grad", "topology_attack.PGDAttack.adj_changes.cpu().detach().numpy", "range", "topology_attack.PGDAttack.adj_changes.data.copy_", "numpy.random.binomial", "topology_attack.PGDAttack.adj_changes.data.copy_", "topology_attack.PGDAttack.get_modified_adj", "deeprobust.graph.utils.normalize_adj_tensor", "victim_model", "topology_attack.PGDAttack._loss", "torch.tensor", "topology_attack.PGDAttack.adj_changes.cpu().detach", "numpy.random.binomial.sum", "torch.tensor", "topology_attack.PGDAttack.adj_changes.cpu"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._loss"], ["", "def", "random_sample", "(", "self", ",", "ori_adj", ",", "ori_features", ",", "labels", ",", "idx_train", ",", "n_perturbations", ")", ":", "\n", "        ", "K", "=", "20", "\n", "best_loss", "=", "-", "1000", "\n", "victim_model", "=", "self", ".", "surrogate", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "s", "=", "self", ".", "adj_changes", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "for", "i", "in", "range", "(", "K", ")", ":", "\n", "                ", "sampled", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "s", ")", "\n", "\n", "# print(sampled.sum())", "\n", "if", "sampled", ".", "sum", "(", ")", ">", "n_perturbations", ":", "\n", "                    ", "continue", "\n", "", "self", ".", "adj_changes", ".", "data", ".", "copy_", "(", "torch", ".", "tensor", "(", "sampled", ")", ")", "\n", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "output", "=", "victim_model", "(", "ori_features", ",", "adj_norm", ")", "\n", "loss", "=", "self", ".", "_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "# loss = F.nll_loss(output[idx_train], labels[idx_train])", "\n", "# print(loss)", "\n", "if", "best_loss", "<", "loss", ":", "\n", "                    ", "best_loss", "=", "loss", "\n", "best_s", "=", "sampled", "\n", "", "", "self", ".", "adj_changes", ".", "data", ".", "copy_", "(", "torch", ".", "tensor", "(", "best_s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack._loss": [[156, 168], ["torch.nn.functional.nll_loss", "deeprobust.graph.utils.tensor2onehot", "torch.clamp().mean", "torch.clamp", "numpy.arange", "numpy.arange", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.tensor2onehot"], ["", "", "def", "_loss", "(", "self", ",", "output", ",", "labels", ")", ":", "\n", "        ", "if", "self", ".", "loss_type", "==", "\"CE\"", ":", "\n", "            ", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "labels", ")", "\n", "", "if", "self", ".", "loss_type", "==", "\"CW\"", ":", "\n", "            ", "onehot", "=", "utils", ".", "tensor2onehot", "(", "labels", ")", "\n", "best_second_class", "=", "(", "output", "-", "1000", "*", "onehot", ")", ".", "argmax", "(", "1", ")", "\n", "margin", "=", "output", "[", "np", ".", "arange", "(", "len", "(", "output", ")", ")", ",", "labels", "]", "-", "output", "[", "np", ".", "arange", "(", "len", "(", "output", ")", ")", ",", "best_second_class", "]", "\n", "k", "=", "0", "\n", "loss", "=", "-", "torch", ".", "clamp", "(", "margin", ",", "min", "=", "k", ")", ".", "mean", "(", ")", "\n", "# loss = torch.clamp(margin.sum()+50, min=k)", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.projection": [[169, 178], ["torch.clamp().sum", "topology_attack.PGDAttack.adj_changes.max", "topology_attack.PGDAttack.bisection", "topology_attack.PGDAttack.adj_changes.data.copy_", "topology_attack.PGDAttack.adj_changes.data.copy_", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.bisection"], ["", "def", "projection", "(", "self", ",", "n_perturbations", ")", ":", "\n", "# projected = torch.clamp(self.adj_changes, 0, 1)", "\n", "        ", "if", "torch", ".", "clamp", "(", "self", ".", "adj_changes", ",", "0", ",", "1", ")", ".", "sum", "(", ")", ">", "n_perturbations", ":", "\n", "            ", "left", "=", "(", "self", ".", "adj_changes", "-", "1", ")", ".", "min", "(", ")", "\n", "right", "=", "self", ".", "adj_changes", ".", "max", "(", ")", "\n", "miu", "=", "self", ".", "bisection", "(", "left", ",", "right", ",", "n_perturbations", ",", "epsilon", "=", "1e-5", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "copy_", "(", "torch", ".", "clamp", "(", "self", ".", "adj_changes", ".", "data", "-", "miu", ",", "min", "=", "0", ",", "max", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "adj_changes", ".", "data", ".", "copy_", "(", "torch", ".", "clamp", "(", "self", ".", "adj_changes", ".", "data", ",", "min", "=", "0", ",", "max", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.get_modified_adj": [[179, 191], ["torch.zeros().to", "torch.tril_indices", "torch.zeros().to.t", "torch.zeros", "torch.ones_like", "torch.eye().to", "torch.eye"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "get_modified_adj", "(", "self", ",", "ori_adj", ")", ":", "\n", "\n", "        ", "if", "self", ".", "complementary", "is", "None", ":", "\n", "            ", "self", ".", "complementary", "=", "(", "torch", ".", "ones_like", "(", "ori_adj", ")", "-", "torch", ".", "eye", "(", "self", ".", "nnodes", ")", ".", "to", "(", "self", ".", "device", ")", "-", "ori_adj", ")", "-", "ori_adj", "\n", "\n", "", "m", "=", "torch", ".", "zeros", "(", "(", "self", ".", "nnodes", ",", "self", ".", "nnodes", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "tril_indices", "=", "torch", ".", "tril_indices", "(", "row", "=", "self", ".", "nnodes", ",", "col", "=", "self", ".", "nnodes", ",", "offset", "=", "-", "1", ")", "\n", "m", "[", "tril_indices", "[", "0", "]", ",", "tril_indices", "[", "1", "]", "]", "=", "self", ".", "adj_changes", "\n", "m", "=", "m", "+", "m", ".", "t", "(", ")", "\n", "modified_adj", "=", "self", ".", "complementary", "*", "m", "+", "ori_adj", "\n", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.bisection": [[192, 209], ["torch.clamp().sum", "topology_attack.PGDAttack.bisection.func"], "methods", ["None"], ["", "def", "bisection", "(", "self", ",", "a", ",", "b", ",", "n_perturbations", ",", "epsilon", ")", ":", "\n", "        ", "def", "func", "(", "x", ")", ":", "\n", "            ", "return", "torch", ".", "clamp", "(", "self", ".", "adj_changes", "-", "x", ",", "0", ",", "1", ")", ".", "sum", "(", ")", "-", "n_perturbations", "\n", "\n", "", "miu", "=", "a", "\n", "while", "(", "(", "b", "-", "a", ")", ">=", "epsilon", ")", ":", "\n", "            ", "miu", "=", "(", "a", "+", "b", ")", "/", "2", "\n", "# Check if middle point is root", "\n", "if", "(", "func", "(", "miu", ")", "==", "0.0", ")", ":", "\n", "                ", "break", "\n", "# Decide the side to repeat the steps", "\n", "", "if", "(", "func", "(", "miu", ")", "*", "func", "(", "a", ")", "<", "0", ")", ":", "\n", "                ", "b", "=", "miu", "\n", "", "else", ":", "\n", "                ", "a", "=", "miu", "\n", "# print(\"The value of root is : \",\"%.4f\" % miu)", "\n", "", "", "return", "miu", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.MinMax.__init__": [[253, 256], ["topology_attack.PGDAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "loss_type", "=", "'CE'", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "MinMax", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "loss_type", ",", "feature_shape", ",", "attack_structure", ",", "attack_features", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.MinMax.attack": [[258, 323], ["scipy.issparse", "deeprobust.graph.utils.to_tensor", "torch.optim.Adam", "victim_model.eval", "tqdm.tqdm.tqdm", "topology_attack.MinMax.random_sample", "topology_attack.MinMax.get_modified_adj().detach", "victim_model.parameters", "range", "victim_model.train", "topology_attack.MinMax.get_modified_adj", "deeprobust.graph.utils.normalize_adj_tensor", "victim_model", "topology_attack.MinMax._loss", "torch.optim.Adam.zero_grad", "topology_attack.MinMax.backward", "torch.optim.Adam.step", "victim_model.eval", "topology_attack.MinMax.get_modified_adj", "deeprobust.graph.utils.normalize_adj_tensor", "victim_model", "topology_attack.MinMax._loss", "topology_attack.MinMax.projection", "torch.autograd.grad", "topology_attack.MinMax.adj_changes.data.add_", "topology_attack.MinMax.adj_changes.data.add_", "topology_attack.MinMax.get_modified_adj", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.random_sample", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj"], ["", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        epochs:\n            number of training epochs\n\n        \"\"\"", "\n", "\n", "victim_model", "=", "self", ".", "surrogate", "\n", "\n", "self", ".", "sparse_features", "=", "sp", ".", "issparse", "(", "ori_features", ")", "\n", "ori_adj", ",", "ori_features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# optimizer", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "victim_model", ".", "parameters", "(", ")", ",", "lr", "=", "0.01", ")", "\n", "\n", "epochs", "=", "200", "\n", "victim_model", ".", "eval", "(", ")", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "epochs", ")", ")", ":", "\n", "# update victim model", "\n", "            ", "victim_model", ".", "train", "(", ")", "\n", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "output", "=", "victim_model", "(", "ori_features", ",", "adj_norm", ")", "\n", "loss", "=", "self", ".", "_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# generate pgd attack", "\n", "victim_model", ".", "eval", "(", ")", "\n", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "output", "=", "victim_model", "(", "ori_features", ",", "adj_norm", ")", "\n", "loss", "=", "self", ".", "_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "adj_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "self", ".", "adj_changes", ")", "[", "0", "]", "\n", "# adj_grad = self.adj_changes.grad", "\n", "\n", "if", "self", ".", "loss_type", "==", "'CE'", ":", "\n", "                ", "lr", "=", "200", "/", "np", ".", "sqrt", "(", "t", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "add_", "(", "lr", "*", "adj_grad", ")", "\n", "\n", "", "if", "self", ".", "loss_type", "==", "'CW'", ":", "\n", "                ", "lr", "=", "0.1", "/", "np", ".", "sqrt", "(", "t", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "add_", "(", "lr", "*", "adj_grad", ")", "\n", "\n", "# self.adj_changes.grad.zero_()", "\n", "", "self", ".", "projection", "(", "n_perturbations", ")", "\n", "\n", "", "self", ".", "random_sample", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "idx_train", ",", "n_perturbations", ")", "\n", "self", ".", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", ".", "detach", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.__init__": [[41, 43], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.attack": [[44, 112], ["node_embedding_attack.NodeEmbeddingAttack.flip_candidates", "node_embedding_attack.NodeEmbeddingAttack.check_adj", "node_embedding_attack.NodeEmbeddingAttack.flip_candidates", "scipy.eigh", "scipy.eigh", "node_embedding_attack.estimate_loss_with_delta_eigenvals", "estimate_loss_with_delta_eigenvals.argsort", "numpy.diag", "scipy.eigh", "scipy.eigh", "node_embedding_attack.estimate_loss_with_delta_eigenvals", "len", "node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal_minimum_spanning_tree", "node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal", "node_embedding_attack.NodeEmbeddingAttack.generate_candidates_addition", "node_embedding_attack.NodeEmbeddingAttack.toarray", "numpy.diag", "adj.toarray", "adj.sum", "node_embedding_attack.NodeEmbeddingAttack.sum", "estimate_loss_with_delta_eigenvals.argsort"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.flip_candidates", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.flip_candidates", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.estimate_loss_with_delta_eigenvals", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.estimate_loss_with_delta_eigenvals", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal_minimum_spanning_tree", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_addition"], ["", "def", "attack", "(", "self", ",", "adj", ",", "n_perturbations", "=", "1000", ",", "dim", "=", "32", ",", "window_size", "=", "5", ",", "\n", "attack_type", "=", "\"remove\"", ",", "min_span_tree", "=", "False", ",", "n_candidates", "=", "None", ",", "seed", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Selects the top (n_perturbations) number of flips using our perturbation attack.\n\n        :param adj: sp.spmatrix\n            The graph represented as a sparse scipy matrix\n        :param n_perturbations: int\n            Number of flips to select\n        :param dim: int\n            Dimensionality of the embeddings.\n        :param window_size: int\n            Co-occurence window size.\n        :param attack_type: str\n            can be chosed from [\"remove\", \"add\", \"add_by_remove\"]\n        :param min_span_tree: bool\n            Whether to disallow edges that lie on the minimum spanning tree;\n            only valid when `attack_type` is \"remove\"\n        :param n_candidates: int\n            Number of candiates for addition; only valid when `attack_type` is \"add\" or \"add_by_remove\";\n        :param seed: int\n            Random seed\n        \"\"\"", "\n", "assert", "attack_type", "in", "[", "\"remove\"", ",", "\"add\"", ",", "\"add_by_remove\"", "]", ",", "\"attack_type can only be `remove` or `add`\"", "\n", "\n", "if", "attack_type", "==", "\"remove\"", ":", "\n", "            ", "if", "min_span_tree", ":", "\n", "                ", "candidates", "=", "self", ".", "generate_candidates_removal_minimum_spanning_tree", "(", "adj", ")", "\n", "", "else", ":", "\n", "                ", "candidates", "=", "self", ".", "generate_candidates_removal", "(", "adj", ",", "seed", ")", "\n", "\n", "", "", "elif", "attack_type", "==", "\"add\"", "or", "attack_type", "==", "\"add_by_remove\"", ":", "\n", "\n", "            ", "assert", "n_candidates", ",", "\"please specify the value of `n_candidates`, \"", "+", "\"i.e. how many candiate you want to genereate for addition\"", "\n", "candidates", "=", "self", ".", "generate_candidates_addition", "(", "adj", ",", "n_candidates", ",", "seed", ")", "\n", "\n", "\n", "", "n_nodes", "=", "adj", ".", "shape", "[", "0", "]", "\n", "\n", "if", "attack_type", "==", "\"add_by_remove\"", ":", "\n", "            ", "candidates_add", "=", "candidates", "\n", "adj_add", "=", "self", ".", "flip_candidates", "(", "adj", ",", "candidates_add", ")", "\n", "vals_org_add", ",", "vecs_org_add", "=", "spl", ".", "eigh", "(", "adj_add", ".", "toarray", "(", ")", ",", "np", ".", "diag", "(", "adj_add", ".", "sum", "(", "1", ")", ".", "A1", ")", ")", "\n", "flip_indicator", "=", "1", "-", "2", "*", "adj_add", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "loss_est", "=", "estimate_loss_with_delta_eigenvals", "(", "candidates_add", ",", "flip_indicator", ",", "\n", "vals_org_add", ",", "vecs_org_add", ",", "n_nodes", ",", "dim", ",", "window_size", ")", "\n", "\n", "loss_argsort", "=", "loss_est", ".", "argsort", "(", ")", "\n", "top_flips", "=", "candidates_add", "[", "loss_argsort", "[", ":", "n_perturbations", "]", "]", "\n", "\n", "", "else", ":", "\n", "# vector indicating whether we are adding an edge (+1) or removing an edge (-1)", "\n", "            ", "delta_w", "=", "1", "-", "2", "*", "adj", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "# generalized eigenvalues/eigenvectors", "\n", "deg_matrix", "=", "np", ".", "diag", "(", "adj", ".", "sum", "(", "1", ")", ".", "A1", ")", "\n", "vals_org", ",", "vecs_org", "=", "spl", ".", "eigh", "(", "adj", ".", "toarray", "(", ")", ",", "deg_matrix", ")", "\n", "\n", "loss_for_candidates", "=", "estimate_loss_with_delta_eigenvals", "(", "candidates", ",", "delta_w", ",", "vals_org", ",", "vecs_org", ",", "n_nodes", ",", "dim", ",", "window_size", ")", "\n", "top_flips", "=", "candidates", "[", "loss_for_candidates", ".", "argsort", "(", ")", "[", "-", "n_perturbations", ":", "]", "]", "\n", "\n", "", "assert", "len", "(", "top_flips", ")", "==", "n_perturbations", "\n", "\n", "modified_adj", "=", "self", ".", "flip_candidates", "(", "adj", ",", "top_flips", ")", "\n", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal": [[113, 141], ["numpy.column_stack", "node_embedding_attack.edges_to_sparse", "adj_hidden.maximum.maximum.maximum", "numpy.column_stack", "numpy.random.seed", "numpy.where", "scipy.triu().nonzero", "scipy.triu().nonzero", "numpy.arange", "numpy.fromiter", "numpy.logical_not", "map", "scipy.triu", "scipy.triu", "adj.sum", "numpy.in1d", "numpy.in1d", "adj.tolil"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.edges_to_sparse"], ["", "def", "generate_candidates_removal", "(", "self", ",", "adj", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generates candidate edge flips for removal (edge -> non-edge),\n        disallowing one random edge per node to prevent singleton nodes.\n\n        :param adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        :param seed: int\n            Random seed\n        :return: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        \"\"\"", "\n", "n_nodes", "=", "adj", ".", "shape", "[", "0", "]", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "", "deg", "=", "np", ".", "where", "(", "adj", ".", "sum", "(", "1", ")", ".", "A1", "==", "1", ")", "[", "0", "]", "\n", "hiddeen", "=", "np", ".", "column_stack", "(", "\n", "(", "np", ".", "arange", "(", "n_nodes", ")", ",", "np", ".", "fromiter", "(", "map", "(", "np", ".", "random", ".", "choice", ",", "adj", ".", "tolil", "(", ")", ".", "rows", ")", ",", "dtype", "=", "np", ".", "int32", ")", ")", ")", "\n", "\n", "adj_hidden", "=", "edges_to_sparse", "(", "hiddeen", ",", "adj", ".", "shape", "[", "0", "]", ")", "\n", "adj_hidden", "=", "adj_hidden", ".", "maximum", "(", "adj_hidden", ".", "T", ")", "\n", "\n", "adj_keep", "=", "adj", "-", "adj_hidden", "\n", "\n", "candidates", "=", "np", ".", "column_stack", "(", "(", "sp", ".", "triu", "(", "adj_keep", ")", ".", "nonzero", "(", ")", ")", ")", "\n", "\n", "candidates", "=", "candidates", "[", "np", ".", "logical_not", "(", "np", ".", "in1d", "(", "candidates", "[", ":", ",", "0", "]", ",", "deg", ")", "|", "np", ".", "in1d", "(", "candidates", "[", ":", ",", "1", "]", ",", "deg", ")", ")", "]", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal_minimum_spanning_tree": [[142, 156], ["scipy.csgraph.minimum_spanning_tree", "scipy.csgraph.minimum_spanning_tree", "mst.maximum.maximum.maximum", "numpy.column_stack", "scipy.triu().nonzero", "scipy.triu().nonzero", "scipy.triu", "scipy.triu"], "methods", ["None"], ["", "def", "generate_candidates_removal_minimum_spanning_tree", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Generates candidate edge flips for removal (edge -> non-edge),\n         disallowing edges that lie on the minimum spanning tree.\n        adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        :return: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        \"\"\"", "\n", "mst", "=", "sp", ".", "csgraph", ".", "minimum_spanning_tree", "(", "adj", ")", "\n", "mst", "=", "mst", ".", "maximum", "(", "mst", ".", "T", ")", "\n", "adj_sample", "=", "adj", "-", "mst", "\n", "candidates", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj_sample", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_addition": [[157, 183], ["numpy.random.randint", "numpy.array", "numpy.random.seed", "list", "len", "set", "map"], "methods", ["None"], ["", "def", "generate_candidates_addition", "(", "self", ",", "adj", ",", "n_candidates", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generates candidate edge flips for addition (non-edge -> edge).\n\n        :param adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        :param n_candidates: int\n            Number of candidates to generate.\n        :param seed: int\n            Random seed\n        :return: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        \"\"\"", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "num_nodes", "=", "adj", ".", "shape", "[", "0", "]", "\n", "\n", "candidates", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "num_nodes", ",", "[", "n_candidates", "*", "5", ",", "2", "]", ")", "\n", "candidates", "=", "candidates", "[", "candidates", "[", ":", ",", "0", "]", "<", "candidates", "[", ":", ",", "1", "]", "]", "\n", "candidates", "=", "candidates", "[", "adj", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "==", "0", "]", "\n", "candidates", "=", "np", ".", "array", "(", "list", "(", "set", "(", "map", "(", "tuple", ",", "candidates", ")", ")", ")", ")", "\n", "candidates", "=", "candidates", "[", ":", "n_candidates", "]", "\n", "\n", "assert", "len", "(", "candidates", ")", "==", "n_candidates", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.flip_candidates": [[184, 201], ["adj.copy().tolil", "adj_flipped.tocsr.tocsr.tocsr", "adj_flipped.tocsr.tocsr.eliminate_zeros", "adj.copy"], "methods", ["None"], ["", "def", "flip_candidates", "(", "self", ",", "adj", ",", "candidates", ")", ":", "\n", "        ", "\"\"\"Flip the edges in the candidate set to non-edges and vise-versa.\n\n        :param adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        :param candidates: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        :return: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph with the flipped edges/non-edges.\n        \"\"\"", "\n", "adj_flipped", "=", "adj", ".", "copy", "(", ")", ".", "tolil", "(", ")", "\n", "adj_flipped", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", "=", "1", "-", "adj", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", "\n", "adj_flipped", "[", "candidates", "[", ":", ",", "1", "]", ",", "candidates", "[", ":", ",", "0", "]", "]", "=", "1", "-", "adj", "[", "candidates", "[", ":", ",", "1", "]", ",", "candidates", "[", ":", ",", "0", "]", "]", "\n", "adj_flipped", "=", "adj_flipped", ".", "tocsr", "(", ")", "\n", "adj_flipped", ".", "eliminate_zeros", "(", ")", "\n", "\n", "return", "adj_flipped", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.__init__": [[327, 330], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "type", ")", ":", "\n", "        ", "assert", "type", "in", "[", "\"degree\"", ",", "\"eigencentrality\"", ",", "\"random\"", "]", "\n", "self", ".", "type", "=", "type", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.attack": [[331, 381], ["node_embedding_attack.OtherNodeEmbeddingAttack.flip_candidates", "node_embedding_attack.OtherNodeEmbeddingAttack.check_adj", "node_embedding_attack.OtherNodeEmbeddingAttack.random_top_flips", "len", "node_embedding_attack.OtherNodeEmbeddingAttack.generate_candidates_removal_minimum_spanning_tree", "node_embedding_attack.OtherNodeEmbeddingAttack.generate_candidates_removal", "node_embedding_attack.OtherNodeEmbeddingAttack.generate_candidates_addition", "node_embedding_attack.OtherNodeEmbeddingAttack.eigencentrality_top_flips", "node_embedding_attack.OtherNodeEmbeddingAttack.degree_top_flips"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.flip_candidates", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.random_top_flips", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal_minimum_spanning_tree", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_removal", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.NodeEmbeddingAttack.generate_candidates_addition", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.eigencentrality_top_flips", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.degree_top_flips"], ["", "def", "attack", "(", "self", ",", "adj", ",", "n_perturbations", "=", "1000", ",", "attack_type", "=", "\"remove\"", ",", "\n", "min_span_tree", "=", "False", ",", "n_candidates", "=", "None", ",", "seed", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Selects the top (n_perturbations) number of flips using our perturbation attack.\n\n        :param adj: sp.spmatrix\n            The graph represented as a sparse scipy matrix\n        :param n_perturbations: int\n            Number of flips to select\n        :param dim: int\n            Dimensionality of the embeddings.\n        :param attack_type: str\n            can be chosed from [\"remove\", \"add\"]\n        :param min_span_tree: bool\n            Whether to disallow edges that lie on the minimum spanning tree;\n            only valid when `attack_type` is \"remove\"\n        :param n_candidates: int\n            Number of candiates for addition; only valid when `attack_type` is \"add\";\n        :param seed: int\n            Random seed;\n        :return: np.ndarray, shape [?, 2]\n            The top edge flips from the candidate set\n        \"\"\"", "\n", "assert", "attack_type", "in", "[", "\"remove\"", ",", "\"add\"", "]", ",", "\"attack_type can only be `remove` or `add`\"", "\n", "\n", "if", "attack_type", "==", "\"remove\"", ":", "\n", "            ", "if", "min_span_tree", ":", "\n", "                ", "candidates", "=", "self", ".", "generate_candidates_removal_minimum_spanning_tree", "(", "adj", ")", "\n", "", "else", ":", "\n", "                ", "candidates", "=", "self", ".", "generate_candidates_removal", "(", "adj", ",", "seed", ")", "\n", "", "", "elif", "attack_type", "==", "\"add\"", ":", "\n", "            ", "assert", "n_candidates", ",", "\"please specify the value of `n_candidates`, \"", "+", "\"i.e. how many candiate you want to genereate for addition\"", "\n", "candidates", "=", "self", ".", "generate_candidates_addition", "(", "adj", ",", "n_candidates", ",", "seed", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "if", "self", ".", "type", "==", "\"random\"", ":", "\n", "            ", "top_flips", "=", "self", ".", "random_top_flips", "(", "candidates", ",", "n_perturbations", ",", "seed", ")", "\n", "", "elif", "self", ".", "type", "==", "\"eigencentrality\"", ":", "\n", "            ", "top_flips", "=", "self", ".", "eigencentrality_top_flips", "(", "adj", ",", "candidates", ",", "n_perturbations", ")", "\n", "", "elif", "self", ".", "type", "==", "\"degree\"", ":", "\n", "            ", "top_flips", "=", "self", ".", "degree_top_flips", "(", "adj", ",", "candidates", ",", "n_perturbations", ",", "complement", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "assert", "len", "(", "top_flips", ")", "==", "n_perturbations", "\n", "modified_adj", "=", "self", ".", "flip_candidates", "(", "adj", ",", "top_flips", ")", "\n", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.random_top_flips": [[382, 397], ["numpy.random.seed", "numpy.random.permutation", "len"], "methods", ["None"], ["", "def", "random_top_flips", "(", "self", ",", "candidates", ",", "n_perturbations", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Selects (n_perturbations) number of flips at random.\n\n        :param candidates: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        :param n_perturbations: int\n            Number of flips to select\n        :param seed: int\n            Random seed\n        :return: np.ndarray, shape [?, 2]\n            The top edge flips from the candidate set\n        \"\"\"", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "", "return", "candidates", "[", "np", ".", "random", ".", "permutation", "(", "len", "(", "candidates", ")", ")", "[", ":", "n_perturbations", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.eigencentrality_top_flips": [[399, 419], ["numpy.column_stack", "node_embedding_attack.construct_line_graph", "networkx.eigenvector_centrality_numpy", "numpy.array", "numpy.array.argsort", "scipy.triu().nonzero", "scipy.triu().nonzero", "networkx.Graph", "tuple", "numpy.array.items", "scipy.triu", "scipy.triu", "tuple"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.construct_line_graph"], ["", "def", "eigencentrality_top_flips", "(", "self", ",", "adj", ",", "candidates", ",", "n_perturbations", ")", ":", "\n", "        ", "\"\"\"Selects the top (n_perturbations) number of flips using eigencentrality score of the edges.\n        Applicable only when removing edges.\n\n        :param adj: sp.spmatrix\n            The graph represented as a sparse scipy matrix\n        :param candidates: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        :param n_perturbations: int\n            Number of flips to select\n        :return: np.ndarray, shape [?, 2]\n            The top edge flips from the candidate set\n        \"\"\"", "\n", "edges", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "line_graph", "=", "construct_line_graph", "(", "adj", ")", "\n", "eigcentrality_scores", "=", "nx", ".", "eigenvector_centrality_numpy", "(", "nx", ".", "Graph", "(", "line_graph", ")", ")", "\n", "eigcentrality_scores", "=", "{", "tuple", "(", "edges", "[", "k", "]", ")", ":", "eigcentrality_scores", "[", "k", "]", "for", "k", ",", "v", "in", "eigcentrality_scores", ".", "items", "(", ")", "}", "\n", "eigcentrality_scores", "=", "np", ".", "array", "(", "[", "eigcentrality_scores", "[", "tuple", "(", "cnd", ")", "]", "for", "cnd", "in", "candidates", "]", ")", "\n", "scores_argsrt", "=", "eigcentrality_scores", ".", "argsort", "(", ")", "\n", "return", "candidates", "[", "scores_argsrt", "[", "-", "n_perturbations", ":", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.OtherNodeEmbeddingAttack.degree_top_flips": [[421, 441], ["scipy.csr_matrix", "scipy.csr_matrix", "scipy.csr_matrix.sum", "scipy.csr_matrix.toarray"], "methods", ["None"], ["", "def", "degree_top_flips", "(", "self", ",", "adj", ",", "candidates", ",", "n_perturbations", ",", "complement", ")", ":", "\n", "        ", "\"\"\"Selects the top (n_perturbations) number of flips using degree centrality score of the edges.\n\n        :param adj: sp.spmatrix\n            The graph represented as a sparse scipy matrix\n        :param candidates: np.ndarray, shape [?, 2]\n            Candidate set of edge flips\n        :param n_perturbations: int\n            Number of flips to select\n        :param complement: bool\n            Whether to look at the complement graph\n        :return: np.ndarray, shape [?, 2]\n            The top edge flips from the candidate set\n        \"\"\"", "\n", "if", "complement", ":", "\n", "            ", "adj", "=", "sp", ".", "csr_matrix", "(", "1", "-", "adj", ".", "toarray", "(", ")", ")", "\n", "", "deg", "=", "adj", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg_argsort", "=", "(", "deg", "[", "candidates", "[", ":", ",", "0", "]", "]", "+", "deg", "[", "candidates", "[", ":", ",", "1", "]", "]", ")", ".", "argsort", "(", ")", "\n", "\n", "return", "candidates", "[", "deg_argsort", "[", "-", "n_perturbations", ":", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.estimate_loss_with_delta_eigenvals": [[203, 237], ["numba.jit", "numpy.zeros", "range", "len", "len", "node_embedding_attack.sum_of_powers", "numpy.sqrt", "numpy.sum", "numpy.sort"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.sum_of_powers"], ["", "", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "estimate_loss_with_delta_eigenvals", "(", "candidates", ",", "flip_indicator", ",", "vals_org", ",", "vecs_org", ",", "n_nodes", ",", "dim", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"Computes the estimated loss using the change in the eigenvalues for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips,\n    :param flip_indicator: np.ndarray, shape [?]\n        Vector indicating whether we are adding an edge (+1) or removing an edge (-1)\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :param n_nodes: int\n        Number of nodes\n    :param dim: int\n        Embedding dimension\n    :param window_size: int\n        Size of the window\n    :return: np.ndarray, shape [?]\n        Estimated loss for each candidate flip\n    \"\"\"", "\n", "\n", "loss_est", "=", "np", ".", "zeros", "(", "len", "(", "candidates", ")", ")", "\n", "for", "x", "in", "range", "(", "len", "(", "candidates", ")", ")", ":", "\n", "        ", "i", ",", "j", "=", "candidates", "[", "x", "]", "\n", "vals_est", "=", "vals_org", "+", "flip_indicator", "[", "x", "]", "*", "(", "\n", "2", "*", "vecs_org", "[", "i", "]", "*", "vecs_org", "[", "j", "]", "-", "vals_org", "*", "(", "vecs_org", "[", "i", "]", "**", "2", "+", "vecs_org", "[", "j", "]", "**", "2", ")", ")", "\n", "\n", "vals_sum_powers", "=", "sum_of_powers", "(", "vals_est", ",", "window_size", ")", "\n", "\n", "loss_ij", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "sort", "(", "vals_sum_powers", "**", "2", ")", "[", ":", "n_nodes", "-", "dim", "]", ")", ")", "\n", "loss_est", "[", "x", "]", "=", "loss_ij", "\n", "\n", "", "return", "loss_est", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.estimate_delta_eigenvecs": [[239, 277], ["numba.jit", "len", "numpy.zeros", "range", "range", "numpy.dot"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "estimate_delta_eigenvecs", "(", "candidates", ",", "flip_indicator", ",", "degrees", ",", "vals_org", ",", "vecs_org", ",", "delta_eigvals", ",", "pinvs", ")", ":", "\n", "    ", "\"\"\"Computes the estimated change in the eigenvectors for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips,\n    :param flip_indicator: np.ndarray, shape [?]\n        Vector indicating whether we are adding an edge (+1) or removing an edge (-1)\n    :param degrees: np.ndarray, shape [n]\n        Vector of node degrees.\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :param delta_eigvals: np.ndarray, shape [?, n]\n        Estimated change in the eigenvalues for all candidate edge flips\n    :param pinvs: np.ndarray, shape [k, n, n]\n        Precomputed pseudo-inverse matrices for every dimension\n    :return: np.ndarray, shape [?, n, k]\n        Estimated change in the eigenvectors for all candidate edge flips\n    \"\"\"", "\n", "n_nodes", ",", "dim", "=", "vecs_org", ".", "shape", "\n", "n_candidates", "=", "len", "(", "candidates", ")", "\n", "delta_eigvecs", "=", "np", ".", "zeros", "(", "(", "n_candidates", ",", "dim", ",", "n_nodes", ")", ")", "\n", "\n", "for", "k", "in", "range", "(", "dim", ")", ":", "\n", "        ", "cur_eigvecs", "=", "vecs_org", "[", ":", ",", "k", "]", "\n", "cur_eigvals", "=", "vals_org", "[", "k", "]", "\n", "for", "c", "in", "range", "(", "n_candidates", ")", ":", "\n", "            ", "degree_eigvec", "=", "(", "-", "delta_eigvals", "[", "c", ",", "k", "]", "*", "degrees", ")", "*", "cur_eigvecs", "\n", "i", ",", "j", "=", "candidates", "[", "c", "]", "\n", "\n", "degree_eigvec", "[", "i", "]", "+=", "cur_eigvecs", "[", "j", "]", "-", "cur_eigvals", "*", "cur_eigvecs", "[", "i", "]", "\n", "degree_eigvec", "[", "j", "]", "+=", "cur_eigvecs", "[", "i", "]", "-", "cur_eigvals", "*", "cur_eigvecs", "[", "j", "]", "\n", "\n", "delta_eigvecs", "[", "c", ",", "k", "]", "=", "np", ".", "dot", "(", "pinvs", "[", "k", "]", ",", "flip_indicator", "[", "c", "]", "*", "degree_eigvec", ")", "\n", "\n", "", "", "return", "delta_eigvecs", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.estimate_delta_eigvals": [[279, 301], ["None"], "function", ["None"], ["", "def", "estimate_delta_eigvals", "(", "candidates", ",", "adj", ",", "vals_org", ",", "vecs_org", ")", ":", "\n", "    ", "\"\"\"Computes the estimated change in the eigenvalues for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param adj: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :return: np.ndarray, shape [?, n]\n        Estimated change in the eigenvalues for all candidate edge flips\n    \"\"\"", "\n", "# vector indicating whether we are adding an edge (+1) or removing an edge (-1)", "\n", "delta_w", "=", "1", "-", "2", "*", "adj", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "delta_eigvals", "=", "delta_w", "[", ":", ",", "None", "]", "*", "(", "2", "*", "vecs_org", "[", "candidates", "[", ":", ",", "0", "]", "]", "*", "vecs_org", "[", "candidates", "[", ":", ",", "1", "]", "]", "\n", "-", "vals_org", "*", "(", "\n", "vecs_org", "[", "candidates", "[", ":", ",", "0", "]", "]", "**", "2", "+", "vecs_org", "[", "candidates", "[", ":", ",", "1", "]", "]", "**", "2", ")", ")", "\n", "\n", "return", "delta_eigvals", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.sum_of_powers": [[443, 461], ["numba.jit", "numpy.zeros", "enumerate", "np.zeros.sum", "range", "numpy.power"], "function", ["None"], ["", "", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "sum_of_powers", "(", "x", ",", "power", ")", ":", "\n", "    ", "\"\"\"For each x_i, computes \\sum_{r=1}^{pow) x_i^r (elementwise sum of powers).\n\n    :param x: shape [?]\n        Any vector\n    :param pow: int\n        The largest power to consider\n    :return: shape [?]\n        Vector where each element is the sum of powers from 1 to pow.\n    \"\"\"", "\n", "n", "=", "x", ".", "shape", "[", "0", "]", "\n", "sum_powers", "=", "np", ".", "zeros", "(", "(", "power", ",", "n", ")", ")", "\n", "\n", "for", "i", ",", "i_power", "in", "enumerate", "(", "range", "(", "1", ",", "power", "+", "1", ")", ")", ":", "\n", "        ", "sum_powers", "[", "i", "]", "=", "np", ".", "power", "(", "x", ",", "i_power", ")", "\n", "\n", "", "return", "sum_powers", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.edges_to_sparse": [[463, 468], ["scipy.coo_matrix().tocsr", "numpy.ones", "scipy.coo_matrix"], "function", ["None"], ["", "def", "edges_to_sparse", "(", "edges", ",", "num_nodes", ",", "weights", "=", "None", ")", ":", "\n", "    ", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "np", ".", "ones", "(", "edges", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "return", "sp", ".", "coo_matrix", "(", "(", "weights", ",", "(", "edges", "[", ":", ",", "0", "]", ",", "edges", "[", ":", ",", "1", "]", ")", ")", ",", "shape", "=", "(", "num_nodes", ",", "num_nodes", ")", ")", ".", "tocsr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.node_embedding_attack.construct_line_graph": [[469, 492], ["numpy.column_stack", "scipy.eye().tocsr", "scipy.triu().nonzero", "E2.dot", "scipy.eye", "E2.dot", "scipy.eye", "scipy.triu", "E1.dot", "E1.dot"], "function", ["None"], ["", "def", "construct_line_graph", "(", "adj", ")", ":", "\n", "    ", "\"\"\"Construct a line graph from an undirected original graph.\n\n    Parameters\n    ----------\n    adj : sp.spmatrix [n_samples ,n_samples]\n        Symmetric binary adjacency matrix.\n    Returns\n    -------\n    L : sp.spmatrix, shape [A.nnz/2, A.nnz/2]\n        Symmetric binary adjacency matrix of the line graph.\n    \"\"\"", "\n", "N", "=", "adj", ".", "shape", "[", "0", "]", "\n", "edges", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "e1", ",", "e2", "=", "edges", "[", ":", ",", "0", "]", ",", "edges", "[", ":", ",", "1", "]", "\n", "\n", "I", "=", "sp", ".", "eye", "(", "N", ")", ".", "tocsr", "(", ")", "\n", "E1", "=", "I", "[", "e1", "]", "\n", "E2", "=", "I", "[", "e2", "]", "\n", "\n", "L", "=", "E1", ".", "dot", "(", "E1", ".", "T", ")", "+", "E1", ".", "dot", "(", "E2", ".", "T", ")", "+", "E2", ".", "dot", "(", "E1", ".", "T", ")", "+", "E2", ".", "dot", "(", "E2", ".", "T", ")", "\n", "\n", "return", "L", "-", "2", "*", "sp", ".", "eye", "(", "L", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.__init__": [[59, 114], ["torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "numpy.array", "len", "deeprobust.graph.rl.nstep_replay_mem.NstepReplayMem", "deeprobust.graph.rl.nipa_q_net_node.NStepQNetNode", "deeprobust.graph.rl.nipa_q_net_node.NStepQNetNode", "nipa.NIPA.net.to", "nipa.NIPA.old_net.to", "nipa.NIPA.take_snapshot", "len", "int", "numpy.arange", "os.exists", "os.exists", "os.system", "os.system", "os.system", "os.system", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "len", "list_action_space.items", "labels.max"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.take_snapshot"], ["def", "__init__", "(", "self", ",", "env", ",", "features", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "idx_test", ",", "\n", "list_action_space", ",", "ratio", ",", "reward_type", "=", "'binary'", ",", "batch_size", "=", "30", ",", "\n", "num_wrong", "=", "0", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "gm", "=", "'mean_field'", ",", "\n", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "save_dir", "=", "'checkpoint_dqn'", ",", "device", "=", "None", ")", ":", "\n", "\n", "        ", "assert", "device", "is", "not", "None", ",", "\"'device' cannot be None, please specify it\"", "\n", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "possible_labels", "=", "torch", ".", "arange", "(", "labels", ".", "max", "(", ")", "+", "1", ")", ".", "to", "(", "labels", ".", "device", ")", "\n", "self", ".", "idx_train", "=", "idx_train", "\n", "self", ".", "idx_val", "=", "idx_val", "\n", "self", ".", "idx_test", "=", "idx_test", "\n", "self", ".", "num_wrong", "=", "num_wrong", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "\n", "degrees", "=", "np", ".", "array", "(", "[", "len", "(", "d", ")", "for", "n", ",", "d", "in", "list_action_space", ".", "items", "(", ")", "]", ")", "\n", "N", "=", "len", "(", "degrees", "[", "degrees", ">", "0", "]", ")", "\n", "self", ".", "n_injected", "=", "len", "(", "degrees", ")", "-", "N", "\n", "assert", "self", ".", "n_injected", "==", "int", "(", "ratio", "*", "N", ")", "\n", "self", ".", "injected_nodes", "=", "np", ".", "arange", "(", "N", ")", "[", "-", "self", ".", "n_injected", ":", "]", "\n", "\n", "self", ".", "reward_type", "=", "reward_type", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "if", "not", "osp", ".", "exists", "(", "save_dir", ")", ":", "\n", "            ", "os", ".", "system", "(", "'mkdir -p %s'", "%", "save_dir", ")", "\n", "\n", "", "self", ".", "gm", "=", "gm", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "mem_pool", "=", "NstepReplayMem", "(", "memory_size", "=", "500000", ",", "n_steps", "=", "3", ",", "balance_sample", "=", "reward_type", "==", "'binary'", ",", "model", "=", "'nipa'", ")", "\n", "self", ".", "env", "=", "env", "\n", "\n", "self", ".", "net", "=", "NStepQNetNode", "(", "3", ",", "features", ",", "labels", ",", "list_action_space", ",", "self", ".", "n_injected", ",", "\n", "bilin_q", "=", "bilin_q", ",", "embed_dim", "=", "embed_dim", ",", "mlp_hidden", "=", "mlp_hidden", ",", "\n", "max_lv", "=", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", "\n", "\n", "self", ".", "old_net", "=", "NStepQNetNode", "(", "3", ",", "features", ",", "labels", ",", "list_action_space", ",", "self", ".", "n_injected", ",", "\n", "bilin_q", "=", "bilin_q", ",", "embed_dim", "=", "embed_dim", ",", "mlp_hidden", "=", "mlp_hidden", ",", "\n", "max_lv", "=", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", "\n", "\n", "self", ".", "net", "=", "self", ".", "net", ".", "to", "(", "device", ")", "\n", "self", ".", "old_net", "=", "self", ".", "old_net", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "eps_start", "=", "1.0", "\n", "self", ".", "eps_end", "=", "0.05", "\n", "# self.eps_step = 100000", "\n", "self", ".", "eps_step", "=", "30000", "\n", "self", ".", "GAMMA", "=", "0.9", "\n", "self", ".", "burn_in", "=", "50", "\n", "self", ".", "step", "=", "0", "\n", "self", ".", "pos", "=", "0", "\n", "self", ".", "best_eval", "=", "None", "\n", "self", ".", "take_snapshot", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.take_snapshot": [[115, 117], ["nipa.NIPA.old_net.load_state_dict", "nipa.NIPA.net.state_dict"], "methods", ["None"], ["", "def", "take_snapshot", "(", "self", ")", ":", "\n", "        ", "self", ".", "old_net", ".", "load_state_dict", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.make_actions": [[118, 138], ["max", "nipa.NIPA.env.uniformRandActions", "nipa.NIPA.env.getStateRef", "nipa.NIPA.possible_actions", "nipa.NIPA.net", "random.random", "len", "len", "max"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.uniformRandActions", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.getStateRef", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.possible_actions"], ["", "def", "make_actions", "(", "self", ",", "time_t", ",", "greedy", "=", "False", ")", ":", "\n", "# TODO", "\n", "        ", "self", ".", "eps", "=", "self", ".", "eps_end", "+", "max", "(", "0.", ",", "(", "self", ".", "eps_start", "-", "self", ".", "eps_end", ")", "\n", "*", "(", "self", ".", "eps_step", "-", "max", "(", "0.", ",", "self", ".", "step", ")", ")", "/", "self", ".", "eps_step", ")", "\n", "\n", "self", ".", "step", "+=", "1", "\n", "if", "random", ".", "random", "(", ")", "<", "self", ".", "eps", "and", "not", "greedy", ":", "\n", "            ", "actions", "=", "self", ".", "env", ".", "uniformRandActions", "(", ")", "\n", "", "else", ":", "\n", "\n", "            ", "cur_state", "=", "self", ".", "env", ".", "getStateRef", "(", ")", "\n", "# list_at = self.env.uniformRandActions()", "\n", "list_at", "=", "self", ".", "env", ".", "first_nodes", "if", "time_t", "==", "1", "else", "None", "\n", "\n", "actions", "=", "self", ".", "possible_actions", "(", "cur_state", ",", "list_at", ",", "time_t", ")", "\n", "actions", ",", "values", "=", "self", ".", "net", "(", "time_t", ",", "cur_state", ",", "actions", ",", "greedy_acts", "=", "True", ",", "is_inference", "=", "True", ")", "\n", "\n", "assert", "len", "(", "actions", ")", "==", "len", "(", "cur_state", ")", "\n", "# actions = list(actions.cpu().numpy())", "\n", "", "return", "actions", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.run_simulation": [[139, 164], ["nipa.NIPA.env.setup", "nipa.NIPA.env.isActionFinished", "nipa.NIPA.make_actions", "nipa.NIPA.env.cloneState", "nipa.NIPA.env.step", "nipa.NIPA.env.isActionFinished", "nipa.NIPA.env.isTerminal", "nipa.NIPA.mem_pool.add_list", "nipa.NIPA.env.isActionFinished", "nipa.NIPA.env.cloneState", "numpy.zeros", "nipa.NIPA.env.cloneState", "len", "len", "nipa.NIPA.env.isTerminal"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.make_actions", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add_list", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal"], ["", "def", "run_simulation", "(", "self", ")", ":", "\n", "        ", "self", ".", "env", ".", "setup", "(", ")", "\n", "t", "=", "0", "\n", "while", "not", "self", ".", "env", ".", "isActionFinished", "(", ")", ":", "\n", "            ", "list_at", "=", "self", ".", "make_actions", "(", "t", ")", "\n", "list_st", "=", "self", ".", "env", ".", "cloneState", "(", ")", "\n", "\n", "self", ".", "env", ".", "step", "(", "list_at", ")", "\n", "\n", "assert", "(", "self", ".", "env", ".", "rewards", "is", "not", "None", ")", "==", "self", ".", "env", ".", "isActionFinished", "(", ")", "\n", "if", "self", ".", "env", ".", "isActionFinished", "(", ")", ":", "\n", "                ", "rewards", "=", "self", ".", "env", ".", "rewards", "\n", "s_prime", "=", "self", ".", "env", ".", "cloneState", "(", ")", "\n", "", "else", ":", "\n", "                ", "rewards", "=", "np", ".", "zeros", "(", "len", "(", "list_at", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "s_prime", "=", "self", ".", "env", ".", "cloneState", "(", ")", "\n", "\n", "", "if", "self", ".", "env", ".", "isTerminal", "(", ")", ":", "\n", "                ", "rewards", "=", "self", ".", "env", ".", "rewards", "\n", "s_prime", "=", "None", "\n", "# self.env.init_overall_steps()", "\n", "\n", "", "self", ".", "mem_pool", ".", "add_list", "(", "list_st", ",", "list_at", ",", "rewards", ",", "s_prime", ",", "\n", "[", "self", ".", "env", ".", "isTerminal", "(", ")", "]", "*", "len", "(", "list_at", ")", ",", "t", ")", "\n", "t", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.eval": [[165, 204], ["nipa.NIPA.env.init_overall_steps", "nipa.NIPA.env.setup", "itertools.count", "nipa.NIPA.env.modified_list[].get_extra_adj", "nipa.NIPA.env.classifier.norm_tool.norm_extra", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "nipa.NIPA.env.classifier.fit", "nipa.NIPA.env.classifier", "deeprobust.graph.utils.loss_acc", "print", "nipa.NIPA.env.setup", "nipa.NIPA.env.isTerminal", "print", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "nipa.NIPA.env.isActionFinished", "nipa.NIPA.make_actions", "nipa.NIPA.env.step", "nipa.NIPA.net.state_dict", "os.join", "os.join", "open", "f.write", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.init_overall_steps", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.loss_acc", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.make_actions", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "def", "eval", "(", "self", ",", "training", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate RL agent.\n        \"\"\"", "\n", "self", ".", "env", ".", "init_overall_steps", "(", ")", "\n", "self", ".", "env", ".", "setup", "(", ")", "\n", "\n", "for", "_", "in", "count", "(", ")", ":", "\n", "            ", "self", ".", "env", ".", "setup", "(", ")", "\n", "t", "=", "0", "\n", "while", "not", "self", ".", "env", ".", "isActionFinished", "(", ")", ":", "\n", "                ", "list_at", "=", "self", ".", "make_actions", "(", "t", ",", "greedy", "=", "True", ")", "\n", "# print(list_at)", "\n", "self", ".", "env", ".", "step", "(", "list_at", ",", "inference", "=", "True", ")", "\n", "t", "+=", "1", "\n", "", "if", "self", ".", "env", ".", "isTerminal", "(", ")", ":", "\n", "                ", "break", "\n", "\n", "", "", "device", "=", "self", ".", "labels", ".", "device", "\n", "extra_adj", "=", "self", ".", "env", ".", "modified_list", "[", "0", "]", ".", "get_extra_adj", "(", "device", "=", "device", ")", "\n", "adj", "=", "self", ".", "env", ".", "classifier", ".", "norm_tool", ".", "norm_extra", "(", "extra_adj", ")", "\n", "labels", "=", "torch", ".", "cat", "(", "(", "self", ".", "labels", ",", "self", ".", "env", ".", "modified_label_list", "[", "0", "]", ")", ")", "\n", "\n", "self", ".", "env", ".", "classifier", ".", "fit", "(", "self", ".", "features", ",", "adj", ",", "labels", ",", "self", ".", "idx_train", ",", "self", ".", "idx_val", ",", "normalize", "=", "False", ",", "patience", "=", "50", ")", "\n", "output", "=", "self", ".", "env", ".", "classifier", "(", "self", ".", "features", ",", "adj", ")", "\n", "loss", ",", "acc", "=", "loss_acc", "(", "output", ",", "self", ".", "labels", ",", "self", ".", "idx_test", ")", "\n", "print", "(", "'\\033[93m average test: acc %.5f\\033[0m'", "%", "(", "acc", ")", ")", "\n", "\n", "if", "training", "==", "True", "and", "self", ".", "best_eval", "is", "None", "or", "acc", "<", "self", ".", "best_eval", ":", "\n", "            ", "print", "(", "'----saving to best attacker since this is the best attack rate so far.----'", ")", "\n", "torch", ".", "save", "(", "self", ".", "net", ".", "state_dict", "(", ")", ",", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "'epoch-best.model'", ")", ")", "\n", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "'epoch-best.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "'%.4f\\n'", "%", "acc", ")", "\n", "# with open(osp.join(self.save_dir, 'attack_solution.txt'), 'w') as f:", "\n", "#     for i in range(len(self.idx_meta)):", "\n", "#         f.write('%d: [' % self.idx_meta[i])", "\n", "#         for e in self.env.modified_list[i].directed_edges:", "\n", "#             f.write('(%d %d)' % e)", "\n", "#         f.write('] succ: %d\\n' % (self.env.binary_rewards[i]))", "\n", "", "self", ".", "best_eval", "=", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.train": [[205, 257], ["torch.Adam", "torch.Adam", "torch.Adam", "nipa.NIPA.env.init_overall_steps", "tqdm.tqdm.tqdm", "nipa.NIPA.mem_pool.print_count", "tqdm.tqdm.tqdm", "nipa.NIPA.net.parameters", "range", "nipa.NIPA.run_simulation", "range", "nipa.NIPA.env.init_overall_steps", "itertools.count", "nipa.NIPA.run_simulation", "nipa.NIPA.mem_pool.sample", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "nipa.NIPA.net", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.Adam.zero_grad", "torch.clamp.backward", "torch.clamp.backward", "torch.clamp.backward", "torch.Adam.step", "nipa.NIPA.env.isTerminal", "nipa.NIPA.take_snapshot", "nipa.NIPA.eval", "nipa.NIPA.possible_actions", "nipa.NIPA.old_net", "print", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.init_overall_steps", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.print_count", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.run_simulation", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.init_overall_steps", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.run_simulation", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.take_snapshot", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.possible_actions"], ["", "", "def", "train", "(", "self", ",", "num_episodes", "=", "10", ",", "lr", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"Train RL agent.\n        \"\"\"", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "self", ".", "env", ".", "init_overall_steps", "(", ")", "\n", "pbar", "=", "tqdm", "(", "range", "(", "self", ".", "burn_in", ")", ",", "unit", "=", "'batch'", ")", "\n", "for", "p", "in", "pbar", ":", "\n", "            ", "self", ".", "run_simulation", "(", ")", "\n", "", "self", ".", "mem_pool", ".", "print_count", "(", ")", "\n", "\n", "for", "i_episode", "in", "tqdm", "(", "range", "(", "num_episodes", ")", ")", ":", "\n", "            ", "self", ".", "env", ".", "init_overall_steps", "(", ")", "\n", "\n", "for", "t", "in", "count", "(", ")", ":", "\n", "                ", "self", ".", "run_simulation", "(", ")", "\n", "\n", "cur_time", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "=", "self", ".", "mem_pool", ".", "sample", "(", "batch_size", "=", "self", ".", "batch_size", ")", "\n", "list_target", "=", "torch", ".", "Tensor", "(", "list_rt", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "not", "list_term", "[", "0", "]", ":", "\n", "                    ", "actions", "=", "self", ".", "possible_actions", "(", "list_st", ",", "list_at", ",", "cur_time", "+", "1", ")", "\n", "_", ",", "q_rhs", "=", "self", ".", "old_net", "(", "cur_time", "+", "1", ",", "list_s_primes", ",", "actions", ",", "greedy_acts", "=", "True", ")", "\n", "list_target", "+=", "self", ".", "GAMMA", "*", "q_rhs", "\n", "\n", "# list_target = list_target.view(-1, 1)", "\n", "", "_", ",", "q_sa", "=", "self", ".", "net", "(", "cur_time", ",", "list_st", ",", "list_at", ")", "\n", "loss", "=", "F", ".", "mse_loss", "(", "q_sa", ",", "list_target", ")", "\n", "loss", "=", "torch", ".", "clamp", "(", "loss", ",", "-", "1", ",", "1", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "# print([x[0] for x in self.nnamed_parameters() if x[1].grad is None])", "\n", "# for param in self.net.parameters():", "\n", "#     if param.grad is None:", "\n", "#         continue", "\n", "#     param.grad.data.clamp_(-1, 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# pbar.set_description('eps: %.5f, loss: %0.5f, q_val: %.5f' % (self.eps, loss, torch.mean(q_sa)) )", "\n", "if", "t", "%", "20", "==", "0", ":", "\n", "                    ", "print", "(", "'eps: %.5f, loss: %0.5f, q_val: %.5f, list_target: %.5f'", "%", "(", "self", ".", "eps", ",", "loss", ",", "torch", ".", "mean", "(", "q_sa", ")", ",", "torch", ".", "mean", "(", "list_target", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "env", ".", "isTerminal", "(", ")", ":", "\n", "                    ", "break", "\n", "\n", "# if (t+1) % 50 == 0:", "\n", "#     self.take_snapshot()", "\n", "\n", "", "", "if", "i_episode", "%", "1", "==", "0", ":", "\n", "                ", "self", ".", "take_snapshot", "(", ")", "\n", "\n", "", "if", "i_episode", "%", "1", "==", "0", ":", "\n", "                ", "self", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.nipa.NIPA.possible_actions": [[258, 286], ["numpy.tile", "range", "nipa.NIPA.possible_labels.repeat", "len", "[].get_possible_nodes", "actions.append", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_possible_nodes"], ["", "", "", "def", "possible_actions", "(", "self", ",", "list_st", ",", "list_at", ",", "t", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        list_st:\n            current state\n        list_at:\n            current action\n\n        Returns\n        -------\n        list\n            actions for next state\n        \"\"\"", "\n", "\n", "t", "=", "t", "%", "3", "\n", "if", "t", "==", "0", ":", "\n", "            ", "return", "np", ".", "tile", "(", "self", ".", "injected_nodes", ",", "(", "(", "len", "(", "list_st", ")", ",", "1", ")", ")", ")", "\n", "\n", "", "if", "t", "==", "1", ":", "\n", "            ", "actions", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "list_at", ")", ")", ":", "\n", "                ", "a_prime", "=", "list_st", "[", "i", "]", "[", "0", "]", ".", "get_possible_nodes", "(", "list_at", "[", "i", "]", ")", "\n", "actions", ".", "append", "(", "a_prime", ")", "\n", "", "return", "actions", "\n", "\n", "", "if", "t", "==", "2", ":", "\n", "            ", "return", "self", ".", "possible_labels", ".", "repeat", "(", "(", "len", "(", "list_st", ")", ",", "1", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.__init__": [[44, 65], ["deeprobust.graph.global_attack.BaseAttack.__init__", "torch.nn.parameter.Parameter", "mettack.BaseMeta.adj_changes.data.fill_", "torch.nn.parameter.Parameter", "mettack.BaseMeta.feature_changes.data.fill_", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "feature_shape", "=", "None", ",", "lambda_", "=", "0.5", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "BaseMeta", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "self", ".", "lambda_", "=", "lambda_", "\n", "\n", "assert", "attack_features", "or", "attack_structure", ",", "'attack_features or attack_structure cannot be both False'", "\n", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "\n", "if", "attack_structure", ":", "\n", "            ", "assert", "nnodes", "is", "not", "None", ",", "'Please give nnodes='", "\n", "self", ".", "adj_changes", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nnodes", ",", "nnodes", ")", ")", "\n", "self", ".", "adj_changes", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "", "if", "attack_features", ":", "\n", "            ", "assert", "feature_shape", "is", "not", "None", ",", "'Please give feature_shape='", "\n", "self", ".", "feature_changes", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "feature_shape", ")", ")", "\n", "self", ".", "feature_changes", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "", "self", ".", "with_relu", "=", "model", ".", "with_relu", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.attack": [[66, 68], ["None"], "methods", ["None"], ["", "def", "attack", "(", "self", ",", "adj", ",", "labels", ",", "n_perturbations", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_modified_adj": [[69, 75], ["numpy.diag_indices", "torch.clamp", "torch.diag", "torch.diag", "torch.transpose"], "methods", ["None"], ["", "def", "get_modified_adj", "(", "self", ",", "ori_adj", ")", ":", "\n", "        ", "adj_changes_square", "=", "self", ".", "adj_changes", "-", "torch", ".", "diag", "(", "torch", ".", "diag", "(", "self", ".", "adj_changes", ",", "0", ")", ")", "\n", "ind", "=", "np", ".", "diag_indices", "(", "self", ".", "adj_changes", ".", "shape", "[", "0", "]", ")", "\n", "adj_changes_symm", "=", "torch", ".", "clamp", "(", "adj_changes_square", "+", "torch", ".", "transpose", "(", "adj_changes_square", ",", "1", ",", "0", ")", ",", "-", "1", ",", "1", ")", "\n", "modified_adj", "=", "adj_changes_symm", "+", "ori_adj", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_modified_features": [[76, 78], ["None"], "methods", ["None"], ["", "def", "get_modified_features", "(", "self", ",", "ori_features", ")", ":", "\n", "        ", "return", "ori_features", "+", "self", ".", "feature_changes", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.filter_potential_singletons": [[79, 92], ["modified_adj.sum", "degree_one.repeat().float", "l_and.t", "degree_one.repeat"], "methods", ["None"], ["", "def", "filter_potential_singletons", "(", "self", ",", "modified_adj", ")", ":", "\n", "        ", "\"\"\"\n        Computes a mask for entries potentially leading to singleton nodes, i.e. one of the two nodes corresponding to\n        the entry have degree 1 and there is an edge between the two nodes.\n        \"\"\"", "\n", "\n", "degrees", "=", "modified_adj", ".", "sum", "(", "0", ")", "\n", "degree_one", "=", "(", "degrees", "==", "1", ")", "\n", "resh", "=", "degree_one", ".", "repeat", "(", "modified_adj", ".", "shape", "[", "0", "]", ",", "1", ")", ".", "float", "(", ")", "\n", "l_and", "=", "resh", "*", "modified_adj", "\n", "logical_and_symmetric", "=", "l_and", "+", "l_and", ".", "t", "(", ")", "\n", "flat_mask", "=", "1", "-", "logical_and_symmetric", "\n", "return", "flat_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.self_training_label": [[93, 99], ["output.argmax"], "methods", ["None"], ["", "def", "self_training_label", "(", "self", ",", "labels", ",", "idx_train", ")", ":", "\n", "# Predict the labels of the unlabeled nodes to use them for self-training.", "\n", "        ", "output", "=", "self", ".", "surrogate", ".", "output", "\n", "labels_self_training", "=", "output", ".", "argmax", "(", "1", ")", "\n", "labels_self_training", "[", "idx_train", "]", "=", "labels", "[", "idx_train", "]", "\n", "return", "labels_self_training", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.log_likelihood_constraint": [[101, 115], ["torch.tensor().to", "deeprobust.graph.utils.likelihood_ratio_filter", "numpy.array", "torch.tensor", "numpy.triu().nonzero", "numpy.triu", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.likelihood_ratio_filter"], ["", "def", "log_likelihood_constraint", "(", "self", ",", "modified_adj", ",", "ori_adj", ",", "ll_cutoff", ")", ":", "\n", "        ", "\"\"\"\n        Computes a mask for entries that, if the edge corresponding to the entry is added/removed, would lead to the\n        log likelihood constraint to be violated.\n\n        Note that different data type (float, double) can effect the final results.\n        \"\"\"", "\n", "t_d_min", "=", "torch", ".", "tensor", "(", "2.0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "t_possible_edges", "=", "np", ".", "array", "(", "np", ".", "triu", "(", "np", ".", "ones", "(", "(", "self", ".", "nnodes", ",", "self", ".", "nnodes", ")", ")", ",", "k", "=", "1", ")", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "allowed_mask", ",", "current_ratio", "=", "utils", ".", "likelihood_ratio_filter", "(", "t_possible_edges", ",", "\n", "modified_adj", ",", "\n", "ori_adj", ",", "t_d_min", ",", "\n", "ll_cutoff", ")", "\n", "return", "allowed_mask", ",", "current_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_adj_score": [[116, 131], ["adj_meta_grad.min", "torch.diag", "mettack.BaseMeta.filter_potential_singletons", "torch.diag", "mettack.BaseMeta.log_likelihood_constraint", "allowed_mask.to.to.to"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.filter_potential_singletons", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.log_likelihood_constraint", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "get_adj_score", "(", "self", ",", "adj_grad", ",", "modified_adj", ",", "ori_adj", ",", "ll_constraint", ",", "ll_cutoff", ")", ":", "\n", "        ", "adj_meta_grad", "=", "adj_grad", "*", "(", "-", "2", "*", "modified_adj", "+", "1", ")", "\n", "# Make sure that the minimum entry is 0.", "\n", "adj_meta_grad", "-=", "adj_meta_grad", ".", "min", "(", ")", "\n", "# Filter self-loops", "\n", "adj_meta_grad", "-=", "torch", ".", "diag", "(", "torch", ".", "diag", "(", "adj_meta_grad", ",", "0", ")", ")", "\n", "# # Set entries to 0 that could lead to singleton nodes.", "\n", "singleton_mask", "=", "self", ".", "filter_potential_singletons", "(", "modified_adj", ")", "\n", "adj_meta_grad", "=", "adj_meta_grad", "*", "singleton_mask", "\n", "\n", "if", "ll_constraint", ":", "\n", "            ", "allowed_mask", ",", "self", ".", "ll_ratio", "=", "self", ".", "log_likelihood_constraint", "(", "modified_adj", ",", "ori_adj", ",", "ll_cutoff", ")", "\n", "allowed_mask", "=", "allowed_mask", ".", "to", "(", "self", ".", "device", ")", "\n", "adj_meta_grad", "=", "adj_meta_grad", "*", "allowed_mask", "\n", "", "return", "adj_meta_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_feature_score": [[132, 136], ["feature_meta_grad.min"], "methods", ["None"], ["", "def", "get_feature_score", "(", "self", ",", "feature_grad", ",", "modified_features", ")", ":", "\n", "        ", "feature_meta_grad", "=", "feature_grad", "*", "(", "-", "2", "*", "modified_features", "+", "1", ")", "\n", "feature_meta_grad", "-=", "feature_meta_grad", ".", "min", "(", ")", "\n", "return", "feature_meta_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack.__init__": [[167, 211], ["mettack.BaseMeta.__init__", "enumerate", "torch.nn.parameter.Parameter", "torch.zeros().to", "mettack.Metattack.weights.append", "mettack.Metattack.w_velocities.append", "mettack.Metattack._initialize", "torch.nn.parameter.Parameter", "torch.zeros().to", "mettack.Metattack.weights.append", "mettack.Metattack.w_velocities.append", "torch.FloatTensor().to", "torch.nn.parameter.Parameter", "torch.zeros().to", "mettack.Metattack.biases.append", "mettack.Metattack.b_velocities.append", "torch.FloatTensor().to", "torch.nn.parameter.Parameter", "torch.zeros().to", "mettack.Metattack.biases.append", "mettack.Metattack.b_velocities.append", "torch.zeros", "torch.FloatTensor().to", "torch.zeros", "torch.FloatTensor().to", "torch.FloatTensor", "torch.zeros", "torch.FloatTensor", "torch.zeros", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ",", "with_bias", "=", "False", ",", "lambda_", "=", "0.5", ",", "train_iters", "=", "100", ",", "lr", "=", "0.1", ",", "momentum", "=", "0.9", ")", ":", "\n", "\n", "        ", "super", "(", "Metattack", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "feature_shape", ",", "lambda_", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "train_iters", "=", "train_iters", "\n", "self", ".", "with_bias", "=", "with_bias", "\n", "\n", "self", ".", "weights", "=", "[", "]", "\n", "self", ".", "biases", "=", "[", "]", "\n", "self", ".", "w_velocities", "=", "[", "]", "\n", "self", ".", "b_velocities", "=", "[", "]", "\n", "\n", "self", ".", "hidden_sizes", "=", "self", ".", "surrogate", ".", "hidden_sizes", "\n", "self", ".", "nfeat", "=", "self", ".", "surrogate", ".", "nfeat", "\n", "self", ".", "nclass", "=", "self", ".", "surrogate", ".", "nclass", "\n", "\n", "previous_size", "=", "self", ".", "nfeat", "\n", "for", "ix", ",", "nhid", "in", "enumerate", "(", "self", ".", "hidden_sizes", ")", ":", "\n", "            ", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "previous_size", ",", "nhid", ")", ".", "to", "(", "device", ")", ")", "\n", "w_velocity", "=", "torch", ".", "zeros", "(", "weight", ".", "shape", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "weights", ".", "append", "(", "weight", ")", "\n", "self", ".", "w_velocities", ".", "append", "(", "w_velocity", ")", "\n", "\n", "if", "self", ".", "with_bias", ":", "\n", "                ", "bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nhid", ")", ".", "to", "(", "device", ")", ")", "\n", "b_velocity", "=", "torch", ".", "zeros", "(", "bias", ".", "shape", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "biases", ".", "append", "(", "bias", ")", "\n", "self", ".", "b_velocities", ".", "append", "(", "b_velocity", ")", "\n", "\n", "", "previous_size", "=", "nhid", "\n", "\n", "", "output_weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "previous_size", ",", "self", ".", "nclass", ")", ".", "to", "(", "device", ")", ")", "\n", "output_w_velocity", "=", "torch", ".", "zeros", "(", "output_weight", ".", "shape", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "weights", ".", "append", "(", "output_weight", ")", "\n", "self", ".", "w_velocities", ".", "append", "(", "output_w_velocity", ")", "\n", "\n", "if", "self", ".", "with_bias", ":", "\n", "            ", "output_bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "self", ".", "nclass", ")", ".", "to", "(", "device", ")", ")", "\n", "output_b_velocity", "=", "torch", ".", "zeros", "(", "output_bias", ".", "shape", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "biases", ".", "append", "(", "output_bias", ")", "\n", "self", ".", "b_velocities", ".", "append", "(", "output_b_velocity", ")", "\n", "\n", "", "self", ".", "_initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack._initialize": [[212, 223], ["zip", "w.data.uniform_", "v.data.fill_", "zip", "math.sqrt", "b.data.uniform_", "v.data.fill_", "w.size", "math.sqrt", "w.size"], "methods", ["None"], ["", "def", "_initialize", "(", "self", ")", ":", "\n", "        ", "for", "w", ",", "v", "in", "zip", "(", "self", ".", "weights", ",", "self", ".", "w_velocities", ")", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "w", ".", "size", "(", "1", ")", ")", "\n", "w", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "v", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "", "if", "self", ".", "with_bias", ":", "\n", "            ", "for", "b", ",", "v", "in", "zip", "(", "self", ".", "biases", ",", "self", ".", "b_velocities", ")", ":", "\n", "                ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "w", ".", "size", "(", "1", ")", ")", "\n", "b", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "v", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack.inner_train": [[224, 263], ["mettack.Metattack._initialize", "range", "range", "mettack.Metattack.weights[].detach", "mettack.Metattack.w_velocities[].detach", "enumerate", "torch.nn.functional.log_softmax", "torch.nn.functional.nll_loss", "torch.autograd.grad", "len", "mettack.Metattack.biases[].detach", "mettack.Metattack.b_velocities[].detach", "torch.autograd.grad", "torch.nn.functional.relu", "zip", "zip", "zip", "zip", "torch.spmm", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize"], ["", "", "", "def", "inner_train", "(", "self", ",", "features", ",", "adj_norm", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ")", ":", "\n", "        ", "self", ".", "_initialize", "(", ")", "\n", "\n", "for", "ix", "in", "range", "(", "len", "(", "self", ".", "hidden_sizes", ")", "+", "1", ")", ":", "\n", "            ", "self", ".", "weights", "[", "ix", "]", "=", "self", ".", "weights", "[", "ix", "]", ".", "detach", "(", ")", "\n", "self", ".", "weights", "[", "ix", "]", ".", "requires_grad", "=", "True", "\n", "self", ".", "w_velocities", "[", "ix", "]", "=", "self", ".", "w_velocities", "[", "ix", "]", ".", "detach", "(", ")", "\n", "self", ".", "w_velocities", "[", "ix", "]", ".", "requires_grad", "=", "True", "\n", "\n", "if", "self", ".", "with_bias", ":", "\n", "                ", "self", ".", "biases", "[", "ix", "]", "=", "self", ".", "biases", "[", "ix", "]", ".", "detach", "(", ")", "\n", "self", ".", "biases", "[", "ix", "]", ".", "requires_grad", "=", "True", "\n", "self", ".", "b_velocities", "[", "ix", "]", "=", "self", ".", "b_velocities", "[", "ix", "]", ".", "detach", "(", ")", "\n", "self", ".", "b_velocities", "[", "ix", "]", ".", "requires_grad", "=", "True", "\n", "\n", "", "", "for", "j", "in", "range", "(", "self", ".", "train_iters", ")", ":", "\n", "            ", "hidden", "=", "features", "\n", "for", "ix", ",", "w", "in", "enumerate", "(", "self", ".", "weights", ")", ":", "\n", "                ", "b", "=", "self", ".", "biases", "[", "ix", "]", "if", "self", ".", "with_bias", "else", "0", "\n", "if", "self", ".", "sparse_features", ":", "\n", "                    ", "hidden", "=", "adj_norm", "@", "torch", ".", "spmm", "(", "hidden", ",", "w", ")", "+", "b", "\n", "", "else", ":", "\n", "                    ", "hidden", "=", "adj_norm", "@", "hidden", "@", "w", "+", "b", "\n", "\n", "", "if", "self", ".", "with_relu", "and", "ix", "!=", "len", "(", "self", ".", "weights", ")", "-", "1", ":", "\n", "                    ", "hidden", "=", "F", ".", "relu", "(", "hidden", ")", "\n", "\n", "", "", "output", "=", "F", ".", "log_softmax", "(", "hidden", ",", "dim", "=", "1", ")", "\n", "loss_labeled", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "\n", "weight_grads", "=", "torch", ".", "autograd", ".", "grad", "(", "loss_labeled", ",", "self", ".", "weights", ",", "create_graph", "=", "True", ")", "\n", "self", ".", "w_velocities", "=", "[", "self", ".", "momentum", "*", "v", "+", "g", "for", "v", ",", "g", "in", "zip", "(", "self", ".", "w_velocities", ",", "weight_grads", ")", "]", "\n", "if", "self", ".", "with_bias", ":", "\n", "                ", "bias_grads", "=", "torch", ".", "autograd", ".", "grad", "(", "loss_labeled", ",", "self", ".", "biases", ",", "create_graph", "=", "True", ")", "\n", "self", ".", "b_velocities", "=", "[", "self", ".", "momentum", "*", "v", "+", "g", "for", "v", ",", "g", "in", "zip", "(", "self", ".", "b_velocities", ",", "bias_grads", ")", "]", "\n", "\n", "", "self", ".", "weights", "=", "[", "w", "-", "self", ".", "lr", "*", "v", "for", "w", ",", "v", "in", "zip", "(", "self", ".", "weights", ",", "self", ".", "w_velocities", ")", "]", "\n", "if", "self", ".", "with_bias", ":", "\n", "                ", "self", ".", "biases", "=", "[", "b", "-", "self", ".", "lr", "*", "v", "for", "b", ",", "v", "in", "zip", "(", "self", ".", "biases", ",", "self", ".", "b_velocities", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack.get_meta_grad": [[264, 299], ["enumerate", "torch.nn.functional.log_softmax", "torch.nn.functional.nll_loss", "torch.nn.functional.nll_loss", "torch.nn.functional.nll_loss", "print", "print", "print", "torch.nn.functional.relu", "torch.nn.functional.nll_loss.item", "deeprobust.graph.utils.accuracy().item", "attack_loss.item", "torch.autograd.grad", "torch.autograd.grad", "torch.spmm", "len", "deeprobust.graph.utils.accuracy"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "", "", "def", "get_meta_grad", "(", "self", ",", "features", ",", "adj_norm", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ",", "labels_self_training", ")", ":", "\n", "\n", "        ", "hidden", "=", "features", "\n", "for", "ix", ",", "w", "in", "enumerate", "(", "self", ".", "weights", ")", ":", "\n", "            ", "b", "=", "self", ".", "biases", "[", "ix", "]", "if", "self", ".", "with_bias", "else", "0", "\n", "if", "self", ".", "sparse_features", ":", "\n", "                ", "hidden", "=", "adj_norm", "@", "torch", ".", "spmm", "(", "hidden", ",", "w", ")", "+", "b", "\n", "", "else", ":", "\n", "                ", "hidden", "=", "adj_norm", "@", "hidden", "@", "w", "+", "b", "\n", "", "if", "self", ".", "with_relu", "and", "ix", "!=", "len", "(", "self", ".", "weights", ")", "-", "1", ":", "\n", "                ", "hidden", "=", "F", ".", "relu", "(", "hidden", ")", "\n", "\n", "", "", "output", "=", "F", ".", "log_softmax", "(", "hidden", ",", "dim", "=", "1", ")", "\n", "\n", "loss_labeled", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_unlabeled", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_unlabeled", "]", ",", "labels_self_training", "[", "idx_unlabeled", "]", ")", "\n", "loss_test_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_unlabeled", "]", ",", "labels", "[", "idx_unlabeled", "]", ")", "\n", "\n", "if", "self", ".", "lambda_", "==", "1", ":", "\n", "            ", "attack_loss", "=", "loss_labeled", "\n", "", "elif", "self", ".", "lambda_", "==", "0", ":", "\n", "            ", "attack_loss", "=", "loss_unlabeled", "\n", "", "else", ":", "\n", "            ", "attack_loss", "=", "self", ".", "lambda_", "*", "loss_labeled", "+", "(", "1", "-", "self", ".", "lambda_", ")", "*", "loss_unlabeled", "\n", "\n", "", "print", "(", "'GCN loss on unlabled data: {}'", ".", "format", "(", "loss_test_val", ".", "item", "(", ")", ")", ")", "\n", "print", "(", "'GCN acc on unlabled data: {}'", ".", "format", "(", "utils", ".", "accuracy", "(", "output", "[", "idx_unlabeled", "]", ",", "labels", "[", "idx_unlabeled", "]", ")", ".", "item", "(", ")", ")", ")", "\n", "print", "(", "'attack loss: {}'", ".", "format", "(", "attack_loss", ".", "item", "(", ")", ")", ")", "\n", "\n", "adj_grad", ",", "feature_grad", "=", "None", ",", "None", "\n", "if", "self", ".", "attack_structure", ":", "\n", "            ", "adj_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "attack_loss", ",", "self", ".", "adj_changes", ",", "retain_graph", "=", "True", ")", "[", "0", "]", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "feature_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "attack_loss", ",", "self", ".", "feature_changes", ",", "retain_graph", "=", "True", ")", "[", "0", "]", "\n", "", "return", "adj_grad", ",", "feature_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack.attack": [[300, 367], ["scipy.issparse", "deeprobust.graph.utils.to_tensor", "mettack.Metattack.self_training_label", "tqdm.tqdm.tqdm", "range", "deeprobust.graph.utils.normalize_adj_tensor", "mettack.Metattack.inner_train", "mettack.Metattack.get_meta_grad", "torch.tensor().to", "torch.tensor().to", "mettack.Metattack.get_modified_adj().detach", "mettack.Metattack.get_modified_features().detach", "mettack.Metattack.get_modified_adj", "mettack.Metattack.get_adj_score", "mettack.Metattack.get_feature_score", "mettack.Metattack.max", "mettack.Metattack.max", "torch.argmax", "deeprobust.graph.utils.unravel_index", "torch.argmax", "deeprobust.graph.utils.unravel_index", "torch.tensor", "torch.tensor", "mettack.Metattack.get_modified_adj", "mettack.Metattack.get_modified_features"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.self_training_label", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.inner_train", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.Metattack.get_meta_grad", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_adj_score", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_feature_score", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.unravel_index", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.unravel_index", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_features"], ["", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "idx_unlabeled", ",", "n_perturbations", ",", "ll_constraint", "=", "True", ",", "ll_cutoff", "=", "0.004", ")", ":", "\n", "        ", "\"\"\"Generate n_perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_unlabeled:\n            unlabeled nodes indices\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        ll_constraint: bool\n            whether to exert the likelihood ratio test constraint\n        ll_cutoff : float\n            The critical value for the likelihood ratio test of the power law distributions.\n            See the Chi square distribution with one degree of freedom. Default value 0.004\n            corresponds to a p-value of roughly 0.95. It would be ignored if `ll_constraint`\n            is False.\n\n        \"\"\"", "\n", "\n", "self", ".", "sparse_features", "=", "sp", ".", "issparse", "(", "ori_features", ")", "\n", "ori_adj", ",", "ori_features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "labels_self_training", "=", "self", ".", "self_training_label", "(", "labels", ",", "idx_train", ")", "\n", "modified_adj", "=", "ori_adj", "\n", "modified_features", "=", "ori_features", "\n", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "n_perturbations", ")", ",", "desc", "=", "\"Perturbing graph\"", ")", ":", "\n", "            ", "if", "self", ".", "attack_structure", ":", "\n", "                ", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "                ", "modified_features", "=", "ori_features", "+", "self", ".", "feature_changes", "\n", "\n", "", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "self", ".", "inner_train", "(", "modified_features", ",", "adj_norm", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ")", "\n", "\n", "adj_grad", ",", "feature_grad", "=", "self", ".", "get_meta_grad", "(", "modified_features", ",", "adj_norm", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ",", "labels_self_training", ")", "\n", "\n", "adj_meta_score", "=", "torch", ".", "tensor", "(", "0.0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "feature_meta_score", "=", "torch", ".", "tensor", "(", "0.0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "attack_structure", ":", "\n", "                ", "adj_meta_score", "=", "self", ".", "get_adj_score", "(", "adj_grad", ",", "modified_adj", ",", "ori_adj", ",", "ll_constraint", ",", "ll_cutoff", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "                ", "feature_meta_score", "=", "self", ".", "get_feature_score", "(", "feature_grad", ",", "modified_features", ")", "\n", "\n", "", "if", "adj_meta_score", ".", "max", "(", ")", ">=", "feature_meta_score", ".", "max", "(", ")", ":", "\n", "                ", "adj_meta_argmax", "=", "torch", ".", "argmax", "(", "adj_meta_score", ")", "\n", "row_idx", ",", "col_idx", "=", "utils", ".", "unravel_index", "(", "adj_meta_argmax", ",", "ori_adj", ".", "shape", ")", "\n", "self", ".", "adj_changes", ".", "data", "[", "row_idx", "]", "[", "col_idx", "]", "+=", "(", "-", "2", "*", "modified_adj", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", "[", "col_idx", "]", "[", "row_idx", "]", "+=", "(", "-", "2", "*", "modified_adj", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "feature_meta_argmax", "=", "torch", ".", "argmax", "(", "feature_meta_score", ")", "\n", "row_idx", ",", "col_idx", "=", "utils", ".", "unravel_index", "(", "feature_meta_argmax", ",", "ori_features", ".", "shape", ")", "\n", "self", ".", "feature_changes", ".", "data", "[", "row_idx", "]", "[", "col_idx", "]", "+=", "(", "-", "2", "*", "modified_features", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "\n", "", "", "if", "self", ".", "attack_structure", ":", "\n", "            ", "self", ".", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", ".", "detach", "(", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "self", ".", "modified_features", "=", "self", ".", "get_modified_features", "(", "ori_features", ")", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.__init__": [[399, 433], ["mettack.BaseMeta.__init__", "enumerate", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "mettack.MetaApprox.weights.append", "mettack.MetaApprox.biases.append", "torch.optim.Adam", "mettack.MetaApprox._initialize", "torch.zeros().to", "torch.zeros().to", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "mettack.MetaApprox.weights.append", "mettack.MetaApprox.biases.append", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.zeros", "torch.zeros", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ",", "with_bias", "=", "False", ",", "lambda_", "=", "0.5", ",", "train_iters", "=", "100", ",", "lr", "=", "0.01", ")", ":", "\n", "\n", "        ", "super", "(", "MetaApprox", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "feature_shape", ",", "lambda_", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "train_iters", "=", "train_iters", "\n", "self", ".", "adj_meta_grad", "=", "None", "\n", "self", ".", "features_meta_grad", "=", "None", "\n", "if", "self", ".", "attack_structure", ":", "\n", "            ", "self", ".", "adj_grad_sum", "=", "torch", ".", "zeros", "(", "nnodes", ",", "nnodes", ")", ".", "to", "(", "device", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "self", ".", "feature_grad_sum", "=", "torch", ".", "zeros", "(", "feature_shape", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "self", ".", "with_bias", "=", "with_bias", "\n", "\n", "self", ".", "weights", "=", "[", "]", "\n", "self", ".", "biases", "=", "[", "]", "\n", "\n", "previous_size", "=", "self", ".", "nfeat", "\n", "for", "ix", ",", "nhid", "in", "enumerate", "(", "self", ".", "hidden_sizes", ")", ":", "\n", "            ", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "previous_size", ",", "nhid", ")", ".", "to", "(", "device", ")", ")", "\n", "bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nhid", ")", ".", "to", "(", "device", ")", ")", "\n", "previous_size", "=", "nhid", "\n", "\n", "self", ".", "weights", ".", "append", "(", "weight", ")", "\n", "self", ".", "biases", ".", "append", "(", "bias", ")", "\n", "\n", "", "output_weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "previous_size", ",", "self", ".", "nclass", ")", ".", "to", "(", "device", ")", ")", "\n", "output_bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "self", ".", "nclass", ")", ".", "to", "(", "device", ")", ")", "\n", "self", ".", "weights", ".", "append", "(", "output_weight", ")", "\n", "self", ".", "biases", ".", "append", "(", "output_bias", ")", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "weights", "+", "self", ".", "biases", ",", "lr", "=", "lr", ")", "# , weight_decay=5e-4)", "\n", "self", ".", "_initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox._initialize": [[434, 443], ["zip", "torch.optim.Adam", "w.data.uniform_", "b.data.uniform_", "math.sqrt", "w.size"], "methods", ["None"], ["", "def", "_initialize", "(", "self", ")", ":", "\n", "        ", "for", "w", ",", "b", "in", "zip", "(", "self", ".", "weights", ",", "self", ".", "biases", ")", ":", "\n", "# w.data.fill_(1)", "\n", "# b.data.fill_(1)", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "w", ".", "size", "(", "1", ")", ")", "\n", "w", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "b", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "weights", "+", "self", ".", "biases", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.inner_train": [[444, 493], ["deeprobust.graph.utils.normalize_adj_tensor", "range", "torch.nn.functional.nll_loss", "print", "print", "enumerate", "torch.nn.functional.log_softmax", "torch.nn.functional.nll_loss", "torch.nn.functional.nll_loss", "mettack.MetaApprox.optimizer.zero_grad", "torch.nn.functional.nll_loss.backward", "mettack.MetaApprox.optimizer.step", "mettack.MetaApprox.adj_changes.grad.zero_", "mettack.MetaApprox.feature_changes.grad.zero_", "torch.nn.functional.nll_loss.item", "deeprobust.graph.utils.accuracy().item", "torch.nn.functional.relu", "torch.autograd.grad", "torch.autograd.grad", "deeprobust.graph.utils.accuracy", "torch.spmm"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "inner_train", "(", "self", ",", "features", ",", "modified_adj", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ",", "labels_self_training", ")", ":", "\n", "        ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "for", "j", "in", "range", "(", "self", ".", "train_iters", ")", ":", "\n", "# hidden = features", "\n", "# for w, b in zip(self.weights, self.biases):", "\n", "#     if self.sparse_features:", "\n", "#         hidden = adj_norm @ torch.spmm(hidden, w) + b", "\n", "#     else:", "\n", "#         hidden = adj_norm @ hidden @ w + b", "\n", "#     if self.with_relu:", "\n", "#         hidden = F.relu(hidden)", "\n", "\n", "            ", "hidden", "=", "features", "\n", "for", "ix", ",", "w", "in", "enumerate", "(", "self", ".", "weights", ")", ":", "\n", "                ", "b", "=", "self", ".", "biases", "[", "ix", "]", "if", "self", ".", "with_bias", "else", "0", "\n", "if", "self", ".", "sparse_features", ":", "\n", "                    ", "hidden", "=", "adj_norm", "@", "torch", ".", "spmm", "(", "hidden", ",", "w", ")", "+", "b", "\n", "", "else", ":", "\n", "                    ", "hidden", "=", "adj_norm", "@", "hidden", "@", "w", "+", "b", "\n", "", "if", "self", ".", "with_relu", ":", "\n", "                    ", "hidden", "=", "F", ".", "relu", "(", "hidden", ")", "\n", "\n", "", "", "output", "=", "F", ".", "log_softmax", "(", "hidden", ",", "dim", "=", "1", ")", "\n", "loss_labeled", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_unlabeled", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_unlabeled", "]", ",", "labels_self_training", "[", "idx_unlabeled", "]", ")", "\n", "\n", "if", "self", ".", "lambda_", "==", "1", ":", "\n", "                ", "attack_loss", "=", "loss_labeled", "\n", "", "elif", "self", ".", "lambda_", "==", "0", ":", "\n", "                ", "attack_loss", "=", "loss_unlabeled", "\n", "", "else", ":", "\n", "                ", "attack_loss", "=", "self", ".", "lambda_", "*", "loss_labeled", "+", "(", "1", "-", "self", ".", "lambda_", ")", "*", "loss_unlabeled", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss_labeled", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "if", "self", ".", "attack_structure", ":", "\n", "                ", "self", ".", "adj_changes", ".", "grad", ".", "zero_", "(", ")", "\n", "self", ".", "adj_grad_sum", "+=", "torch", ".", "autograd", ".", "grad", "(", "attack_loss", ",", "self", ".", "adj_changes", ",", "retain_graph", "=", "True", ")", "[", "0", "]", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "                ", "self", ".", "feature_changes", ".", "grad", ".", "zero_", "(", ")", "\n", "self", ".", "feature_grad_sum", "+=", "torch", ".", "autograd", ".", "grad", "(", "attack_loss", ",", "self", ".", "feature_changes", ",", "retain_graph", "=", "True", ")", "[", "0", "]", "\n", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "\n", "", "loss_test_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_unlabeled", "]", ",", "labels", "[", "idx_unlabeled", "]", ")", "\n", "print", "(", "'GCN loss on unlabled data: {}'", ".", "format", "(", "loss_test_val", ".", "item", "(", ")", ")", ")", "\n", "print", "(", "'GCN acc on unlabled data: {}'", ".", "format", "(", "utils", ".", "accuracy", "(", "output", "[", "idx_unlabeled", "]", ",", "labels", "[", "idx_unlabeled", "]", ")", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.attack": [[495, 562], ["deeprobust.graph.utils.to_tensor", "mettack.MetaApprox.self_training_label", "scipy.issparse", "tqdm.tqdm.tqdm", "range", "mettack.MetaApprox._initialize", "mettack.MetaApprox.inner_train", "torch.tensor().to", "torch.tensor().to", "mettack.MetaApprox.get_modified_adj().detach", "mettack.MetaApprox.get_modified_features().detach", "mettack.MetaApprox.get_modified_adj", "mettack.MetaApprox.adj_grad_sum.data.fill_", "mettack.MetaApprox.feature_grad_sum.data.fill_", "mettack.MetaApprox.get_adj_score", "mettack.MetaApprox.get_feature_score", "mettack.MetaApprox.max", "mettack.MetaApprox.max", "torch.argmax", "deeprobust.graph.utils.unravel_index", "torch.argmax", "deeprobust.graph.utils.unravel_index", "torch.tensor", "torch.tensor", "mettack.MetaApprox.get_modified_adj", "mettack.MetaApprox.get_modified_features"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.self_training_label", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.MetaApprox.inner_train", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_adj_score", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.mettack.BaseMeta.get_feature_score", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.unravel_index", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.unravel_index", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_features"], ["", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "idx_unlabeled", ",", "n_perturbations", ",", "ll_constraint", "=", "True", ",", "ll_cutoff", "=", "0.004", ")", ":", "\n", "        ", "\"\"\"Generate n_perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_unlabeled:\n            unlabeled nodes indices\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        ll_constraint: bool\n            whether to exert the likelihood ratio test constraint\n        ll_cutoff : float\n            The critical value for the likelihood ratio test of the power law distributions.\n            See the Chi square distribution with one degree of freedom. Default value 0.004\n            corresponds to a p-value of roughly 0.95. It would be ignored if `ll_constraint`\n            is False.\n\n        \"\"\"", "\n", "ori_adj", ",", "ori_features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "ori_adj", ",", "ori_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "labels_self_training", "=", "self", ".", "self_training_label", "(", "labels", ",", "idx_train", ")", "\n", "self", ".", "sparse_features", "=", "sp", ".", "issparse", "(", "ori_features", ")", "\n", "modified_adj", "=", "ori_adj", "\n", "modified_features", "=", "ori_features", "\n", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "n_perturbations", ")", ",", "desc", "=", "\"Perturbing graph\"", ")", ":", "\n", "            ", "self", ".", "_initialize", "(", ")", "\n", "\n", "if", "self", ".", "attack_structure", ":", "\n", "                ", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", "\n", "self", ".", "adj_grad_sum", ".", "data", ".", "fill_", "(", "0", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "                ", "modified_features", "=", "ori_features", "+", "self", ".", "feature_changes", "\n", "self", ".", "feature_grad_sum", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "", "self", ".", "inner_train", "(", "modified_features", ",", "modified_adj", ",", "idx_train", ",", "idx_unlabeled", ",", "labels", ",", "labels_self_training", ")", "\n", "\n", "adj_meta_score", "=", "torch", ".", "tensor", "(", "0.0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "feature_meta_score", "=", "torch", ".", "tensor", "(", "0.0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "self", ".", "attack_structure", ":", "\n", "                ", "adj_meta_score", "=", "self", ".", "get_adj_score", "(", "self", ".", "adj_grad_sum", ",", "modified_adj", ",", "ori_adj", ",", "ll_constraint", ",", "ll_cutoff", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "                ", "feature_meta_score", "=", "self", ".", "get_feature_score", "(", "self", ".", "feature_grad_sum", ",", "modified_features", ")", "\n", "\n", "", "if", "adj_meta_score", ".", "max", "(", ")", ">=", "feature_meta_score", ".", "max", "(", ")", ":", "\n", "                ", "adj_meta_argmax", "=", "torch", ".", "argmax", "(", "adj_meta_score", ")", "\n", "row_idx", ",", "col_idx", "=", "utils", ".", "unravel_index", "(", "adj_meta_argmax", ",", "ori_adj", ".", "shape", ")", "\n", "self", ".", "adj_changes", ".", "data", "[", "row_idx", "]", "[", "col_idx", "]", "+=", "(", "-", "2", "*", "modified_adj", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "self", ".", "adj_changes", ".", "data", "[", "col_idx", "]", "[", "row_idx", "]", "+=", "(", "-", "2", "*", "modified_adj", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "feature_meta_argmax", "=", "torch", ".", "argmax", "(", "feature_meta_score", ")", "\n", "row_idx", ",", "col_idx", "=", "utils", ".", "unravel_index", "(", "feature_meta_argmax", ",", "ori_features", ".", "shape", ")", "\n", "self", ".", "feature_changes", ".", "data", "[", "row_idx", "]", "[", "col_idx", "]", "+=", "(", "-", "2", "*", "modified_features", "[", "row_idx", "]", "[", "col_idx", "]", "+", "1", ")", "\n", "\n", "", "", "if", "self", ".", "attack_structure", ":", "\n", "            ", "self", ".", "modified_adj", "=", "self", ".", "get_modified_adj", "(", "ori_adj", ")", ".", "detach", "(", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "self", ".", "modified_features", "=", "self", ".", "get_modified_features", "(", "ori_features", ")", ".", "detach", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.dice.DICE.__init__": [[39, 43], ["deeprobust.graph.global_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "DICE", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", "=", "attack_structure", ",", "attack_features", "=", "attack_features", ",", "device", "=", "device", ")", "\n", "\n", "assert", "not", "self", ".", "attack_features", ",", "'DICE does NOT support attacking features'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.dice.DICE.attack": [[44, 102], ["print", "ori_adj.tolil", "numpy.random.choice", "sum", "set", "scipy.triu().nonzero", "range", "dice.DICE.check_adj", "zip", "numpy.random.permutation", "numpy.random.randint", "scipy.triu", "zip", "ori_adj.nonzero", "range", "numpy.random.randint", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj"], ["", "def", "attack", "(", "self", ",", "ori_adj", ",", "labels", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Delete internally, connect externally. This baseline has all true class labels\n        (train and test) available.\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        labels:\n            node labels\n        n_perturbations : int\n            Number of edge removals/additions.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "\n", "# ori_adj: sp.csr_matrix", "\n", "\n", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "modified_adj", "=", "ori_adj", ".", "tolil", "(", ")", "\n", "\n", "remove_or_insert", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "n_perturbations", ")", "\n", "n_remove", "=", "sum", "(", "remove_or_insert", ")", "\n", "\n", "nonzero", "=", "set", "(", "zip", "(", "*", "ori_adj", ".", "nonzero", "(", ")", ")", ")", "\n", "indices", "=", "sp", ".", "triu", "(", "modified_adj", ")", ".", "nonzero", "(", ")", "\n", "possible_indices", "=", "[", "x", "for", "x", "in", "zip", "(", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", ")", "\n", "if", "labels", "[", "x", "[", "0", "]", "]", "==", "labels", "[", "x", "[", "1", "]", "]", "]", "\n", "\n", "remove_indices", "=", "np", ".", "random", ".", "permutation", "(", "possible_indices", ")", "[", ":", "n_remove", "]", "\n", "modified_adj", "[", "remove_indices", "[", ":", ",", "0", "]", ",", "remove_indices", "[", ":", ",", "1", "]", "]", "=", "0", "\n", "modified_adj", "[", "remove_indices", "[", ":", ",", "1", "]", ",", "remove_indices", "[", ":", ",", "0", "]", "]", "=", "0", "\n", "\n", "n_insert", "=", "n_perturbations", "-", "n_remove", "\n", "\n", "# # sample edges to add", "\n", "# nonzero = nonzero", "\n", "# edges = self.random_sample_edges(adj, n_insert, exclude=nonzero)", "\n", "# for n1, n2 in edges:", "\n", "#     modified_adj[n1, n2] += 1", "\n", "#     modified_adj[n2, n1] += 1", "\n", "\n", "# sample edges to add", "\n", "for", "i", "in", "range", "(", "n_insert", ")", ":", "\n", "# select a node", "\n", "            ", "node1", "=", "np", ".", "random", ".", "randint", "(", "ori_adj", ".", "shape", "[", "0", "]", ")", "\n", "possible_nodes", "=", "[", "x", "for", "x", "in", "range", "(", "ori_adj", ".", "shape", "[", "0", "]", ")", "\n", "if", "labels", "[", "x", "]", "!=", "labels", "[", "node1", "]", "and", "modified_adj", "[", "x", ",", "node1", "]", "==", "0", "]", "\n", "# select another node", "\n", "node2", "=", "possible_nodes", "[", "np", ".", "random", ".", "randint", "(", "len", "(", "possible_nodes", ")", ")", "]", "\n", "modified_adj", "[", "node1", ",", "node2", "]", "=", "1", "\n", "modified_adj", "[", "node2", ",", "node1", "]", "=", "1", "\n", "\n", "", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.dice.DICE.sample_forever": [[104, 115], ["tuple", "random.sample", "exclude.add", "exclude.add", "range"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "sample_forever", "(", "self", ",", "adj", ",", "exclude", ")", ":", "\n", "        ", "\"\"\"Randomly random sample edges from adjacency matrix, `exclude` is a set\n        which contains the edges we do not want to sample and the ones already sampled\n        \"\"\"", "\n", "while", "True", ":", "\n", "# t = tuple(np.random.randint(0, adj.shape[0], 2))", "\n", "            ", "t", "=", "tuple", "(", "random", ".", "sample", "(", "range", "(", "0", ",", "adj", ".", "shape", "[", "0", "]", ")", ",", "2", ")", ")", "\n", "if", "t", "not", "in", "exclude", ":", "\n", "                ", "yield", "t", "\n", "exclude", ".", "add", "(", "t", ")", "\n", "exclude", ".", "add", "(", "(", "t", "[", "1", "]", ",", "t", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.dice.DICE.random_sample_edges": [[116, 119], ["dice.DICE.sample_forever", "next", "range"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.sample_forever", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next"], ["", "", "", "def", "random_sample_edges", "(", "self", ",", "adj", ",", "n", ",", "exclude", ")", ":", "\n", "        ", "itr", "=", "self", ".", "sample_forever", "(", "adj", ",", "exclude", "=", "exclude", ")", "\n", "return", "[", "next", "(", "itr", ")", "for", "_", "in", "range", "(", "n", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.__init__": [[38, 56], ["deeprobust.graph.global_attack.BaseAttack.__init__", "torch.nn.parameter.Parameter", "ig_attack.IGAttack.adj_changes.data.fill_", "torch.nn.parameter.Parameter", "ig_attack.IGAttack.feature_changes.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "int"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], []], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.attack": [[57, 94], ["scipy.issparse", "deeprobust.graph.utils.to_tensor", "victim_model.eval", "warnings.warn", "deeprobust.graph.utils.normalize_adj_tensor", "ig_attack.IGAttack.calc_importance_edge", "ig_attack.IGAttack.calc_importance_feature", "ipdb.set_trace", "tqdm.tqdm.tqdm", "ig_attack.IGAttack.adj_changes.data.copy_", "ig_attack.IGAttack.get_modified_adj().detach", "range", "torch.tensor", "ig_attack.IGAttack.get_modified_adj"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_edge", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_feature", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj"], ["\n", "\n", "def", "__init__", "(", "self", ",", "model", ",", "nnodes", "=", "None", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "True", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "IGAttack", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "\n", "assert", "attack_features", "or", "attack_structure", ",", "'attack_features or attack_structure cannot be both False'", "\n", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "self", ".", "target_node", "=", "None", "\n", "\n", "", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "target_node", ",", "n_perturbations", ",", "steps", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train:\n            training nodes indices\n        target_node : int\n            target node index to be attacked\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        steps : int\n            steps for computing integrated gradients\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.calc_importance_edge": [[95, 133], ["deeprobust.graph.utils.normalize_adj_tensor", "tqdm.tqdm.tqdm", "range", "range", "integrated_grad_list.append", "ig_attack.IGAttack.surrogate", "torch.nn.functional.nll_loss", "torch.autograd.grad", "_sum.mean", "_sum.mean", "range", "range", "float", "float"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["\n", "self", ".", "surrogate", ".", "eval", "(", ")", "\n", "self", ".", "target_node", "=", "target_node", "\n", "\n", "\n", "modified_adj", "=", "ori_adj", ".", "todense", "(", ")", "\n", "modified_features", "=", "ori_features", ".", "todense", "(", ")", "\n", "adj", ",", "features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "modified_adj", ",", "modified_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "\n", "pseudo_labels", "=", "self", ".", "surrogate", ".", "predict", "(", ")", ".", "detach", "(", ")", ".", "argmax", "(", "1", ")", "\n", "pseudo_labels", "[", "idx_train", "]", "=", "labels", "[", "idx_train", "]", "\n", "self", ".", "pseudo_labels", "=", "pseudo_labels", "\n", "\n", "s_e", "=", "np", ".", "zeros", "(", "adj", ".", "shape", "[", "1", "]", ")", "\n", "s_f", "=", "np", ".", "zeros", "(", "features", ".", "shape", "[", "1", "]", ")", "\n", "if", "self", ".", "attack_structure", ":", "\n", "            ", "s_e", "=", "self", ".", "calc_importance_edge", "(", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "s_f", "=", "self", ".", "calc_importance_feature", "(", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", "\n", "\n", "", "for", "t", "in", "(", "range", "(", "n_perturbations", ")", ")", ":", "\n", "            ", "s_e_max", "=", "np", ".", "argmax", "(", "s_e", ")", "\n", "s_f_max", "=", "np", ".", "argmax", "(", "s_f", ")", "\n", "\n", "if", "s_e", "[", "s_e_max", "]", ">=", "s_f", "[", "s_f_max", "]", ":", "\n", "# edge perturbation score is larger", "\n", "                ", "if", "self", ".", "attack_structure", ":", "\n", "                    ", "value", "=", "np", ".", "abs", "(", "1", "-", "modified_adj", "[", "target_node", ",", "s_e_max", "]", ")", "\n", "modified_adj", "[", "target_node", ",", "s_e_max", "]", "=", "value", "\n", "modified_adj", "[", "s_e_max", ",", "target_node", "]", "=", "value", "\n", "s_e", "[", "s_e_max", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\"\"\"No posisble perturbation on the structure can be made!\n                            See https://github.com/DSE-MSU/DeepRobust/issues/42 for more details.\"\"\"", ")", "\n", "", "", "else", ":", "\n", "# feature perturbation score is larger", "\n", "                ", "if", "self", ".", "attack_features", ":", "\n", "                    ", "modified_features", "[", "target_node", ",", "s_f_max", "]", "=", "np", ".", "abs", "(", "1", "-", "modified_features", "[", "target_node", ",", "s_f_max", "]", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_gradient": [[134, 141], ["ig_attack.IGAttack.surrogate", "torch.nn.functional.nll_loss", "torch.autograd.grad"], "methods", ["None"], ["s_f", "[", "s_f_max", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\"\"\"No posisble perturbation on the features can be made!\n                            See https://github.com/DSE-MSU/DeepRobust/issues/42 for more details.\"\"\"", ")", "\n", "\n", "\n", "", "", "", "self", ".", "modified_adj", "=", "sp", ".", "csr_matrix", "(", "modified_adj", ")", "\n", "self", ".", "modified_features", "=", "sp", ".", "csr_matrix", "(", "modified_features", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.calc_importance_feature": [[142, 168], ["range", "range", "integrated_grad_list.append", "ig_attack.IGAttack.surrogate", "torch.nn.functional.nll_loss", "torch.autograd.grad", "_sum.mean", "_sum.mean", "range", "range", "float", "float"], "methods", ["None"], ["self", ".", "check_adj", "(", "modified_adj", ")", "\n", "\n", "", "def", "calc_importance_edge", "(", "self", ",", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", ":", "\n", "        ", "\"\"\"Calculate integrated gradient for edges. Although I think the the gradient should be\n        with respect to adj instead of adj_norm, but the calculation is too time-consuming. So I\n        finally decided to calculate the gradient of loss with respect to adj_norm\n        \"\"\"", "\n", "baseline_add", "=", "adj_norm", ".", "clone", "(", ")", "\n", "baseline_remove", "=", "adj_norm", ".", "clone", "(", ")", "\n", "baseline_add", ".", "data", "[", "self", ".", "target_node", "]", "=", "1", "\n", "baseline_remove", ".", "data", "[", "self", ".", "target_node", "]", "=", "0", "\n", "adj_norm", ".", "requires_grad", "=", "True", "\n", "integrated_grad_list", "=", "[", "]", "\n", "\n", "i", "=", "self", ".", "target_node", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "adj_norm", ".", "shape", "[", "1", "]", ")", ")", ":", "\n", "            ", "if", "adj_norm", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_remove", "+", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "adj_norm", "-", "baseline_remove", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "else", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_add", "-", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "baseline_add", "-", "adj_norm", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "_sum", "=", "0", "\n", "\n", "for", "new_adj", "in", "scaled_inputs", ":", "\n", "                ", "output", "=", "self", ".", "surrogate", "(", "features", ",", "new_adj", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", "[", "[", "self", ".", "target_node", "]", "]", ",", "\n", "self", ".", "pseudo_labels", "[", "[", "self", ".", "target_node", "]", "]", ")", "\n", "adj_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "adj_norm", ")", "[", "0", "]", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.calc_gradient_adj": [[169, 176], ["adj_grad.mean", "deeprobust.graph.utils.normalize_adj_tensor", "ig_attack.IGAttack.surrogate", "torch.nn.functional.nll_loss", "torch.autograd.grad"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["adj_grad", "=", "adj_grad", "[", "i", "]", "[", "j", "]", "\n", "_sum", "+=", "adj_grad", "\n", "\n", "", "if", "adj_norm", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "avg_grad", "=", "(", "adj_norm", "[", "i", "]", "[", "j", "]", "-", "0", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "avg_grad", "=", "(", "1", "-", "adj_norm", "[", "i", "]", "[", "j", "]", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.calc_gradient_feature": [[177, 183], ["adj_grad.mean", "ig_attack.IGAttack.surrogate", "torch.nn.functional.nll_loss", "torch.autograd.grad"], "methods", ["None"], ["", "integrated_grad_list", ".", "append", "(", "avg_grad", ".", "detach", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "integrated_grad_list", "[", "i", "]", "=", "0", "\n", "# make impossible perturbation to be negative", "\n", "integrated_grad_list", "=", "np", ".", "array", "(", "integrated_grad_list", ")", "\n", "adj", "=", "(", "adj_norm", ">", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "integrated_grad_list", "=", "(", "-", "2", "*", "adj", "[", "self", ".", "target_node", "]", "+", "1", ")", "*", "integrated_grad_list", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_adj": [[184, 190], ["numpy.diag_indices", "torch.clamp", "torch.diag", "torch.diag", "torch.transpose"], "methods", ["None"], ["integrated_grad_list", "[", "self", ".", "target_node", "]", "=", "-", "10", "\n", "return", "integrated_grad_list", "\n", "\n", "", "def", "calc_importance_feature", "(", "self", ",", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", ":", "\n", "        ", "\"\"\"Calculate integrated gradient for features\n        \"\"\"", "\n", "baseline_add", "=", "features", ".", "clone", "(", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.ig_attack.IGAttack.get_modified_features": [[191, 193], ["None"], "methods", ["None"], ["baseline_remove", "=", "features", ".", "clone", "(", ")", "\n", "baseline_add", ".", "data", "[", "self", ".", "target_node", "]", "=", "1", "\n", "baseline_remove", ".", "data", "[", "self", ".", "target_node", "]", "=", "0", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.__init__": [[36, 40], ["deeprobust.graph.global_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "Random", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", "=", "attack_structure", ",", "attack_features", "=", "attack_features", ",", "device", "=", "device", ")", "\n", "\n", "assert", "not", "self", ".", "attack_features", ",", "'RND does NOT support attacking features'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.attack": [[41, 62], ["random_attack.Random.perturb_adj"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.perturb_adj"], ["", "def", "attack", "(", "self", ",", "ori_adj", ",", "n_perturbations", ",", "type", "=", "'add'", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate attacks on the input graph.\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        n_perturbations : int\n            Number of edge removals/additions.\n        type: str\n            perturbation type. Could be 'add', 'remove' or 'flip'.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "\n", "if", "self", ".", "attack_structure", ":", "\n", "            ", "modified_adj", "=", "self", ".", "perturb_adj", "(", "ori_adj", ",", "n_perturbations", ",", "type", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.perturb_adj": [[63, 110], ["adj.tolil", "type.lower.lower.lower", "random_attack.Random.check_adj", "random_attack.Random.random_sample_edges", "set", "random_attack.Random.random_sample_edges", "zip", "numpy.array", "set", "scipy.triu().nonzero", "numpy.random.permutation", "adj.nonzero", "scipy.triu"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.random_sample_edges", "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.random_sample_edges"], ["", "", "def", "perturb_adj", "(", "self", ",", "adj", ",", "n_perturbations", ",", "type", "=", "'add'", ")", ":", "\n", "        ", "\"\"\"Randomly add, remove or flip edges.\n\n        Parameters\n        ----------\n        adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        n_perturbations : int\n            Number of edge removals/additions.\n        type: str\n            perturbation type. Could be 'add', 'remove' or 'flip'.\n\n        Returns\n        ------\n        scipy.sparse matrix\n            perturbed adjacency matrix\n        \"\"\"", "\n", "# adj: sp.csr_matrix", "\n", "modified_adj", "=", "adj", ".", "tolil", "(", ")", "\n", "\n", "type", "=", "type", ".", "lower", "(", ")", "\n", "assert", "type", "in", "[", "'add'", ",", "'remove'", ",", "'flip'", "]", "\n", "\n", "if", "type", "==", "'flip'", ":", "\n", "# sample edges to flip", "\n", "            ", "edges", "=", "self", ".", "random_sample_edges", "(", "adj", ",", "n_perturbations", ",", "exclude", "=", "set", "(", ")", ")", "\n", "for", "n1", ",", "n2", "in", "edges", ":", "\n", "                ", "modified_adj", "[", "n1", ",", "n2", "]", "=", "1", "-", "modified_adj", "[", "n1", ",", "n2", "]", "\n", "modified_adj", "[", "n2", ",", "n1", "]", "=", "1", "-", "modified_adj", "[", "n2", ",", "n1", "]", "\n", "\n", "", "", "if", "type", "==", "'add'", ":", "\n", "# sample edges to add", "\n", "            ", "nonzero", "=", "set", "(", "zip", "(", "*", "adj", ".", "nonzero", "(", ")", ")", ")", "\n", "edges", "=", "self", ".", "random_sample_edges", "(", "adj", ",", "n_perturbations", ",", "exclude", "=", "nonzero", ")", "\n", "for", "n1", ",", "n2", "in", "edges", ":", "\n", "                ", "modified_adj", "[", "n1", ",", "n2", "]", "=", "1", "\n", "modified_adj", "[", "n2", ",", "n1", "]", "=", "1", "\n", "\n", "", "", "if", "type", "==", "'remove'", ":", "\n", "# sample edges to remove", "\n", "            ", "nonzero", "=", "np", ".", "array", "(", "sp", ".", "triu", "(", "adj", ",", "k", "=", "1", ")", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "indices", "=", "np", ".", "random", ".", "permutation", "(", "nonzero", ")", "[", ":", "n_perturbations", "]", ".", "T", "\n", "modified_adj", "[", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", "]", "=", "0", "\n", "modified_adj", "[", "indices", "[", "1", "]", ",", "indices", "[", "0", "]", "]", "=", "0", "\n", "\n", "", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.perturb_features": [[111, 117], ["print"], "methods", ["None"], ["", "def", "perturb_features", "(", "self", ",", "features", ",", "n_perturbations", ")", ":", "\n", "        ", "\"\"\"Randomly perturb features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "return", "modified_features", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.inject_nodes": [[118, 128], ["print", "adj.tolil"], "methods", ["None"], ["", "def", "inject_nodes", "(", "self", ",", "adj", ",", "n_add", ",", "n_perturbations", ")", ":", "\n", "        ", "\"\"\"For each added node, randomly connect with other nodes.\n        \"\"\"", "\n", "# adj: sp.csr_matrix", "\n", "# TODO", "\n", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "raise", "NotImplementedError", "\n", "\n", "modified_adj", "=", "adj", ".", "tolil", "(", ")", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.random_sample_edges": [[129, 132], ["random_attack.Random.sample_forever", "next", "range"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.sample_forever", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next"], ["", "def", "random_sample_edges", "(", "self", ",", "adj", ",", "n", ",", "exclude", ")", ":", "\n", "        ", "itr", "=", "self", ".", "sample_forever", "(", "adj", ",", "exclude", "=", "exclude", ")", "\n", "return", "[", "next", "(", "itr", ")", "for", "_", "in", "range", "(", "n", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.random_attack.Random.sample_forever": [[133, 145], ["tuple", "numpy.random.choice", "exclude.add", "exclude.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "sample_forever", "(", "self", ",", "adj", ",", "exclude", ")", ":", "\n", "        ", "\"\"\"Randomly random sample edges from adjacency matrix, `exclude` is a set\n        which contains the edges we do not want to sample and the ones already sampled\n        \"\"\"", "\n", "while", "True", ":", "\n", "# t = tuple(np.random.randint(0, adj.shape[0], 2))", "\n", "# t = tuple(random.sample(range(0, adj.shape[0]), 2))", "\n", "            ", "t", "=", "tuple", "(", "np", ".", "random", ".", "choice", "(", "adj", ".", "shape", "[", "0", "]", ",", "2", ",", "replace", "=", "False", ")", ")", "\n", "if", "t", "not", "in", "exclude", ":", "\n", "                ", "yield", "t", "\n", "exclude", ".", "add", "(", "t", ")", "\n", "exclude", ".", "add", "(", "(", "t", "[", "1", "]", ",", "t", "[", "0", "]", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.__init__": [[29, 43], ["torch.nn.modules.module.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "BaseAttack", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "surrogate", "=", "model", "\n", "self", ".", "nnodes", "=", "nnodes", "\n", "self", ".", "attack_structure", "=", "attack_structure", "\n", "self", ".", "attack_features", "=", "attack_features", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "if", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "nclass", "=", "model", ".", "nclass", "\n", "self", ".", "nfeat", "=", "model", ".", "nfeat", "\n", "self", ".", "hidden_sizes", "=", "model", ".", "hidden_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.attack": [[44, 60], ["None"], "methods", ["None"], ["", "", "def", "attack", "(", "self", ",", "ori_adj", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate attacks on the input graph.\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        n_perturbations : int\n            Number of edge removals/additions.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.check_adj": [[61, 67], ["numpy.abs().sum", "adj.tocsr().max", "adj.tocsr().min", "numpy.abs", "adj.tocsr", "adj.tocsr"], "methods", ["None"], ["", "def", "check_adj", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric and unweighted.\n        \"\"\"", "\n", "assert", "np", ".", "abs", "(", "adj", "-", "adj", ".", "T", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.check_adj_tensor": [[68, 77], ["adj.diag", "torch.abs().sum", "adj.max", "adj.min", "adj.diag.max", "adj.diag.min", "torch.abs", "adj.t"], "methods", ["None"], ["", "def", "check_adj_tensor", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric, unweighted, all-zero diagonal.\n        \"\"\"", "\n", "assert", "torch", ".", "abs", "(", "adj", "-", "adj", ".", "t", "(", ")", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n", "assert", "adj", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "diag", "=", "adj", ".", "diag", "(", ")", "\n", "assert", "diag", ".", "max", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "assert", "diag", ".", "min", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.save_adj": [[79, 104], ["type", "deeprobust.graph.utils.to_scipy", "scipy.save_npz", "scipy.save_npz", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy"], ["", "def", "save_adj", "(", "self", ",", "root", "=", "r'/tmp/'", ",", "name", "=", "'mod_adj'", ")", ":", "\n", "        ", "\"\"\"Save attacked adjacency matrix.\n\n        Parameters\n        ----------\n        root :\n            root directory where the variable should be saved\n        name : str\n            saved file name\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "assert", "self", ".", "modified_adj", "is", "not", "None", ",", "'modified_adj is None! Please perturb the graph first.'", "\n", "name", "=", "name", "+", "'.npz'", "\n", "modified_adj", "=", "self", ".", "modified_adj", "\n", "\n", "if", "type", "(", "modified_adj", ")", "is", "torch", ".", "Tensor", ":", "\n", "            ", "sparse_adj", "=", "utils", ".", "to_scipy", "(", "modified_adj", ")", "\n", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "sparse_adj", ")", "\n", "", "else", ":", "\n", "            ", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "modified_adj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.global_attack.base_attack.BaseAttack.save_features": [[105, 131], ["type", "deeprobust.graph.utils.to_scipy", "scipy.save_npz", "scipy.save_npz", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy"], ["", "", "def", "save_features", "(", "self", ",", "root", "=", "r'/tmp/'", ",", "name", "=", "'mod_features'", ")", ":", "\n", "        ", "\"\"\"Save attacked node feature matrix.\n\n        Parameters\n        ----------\n        root :\n            root directory where the variable should be saved\n        name : str\n            saved file name\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "\n", "assert", "self", ".", "modified_features", "is", "not", "None", ",", "'modified_features is None! Please perturb the graph first.'", "\n", "name", "=", "name", "+", "'.npz'", "\n", "modified_features", "=", "self", ".", "modified_features", "\n", "\n", "if", "type", "(", "modified_features", ")", "is", "torch", ".", "Tensor", ":", "\n", "            ", "sparse_features", "=", "utils", ".", "to_scipy", "(", "modified_features", ")", "\n", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "sparse_features", ")", "\n", "", "else", ":", "\n", "            ", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "modified_features", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.__init__": [[50, 54], ["deeprobust.graph.targeted_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", "=", "None", ",", "nnodes", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "RND", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", "=", "attack_structure", ",", "attack_features", "=", "attack_features", ",", "device", "=", "device", ")", "\n", "\n", "assert", "not", "self", ".", "attack_features", ",", "'RND does NOT support attacking features except adding nodes'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.attack": [[55, 100], ["print", "ori_adj.tolil", "numpy.random.permutation", "rnd.RND.check_adj", "ori_adj[].todense", "len", "numpy.random.permutation", "numpy.concatenate", "range", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj"], ["", "def", "attack", "(", "self", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "target_node", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Randomly sample nodes u whose lable is different from v and\n        add the edge u,v to the graph structure. This baseline only\n        has access to true class labels in training set\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        target_node : int\n            target node index to be attacked\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        \"\"\"", "\n", "# ori_adj: sp.csr_matrix", "\n", "\n", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "modified_adj", "=", "ori_adj", ".", "tolil", "(", ")", "\n", "\n", "row", "=", "ori_adj", "[", "target_node", "]", ".", "todense", "(", ")", ".", "A1", "\n", "diff_label_nodes", "=", "[", "x", "for", "x", "in", "idx_train", "if", "labels", "[", "x", "]", "!=", "labels", "[", "target_node", "]", "and", "row", "[", "x", "]", "==", "0", "]", "\n", "diff_label_nodes", "=", "np", ".", "random", ".", "permutation", "(", "diff_label_nodes", ")", "\n", "\n", "if", "len", "(", "diff_label_nodes", ")", ">=", "n_perturbations", ":", "\n", "            ", "changed_nodes", "=", "diff_label_nodes", "[", ":", "n_perturbations", "]", "\n", "modified_adj", "[", "target_node", ",", "changed_nodes", "]", "=", "1", "\n", "modified_adj", "[", "changed_nodes", ",", "target_node", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "changed_nodes", "=", "diff_label_nodes", "\n", "unlabeled_nodes", "=", "[", "x", "for", "x", "in", "range", "(", "ori_adj", ".", "shape", "[", "0", "]", ")", "if", "x", "not", "in", "idx_train", "and", "row", "[", "x", "]", "==", "0", "]", "\n", "unlabeled_nodes", "=", "np", ".", "random", ".", "permutation", "(", "unlabeled_nodes", ")", "\n", "changed_nodes", "=", "np", ".", "concatenate", "(", "[", "changed_nodes", ",", "\n", "unlabeled_nodes", "[", ":", "n_perturbations", "-", "len", "(", "diff_label_nodes", ")", "]", "]", ")", "\n", "modified_adj", "[", "target_node", ",", "changed_nodes", "]", "=", "1", "\n", "modified_adj", "[", "changed_nodes", ",", "target_node", "]", "=", "1", "\n", "\n", "", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "# self.modified_features = modified_features", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.add_nodes": [[102, 134], ["print", "rnd.RND.reshape_mx", "rnd.RND.reshape_mx", "numpy.random.permutation", "range", "rnd.RND.check_adj", "range", "numpy.random.permutation", "labels.max"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.reshape_mx", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.reshape_mx", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj"], ["", "def", "add_nodes", "(", "self", ",", "features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "target_node", ",", "n_added", "=", "1", ",", "n_perturbations", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        For each added node, first connect the target node with added fake nodes.\n        Then randomly connect the fake nodes with other nodes whose label is\n        different from target node. As for the node feature, simply copy arbitary node\n        \"\"\"", "\n", "# ori_adj: sp.csr_matrix", "\n", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "N", "=", "ori_adj", ".", "shape", "[", "0", "]", "\n", "D", "=", "features", ".", "shape", "[", "1", "]", "\n", "modified_adj", "=", "self", ".", "reshape_mx", "(", "ori_adj", ",", "shape", "=", "(", "N", "+", "n_added", ",", "N", "+", "n_added", ")", ")", "\n", "modified_features", "=", "self", ".", "reshape_mx", "(", "features", ",", "shape", "=", "(", "N", "+", "n_added", ",", "D", ")", ")", "\n", "\n", "diff_labels", "=", "[", "l", "for", "l", "in", "range", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "if", "l", "!=", "labels", "[", "target_node", "]", "]", "\n", "diff_labels", "=", "np", ".", "random", ".", "permutation", "(", "diff_labels", ")", "\n", "possible_nodes", "=", "[", "x", "for", "x", "in", "idx_train", "if", "labels", "[", "x", "]", "==", "diff_labels", "[", "0", "]", "]", "\n", "\n", "for", "fake_node", "in", "range", "(", "N", ",", "N", "+", "n_added", ")", ":", "\n", "            ", "sampled_nodes", "=", "np", ".", "random", ".", "permutation", "(", "possible_nodes", ")", "[", ":", "n_perturbations", "]", "\n", "# connect the fake node with target node", "\n", "modified_adj", "[", "fake_node", ",", "target_node", "]", "=", "1", "\n", "modified_adj", "[", "target_node", ",", "fake_node", "]", "=", "1", "\n", "# connect the fake node with other nodes", "\n", "for", "node", "in", "sampled_nodes", ":", "\n", "                ", "modified_adj", "[", "fake_node", ",", "node", "]", "=", "1", "\n", "modified_adj", "[", "node", ",", "fake_node", "]", "=", "1", "\n", "", "modified_features", "[", "fake_node", "]", "=", "features", "[", "node", "]", "\n", "\n", "", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "self", ".", "modified_features", "=", "modified_features", "\n", "# return modified_adj, modified_features", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rnd.RND.reshape_mx": [[136, 139], ["mx.nonzero", "scipy.csr_matrix().tolil", "scipy.csr_matrix"], "methods", ["None"], ["", "def", "reshape_mx", "(", "self", ",", "mx", ",", "shape", ")", ":", "\n", "        ", "indices", "=", "mx", ".", "nonzero", "(", ")", "\n", "return", "sp", ".", "csr_matrix", "(", "(", "mx", ".", "data", ",", "(", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", ")", ")", ",", "shape", "=", "shape", ")", ".", "tolil", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.__init__": [[74, 84], ["deeprobust.graph.targeted_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "Nettack", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", "=", "attack_structure", ",", "attack_features", "=", "attack_features", ",", "device", "=", "device", ")", "\n", "\n", "self", ".", "structure_perturbations", "=", "[", "]", "\n", "self", ".", "feature_perturbations", "=", "[", "]", "\n", "self", ".", "influencer_nodes", "=", "[", "]", "\n", "self", ".", "potential_edges", "=", "[", "]", "\n", "\n", "self", ".", "cooc_constraint", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.filter_potential_singletons": [[85, 98], ["modified_adj.sum", "degree_one.repeat().float", "l_and.t", "degree_one.repeat"], "methods", ["None"], ["", "def", "filter_potential_singletons", "(", "self", ",", "modified_adj", ")", ":", "\n", "        ", "\"\"\"Computes a mask for entries potentially leading to singleton nodes, i.e.\n        one of the two nodes corresponding to the entry have degree 1 and there\n        is an edge between the two nodes.\n        \"\"\"", "\n", "\n", "degrees", "=", "modified_adj", ".", "sum", "(", "0", ")", "\n", "degree_one", "=", "(", "degrees", "==", "1", ")", "\n", "resh", "=", "degree_one", ".", "repeat", "(", "self", ".", "nnodes", ",", "1", ")", ".", "float", "(", ")", "\n", "l_and", "=", "resh", "*", "modified_adj", "\n", "logical_and_symmetric", "=", "l_and", "+", "l_and", ".", "t", "(", ")", "\n", "flat_mask", "=", "1", "-", "logical_and_symmetric", "\n", "return", "flat_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.get_linearized_weight": [[99, 103], ["W.detach().cpu().numpy", "W.detach().cpu", "W.detach"], "methods", ["None"], ["", "def", "get_linearized_weight", "(", "self", ")", ":", "\n", "        ", "surrogate", "=", "self", ".", "surrogate", "\n", "W", "=", "surrogate", ".", "gc1", ".", "weight", "@", "surrogate", ".", "gc2", ".", "weight", "\n", "return", "W", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.attack": [[104, 296], ["nettack.Nettack.modified_features.T.dot().tolil", "deeprobust.graph.utils.normalize_adj", "nettack.Nettack.get_linearized_weight", "nettack.Nettack.potential_edges.astype", "range", "type", "deeprobust.graph.utils.to_scipy().tolil", "deeprobust.graph.utils.to_scipy().tolil", "deeprobust.graph.utils.to_scipy().tolil", "deeprobust.graph.utils.to_scipy().tolil", "adj.tolil", "adj.tolil", "features.tolil", "features.tolil", "numpy.eye", "print", "print", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "nettack.compute_alpha", "nettack.compute_log_likelihood", "len", "nettack.Nettack.modified_features.T.dot", "int", "print", "print", "print", "nettack.Nettack.ori_adj.sum", "nettack.Nettack.modified_adj.sum", "numpy.log", "numpy.log", "nettack.Nettack.get_attacker_nodes", "numpy.concatenate().astype", "numpy.row_stack", "numpy.column_stack", "numpy.array", "print", "nettack.filter_singletons", "nettack.update_Sx", "nettack.compute_alpha", "nettack.compute_log_likelihood", "nettack.compute_alpha", "nettack.compute_log_likelihood", "nettack.filter_chisquare", "nettack.Nettack.compute_new_a_hat_uv", "nettack.Nettack.struct_score", "nettack.Nettack.argmin", "nettack.Nettack.min", "nettack.Nettack.feature_scores", "deeprobust.graph.utils.normalize_adj", "nettack.Nettack.structure_perturbations.append", "nettack.Nettack.feature_perturbations.append", "surrogate_losses.append", "nettack.Nettack.feature_perturbations.append", "nettack.Nettack.structure_perturbations.append", "surrogate_losses.append", "deeprobust.graph.utils.to_scipy", "deeprobust.graph.utils.to_scipy", "deeprobust.graph.utils.to_scipy", "deeprobust.graph.utils.to_scipy", "print", "print", "tuple", "tuple", "print", "numpy.concatenate", "numpy.column_stack", "numpy.tile", "numpy.setdiff1d", "print", "print", "tuple", "tuple", "tuple", "numpy.arange", "tuple", "tuple", "numpy.tile", "numpy.setdiff1d", "nettack.Nettack.modified_adj[].toarray", "numpy.arange", "numpy.array", "tuple"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.get_linearized_weight", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.get_attacker_nodes", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.filter_singletons", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.update_Sx", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.filter_chisquare", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_new_a_hat_uv", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.struct_score", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.feature_scores", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy"], ["", "def", "attack", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "target_node", ",", "n_perturbations", ",", "direct", "=", "True", ",", "n_influencers", "=", "0", ",", "ll_cutoff", "=", "0.004", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features : torch.Tensor or scipy.sparse.csr_matrix\n            Origina (unperturbed) node feature matrix. Note that\n            torch.Tensor will be automatically transformed into\n            scipy.sparse.csr_matrix\n        ori_adj : torch.Tensor or scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix. Note that\n            torch.Tensor will be automatically transformed into\n            scipy.sparse.csr_matrix\n        labels :\n            node labels\n        target_node : int\n            target node index to be attacked\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        direct: bool\n            whether to conduct direct attack\n        n_influencers:\n            number of influencer nodes when performing indirect attack.\n            (setting `direct` to False). When `direct` is True, it would be ignored.\n        ll_cutoff : float\n            The critical value for the likelihood ratio test of the power law distributions.\n            See the Chi square distribution with one degree of freedom. Default value 0.004\n            corresponds to a p-value of roughly 0.95.\n        verbose : bool\n            whether to show verbose logs\n        \"\"\"", "\n", "\n", "if", "self", ".", "nnodes", "is", "None", ":", "\n", "            ", "self", ".", "nnodes", "=", "adj", ".", "shape", "[", "0", "]", "\n", "\n", "", "self", ".", "target_node", "=", "target_node", "\n", "\n", "if", "type", "(", "adj", ")", "is", "torch", ".", "Tensor", ":", "\n", "            ", "self", ".", "ori_adj", "=", "utils", ".", "to_scipy", "(", "adj", ")", ".", "tolil", "(", ")", "\n", "self", ".", "modified_adj", "=", "utils", ".", "to_scipy", "(", "adj", ")", ".", "tolil", "(", ")", "\n", "self", ".", "ori_features", "=", "utils", ".", "to_scipy", "(", "features", ")", ".", "tolil", "(", ")", "\n", "self", ".", "modified_features", "=", "utils", ".", "to_scipy", "(", "features", ")", ".", "tolil", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ori_adj", "=", "adj", ".", "tolil", "(", ")", "\n", "self", ".", "modified_adj", "=", "adj", ".", "tolil", "(", ")", "\n", "self", ".", "ori_features", "=", "features", ".", "tolil", "(", ")", "\n", "self", ".", "modified_features", "=", "features", ".", "tolil", "(", ")", "\n", "\n", "", "self", ".", "cooc_matrix", "=", "self", ".", "modified_features", ".", "T", ".", "dot", "(", "self", ".", "modified_features", ")", ".", "tolil", "(", ")", "\n", "\n", "attack_features", "=", "self", ".", "attack_features", "\n", "attack_structure", "=", "self", ".", "attack_structure", "\n", "assert", "not", "(", "direct", "==", "False", "and", "n_influencers", "==", "0", ")", ",", "\"indirect mode requires at least one influencer node\"", "\n", "assert", "n_perturbations", ">", "0", ",", "\"need at least one perturbation\"", "\n", "assert", "attack_features", "or", "attack_structure", ",", "\"either attack_features or attack_structure must be true\"", "\n", "\n", "# adj_norm = utils.normalize_adj_tensor(modified_adj, sparse=True)", "\n", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj", "(", "self", ".", "modified_adj", ")", "\n", "self", ".", "W", "=", "self", ".", "get_linearized_weight", "(", ")", "\n", "\n", "logits", "=", "(", "self", ".", "adj_norm", "@", "self", ".", "adj_norm", "@", "self", ".", "modified_features", "@", "self", ".", "W", ")", "[", "target_node", "]", "\n", "\n", "self", ".", "label_u", "=", "labels", "[", "target_node", "]", "\n", "label_target_onehot", "=", "np", ".", "eye", "(", "int", "(", "self", ".", "nclass", ")", ")", "[", "labels", "[", "target_node", "]", "]", "\n", "best_wrong_class", "=", "(", "logits", "-", "1000", "*", "label_target_onehot", ")", ".", "argmax", "(", ")", "\n", "surrogate_losses", "=", "[", "logits", "[", "labels", "[", "target_node", "]", "]", "-", "logits", "[", "best_wrong_class", "]", "]", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"##### Starting attack #####\"", ")", "\n", "if", "attack_structure", "and", "attack_features", ":", "\n", "                ", "print", "(", "\"##### Attack node with ID {} using structure and feature perturbations #####\"", ".", "format", "(", "target_node", ")", ")", "\n", "", "elif", "attack_features", ":", "\n", "                ", "print", "(", "\"##### Attack only using feature perturbations #####\"", ")", "\n", "", "elif", "attack_structure", ":", "\n", "                ", "print", "(", "\"##### Attack only using structure perturbations #####\"", ")", "\n", "", "if", "direct", ":", "\n", "                ", "print", "(", "\"##### Attacking the node directly #####\"", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"##### Attacking the node indirectly via {} influencer nodes #####\"", ".", "format", "(", "n_influencers", ")", ")", "\n", "", "print", "(", "\"##### Performing {} perturbations #####\"", ".", "format", "(", "n_perturbations", ")", ")", "\n", "\n", "", "if", "attack_structure", ":", "\n", "# Setup starting values of the likelihood ratio test.", "\n", "            ", "degree_sequence_start", "=", "self", ".", "ori_adj", ".", "sum", "(", "0", ")", ".", "A1", "\n", "current_degree_sequence", "=", "self", ".", "modified_adj", ".", "sum", "(", "0", ")", ".", "A1", "\n", "d_min", "=", "2", "\n", "\n", "S_d_start", "=", "np", ".", "sum", "(", "np", ".", "log", "(", "degree_sequence_start", "[", "degree_sequence_start", ">=", "d_min", "]", ")", ")", "\n", "current_S_d", "=", "np", ".", "sum", "(", "np", ".", "log", "(", "current_degree_sequence", "[", "current_degree_sequence", ">=", "d_min", "]", ")", ")", "\n", "n_start", "=", "np", ".", "sum", "(", "degree_sequence_start", ">=", "d_min", ")", "\n", "current_n", "=", "np", ".", "sum", "(", "current_degree_sequence", ">=", "d_min", ")", "\n", "alpha_start", "=", "compute_alpha", "(", "n_start", ",", "S_d_start", ",", "d_min", ")", "\n", "\n", "log_likelihood_orig", "=", "compute_log_likelihood", "(", "n_start", ",", "alpha_start", ",", "S_d_start", ",", "d_min", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "influencer_nodes", ")", "==", "0", ":", "\n", "            ", "if", "not", "direct", ":", "\n", "# Choose influencer nodes", "\n", "                ", "infls", ",", "add_infls", "=", "self", ".", "get_attacker_nodes", "(", "n_influencers", ",", "add_additional_nodes", "=", "True", ")", "\n", "self", ".", "influencer_nodes", "=", "np", ".", "concatenate", "(", "(", "infls", ",", "add_infls", ")", ")", ".", "astype", "(", "\"int\"", ")", "\n", "# Potential edges are all edges from any attacker to any other node, except the respective", "\n", "# attacker itself or the node being attacked.", "\n", "self", ".", "potential_edges", "=", "np", ".", "row_stack", "(", "[", "np", ".", "column_stack", "(", "(", "np", ".", "tile", "(", "infl", ",", "self", ".", "nnodes", "-", "2", ")", ",", "\n", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "self", ".", "nnodes", ")", ",", "\n", "np", ".", "array", "(", "[", "target_node", ",", "infl", "]", ")", ")", ")", ")", "for", "infl", "in", "\n", "self", ".", "influencer_nodes", "]", ")", "\n", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"Influencer nodes: {}\"", ".", "format", "(", "self", ".", "influencer_nodes", ")", ")", "\n", "", "", "else", ":", "\n", "# direct attack", "\n", "                ", "influencers", "=", "[", "target_node", "]", "\n", "self", ".", "potential_edges", "=", "np", ".", "column_stack", "(", "(", "np", ".", "tile", "(", "target_node", ",", "self", ".", "nnodes", "-", "1", ")", ",", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "self", ".", "nnodes", ")", ",", "target_node", ")", ")", ")", "\n", "self", ".", "influencer_nodes", "=", "np", ".", "array", "(", "influencers", ")", "\n", "\n", "", "", "self", ".", "potential_edges", "=", "self", ".", "potential_edges", ".", "astype", "(", "\"int32\"", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_perturbations", ")", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "\"##### ...{}/{} perturbations ... #####\"", ".", "format", "(", "_", "+", "1", ",", "n_perturbations", ")", ")", "\n", "", "if", "attack_structure", ":", "\n", "\n", "# Do not consider edges that, if removed, result in singleton edges in the graph.", "\n", "                ", "singleton_filter", "=", "filter_singletons", "(", "self", ".", "potential_edges", ",", "self", ".", "modified_adj", ")", "\n", "filtered_edges", "=", "self", ".", "potential_edges", "[", "singleton_filter", "]", "\n", "\n", "# Update the values for the power law likelihood ratio test.", "\n", "\n", "deltas", "=", "2", "*", "(", "1", "-", "self", ".", "modified_adj", "[", "tuple", "(", "filtered_edges", ".", "T", ")", "]", ".", "toarray", "(", ")", "[", "0", "]", ")", "-", "1", "\n", "d_edges_old", "=", "current_degree_sequence", "[", "filtered_edges", "]", "\n", "d_edges_new", "=", "current_degree_sequence", "[", "filtered_edges", "]", "+", "deltas", "[", ":", ",", "None", "]", "\n", "new_S_d", ",", "new_n", "=", "update_Sx", "(", "current_S_d", ",", "current_n", ",", "d_edges_old", ",", "d_edges_new", ",", "d_min", ")", "\n", "new_alphas", "=", "compute_alpha", "(", "new_n", ",", "new_S_d", ",", "d_min", ")", "\n", "new_ll", "=", "compute_log_likelihood", "(", "new_n", ",", "new_alphas", ",", "new_S_d", ",", "d_min", ")", "\n", "alphas_combined", "=", "compute_alpha", "(", "new_n", "+", "n_start", ",", "new_S_d", "+", "S_d_start", ",", "d_min", ")", "\n", "new_ll_combined", "=", "compute_log_likelihood", "(", "new_n", "+", "n_start", ",", "alphas_combined", ",", "new_S_d", "+", "S_d_start", ",", "d_min", ")", "\n", "new_ratios", "=", "-", "2", "*", "new_ll_combined", "+", "2", "*", "(", "new_ll", "+", "log_likelihood_orig", ")", "\n", "\n", "# Do not consider edges that, if added/removed, would lead to a violation of the", "\n", "# likelihood ration Chi_square cutoff value.", "\n", "powerlaw_filter", "=", "filter_chisquare", "(", "new_ratios", ",", "ll_cutoff", ")", "\n", "filtered_edges_final", "=", "filtered_edges", "[", "powerlaw_filter", "]", "\n", "\n", "# Compute new entries in A_hat_square_uv", "\n", "a_hat_uv_new", "=", "self", ".", "compute_new_a_hat_uv", "(", "filtered_edges_final", ",", "target_node", ")", "\n", "# Compute the struct scores for each potential edge", "\n", "struct_scores", "=", "self", ".", "struct_score", "(", "a_hat_uv_new", ",", "self", ".", "modified_features", "@", "self", ".", "W", ")", "\n", "best_edge_ix", "=", "struct_scores", ".", "argmin", "(", ")", "\n", "best_edge_score", "=", "struct_scores", ".", "min", "(", ")", "\n", "best_edge", "=", "filtered_edges_final", "[", "best_edge_ix", "]", "\n", "\n", "", "if", "attack_features", ":", "\n", "# Compute the feature scores for each potential feature perturbation", "\n", "                ", "feature_ixs", ",", "feature_scores", "=", "self", ".", "feature_scores", "(", ")", "\n", "best_feature_ix", "=", "feature_ixs", "[", "0", "]", "\n", "best_feature_score", "=", "feature_scores", "[", "0", "]", "\n", "\n", "", "if", "attack_structure", "and", "attack_features", ":", "\n", "# decide whether to choose an edge or feature to change", "\n", "                ", "if", "best_edge_score", "<", "best_feature_score", ":", "\n", "                    ", "if", "verbose", ":", "\n", "                        ", "print", "(", "\"Edge perturbation: {}\"", ".", "format", "(", "best_edge", ")", ")", "\n", "", "change_structure", "=", "True", "\n", "", "else", ":", "\n", "                    ", "if", "verbose", ":", "\n", "                        ", "print", "(", "\"Feature perturbation: {}\"", ".", "format", "(", "best_feature_ix", ")", ")", "\n", "", "change_structure", "=", "False", "\n", "\n", "", "", "elif", "attack_structure", ":", "\n", "                ", "change_structure", "=", "True", "\n", "", "elif", "attack_features", ":", "\n", "                ", "change_structure", "=", "False", "\n", "\n", "", "if", "change_structure", ":", "\n", "# perform edge perturbation", "\n", "                ", "self", ".", "modified_adj", "[", "tuple", "(", "best_edge", ")", "]", "=", "self", ".", "modified_adj", "[", "tuple", "(", "best_edge", "[", ":", ":", "-", "1", "]", ")", "]", "=", "1", "-", "self", ".", "modified_adj", "[", "tuple", "(", "best_edge", ")", "]", "\n", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj", "(", "self", ".", "modified_adj", ")", "\n", "\n", "self", ".", "structure_perturbations", ".", "append", "(", "tuple", "(", "best_edge", ")", ")", "\n", "self", ".", "feature_perturbations", ".", "append", "(", "(", ")", ")", "\n", "surrogate_losses", ".", "append", "(", "best_edge_score", ")", "\n", "\n", "# Update likelihood ratio test values", "\n", "current_S_d", "=", "new_S_d", "[", "powerlaw_filter", "]", "[", "best_edge_ix", "]", "\n", "current_n", "=", "new_n", "[", "powerlaw_filter", "]", "[", "best_edge_ix", "]", "\n", "current_degree_sequence", "[", "best_edge", "]", "+=", "deltas", "[", "powerlaw_filter", "]", "[", "best_edge_ix", "]", "\n", "\n", "", "else", ":", "\n", "                ", "self", ".", "modified_features", "[", "tuple", "(", "best_feature_ix", ")", "]", "=", "1", "-", "self", ".", "modified_features", "[", "tuple", "(", "best_feature_ix", ")", "]", "\n", "self", ".", "feature_perturbations", ".", "append", "(", "tuple", "(", "best_feature_ix", ")", ")", "\n", "self", ".", "structure_perturbations", ".", "append", "(", "(", ")", ")", "\n", "surrogate_losses", ".", "append", "(", "best_feature_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.get_attacker_nodes": [[299, 342], ["numpy.column_stack().astype", "nettack.Nettack.compute_new_a_hat_uv", "nettack.Nettack.struct_score", "nettack.Nettack.ori_adj[].nonzero", "len", "numpy.column_stack", "numpy.setdiff1d", "len", "numpy.column_stack", "nettack.Nettack.compute_new_a_hat_uv", "nettack.Nettack.struct_score", "numpy.array", "numpy.setdiff1d", "len", "numpy.tile", "numpy.argsort", "numpy.arange", "numpy.tile", "len", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_new_a_hat_uv", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.struct_score", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_new_a_hat_uv", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.struct_score"], ["", "", "", "def", "get_attacker_nodes", "(", "self", ",", "n", "=", "5", ",", "add_additional_nodes", "=", "False", ")", ":", "\n", "        ", "\"\"\"Determine the influencer nodes to attack node i based on\n        the weights W and the attributes X.\n        \"\"\"", "\n", "assert", "n", "<", "self", ".", "nnodes", "-", "1", ",", "\"number of influencers cannot be >= number of nodes in the graph!\"", "\n", "neighbors", "=", "self", ".", "ori_adj", "[", "self", ".", "target_node", "]", ".", "nonzero", "(", ")", "[", "1", "]", "\n", "assert", "self", ".", "target_node", "not", "in", "neighbors", "\n", "\n", "potential_edges", "=", "np", ".", "column_stack", "(", "(", "np", ".", "tile", "(", "self", ".", "target_node", ",", "len", "(", "neighbors", ")", ")", ",", "neighbors", ")", ")", ".", "astype", "(", "\"int32\"", ")", "\n", "\n", "# The new A_hat_square_uv values that we would get if we removed the edge from u to each of the neighbors, respectively", "\n", "a_hat_uv", "=", "self", ".", "compute_new_a_hat_uv", "(", "potential_edges", ",", "self", ".", "target_node", ")", "\n", "\n", "# XW = self.compute_XW()", "\n", "XW", "=", "self", ".", "modified_features", "@", "self", ".", "W", "\n", "\n", "# compute the struct scores for all neighbors", "\n", "struct_scores", "=", "self", ".", "struct_score", "(", "a_hat_uv", ",", "XW", ")", "\n", "if", "len", "(", "neighbors", ")", ">=", "n", ":", "# do we have enough neighbors for the number of desired influencers?", "\n", "            ", "influencer_nodes", "=", "neighbors", "[", "np", ".", "argsort", "(", "struct_scores", ")", "[", ":", "n", "]", "]", "\n", "if", "add_additional_nodes", ":", "\n", "                ", "return", "influencer_nodes", ",", "np", ".", "array", "(", "[", "]", ")", "\n", "", "return", "influencer_nodes", "\n", "", "else", ":", "\n", "\n", "            ", "influencer_nodes", "=", "neighbors", "\n", "if", "add_additional_nodes", ":", "# Add additional influencers by connecting them to u first.", "\n", "# Compute the set of possible additional influencers, i.e. all nodes except the ones", "\n", "# that are already connected to u.", "\n", "                ", "poss_add_infl", "=", "np", ".", "setdiff1d", "(", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "self", ".", "nnodes", ")", ",", "neighbors", ")", ",", "self", ".", "target_node", ")", "\n", "n_possible_additional", "=", "len", "(", "poss_add_infl", ")", "\n", "n_additional_attackers", "=", "n", "-", "len", "(", "neighbors", ")", "\n", "possible_edges", "=", "np", ".", "column_stack", "(", "(", "np", ".", "tile", "(", "self", ".", "target_node", ",", "n_possible_additional", ")", ",", "poss_add_infl", ")", ")", "\n", "\n", "# Compute the struct_scores for all possible additional influencers, and choose the one", "\n", "# with the best struct score.", "\n", "a_hat_uv_additional", "=", "self", ".", "compute_new_a_hat_uv", "(", "possible_edges", ",", "self", ".", "target_node", ")", "\n", "additional_struct_scores", "=", "self", ".", "struct_score", "(", "a_hat_uv_additional", ",", "XW", ")", "\n", "additional_influencers", "=", "poss_add_infl", "[", "np", ".", "argsort", "(", "additional_struct_scores", ")", "[", "-", "n_additional_attackers", ":", ":", "]", "]", "\n", "\n", "return", "influencer_nodes", ",", "additional_influencers", "\n", "", "else", ":", "\n", "                ", "return", "influencer_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.compute_logits": [[343, 345], ["None"], "methods", ["None"], ["", "", "", "def", "compute_logits", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "adj_norm", "@", "self", ".", "adj_norm", "@", "self", ".", "modified_features", "@", "self", ".", "W", ")", "[", "self", ".", "target_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.strongest_wrong_class": [[346, 349], ["numpy.eye"], "methods", ["None"], ["", "def", "strongest_wrong_class", "(", "self", ",", "logits", ")", ":", "\n", "        ", "label_u_onehot", "=", "np", ".", "eye", "(", "self", ".", "nclass", ")", "[", "self", ".", "label_u", "]", "\n", "return", "(", "logits", "-", "1000", "*", "label_u_onehot", ")", ".", "argmax", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.feature_scores": [[350, 376], ["nettack.Nettack.compute_logits", "nettack.Nettack.strongest_wrong_class", "scipy.lil_matrix", "scipy.lil_matrix", "gradients_flipped.multiply.multiply.multiply", "nettack.Nettack.compute_cooccurrence_constraint", "nettack.Nettack.gradient_wrt_x", "nettack.Nettack.gradient_wrt_x", "numpy.array", "numpy.argsort", "nettack.Nettack.modified_features.nonzero", "gradients_flipped.multiply.multiply.nonzero", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.compute_logits", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.strongest_wrong_class", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.compute_cooccurrence_constraint", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.gradient_wrt_x", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.gradient_wrt_x"], ["", "def", "feature_scores", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute feature scores for all possible feature changes.\n        \"\"\"", "\n", "\n", "if", "self", ".", "cooc_constraint", "is", "None", ":", "\n", "            ", "self", ".", "compute_cooccurrence_constraint", "(", "self", ".", "influencer_nodes", ")", "\n", "", "logits", "=", "self", ".", "compute_logits", "(", ")", "\n", "best_wrong_class", "=", "self", ".", "strongest_wrong_class", "(", "logits", ")", "\n", "surrogate_loss", "=", "logits", "[", "self", ".", "label_u", "]", "-", "logits", "[", "best_wrong_class", "]", "\n", "\n", "gradient", "=", "self", ".", "gradient_wrt_x", "(", "self", ".", "label_u", ")", "-", "self", ".", "gradient_wrt_x", "(", "best_wrong_class", ")", "\n", "# gradients_flipped = (gradient * -1).tolil()", "\n", "gradients_flipped", "=", "sp", ".", "lil_matrix", "(", "gradient", "*", "-", "1", ")", "\n", "gradients_flipped", "[", "self", ".", "modified_features", ".", "nonzero", "(", ")", "]", "*=", "-", "1", "\n", "\n", "X_influencers", "=", "sp", ".", "lil_matrix", "(", "self", ".", "modified_features", ".", "shape", ")", "\n", "X_influencers", "[", "self", ".", "influencer_nodes", "]", "=", "self", ".", "modified_features", "[", "self", ".", "influencer_nodes", "]", "\n", "gradients_flipped", "=", "gradients_flipped", ".", "multiply", "(", "(", "self", ".", "cooc_constraint", "+", "X_influencers", ")", ">", "0", ")", "\n", "nnz_ixs", "=", "np", ".", "array", "(", "gradients_flipped", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "\n", "sorting", "=", "np", ".", "argsort", "(", "gradients_flipped", "[", "tuple", "(", "nnz_ixs", ".", "T", ")", "]", ")", ".", "A1", "\n", "sorted_ixs", "=", "nnz_ixs", "[", "sorting", "]", "\n", "grads", "=", "gradients_flipped", "[", "tuple", "(", "nnz_ixs", "[", "sorting", "]", ".", "T", ")", "]", "\n", "\n", "scores", "=", "surrogate_loss", "-", "grads", "\n", "return", "sorted_ixs", "[", ":", ":", "-", "1", "]", ",", "scores", ".", "A1", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.compute_cooccurrence_constraint": [[377, 416], ["nettack.Nettack.cooc_matrix.copy", "nettack.Nettack.setdiag", "numpy.reciprocal", "numpy.zeros", "range", "scipy.lil_matrix", "scipy.csr_matrix", "numpy.sum", "numpy.sum", "nettack.Nettack.multiply", "numpy.array", "word_degrees.astype", "nettack.Nettack.modified_features[].nonzero", "nettack.Nettack.multiply.nonzero", "idegs[].sum", "n_idx.tolist", "nettack.Nettack.multiply.nonzero", "range"], "methods", ["None"], ["", "def", "compute_cooccurrence_constraint", "(", "self", ",", "nodes", ")", ":", "\n", "        ", "\"\"\"\n        Co-occurrence constraint as described in the paper.\n\n        Parameters\n        ----------\n        nodes: np.array\n            Nodes whose features are considered for change\n\n        Returns\n        -------\n        np.array [len(nodes), D], dtype bool\n            Binary matrix of dimension len(nodes) x D. A 1 in entry n,d indicates that\n            we are allowed to add feature d to the features of node n.\n\n        \"\"\"", "\n", "\n", "words_graph", "=", "self", ".", "cooc_matrix", ".", "copy", "(", ")", "\n", "D", "=", "self", ".", "modified_features", ".", "shape", "[", "1", "]", "\n", "words_graph", ".", "setdiag", "(", "0", ")", "\n", "words_graph", "=", "(", "words_graph", ">", "0", ")", "\n", "word_degrees", "=", "np", ".", "sum", "(", "words_graph", ",", "axis", "=", "0", ")", ".", "A1", "\n", "\n", "inv_word_degrees", "=", "np", ".", "reciprocal", "(", "word_degrees", ".", "astype", "(", "float", ")", "+", "1e-8", ")", "\n", "\n", "sd", "=", "np", ".", "zeros", "(", "[", "self", ".", "nnodes", "]", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "nnodes", ")", ":", "\n", "            ", "n_idx", "=", "self", ".", "modified_features", "[", "n", ",", ":", "]", ".", "nonzero", "(", ")", "[", "1", "]", "\n", "sd", "[", "n", "]", "=", "np", ".", "sum", "(", "inv_word_degrees", "[", "n_idx", ".", "tolist", "(", ")", "]", ")", "\n", "\n", "", "scores_matrix", "=", "sp", ".", "lil_matrix", "(", "(", "self", ".", "nnodes", ",", "D", ")", ")", "\n", "\n", "for", "n", "in", "nodes", ":", "\n", "            ", "common_words", "=", "words_graph", ".", "multiply", "(", "self", ".", "modified_features", "[", "n", "]", ")", "\n", "idegs", "=", "inv_word_degrees", "[", "common_words", ".", "nonzero", "(", ")", "[", "1", "]", "]", "\n", "nnz", "=", "common_words", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "scores", "=", "np", ".", "array", "(", "[", "idegs", "[", "nnz", "==", "ix", "]", ".", "sum", "(", ")", "for", "ix", "in", "range", "(", "D", ")", "]", ")", "\n", "scores_matrix", "[", "n", "]", "=", "scores", "\n", "", "self", ".", "cooc_constraint", "=", "sp", ".", "csr_matrix", "(", "scores_matrix", "-", "0.5", "*", "sd", "[", ":", ",", "None", "]", ">", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.gradient_wrt_x": [[417, 420], ["[].T.dot", "nettack.Nettack.W[].reshape", "nettack.Nettack.adj_norm.dot"], "methods", ["None"], ["", "def", "gradient_wrt_x", "(", "self", ",", "label", ")", ":", "\n", "# return self.adj_norm.dot(self.adj_norm)[self.target_node].T.dot(self.W[:, label].T)", "\n", "        ", "return", "self", ".", "adj_norm", ".", "dot", "(", "self", ".", "adj_norm", ")", "[", "self", ".", "target_node", "]", ".", "T", ".", "dot", "(", "self", ".", "W", "[", ":", ",", "label", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.reset": [[421, 431], ["nettack.Nettack.ori_adj.copy", "nettack.Nettack.ori_features.copy"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reset Nettack\n        \"\"\"", "\n", "self", ".", "modified_adj", "=", "self", ".", "ori_adj", ".", "copy", "(", ")", "\n", "self", ".", "modified_features", "=", "self", ".", "ori_features", ".", "copy", "(", ")", "\n", "self", ".", "structure_perturbations", "=", "[", "]", "\n", "self", ".", "feature_perturbations", "=", "[", "]", "\n", "self", ".", "influencer_nodes", "=", "[", "]", "\n", "self", ".", "potential_edges", "=", "[", "]", "\n", "self", ".", "cooc_constraint", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.struct_score": [[433, 458], ["a_hat_uv.dot", "numpy.eye"], "methods", ["None"], ["", "def", "struct_score", "(", "self", ",", "a_hat_uv", ",", "XW", ")", ":", "\n", "        ", "\"\"\"\n        Compute structure scores, cf. Eq. 15 in the paper\n\n        Parameters\n        ----------\n        a_hat_uv: sp.sparse_matrix, shape [P,2]\n            Entries of matrix A_hat^2_u for each potential edge (see paper for explanation)\n\n        XW: sp.sparse_matrix, shape [N, K], dtype float\n            The class logits for each node.\n\n        Returns\n        -------\n        np.array [P,]\n            The struct score for every row in a_hat_uv\n        \"\"\"", "\n", "\n", "logits", "=", "a_hat_uv", ".", "dot", "(", "XW", ")", "\n", "label_onehot", "=", "np", ".", "eye", "(", "XW", ".", "shape", "[", "1", "]", ")", "[", "self", ".", "label_u", "]", "\n", "best_wrong_class_logits", "=", "(", "logits", "-", "1000", "*", "label_onehot", ")", ".", "max", "(", "1", ")", "\n", "logits_for_correct_class", "=", "logits", "[", ":", ",", "self", ".", "label_u", "]", "\n", "struct_scores", "=", "logits_for_correct_class", "-", "best_wrong_class_logits", "\n", "\n", "return", "struct_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.Nettack.compute_new_a_hat_uv": [[459, 488], ["nettack.Nettack.compute_new_a_hat_uv"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_new_a_hat_uv"], ["", "def", "compute_new_a_hat_uv", "(", "self", ",", "potential_edges", ",", "target_node", ")", ":", "\n", "        ", "\"\"\"\n        Compute the updated A_hat_square_uv entries that would result from inserting/deleting the input edges,\n        for every edge.\n\n        Parameters\n        ----------\n        potential_edges: np.array, shape [P,2], dtype int\n            The edges to check.\n\n        Returns\n        -------\n        sp.sparse_matrix: updated A_hat_square_u entries, a sparse PxN matrix, where P is len(possible_edges).\n        \"\"\"", "\n", "\n", "edges", "=", "np", ".", "array", "(", "self", ".", "modified_adj", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "edges_set", "=", "{", "tuple", "(", "x", ")", "for", "x", "in", "edges", "}", "\n", "A_hat_sq", "=", "self", ".", "adj_norm", "@", "self", ".", "adj_norm", "\n", "values_before", "=", "A_hat_sq", "[", "target_node", "]", ".", "toarray", "(", ")", "[", "0", "]", "\n", "node_ixs", "=", "np", ".", "unique", "(", "edges", "[", ":", ",", "0", "]", ",", "return_index", "=", "True", ")", "[", "1", "]", "\n", "twohop_ixs", "=", "np", ".", "array", "(", "A_hat_sq", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "degrees", "=", "self", ".", "modified_adj", ".", "sum", "(", "0", ")", ".", "A1", "+", "1", "\n", "\n", "ixs", ",", "vals", "=", "compute_new_a_hat_uv", "(", "edges", ",", "node_ixs", ",", "edges_set", ",", "twohop_ixs", ",", "values_before", ",", "degrees", ",", "\n", "potential_edges", ".", "astype", "(", "np", ".", "int32", ")", ",", "target_node", ")", "\n", "ixs_arr", "=", "np", ".", "array", "(", "ixs", ")", "\n", "a_hat_uv", "=", "sp", ".", "coo_matrix", "(", "(", "vals", ",", "(", "ixs_arr", "[", ":", ",", "0", "]", ",", "ixs_arr", "[", ":", ",", "1", "]", ")", ")", ",", "shape", "=", "[", "len", "(", "potential_edges", ")", ",", "self", ".", "nnodes", "]", ")", "\n", "\n", "return", "a_hat_uv", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.connected_after": [[489, 498], ["numba.jit"], "function", ["None"], ["", "", "@", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "connected_after", "(", "u", ",", "v", ",", "connected_before", ",", "delta", ")", ":", "\n", "    ", "if", "u", "==", "v", ":", "\n", "        ", "if", "delta", "==", "-", "1", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "", "", "else", ":", "\n", "        ", "return", "connected_before", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_new_a_hat_uv": [[500, 570], ["numba.jit", "set", "range", "len", "set", "degs.copy", "set", "affected_nodes.union.union", "nettack.connected_after", "nettack.connected_after", "numpy.concatenate", "set", "nettack.connected_after", "nettack.connected_after", "return_ixs.append", "return_values.append", "len", "numpy.sqrt", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.connected_after", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.connected_after", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.connected_after", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.connected_after"], ["", "", "@", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "compute_new_a_hat_uv", "(", "edge_ixs", ",", "node_nb_ixs", ",", "edges_set", ",", "twohop_ixs", ",", "values_before", ",", "degs", ",", "potential_edges", ",", "u", ")", ":", "\n", "    ", "\"\"\"\n    Compute the new values [A_hat_square]_u for every potential edge, where u is the target node. C.f. Theorem 5.1\n    equation 17.\n\n    \"\"\"", "\n", "N", "=", "degs", ".", "shape", "[", "0", "]", "\n", "\n", "twohop_u", "=", "twohop_ixs", "[", "twohop_ixs", "[", ":", ",", "0", "]", "==", "u", ",", "1", "]", "\n", "nbs_u", "=", "edge_ixs", "[", "edge_ixs", "[", ":", ",", "0", "]", "==", "u", ",", "1", "]", "\n", "nbs_u_set", "=", "set", "(", "nbs_u", ")", "\n", "\n", "return_ixs", "=", "[", "]", "\n", "return_values", "=", "[", "]", "\n", "\n", "for", "ix", "in", "range", "(", "len", "(", "potential_edges", ")", ")", ":", "\n", "        ", "edge", "=", "potential_edges", "[", "ix", "]", "\n", "edge_set", "=", "set", "(", "edge", ")", "\n", "degs_new", "=", "degs", ".", "copy", "(", ")", "\n", "delta", "=", "-", "2", "*", "(", "(", "edge", "[", "0", "]", ",", "edge", "[", "1", "]", ")", "in", "edges_set", ")", "+", "1", "\n", "degs_new", "[", "edge", "]", "+=", "delta", "\n", "\n", "nbs_edge0", "=", "edge_ixs", "[", "edge_ixs", "[", ":", ",", "0", "]", "==", "edge", "[", "0", "]", ",", "1", "]", "\n", "nbs_edge1", "=", "edge_ixs", "[", "edge_ixs", "[", ":", ",", "0", "]", "==", "edge", "[", "1", "]", ",", "1", "]", "\n", "\n", "affected_nodes", "=", "set", "(", "np", ".", "concatenate", "(", "(", "twohop_u", ",", "nbs_edge0", ",", "nbs_edge1", ")", ")", ")", "\n", "affected_nodes", "=", "affected_nodes", ".", "union", "(", "edge_set", ")", "\n", "a_um", "=", "edge", "[", "0", "]", "in", "nbs_u_set", "\n", "a_un", "=", "edge", "[", "1", "]", "in", "nbs_u_set", "\n", "\n", "a_un_after", "=", "connected_after", "(", "u", ",", "edge", "[", "0", "]", ",", "a_un", ",", "delta", ")", "\n", "a_um_after", "=", "connected_after", "(", "u", ",", "edge", "[", "1", "]", ",", "a_um", ",", "delta", ")", "\n", "\n", "for", "v", "in", "affected_nodes", ":", "\n", "            ", "a_uv_before", "=", "v", "in", "nbs_u_set", "\n", "a_uv_before_sl", "=", "a_uv_before", "or", "v", "==", "u", "\n", "\n", "if", "v", "in", "edge_set", "and", "u", "in", "edge_set", "and", "u", "!=", "v", ":", "\n", "                ", "if", "delta", "==", "-", "1", ":", "\n", "                    ", "a_uv_after", "=", "False", "\n", "", "else", ":", "\n", "                    ", "a_uv_after", "=", "True", "\n", "", "", "else", ":", "\n", "                ", "a_uv_after", "=", "a_uv_before", "\n", "", "a_uv_after_sl", "=", "a_uv_after", "or", "v", "==", "u", "\n", "\n", "from_ix", "=", "node_nb_ixs", "[", "v", "]", "\n", "to_ix", "=", "node_nb_ixs", "[", "v", "+", "1", "]", "if", "v", "<", "N", "-", "1", "else", "len", "(", "edge_ixs", ")", "\n", "node_nbs", "=", "edge_ixs", "[", "from_ix", ":", "to_ix", ",", "1", "]", "\n", "node_nbs_set", "=", "set", "(", "node_nbs", ")", "\n", "a_vm_before", "=", "edge", "[", "0", "]", "in", "node_nbs_set", "\n", "\n", "a_vn_before", "=", "edge", "[", "1", "]", "in", "node_nbs_set", "\n", "a_vn_after", "=", "connected_after", "(", "v", ",", "edge", "[", "0", "]", ",", "a_vn_before", ",", "delta", ")", "\n", "a_vm_after", "=", "connected_after", "(", "v", ",", "edge", "[", "1", "]", ",", "a_vm_before", ",", "delta", ")", "\n", "\n", "mult_term", "=", "1", "/", "np", ".", "sqrt", "(", "degs_new", "[", "u", "]", "*", "degs_new", "[", "v", "]", ")", "\n", "\n", "sum_term1", "=", "np", ".", "sqrt", "(", "degs", "[", "u", "]", "*", "degs", "[", "v", "]", ")", "*", "values_before", "[", "v", "]", "-", "a_uv_before_sl", "/", "degs", "[", "u", "]", "-", "a_uv_before", "/", "degs", "[", "v", "]", "\n", "sum_term2", "=", "a_uv_after", "/", "degs_new", "[", "v", "]", "+", "a_uv_after_sl", "/", "degs_new", "[", "u", "]", "\n", "sum_term3", "=", "-", "(", "(", "a_um", "and", "a_vm_before", ")", "/", "degs", "[", "edge", "[", "0", "]", "]", ")", "+", "(", "a_um_after", "and", "a_vm_after", ")", "/", "degs_new", "[", "edge", "[", "0", "]", "]", "\n", "sum_term4", "=", "-", "(", "(", "a_un", "and", "a_vn_before", ")", "/", "degs", "[", "edge", "[", "1", "]", "]", ")", "+", "(", "a_un_after", "and", "a_vn_after", ")", "/", "degs_new", "[", "edge", "[", "1", "]", "]", "\n", "new_val", "=", "mult_term", "*", "(", "sum_term1", "+", "sum_term2", "+", "sum_term3", "+", "sum_term4", ")", "\n", "\n", "return_ixs", ".", "append", "(", "(", "ix", ",", "v", ")", ")", "\n", "return_values", ".", "append", "(", "new_val", ")", "\n", "\n", "", "", "return", "return_ixs", ",", "return_values", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.filter_singletons": [[571, 587], ["numpy.squeeze", "numpy.squeeze", "zeros.sum", "numpy.array", "numpy.array", "numpy.sum", "adj.tocsr", "tuple", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "filter_singletons", "(", "edges", ",", "adj", ")", ":", "\n", "    ", "\"\"\"\n    Filter edges that, if removed, would turn one or more nodes into singleton nodes.\n    \"\"\"", "\n", "\n", "\n", "degs", "=", "np", ".", "squeeze", "(", "np", ".", "array", "(", "np", ".", "sum", "(", "adj", ",", "0", ")", ")", ")", "\n", "existing_edges", "=", "np", ".", "squeeze", "(", "np", ".", "array", "(", "adj", ".", "tocsr", "(", ")", "[", "tuple", "(", "edges", ".", "T", ")", "]", ")", ")", "\n", "if", "existing_edges", ".", "size", ">", "0", ":", "\n", "        ", "edge_degrees", "=", "degs", "[", "np", ".", "array", "(", "edges", ")", "]", "+", "2", "*", "(", "1", "-", "existing_edges", "[", ":", ",", "None", "]", ")", "-", "1", "\n", "", "else", ":", "\n", "        ", "edge_degrees", "=", "degs", "[", "np", ".", "array", "(", "edges", ")", "]", "+", "1", "\n", "\n", "", "zeros", "=", "edge_degrees", "==", "0", "\n", "zeros_sum", "=", "zeros", ".", "sum", "(", "1", ")", "\n", "return", "zeros_sum", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_alpha": [[588, 595], ["numpy.log"], "function", ["None"], ["", "def", "compute_alpha", "(", "n", ",", "S_d", ",", "d_min", ")", ":", "\n", "    ", "\"\"\"\n    Approximate the alpha of a power law distribution.\n\n    \"\"\"", "\n", "\n", "return", "n", "/", "(", "S_d", "-", "n", "*", "np", ".", "log", "(", "d_min", "-", "0.5", ")", ")", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.update_Sx": [[597, 613], ["numpy.multiply", "numpy.multiply", "numpy.log().sum", "numpy.sum", "numpy.log().sum", "numpy.sum", "numpy.log", "numpy.log", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "def", "update_Sx", "(", "S_old", ",", "n_old", ",", "d_old", ",", "d_new", ",", "d_min", ")", ":", "\n", "    ", "\"\"\"\n    Update on the sum of log degrees S_d and n based on degree distribution resulting from inserting or deleting\n    a single edge.\n    \"\"\"", "\n", "\n", "old_in_range", "=", "d_old", ">=", "d_min", "\n", "new_in_range", "=", "d_new", ">=", "d_min", "\n", "\n", "d_old_in_range", "=", "np", ".", "multiply", "(", "d_old", ",", "old_in_range", ")", "\n", "d_new_in_range", "=", "np", ".", "multiply", "(", "d_new", ",", "new_in_range", ")", "\n", "\n", "new_S_d", "=", "S_old", "-", "np", ".", "log", "(", "np", ".", "maximum", "(", "d_old_in_range", ",", "1", ")", ")", ".", "sum", "(", "1", ")", "+", "np", ".", "log", "(", "np", ".", "maximum", "(", "d_new_in_range", ",", "1", ")", ")", ".", "sum", "(", "1", ")", "\n", "new_n", "=", "n_old", "-", "np", ".", "sum", "(", "old_in_range", ",", "1", ")", "+", "np", ".", "sum", "(", "new_in_range", ",", "1", ")", "\n", "\n", "return", "new_S_d", ",", "new_n", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.compute_log_likelihood": [[615, 622], ["numpy.log", "numpy.log"], "function", ["None"], ["", "def", "compute_log_likelihood", "(", "n", ",", "alpha", ",", "S_d", ",", "d_min", ")", ":", "\n", "    ", "\"\"\"\n    Compute log likelihood of the powerlaw fit.\n\n    \"\"\"", "\n", "\n", "return", "n", "*", "np", ".", "log", "(", "alpha", ")", "+", "n", "*", "alpha", "*", "np", ".", "log", "(", "d_min", ")", "+", "(", "alpha", "+", "1", ")", "*", "S_d", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.nettack.filter_chisquare": [[623, 625], ["None"], "function", ["None"], ["", "def", "filter_chisquare", "(", "ll_ratios", ",", "cutoff", ")", ":", "\n", "    ", "return", "ll_ratios", "<", "cutoff", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.fga.FGA.__init__": [[56, 66], ["deeprobust.graph.targeted_attack.BaseAttack.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "fga.FGA.feature_changes.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "FGA", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", "=", "attack_structure", ",", "attack_features", "=", "attack_features", ",", "device", "=", "device", ")", "\n", "\n", "\n", "assert", "not", "self", ".", "attack_features", ",", "\"not support attacking features\"", "\n", "\n", "if", "self", ".", "attack_features", ":", "\n", "            ", "self", ".", "feature_changes", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "feature_shape", ")", ")", "\n", "self", ".", "feature_changes", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.fga.FGA.attack": [[67, 122], ["ori_adj.todense", "ori_features.todense", "deeprobust.graph.utils.to_tensor", "fga.FGA.surrogate.eval", "fga.FGA.surrogate.predict().detach().argmax", "range", "scipy.csr_matrix.detach().cpu().numpy", "scipy.csr_matrix", "fga.FGA.check_adj", "print", "deeprobust.graph.utils.normalize_adj_tensor", "fga.FGA.surrogate.predict().detach", "fga.FGA.surrogate", "torch.nll_loss", "torch.nll_loss", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "scipy.csr_matrix.detach().cpu", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "fga.FGA.surrogate.predict", "scipy.csr_matrix.detach"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict"], ["", "", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "target_node", ",", "n_perturbations", ",", "verbose", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) node feature matrix\n        labels :\n            node labels\n        idx_train:\n            training node indices\n        target_node : int\n            target node index to be attacked\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        \"\"\"", "\n", "\n", "modified_adj", "=", "ori_adj", ".", "todense", "(", ")", "\n", "modified_features", "=", "ori_features", ".", "todense", "(", ")", "\n", "modified_adj", ",", "modified_features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "modified_adj", ",", "modified_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "self", ".", "surrogate", ".", "eval", "(", ")", "\n", "if", "verbose", "==", "True", ":", "\n", "            ", "print", "(", "'number of pertubations: %s'", "%", "n_perturbations", ")", "\n", "\n", "", "pseudo_labels", "=", "self", ".", "surrogate", ".", "predict", "(", ")", ".", "detach", "(", ")", ".", "argmax", "(", "1", ")", "\n", "pseudo_labels", "[", "idx_train", "]", "=", "labels", "[", "idx_train", "]", "\n", "\n", "modified_adj", ".", "requires_grad", "=", "True", "\n", "for", "i", "in", "range", "(", "n_perturbations", ")", ":", "\n", "            ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "modified_adj", ")", "\n", "\n", "if", "self", ".", "attack_structure", ":", "\n", "                ", "output", "=", "self", ".", "surrogate", "(", "modified_features", ",", "adj_norm", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", "[", "[", "target_node", "]", "]", ",", "pseudo_labels", "[", "[", "target_node", "]", "]", ")", "\n", "grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "modified_adj", ")", "[", "0", "]", "\n", "# bidirection", "\n", "grad", "=", "(", "grad", "[", "target_node", "]", "+", "grad", "[", ":", ",", "target_node", "]", ")", "*", "(", "-", "2", "*", "modified_adj", "[", "target_node", "]", "+", "1", ")", "\n", "grad", "[", "target_node", "]", "=", "-", "10", "\n", "grad_argmax", "=", "torch", ".", "argmax", "(", "grad", ")", "\n", "\n", "", "value", "=", "-", "2", "*", "modified_adj", "[", "target_node", "]", "[", "grad_argmax", "]", "+", "1", "\n", "modified_adj", ".", "data", "[", "target_node", "]", "[", "grad_argmax", "]", "+=", "value", "\n", "modified_adj", ".", "data", "[", "grad_argmax", "]", "[", "target_node", "]", "+=", "value", "\n", "\n", "if", "self", ".", "attack_features", ":", "\n", "                ", "pass", "\n", "\n", "", "", "modified_adj", "=", "modified_adj", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "modified_adj", "=", "sp", ".", "csr_matrix", "(", "modified_adj", ")", "\n", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "# self.modified_features = modified_features", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.__init__": [[64, 73], ["deeprobust.graph.targeted_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "nnodes", "=", "None", ",", "feature_shape", "=", "None", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "True", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "IGAttack", ",", "self", ")", ".", "__init__", "(", "model", ",", "nnodes", ",", "attack_structure", ",", "attack_features", ",", "device", ")", "\n", "\n", "assert", "attack_features", "or", "attack_structure", ",", "'attack_features or attack_structure cannot be both False'", "\n", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "self", ".", "target_node", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.attack": [[74, 143], ["ig_attack.IGAttack.surrogate.eval", "ori_adj.todense", "ori_features.todense", "deeprobust.graph.utils.to_tensor", "deeprobust.graph.utils.normalize_adj_tensor", "ig_attack.IGAttack.surrogate.predict().detach().argmax", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "scipy.csr_matrix", "scipy.csr_matrix", "scipy.csr_matrix", "scipy.csr_matrix", "ig_attack.IGAttack.check_adj", "ig_attack.IGAttack.calc_importance_edge", "ig_attack.IGAttack.calc_importance_feature", "numpy.argmax", "numpy.argmax", "numpy.argmax", "numpy.argmax", "ig_attack.IGAttack.surrogate.predict().detach", "numpy.abs", "numpy.abs", "Exception", "numpy.abs", "numpy.abs", "Exception", "ig_attack.IGAttack.surrogate.predict"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_edge", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_feature", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict"], ["", "def", "attack", "(", "self", ",", "ori_features", ",", "ori_adj", ",", "labels", ",", "idx_train", ",", "target_node", ",", "n_perturbations", ",", "steps", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate perturbations on the input graph.\n\n        Parameters\n        ----------\n        ori_features :\n            Original (unperturbed) node feature matrix\n        ori_adj :\n            Original (unperturbed) adjacency matrix\n        labels :\n            node labels\n        idx_train:\n            training nodes indices\n        target_node : int\n            target node index to be attacked\n        n_perturbations : int\n            Number of perturbations on the input graph. Perturbations could\n            be edge removals/additions or feature removals/additions.\n        steps : int\n            steps for computing integrated gradients\n        \"\"\"", "\n", "\n", "self", ".", "surrogate", ".", "eval", "(", ")", "\n", "self", ".", "target_node", "=", "target_node", "\n", "\n", "\n", "modified_adj", "=", "ori_adj", ".", "todense", "(", ")", "\n", "modified_features", "=", "ori_features", ".", "todense", "(", ")", "\n", "adj", ",", "features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "modified_adj", ",", "modified_features", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "\n", "pseudo_labels", "=", "self", ".", "surrogate", ".", "predict", "(", ")", ".", "detach", "(", ")", ".", "argmax", "(", "1", ")", "\n", "pseudo_labels", "[", "idx_train", "]", "=", "labels", "[", "idx_train", "]", "\n", "self", ".", "pseudo_labels", "=", "pseudo_labels", "\n", "\n", "s_e", "=", "np", ".", "zeros", "(", "adj", ".", "shape", "[", "1", "]", ")", "\n", "s_f", "=", "np", ".", "zeros", "(", "features", ".", "shape", "[", "1", "]", ")", "\n", "if", "self", ".", "attack_structure", ":", "\n", "            ", "s_e", "=", "self", ".", "calc_importance_edge", "(", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", "\n", "", "if", "self", ".", "attack_features", ":", "\n", "            ", "s_f", "=", "self", ".", "calc_importance_feature", "(", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", "\n", "\n", "", "for", "t", "in", "(", "range", "(", "n_perturbations", ")", ")", ":", "\n", "            ", "s_e_max", "=", "np", ".", "argmax", "(", "s_e", ")", "\n", "s_f_max", "=", "np", ".", "argmax", "(", "s_f", ")", "\n", "\n", "if", "s_e", "[", "s_e_max", "]", ">=", "s_f", "[", "s_f_max", "]", ":", "\n", "# edge perturbation score is larger", "\n", "                ", "if", "self", ".", "attack_structure", ":", "\n", "                    ", "value", "=", "np", ".", "abs", "(", "1", "-", "modified_adj", "[", "target_node", ",", "s_e_max", "]", ")", "\n", "modified_adj", "[", "target_node", ",", "s_e_max", "]", "=", "value", "\n", "modified_adj", "[", "s_e_max", ",", "target_node", "]", "=", "value", "\n", "s_e", "[", "s_e_max", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\"\"\"No posisble perturbation on the structure can be made!\n                            See https://github.com/DSE-MSU/DeepRobust/issues/42 for more details.\"\"\"", ")", "\n", "", "", "else", ":", "\n", "# feature perturbation score is larger", "\n", "                ", "if", "self", ".", "attack_features", ":", "\n", "                    ", "modified_features", "[", "target_node", ",", "s_f_max", "]", "=", "np", ".", "abs", "(", "1", "-", "modified_features", "[", "target_node", ",", "s_f_max", "]", ")", "\n", "s_f", "[", "s_f_max", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\"\"\"No posisble perturbation on the features can be made!\n                            See https://github.com/DSE-MSU/DeepRobust/issues/42 for more details.\"\"\"", ")", "\n", "\n", "\n", "", "", "", "self", ".", "modified_adj", "=", "sp", ".", "csr_matrix", "(", "modified_adj", ")", "\n", "self", ".", "modified_features", "=", "sp", ".", "csr_matrix", "(", "modified_features", ")", "\n", "self", ".", "check_adj", "(", "modified_adj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_edge": [[144, 186], ["adj_norm.clone", "adj_norm.clone", "tqdm.tqdm.tqdm", "numpy.array", "numpy.array", "range", "numpy.array.append", "ig_attack.IGAttack.surrogate", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "avg_grad.detach().item", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "_sum.mean", "_sum.mean", "range", "range", "avg_grad.detach", "float", "float"], "methods", ["None"], ["", "def", "calc_importance_edge", "(", "self", ",", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", ":", "\n", "        ", "\"\"\"Calculate integrated gradient for edges. Although I think the the gradient should be\n        with respect to adj instead of adj_norm, but the calculation is too time-consuming. So I\n        finally decided to calculate the gradient of loss with respect to adj_norm\n        \"\"\"", "\n", "baseline_add", "=", "adj_norm", ".", "clone", "(", ")", "\n", "baseline_remove", "=", "adj_norm", ".", "clone", "(", ")", "\n", "baseline_add", ".", "data", "[", "self", ".", "target_node", "]", "=", "1", "\n", "baseline_remove", ".", "data", "[", "self", ".", "target_node", "]", "=", "0", "\n", "adj_norm", ".", "requires_grad", "=", "True", "\n", "integrated_grad_list", "=", "[", "]", "\n", "\n", "i", "=", "self", ".", "target_node", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "adj_norm", ".", "shape", "[", "1", "]", ")", ")", ":", "\n", "            ", "if", "adj_norm", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_remove", "+", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "adj_norm", "-", "baseline_remove", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "else", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_add", "-", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "baseline_add", "-", "adj_norm", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "_sum", "=", "0", "\n", "\n", "for", "new_adj", "in", "scaled_inputs", ":", "\n", "                ", "output", "=", "self", ".", "surrogate", "(", "features", ",", "new_adj", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", "[", "[", "self", ".", "target_node", "]", "]", ",", "\n", "self", ".", "pseudo_labels", "[", "[", "self", ".", "target_node", "]", "]", ")", "\n", "adj_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "adj_norm", ")", "[", "0", "]", "\n", "adj_grad", "=", "adj_grad", "[", "i", "]", "[", "j", "]", "\n", "_sum", "+=", "adj_grad", "\n", "\n", "", "if", "adj_norm", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "avg_grad", "=", "(", "adj_norm", "[", "i", "]", "[", "j", "]", "-", "0", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "avg_grad", "=", "(", "1", "-", "adj_norm", "[", "i", "]", "[", "j", "]", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "\n", "", "integrated_grad_list", ".", "append", "(", "avg_grad", ".", "detach", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "integrated_grad_list", "[", "i", "]", "=", "0", "\n", "# make impossible perturbation to be negative", "\n", "integrated_grad_list", "=", "np", ".", "array", "(", "integrated_grad_list", ")", "\n", "adj", "=", "(", "adj_norm", ">", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "integrated_grad_list", "=", "(", "-", "2", "*", "adj", "[", "self", ".", "target_node", "]", "+", "1", ")", "*", "integrated_grad_list", "\n", "integrated_grad_list", "[", "self", ".", "target_node", "]", "=", "-", "10", "\n", "return", "integrated_grad_list", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.ig_attack.IGAttack.calc_importance_feature": [[187, 224], ["features.clone", "features.clone", "tqdm.tqdm.tqdm", "numpy.array", "numpy.array", "range", "numpy.array.append", "ig_attack.IGAttack.surrogate", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "avg_grad.detach().item", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "_sum.mean", "_sum.mean", "range", "range", "avg_grad.detach", "float", "float"], "methods", ["None"], ["", "def", "calc_importance_feature", "(", "self", ",", "features", ",", "adj_norm", ",", "labels", ",", "steps", ")", ":", "\n", "        ", "\"\"\"Calculate integrated gradient for features\n        \"\"\"", "\n", "baseline_add", "=", "features", ".", "clone", "(", ")", "\n", "baseline_remove", "=", "features", ".", "clone", "(", ")", "\n", "baseline_add", ".", "data", "[", "self", ".", "target_node", "]", "=", "1", "\n", "baseline_remove", ".", "data", "[", "self", ".", "target_node", "]", "=", "0", "\n", "\n", "features", ".", "requires_grad", "=", "True", "\n", "integrated_grad_list", "=", "[", "]", "\n", "i", "=", "self", ".", "target_node", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "features", ".", "shape", "[", "1", "]", ")", ")", ":", "\n", "            ", "if", "features", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_add", "+", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "features", "-", "baseline_add", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "else", ":", "\n", "                ", "scaled_inputs", "=", "[", "baseline_remove", "-", "(", "float", "(", "k", ")", "/", "steps", ")", "*", "(", "baseline_remove", "-", "features", ")", "for", "k", "in", "range", "(", "0", ",", "steps", "+", "1", ")", "]", "\n", "", "_sum", "=", "0", "\n", "\n", "for", "new_features", "in", "scaled_inputs", ":", "\n", "                ", "output", "=", "self", ".", "surrogate", "(", "new_features", ",", "adj_norm", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", "[", "[", "self", ".", "target_node", "]", "]", ",", "\n", "self", ".", "pseudo_labels", "[", "[", "self", ".", "target_node", "]", "]", ")", "\n", "\n", "feature_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "features", ")", "[", "0", "]", "\n", "feature_grad", "=", "feature_grad", "[", "i", "]", "[", "j", "]", "\n", "_sum", "+=", "feature_grad", "\n", "\n", "", "if", "features", "[", "i", "]", "[", "j", "]", ":", "\n", "                ", "avg_grad", "=", "(", "features", "[", "i", "]", "[", "j", "]", "-", "0", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "avg_grad", "=", "(", "1", "-", "features", "[", "i", "]", "[", "j", "]", ")", "*", "_sum", ".", "mean", "(", ")", "\n", "", "integrated_grad_list", ".", "append", "(", "avg_grad", ".", "detach", "(", ")", ".", "item", "(", ")", ")", "\n", "# make impossible perturbation to be negative", "\n", "", "features", "=", "(", "features", ">", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "integrated_grad_list", "=", "np", ".", "array", "(", "integrated_grad_list", ")", "\n", "integrated_grad_list", "=", "(", "-", "2", "*", "features", "[", "self", ".", "target_node", "]", "+", "1", ")", "*", "integrated_grad_list", "\n", "return", "integrated_grad_list", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.__init__": [[24, 40], ["torch.nn.modules.module.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["\n", "\n", "def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "BaseAttack", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "surrogate", "=", "model", "\n", "self", ".", "nnodes", "=", "nnodes", "\n", "self", ".", "attack_structure", "=", "attack_structure", "\n", "self", ".", "attack_features", "=", "attack_features", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "if", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "nclass", "=", "model", ".", "nclass", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.attack": [[41, 58], ["None"], "methods", ["None"], ["self", ".", "nfeat", "=", "model", ".", "nfeat", "\n", "self", ".", "hidden_sizes", "=", "model", ".", "hidden_sizes", "\n", "\n", "", "", "def", "attack", "(", "self", ",", "ori_adj", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate attacks on the input graph.\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        n_perturbations : int\n            Number of edge removals/additions.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.check_adj": [[59, 72], ["scipy.issparse", "type", "adj.cpu().numpy.cpu().numpy.cpu().numpy", "numpy.abs().sum", "adj.cpu().numpy.cpu().numpy.tocsr().max", "adj.cpu().numpy.cpu().numpy.tocsr().min", "adj.cpu().numpy.cpu().numpy.max", "adj.cpu().numpy.cpu().numpy.min", "adj.cpu().numpy.cpu().numpy.cpu", "numpy.abs", "adj.cpu().numpy.cpu().numpy.tocsr", "adj.cpu().numpy.cpu().numpy.tocsr"], "methods", ["None"], ["pass", "\n", "\n", "", "def", "check_adj", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric and unweighted.\n        \"\"\"", "\n", "assert", "np", ".", "abs", "(", "adj", "-", "adj", ".", "T", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "\n", "", "def", "check_adj_tensor", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric, unweighted, all-zero diagonal.\n        \"\"\"", "\n", "assert", "torch", ".", "abs", "(", "adj", "-", "adj", ".", "t", "(", ")", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.save_adj": [[73, 98], ["type", "utils.to_scipy", "scipy.save_npz", "scipy.save_npz", "osp.join", "osp.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy"], ["assert", "adj", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "diag", "=", "adj", ".", "diag", "(", ")", "\n", "assert", "diag", ".", "max", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "assert", "diag", ".", "min", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "\n", "\n", "", "def", "save_adj", "(", "self", ",", "root", "=", "r'/tmp/'", ",", "name", "=", "'mod_adj'", ")", ":", "\n", "        ", "\"\"\"Save attacked adjacency matrix.\n\n        Parameters\n        ----------\n        root :\n            root directory where the variable should be saved\n        name : str\n            saved file name\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "assert", "self", ".", "modified_adj", "is", "not", "None", ",", "'modified_adj is None! Please perturb the graph first.'", "\n", "name", "=", "name", "+", "'.npz'", "\n", "modified_adj", "=", "self", ".", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.base_attack.BaseAttack.save_features": [[99, 125], ["type", "utils.to_scipy", "scipy.save_npz", "scipy.save_npz", "osp.join", "osp.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_scipy"], ["if", "type", "(", "modified_adj", ")", "is", "torch", ".", "Tensor", ":", "\n", "            ", "sparse_adj", "=", "utils", ".", "to_scipy", "(", "modified_adj", ")", "\n", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "sparse_adj", ")", "\n", "", "else", ":", "\n", "            ", "sp", ".", "save_npz", "(", "osp", ".", "join", "(", "root", ",", "name", ")", ",", "modified_adj", ")", "\n", "\n", "", "", "def", "save_features", "(", "self", ",", "root", "=", "r'/tmp/'", ",", "name", "=", "'mod_features'", ")", ":", "\n", "        ", "\"\"\"Save attacked node feature matrix.\n\n        Parameters\n        ----------\n        root :\n            root directory where the variable should be saved\n        name : str\n            saved file name\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "\n", "assert", "self", ".", "modified_features", "is", "not", "None", ",", "'modified_features is None! Please perturb the graph first.'", "\n", "name", "=", "name", "+", "'.npz'", "\n", "modified_features", "=", "self", ".", "modified_features", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.__init__": [[60, 108], ["deeprobust.graph.rl.nstep_replay_mem.NstepReplayMem", "deeprobust.graph.rl.q_net_node.NStepQNetNode", "deeprobust.graph.rl.q_net_node.NStepQNetNode", "rl_s2v.RLS2V.net.to", "rl_s2v.RLS2V.old_net.to", "rl_s2v.RLS2V.take_snapshot", "os.exists", "os.exists", "os.system", "os.system", "os.system", "os.system"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.take_snapshot"], ["def", "__init__", "(", "self", ",", "env", ",", "features", ",", "labels", ",", "idx_meta", ",", "idx_test", ",", "\n", "list_action_space", ",", "num_mod", ",", "reward_type", ",", "batch_size", "=", "10", ",", "\n", "num_wrong", "=", "0", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "gm", "=", "'mean_field'", ",", "\n", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "save_dir", "=", "'checkpoint_dqn'", ",", "device", "=", "None", ")", ":", "\n", "\n", "\n", "        ", "assert", "device", "is", "not", "None", ",", "\"'device' cannot be None, please specify it\"", "\n", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "idx_meta", "=", "idx_meta", "\n", "self", ".", "idx_test", "=", "idx_test", "\n", "self", ".", "num_wrong", "=", "num_wrong", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "num_mod", "=", "num_mod", "\n", "self", ".", "reward_type", "=", "reward_type", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "if", "not", "osp", ".", "exists", "(", "save_dir", ")", ":", "\n", "            ", "os", ".", "system", "(", "'mkdir -p {}'", ".", "format", "(", "save_dir", ")", ")", "\n", "\n", "", "self", ".", "gm", "=", "gm", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "mem_pool", "=", "NstepReplayMem", "(", "memory_size", "=", "500000", ",", "n_steps", "=", "2", "*", "num_mod", ",", "balance_sample", "=", "reward_type", "==", "'binary'", ")", "\n", "self", ".", "env", "=", "env", "\n", "\n", "# self.net = QNetNode(features, labels, list_action_space)", "\n", "# self.old_net = QNetNode(features, labels, list_action_space)", "\n", "self", ".", "net", "=", "NStepQNetNode", "(", "2", "*", "num_mod", ",", "features", ",", "labels", ",", "list_action_space", ",", "\n", "bilin_q", "=", "bilin_q", ",", "embed_dim", "=", "embed_dim", ",", "mlp_hidden", "=", "mlp_hidden", ",", "\n", "max_lv", "=", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", "\n", "\n", "self", ".", "old_net", "=", "NStepQNetNode", "(", "2", "*", "num_mod", ",", "features", ",", "labels", ",", "list_action_space", ",", "\n", "bilin_q", "=", "bilin_q", ",", "embed_dim", "=", "embed_dim", ",", "mlp_hidden", "=", "mlp_hidden", ",", "\n", "max_lv", "=", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", "\n", "\n", "self", ".", "net", "=", "self", ".", "net", ".", "to", "(", "device", ")", "\n", "self", ".", "old_net", "=", "self", ".", "old_net", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "eps_start", "=", "1.0", "\n", "self", ".", "eps_end", "=", "0.05", "\n", "self", ".", "eps_step", "=", "100000", "\n", "self", ".", "burn_in", "=", "10", "\n", "self", ".", "step", "=", "0", "\n", "self", ".", "pos", "=", "0", "\n", "self", ".", "best_eval", "=", "None", "\n", "self", ".", "take_snapshot", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.take_snapshot": [[109, 111], ["rl_s2v.RLS2V.old_net.load_state_dict", "rl_s2v.RLS2V.net.state_dict"], "methods", ["None"], ["", "def", "take_snapshot", "(", "self", ")", ":", "\n", "        ", "self", ".", "old_net", ".", "load_state_dict", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.make_actions": [[112, 124], ["max", "rl_s2v.RLS2V.env.uniformRandActions", "rl_s2v.RLS2V.env.getStateRef", "rl_s2v.RLS2V.net", "list", "random.random", "list.cpu().numpy", "list.cpu", "max"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.uniformRandActions", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.getStateRef"], ["", "def", "make_actions", "(", "self", ",", "time_t", ",", "greedy", "=", "False", ")", ":", "\n", "        ", "self", ".", "eps", "=", "self", ".", "eps_end", "+", "max", "(", "0.", ",", "(", "self", ".", "eps_start", "-", "self", ".", "eps_end", ")", "\n", "*", "(", "self", ".", "eps_step", "-", "max", "(", "0.", ",", "self", ".", "step", ")", ")", "/", "self", ".", "eps_step", ")", "\n", "\n", "if", "random", ".", "random", "(", ")", "<", "self", ".", "eps", "and", "not", "greedy", ":", "\n", "            ", "actions", "=", "self", ".", "env", ".", "uniformRandActions", "(", ")", "\n", "", "else", ":", "\n", "            ", "cur_state", "=", "self", ".", "env", ".", "getStateRef", "(", ")", "\n", "actions", ",", "values", "=", "self", ".", "net", "(", "time_t", ",", "cur_state", ",", "None", ",", "greedy_acts", "=", "True", ",", "is_inference", "=", "True", ")", "\n", "actions", "=", "list", "(", "actions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "return", "actions", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.run_simulation": [[125, 191], ["rl_s2v.RLS2V.env.setup", "rl_s2v.RLS2V.env.sample_pos_rewards", "len", "len", "random.shuffle", "rl_s2v.RLS2V.env.isTerminal", "rl_s2v.RLS2V.make_actions", "rl_s2v.RLS2V.env.cloneState", "rl_s2v.RLS2V.env.step", "env.isTerminal", "rl_s2v.RLS2V.mem_pool.add_list", "list_of_list_st.append", "list_of_list_at.append", "len", "env.isTerminal", "numpy.zeros", "rl_s2v.RLS2V.env.cloneState", "copy.deepcopy", "copy.deepcopy", "range", "range", "len", "len", "rl_s2v.RLS2V.mem_pool.mem_cells[].add", "env.isTerminal", "copy.deepcopy", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.sample_pos_rewards", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.make_actions", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add_list", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal"], ["", "def", "run_simulation", "(", "self", ")", ":", "\n", "\n", "        ", "if", "(", "self", ".", "pos", "+", "1", ")", "*", "self", ".", "batch_size", ">", "len", "(", "self", ".", "idx_test", ")", ":", "\n", "            ", "self", ".", "pos", "=", "0", "\n", "random", ".", "shuffle", "(", "self", ".", "idx_test", ")", "\n", "\n", "", "selected_idx", "=", "self", ".", "idx_test", "[", "self", ".", "pos", "*", "self", ".", "batch_size", ":", "(", "self", ".", "pos", "+", "1", ")", "*", "self", ".", "batch_size", "]", "\n", "self", ".", "pos", "+=", "1", "\n", "self", ".", "env", ".", "setup", "(", "selected_idx", ")", "\n", "\n", "t", "=", "0", "\n", "list_of_list_st", "=", "[", "]", "\n", "list_of_list_at", "=", "[", "]", "\n", "\n", "while", "not", "self", ".", "env", ".", "isTerminal", "(", ")", ":", "\n", "            ", "list_at", "=", "self", ".", "make_actions", "(", "t", ")", "\n", "list_st", "=", "self", ".", "env", ".", "cloneState", "(", ")", "\n", "\n", "self", ".", "env", ".", "step", "(", "list_at", ")", "\n", "\n", "# TODO Wei added line #87", "\n", "env", "=", "self", ".", "env", "\n", "assert", "(", "env", ".", "rewards", "is", "not", "None", ")", "==", "env", ".", "isTerminal", "(", ")", "\n", "if", "env", ".", "isTerminal", "(", ")", ":", "\n", "                ", "rewards", "=", "env", ".", "rewards", "\n", "s_prime", "=", "None", "\n", "", "else", ":", "\n", "                ", "rewards", "=", "np", ".", "zeros", "(", "len", "(", "list_at", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "s_prime", "=", "self", ".", "env", ".", "cloneState", "(", ")", "\n", "\n", "", "self", ".", "mem_pool", ".", "add_list", "(", "list_st", ",", "list_at", ",", "rewards", ",", "s_prime", ",", "[", "env", ".", "isTerminal", "(", ")", "]", "*", "len", "(", "list_at", ")", ",", "t", ")", "\n", "list_of_list_st", ".", "append", "(", "deepcopy", "(", "list_st", ")", ")", "\n", "list_of_list_at", ".", "append", "(", "deepcopy", "(", "list_at", ")", ")", "\n", "t", "+=", "1", "\n", "\n", "# if the reward type is nll_loss, directly return", "\n", "", "if", "self", ".", "reward_type", "==", "'nll'", ":", "\n", "            ", "return", "\n", "\n", "", "T", "=", "t", "\n", "cands", "=", "self", ".", "env", ".", "sample_pos_rewards", "(", "len", "(", "selected_idx", ")", ")", "\n", "if", "len", "(", "cands", ")", ":", "\n", "            ", "for", "c", "in", "cands", ":", "\n", "                ", "sample_idx", ",", "target", "=", "c", "\n", "doable", "=", "True", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "                    ", "if", "self", ".", "list_action_space", "[", "target", "]", "is", "not", "None", "and", "(", "not", "list_of_list_at", "[", "t", "]", "[", "sample_idx", "]", "in", "self", ".", "list_action_space", "[", "target", "]", ")", ":", "\n", "                        ", "doable", "=", "False", "# TODO WHY False? This is only 1-hop neighbour", "\n", "break", "\n", "", "", "if", "not", "doable", ":", "\n", "                    ", "continue", "\n", "\n", "", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "                    ", "s_t", "=", "list_of_list_st", "[", "t", "]", "[", "sample_idx", "]", "\n", "a_t", "=", "list_of_list_at", "[", "t", "]", "[", "sample_idx", "]", "\n", "s_t", "=", "[", "target", ",", "deepcopy", "(", "s_t", "[", "1", "]", ")", ",", "s_t", "[", "2", "]", "]", "\n", "if", "t", "+", "1", "==", "T", ":", "\n", "                        ", "s_prime", "=", "(", "None", ",", "None", ",", "None", ")", "\n", "r", "=", "1.0", "\n", "term", "=", "True", "\n", "", "else", ":", "\n", "                        ", "s_prime", "=", "list_of_list_st", "[", "t", "+", "1", "]", "[", "sample_idx", "]", "\n", "s_prime", "=", "[", "target", ",", "deepcopy", "(", "s_prime", "[", "1", "]", ")", ",", "s_prime", "[", "2", "]", "]", "\n", "r", "=", "0.0", "\n", "term", "=", "False", "\n", "", "self", ".", "mem_pool", ".", "mem_cells", "[", "t", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r", ",", "s_prime", ",", "term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.eval": [[192, 220], ["rl_s2v.RLS2V.env.setup", "print", "rl_s2v.RLS2V.env.isTerminal", "rl_s2v.RLS2V.make_actions", "rl_s2v.RLS2V.env.step", "numpy.sum", "print", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "len", "rl_s2v.RLS2V.net.state_dict", "os.join", "os.join", "open", "f.write", "open", "range", "os.join", "os.join", "os.join", "os.join", "len", "f.write", "f.write", "f.write"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.make_actions", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "", "", "def", "eval", "(", "self", ",", "training", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate RL agent.\n        \"\"\"", "\n", "\n", "self", ".", "env", ".", "setup", "(", "self", ".", "idx_meta", ")", "\n", "t", "=", "0", "\n", "\n", "while", "not", "self", ".", "env", ".", "isTerminal", "(", ")", ":", "\n", "            ", "list_at", "=", "self", ".", "make_actions", "(", "t", ",", "greedy", "=", "True", ")", "\n", "self", ".", "env", ".", "step", "(", "list_at", ")", "\n", "t", "+=", "1", "\n", "\n", "", "acc", "=", "1", "-", "(", "self", ".", "env", ".", "binary_rewards", "+", "1.0", ")", "/", "2.0", "\n", "acc", "=", "np", ".", "sum", "(", "acc", ")", "/", "(", "len", "(", "self", ".", "idx_meta", ")", "+", "self", ".", "num_wrong", ")", "\n", "print", "(", "'\\033[93m average test: acc %.5f\\033[0m'", "%", "(", "acc", ")", ")", "\n", "\n", "if", "training", "==", "True", "and", "self", ".", "best_eval", "is", "None", "or", "acc", "<", "self", ".", "best_eval", ":", "\n", "            ", "print", "(", "'----saving to best attacker since this is the best attack rate so far.----'", ")", "\n", "torch", ".", "save", "(", "self", ".", "net", ".", "state_dict", "(", ")", ",", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "'epoch-best.model'", ")", ")", "\n", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "'epoch-best.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "'%.4f\\n'", "%", "acc", ")", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "'attack_solution.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "idx_meta", ")", ")", ":", "\n", "                    ", "f", ".", "write", "(", "'%d: ['", "%", "self", ".", "idx_meta", "[", "i", "]", ")", "\n", "for", "e", "in", "self", ".", "env", ".", "modified_list", "[", "i", "]", ".", "directed_edges", ":", "\n", "                        ", "f", ".", "write", "(", "'(%d %d)'", "%", "e", ")", "\n", "", "f", ".", "write", "(", "'] succ: %d\\n'", "%", "(", "self", ".", "env", ".", "binary_rewards", "[", "i", "]", ")", ")", "\n", "", "", "self", ".", "best_eval", "=", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.train": [[221, 261], ["tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "rl_s2v.RLS2V.run_simulation", "range", "rl_s2v.RLS2V.net.parameters", "rl_s2v.RLS2V.run_simulation", "rl_s2v.RLS2V.mem_pool.sample", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "list_target.view.view.view", "rl_s2v.RLS2V.net", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "torch.Adam.zero_grad", "torch.mse_loss.backward", "torch.Adam.step", "tqdm.tqdm.tqdm.set_description", "rl_s2v.RLS2V.take_snapshot", "rl_s2v.RLS2V.eval", "zip", "rl_s2v.RLS2V.old_net", "deeprobust.graph.rl.q_net_node.node_greedy_actions", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.run_simulation", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.run_simulation", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.targeted_attack.rl_s2v.RLS2V.take_snapshot", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.node_greedy_actions"], ["", "", "def", "train", "(", "self", ",", "num_steps", "=", "100000", ",", "lr", "=", "0.001", ")", ":", "\n", "        ", "\"\"\"Train RL agent.\n        \"\"\"", "\n", "\n", "pbar", "=", "tqdm", "(", "range", "(", "self", ".", "burn_in", ")", ",", "unit", "=", "'batch'", ")", "\n", "\n", "for", "p", "in", "pbar", ":", "\n", "            ", "self", ".", "run_simulation", "(", ")", "\n", "\n", "", "pbar", "=", "tqdm", "(", "range", "(", "num_steps", ")", ",", "unit", "=", "'steps'", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n", "for", "self", ".", "step", "in", "pbar", ":", "\n", "\n", "            ", "self", ".", "run_simulation", "(", ")", "\n", "\n", "if", "self", ".", "step", "%", "123", "==", "0", ":", "\n", "# update the params of old_net", "\n", "                ", "self", ".", "take_snapshot", "(", ")", "\n", "", "if", "self", ".", "step", "%", "500", "==", "0", ":", "\n", "                ", "self", ".", "eval", "(", ")", "\n", "\n", "", "cur_time", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "=", "self", ".", "mem_pool", ".", "sample", "(", "batch_size", "=", "self", ".", "batch_size", ")", "\n", "list_target", "=", "torch", ".", "Tensor", "(", "list_rt", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "not", "list_term", "[", "0", "]", ":", "\n", "                ", "target_nodes", ",", "_", ",", "picked_nodes", "=", "zip", "(", "*", "list_s_primes", ")", "\n", "_", ",", "q_t_plus_1", "=", "self", ".", "old_net", "(", "cur_time", "+", "1", ",", "list_s_primes", ",", "None", ")", "\n", "_", ",", "q_rhs", "=", "node_greedy_actions", "(", "target_nodes", ",", "picked_nodes", ",", "q_t_plus_1", ",", "self", ".", "old_net", ")", "\n", "list_target", "+=", "q_rhs", "\n", "\n", "# list_target = Variable(list_target.view(-1, 1))", "\n", "", "list_target", "=", "list_target", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "_", ",", "q_sa", "=", "self", ".", "net", "(", "cur_time", ",", "list_st", ",", "list_at", ")", "\n", "q_sa", "=", "torch", ".", "cat", "(", "q_sa", ",", "dim", "=", "0", ")", "\n", "loss", "=", "F", ".", "mse_loss", "(", "q_sa", ",", "list_target", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "pbar", ".", "set_description", "(", "'eps: %.5f, loss: %0.5f, q_val: %.5f'", "%", "(", "self", ".", "eps", ",", "loss", ",", "torch", ".", "mean", "(", "q_sa", ")", ")", ")", "\n", "# print('eps: %.5f, loss: %0.5f, q_val: %.5f' % (self.eps, loss, torch.mean(q_sa)) )", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.StaticGraph.get_gsize": [[31, 34], ["torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "len"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_gsize", "(", ")", ":", "\n", "        ", "return", "torch", ".", "Size", "(", "(", "len", "(", "StaticGraph", ".", "graph", ")", ",", "len", "(", "StaticGraph", ".", "graph", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.GraphNormTool.__init__": [[37, 61], ["numpy.array", "numpy.array", "numpy.hstack", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "rl_s2v_env.GraphNormTool.raw_adj.to", "rl_s2v_env.GraphNormTool.raw_adj.clone", "g.edges", "rl_s2v_env.StaticGraph.get_gsize", "torch.LongTensor.size", "torch.LongTensor.size", "torch.LongTensor.size", "torch.LongTensor.size", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.degree_normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj_tensor"], ["    ", "def", "__init__", "(", "self", ",", "normalize", ",", "gm", ",", "device", ")", ":", "\n", "        ", "self", ".", "adj_norm", "=", "normalize", "\n", "self", ".", "gm", "=", "gm", "\n", "g", "=", "StaticGraph", ".", "graph", "\n", "edges", "=", "np", ".", "array", "(", "g", ".", "edges", "(", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "rev_edges", "=", "np", ".", "array", "(", "[", "edges", "[", ":", ",", "1", "]", ",", "edges", "[", ":", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# self_edges = np.array([range(len(g)), range(len(g))], dtype=np.int64)", "\n", "# edges = np.hstack((edges.T, rev_edges, self_edges))", "\n", "edges", "=", "np", ".", "hstack", "(", "(", "edges", ".", "T", ",", "rev_edges", ")", ")", "\n", "idxes", "=", "torch", ".", "LongTensor", "(", "edges", ")", "\n", "values", "=", "torch", ".", "ones", "(", "idxes", ".", "size", "(", ")", "[", "1", "]", ")", "\n", "\n", "self", ".", "raw_adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "StaticGraph", ".", "get_gsize", "(", ")", ")", "\n", "self", ".", "raw_adj", "=", "self", ".", "raw_adj", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "normed_adj", "=", "self", ".", "raw_adj", ".", "clone", "(", ")", "\n", "if", "self", ".", "adj_norm", ":", "\n", "            ", "if", "self", ".", "gm", "==", "'gcn'", ":", "\n", "                ", "self", ".", "normed_adj", "=", "utils", ".", "normalize_adj_tensor", "(", "self", ".", "normed_adj", ",", "sparse", "=", "True", ")", "\n", "# GraphLaplacianNorm(self.normed_adj)", "\n", "", "else", ":", "\n", "\n", "                ", "self", ".", "normed_adj", "=", "utils", ".", "degree_normalize_adj_tensor", "(", "self", ".", "normed_adj", ",", "sparse", "=", "True", ")", "\n", "# GraphDegreeNorm(self.normed_adj)", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.GraphNormTool.norm_extra": [[63, 75], ["deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.degree_normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj_tensor"], ["", "", "", "def", "norm_extra", "(", "self", ",", "added_adj", "=", "None", ")", ":", "\n", "        ", "if", "added_adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "normed_adj", "\n", "\n", "", "new_adj", "=", "self", ".", "raw_adj", "+", "added_adj", "\n", "if", "self", ".", "adj_norm", ":", "\n", "            ", "if", "self", ".", "gm", "==", "'gcn'", ":", "\n", "                ", "new_adj", "=", "utils", ".", "normalize_adj_tensor", "(", "new_adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "new_adj", "=", "utils", ".", "degree_normalize_adj_tensor", "(", "new_adj", ",", "sparse", "=", "True", ")", "\n", "\n", "", "", "return", "new_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.ModifiedGraph.__init__": [[78, 88], ["set", "set", "numpy.arange", "range", "copy.deepcopy", "copy.deepcopy", "rl_s2v_env.StaticGraph.get_gsize", "rl_s2v_env.StaticGraph.get_gsize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize"], ["    ", "def", "__init__", "(", "self", ",", "directed_edges", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "        ", "self", ".", "edge_set", "=", "set", "(", ")", "#(first, second)", "\n", "self", ".", "node_set", "=", "set", "(", "range", "(", "StaticGraph", ".", "get_gsize", "(", ")", "[", "0", "]", ")", ")", "\n", "self", ".", "node_set", "=", "np", ".", "arange", "(", "StaticGraph", ".", "get_gsize", "(", ")", "[", "0", "]", ")", "\n", "if", "directed_edges", "is", "not", "None", ":", "\n", "            ", "self", ".", "directed_edges", "=", "deepcopy", "(", "directed_edges", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "weights", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "directed_edges", "=", "[", "]", "\n", "self", ".", "weights", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.ModifiedGraph.add_edge": [[89, 103], ["rl_s2v_env.ModifiedGraph.edge_set.add", "rl_s2v_env.ModifiedGraph.edge_set.add", "rl_s2v_env.ModifiedGraph.directed_edges.append", "rl_s2v_env.ModifiedGraph.weights.append"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "", "def", "add_edge", "(", "self", ",", "x", ",", "y", ",", "z", ")", ":", "\n", "        ", "assert", "x", "is", "not", "None", "and", "y", "is", "not", "None", "\n", "if", "x", "==", "y", ":", "\n", "            ", "return", "\n", "", "for", "e", "in", "self", ".", "directed_edges", ":", "\n", "            ", "if", "e", "[", "0", "]", "==", "x", "and", "e", "[", "1", "]", "==", "y", ":", "\n", "                ", "return", "\n", "", "if", "e", "[", "1", "]", "==", "x", "and", "e", "[", "0", "]", "==", "y", ":", "\n", "                ", "return", "\n", "", "", "self", ".", "edge_set", ".", "add", "(", "(", "x", ",", "y", ")", ")", "# (first, second)", "\n", "self", ".", "edge_set", ".", "add", "(", "(", "y", ",", "x", ")", ")", "# (second, first)", "\n", "self", ".", "directed_edges", ".", "append", "(", "(", "x", ",", "y", ")", ")", "\n", "# assert z < 0", "\n", "self", ".", "weights", ".", "append", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.ModifiedGraph.get_extra_adj": [[104, 119], ["len", "numpy.array", "numpy.array", "numpy.hstack", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "added_adj.to.to.to", "rl_s2v_env.StaticGraph.get_gsize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize"], ["", "def", "get_extra_adj", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "directed_edges", ")", ":", "\n", "            ", "edges", "=", "np", ".", "array", "(", "self", ".", "directed_edges", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "rev_edges", "=", "np", ".", "array", "(", "[", "edges", "[", ":", ",", "1", "]", ",", "edges", "[", ":", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "edges", "=", "np", ".", "hstack", "(", "(", "edges", ".", "T", ",", "rev_edges", ")", ")", "\n", "\n", "idxes", "=", "torch", ".", "LongTensor", "(", "edges", ")", "\n", "values", "=", "torch", ".", "Tensor", "(", "self", ".", "weights", "+", "self", ".", "weights", ")", "\n", "\n", "added_adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "StaticGraph", ".", "get_gsize", "(", ")", ")", "\n", "\n", "added_adj", "=", "added_adj", ".", "to", "(", "device", ")", "\n", "return", "added_adj", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.ModifiedGraph.get_possible_nodes": [[120, 128], ["set", "numpy.setdiff1d", "numpy.array", "set.append"], "methods", ["None"], ["", "", "def", "get_possible_nodes", "(", "self", ",", "target_node", ")", ":", "\n", "        ", "connected", "=", "set", "(", ")", "\n", "connected", "=", "[", "]", "\n", "for", "n1", ",", "n2", "in", "self", ".", "edge_set", ":", "\n", "            ", "if", "n1", "==", "target_node", ":", "\n", "# connected.add(target_node)", "\n", "                ", "connected", ".", "append", "(", "n1", ")", "\n", "", "", "return", "np", ".", "setdiff1d", "(", "self", ".", "node_set", ",", "np", ".", "array", "(", "connected", ")", ")", "\n", "# return self.node_set - connected", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.__init__": [[135, 144], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "features", ",", "labels", ",", "all_targets", ",", "list_action_space", ",", "classifier", ",", "num_mod", "=", "1", ",", "reward_type", "=", "'binary'", ")", ":", "\n", "\n", "        ", "self", ".", "classifier", "=", "classifier", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "all_targets", "=", "all_targets", "\n", "self", ".", "num_mod", "=", "num_mod", "\n", "self", ".", "reward_type", "=", "reward_type", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.setup": [[145, 156], ["range", "len", "rl_s2v_env.NodeAttackEnv.modified_list.append", "rl_s2v_env.ModifiedGraph"], "methods", ["None"], ["", "def", "setup", "(", "self", ",", "target_nodes", ")", ":", "\n", "        ", "self", ".", "target_nodes", "=", "target_nodes", "\n", "self", ".", "n_steps", "=", "0", "\n", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "rewards", "=", "None", "\n", "self", ".", "binary_rewards", "=", "None", "\n", "self", ".", "modified_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "            ", "self", ".", "modified_list", ".", "append", "(", "ModifiedGraph", "(", ")", ")", "\n", "\n", "", "self", ".", "list_acc_of_all", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.step": [[157, 200], ["rl_s2v_env.NodeAttackEnv.isTerminal", "range", "range", "len", "rl_s2v_env.NodeAttackEnv.modified_list[].add_edge", "len", "rl_s2v_env.NodeAttackEnv.modified_list[].get_extra_adj", "rl_s2v_env.NodeAttackEnv.classifier.norm_tool.norm_extra", "rl_s2v_env.NodeAttackEnv.classifier", "loss_acc", "rl_s2v_env.NodeAttackEnv.all_targets.index", "numpy.copy", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu().view().numpy", "rl_s2v_env.NodeAttackEnv.list_acc_of_all.append", "acc_list.append", "loss_list.append", "numpy.array().astype", "numpy.copy.double().cpu().view().numpy", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu().view", "numpy.array", "numpy.copy.double().cpu().view", "numpy.array", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu", "numpy.array", "numpy.copy.double().cpu", "numpy.copy.double"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.add_edge", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.loss_acc"], ["", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "\"\"\"run actions and get rewards\n        \"\"\"", "\n", "if", "self", ".", "first_nodes", "is", "None", ":", "# pick the first node of edge", "\n", "            ", "assert", "self", ".", "n_steps", "%", "2", "==", "0", "\n", "self", ".", "first_nodes", "=", "actions", "[", ":", "]", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "# assert self.first_nodes[i] != actions[i]", "\n", "# deleta an edge from the graph", "\n", "                ", "self", ".", "modified_list", "[", "i", "]", ".", "add_edge", "(", "self", ".", "first_nodes", "[", "i", "]", ",", "actions", "[", "i", "]", ",", "-", "1.0", ")", "\n", "", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "banned_list", "=", "None", "\n", "", "self", ".", "n_steps", "+=", "1", "\n", "\n", "if", "self", ".", "isTerminal", "(", ")", ":", "\n", "# only calc reward when its terminal", "\n", "            ", "acc_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "# for i in tqdm(range(len(self.target_nodes))):", "\n", "for", "i", "in", "(", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ")", ":", "\n", "                ", "device", "=", "self", ".", "labels", ".", "device", "\n", "extra_adj", "=", "self", ".", "modified_list", "[", "i", "]", ".", "get_extra_adj", "(", "device", "=", "device", ")", "\n", "adj", "=", "self", ".", "classifier", ".", "norm_tool", ".", "norm_extra", "(", "extra_adj", ")", "\n", "\n", "output", "=", "self", ".", "classifier", "(", "self", ".", "features", ",", "adj", ")", "\n", "\n", "loss", ",", "acc", "=", "loss_acc", "(", "output", ",", "self", ".", "labels", ",", "self", ".", "all_targets", ",", "avg_loss", "=", "False", ")", "\n", "# _, loss, acc = self.classifier(self.features, Variable(adj), self.all_targets, self.labels, avg_loss=False)", "\n", "\n", "cur_idx", "=", "self", ".", "all_targets", ".", "index", "(", "self", ".", "target_nodes", "[", "i", "]", ")", "\n", "acc", "=", "np", ".", "copy", "(", "acc", ".", "double", "(", ")", ".", "cpu", "(", ")", ".", "view", "(", "-", "1", ")", ".", "numpy", "(", ")", ")", "\n", "loss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "view", "(", "-", "1", ")", ".", "numpy", "(", ")", "\n", "self", ".", "list_acc_of_all", ".", "append", "(", "acc", ")", "\n", "acc_list", ".", "append", "(", "acc", "[", "cur_idx", "]", ")", "\n", "loss_list", ".", "append", "(", "loss", "[", "cur_idx", "]", ")", "\n", "\n", "", "self", ".", "binary_rewards", "=", "(", "np", ".", "array", "(", "acc_list", ")", "*", "-", "2.0", "+", "1.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "self", ".", "reward_type", "==", "'binary'", ":", "\n", "                ", "self", ".", "rewards", "=", "(", "np", ".", "array", "(", "acc_list", ")", "*", "-", "2.0", "+", "1.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "                ", "assert", "self", ".", "reward_type", "==", "'nll'", "\n", "self", ".", "rewards", "=", "np", ".", "array", "(", "loss_list", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.sample_pos_rewards": [[201, 216], ["range", "random.shuffle", "len", "range", "len", "numpy.where", "len", "cands.append"], "methods", ["None"], ["", "", "", "def", "sample_pos_rewards", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "assert", "self", ".", "list_acc_of_all", "is", "not", "None", "\n", "cands", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "list_acc_of_all", ")", ")", ":", "\n", "            ", "succ", "=", "np", ".", "where", "(", "self", ".", "list_acc_of_all", "[", "i", "]", "<", "0.9", ")", "[", "0", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "succ", ")", ")", ":", "\n", "\n", "                ", "cands", ".", "append", "(", "(", "i", ",", "self", ".", "all_targets", "[", "succ", "[", "j", "]", "]", ")", ")", "\n", "\n", "", "", "if", "num_samples", ">", "len", "(", "cands", ")", ":", "\n", "            ", "return", "cands", "\n", "", "random", ".", "shuffle", "(", "cands", ")", "\n", "return", "cands", "[", "0", ":", "num_samples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.uniformRandActions": [[217, 236], ["range", "len", "act_list.append", "numpy.random.randint", "len", "numpy.random.randint", "len"], "methods", ["None"], ["", "def", "uniformRandActions", "(", "self", ")", ":", "\n", "# TODO: here only support deleting edges", "\n", "# seems they sample first node from 2-hop neighbours", "\n", "        ", "act_list", "=", "[", "]", "\n", "offset", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "            ", "cur_node", "=", "self", ".", "target_nodes", "[", "i", "]", "\n", "region", "=", "self", ".", "list_action_space", "[", "cur_node", "]", "\n", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", "and", "self", ".", "first_nodes", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "region", "=", "self", ".", "list_action_space", "[", "self", ".", "first_nodes", "[", "i", "]", "]", "\n", "\n", "", "if", "region", "is", "None", ":", "# singleton node", "\n", "                ", "cur_action", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "list_action_space", ")", ")", "\n", "", "else", ":", "# select from neighbours or 2-hop neighbours", "\n", "                ", "cur_action", "=", "region", "[", "np", ".", "random", ".", "randint", "(", "len", "(", "region", ")", ")", "]", "\n", "\n", "", "act_list", ".", "append", "(", "cur_action", ")", "\n", "", "return", "act_list", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.isTerminal": [[237, 241], ["None"], "methods", ["None"], ["", "def", "isTerminal", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "n_steps", "==", "2", "*", "self", ".", "num_mod", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.getStateRef": [[242, 248], ["zip", "len"], "methods", ["None"], ["", "def", "getStateRef", "(", "self", ")", ":", "\n", "        ", "cp_first", "=", "[", "None", "]", "*", "len", "(", "self", ".", "target_nodes", ")", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", ":", "\n", "            ", "cp_first", "=", "self", ".", "first_nodes", "\n", "\n", "", "return", "zip", "(", "self", ".", "target_nodes", ",", "self", ".", "modified_list", ",", "cp_first", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_env.NodeAttackEnv.cloneState": [[249, 255], ["list", "len", "zip", "copy.deepcopy"], "methods", ["None"], ["", "def", "cloneState", "(", "self", ")", ":", "\n", "        ", "cp_first", "=", "[", "None", "]", "*", "len", "(", "self", ".", "target_nodes", ")", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", ":", "\n", "            ", "cp_first", "=", "self", ".", "first_nodes", "[", ":", "]", "\n", "\n", "", "return", "list", "(", "zip", "(", "self", ".", "target_nodes", "[", ":", "]", ",", "deepcopy", "(", "self", ".", "modified_list", ")", ",", "cp_first", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.__init__": [[25, 64], ["torch.Module.__init__", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "len", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "deeprobust.graph.rl.env.GraphNormTool", "nipa_q_net_node.weights_init", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "node_labels.max", "node_features.size", "node_labels.max"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.weights_init"], ["    ", "def", "__init__", "(", "self", ",", "node_features", ",", "node_labels", ",", "list_action_space", ",", "n_injected", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "gm", "=", "'mean_field'", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "'''\n        bilin_q: bilinear q or not\n        mlp_hidden: mlp hidden layer size\n        mav_lv: max rounds of message passing\n        '''", "\n", "super", "(", "QNetNode", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_features", "=", "node_features", "\n", "self", ".", "identity", "=", "torch", ".", "eye", "(", "node_labels", ".", "max", "(", ")", "+", "1", ")", ".", "to", "(", "node_labels", ".", "device", ")", "\n", "# self.node_labels = self.to_onehot(node_labels)", "\n", "self", ".", "n_injected", "=", "n_injected", "\n", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "total_nodes", "=", "len", "(", "list_action_space", ")", "\n", "\n", "self", ".", "bilin_q", "=", "bilin_q", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "mlp_hidden", "=", "mlp_hidden", "\n", "self", ".", "max_lv", "=", "max_lv", "\n", "self", ".", "gm", "=", "gm", "\n", "\n", "if", "mlp_hidden", ":", "\n", "            ", "self", ".", "linear_1", "=", "nn", ".", "Linear", "(", "embed_dim", "*", "3", ",", "mlp_hidden", ")", "\n", "self", ".", "linear_out", "=", "nn", ".", "Linear", "(", "mlp_hidden", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear_out", "=", "nn", ".", "Linear", "(", "embed_dim", "*", "3", ",", "1", ")", "\n", "\n", "", "self", ".", "w_n2l", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "node_features", ".", "size", "(", ")", "[", "1", "]", ",", "embed_dim", ")", ")", "\n", "self", ".", "bias_n2l", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "embed_dim", ")", ")", "\n", "\n", "# self.bias_picked = Parameter(torch.Tensor(1, embed_dim))", "\n", "self", ".", "conv_params", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "norm_tool", "=", "GraphNormTool", "(", "normalize", "=", "True", ",", "gm", "=", "self", ".", "gm", ",", "device", "=", "device", ")", "\n", "weights_init", "(", "self", ")", "\n", "\n", "input_dim", "=", "(", "node_labels", ".", "max", "(", ")", "+", "1", ")", "*", "self", ".", "n_injected", "\n", "self", ".", "label_encoder_1", "=", "nn", ".", "Linear", "(", "input_dim", ",", "mlp_hidden", ")", "\n", "self", ".", "label_encoder_2", "=", "nn", ".", "Linear", "(", "mlp_hidden", ",", "embed_dim", ")", "\n", "self", ".", "device", "=", "self", ".", "node_features", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.to_onehot": [[65, 67], ["nipa_q_net_node.QNetNode.identity[].view"], "methods", ["None"], ["", "def", "to_onehot", "(", "self", ",", "labels", ")", ":", "\n", "        ", "return", "self", ".", "identity", "[", "labels", "]", ".", "view", "(", "-", "1", ",", "self", ".", "identity", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_label_embedding": [[68, 75], ["nipa_q_net_node.QNetNode.to_onehot().view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "nipa_q_net_node.QNetNode.label_encoder_1", "nipa_q_net_node.QNetNode.label_encoder_2", "nipa_q_net_node.QNetNode.to_onehot"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.to_onehot"], ["", "def", "get_label_embedding", "(", "self", ",", "labels", ")", ":", "\n", "# int to one hot", "\n", "        ", "onehot", "=", "self", ".", "to_onehot", "(", "labels", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "label_encoder_1", "(", "onehot", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "label_encoder_2", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_action_label_encoding": [[76, 80], ["nipa_q_net_node.QNetNode.to_onehot", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.to_onehot", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "get_action_label_encoding", "(", "self", ",", "label", ")", ":", "\n", "        ", "onehot", "=", "self", ".", "to_onehot", "(", "label", ")", "\n", "zeros", "=", "torch", ".", "zeros", "(", "(", "onehot", ".", "shape", "[", "0", "]", ",", "self", ".", "embed_dim", "-", "onehot", ".", "shape", "[", "1", "]", ")", ")", ".", "to", "(", "onehot", ".", "device", ")", "\n", "return", "torch", ".", "cat", "(", "(", "onehot", ",", "zeros", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_graph_embedding": [[81, 100], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "range", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "nipa_q_net_node.QNetNode.conv_params", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "get_graph_embedding", "(", "self", ",", "adj", ")", ":", "\n", "        ", "if", "self", ".", "node_features", ".", "data", ".", "is_sparse", ":", "\n", "            ", "node_embed", "=", "torch", ".", "spmm", "(", "self", ".", "node_features", ",", "self", ".", "w_n2l", ")", "\n", "", "else", ":", "\n", "            ", "node_embed", "=", "torch", ".", "mm", "(", "self", ".", "node_features", ",", "self", ".", "w_n2l", ")", "\n", "\n", "", "node_embed", "+=", "self", ".", "bias_n2l", "\n", "\n", "input_message", "=", "node_embed", "\n", "node_embed", "=", "F", ".", "relu", "(", "input_message", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "max_lv", ")", ":", "\n", "            ", "n2npool", "=", "torch", ".", "spmm", "(", "adj", ",", "node_embed", ")", "\n", "node_linear", "=", "self", ".", "conv_params", "(", "n2npool", ")", "\n", "merged_linear", "=", "node_linear", "+", "input_message", "\n", "node_embed", "=", "F", ".", "relu", "(", "merged_linear", ")", "\n", "\n", "", "graph_embed", "=", "torch", ".", "mean", "(", "node_embed", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "return", "graph_embed", ",", "node_embed", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.make_spmat": [[101, 109], ["torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "next", "sp.cuda.cuda.cuda", "nipa_q_net_node.QNetNode.parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next"], ["", "def", "make_spmat", "(", "self", ",", "n_rows", ",", "n_cols", ",", "row_idx", ",", "col_idx", ")", ":", "\n", "        ", "idxes", "=", "torch", ".", "LongTensor", "(", "[", "[", "row_idx", "]", ",", "[", "col_idx", "]", "]", ")", "\n", "values", "=", "torch", ".", "ones", "(", "1", ")", "\n", "\n", "sp", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "torch", ".", "Size", "(", "[", "n_rows", ",", "n_cols", "]", ")", ")", "\n", "if", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "is_cuda", ":", "\n", "            ", "sp", "=", "sp", ".", "cuda", "(", ")", "\n", "", "return", "sp", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.forward": [[110, 155], ["torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "zip", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "len", "nipa_q_net_node.QNetNode.norm_tool.norm_extra", "nipa_q_net_node.QNetNode.get_graph_embedding", "nipa_q_net_node.QNetNode.get_label_embedding", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "embed_s.repeat.repeat.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "nipa_q_net_node.QNetNode.linear_out", "len", "batch_graph[].get_extra_adj", "node_embed[].view", "nipa_q_net_node.QNetNode.get_action_label_encoding", "len", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "raw_pred.max.max.argmax", "raw_pred.max.max.max", "greedy_actions.append", "raw_pred.max.max.max", "nipa_q_net_node.QNetNode.linear_1"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_graph_embedding", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_label_embedding", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.QNetNode.get_action_label_encoding"], ["", "def", "forward", "(", "self", ",", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", "=", "False", ",", "is_inference", "=", "False", ")", ":", "\n", "\n", "        ", "preds", "=", "torch", ".", "zeros", "(", "len", "(", "states", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "batch_graph", ",", "modified_labels", "=", "zip", "(", "*", "states", ")", "\n", "greedy_actions", "=", "[", "]", "\n", "with", "torch", ".", "set_grad_enabled", "(", "mode", "=", "not", "is_inference", ")", ":", "\n", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "batch_graph", ")", ")", ":", "\n", "                ", "if", "batch_graph", "[", "i", "]", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "adj", "=", "self", ".", "norm_tool", ".", "norm_extra", "(", "batch_graph", "[", "i", "]", ".", "get_extra_adj", "(", "self", ".", "device", ")", ")", "\n", "# get graph representation", "\n", "graph_embed", ",", "node_embed", "=", "self", ".", "get_graph_embedding", "(", "adj", ")", "\n", "\n", "# get label reprensentation", "\n", "label_embed", "=", "self", ".", "get_label_embedding", "(", "modified_labels", "[", "i", "]", ")", "\n", "\n", "# get action reprensentation", "\n", "if", "time_t", "!=", "2", ":", "\n", "                    ", "action_embed", "=", "node_embed", "[", "actions", "[", "i", "]", "]", ".", "view", "(", "-", "1", ",", "self", ".", "embed_dim", ")", "\n", "", "else", ":", "\n", "                    ", "action_embed", "=", "self", ".", "get_action_label_encoding", "(", "actions", "[", "i", "]", ")", "\n", "\n", "# concat them and send it to neural network", "\n", "", "embed_s", "=", "torch", ".", "cat", "(", "(", "graph_embed", ",", "label_embed", ")", ",", "dim", "=", "1", ")", "\n", "embed_s", "=", "embed_s", ".", "repeat", "(", "len", "(", "action_embed", ")", ",", "1", ")", "\n", "embed_s_a", "=", "torch", ".", "cat", "(", "(", "embed_s", ",", "action_embed", ")", ",", "dim", "=", "1", ")", "\n", "\n", "if", "self", ".", "mlp_hidden", ":", "\n", "                    ", "embed_s_a", "=", "F", ".", "relu", "(", "self", ".", "linear_1", "(", "embed_s_a", ")", ")", "\n", "\n", "", "raw_pred", "=", "self", ".", "linear_out", "(", "embed_s_a", ")", "\n", "\n", "if", "greedy_acts", ":", "\n", "                    ", "action_id", "=", "raw_pred", ".", "argmax", "(", "0", ")", "\n", "raw_pred", "=", "raw_pred", ".", "max", "(", ")", "\n", "greedy_actions", ".", "append", "(", "actions", "[", "i", "]", "[", "action_id", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raw_pred", "=", "raw_pred", ".", "max", "(", ")", "\n", "# list_pred.append(raw_pred)", "\n", "", "preds", "[", "i", "]", "+=", "raw_pred", "\n", "\n", "\n", "", "", "return", "greedy_actions", ",", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.NStepQNetNode.__init__": [[158, 173], ["torch.Module.__init__", "len", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "list_mod.append", "nipa_q_net_node.QNetNode"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_steps", ",", "node_features", ",", "node_labels", ",", "list_action_space", ",", "n_injected", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "gm", "=", "'mean_field'", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "NStepQNetNode", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_features", "=", "node_features", "\n", "self", ".", "node_labels", "=", "node_labels", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "total_nodes", "=", "len", "(", "list_action_space", ")", "\n", "\n", "list_mod", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "num_steps", ")", ":", "\n", "# list_mod.append(QNetNode(node_features, node_labels, list_action_space))", "\n", "            ", "list_mod", ".", "append", "(", "QNetNode", "(", "node_features", ",", "node_labels", ",", "list_action_space", ",", "n_injected", ",", "bilin_q", ",", "embed_dim", ",", "mlp_hidden", ",", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "self", ".", "list_mod", "=", "nn", ".", "ModuleList", "(", "list_mod", ")", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.NStepQNetNode.forward": [[174, 180], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", "=", "False", ",", "is_inference", "=", "False", ")", ":", "\n", "# print('time_t:', time_t)", "\n", "# print('self.num_step:', self.num_steps)", "\n", "# assert time_t >= 0 and time_t < self.num_steps", "\n", "        ", "time_t", "=", "time_t", "%", "3", "\n", "return", "self", ".", "list_mod", "[", "time_t", "]", "(", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", ",", "is_inference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.glorot_uniform": [[182, 195], ["numpy.sqrt", "t.uniform_", "len", "t.size", "t.size", "len", "numpy.prod", "numpy.prod", "t.size", "t.size", "t.size", "t.size", "t.size", "t.size", "t.size"], "function", ["None"], ["", "", "def", "glorot_uniform", "(", "t", ")", ":", "\n", "    ", "if", "len", "(", "t", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "        ", "fan_in", ",", "fan_out", "=", "t", ".", "size", "(", ")", "\n", "", "elif", "len", "(", "t", ".", "size", "(", ")", ")", "==", "3", ":", "\n", "# out_ch, in_ch, kernel for Conv 1", "\n", "        ", "fan_in", "=", "t", ".", "size", "(", ")", "[", "1", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "\n", "fan_out", "=", "t", ".", "size", "(", ")", "[", "0", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "\n", "", "else", ":", "\n", "        ", "fan_in", "=", "np", ".", "prod", "(", "t", ".", "size", "(", ")", ")", "\n", "fan_out", "=", "np", ".", "prod", "(", "t", ".", "size", "(", ")", ")", "\n", "\n", "", "limit", "=", "np", ".", "sqrt", "(", "6.0", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "t", ".", "uniform_", "(", "-", "limit", ",", "limit", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node._param_init": [[197, 203], ["isinstance", "nipa_q_net_node.glorot_uniform", "isinstance", "m.bias.data.zero_", "nipa_q_net_node.glorot_uniform"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.glorot_uniform", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.glorot_uniform"], ["", "def", "_param_init", "(", "m", ")", ":", "\n", "    ", "if", "isinstance", "(", "m", ",", "Parameter", ")", ":", "\n", "        ", "glorot_uniform", "(", "m", ".", "data", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "        ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "glorot_uniform", "(", "m", ".", "weight", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.weights_init": [[204, 215], ["m.modules", "m.named_parameters", "isinstance", "nipa_q_net_node._param_init", "nipa_q_net_node._param_init", "nipa_q_net_node._param_init"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init"], ["", "", "def", "weights_init", "(", "m", ")", ":", "\n", "    ", "for", "p", "in", "m", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "p", ",", "nn", ".", "ParameterList", ")", ":", "\n", "            ", "for", "pp", "in", "p", ":", "\n", "                ", "_param_init", "(", "pp", ")", "\n", "", "", "else", ":", "\n", "            ", "_param_init", "(", "p", ")", "\n", "\n", "", "", "for", "name", ",", "p", "in", "m", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "not", "'.'", "in", "name", ":", "# top-level parameters", "\n", "            ", "_param_init", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_q_net_node.node_greedy_actions": [[216, 241], ["range", "len", "len", "len", "torch.max", "torch.max", "torch.max", "torch.max", "values.append", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "actions.append", "actions.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "list_q[].size", "list_q[].size", "torch.LongTensor.data.cpu().numpy", "torch.LongTensor.data.cpu"], "function", ["None"], ["", "", "", "def", "node_greedy_actions", "(", "target_nodes", ",", "picked_nodes", ",", "list_q", ",", "net", ")", ":", "\n", "    ", "assert", "len", "(", "target_nodes", ")", "==", "len", "(", "list_q", ")", "\n", "\n", "actions", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "target_nodes", ")", ")", ":", "\n", "        ", "region", "=", "net", ".", "list_action_space", "[", "target_nodes", "[", "i", "]", "]", "\n", "if", "picked_nodes", "is", "not", "None", "and", "picked_nodes", "[", "i", "]", "is", "not", "None", ":", "\n", "            ", "region", "=", "net", ".", "list_action_space", "[", "picked_nodes", "[", "i", "]", "]", "\n", "", "if", "region", "is", "None", ":", "\n", "            ", "assert", "list_q", "[", "i", "]", ".", "size", "(", ")", "[", "0", "]", "==", "net", ".", "total_nodes", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "region", ")", "==", "list_q", "[", "i", "]", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "", "val", ",", "act", "=", "torch", ".", "max", "(", "list_q", "[", "i", "]", ",", "dim", "=", "0", ")", "\n", "values", ".", "append", "(", "val", ")", "\n", "if", "region", "is", "not", "None", ":", "\n", "            ", "act", "=", "region", "[", "act", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", "]", "\n", "# act = Variable(torch.LongTensor([act]))", "\n", "act", "=", "torch", ".", "LongTensor", "(", "[", "act", "]", ")", "\n", "actions", ".", "append", "(", "act", ")", "\n", "", "else", ":", "\n", "            ", "actions", ".", "append", "(", "act", ")", "\n", "\n", "", "", "return", "torch", ".", "cat", "(", "actions", ",", "dim", "=", "0", ")", ".", "data", ",", "torch", ".", "cat", "(", "values", ",", "dim", "=", "0", ")", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.QNetNode.__init__": [[24, 60], ["torch.Module.__init__", "len", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "deeprobust.graph.rl.env.GraphNormTool", "q_net_node.weights_init", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "node_features.size"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.weights_init"], ["    ", "def", "__init__", "(", "self", ",", "node_features", ",", "node_labels", ",", "list_action_space", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "gm", "=", "'mean_field'", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "'''\n        bilin_q: bilinear q or not\n        mlp_hidden: mlp hidden layer size\n        mav_lv: max rounds of message passing\n        '''", "\n", "super", "(", "QNetNode", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_features", "=", "node_features", "\n", "self", ".", "node_labels", "=", "node_labels", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "total_nodes", "=", "len", "(", "list_action_space", ")", "\n", "\n", "self", ".", "bilin_q", "=", "bilin_q", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "mlp_hidden", "=", "mlp_hidden", "\n", "self", ".", "max_lv", "=", "max_lv", "\n", "self", ".", "gm", "=", "gm", "\n", "\n", "if", "bilin_q", ":", "\n", "            ", "last_wout", "=", "embed_dim", "\n", "", "else", ":", "\n", "            ", "last_wout", "=", "1", "\n", "self", ".", "bias_target", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ",", "embed_dim", ")", ")", "\n", "\n", "", "if", "mlp_hidden", ":", "\n", "            ", "self", ".", "linear_1", "=", "nn", ".", "Linear", "(", "embed_dim", "*", "2", ",", "mlp_hidden", ")", "\n", "self", ".", "linear_out", "=", "nn", ".", "Linear", "(", "mlp_hidden", ",", "last_wout", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear_out", "=", "nn", ".", "Linear", "(", "embed_dim", "*", "2", ",", "last_wout", ")", "\n", "\n", "", "self", ".", "w_n2l", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "node_features", ".", "size", "(", ")", "[", "1", "]", ",", "embed_dim", ")", ")", "\n", "self", ".", "bias_n2l", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "embed_dim", ")", ")", "\n", "self", ".", "bias_picked", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ",", "embed_dim", ")", ")", "\n", "self", ".", "conv_params", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "norm_tool", "=", "GraphNormTool", "(", "normalize", "=", "True", ",", "gm", "=", "self", ".", "gm", ",", "device", "=", "device", ")", "\n", "weights_init", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.QNetNode.make_spmat": [[61, 69], ["torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "next", "sp.cuda.cuda.cuda", "q_net_node.QNetNode.parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next"], ["", "def", "make_spmat", "(", "self", ",", "n_rows", ",", "n_cols", ",", "row_idx", ",", "col_idx", ")", ":", "\n", "        ", "idxes", "=", "torch", ".", "LongTensor", "(", "[", "[", "row_idx", "]", ",", "[", "col_idx", "]", "]", ")", "\n", "values", "=", "torch", ".", "ones", "(", "1", ")", "\n", "\n", "sp", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "torch", ".", "Size", "(", "[", "n_rows", ",", "n_cols", "]", ")", ")", "\n", "if", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "is_cuda", ":", "\n", "            ", "sp", "=", "sp", ".", "cuda", "(", ")", "\n", "", "return", "sp", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.QNetNode.forward": [[70, 143], ["zip", "range", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "len", "torch.mm.clone", "torch.mm.clone", "torch.mm.clone", "torch.mm.clone", "q_net_node.node_greedy_actions", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "q_net_node.QNetNode.norm_tool.norm_extra", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "node_embed[].view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "q_net_node.QNetNode.linear_out", "list_pred.append", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "q_net_node.QNetNode.make_spmat", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "q_net_node.QNetNode.make_spmat", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "batch_graph[].get_extra_adj", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "q_net_node.QNetNode.conv_params", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "graph_embed.repeat.repeat.repeat", "node_embed[].view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "region.index", "q_net_node.QNetNode.linear_1", "node_embed[].view.size"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.node_greedy_actions", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.QNetNode.make_spmat", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.QNetNode.make_spmat", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj"], ["", "def", "forward", "(", "self", ",", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", "=", "False", ",", "is_inference", "=", "False", ")", ":", "\n", "\n", "        ", "if", "self", ".", "node_features", ".", "data", ".", "is_sparse", ":", "\n", "            ", "input_node_linear", "=", "torch", ".", "spmm", "(", "self", ".", "node_features", ",", "self", ".", "w_n2l", ")", "\n", "", "else", ":", "\n", "            ", "input_node_linear", "=", "torch", ".", "mm", "(", "self", ".", "node_features", ",", "self", ".", "w_n2l", ")", "\n", "\n", "", "input_node_linear", "+=", "self", ".", "bias_n2l", "\n", "\n", "# TODO the number of target nodes is batch_size, it actually parallizes", "\n", "target_nodes", ",", "batch_graph", ",", "picked_nodes", "=", "zip", "(", "*", "states", ")", "\n", "\n", "list_pred", "=", "[", "]", "\n", "prefix_sum", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "batch_graph", ")", ")", ":", "\n", "            ", "region", "=", "self", ".", "list_action_space", "[", "target_nodes", "[", "i", "]", "]", "\n", "\n", "node_embed", "=", "input_node_linear", ".", "clone", "(", ")", "\n", "if", "picked_nodes", "is", "not", "None", "and", "picked_nodes", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "with", "torch", ".", "set_grad_enabled", "(", "mode", "=", "not", "is_inference", ")", ":", "\n", "                    ", "picked_sp", "=", "self", ".", "make_spmat", "(", "self", ".", "total_nodes", ",", "1", ",", "picked_nodes", "[", "i", "]", ",", "0", ")", "\n", "node_embed", "+=", "torch", ".", "spmm", "(", "picked_sp", ",", "self", ".", "bias_picked", ")", "\n", "region", "=", "self", ".", "list_action_space", "[", "picked_nodes", "[", "i", "]", "]", "\n", "\n", "", "", "if", "not", "self", ".", "bilin_q", ":", "\n", "                ", "with", "torch", ".", "set_grad_enabled", "(", "mode", "=", "not", "is_inference", ")", ":", "\n", "# with torch.no_grad():", "\n", "                    ", "target_sp", "=", "self", ".", "make_spmat", "(", "self", ".", "total_nodes", ",", "1", ",", "target_nodes", "[", "i", "]", ",", "0", ")", "\n", "node_embed", "+=", "torch", ".", "spmm", "(", "target_sp", ",", "self", ".", "bias_target", ")", "\n", "\n", "", "", "with", "torch", ".", "set_grad_enabled", "(", "mode", "=", "not", "is_inference", ")", ":", "\n", "                ", "device", "=", "self", ".", "node_features", ".", "device", "\n", "adj", "=", "self", ".", "norm_tool", ".", "norm_extra", "(", "batch_graph", "[", "i", "]", ".", "get_extra_adj", "(", "device", ")", ")", "\n", "\n", "lv", "=", "0", "\n", "input_message", "=", "node_embed", "\n", "\n", "node_embed", "=", "F", ".", "relu", "(", "input_message", ")", "\n", "while", "lv", "<", "self", ".", "max_lv", ":", "\n", "                    ", "n2npool", "=", "torch", ".", "spmm", "(", "adj", ",", "node_embed", ")", "\n", "node_linear", "=", "self", ".", "conv_params", "(", "n2npool", ")", "\n", "merged_linear", "=", "node_linear", "+", "input_message", "\n", "node_embed", "=", "F", ".", "relu", "(", "merged_linear", ")", "\n", "lv", "+=", "1", "\n", "\n", "", "target_embed", "=", "node_embed", "[", "target_nodes", "[", "i", "]", ",", ":", "]", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "if", "region", "is", "not", "None", ":", "\n", "                    ", "node_embed", "=", "node_embed", "[", "region", "]", "\n", "\n", "", "graph_embed", "=", "torch", ".", "mean", "(", "node_embed", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "\n", "if", "actions", "is", "None", ":", "\n", "                    ", "graph_embed", "=", "graph_embed", ".", "repeat", "(", "node_embed", ".", "size", "(", ")", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "if", "region", "is", "not", "None", ":", "\n", "                        ", "act_idx", "=", "region", ".", "index", "(", "actions", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                        ", "act_idx", "=", "actions", "[", "i", "]", "\n", "", "node_embed", "=", "node_embed", "[", "act_idx", ",", ":", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "", "embed_s_a", "=", "torch", ".", "cat", "(", "(", "node_embed", ",", "graph_embed", ")", ",", "dim", "=", "1", ")", "\n", "if", "self", ".", "mlp_hidden", ":", "\n", "                    ", "embed_s_a", "=", "F", ".", "relu", "(", "self", ".", "linear_1", "(", "embed_s_a", ")", ")", "\n", "", "raw_pred", "=", "self", ".", "linear_out", "(", "embed_s_a", ")", "\n", "\n", "if", "self", ".", "bilin_q", ":", "\n", "                    ", "raw_pred", "=", "torch", ".", "mm", "(", "raw_pred", ",", "target_embed", ")", "\n", "", "list_pred", ".", "append", "(", "raw_pred", ")", "\n", "\n", "", "", "if", "greedy_acts", ":", "\n", "            ", "actions", ",", "_", "=", "node_greedy_actions", "(", "target_nodes", ",", "picked_nodes", ",", "list_pred", ",", "self", ")", "\n", "\n", "", "return", "actions", ",", "list_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.NStepQNetNode.__init__": [[146, 161], ["torch.Module.__init__", "len", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "list_mod.append", "q_net_node.QNetNode"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_steps", ",", "node_features", ",", "node_labels", ",", "list_action_space", ",", "bilin_q", "=", "1", ",", "embed_dim", "=", "64", ",", "mlp_hidden", "=", "64", ",", "max_lv", "=", "1", ",", "gm", "=", "'mean_field'", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "NStepQNetNode", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_features", "=", "node_features", "\n", "self", ".", "node_labels", "=", "node_labels", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "total_nodes", "=", "len", "(", "list_action_space", ")", "\n", "\n", "list_mod", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "num_steps", ")", ":", "\n", "# list_mod.append(QNetNode(node_features, node_labels, list_action_space))", "\n", "            ", "list_mod", ".", "append", "(", "QNetNode", "(", "node_features", ",", "node_labels", ",", "list_action_space", ",", "bilin_q", ",", "embed_dim", ",", "mlp_hidden", ",", "max_lv", ",", "gm", "=", "gm", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "self", ".", "list_mod", "=", "nn", ".", "ModuleList", "(", "list_mod", ")", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.NStepQNetNode.forward": [[162, 166], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", "=", "False", ",", "is_inference", "=", "False", ")", ":", "\n", "        ", "assert", "time_t", ">=", "0", "and", "time_t", "<", "self", ".", "num_steps", "\n", "\n", "return", "self", ".", "list_mod", "[", "time_t", "]", "(", "time_t", ",", "states", ",", "actions", ",", "greedy_acts", ",", "is_inference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.glorot_uniform": [[168, 181], ["numpy.sqrt", "t.uniform_", "len", "t.size", "t.size", "len", "numpy.prod", "numpy.prod", "t.size", "t.size", "t.size", "t.size", "t.size", "t.size", "t.size"], "function", ["None"], ["", "", "def", "glorot_uniform", "(", "t", ")", ":", "\n", "    ", "if", "len", "(", "t", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "        ", "fan_in", ",", "fan_out", "=", "t", ".", "size", "(", ")", "\n", "", "elif", "len", "(", "t", ".", "size", "(", ")", ")", "==", "3", ":", "\n", "# out_ch, in_ch, kernel for Conv 1", "\n", "        ", "fan_in", "=", "t", ".", "size", "(", ")", "[", "1", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "\n", "fan_out", "=", "t", ".", "size", "(", ")", "[", "0", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "\n", "", "else", ":", "\n", "        ", "fan_in", "=", "np", ".", "prod", "(", "t", ".", "size", "(", ")", ")", "\n", "fan_out", "=", "np", ".", "prod", "(", "t", ".", "size", "(", ")", ")", "\n", "\n", "", "limit", "=", "np", ".", "sqrt", "(", "6.0", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "t", ".", "uniform_", "(", "-", "limit", ",", "limit", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init": [[183, 189], ["isinstance", "q_net_node.glorot_uniform", "isinstance", "m.bias.data.zero_", "q_net_node.glorot_uniform"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.glorot_uniform", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.glorot_uniform"], ["", "def", "_param_init", "(", "m", ")", ":", "\n", "    ", "if", "isinstance", "(", "m", ",", "Parameter", ")", ":", "\n", "        ", "glorot_uniform", "(", "m", ".", "data", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "        ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "glorot_uniform", "(", "m", ".", "weight", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.weights_init": [[190, 201], ["m.modules", "m.named_parameters", "isinstance", "q_net_node._param_init", "q_net_node._param_init", "q_net_node._param_init"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init", "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node._param_init"], ["", "", "def", "weights_init", "(", "m", ")", ":", "\n", "    ", "for", "p", "in", "m", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "p", ",", "nn", ".", "ParameterList", ")", ":", "\n", "            ", "for", "pp", "in", "p", ":", "\n", "                ", "_param_init", "(", "pp", ")", "\n", "", "", "else", ":", "\n", "            ", "_param_init", "(", "p", ")", "\n", "\n", "", "", "for", "name", ",", "p", "in", "m", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "not", "'.'", "in", "name", ":", "# top-level parameters", "\n", "            ", "_param_init", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.q_net_node.node_greedy_actions": [[202, 227], ["range", "len", "len", "len", "torch.max", "torch.max", "torch.max", "torch.max", "values.append", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "actions.append", "actions.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "list_q[].size", "list_q[].size", "torch.LongTensor.data.cpu().numpy", "torch.LongTensor.data.cpu"], "function", ["None"], ["", "", "", "def", "node_greedy_actions", "(", "target_nodes", ",", "picked_nodes", ",", "list_q", ",", "net", ")", ":", "\n", "    ", "assert", "len", "(", "target_nodes", ")", "==", "len", "(", "list_q", ")", "\n", "\n", "actions", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "target_nodes", ")", ")", ":", "\n", "        ", "region", "=", "net", ".", "list_action_space", "[", "target_nodes", "[", "i", "]", "]", "\n", "if", "picked_nodes", "is", "not", "None", "and", "picked_nodes", "[", "i", "]", "is", "not", "None", ":", "\n", "            ", "region", "=", "net", ".", "list_action_space", "[", "picked_nodes", "[", "i", "]", "]", "\n", "", "if", "region", "is", "None", ":", "\n", "            ", "assert", "list_q", "[", "i", "]", ".", "size", "(", ")", "[", "0", "]", "==", "net", ".", "total_nodes", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "region", ")", "==", "list_q", "[", "i", "]", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "", "val", ",", "act", "=", "torch", ".", "max", "(", "list_q", "[", "i", "]", ",", "dim", "=", "0", ")", "\n", "values", ".", "append", "(", "val", ")", "\n", "if", "region", "is", "not", "None", ":", "\n", "            ", "act", "=", "region", "[", "act", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", "]", "\n", "# act = Variable(torch.LongTensor([act]))", "\n", "act", "=", "torch", ".", "LongTensor", "(", "[", "act", "]", ")", "\n", "actions", ".", "append", "(", "act", ")", "\n", "", "else", ":", "\n", "            ", "actions", ".", "append", "(", "act", ")", "\n", "\n", "", "", "return", "torch", ".", "cat", "(", "actions", ",", "dim", "=", "0", ")", ".", "data", ",", "torch", ".", "cat", "(", "values", ",", "dim", "=", "0", ")", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.__init__": [[30, 57], ["NodeAttackEnv.__init__", "numpy.array", "len", "int", "print", "numpy.arange", "numpy.hstack", "range", "numpy.array.sum", "len", "int", "nipa_env.NodeInjectionEnv.modified_label_list.append", "len", "labels[].clone", "dict_of_lists.items"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "features", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "dict_of_lists", ",", "classifier", ",", "ratio", "=", "0.01", ",", "parallel_size", "=", "1", ",", "reward_type", "=", "'binary'", ")", ":", "\n", "        ", "\"\"\"number of injected nodes: ratio*|V|\n           number of modifications: ratio*|V|*|D_avg|\n        \"\"\"", "\n", "# super(NodeInjectionEnv, self).__init__(features, labels, all_targets, list_action_space, classifier, num_mod, reward_type)", "\n", "super", "(", "NodeInjectionEnv", ",", "self", ")", ".", "__init__", "(", "features", ",", "labels", ",", "idx_val", ",", "dict_of_lists", ",", "classifier", ")", "\n", "self", ".", "parallel_size", "=", "parallel_size", "\n", "\n", "degrees", "=", "np", ".", "array", "(", "[", "len", "(", "d", ")", "for", "n", ",", "d", "in", "dict_of_lists", ".", "items", "(", ")", "]", ")", "\n", "N", "=", "len", "(", "degrees", "[", "degrees", ">", "0", "]", ")", "\n", "avg_degree", "=", "degrees", ".", "sum", "(", ")", "/", "N", "\n", "self", ".", "n_injected", "=", "len", "(", "degrees", ")", "-", "N", "\n", "assert", "self", ".", "n_injected", "==", "int", "(", "ratio", "*", "N", ")", "\n", "\n", "self", ".", "ori_adj_size", "=", "N", "\n", "self", ".", "n_perturbations", "=", "int", "(", "self", ".", "n_injected", "*", "avg_degree", ")", "\n", "print", "(", "\"number of perturbations: {}\"", ".", "format", "(", "self", ".", "n_perturbations", ")", ")", "\n", "self", ".", "all_nodes", "=", "np", ".", "arange", "(", "N", ")", "\n", "self", ".", "injected_nodes", "=", "self", ".", "all_nodes", "[", "-", "self", ".", "n_injected", ":", "]", "\n", "self", ".", "previous_acc", "=", "[", "1", "]", "*", "parallel_size", "\n", "\n", "self", ".", "idx_train", "=", "np", ".", "hstack", "(", "(", "idx_train", ",", "self", ".", "injected_nodes", ")", ")", "\n", "self", ".", "idx_val", "=", "idx_val", "\n", "\n", "self", ".", "modified_label_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "parallel_size", ")", ":", "\n", "            ", "self", ".", "modified_label_list", ".", "append", "(", "labels", "[", "-", "self", ".", "n_injected", ":", "]", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.init_overall_steps": [[59, 64], ["range", "nipa_env.NodeInjectionEnv.modified_list.append", "ModifiedGraph"], "methods", ["None"], ["", "", "def", "init_overall_steps", "(", "self", ")", ":", "\n", "        ", "self", ".", "overall_steps", "=", "0", "\n", "self", ".", "modified_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "parallel_size", ")", ":", "\n", "            ", "self", ".", "modified_list", ".", "append", "(", "ModifiedGraph", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.setup": [[65, 72], ["None"], "methods", ["None"], ["", "", "def", "setup", "(", "self", ")", ":", "\n", "        ", "self", ".", "n_steps", "=", "0", "\n", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "second_nodes", "=", "None", "\n", "self", ".", "rewards", "=", "None", "\n", "self", ".", "binary_rewards", "=", "None", "\n", "self", ".", "list_acc_of_all", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.step": [[73, 116], ["range", "range", "nipa_env.NodeInjectionEnv.isActionFinished", "nipa_env.NodeInjectionEnv.modified_list[].add_edge", "range", "nipa_env.NodeInjectionEnv.modified_list[].get_extra_adj", "nipa_env.NodeInjectionEnv.classifier.norm_tool.norm_extra", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "nipa_env.NodeInjectionEnv.classifier.fit", "nipa_env.NodeInjectionEnv.classifier", "loss_acc", "correct.sum", "rewards.append", "numpy.array().astype", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.add_edge", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.loss_acc"], ["", "def", "step", "(", "self", ",", "actions", ",", "inference", "=", "False", ")", ":", "\n", "        ", "'''\n            run actions and get reward\n        '''", "\n", "if", "self", ".", "first_nodes", "is", "None", ":", "# pick the first node of edge", "\n", "            ", "assert", "(", "self", ".", "n_steps", "+", "1", ")", "%", "3", "==", "1", "\n", "self", ".", "first_nodes", "=", "actions", "[", ":", "]", "\n", "\n", "", "if", "(", "self", ".", "n_steps", "+", "1", ")", "%", "3", "==", "2", ":", "\n", "            ", "self", ".", "second_nodes", "=", "actions", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "parallel_size", ")", ":", "\n", "# add an edge from the graph", "\n", "                ", "self", ".", "modified_list", "[", "i", "]", ".", "add_edge", "(", "self", ".", "first_nodes", "[", "i", "]", ",", "actions", "[", "i", "]", ",", "1.0", ")", "\n", "\n", "", "", "if", "(", "self", ".", "n_steps", "+", "1", ")", "%", "3", "==", "0", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "parallel_size", ")", ":", "\n", "# change label", "\n", "                ", "self", ".", "modified_label_list", "[", "i", "]", "[", "self", ".", "first_nodes", "[", "i", "]", "-", "self", ".", "ori_adj_size", "]", "=", "actions", "[", "i", "]", "\n", "\n", "", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "second_nodes", "=", "None", "\n", "\n", "", "self", ".", "n_steps", "+=", "1", "\n", "self", ".", "overall_steps", "+=", "1", "\n", "\n", "if", "not", "inference", ":", "\n", "            ", "if", "self", ".", "isActionFinished", "(", ")", ":", "\n", "                ", "rewards", "=", "[", "]", "\n", "for", "i", "in", "(", "range", "(", "self", ".", "parallel_size", ")", ")", ":", "\n", "                    ", "device", "=", "self", ".", "labels", ".", "device", "\n", "extra_adj", "=", "self", ".", "modified_list", "[", "i", "]", ".", "get_extra_adj", "(", "device", "=", "device", ")", "\n", "adj", "=", "self", ".", "classifier", ".", "norm_tool", ".", "norm_extra", "(", "extra_adj", ")", "\n", "labels", "=", "torch", ".", "cat", "(", "(", "self", ".", "labels", ",", "self", ".", "modified_label_list", "[", "i", "]", ")", ")", "\n", "# self.classifier.fit(self.features, adj, labels, self.idx_train, self.idx_val, normalize=False)", "\n", "self", ".", "classifier", ".", "fit", "(", "self", ".", "features", ",", "adj", ",", "labels", ",", "self", ".", "idx_train", ",", "self", ".", "idx_val", ",", "normalize", "=", "False", ",", "patience", "=", "30", ")", "\n", "output", "=", "self", ".", "classifier", "(", "self", ".", "features", ",", "adj", ")", "\n", "loss", ",", "correct", "=", "loss_acc", "(", "output", ",", "self", ".", "labels", ",", "self", ".", "idx_val", ",", "avg_loss", "=", "False", ")", "\n", "acc", "=", "correct", ".", "sum", "(", ")", "\n", "# r = 1 if self.previous_acc[i] - acc > 0.01  else -1", "\n", "r", "=", "1", "if", "self", ".", "previous_acc", "[", "i", "]", "-", "acc", ">", "0", "else", "-", "1", "\n", "self", ".", "previous_acc", "[", "i", "]", "=", "acc", "\n", "rewards", ".", "append", "(", "r", ")", "\n", "self", ".", "rewards", "=", "np", ".", "array", "(", "rewards", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.sample_pos_rewards": [[118, 133], ["range", "random.shuffle", "len", "range", "len", "numpy.where", "len", "cands.append"], "methods", ["None"], ["", "", "", "", "def", "sample_pos_rewards", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "assert", "self", ".", "list_acc_of_all", "is", "not", "None", "\n", "cands", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "list_acc_of_all", ")", ")", ":", "\n", "            ", "succ", "=", "np", ".", "where", "(", "self", ".", "list_acc_of_all", "[", "i", "]", "<", "0.9", ")", "[", "0", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "succ", ")", ")", ":", "\n", "\n", "                ", "cands", ".", "append", "(", "(", "i", ",", "self", ".", "all_targets", "[", "succ", "[", "j", "]", "]", ")", ")", "\n", "\n", "", "", "if", "num_samples", ">", "len", "(", "cands", ")", ":", "\n", "            ", "return", "cands", "\n", "", "random", ".", "shuffle", "(", "cands", ")", "\n", "return", "cands", "[", "0", ":", "num_samples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.uniformRandActions": [[134, 153], ["range", "act_list.append", "numpy.random.choice", "numpy.random.randint", "numpy.random.randint", "len", "numpy.random.randint", "len", "nipa_env.NodeInjectionEnv.labels.cpu().max", "nipa_env.NodeInjectionEnv.labels.cpu"], "methods", ["None"], ["", "def", "uniformRandActions", "(", "self", ")", ":", "\n", "        ", "act_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "parallel_size", ")", ":", "\n", "            ", "if", "self", ".", "first_nodes", "is", "None", ":", "\n", "# a1: choose a node from injected nodes", "\n", "                ", "cur_action", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "injected_nodes", ")", "\n", "\n", "", "if", "self", ".", "first_nodes", "is", "not", "None", "and", "self", ".", "second_nodes", "is", "None", ":", "\n", "# a2: choose a node from all nodes", "\n", "                ", "cur_action", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "list_action_space", ")", ")", "\n", "while", "(", "self", ".", "first_nodes", "[", "i", "]", ",", "cur_action", ")", "in", "self", ".", "modified_list", "[", "i", "]", ".", "edge_set", ":", "\n", "                    ", "cur_action", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "list_action_space", ")", ")", "\n", "\n", "", "", "if", "self", ".", "first_nodes", "is", "not", "None", "and", "self", ".", "second_nodes", "is", "not", "None", ":", "\n", "# a3: choose label", "\n", "                ", "cur_action", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "labels", ".", "cpu", "(", ")", ".", "max", "(", ")", "+", "1", ")", "\n", "\n", "", "act_list", ".", "append", "(", "cur_action", ")", "\n", "", "return", "act_list", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isActionFinished": [[154, 158], ["None"], "methods", ["None"], ["", "def", "isActionFinished", "(", "self", ")", ":", "\n", "        ", "if", "(", "self", ".", "n_steps", ")", "%", "3", "==", "0", "and", "self", ".", "n_steps", "!=", "0", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.isTerminal": [[159, 163], ["None"], "methods", ["None"], ["", "def", "isTerminal", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "overall_steps", "==", "3", "*", "self", ".", "n_perturbations", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.getStateRef": [[164, 166], ["list", "zip"], "methods", ["None"], ["", "def", "getStateRef", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "zip", "(", "self", ".", "modified_list", ",", "self", ".", "modified_label_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_env.NodeInjectionEnv.cloneState": [[167, 169], ["list", "zip", "copy.deepcopy", "copy.deepcopy"], "methods", ["None"], ["", "def", "cloneState", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "zip", "(", "deepcopy", "(", "self", ".", "modified_list", ")", ",", "deepcopy", "(", "self", ".", "modified_label_list", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_config.build_kwargs": [[49, 54], ["str"], "function", ["None"], ["def", "build_kwargs", "(", "keys", ",", "arg_dict", ")", ":", "\n", "    ", "st", "=", "''", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "st", "+=", "'%s-%s'", "%", "(", "key", ",", "str", "(", "arg_dict", "[", "key", "]", ")", ")", "\n", "", "return", "st", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.rl_s2v_config.save_args": [[55, 58], ["open", "pickle.dump"], "function", ["None"], ["", "def", "save_args", "(", "fout", ",", "args", ")", ":", "\n", "    ", "with", "open", "(", "fout", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cp", ".", "dump", "(", "args", ",", "f", ",", "cp", ".", "HIGHEST_PROTOCOL", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_nstep_replay_mem.NstepReplayMem.__init__": [[27, 35], ["range", "nipa_nstep_replay_mem.NstepReplayMem.mem_cells.append", "nipa_nstep_replay_mem.NstepReplayMem.mem_cells.append", "NstepReplayMemCell", "NstepReplayMemCell"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "memory_size", ",", "n_steps", ",", "balance_sample", "=", "False", ")", ":", "\n", "        ", "self", ".", "mem_cells", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_steps", "-", "1", ")", ":", "\n", "            ", "self", ".", "mem_cells", ".", "append", "(", "NstepReplayMemCell", "(", "memory_size", ",", "False", ")", ")", "\n", "", "self", ".", "mem_cells", ".", "append", "(", "NstepReplayMemCell", "(", "memory_size", ",", "balance_sample", ")", ")", "\n", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "memory_size", "=", "memory_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_nstep_replay_mem.NstepReplayMem.add": [[36, 43], ["nipa_nstep_replay_mem.NstepReplayMem.mem_cells[].add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "add", "(", "self", ",", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ",", "t", ")", ":", "\n", "        ", "assert", "t", ">=", "0", "and", "t", "<", "self", ".", "n_steps", "\n", "if", "t", "==", "self", ".", "n_steps", "-", "1", ":", "\n", "            ", "assert", "terminal", "\n", "", "else", ":", "\n", "            ", "assert", "not", "terminal", "\n", "", "self", ".", "mem_cells", "[", "t", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_nstep_replay_mem.NstepReplayMem.add_list": [[44, 51], ["range", "len", "nipa_nstep_replay_mem.NstepReplayMem.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "add_list", "(", "self", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_sp", ",", "list_term", ",", "t", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "list_st", ")", ")", ":", "\n", "            ", "if", "list_sp", "is", "None", ":", "\n", "                ", "sp", "=", "(", "None", ",", "None", ",", "None", ")", "\n", "", "else", ":", "\n", "                ", "sp", "=", "list_sp", "[", "i", "]", "\n", "", "self", ".", "add", "(", "list_st", "[", "i", "]", ",", "list_at", "[", "i", "]", ",", "list_rt", "[", "i", "]", ",", "sp", ",", "list_term", "[", "i", "]", ",", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_nstep_replay_mem.NstepReplayMem.sample": [[52, 57], ["nipa_nstep_replay_mem.NstepReplayMem.mem_cells[].sample", "numpy.random.randint"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample"], ["", "", "def", "sample", "(", "self", ",", "batch_size", ",", "t", "=", "None", ")", ":", "\n", "        ", "if", "t", "is", "None", ":", "\n", "            ", "t", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "n_steps", ")", "\n", "", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "=", "self", ".", "mem_cells", "[", "t", "]", ".", "sample", "(", "batch_size", ")", "\n", "return", "t", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_nstep_replay_mem.nipa_hash_state_action": [[11, 24], ["None"], "function", ["None"], ["def", "nipa_hash_state_action", "(", "s_t", ",", "a_t", ")", ":", "\n", "    ", "key", "=", "s_t", "[", "0", "]", "\n", "base", "=", "179424673", "\n", "for", "e", "in", "s_t", "[", "1", "]", ".", "directed_edges", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "e", "[", "0", "]", ")", "%", "base", "\n", "key", "=", "(", "key", "*", "base", "+", "e", "[", "1", "]", ")", "%", "base", "\n", "", "if", "s_t", "[", "2", "]", "is", "not", "None", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "s_t", "[", "2", "]", ")", "%", "base", "\n", "", "else", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", ")", "%", "base", "\n", "\n", "", "key", "=", "(", "key", "*", "base", "+", "a_t", ")", "%", "base", "\n", "return", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplaySubMemCell.__init__": [[10, 21], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "memory_size", ")", ":", "\n", "        ", "self", ".", "memory_size", "=", "memory_size", "\n", "\n", "self", ".", "actions", "=", "[", "None", "]", "*", "self", ".", "memory_size", "\n", "self", ".", "rewards", "=", "[", "None", "]", "*", "self", ".", "memory_size", "\n", "self", ".", "states", "=", "[", "None", "]", "*", "self", ".", "memory_size", "\n", "self", ".", "s_primes", "=", "[", "None", "]", "*", "self", ".", "memory_size", "\n", "self", ".", "terminals", "=", "[", "None", "]", "*", "self", ".", "memory_size", "\n", "\n", "self", ".", "count", "=", "0", "\n", "self", ".", "current", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplaySubMemCell.add": [[22, 31], ["max"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ")", ":", "\n", "        ", "self", ".", "actions", "[", "self", ".", "current", "]", "=", "a_t", "\n", "self", ".", "rewards", "[", "self", ".", "current", "]", "=", "r_t", "\n", "self", ".", "states", "[", "self", ".", "current", "]", "=", "s_t", "\n", "self", ".", "s_primes", "[", "self", ".", "current", "]", "=", "s_prime", "\n", "self", ".", "terminals", "[", "self", ".", "current", "]", "=", "terminal", "\n", "\n", "self", ".", "count", "=", "max", "(", "self", ".", "count", ",", "self", ".", "current", "+", "1", ")", "\n", "self", ".", "current", "=", "(", "self", ".", "current", "+", "1", ")", "%", "self", ".", "memory_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplaySubMemCell.add_list": [[32, 39], ["range", "len", "nstep_replay_mem.NstepReplaySubMemCell.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "add_list", "(", "self", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_sp", ",", "list_term", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "list_st", ")", ")", ":", "\n", "            ", "if", "list_sp", "is", "None", ":", "\n", "                ", "sp", "=", "(", "None", ",", "None", ",", "None", ")", "\n", "", "else", ":", "\n", "                ", "sp", "=", "list_sp", "[", "i", "]", "\n", "", "self", ".", "add", "(", "list_st", "[", "i", "]", ",", "list_at", "[", "i", "]", ",", "list_rt", "[", "i", "]", ",", "sp", ",", "list_term", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplaySubMemCell.sample": [[40, 58], ["range", "random.randint", "list_st.append", "list_at.append", "list_rt.append", "list_s_primes.append", "list_term.append", "float"], "methods", ["None"], ["", "", "def", "sample", "(", "self", ",", "batch_size", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "count", ">=", "batch_size", "\n", "list_st", "=", "[", "]", "\n", "list_at", "=", "[", "]", "\n", "list_rt", "=", "[", "]", "\n", "list_s_primes", "=", "[", "]", "\n", "list_term", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "idx", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "count", "-", "1", ")", "\n", "list_st", ".", "append", "(", "self", ".", "states", "[", "idx", "]", ")", "\n", "list_at", ".", "append", "(", "self", ".", "actions", "[", "idx", "]", ")", "\n", "list_rt", ".", "append", "(", "float", "(", "self", ".", "rewards", "[", "idx", "]", ")", ")", "\n", "list_s_primes", ".", "append", "(", "self", ".", "s_primes", "[", "idx", "]", ")", "\n", "list_term", ".", "append", "(", "self", ".", "terminals", "[", "idx", "]", ")", "\n", "\n", "", "return", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMemCell.__init__": [[88, 95], ["nstep_replay_mem.NstepReplayMemCell.sub_list.append", "nstep_replay_mem.NstepReplaySubMemCell", "nstep_replay_mem.NstepReplayMemCell.sub_list.append", "set", "nstep_replay_mem.NstepReplaySubMemCell"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "memory_size", ",", "balance_sample", "=", "False", ")", ":", "\n", "        ", "self", ".", "sub_list", "=", "[", "]", "\n", "self", ".", "balance_sample", "=", "balance_sample", "\n", "self", ".", "sub_list", ".", "append", "(", "NstepReplaySubMemCell", "(", "memory_size", ")", ")", "\n", "if", "balance_sample", ":", "\n", "            ", "self", ".", "sub_list", ".", "append", "(", "NstepReplaySubMemCell", "(", "memory_size", ")", ")", "\n", "self", ".", "state_set", "=", "set", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMemCell.add": [[96, 108], ["nstep_replay_mem.NstepReplayMemCell.sub_list[].add", "nstep_replay_mem.NstepReplayMemCell.sub_list[].add", "nstep_replay_mem.hash_state_action", "nstep_replay_mem.NstepReplayMemCell.state_set.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.hash_state_action", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "", "def", "add", "(", "self", ",", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ",", "use_hash", "=", "True", ")", ":", "\n", "        ", "if", "not", "self", ".", "balance_sample", "or", "r_t", "<", "0", ":", "\n", "            ", "self", ".", "sub_list", "[", "0", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ")", "\n", "", "else", ":", "\n", "            ", "assert", "r_t", ">", "0", "\n", "if", "use_hash", ":", "\n", "# TODO add hash?", "\n", "                ", "key", "=", "hash_state_action", "(", "s_t", ",", "a_t", ")", "\n", "if", "key", "in", "self", ".", "state_set", ":", "\n", "                    ", "return", "\n", "", "self", ".", "state_set", ".", "add", "(", "key", ")", "\n", "", "self", ".", "sub_list", "[", "1", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMemCell.sample": [[109, 117], ["nstep_replay_mem.NstepReplayMemCell.sub_list[].sample", "nstep_replay_mem.NstepReplayMemCell.sub_list[].sample", "nstep_replay_mem.NstepReplayMemCell.sub_list[].sample"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample"], ["", "", "def", "sample", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "if", "not", "self", ".", "balance_sample", "or", "self", ".", "sub_list", "[", "1", "]", ".", "count", "<", "batch_size", ":", "\n", "            ", "return", "self", ".", "sub_list", "[", "0", "]", ".", "sample", "(", "batch_size", ")", "\n", "\n", "", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "=", "self", ".", "sub_list", "[", "0", "]", ".", "sample", "(", "batch_size", "//", "2", ")", "\n", "list_st2", ",", "list_at2", ",", "list_rt2", ",", "list_s_primes2", ",", "list_term2", "=", "self", ".", "sub_list", "[", "1", "]", ".", "sample", "(", "batch_size", "-", "batch_size", "//", "2", ")", "\n", "\n", "return", "list_st", "+", "list_st2", ",", "list_at", "+", "list_at2", ",", "list_rt", "+", "list_rt2", ",", "list_s_primes", "+", "list_s_primes2", ",", "list_term", "+", "list_term2", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.__init__": [[119, 128], ["range", "nstep_replay_mem.NstepReplayMem.mem_cells.append", "nstep_replay_mem.NstepReplayMem.mem_cells.append", "nstep_replay_mem.NstepReplayMemCell", "nstep_replay_mem.NstepReplayMemCell"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "memory_size", ",", "n_steps", ",", "balance_sample", "=", "False", ",", "model", "=", "'rl_s2v'", ")", ":", "\n", "        ", "self", ".", "mem_cells", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_steps", "-", "1", ")", ":", "\n", "            ", "self", ".", "mem_cells", ".", "append", "(", "NstepReplayMemCell", "(", "memory_size", ",", "False", ")", ")", "\n", "", "self", ".", "mem_cells", ".", "append", "(", "NstepReplayMemCell", "(", "memory_size", ",", "balance_sample", ")", ")", "\n", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "memory_size", "=", "memory_size", "\n", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add": [[129, 139], ["nstep_replay_mem.NstepReplayMem.mem_cells[].add", "nstep_replay_mem.NstepReplayMem.mem_cells[].add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "add", "(", "self", ",", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ",", "t", ")", ":", "\n", "        ", "assert", "t", ">=", "0", "and", "t", "<", "self", ".", "n_steps", "\n", "if", "self", ".", "model", "==", "'nipa'", ":", "\n", "            ", "self", ".", "mem_cells", "[", "t", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ",", "use_hash", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "if", "t", "==", "self", ".", "n_steps", "-", "1", ":", "\n", "                ", "assert", "terminal", "\n", "", "else", ":", "\n", "                ", "assert", "not", "terminal", "\n", "", "self", ".", "mem_cells", "[", "t", "]", ".", "add", "(", "s_t", ",", "a_t", ",", "r_t", ",", "s_prime", ",", "terminal", ",", "use_hash", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add_list": [[140, 147], ["range", "len", "nstep_replay_mem.NstepReplayMem.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "", "def", "add_list", "(", "self", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_sp", ",", "list_term", ",", "t", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "list_st", ")", ")", ":", "\n", "            ", "if", "list_sp", "is", "None", ":", "\n", "                ", "sp", "=", "(", "None", ",", "None", ",", "None", ")", "\n", "", "else", ":", "\n", "                ", "sp", "=", "list_sp", "[", "i", "]", "\n", "", "self", ".", "add", "(", "list_st", "[", "i", "]", ",", "list_at", "[", "i", "]", ",", "list_rt", "[", "i", "]", ",", "sp", ",", "list_term", "[", "i", "]", ",", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample": [[148, 153], ["numpy.random.randint", "nstep_replay_mem.NstepReplayMem.mem_cells[].sample"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample"], ["", "", "def", "sample", "(", "self", ",", "batch_size", ",", "t", "=", "None", ")", ":", "\n", "        ", "if", "t", "is", "None", ":", "\n", "            ", "t", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "n_steps", ")", "\n", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "=", "self", ".", "mem_cells", "[", "t", "]", ".", "sample", "(", "batch_size", ")", "\n", "", "return", "t", ",", "list_st", ",", "list_at", ",", "list_rt", ",", "list_s_primes", ",", "list_term", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.print_count": [[154, 158], ["range", "enumerate", "print"], "methods", ["None"], ["", "def", "print_count", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "n_steps", ")", ":", "\n", "            ", "for", "j", ",", "cell", "in", "enumerate", "(", "self", ".", "mem_cells", "[", "i", "]", ".", "sub_list", ")", ":", "\n", "                ", "print", "(", "'Cell {} sub_list {}: {}'", ".", "format", "(", "i", ",", "j", ",", "cell", ".", "count", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.hash_state_action": [[59, 72], ["None"], "function", ["None"], ["", "", "def", "hash_state_action", "(", "s_t", ",", "a_t", ")", ":", "\n", "    ", "key", "=", "s_t", "[", "0", "]", "\n", "base", "=", "179424673", "\n", "for", "e", "in", "s_t", "[", "1", "]", ".", "directed_edges", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "e", "[", "0", "]", ")", "%", "base", "\n", "key", "=", "(", "key", "*", "base", "+", "e", "[", "1", "]", ")", "%", "base", "\n", "", "if", "s_t", "[", "2", "]", "is", "not", "None", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "s_t", "[", "2", "]", ")", "%", "base", "\n", "", "else", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", ")", "%", "base", "\n", "\n", "", "key", "=", "(", "key", "*", "base", "+", "a_t", ")", "%", "base", "\n", "return", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.nipa_hash_state_action": [[73, 86], ["None"], "function", ["None"], ["", "def", "nipa_hash_state_action", "(", "s_t", ",", "a_t", ")", ":", "\n", "    ", "key", "=", "s_t", "[", "0", "]", "\n", "base", "=", "179424673", "\n", "for", "e", "in", "s_t", "[", "1", "]", ".", "directed_edges", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "e", "[", "0", "]", ")", "%", "base", "\n", "key", "=", "(", "key", "*", "base", "+", "e", "[", "1", "]", ")", "%", "base", "\n", "", "if", "s_t", "[", "2", "]", "is", "not", "None", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", "+", "s_t", "[", "2", "]", ")", "%", "base", "\n", "", "else", ":", "\n", "        ", "key", "=", "(", "key", "*", "base", ")", "%", "base", "\n", "\n", "", "key", "=", "(", "key", "*", "base", "+", "a_t", ")", "%", "base", "\n", "return", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_config.build_kwargs": [[51, 56], ["str"], "function", ["None"], ["def", "build_kwargs", "(", "keys", ",", "arg_dict", ")", ":", "\n", "    ", "st", "=", "''", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "st", "+=", "'%s-%s'", "%", "(", "key", ",", "str", "(", "arg_dict", "[", "key", "]", ")", ")", "\n", "", "return", "st", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.nipa_config.save_args": [[57, 60], ["open", "pickle.dump"], "function", ["None"], ["", "def", "save_args", "(", "fout", ",", "args", ")", ":", "\n", "    ", "with", "open", "(", "fout", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cp", ".", "dump", "(", "args", ",", "f", ",", "cp", ".", "HIGHEST_PROTOCOL", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize": [[31, 34], ["torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "len", "len"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_gsize", "(", ")", ":", "\n", "        ", "return", "torch", ".", "Size", "(", "(", "len", "(", "StaticGraph", ".", "graph", ")", ",", "len", "(", "StaticGraph", ".", "graph", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.__init__": [[37, 61], ["numpy.array", "numpy.array", "numpy.hstack", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "env.GraphNormTool.raw_adj.to", "env.GraphNormTool.raw_adj.clone", "g.edges", "env.StaticGraph.get_gsize", "torch.LongTensor.size", "torch.LongTensor.size", "torch.LongTensor.size", "torch.LongTensor.size", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.degree_normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj_tensor"], ["    ", "def", "__init__", "(", "self", ",", "normalize", ",", "gm", ",", "device", ")", ":", "\n", "        ", "self", ".", "adj_norm", "=", "normalize", "\n", "self", ".", "gm", "=", "gm", "\n", "g", "=", "StaticGraph", ".", "graph", "\n", "edges", "=", "np", ".", "array", "(", "g", ".", "edges", "(", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "rev_edges", "=", "np", ".", "array", "(", "[", "edges", "[", ":", ",", "1", "]", ",", "edges", "[", ":", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# self_edges = np.array([range(len(g)), range(len(g))], dtype=np.int64)", "\n", "# edges = np.hstack((edges.T, rev_edges, self_edges))", "\n", "edges", "=", "np", ".", "hstack", "(", "(", "edges", ".", "T", ",", "rev_edges", ")", ")", "\n", "idxes", "=", "torch", ".", "LongTensor", "(", "edges", ")", "\n", "values", "=", "torch", ".", "ones", "(", "idxes", ".", "size", "(", ")", "[", "1", "]", ")", "\n", "\n", "self", ".", "raw_adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "StaticGraph", ".", "get_gsize", "(", ")", ")", "\n", "self", ".", "raw_adj", "=", "self", ".", "raw_adj", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "normed_adj", "=", "self", ".", "raw_adj", ".", "clone", "(", ")", "\n", "if", "self", ".", "adj_norm", ":", "\n", "            ", "if", "self", ".", "gm", "==", "'gcn'", ":", "\n", "                ", "self", ".", "normed_adj", "=", "utils", ".", "normalize_adj_tensor", "(", "self", ".", "normed_adj", ",", "sparse", "=", "True", ")", "\n", "# GraphLaplacianNorm(self.normed_adj)", "\n", "", "else", ":", "\n", "\n", "                ", "self", ".", "normed_adj", "=", "utils", ".", "degree_normalize_adj_tensor", "(", "self", ".", "normed_adj", ",", "sparse", "=", "True", ")", "\n", "# GraphDegreeNorm(self.normed_adj)", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra": [[63, 75], ["deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.degree_normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.degree_normalize_adj_tensor"], ["", "", "", "def", "norm_extra", "(", "self", ",", "added_adj", "=", "None", ")", ":", "\n", "        ", "if", "added_adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "normed_adj", "\n", "\n", "", "new_adj", "=", "self", ".", "raw_adj", "+", "added_adj", "\n", "if", "self", ".", "adj_norm", ":", "\n", "            ", "if", "self", ".", "gm", "==", "'gcn'", ":", "\n", "                ", "new_adj", "=", "utils", ".", "normalize_adj_tensor", "(", "new_adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "new_adj", "=", "utils", ".", "degree_normalize_adj_tensor", "(", "new_adj", ",", "sparse", "=", "True", ")", "\n", "\n", "", "", "return", "new_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.__init__": [[79, 89], ["set", "set", "numpy.arange", "range", "copy.deepcopy", "copy.deepcopy", "env.StaticGraph.get_gsize", "env.StaticGraph.get_gsize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize"], ["    ", "def", "__init__", "(", "self", ",", "directed_edges", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "        ", "self", ".", "edge_set", "=", "set", "(", ")", "#(first, second)", "\n", "self", ".", "node_set", "=", "set", "(", "range", "(", "StaticGraph", ".", "get_gsize", "(", ")", "[", "0", "]", ")", ")", "\n", "self", ".", "node_set", "=", "np", ".", "arange", "(", "StaticGraph", ".", "get_gsize", "(", ")", "[", "0", "]", ")", "\n", "if", "directed_edges", "is", "not", "None", ":", "\n", "            ", "self", ".", "directed_edges", "=", "deepcopy", "(", "directed_edges", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "weights", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "directed_edges", "=", "[", "]", "\n", "self", ".", "weights", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.add_edge": [[90, 104], ["env.ModifiedGraph.edge_set.add", "env.ModifiedGraph.edge_set.add", "env.ModifiedGraph.directed_edges.append", "env.ModifiedGraph.weights.append"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "", "def", "add_edge", "(", "self", ",", "x", ",", "y", ",", "z", ")", ":", "\n", "        ", "assert", "x", "is", "not", "None", "and", "y", "is", "not", "None", "\n", "if", "x", "==", "y", ":", "\n", "            ", "return", "\n", "", "for", "e", "in", "self", ".", "directed_edges", ":", "\n", "            ", "if", "e", "[", "0", "]", "==", "x", "and", "e", "[", "1", "]", "==", "y", ":", "\n", "                ", "return", "\n", "", "if", "e", "[", "1", "]", "==", "x", "and", "e", "[", "0", "]", "==", "y", ":", "\n", "                ", "return", "\n", "", "", "self", ".", "edge_set", ".", "add", "(", "(", "x", ",", "y", ")", ")", "# (first, second)", "\n", "self", ".", "edge_set", ".", "add", "(", "(", "y", ",", "x", ")", ")", "# (second, first)", "\n", "self", ".", "directed_edges", ".", "append", "(", "(", "x", ",", "y", ")", ")", "\n", "# assert z < 0", "\n", "self", ".", "weights", ".", "append", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj": [[105, 120], ["len", "numpy.array", "numpy.array", "numpy.hstack", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "added_adj.to.to.to", "env.StaticGraph.get_gsize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.StaticGraph.get_gsize"], ["", "def", "get_extra_adj", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "directed_edges", ")", ":", "\n", "            ", "edges", "=", "np", ".", "array", "(", "self", ".", "directed_edges", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "rev_edges", "=", "np", ".", "array", "(", "[", "edges", "[", ":", ",", "1", "]", ",", "edges", "[", ":", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "edges", "=", "np", ".", "hstack", "(", "(", "edges", ".", "T", ",", "rev_edges", ")", ")", "\n", "\n", "idxes", "=", "torch", ".", "LongTensor", "(", "edges", ")", "\n", "values", "=", "torch", ".", "Tensor", "(", "self", ".", "weights", "+", "self", ".", "weights", ")", "\n", "\n", "added_adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "idxes", ",", "values", ",", "StaticGraph", ".", "get_gsize", "(", ")", ")", "\n", "\n", "added_adj", "=", "added_adj", ".", "to", "(", "device", ")", "\n", "return", "added_adj", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_possible_nodes": [[121, 129], ["numpy.setdiff1d", "numpy.array", "connected.append"], "methods", ["None"], ["", "", "def", "get_possible_nodes", "(", "self", ",", "target_node", ")", ":", "\n", "# connected = set()", "\n", "        ", "connected", "=", "[", "target_node", "]", "\n", "for", "n1", ",", "n2", "in", "self", ".", "edge_set", ":", "\n", "            ", "if", "n1", "==", "target_node", ":", "\n", "# connected.add(target_node)", "\n", "                ", "connected", ".", "append", "(", "n2", ")", "\n", "", "", "return", "np", ".", "setdiff1d", "(", "self", ".", "node_set", ",", "np", ".", "array", "(", "connected", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.__init__": [[137, 146], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "features", ",", "labels", ",", "all_targets", ",", "list_action_space", ",", "classifier", ",", "num_mod", "=", "1", ",", "reward_type", "=", "'binary'", ")", ":", "\n", "\n", "        ", "self", ".", "classifier", "=", "classifier", "\n", "self", ".", "list_action_space", "=", "list_action_space", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "all_targets", "=", "all_targets", "\n", "self", ".", "num_mod", "=", "num_mod", "\n", "self", ".", "reward_type", "=", "reward_type", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.setup": [[147, 158], ["range", "len", "env.NodeAttackEnv.modified_list.append", "env.ModifiedGraph"], "methods", ["None"], ["", "def", "setup", "(", "self", ",", "target_nodes", ")", ":", "\n", "        ", "self", ".", "target_nodes", "=", "target_nodes", "\n", "self", ".", "n_steps", "=", "0", "\n", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "rewards", "=", "None", "\n", "self", ".", "binary_rewards", "=", "None", "\n", "self", ".", "modified_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "            ", "self", ".", "modified_list", ".", "append", "(", "ModifiedGraph", "(", ")", ")", "\n", "\n", "", "self", ".", "list_acc_of_all", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.step": [[159, 202], ["env.NodeAttackEnv.isTerminal", "range", "range", "len", "env.NodeAttackEnv.modified_list[].add_edge", "len", "env.NodeAttackEnv.modified_list[].get_extra_adj", "env.NodeAttackEnv.classifier.norm_tool.norm_extra", "env.NodeAttackEnv.classifier", "loss_acc", "env.NodeAttackEnv.all_targets.index", "numpy.copy", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu().view().numpy", "env.NodeAttackEnv.list_acc_of_all.append", "acc_list.append", "loss_list.append", "numpy.array().astype", "numpy.copy.double().cpu().view().numpy", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu().view", "numpy.array", "numpy.copy.double().cpu().view", "numpy.array", "loss.data.cpu().view().numpy.data.cpu().view().numpy.data.cpu", "numpy.array", "numpy.copy.double().cpu", "numpy.copy.double"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.add_edge", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.ModifiedGraph.get_extra_adj", "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.GraphNormTool.norm_extra", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.loss_acc"], ["", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "\"\"\"run actions and get rewards\n        \"\"\"", "\n", "if", "self", ".", "first_nodes", "is", "None", ":", "# pick the first node of edge", "\n", "            ", "assert", "self", ".", "n_steps", "%", "2", "==", "0", "\n", "self", ".", "first_nodes", "=", "actions", "[", ":", "]", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "# assert self.first_nodes[i] != actions[i]", "\n", "# deleta an edge from the graph", "\n", "                ", "self", ".", "modified_list", "[", "i", "]", ".", "add_edge", "(", "self", ".", "first_nodes", "[", "i", "]", ",", "actions", "[", "i", "]", ",", "-", "1.0", ")", "\n", "", "self", ".", "first_nodes", "=", "None", "\n", "self", ".", "banned_list", "=", "None", "\n", "", "self", ".", "n_steps", "+=", "1", "\n", "\n", "if", "self", ".", "isTerminal", "(", ")", ":", "\n", "# only calc reward when its terminal", "\n", "            ", "acc_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "# for i in tqdm(range(len(self.target_nodes))):", "\n", "for", "i", "in", "(", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ")", ":", "\n", "                ", "device", "=", "self", ".", "labels", ".", "device", "\n", "extra_adj", "=", "self", ".", "modified_list", "[", "i", "]", ".", "get_extra_adj", "(", "device", "=", "device", ")", "\n", "adj", "=", "self", ".", "classifier", ".", "norm_tool", ".", "norm_extra", "(", "extra_adj", ")", "\n", "\n", "output", "=", "self", ".", "classifier", "(", "self", ".", "features", ",", "adj", ")", "\n", "\n", "loss", ",", "acc", "=", "loss_acc", "(", "output", ",", "self", ".", "labels", ",", "self", ".", "all_targets", ",", "avg_loss", "=", "False", ")", "\n", "# _, loss, acc = self.classifier(self.features, Variable(adj), self.all_targets, self.labels, avg_loss=False)", "\n", "\n", "cur_idx", "=", "self", ".", "all_targets", ".", "index", "(", "self", ".", "target_nodes", "[", "i", "]", ")", "\n", "acc", "=", "np", ".", "copy", "(", "acc", ".", "double", "(", ")", ".", "cpu", "(", ")", ".", "view", "(", "-", "1", ")", ".", "numpy", "(", ")", ")", "\n", "loss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "view", "(", "-", "1", ")", ".", "numpy", "(", ")", "\n", "self", ".", "list_acc_of_all", ".", "append", "(", "acc", ")", "\n", "acc_list", ".", "append", "(", "acc", "[", "cur_idx", "]", ")", "\n", "loss_list", ".", "append", "(", "loss", "[", "cur_idx", "]", ")", "\n", "\n", "", "self", ".", "binary_rewards", "=", "(", "np", ".", "array", "(", "acc_list", ")", "*", "-", "2.0", "+", "1.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "self", ".", "reward_type", "==", "'binary'", ":", "\n", "                ", "self", ".", "rewards", "=", "(", "np", ".", "array", "(", "acc_list", ")", "*", "-", "2.0", "+", "1.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "                ", "assert", "self", ".", "reward_type", "==", "'nll'", "\n", "self", ".", "rewards", "=", "np", ".", "array", "(", "loss_list", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.sample_pos_rewards": [[203, 218], ["range", "random.shuffle", "len", "range", "len", "numpy.where", "len", "cands.append"], "methods", ["None"], ["", "", "", "def", "sample_pos_rewards", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "assert", "self", ".", "list_acc_of_all", "is", "not", "None", "\n", "cands", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "list_acc_of_all", ")", ")", ":", "\n", "            ", "succ", "=", "np", ".", "where", "(", "self", ".", "list_acc_of_all", "[", "i", "]", "<", "0.9", ")", "[", "0", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "succ", ")", ")", ":", "\n", "\n", "                ", "cands", ".", "append", "(", "(", "i", ",", "self", ".", "all_targets", "[", "succ", "[", "j", "]", "]", ")", ")", "\n", "\n", "", "", "if", "num_samples", ">", "len", "(", "cands", ")", ":", "\n", "            ", "return", "cands", "\n", "", "random", ".", "shuffle", "(", "cands", ")", "\n", "return", "cands", "[", "0", ":", "num_samples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.uniformRandActions": [[219, 238], ["range", "len", "act_list.append", "numpy.random.randint", "len", "numpy.random.randint", "len"], "methods", ["None"], ["", "def", "uniformRandActions", "(", "self", ")", ":", "\n", "# TODO: here only support deleting edges", "\n", "# seems they sample first node from 2-hop neighbours", "\n", "        ", "act_list", "=", "[", "]", "\n", "offset", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "target_nodes", ")", ")", ":", "\n", "            ", "cur_node", "=", "self", ".", "target_nodes", "[", "i", "]", "\n", "region", "=", "self", ".", "list_action_space", "[", "cur_node", "]", "\n", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", "and", "self", ".", "first_nodes", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "region", "=", "self", ".", "list_action_space", "[", "self", ".", "first_nodes", "[", "i", "]", "]", "\n", "\n", "", "if", "region", "is", "None", ":", "# singleton node", "\n", "                ", "cur_action", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "list_action_space", ")", ")", "\n", "", "else", ":", "# select from neighbours or 2-hop neighbours", "\n", "                ", "cur_action", "=", "region", "[", "np", ".", "random", ".", "randint", "(", "len", "(", "region", ")", ")", "]", "\n", "\n", "", "act_list", ".", "append", "(", "cur_action", ")", "\n", "", "return", "act_list", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.isTerminal": [[239, 243], ["None"], "methods", ["None"], ["", "def", "isTerminal", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "n_steps", "==", "2", "*", "self", ".", "num_mod", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.getStateRef": [[244, 250], ["zip", "len"], "methods", ["None"], ["", "def", "getStateRef", "(", "self", ")", ":", "\n", "        ", "cp_first", "=", "[", "None", "]", "*", "len", "(", "self", ".", "target_nodes", ")", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", ":", "\n", "            ", "cp_first", "=", "self", ".", "first_nodes", "\n", "\n", "", "return", "zip", "(", "self", ".", "target_nodes", ",", "self", ".", "modified_list", ",", "cp_first", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.rl.env.NodeAttackEnv.cloneState": [[251, 257], ["list", "len", "zip", "copy.deepcopy"], "methods", ["None"], ["", "def", "cloneState", "(", "self", ")", ":", "\n", "        ", "cp_first", "=", "[", "None", "]", "*", "len", "(", "self", ".", "target_nodes", ")", "\n", "if", "self", ".", "first_nodes", "is", "not", "None", ":", "\n", "            ", "cp_first", "=", "self", ".", "first_nodes", "[", ":", "]", "\n", "\n", "", "return", "list", "(", "zip", "(", "self", ".", "target_nodes", "[", ":", "]", ",", "deepcopy", "(", "self", ".", "modified_list", ")", ",", "cp_first", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PtbDataset.__init__": [[37, 51], ["name.lower", "os.expanduser", "os.expanduser", "os.join", "os.join", "attacked_data.PtbDataset.load_data", "os.normpath", "os.normpath"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_data"], ["def", "__init__", "(", "self", ",", "root", ",", "name", ",", "attack_method", "=", "'mettack'", ")", ":", "\n", "        ", "assert", "attack_method", "in", "[", "'mettack'", ",", "'metattack'", ",", "'meta'", "]", ",", "'Currently the database only stores graphs perturbed by 5% mettack'", "\n", "\n", "self", ".", "name", "=", "name", ".", "lower", "(", ")", "\n", "assert", "self", ".", "name", "in", "[", "'cora'", ",", "'citeseer'", ",", "'polblogs'", "]", ",", "'Currently only support cora, citeseer, polblogs'", "\n", "\n", "self", ".", "attack_method", "=", "'mettack'", "# attack_method", "\n", "self", ".", "url", "=", "'https://raw.githubusercontent.com/ChandlerBang/pytorch-gnn-meta-attack/master/pre-attacked/{}_{}_0.05.npz'", ".", "format", "(", "self", ".", "name", ",", "self", ".", "attack_method", ")", "\n", "self", ".", "root", "=", "osp", ".", "expanduser", "(", "osp", ".", "normpath", "(", "root", ")", ")", "\n", "self", ".", "data_filename", "=", "osp", ".", "join", "(", "root", ",", "\n", "'{}_{}_0.05.npz'", ".", "format", "(", "self", ".", "name", ",", "self", ".", "attack_method", ")", ")", "\n", "self", ".", "adj", "=", "self", ".", "load_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PtbDataset.load_data": [[52, 59], ["print", "scipy.load_npz", "warnings.warn", "os.exists", "os.exists", "attacked_data.PtbDataset.download_npz"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_npz"], ["", "def", "load_data", "(", "self", ")", ":", "\n", "        ", "if", "not", "osp", ".", "exists", "(", "self", ".", "data_filename", ")", ":", "\n", "            ", "self", ".", "download_npz", "(", ")", "\n", "", "print", "(", "'Loading {} dataset perturbed by 0.05 mettack...'", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "adj", "=", "sp", ".", "load_npz", "(", "self", ".", "data_filename", ")", "\n", "warnings", ".", "warn", "(", "'''the adjacency matrix is perturbed, using the data splits under seed 15(default seed for deeprobust.graph.data.Dataset), so if you are going to verify the attacking performance, you should use the same data splits'''", ")", "\n", "return", "adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PtbDataset.download_npz": [[60, 67], ["print", "urllib.request.urlretrieve", "Exception"], "methods", ["None"], ["", "def", "download_npz", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Dowloading from {} to {}'", ".", "format", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", ")", "\n", "try", ":", "\n", "            ", "urllib", ".", "request", ".", "urlretrieve", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "'''Download failed! Make sure you have\n                    stable Internet connection and enter the right name'''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.__init__": [[105, 128], ["name.lower", "os.expanduser", "os.expanduser", "os.join", "os.join", "attacked_data.PrePtbDataset.load_data", "os.normpath", "os.normpath"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_data"], ["def", "__init__", "(", "self", ",", "root", ",", "name", ",", "attack_method", "=", "'meta'", ",", "ptb_rate", "=", "0.05", ")", ":", "\n", "\n", "        ", "if", "attack_method", "==", "'mettack'", "or", "attack_method", "==", "'metattack'", ":", "\n", "            ", "attack_method", "=", "'meta'", "\n", "\n", "", "assert", "attack_method", "in", "[", "'meta'", ",", "'nettack'", "]", ",", "' Currently the database only stores graphs perturbed by metattack, nettack'", "\n", "# assert attack_method in ['meta'], \\", "\n", "#     ' Currently the database only stores graphs perturbed by metattack. Will update nettack soon.'", "\n", "\n", "self", ".", "name", "=", "name", ".", "lower", "(", ")", "\n", "assert", "self", ".", "name", "in", "[", "'cora'", ",", "'citeseer'", ",", "'polblogs'", ",", "'pubmed'", ",", "'cora_ml'", "]", ",", "'Currently only support cora, citeseer, pubmed, polblogs, cora_ml'", "\n", "\n", "self", ".", "attack_method", "=", "attack_method", "\n", "self", ".", "ptb_rate", "=", "ptb_rate", "\n", "self", ".", "url", "=", "'https://raw.githubusercontent.com/ChandlerBang/Pro-GNN/master/{}/{}_{}_adj_{}.npz'", ".", "format", "(", "self", ".", "attack_method", ",", "self", ".", "name", ",", "self", ".", "attack_method", ",", "self", ".", "ptb_rate", ")", "\n", "self", ".", "root", "=", "osp", ".", "expanduser", "(", "osp", ".", "normpath", "(", "root", ")", ")", "\n", "self", ".", "data_filename", "=", "osp", ".", "join", "(", "root", ",", "\n", "'{}_{}_adj_{}.npz'", ".", "format", "(", "self", ".", "name", ",", "self", ".", "attack_method", ",", "self", ".", "ptb_rate", ")", ")", "\n", "self", ".", "target_nodes", "=", "None", "\n", "self", ".", "adj", "=", "self", ".", "load_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.load_data": [[129, 144], ["print", "os.exists", "os.exists", "attacked_data.PrePtbDataset.download_npz", "warnings.warn", "scipy.load_npz", "warnings.warn", "scipy.load_npz", "attacked_data.PrePtbDataset.get_target_nodes"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_npz", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz", "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.get_target_nodes"], ["", "def", "load_data", "(", "self", ")", ":", "\n", "        ", "if", "not", "osp", ".", "exists", "(", "self", ".", "data_filename", ")", ":", "\n", "            ", "self", ".", "download_npz", "(", ")", "\n", "", "print", "(", "'Loading {} dataset perturbed by {} {}...'", ".", "format", "(", "self", ".", "name", ",", "self", ".", "ptb_rate", ",", "self", ".", "attack_method", ")", ")", "\n", "\n", "if", "self", ".", "attack_method", "==", "'meta'", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"the pre-attacked graph is perturbed, using the data splits under seed 15 (default seed), so if you are going to verify the attacking performance, you should use the same data splits.\"", ")", "\n", "adj", "=", "sp", ".", "load_npz", "(", "self", ".", "data_filename", ")", "\n", "\n", "", "if", "self", ".", "attack_method", "==", "'nettack'", ":", "\n", "# assert True, \"Will update pre-attacked data by nettack soon\"", "\n", "            ", "warnings", ".", "warn", "(", "\"the pre-attacked graph is perturbed, using the data splits under seed 15 (default seed), so if you are going to verify the attacking performance, you should use the same seed (15).\"", ")", "\n", "adj", "=", "sp", ".", "load_npz", "(", "self", ".", "data_filename", ")", "\n", "self", ".", "target_nodes", "=", "self", ".", "get_target_nodes", "(", ")", "\n", "", "return", "adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.get_target_nodes": [[145, 157], ["os.join", "os.join", "os.exists", "os.exists", "attacked_data.PrePtbDataset.download_file", "open", "json.loads", "f.read"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.download_file"], ["", "def", "get_target_nodes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get target nodes incides, which is the nodes with degree > 10 in the test set.\"\"\"", "\n", "url", "=", "'https://raw.githubusercontent.com/ChandlerBang/Pro-GNN/master/nettack/{}_nettacked_nodes.json'", ".", "format", "(", "self", ".", "name", ")", "\n", "json_file", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "\n", "'{}_nettacked_nodes.json'", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "\n", "if", "not", "osp", ".", "exists", "(", "json_file", ")", ":", "\n", "            ", "self", ".", "download_file", "(", "url", ",", "json_file", ")", "\n", "# with open(f'/mnt/home/jinwei2/Projects/nettack/{dataset}_nettacked_nodes.json', 'r') as f:", "\n", "", "with", "open", "(", "json_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "idx", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ")", "\n", "", "return", "idx", "[", "\"attacked_test_nodes\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.download_file": [[158, 165], ["print", "urllib.request.urlretrieve", "Exception"], "methods", ["None"], ["", "def", "download_file", "(", "self", ",", "url", ",", "file", ")", ":", "\n", "        ", "print", "(", "'Dowloading from {} to {}'", ".", "format", "(", "url", ",", "file", ")", ")", "\n", "try", ":", "\n", "            ", "urllib", ".", "request", ".", "urlretrieve", "(", "url", ",", "file", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"Download failed! Make sure you have \\\n                    stable Internet connection and enter the right name\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.PrePtbDataset.download_npz": [[166, 173], ["print", "urllib.request.urlretrieve", "Exception"], "methods", ["None"], ["", "", "def", "download_npz", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Dowloading from {} to {}'", ".", "format", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", ")", "\n", "try", ":", "\n", "            ", "urllib", ".", "request", ".", "urlretrieve", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"Download failed! Make sure you have \\\n                    stable Internet connection and enter the right name\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.RandomAttack.__init__": [[177, 179], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "name", "=", "'RandomAttack'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.RandomAttack.attack": [[180, 184], ["print", "attacked_data.RandomAttack._random_add_edges"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.RandomAttack._random_add_edges"], ["", "def", "attack", "(", "self", ",", "adj", ",", "ratio", "=", "0.4", ")", ":", "\n", "        ", "print", "(", "'random attack: ratio=%s'", "%", "ratio", ")", "\n", "modified_adj", "=", "self", ".", "_random_add_edges", "(", "adj", ",", "ratio", ")", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.attacked_data.RandomAttack._random_add_edges": [[185, 208], ["attacked_data.RandomAttack._random_add_edges.sample_zero_n"], "methods", ["None"], ["", "def", "_random_add_edges", "(", "self", ",", "adj", ",", "add_ratio", ")", ":", "\n", "\n", "        ", "def", "sample_zero_forever", "(", "mat", ")", ":", "\n", "            ", "nonzero_or_sampled", "=", "set", "(", "zip", "(", "*", "mat", ".", "nonzero", "(", ")", ")", ")", "\n", "while", "True", ":", "\n", "                ", "t", "=", "tuple", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "mat", ".", "shape", "[", "0", "]", ",", "2", ")", ")", "\n", "if", "t", "not", "in", "nonzero_or_sampled", ":", "\n", "                    ", "yield", "t", "\n", "nonzero_or_sampled", ".", "add", "(", "t", ")", "\n", "nonzero_or_sampled", ".", "add", "(", "(", "t", "[", "1", "]", ",", "t", "[", "0", "]", ")", ")", "\n", "\n", "", "", "", "def", "sample_zero_n", "(", "mat", ",", "n", "=", "100", ")", ":", "\n", "            ", "itr", "=", "sample_zero_forever", "(", "mat", ")", "\n", "return", "[", "next", "(", "itr", ")", "for", "_", "in", "range", "(", "n", ")", "]", "\n", "\n", "", "assert", "np", ".", "abs", "(", "adj", "-", "adj", ".", "T", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "non_zeros", "=", "[", "(", "x", ",", "y", ")", "for", "x", ",", "y", "in", "np", ".", "argwhere", "(", "adj", "!=", "0", ")", "if", "x", "<", "y", "]", "# (x, y)", "\n", "\n", "added", "=", "sample_zero_n", "(", "adj", ",", "n", "=", "int", "(", "add_ratio", "*", "len", "(", "non_zeros", ")", ")", ")", "\n", "for", "x", ",", "y", "in", "added", ":", "\n", "            ", "adj", "[", "x", ",", "y", "]", "=", "1", "\n", "adj", "[", "y", ",", "x", "]", "=", "1", "\n", "", "return", "adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.__init__": [[37, 42], ["pyg_dataset.Dpr2Pyg.process", "pyg_dataset.Dpr2Pyg.collate"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.process"], ["def", "__init__", "(", "self", ",", "dpr_data", ",", "transform", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transform", "\n", "pyg_data", "=", "self", ".", "process", "(", "dpr_data", ")", "\n", "self", ".", "data", ",", "self", ".", "slices", "=", "self", ".", "collate", "(", "[", "pyg_data", "]", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.process": [[43, 60], ["torch.LongTensor", "scipy.issparse", "torch.LongTensor", "torch_geometric.data.Data", "pyg_dataset.index_to_mask", "pyg_dataset.index_to_mask", "pyg_dataset.index_to_mask", "dpr_data.adj.nonzero", "torch.FloatTensor().float", "torch.FloatTensor().float", "torch.LongTensor.size", "torch.LongTensor.size", "torch.LongTensor.size", "torch.FloatTensor", "torch.FloatTensor", "dpr_data.features.todense"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask"], ["", "def", "process", "(", "self", ",", "dpr_data", ")", ":", "\n", "        ", "edge_index", "=", "torch", ".", "LongTensor", "(", "dpr_data", ".", "adj", ".", "nonzero", "(", ")", ")", "\n", "# by default, the features in pyg data is dense", "\n", "if", "sp", ".", "issparse", "(", "dpr_data", ".", "features", ")", ":", "\n", "            ", "x", "=", "torch", ".", "FloatTensor", "(", "dpr_data", ".", "features", ".", "todense", "(", ")", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "torch", ".", "FloatTensor", "(", "dpr_data", ".", "features", ")", ".", "float", "(", ")", "\n", "", "y", "=", "torch", ".", "LongTensor", "(", "dpr_data", ".", "labels", ")", "\n", "idx_train", ",", "idx_val", ",", "idx_test", "=", "dpr_data", ".", "idx_train", ",", "dpr_data", ".", "idx_val", ",", "dpr_data", ".", "idx_test", "\n", "data", "=", "Data", "(", "x", "=", "x", ",", "edge_index", "=", "edge_index", ",", "y", "=", "y", ")", "\n", "train_mask", "=", "index_to_mask", "(", "idx_train", ",", "size", "=", "y", ".", "size", "(", "0", ")", ")", "\n", "val_mask", "=", "index_to_mask", "(", "idx_val", ",", "size", "=", "y", ".", "size", "(", "0", ")", ")", "\n", "test_mask", "=", "index_to_mask", "(", "idx_test", ",", "size", "=", "y", ".", "size", "(", "0", ")", ")", "\n", "data", ".", "train_mask", "=", "train_mask", "\n", "data", ".", "val_mask", "=", "val_mask", "\n", "data", ".", "test_mask", "=", "test_mask", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.update_edge_index": [[61, 72], ["torch.LongTensor", "pyg_dataset.Dpr2Pyg.collate", "adj.nonzero"], "methods", ["None"], ["", "def", "update_edge_index", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\" This is an inplace operation to substitute the original edge_index\n        with adj.nonzero()\n\n        Parameters\n        ----------\n        adj: sp.csr_matrix\n            update the original adjacency into adj (by change edge_index)\n        \"\"\"", "\n", "self", ".", "data", ".", "edge_index", "=", "torch", ".", "LongTensor", "(", "adj", ".", "nonzero", "(", ")", ")", "\n", "self", ".", "data", ",", "self", ".", "slices", "=", "self", ".", "collate", "(", "[", "self", ".", "data", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.get": [[73, 86], ["pyg_dataset.Dpr2Pyg.data.__class__", "hasattr", "list", "slice", "itertools.repeat", "slice", "item.dim", "pyg_dataset.Dpr2Pyg.data.__cat_dim__"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "idx", ")", ":", "\n", "        ", "data", "=", "self", ".", "data", ".", "__class__", "(", ")", "\n", "\n", "if", "hasattr", "(", "self", ".", "data", ",", "'__num_nodes__'", ")", ":", "\n", "            ", "data", ".", "num_nodes", "=", "self", ".", "data", ".", "__num_nodes__", "[", "idx", "]", "\n", "\n", "", "for", "key", "in", "self", ".", "data", ".", "keys", ":", "\n", "            ", "item", ",", "slices", "=", "self", ".", "data", "[", "key", "]", ",", "self", ".", "slices", "[", "key", "]", "\n", "s", "=", "list", "(", "repeat", "(", "slice", "(", "None", ")", ",", "item", ".", "dim", "(", ")", ")", ")", "\n", "s", "[", "self", ".", "data", ".", "__cat_dim__", "(", "key", ",", "item", ")", "]", "=", "slice", "(", "slices", "[", "idx", "]", ",", "\n", "slices", "[", "idx", "+", "1", "]", ")", "\n", "data", "[", "key", "]", "=", "item", "[", "s", "]", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.raw_file_names": [[87, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "raw_file_names", "(", "self", ")", ":", "\n", "        ", "return", "[", "'some_file_1'", ",", "'some_file_2'", ",", "...", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.processed_file_names": [[91, 94], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "processed_file_names", "(", "self", ")", ":", "\n", "        ", "return", "[", "'data.pt'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Pyg2Dpr.__init__": [[119, 130], ["scipy.csr_matrix", "pyg_data.x.numpy", "pyg_data.y.numpy", "pyg_dataset.mask_to_index", "pyg_dataset.mask_to_index", "pyg_dataset.mask_to_index", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.mask_to_index", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.mask_to_index", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.mask_to_index"], ["def", "__init__", "(", "self", ",", "pyg_data", ",", "**", "kwargs", ")", ":", "\n", "        ", "pyg_data", "=", "pyg_data", "[", "0", "]", "\n", "n", "=", "pyg_data", ".", "num_nodes", "\n", "self", ".", "adj", "=", "sp", ".", "csr_matrix", "(", "(", "np", ".", "ones", "(", "pyg_data", ".", "edge_index", ".", "shape", "[", "1", "]", ")", ",", "\n", "(", "pyg_data", ".", "edge_index", "[", "0", "]", ",", "pyg_data", ".", "edge_index", "[", "1", "]", ")", ")", ",", "shape", "=", "(", "n", ",", "n", ")", ")", "\n", "self", ".", "features", "=", "pyg_data", ".", "x", ".", "numpy", "(", ")", "\n", "self", ".", "labels", "=", "pyg_data", ".", "y", ".", "numpy", "(", ")", "\n", "self", ".", "idx_train", "=", "mask_to_index", "(", "pyg_data", ".", "train_mask", ",", "n", ")", "\n", "self", ".", "idx_val", "=", "mask_to_index", "(", "pyg_data", ".", "val_mask", ",", "n", ")", "\n", "self", ".", "idx_test", "=", "mask_to_index", "(", "pyg_data", ".", "test_mask", ",", "n", ")", "\n", "self", ".", "name", "=", "'Pyg2Dpr'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.AmazonPyg.__init__": [[166, 172], ["os.join", "torch_geometric.datasets.Amazon.__init__", "pyg_dataset.random_coauthor_amazon_splits", "pyg_dataset.AmazonPyg.collate"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.random_coauthor_amazon_splits"], ["def", "__init__", "(", "self", ",", "root", ",", "name", ",", "transform", "=", "None", ",", "pre_transform", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "path", "=", "osp", ".", "join", "(", "root", ",", "'pygdata'", ",", "name", ")", "\n", "super", "(", "AmazonPyg", ",", "self", ")", ".", "__init__", "(", "path", ",", "name", ",", "transform", ",", "pre_transform", ")", "\n", "\n", "random_coauthor_amazon_splits", "(", "self", ",", "self", ".", "num_classes", ",", "lcc_mask", "=", "None", ")", "\n", "self", ".", "data", ",", "self", ".", "slices", "=", "self", ".", "collate", "(", "[", "self", ".", "data", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.CoauthorPyg.__init__": [[209, 214], ["os.join", "torch_geometric.datasets.Coauthor.__init__", "pyg_dataset.random_coauthor_amazon_splits", "pyg_dataset.CoauthorPyg.collate"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.random_coauthor_amazon_splits"], ["def", "__init__", "(", "self", ",", "root", ",", "name", ",", "transform", "=", "None", ",", "pre_transform", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "path", "=", "osp", ".", "join", "(", "root", ",", "'pygdata'", ",", "name", ")", "\n", "super", "(", "CoauthorPyg", ",", "self", ")", ".", "__init__", "(", "path", ",", "name", ",", "transform", ",", "pre_transform", ")", "\n", "random_coauthor_amazon_splits", "(", "self", ",", "self", ".", "num_classes", ",", "lcc_mask", "=", "None", ")", "\n", "self", ".", "data", ",", "self", ".", "slices", "=", "self", ".", "collate", "(", "[", "self", ".", "data", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.random_coauthor_amazon_splits": [[216, 245], ["torch.cat", "torch.cat", "torch.cat", "pyg_dataset.index_to_mask", "pyg_dataset.index_to_mask", "pyg_dataset.index_to_mask", "range", "range", "indices.append", "indices.append", "torch.randperm", "torch.cat.size", "torch.randperm", "torch.randperm", "index.size", "index.size"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask"], ["", "", "def", "random_coauthor_amazon_splits", "(", "dataset", ",", "num_classes", ",", "lcc_mask", ")", ":", "\n", "    ", "\"\"\"https://github.com/mengliu1998/DeeperGNN/blob/master/DeeperGNN/train_eval.py\n    Set random coauthor/co-purchase splits:\n    * 20 * num_classes labels for training\n    * 30 * num_classes labels for validation\n    rest labels for testing\n    \"\"\"", "\n", "data", "=", "dataset", ".", "data", "\n", "indices", "=", "[", "]", "\n", "if", "lcc_mask", "is", "not", "None", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "index", "=", "(", "data", ".", "y", "[", "lcc_mask", "]", "==", "i", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "index", "=", "index", "[", "torch", ".", "randperm", "(", "index", ".", "size", "(", "0", ")", ")", "]", "\n", "indices", ".", "append", "(", "index", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "index", "=", "(", "data", ".", "y", "==", "i", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "index", "=", "index", "[", "torch", ".", "randperm", "(", "index", ".", "size", "(", "0", ")", ")", "]", "\n", "indices", ".", "append", "(", "index", ")", "\n", "\n", "", "", "train_index", "=", "torch", ".", "cat", "(", "[", "i", "[", ":", "20", "]", "for", "i", "in", "indices", "]", ",", "dim", "=", "0", ")", "\n", "val_index", "=", "torch", ".", "cat", "(", "[", "i", "[", "20", ":", "50", "]", "for", "i", "in", "indices", "]", ",", "dim", "=", "0", ")", "\n", "\n", "rest_index", "=", "torch", ".", "cat", "(", "[", "i", "[", "50", ":", "]", "for", "i", "in", "indices", "]", ",", "dim", "=", "0", ")", "\n", "rest_index", "=", "rest_index", "[", "torch", ".", "randperm", "(", "rest_index", ".", "size", "(", "0", ")", ")", "]", "\n", "\n", "data", ".", "train_mask", "=", "index_to_mask", "(", "train_index", ",", "size", "=", "data", ".", "num_nodes", ")", "\n", "data", ".", "val_mask", "=", "index_to_mask", "(", "val_index", ",", "size", "=", "data", ".", "num_nodes", ")", "\n", "data", ".", "test_mask", "=", "index_to_mask", "(", "rest_index", ",", "size", "=", "data", ".", "num_nodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.mask_to_index": [[246, 249], ["numpy.arange"], "function", ["None"], ["", "def", "mask_to_index", "(", "index", ",", "size", ")", ":", "\n", "    ", "all_idx", "=", "np", ".", "arange", "(", "size", ")", "\n", "return", "all_idx", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.index_to_mask": [[250, 254], ["torch.zeros"], "function", ["None"], ["", "def", "index_to_mask", "(", "index", ",", "size", ")", ":", "\n", "    ", "mask", "=", "torch", ".", "zeros", "(", "(", "size", ",", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "mask", "[", "index", "]", "=", "1", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.__init__": [[47, 70], ["name.lower", "setting.lower", "os.expanduser", "os.expanduser", "os.join", "os.join", "dataset.Dataset.load_data", "dataset.Dataset.get_train_val_test", "os.normpath", "os.normpath", "dataset.Dataset.get_mask"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_data", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_train_val_test", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_mask"], ["def", "__init__", "(", "self", ",", "root", ",", "name", ",", "setting", "=", "'nettack'", ",", "seed", "=", "None", ",", "require_mask", "=", "False", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", ".", "lower", "(", ")", "\n", "self", ".", "setting", "=", "setting", ".", "lower", "(", ")", "\n", "\n", "assert", "self", ".", "name", "in", "[", "'cora'", ",", "'citeseer'", ",", "'cora_ml'", ",", "'polblogs'", ",", "\n", "'pubmed'", ",", "'acm'", ",", "'blogcatalog'", ",", "'uai'", ",", "'flickr'", "]", ",", "'Currently only support cora, citeseer, cora_ml, '", "+", "'polblogs, pubmed, acm, blogcatalog, flickr'", "\n", "assert", "self", ".", "setting", "in", "[", "'gcn'", ",", "'nettack'", "]", ",", "'Settings should be gcn or nettack'", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "# self.url =  'https://raw.githubusercontent.com/danielzuegner/nettack/master/data/%s.npz' % self.name", "\n", "self", ".", "url", "=", "'https://raw.githubusercontent.com/danielzuegner/gnn-meta-attack/master/data/%s.npz'", "%", "self", ".", "name", "\n", "self", ".", "root", "=", "osp", ".", "expanduser", "(", "osp", ".", "normpath", "(", "root", ")", ")", "\n", "self", ".", "data_folder", "=", "osp", ".", "join", "(", "root", ",", "self", ".", "name", ")", "\n", "self", ".", "data_filename", "=", "self", ".", "data_folder", "+", "'.npz'", "\n", "self", ".", "require_mask", "=", "require_mask", "\n", "\n", "self", ".", "require_lcc", "=", "True", "if", "setting", "==", "'nettack'", "else", "False", "\n", "self", ".", "adj", ",", "self", ".", "features", ",", "self", ".", "labels", "=", "self", ".", "load_data", "(", ")", "\n", "self", ".", "idx_train", ",", "self", ".", "idx_val", ",", "self", ".", "idx_test", "=", "self", ".", "get_train_val_test", "(", ")", "\n", "if", "self", ".", "require_mask", ":", "\n", "            ", "self", ".", "get_mask", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_train_val_test": [[71, 78], ["deeprobust.graph.utils.get_train_val_test", "deeprobust.graph.utils.get_train_val_test_gcn"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_train_val_test", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.get_train_val_test_gcn"], ["", "", "def", "get_train_val_test", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get training, validation, test splits according to self.setting (either 'nettack' or 'gcn').\n        \"\"\"", "\n", "if", "self", ".", "setting", "==", "'nettack'", ":", "\n", "            ", "return", "get_train_val_test", "(", "nnodes", "=", "self", ".", "adj", ".", "shape", "[", "0", "]", ",", "val_size", "=", "0.1", ",", "test_size", "=", "0.8", ",", "stratify", "=", "self", ".", "labels", ",", "seed", "=", "self", ".", "seed", ")", "\n", "", "if", "self", ".", "setting", "==", "'gcn'", ":", "\n", "            ", "return", "get_train_val_test_gcn", "(", "self", ".", "labels", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_data": [[79, 92], ["print", "dataset.Dataset.get_adj", "dataset.Dataset.load_pubmed", "dataset.Dataset.load_zip", "os.exists", "os.exists", "dataset.Dataset.download_npz"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_adj", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_pubmed", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_zip", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_npz"], ["", "", "def", "load_data", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Loading {} dataset...'", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "if", "self", ".", "name", "==", "'pubmed'", ":", "\n", "            ", "return", "self", ".", "load_pubmed", "(", ")", "\n", "\n", "", "if", "self", ".", "name", "in", "[", "'acm'", ",", "'blogcatalog'", ",", "'uai'", ",", "'flickr'", "]", ":", "\n", "            ", "return", "self", ".", "load_zip", "(", ")", "\n", "\n", "", "if", "not", "osp", ".", "exists", "(", "self", ".", "data_filename", ")", ":", "\n", "            ", "self", ".", "download_npz", "(", ")", "\n", "\n", "", "adj", ",", "features", ",", "labels", "=", "self", ".", "get_adj", "(", ")", "\n", "return", "adj", ",", "features", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_npz": [[93, 102], ["print", "urllib.request.urlretrieve", "print", "Exception"], "methods", ["None"], ["", "def", "download_npz", "(", "self", ")", ":", "\n", "        ", "\"\"\"Download adjacen matrix npz file from self.url.\n        \"\"\"", "\n", "print", "(", "'Downloading from {} to {}'", ".", "format", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", ")", "\n", "try", ":", "\n", "            ", "urllib", ".", "request", ".", "urlretrieve", "(", "self", ".", "url", ",", "self", ".", "data_filename", ")", "\n", "print", "(", "'Done!'", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "'''Download failed! Make sure you have stable Internet connection and enter the right name'''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_pubmed": [[103, 111], ["print", "urllib.request.urlretrieve", "print", "os.join", "os.join", "Exception"], "methods", ["None"], ["", "", "def", "download_pubmed", "(", "self", ",", "name", ")", ":", "\n", "        ", "url", "=", "'https://raw.githubusercontent.com/tkipf/gcn/master/gcn/data/'", "\n", "try", ":", "\n", "            ", "print", "(", "'Downloading'", ",", "url", ")", "\n", "urllib", ".", "request", ".", "urlretrieve", "(", "url", "+", "name", ",", "osp", ".", "join", "(", "self", ".", "root", ",", "name", ")", ")", "\n", "print", "(", "'Done!'", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "'''Download failed! Make sure you have stable Internet connection and enter the right name'''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_zip": [[112, 121], ["print", "urllib.request.urlretrieve", "print", "os.join", "os.join", "Exception"], "methods", ["None"], ["", "", "def", "download_zip", "(", "self", ",", "name", ")", ":", "\n", "        ", "url", "=", "'https://raw.githubusercontent.com/ChandlerBang/Pro-GNN/master/other_datasets/{}.zip'", ".", "format", "(", "name", ")", "\n", "try", ":", "\n", "            ", "print", "(", "'Downlading'", ",", "url", ")", "\n", "urllib", ".", "request", ".", "urlretrieve", "(", "url", ",", "osp", ".", "join", "(", "self", ".", "root", ",", "name", "+", "'.zip'", ")", ")", "\n", "print", "(", "'Done!'", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "'''Download failed! Make sure you have stable Internet connection and enter the right name'''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_zip": [[122, 146], ["os.join", "os.join", "os.join", "os.join", "os.join", "os.join", "numpy.loadtxt", "numpy.loadtxt", "scipy.csr_matrix", "numpy.genfromtxt", "numpy.array().reshape", "scipy.coo_matrix", "numpy.array", "os.exists", "os.exists", "dataset.Dataset.download_zip", "scipy.coo_matrix.multiply", "zipfile.ZipFile", "zip_ref.extractall", "numpy.array", "numpy.ones", "scipy.coo_matrix.T.multiply", "list"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_zip"], ["", "", "def", "load_zip", "(", "self", ")", ":", "\n", "        ", "data_filename", "=", "self", ".", "data_folder", "+", "'.zip'", "\n", "name", "=", "self", ".", "name", "\n", "if", "not", "osp", ".", "exists", "(", "data_filename", ")", ":", "\n", "            ", "self", ".", "download_zip", "(", "name", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "data_filename", ",", "'r'", ")", "as", "zip_ref", ":", "\n", "                ", "zip_ref", ".", "extractall", "(", "self", ".", "root", ")", "\n", "\n", "", "", "feature_path", "=", "osp", ".", "join", "(", "self", ".", "data_folder", ",", "'{0}.feature'", ".", "format", "(", "name", ")", ")", "\n", "label_path", "=", "osp", ".", "join", "(", "self", ".", "data_folder", ",", "'{0}.label'", ".", "format", "(", "name", ")", ")", "\n", "graph_path", "=", "osp", ".", "join", "(", "self", ".", "data_folder", ",", "'{0}.edge'", ".", "format", "(", "name", ")", ")", "\n", "\n", "f", "=", "np", ".", "loadtxt", "(", "feature_path", ",", "dtype", "=", "float", ")", "\n", "l", "=", "np", ".", "loadtxt", "(", "label_path", ",", "dtype", "=", "int", ")", "\n", "features", "=", "sp", ".", "csr_matrix", "(", "f", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# features = torch.FloatTensor(np.array(features.todense()))", "\n", "struct_edges", "=", "np", ".", "genfromtxt", "(", "graph_path", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "sedges", "=", "np", ".", "array", "(", "list", "(", "struct_edges", ")", ",", "dtype", "=", "np", ".", "int32", ")", ".", "reshape", "(", "struct_edges", ".", "shape", ")", "\n", "n", "=", "features", ".", "shape", "[", "0", "]", "\n", "sadj", "=", "sp", ".", "coo_matrix", "(", "(", "np", ".", "ones", "(", "sedges", ".", "shape", "[", "0", "]", ")", ",", "(", "sedges", "[", ":", ",", "0", "]", ",", "sedges", "[", ":", ",", "1", "]", ")", ")", ",", "shape", "=", "(", "n", ",", "n", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "sadj", "=", "sadj", "+", "sadj", ".", "T", ".", "multiply", "(", "sadj", ".", "T", ">", "sadj", ")", "-", "sadj", ".", "multiply", "(", "sadj", ".", "T", ">", "sadj", ")", "\n", "label", "=", "np", ".", "array", "(", "l", ")", "\n", "\n", "return", "sadj", ",", "features", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_pubmed": [[147, 181], ["range", "tuple", "dataset.parse_index_file", "numpy.sort", "scipy.vstack().tolil", "networkx.adjacency_matrix", "numpy.vstack", "len", "os.join", "os.join", "os.exists", "os.exists", "dataset.Dataset.download_pubmed", "os.join", "os.join", "networkx.from_dict_of_lists", "numpy.where", "os.exists", "os.exists", "dataset.Dataset.download_pubmed", "open", "os.join", "os.join", "scipy.vstack", "objects.append", "objects.append", "pickle.load", "pickle.load"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.parse_index_file", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_pubmed", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.download_pubmed"], ["", "def", "load_pubmed", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "'pubmed'", "\n", "names", "=", "[", "'x'", ",", "'y'", ",", "'tx'", ",", "'ty'", ",", "'allx'", ",", "'ally'", ",", "'graph'", "]", "\n", "objects", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "names", ")", ")", ":", "\n", "            ", "name", "=", "\"ind.{}.{}\"", ".", "format", "(", "dataset", ",", "names", "[", "i", "]", ")", "\n", "data_filename", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "name", ")", "\n", "\n", "if", "not", "osp", ".", "exists", "(", "data_filename", ")", ":", "\n", "                ", "self", ".", "download_pubmed", "(", "name", ")", "\n", "\n", "", "with", "open", "(", "data_filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "if", "sys", ".", "version_info", ">", "(", "3", ",", "0", ")", ":", "\n", "                    ", "objects", ".", "append", "(", "pkl", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", ")", "\n", "", "else", ":", "\n", "                    ", "objects", ".", "append", "(", "pkl", ".", "load", "(", "f", ")", ")", "\n", "\n", "", "", "", "x", ",", "y", ",", "tx", ",", "ty", ",", "allx", ",", "ally", ",", "graph", "=", "tuple", "(", "objects", ")", "\n", "\n", "\n", "test_idx_file", "=", "\"ind.{}.test.index\"", ".", "format", "(", "dataset", ")", "\n", "if", "not", "osp", ".", "exists", "(", "osp", ".", "join", "(", "self", ".", "root", ",", "test_idx_file", ")", ")", ":", "\n", "            ", "self", ".", "download_pubmed", "(", "test_idx_file", ")", "\n", "\n", "", "test_idx_reorder", "=", "parse_index_file", "(", "osp", ".", "join", "(", "self", ".", "root", ",", "test_idx_file", ")", ")", "\n", "test_idx_range", "=", "np", ".", "sort", "(", "test_idx_reorder", ")", "\n", "\n", "features", "=", "sp", ".", "vstack", "(", "(", "allx", ",", "tx", ")", ")", ".", "tolil", "(", ")", "\n", "features", "[", "test_idx_reorder", ",", ":", "]", "=", "features", "[", "test_idx_range", ",", ":", "]", "\n", "adj", "=", "nx", ".", "adjacency_matrix", "(", "nx", ".", "from_dict_of_lists", "(", "graph", ")", ")", "\n", "labels", "=", "np", ".", "vstack", "(", "(", "ally", ",", "ty", ")", ")", "\n", "labels", "[", "test_idx_reorder", ",", ":", "]", "=", "labels", "[", "test_idx_range", ",", ":", "]", "\n", "labels", "=", "np", ".", "where", "(", "labels", ")", "[", "1", "]", "\n", "return", "adj", ",", "features", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_adj": [[182, 204], ["dataset.Dataset.load_npz", "adj.astype().tocsr.astype().tocsr.tolil", "adj.astype().tocsr.astype().tocsr.setdiag", "adj.astype().tocsr.astype().tocsr.astype().tocsr", "adj.astype().tocsr.astype().tocsr.eliminate_zeros", "dataset.Dataset.largest_connected_components", "numpy.abs().sum", "adj.astype().tocsr.astype().tocsr.sum().A1.min", "adj.astype().tocsr.astype().tocsr.astype", "adj.astype().tocsr.astype().tocsr.max", "len", "numpy.abs", "numpy.unique", "adj.astype().tocsr.astype().tocsr.sum", "adj.astype().tocsr.astype().tocsr.nonzero"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.largest_connected_components"], ["", "def", "get_adj", "(", "self", ")", ":", "\n", "        ", "adj", ",", "features", ",", "labels", "=", "self", ".", "load_npz", "(", "self", ".", "data_filename", ")", "\n", "adj", "=", "adj", "+", "adj", ".", "T", "\n", "adj", "=", "adj", ".", "tolil", "(", ")", "\n", "adj", "[", "adj", ">", "1", "]", "=", "1", "\n", "\n", "if", "self", ".", "require_lcc", ":", "\n", "            ", "lcc", "=", "self", ".", "largest_connected_components", "(", "adj", ")", "\n", "adj", "=", "adj", "[", "lcc", "]", "[", ":", ",", "lcc", "]", "\n", "features", "=", "features", "[", "lcc", "]", "\n", "labels", "=", "labels", "[", "lcc", "]", "\n", "assert", "adj", ".", "sum", "(", "0", ")", ".", "A1", ".", "min", "(", ")", ">", "0", ",", "\"Graph contains singleton nodes\"", "\n", "\n", "# whether to set diag=0?", "\n", "", "adj", ".", "setdiag", "(", "0", ")", "\n", "adj", "=", "adj", ".", "astype", "(", "\"float32\"", ")", ".", "tocsr", "(", ")", "\n", "adj", ".", "eliminate_zeros", "(", ")", "\n", "\n", "assert", "np", ".", "abs", "(", "adj", "-", "adj", ".", "T", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "max", "(", ")", "==", "1", "and", "len", "(", "np", ".", "unique", "(", "adj", "[", "adj", ".", "nonzero", "(", ")", "]", ".", "A1", ")", ")", "==", "1", ",", "\"Graph must be unweighted\"", "\n", "\n", "return", "adj", ",", "features", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz": [[205, 228], ["scipy.csr_matrix", "numpy.load", "numpy.eye", "scipy.csr_matrix", "loader.get", "loader.get", "scipy.csr_matrix"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.get", "home.repos.pwc.inspect_result.rinnesz_clga.data.pyg_dataset.Dpr2Pyg.get"], ["", "def", "load_npz", "(", "self", ",", "file_name", ",", "is_sparse", "=", "True", ")", ":", "\n", "        ", "with", "np", ".", "load", "(", "file_name", ")", "as", "loader", ":", "\n", "# loader = dict(loader)", "\n", "            ", "if", "is_sparse", ":", "\n", "                ", "adj", "=", "sp", ".", "csr_matrix", "(", "(", "loader", "[", "'adj_data'", "]", ",", "loader", "[", "'adj_indices'", "]", ",", "\n", "loader", "[", "'adj_indptr'", "]", ")", ",", "shape", "=", "loader", "[", "'adj_shape'", "]", ")", "\n", "if", "'attr_data'", "in", "loader", ":", "\n", "                    ", "features", "=", "sp", ".", "csr_matrix", "(", "(", "loader", "[", "'attr_data'", "]", ",", "loader", "[", "'attr_indices'", "]", ",", "\n", "loader", "[", "'attr_indptr'", "]", ")", ",", "shape", "=", "loader", "[", "'attr_shape'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "features", "=", "None", "\n", "", "labels", "=", "loader", ".", "get", "(", "'labels'", ")", "\n", "", "else", ":", "\n", "                ", "adj", "=", "loader", "[", "'adj_data'", "]", "\n", "if", "'attr_data'", "in", "loader", ":", "\n", "                    ", "features", "=", "loader", "[", "'attr_data'", "]", "\n", "", "else", ":", "\n", "                    ", "features", "=", "None", "\n", "", "labels", "=", "loader", ".", "get", "(", "'labels'", ")", "\n", "", "", "if", "features", "is", "None", ":", "\n", "            ", "features", "=", "np", ".", "eye", "(", "adj", ".", "shape", "[", "0", "]", ")", "\n", "", "features", "=", "sp", ".", "csr_matrix", "(", "features", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "adj", ",", "features", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.largest_connected_components": [[229, 247], ["scipy.csgraph.connected_components", "numpy.bincount", "print", "numpy.argsort", "enumerate"], "methods", ["None"], ["", "def", "largest_connected_components", "(", "self", ",", "adj", ",", "n_components", "=", "1", ")", ":", "\n", "        ", "\"\"\"Select k largest connected components.\n\n\t\tParameters\n\t\t----------\n\t\tadj : scipy.sparse.csr_matrix\n\t\t\tinput adjacency matrix\n\t\tn_components : int\n\t\t\tn largest connected components we want to select\n\t\t\"\"\"", "\n", "\n", "_", ",", "component_indices", "=", "sp", ".", "csgraph", ".", "connected_components", "(", "adj", ")", "\n", "component_sizes", "=", "np", ".", "bincount", "(", "component_indices", ")", "\n", "components_to_keep", "=", "np", ".", "argsort", "(", "component_sizes", ")", "[", ":", ":", "-", "1", "]", "[", ":", "n_components", "]", "# reverse order to sort descending", "\n", "nodes_to_keep", "=", "[", "\n", "idx", "for", "(", "idx", ",", "component", ")", "in", "enumerate", "(", "component_indices", ")", "if", "component", "in", "components_to_keep", "]", "\n", "print", "(", "\"Selecting {0} largest connected components\"", ".", "format", "(", "n_components", ")", ")", "\n", "return", "nodes_to_keep", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.__repr__": [[248, 250], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{0}(adj_shape={1}, feature_shape={2})'", ".", "format", "(", "self", ".", "name", ",", "self", ".", "adj", ".", "shape", ",", "self", ".", "features", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_mask": [[251, 269], ["dataset.Dataset.onehot", "dataset.Dataset.get_mask"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.onehot", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.get_mask"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "idx_train", ",", "idx_val", ",", "idx_test", "=", "self", ".", "idx_train", ",", "self", ".", "idx_val", ",", "self", ".", "idx_test", "\n", "labels", "=", "self", ".", "onehot", "(", "self", ".", "labels", ")", "\n", "\n", "def", "get_mask", "(", "idx", ")", ":", "\n", "            ", "mask", "=", "np", ".", "zeros", "(", "labels", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "mask", "[", "idx", "]", "=", "1", "\n", "return", "mask", "\n", "\n", "", "def", "get_y", "(", "idx", ")", ":", "\n", "            ", "mx", "=", "np", ".", "zeros", "(", "labels", ".", "shape", ")", "\n", "mx", "[", "idx", "]", "=", "labels", "[", "idx", "]", "\n", "return", "mx", "\n", "\n", "", "self", ".", "train_mask", "=", "get_mask", "(", "self", ".", "idx_train", ")", "\n", "self", ".", "val_mask", "=", "get_mask", "(", "self", ".", "idx_val", ")", "\n", "self", ".", "test_mask", "=", "get_mask", "(", "self", ".", "idx_test", ")", "\n", "self", ".", "y_train", ",", "self", ".", "y_val", ",", "self", ".", "y_test", "=", "get_y", "(", "idx_train", ")", ",", "get_y", "(", "idx_val", ")", ",", "get_y", "(", "idx_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.onehot": [[270, 274], ["numpy.identity", "labels.max"], "methods", ["None"], ["", "def", "onehot", "(", "self", ",", "labels", ")", ":", "\n", "        ", "eye", "=", "np", ".", "identity", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.parse_index_file": [[275, 280], ["open", "index.append", "int", "line.strip"], "function", ["None"], ["", "", "def", "parse_index_file", "(", "filename", ")", ":", "\n", "    ", "index", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "filename", ")", ":", "\n", "        ", "index", ".", "append", "(", "int", "(", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "return", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.adv_training.AdvTraining.__init__": [[25, 32], ["RND"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "adversary", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "if", "adversary", "is", "None", ":", "\n", "            ", "adversary", "=", "RND", "(", ")", "\n", "", "self", ".", "adversary", "=", "adversary", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.adv_training.AdvTraining.adv_train": [[33, 54], ["range", "adv_training.AdvTraining.adversary.attack", "adv_training.AdvTraining.model.fit"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit"], ["", "def", "adv_train", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "train_iters", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Start adversarial training.\n\n        Parameters\n        ----------\n        features :\n            node features\n        adj :\n            the adjacency matrix. The format could be torch.tensor or scipy matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices. If not given (None), GCN training process will not adpot early stopping\n        train_iters : int\n            number of training epochs\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "modified_adj", "=", "self", ".", "adversary", ".", "attack", "(", "features", ",", "adj", ")", "\n", "self", ".", "model", ".", "fit", "(", "features", ",", "modified_adj", ",", "train_iters", ",", "initialize", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.__init__": [[55, 71], ["super().__init__", "torch_geometric.nn.SGConv"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nclass", ",", "K", "=", "3", ",", "cached", "=", "True", ",", "lr", "=", "0.01", ",", "\n", "weight_decay", "=", "5e-4", ",", "with_bias", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "SGC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "device", "is", "not", "None", ",", "\"Please specify 'device'!\"", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "conv1", "=", "SGConv", "(", "nfeat", ",", "\n", "nclass", ",", "bias", "=", "with_bias", ",", "K", "=", "K", ",", "cached", "=", "cached", ")", "\n", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "output", "=", "None", "\n", "self", ".", "best_model", "=", "None", "\n", "self", ".", "best_output", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.forward": [[72, 76], ["sgc.SGC.conv1", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", ",", "edge_index", "=", "data", ".", "x", ",", "data", ".", "edge_index", "\n", "x", "=", "self", ".", "conv1", "(", "x", ",", "edge_index", ")", "\n", "return", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.initialize": [[77, 81], ["sgc.SGC.conv1.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize parameters of SGC.\n        \"\"\"", "\n", "self", ".", "conv1", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.fit": [[82, 107], ["pyg_data[].to", "sgc.SGC.train_with_early_stopping", "sgc.SGC.initialize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.train_with_early_stopping", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize"], ["", "def", "fit", "(", "self", ",", "pyg_data", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "False", ",", "patience", "=", "500", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train the SGC model, when idx_val is not None, pick the best model\n        according to the validation loss.\n\n        Parameters\n        ----------\n        pyg_data :\n            pytorch geometric dataset object\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        patience : int\n            patience for early stopping, only valid when `idx_val` is given\n        \"\"\"", "\n", "\n", "# self.device = self.conv1.weight.device", "\n", "if", "initialize", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n", "", "self", ".", "data", "=", "pyg_data", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "# By default, it is trained with early stopping on validation", "\n", "self", ".", "train_with_early_stopping", "(", "train_iters", ",", "patience", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.train_with_early_stopping": [[108, 150], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "sgc.SGC.load_state_dict", "print", "sgc.SGC.parameters", "sgc.SGC.train", "torch.Adam.zero_grad", "sgc.SGC.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "sgc.SGC.eval", "sgc.SGC.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "print", "print", "copy.deepcopy", "sgc.SGC.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "train_with_early_stopping", "(", "self", ",", "train_iters", ",", "patience", ",", "verbose", ")", ":", "\n", "        ", "\"\"\"early stopping based on the validation loss\n        \"\"\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training SGC model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "train_mask", ",", "val_mask", "=", "self", ".", "data", ".", "train_mask", ",", "self", ".", "data", ".", "val_mask", "\n", "\n", "early_stopping", "=", "patience", "\n", "best_loss_val", "=", "100", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "train_mask", "]", ",", "labels", "[", "train_mask", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "val_mask", "]", ",", "labels", "[", "val_mask", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "patience", "=", "early_stopping", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "", "if", "i", ">", "early_stopping", "and", "patience", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ":", "\n", "             ", "print", "(", "'=== early stopping at {0}, loss_val = {1} ==='", ".", "format", "(", "i", ",", "best_loss_val", ")", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.test": [[151, 170], ["sgc.SGC.eval", "sgc.SGC.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "test", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate SGC performance on test set.\n\n        Parameters\n        ----------\n        idx_test :\n            node testing indices\n        \"\"\"", "\n", "self", ".", "eval", "(", ")", "\n", "test_mask", "=", "self", ".", "data", ".", "test_mask", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "# output = self.output", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "acc_test", "=", "utils", ".", "accuracy", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "print", "(", "\"Test set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.sgc.SGC.predict": [[171, 181], ["sgc.SGC.eval", "sgc.SGC.forward"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "predict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of SGC\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "return", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.__init__": [[61, 90], ["torch.Module.__init__", "torch_geometric.nn.GATConv", "torch_geometric.nn.GATConv"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "heads", "=", "8", ",", "output_heads", "=", "1", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "\n", "weight_decay", "=", "5e-4", ",", "with_bias", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "GAT", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "device", "is", "not", "None", ",", "\"Please specify 'device'!\"", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "conv1", "=", "GATConv", "(", "\n", "nfeat", ",", "\n", "nhid", ",", "\n", "heads", "=", "heads", ",", "\n", "dropout", "=", "dropout", ",", "\n", "bias", "=", "with_bias", ")", "\n", "\n", "self", ".", "conv2", "=", "GATConv", "(", "\n", "nhid", "*", "heads", ",", "\n", "nclass", ",", "\n", "heads", "=", "output_heads", ",", "\n", "concat", "=", "False", ",", "\n", "dropout", "=", "dropout", ",", "\n", "bias", "=", "with_bias", ")", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "output", "=", "None", "\n", "self", ".", "best_model", "=", "None", "\n", "self", ".", "best_output", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.forward": [[91, 98], ["torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.elu", "torch.elu", "torch.elu", "torch.elu", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "gat.GAT.conv2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "gat.GAT.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", ",", "edge_index", "=", "data", ".", "x", ",", "data", ".", "edge_index", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "p", "=", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "x", "=", "F", ".", "elu", "(", "self", ".", "conv1", "(", "x", ",", "edge_index", ")", ")", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "p", "=", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ",", "edge_index", ")", "\n", "return", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.initialize": [[99, 104], ["gat.GAT.conv1.reset_parameters", "gat.GAT.conv2.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize parameters of GAT.\n        \"\"\"", "\n", "self", ".", "conv1", ".", "reset_parameters", "(", ")", "\n", "self", ".", "conv2", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.fit": [[105, 130], ["pyg_data[].to", "gat.GAT.train_with_early_stopping", "gat.GAT.initialize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.train_with_early_stopping", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize"], ["", "def", "fit", "(", "self", ",", "pyg_data", ",", "train_iters", "=", "1000", ",", "initialize", "=", "True", ",", "verbose", "=", "False", ",", "patience", "=", "100", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train the GAT model, when idx_val is not None, pick the best model\n        according to the validation loss.\n\n        Parameters\n        ----------\n        pyg_data :\n            pytorch geometric dataset object\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        patience : int\n            patience for early stopping, only valid when `idx_val` is given\n        \"\"\"", "\n", "\n", "self", ".", "device", "=", "self", ".", "conv1", ".", "weight", ".", "device", "\n", "if", "initialize", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n", "", "self", ".", "data", "=", "pyg_data", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "# By default, it is trained with early stopping on validation", "\n", "self", ".", "train_with_early_stopping", "(", "train_iters", ",", "patience", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.train_with_early_stopping": [[131, 173], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "gat.GAT.load_state_dict", "print", "gat.GAT.parameters", "gat.GAT.train", "torch.Adam.zero_grad", "gat.GAT.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "gat.GAT.eval", "gat.GAT.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "print", "print", "copy.deepcopy", "gat.GAT.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "train_with_early_stopping", "(", "self", ",", "train_iters", ",", "patience", ",", "verbose", ")", ":", "\n", "        ", "\"\"\"early stopping based on the validation loss\n        \"\"\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training GAT model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "train_mask", ",", "val_mask", "=", "self", ".", "data", ".", "train_mask", ",", "self", ".", "data", ".", "val_mask", "\n", "\n", "early_stopping", "=", "patience", "\n", "best_loss_val", "=", "100", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "train_mask", "]", ",", "labels", "[", "train_mask", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "val_mask", "]", ",", "labels", "[", "val_mask", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "patience", "=", "early_stopping", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "", "if", "i", ">", "early_stopping", "and", "patience", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ":", "\n", "             ", "print", "(", "'=== early stopping at {0}, loss_val = {1} ==='", ".", "format", "(", "i", ",", "best_loss_val", ")", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.test": [[174, 193], ["gat.GAT.eval", "gat.GAT.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "test", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate GAT performance on test set.\n\n        Parameters\n        ----------\n        idx_test :\n            node testing indices\n        \"\"\"", "\n", "self", ".", "eval", "(", ")", "\n", "test_mask", "=", "self", ".", "data", ".", "test_mask", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "# output = self.output", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "acc_test", "=", "utils", ".", "accuracy", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "print", "(", "\"Test set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gat.GAT.predict": [[194, 204], ["gat.GAT.eval", "gat.GAT.forward"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "predict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of GAT\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "return", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.__init__": [[58, 84], ["torch.Module.__init__", "torch_geometric.nn.ChebConv", "torch_geometric.nn.ChebConv"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "num_hops", "=", "3", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "\n", "weight_decay", "=", "5e-4", ",", "with_bias", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "ChebNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "device", "is", "not", "None", ",", "\"Please specify 'device'!\"", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "conv1", "=", "ChebConv", "(", "\n", "nfeat", ",", "\n", "nhid", ",", "\n", "K", "=", "num_hops", ",", "\n", "bias", "=", "with_bias", ")", "\n", "\n", "self", ".", "conv2", "=", "ChebConv", "(", "\n", "nhid", ",", "\n", "nclass", ",", "\n", "K", "=", "num_hops", ",", "\n", "bias", "=", "with_bias", ")", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "output", "=", "None", "\n", "self", ".", "best_model", "=", "None", "\n", "self", ".", "best_output", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.forward": [[85, 91], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "chebnet.ChebNet.conv2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "chebnet.ChebNet.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", ",", "edge_index", "=", "data", ".", "x", ",", "data", ".", "edge_index", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ",", "edge_index", ")", ")", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "p", "=", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ",", "edge_index", ")", "\n", "return", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.initialize": [[92, 97], ["chebnet.ChebNet.conv1.reset_parameters", "chebnet.ChebNet.conv2.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize parameters of ChebNet.\n        \"\"\"", "\n", "self", ".", "conv1", ".", "reset_parameters", "(", ")", "\n", "self", ".", "conv2", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.fit": [[98, 123], ["pyg_data[].to", "chebnet.ChebNet.train_with_early_stopping", "chebnet.ChebNet.initialize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.train_with_early_stopping", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize"], ["", "def", "fit", "(", "self", ",", "pyg_data", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "False", ",", "patience", "=", "500", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train the ChebNet model, when idx_val is not None, pick the best model\n        according to the validation loss.\n\n        Parameters\n        ----------\n        pyg_data :\n            pytorch geometric dataset object\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        patience : int\n            patience for early stopping, only valid when `idx_val` is given\n        \"\"\"", "\n", "\n", "self", ".", "device", "=", "self", ".", "conv1", ".", "weight", ".", "device", "\n", "if", "initialize", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n", "", "self", ".", "data", "=", "pyg_data", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "# By default, it is trained with early stopping on validation", "\n", "self", ".", "train_with_early_stopping", "(", "train_iters", ",", "patience", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.train_with_early_stopping": [[124, 166], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "chebnet.ChebNet.load_state_dict", "print", "chebnet.ChebNet.parameters", "chebnet.ChebNet.train", "torch.Adam.zero_grad", "chebnet.ChebNet.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "chebnet.ChebNet.eval", "chebnet.ChebNet.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "print", "print", "copy.deepcopy", "chebnet.ChebNet.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "train_with_early_stopping", "(", "self", ",", "train_iters", ",", "patience", ",", "verbose", ")", ":", "\n", "        ", "\"\"\"early stopping based on the validation loss\n        \"\"\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training ChebNet model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "train_mask", ",", "val_mask", "=", "self", ".", "data", ".", "train_mask", ",", "self", ".", "data", ".", "val_mask", "\n", "\n", "early_stopping", "=", "patience", "\n", "best_loss_val", "=", "100", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "train_mask", "]", ",", "labels", "[", "train_mask", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "val_mask", "]", ",", "labels", "[", "val_mask", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "patience", "=", "early_stopping", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "", "if", "i", ">", "early_stopping", "and", "patience", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ":", "\n", "             ", "print", "(", "'=== early stopping at {0}, loss_val = {1} ==='", ".", "format", "(", "i", ",", "best_loss_val", ")", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.test": [[167, 186], ["chebnet.ChebNet.eval", "chebnet.ChebNet.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "test", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate ChebNet performance on test set.\n\n        Parameters\n        ----------\n        idx_test :\n            node testing indices\n        \"\"\"", "\n", "self", ".", "eval", "(", ")", "\n", "test_mask", "=", "self", ".", "data", ".", "test_mask", "\n", "labels", "=", "self", ".", "data", ".", "y", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "# output = self.output", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "acc_test", "=", "utils", ".", "accuracy", "(", "output", "[", "test_mask", "]", ",", "labels", "[", "test_mask", "]", ")", "\n", "print", "(", "\"Test set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.chebnet.ChebNet.predict": [[187, 197], ["chebnet.ChebNet.eval", "chebnet.ChebNet.forward"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "predict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of ChebNet\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "return", "self", ".", "forward", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.__init__": [[69, 124], ["torch.Module.__init__", "deeprobust.graph.defense.GraphConvolution", "deeprobust.graph.defense.GraphConvolution", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "simpgcn.SimPGCN.scores.append", "range", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "simpgcn.SimPGCN.bias.append", "range", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "simpgcn.SimPGCN.D_k.append", "range", "deeprobust.sparse_mx_to_torch_sparse_tensor().to", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "torch.ParameterList", "simpgcn.SimPGCN.D_bias.append", "range", "torch.Linear().to", "torch.Linear().to", "torch.Linear().to", "torch.Linear().to", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "simpgcn.SimPGCN.scores.append", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "simpgcn.SimPGCN.bias.append", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "simpgcn.SimPGCN.D_k.append", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "simpgcn.SimPGCN.D_bias.append", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "deeprobust.sparse_mx_to_torch_sparse_tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "scipy.eye", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor"], ["def", "__init__", "(", "self", ",", "nnodes", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "\n", "weight_decay", "=", "5e-4", ",", "lambda_", "=", "5", ",", "gamma", "=", "0.1", ",", "bias_init", "=", "0", ",", "\n", "with_bias", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "        ", "super", "(", "SimPGCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "device", "is", "not", "None", ",", "\"Please specify 'device'!\"", "\n", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "nfeat", "=", "nfeat", "\n", "self", ".", "hidden_sizes", "=", "[", "nhid", "]", "\n", "self", ".", "nclass", "=", "nclass", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "bias_init", "=", "bias_init", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "lambda_", "=", "lambda_", "\n", "self", ".", "output", "=", "None", "\n", "self", ".", "best_model", "=", "None", "\n", "self", ".", "best_output", "=", "None", "\n", "self", ".", "adj_norm", "=", "None", "\n", "self", ".", "features", "=", "None", "\n", "\n", "self", ".", "gc1", "=", "GraphConvolution", "(", "nfeat", ",", "nhid", ",", "with_bias", "=", "with_bias", ")", "\n", "self", ".", "gc2", "=", "GraphConvolution", "(", "nhid", ",", "nclass", ",", "with_bias", "=", "with_bias", ")", "\n", "\n", "# self.reset_parameters()", "\n", "self", ".", "scores", "=", "nn", ".", "ParameterList", "(", ")", "\n", "self", ".", "scores", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nfeat", ",", "1", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ")", ":", "\n", "            ", "self", ".", "scores", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nhid", ",", "1", ")", ")", ")", "\n", "\n", "", "self", ".", "bias", "=", "nn", ".", "ParameterList", "(", ")", "\n", "self", ".", "bias", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ")", ":", "\n", "            ", "self", ".", "bias", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ")", ")", "\n", "\n", "", "self", ".", "D_k", "=", "nn", ".", "ParameterList", "(", ")", "\n", "self", ".", "D_k", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nfeat", ",", "1", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ")", ":", "\n", "            ", "self", ".", "D_k", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "nhid", ",", "1", ")", ")", ")", "\n", "\n", "", "self", ".", "identity", "=", "utils", ".", "sparse_mx_to_torch_sparse_tensor", "(", "\n", "sp", ".", "eye", "(", "nnodes", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "D_bias", "=", "nn", ".", "ParameterList", "(", ")", "\n", "self", ".", "D_bias", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ")", ":", "\n", "            ", "self", ".", "D_bias", ".", "append", "(", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ")", ")", "\n", "\n", "# discriminator for ssl", "\n", "", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "nhid", ",", "1", ")", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "adj_knn", "=", "None", "\n", "self", ".", "pseudo_labels", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.get_knn_graph": [[125, 144], ["simpgcn.preprocess_adj_noloop", "os.path.exists", "os.mkdir", "os.path.exists", "sklearn.metrics.pairwise.cosine_similarity", "numpy.save", "range", "scipy.csr_matrix", "scipy.save_npz", "print", "scipy.load_npz", "len", "numpy.argsort", "numpy.arange", "numpy.arange", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.preprocess_adj_noloop", "home.repos.pwc.inspect_result.rinnesz_clga.data.dataset.Dataset.load_npz"], ["", "def", "get_knn_graph", "(", "self", ",", "features", ",", "k", "=", "20", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "'saved_knn/'", ")", ":", "\n", "           ", "os", ".", "mkdir", "(", "'saved_knn'", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'saved_knn/knn_graph_{}.npz'", ".", "format", "(", "features", ".", "shape", ")", ")", ":", "\n", "            ", "features", "[", "features", "!=", "0", "]", "=", "1", "\n", "sims", "=", "cosine_similarity", "(", "features", ")", "\n", "np", ".", "save", "(", "'saved_knn/cosine_sims_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ",", "sims", ")", "\n", "\n", "sims", "[", "(", "np", ".", "arange", "(", "len", "(", "sims", ")", ")", ",", "np", ".", "arange", "(", "len", "(", "sims", ")", ")", ")", "]", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "sims", ")", ")", ":", "\n", "                ", "indices_argsort", "=", "np", ".", "argsort", "(", "sims", "[", "i", "]", ")", "\n", "sims", "[", "i", ",", "indices_argsort", "[", ":", "-", "k", "]", "]", "=", "0", "\n", "\n", "", "adj_knn", "=", "sp", ".", "csr_matrix", "(", "sims", ")", "\n", "sp", ".", "save_npz", "(", "'saved_knn/knn_graph_{}.npz'", ".", "format", "(", "features", ".", "shape", ")", ",", "adj_knn", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'loading saved_knn/knn_graph_{}.npz...'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "adj_knn", "=", "sp", ".", "load_npz", "(", "'saved_knn/knn_graph_{}.npz'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "", "return", "preprocess_adj_noloop", "(", "adj_knn", ",", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.initialize": [[145, 165], ["simpgcn.SimPGCN.gc1.reset_parameters", "simpgcn.SimPGCN.gc2.reset_parameters", "s.data.uniform_", "b.data.fill_", "Dk.data.uniform_", "b.data.fill_", "math.sqrt", "math.sqrt", "s.size", "Dk.size"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize parameters of SimPGCN.\n        \"\"\"", "\n", "self", ".", "gc1", ".", "reset_parameters", "(", ")", "\n", "self", ".", "gc2", ".", "reset_parameters", "(", ")", "\n", "\n", "for", "s", "in", "self", ".", "scores", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "s", ".", "size", "(", "1", ")", ")", "\n", "s", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "", "for", "b", "in", "self", ".", "bias", ":", "\n", "# fill in b with postive value to make", "\n", "# score s closer to 1 at the beginning", "\n", "            ", "b", ".", "data", ".", "fill_", "(", "self", ".", "bias_init", ")", "\n", "\n", "", "for", "Dk", "in", "self", ".", "D_k", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "Dk", ".", "size", "(", "1", ")", ")", "\n", "Dk", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "", "for", "b", "in", "self", ".", "D_bias", ":", "\n", "            ", "b", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.fit": [[167, 197], ["simpgcn.SimPGCN.initialize", "type", "deeprobust.to_tensor", "features.to.to.to", "adj.to.to.to", "labels.to.to.to", "deeprobust.is_sparse_tensor", "simpgcn.SimPGCN._train_without_val", "deeprobust.normalize_adj_tensor", "deeprobust.normalize_adj_tensor", "simpgcn.SimPGCN._train_with_early_stopping", "simpgcn.SimPGCN._train_with_val"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_without_val", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN._train_with_early_stopping", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_with_val"], ["", "", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "False", ",", "normalize", "=", "True", ",", "patience", "=", "500", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "initialize", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n", "", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "            ", "features", ",", "adj", ",", "labels", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "features", ".", "to", "(", "self", ".", "device", ")", "\n", "adj", "=", "adj", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "normalize", ":", "\n", "            ", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "", "else", ":", "\n", "            ", "adj_norm", "=", "adj", "\n", "\n", "", "self", ".", "adj_norm", "=", "adj_norm", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "\n", "if", "idx_val", "is", "None", ":", "\n", "            ", "self", ".", "_train_without_val", "(", "labels", ",", "idx_train", ",", "train_iters", ",", "verbose", ")", "\n", "", "else", ":", "\n", "            ", "if", "patience", "<", "train_iters", ":", "\n", "                ", "self", ".", "_train_with_early_stopping", "(", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "patience", ",", "verbose", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_train_with_val", "(", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.forward": [[199, 202], ["simpgcn.SimPGCN.myforward"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.myforward"], ["", "", "", "def", "forward", "(", "self", ",", "fea", ",", "adj", ")", ":", "\n", "        ", "x", ",", "_", "=", "self", ".", "myforward", "(", "fea", ",", "adj", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.myforward": [[203, 228], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.log_softmax.clone", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "simpgcn.SimPGCN.get_knn_graph", "fea.to_dense().cpu().numpy", "simpgcn.SimPGCN.gc1", "simpgcn.SimPGCN.gc2", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "torch.sigmoid.view", "simpgcn.SimPGCN.gc1", "simpgcn.SimPGCN.gc1", "simpgcn.SimPGCN.gc2", "simpgcn.SimPGCN.gc2", "Dk_i.view", "Dk_o.view", "fea.to_dense().cpu", "fea.to_dense"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.get_knn_graph"], ["", "def", "myforward", "(", "self", ",", "fea", ",", "adj", ")", ":", "\n", "        ", "'''output embedding and log_softmax'''", "\n", "if", "self", ".", "adj_knn", "is", "None", ":", "\n", "            ", "self", ".", "adj_knn", "=", "self", ".", "get_knn_graph", "(", "fea", ".", "to_dense", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "adj_knn", "=", "self", ".", "adj_knn", "\n", "gamma", "=", "self", ".", "gamma", "\n", "\n", "s_i", "=", "torch", ".", "sigmoid", "(", "fea", "@", "self", ".", "scores", "[", "0", "]", "+", "self", ".", "bias", "[", "0", "]", ")", "\n", "\n", "Dk_i", "=", "(", "fea", "@", "self", ".", "D_k", "[", "0", "]", "+", "self", ".", "D_bias", "[", "0", "]", ")", "\n", "x", "=", "(", "s_i", "*", "self", ".", "gc1", "(", "fea", ",", "adj", ")", "+", "(", "1", "-", "s_i", ")", "*", "self", ".", "gc1", "(", "fea", ",", "adj_knn", ")", ")", "+", "(", "gamma", ")", "*", "Dk_i", "*", "self", ".", "gc1", "(", "fea", ",", "self", ".", "identity", ")", "\n", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "embedding", "=", "x", ".", "clone", "(", ")", "\n", "\n", "# output, no relu and dropput here.", "\n", "s_o", "=", "torch", ".", "sigmoid", "(", "x", "@", "self", ".", "scores", "[", "-", "1", "]", "+", "self", ".", "bias", "[", "-", "1", "]", ")", "\n", "Dk_o", "=", "(", "x", "@", "self", ".", "D_k", "[", "-", "1", "]", "+", "self", ".", "D_bias", "[", "-", "1", "]", ")", "\n", "x", "=", "(", "s_o", "*", "self", ".", "gc2", "(", "x", ",", "adj", ")", "+", "(", "1", "-", "s_o", ")", "*", "self", ".", "gc2", "(", "x", ",", "adj_knn", ")", ")", "+", "(", "gamma", ")", "*", "Dk_o", "*", "self", ".", "gc2", "(", "x", ",", "self", ".", "identity", ")", "\n", "\n", "x", "=", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n", "self", ".", "ss", "=", "torch", ".", "cat", "(", "(", "s_i", ".", "view", "(", "1", ",", "-", "1", ")", ",", "s_o", ".", "view", "(", "1", ",", "-", "1", ")", ",", "gamma", "*", "Dk_i", ".", "view", "(", "1", ",", "-", "1", ")", ",", "gamma", "*", "Dk_o", ".", "view", "(", "1", ",", "-", "1", ")", ")", ",", "dim", "=", "0", ")", "\n", "return", "x", ",", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.regression_loss": [[229, 252], ["simpgcn.AttrSim", "AttrSim.get_label().to", "len", "numpy.random.choice", "simpgcn.SimPGCN.linear", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "simpgcn.SimPGCN.linear", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "simpgcn.SimPGCN.features.to_dense", "len", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "simpgcn.AttrSim.get_label"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.AttrSim.get_label"], ["", "def", "regression_loss", "(", "self", ",", "embeddings", ")", ":", "\n", "        ", "if", "self", ".", "pseudo_labels", "is", "None", ":", "\n", "            ", "agent", "=", "AttrSim", "(", "self", ".", "features", ".", "to_dense", "(", ")", ")", "\n", "self", ".", "pseudo_labels", "=", "agent", ".", "get_label", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "node_pairs", "=", "agent", ".", "node_pairs", "\n", "self", ".", "node_pairs", "=", "node_pairs", "\n", "\n", "", "k", "=", "10000", "\n", "node_pairs", "=", "self", ".", "node_pairs", "\n", "if", "len", "(", "self", ".", "node_pairs", "[", "0", "]", ")", ">", "k", ":", "\n", "            ", "sampled", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "node_pairs", "[", "0", "]", ")", ",", "k", ",", "replace", "=", "False", ")", "\n", "\n", "embeddings0", "=", "embeddings", "[", "node_pairs", "[", "0", "]", "[", "sampled", "]", "]", "\n", "embeddings1", "=", "embeddings", "[", "node_pairs", "[", "1", "]", "[", "sampled", "]", "]", "\n", "embeddings", "=", "self", ".", "linear", "(", "torch", ".", "abs", "(", "embeddings0", "-", "embeddings1", ")", ")", "\n", "loss", "=", "F", ".", "mse_loss", "(", "embeddings", ",", "self", ".", "pseudo_labels", "[", "sampled", "]", ",", "reduction", "=", "'mean'", ")", "\n", "", "else", ":", "\n", "            ", "embeddings0", "=", "embeddings", "[", "node_pairs", "[", "0", "]", "]", "\n", "embeddings1", "=", "embeddings", "[", "node_pairs", "[", "1", "]", "]", "\n", "embeddings", "=", "self", ".", "linear", "(", "torch", ".", "abs", "(", "embeddings0", "-", "embeddings1", ")", ")", "\n", "loss", "=", "F", ".", "mse_loss", "(", "embeddings", ",", "self", ".", "pseudo_labels", ",", "reduction", "=", "'mean'", ")", "\n", "# print(loss)", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN._train_without_val": [[253, 271], ["simpgcn.SimPGCN.train", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "simpgcn.SimPGCN.eval", "simpgcn.SimPGCN.forward", "simpgcn.SimPGCN.parameters", "simpgcn.SimPGCN.train", "torch.Adam.zero_grad", "simpgcn.SimPGCN.myforward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "loss_total.backward", "torch.Adam.step", "simpgcn.SimPGCN.regression_loss", "print", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.myforward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.regression_loss"], ["", "def", "_train_without_val", "(", "self", ",", "labels", ",", "idx_train", ",", "train_iters", ",", "verbose", ")", ":", "\n", "        ", "self", ".", "train", "(", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", ",", "embeddings", "=", "self", ".", "myforward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_ssl", "=", "self", ".", "lambda_", "*", "self", ".", "regression_loss", "(", "embeddings", ")", "\n", "loss_total", "=", "loss_train", "+", "loss_ssl", "\n", "loss_total", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "self", ".", "output", "=", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN._train_with_val": [[273, 314], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "simpgcn.SimPGCN.load_state_dict", "print", "simpgcn.SimPGCN.parameters", "simpgcn.SimPGCN.train", "torch.Adam.zero_grad", "simpgcn.SimPGCN.myforward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "loss_total.backward", "torch.Adam.step", "simpgcn.SimPGCN.eval", "simpgcn.SimPGCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.accuracy", "print", "simpgcn.SimPGCN.regression_loss", "print", "copy.deepcopy", "copy.deepcopy", "simpgcn.SimPGCN.state_dict", "simpgcn.SimPGCN.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.myforward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.regression_loss"], ["", "def", "_train_with_val", "(", "self", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "verbose", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training gcn model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "best_loss_val", "=", "100", "\n", "best_acc_val", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", ",", "embeddings", "=", "self", ".", "myforward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "# acc_train = accuracy(output[idx_train], labels[idx_train])", "\n", "loss_ssl", "=", "self", ".", "lambda_", "*", "self", ".", "regression_loss", "(", "embeddings", ")", "\n", "loss_total", "=", "loss_train", "+", "loss_ssl", "\n", "loss_total", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "acc_val", "=", "utils", ".", "accuracy", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "if", "acc_val", ">", "best_acc_val", ":", "\n", "                ", "best_acc_val", "=", "acc_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== picking the best model according to the performance on validation ==='", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN._train_with_early_stopping": [[315, 353], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "simpgcn.SimPGCN.load_state_dict", "print", "simpgcn.SimPGCN.parameters", "simpgcn.SimPGCN.train", "torch.Adam.zero_grad", "simpgcn.SimPGCN.myforward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "loss_total.backward", "torch.Adam.step", "simpgcn.SimPGCN.eval", "simpgcn.SimPGCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "print", "simpgcn.SimPGCN.regression_loss", "print", "copy.deepcopy", "simpgcn.SimPGCN.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.myforward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.regression_loss"], ["", "def", "_train_with_early_stopping", "(", "self", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "patience", ",", "verbose", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training gcn model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "early_stopping", "=", "patience", "\n", "best_loss_val", "=", "100", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", ",", "embeddings", "=", "self", ".", "myforward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_ssl", "=", "self", ".", "lambda_", "*", "self", ".", "regression_loss", "(", "embeddings", ")", "\n", "loss_total", "=", "loss_train", "+", "loss_ssl", "\n", "loss_total", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "patience", "=", "early_stopping", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "", "if", "i", ">", "early_stopping", "and", "patience", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ":", "\n", "             ", "print", "(", "'=== early stopping at {0}, loss_val = {1} ==='", ".", "format", "(", "i", ",", "best_loss_val", ")", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.test": [[354, 371], ["simpgcn.SimPGCN.eval", "simpgcn.SimPGCN.predict", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.accuracy", "print", "deeprobust.accuracy.item", "torch.nll_loss.item", "deeprobust.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "test", "(", "self", ",", "idx_test", ")", ":", "\n", "        ", "\"\"\"Evaluate GCN performance on test set.\n\n        Parameters\n        ----------\n        idx_test :\n            node testing indices\n        \"\"\"", "\n", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "predict", "(", ")", "\n", "# output = self.output", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_test", "]", ",", "self", ".", "labels", "[", "idx_test", "]", ")", "\n", "acc_test", "=", "utils", ".", "accuracy", "(", "output", "[", "idx_test", "]", ",", "self", ".", "labels", "[", "idx_test", "]", ")", "\n", "print", "(", "\"Test set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.SimPGCN.predict": [[373, 403], ["simpgcn.SimPGCN.eval", "simpgcn.SimPGCN.forward", "deeprobust.is_sparse_tensor", "simpgcn.SimPGCN.forward", "type", "deeprobust.to_tensor", "deeprobust.normalize_adj_tensor", "deeprobust.normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["", "def", "predict", "(", "self", ",", "features", "=", "None", ",", "adj", "=", "None", ")", ":", "\n", "        ", "\"\"\"By default, the inputs should be unnormalized data\n\n        Parameters\n        ----------\n        features :\n            node features. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n        adj :\n            adjcency matrix. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n\n\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of GCN\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "if", "features", "is", "None", "and", "adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "", "else", ":", "\n", "            ", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "                ", "features", ",", "adj", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "features", "=", "features", "\n", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.AttrSim.__init__": [[407, 410], ["features.cpu().numpy", "features.cpu"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "features", ")", ":", "\n", "        ", "self", ".", "features", "=", "features", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "features", "[", "self", ".", "features", "!=", "0", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.AttrSim.get_label": [[411, 458], ["print", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "torch.FloatTensor().reshape", "os.path.exists", "sklearn.metrics.pairwise.cosine_similarity", "numpy.save", "print", "numpy.load", "os.path.exists", "numpy.array().transpose", "numpy.save", "print", "numpy.load", "len", "numpy.load.argsort", "numpy.arange", "numpy.hstack", "set", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "len", "itertools.product", "set", "tqdm", "numpy.array", "set.add", "enumerate", "row.argsort.argsort.argsort", "numpy.arange", "numpy.random.choice", "numpy.hstack", "list", "set.add"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "def", "get_label", "(", "self", ",", "k", "=", "5", ")", ":", "\n", "        ", "features", "=", "self", ".", "features", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'saved_knn/cosine_sims_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", ":", "\n", "            ", "sims", "=", "cosine_similarity", "(", "features", ")", "\n", "np", ".", "save", "(", "'saved_knn/cosine_sims_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ",", "sims", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'loading saved_knn/cosine_sims_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "sims", "=", "np", ".", "load", "(", "'saved_knn/cosine_sims_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'saved_knn/attrsim_sampled_idx_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "indices_sorted", "=", "sims", ".", "argsort", "(", "1", ")", "\n", "idx", "=", "np", ".", "arange", "(", "k", ",", "sims", ".", "shape", "[", "0", "]", "-", "k", ")", "\n", "selected", "=", "np", ".", "hstack", "(", "(", "indices_sorted", "[", ":", ",", ":", "k", "]", ",", "\n", "indices_sorted", "[", ":", ",", "-", "k", "-", "1", ":", "]", ")", ")", "\n", "\n", "selected_set", "=", "set", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "sims", ")", ")", ":", "\n", "                    ", "for", "pair", "in", "product", "(", "[", "i", "]", ",", "selected", "[", "i", "]", ")", ":", "\n", "                        ", "if", "pair", "[", "0", "]", ">", "pair", "[", "1", "]", ":", "\n", "                            ", "pair", "=", "(", "pair", "[", "1", "]", ",", "pair", "[", "0", "]", ")", "\n", "", "if", "pair", "[", "0", "]", "==", "pair", "[", "1", "]", ":", "\n", "                            ", "continue", "\n", "", "selected_set", ".", "add", "(", "pair", ")", "\n", "\n", "", "", "", "except", "MemoryError", ":", "\n", "                ", "selected_set", "=", "set", "(", ")", "\n", "for", "ii", ",", "row", "in", "tqdm", "(", "enumerate", "(", "sims", ")", ")", ":", "\n", "                    ", "row", "=", "row", ".", "argsort", "(", ")", "\n", "idx", "=", "np", ".", "arange", "(", "k", ",", "sims", ".", "shape", "[", "0", "]", "-", "k", ")", "\n", "sampled", "=", "np", ".", "random", ".", "choice", "(", "idx", ",", "k", ",", "replace", "=", "False", ")", "\n", "for", "node", "in", "np", ".", "hstack", "(", "(", "row", "[", ":", "k", "]", ",", "row", "[", "-", "k", "-", "1", ":", "]", ",", "row", "[", "sampled", "]", ")", ")", ":", "\n", "                        ", "if", "ii", ">", "node", ":", "\n", "                            ", "pair", "=", "(", "node", ",", "ii", ")", "\n", "", "else", ":", "\n", "                            ", "pair", "=", "(", "ii", ",", "node", ")", "\n", "", "selected_set", ".", "add", "(", "pair", ")", "\n", "\n", "", "", "", "sampled", "=", "np", ".", "array", "(", "list", "(", "selected_set", ")", ")", ".", "transpose", "(", ")", "\n", "np", ".", "save", "(", "'saved_knn/attrsim_sampled_idx_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ",", "sampled", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'loading saved_knn/attrsim_sampled_idx_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "sampled", "=", "np", ".", "load", "(", "'saved_knn/attrsim_sampled_idx_{}.npy'", ".", "format", "(", "features", ".", "shape", ")", ")", "\n", "", "print", "(", "'number of sampled:'", ",", "len", "(", "sampled", "[", "0", "]", ")", ")", "\n", "self", ".", "node_pairs", "=", "(", "sampled", "[", "0", "]", ",", "sampled", "[", "1", "]", ")", "\n", "self", ".", "sims", "=", "sims", "\n", "return", "torch", ".", "FloatTensor", "(", "sims", "[", "self", ".", "node_pairs", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.preprocess_adj_noloop": [[460, 466], ["adj_normalizer", "deeprobust.sparse_mx_to_torch_sparse_tensor().float", "r_adj.to.to", "deeprobust.sparse_mx_to_torch_sparse_tensor"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.sparse_mx_to_torch_sparse_tensor"], ["", "", "def", "preprocess_adj_noloop", "(", "adj", ",", "device", ")", ":", "\n", "    ", "adj_normalizer", "=", "noaug_normalized_adjacency", "\n", "r_adj", "=", "adj_normalizer", "(", "adj", ")", "\n", "r_adj", "=", "utils", ".", "sparse_mx_to_torch_sparse_tensor", "(", "r_adj", ")", ".", "float", "(", ")", "\n", "r_adj", "=", "r_adj", ".", "to", "(", "device", ")", "\n", "return", "r_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.simpgcn.noaug_normalized_adjacency": [[467, 474], ["scipy.coo_matrix", "numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot().dot().tocoo", "sp.coo_matrix.sum", "numpy.power", "numpy.isinf", "sp.diags.dot().dot", "sp.diags.dot"], "function", ["None"], ["", "def", "noaug_normalized_adjacency", "(", "adj", ")", ":", "\n", "   ", "adj", "=", "sp", ".", "coo_matrix", "(", "adj", ")", "\n", "row_sum", "=", "np", ".", "array", "(", "adj", ".", "sum", "(", "1", ")", ")", "\n", "d_inv_sqrt", "=", "np", ".", "power", "(", "row_sum", ",", "-", "0.5", ")", ".", "flatten", "(", ")", "\n", "d_inv_sqrt", "[", "np", ".", "isinf", "(", "d_inv_sqrt", ")", "]", "=", "0.", "\n", "d_mat_inv_sqrt", "=", "sp", ".", "diags", "(", "d_inv_sqrt", ")", "\n", "return", "d_mat_inv_sqrt", ".", "dot", "(", "adj", ")", ".", "dot", "(", "d_mat_inv_sqrt", ")", ".", "tocoo", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GraphConvolution.__init__": [[16, 26], ["torch.nn.modules.module.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "gcn.GraphConvolution.reset_parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "gcn.GraphConvolution.register_parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "with_bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "GraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "if", "with_bias", ":", "\n", "            ", "self", ".", "bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GraphConvolution.reset_parameters": [[27, 32], ["gcn.GraphConvolution.weight.data.uniform_", "math.sqrt", "gcn.GraphConvolution.bias.data.uniform_", "gcn.GraphConvolution.weight.size"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "weight", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GraphConvolution.forward": [[33, 45], ["torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "adj", ")", ":", "\n", "        ", "\"\"\" Graph Convolutional Layer forward function\n        \"\"\"", "\n", "if", "input", ".", "data", ".", "is_sparse", ":", "\n", "            ", "support", "=", "torch", ".", "spmm", "(", "input", ",", "self", ".", "weight", ")", "\n", "", "else", ":", "\n", "            ", "support", "=", "torch", ".", "mm", "(", "input", ",", "self", ".", "weight", ")", "\n", "", "output", "=", "torch", ".", "spmm", "(", "adj", ",", "support", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "return", "output", "+", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GraphConvolution.__repr__": [[46, 50], ["str", "str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "' ('", "+", "str", "(", "self", ".", "in_features", ")", "+", "' -> '", "+", "str", "(", "self", ".", "out_features", ")", "+", "')'", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.__init__": [[96, 121], ["torch.Module.__init__", "gcn.GraphConvolution", "gcn.GraphConvolution"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "weight_decay", "=", "5e-4", ",", "\n", "with_relu", "=", "True", ",", "with_bias", "=", "True", ",", "device", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "GCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "device", "is", "not", "None", ",", "\"Please specify 'device'!\"", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "nfeat", "=", "nfeat", "\n", "self", ".", "hidden_sizes", "=", "[", "nhid", "]", "\n", "self", ".", "nclass", "=", "nclass", "\n", "self", ".", "gc1", "=", "GraphConvolution", "(", "nfeat", ",", "nhid", ",", "with_bias", "=", "with_bias", ")", "\n", "self", ".", "gc2", "=", "GraphConvolution", "(", "nhid", ",", "nclass", ",", "with_bias", "=", "with_bias", ")", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "lr", "=", "lr", "\n", "if", "not", "with_relu", ":", "\n", "            ", "self", ".", "weight_decay", "=", "0", "\n", "", "else", ":", "\n", "            ", "self", ".", "weight_decay", "=", "weight_decay", "\n", "", "self", ".", "with_relu", "=", "with_relu", "\n", "self", ".", "with_bias", "=", "with_bias", "\n", "self", ".", "output", "=", "None", "\n", "self", ".", "best_model", "=", "None", "\n", "self", ".", "best_output", "=", "None", "\n", "self", ".", "adj_norm", "=", "None", "\n", "self", ".", "features", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.forward": [[122, 131], ["torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "gcn.GCN.gc2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "gcn.GCN.gc1", "gcn.GCN.gc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "adj", ")", ":", "\n", "        ", "if", "self", ".", "with_relu", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "self", ".", "gc1", "(", "x", ",", "adj", ")", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "gc1", "(", "x", ",", "adj", ")", "\n", "\n", "", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "x", "=", "self", ".", "gc2", "(", "x", ",", "adj", ")", "\n", "return", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize": [[132, 137], ["gcn.GCN.gc1.reset_parameters", "gcn.GCN.gc2.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize parameters of GCN.\n        \"\"\"", "\n", "self", ".", "gc1", ".", "reset_parameters", "(", ")", "\n", "self", ".", "gc2", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.fit": [[138, 195], ["gcn.GCN.initialize", "type", "deeprobust.graph.utils.to_tensor", "features.to.to.to", "adj.to.to.to", "labels.to.to.to", "deeprobust.graph.utils.is_sparse_tensor", "gcn.GCN._train_without_val", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.normalize_adj_tensor", "gcn.GCN._train_with_early_stopping", "gcn.GCN._train_with_val"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.initialize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_without_val", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN._train_with_early_stopping", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_with_val"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "False", ",", "normalize", "=", "True", ",", "patience", "=", "500", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train the gcn model, when idx_val is not None, pick the best model according to the validation loss.\n\n        Parameters\n        ----------\n        features :\n            node features\n        adj :\n            the adjacency matrix. The format could be torch.tensor or scipy matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices. If not given (None), GCN training process will not adpot early stopping\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        normalize : bool\n            whether to normalize the input adjacency matrix.\n        patience : int\n            patience for early stopping, only valid when `idx_val` is given\n        \"\"\"", "\n", "\n", "self", ".", "device", "=", "self", ".", "gc1", ".", "weight", ".", "device", "\n", "if", "initialize", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n", "", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "            ", "features", ",", "adj", ",", "labels", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "features", ".", "to", "(", "self", ".", "device", ")", "\n", "adj", "=", "adj", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "normalize", ":", "\n", "            ", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "", "else", ":", "\n", "            ", "adj_norm", "=", "adj", "\n", "\n", "", "self", ".", "adj_norm", "=", "adj_norm", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "\n", "if", "idx_val", "is", "None", ":", "\n", "            ", "self", ".", "_train_without_val", "(", "labels", ",", "idx_train", ",", "train_iters", ",", "verbose", ")", "\n", "", "else", ":", "\n", "            ", "if", "patience", "<", "train_iters", ":", "\n", "                ", "self", ".", "_train_with_early_stopping", "(", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "patience", ",", "verbose", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_train_with_val", "(", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN._train_without_val": [[196, 211], ["gcn.GCN.train", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "gcn.GCN.eval", "gcn.GCN.forward", "gcn.GCN.parameters", "torch.Adam.zero_grad", "gcn.GCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "print", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "", "def", "_train_without_val", "(", "self", ",", "labels", ",", "idx_train", ",", "train_iters", ",", "verbose", ")", ":", "\n", "        ", "self", ".", "train", "(", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "self", ".", "output", "=", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN._train_with_val": [[212, 249], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "gcn.GCN.load_state_dict", "print", "gcn.GCN.parameters", "gcn.GCN.train", "torch.Adam.zero_grad", "gcn.GCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "gcn.GCN.eval", "gcn.GCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "print", "copy.deepcopy", "copy.deepcopy", "gcn.GCN.state_dict", "gcn.GCN.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "_train_with_val", "(", "self", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "verbose", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training gcn model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "best_loss_val", "=", "100", "\n", "best_acc_val", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "acc_val", "=", "utils", ".", "accuracy", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "if", "acc_val", ">", "best_acc_val", ":", "\n", "                ", "best_acc_val", "=", "acc_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== picking the best model according to the performance on validation ==='", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN._train_with_early_stopping": [[250, 293], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "gcn.GCN.load_state_dict", "print", "gcn.GCN.parameters", "gcn.GCN.train", "torch.Adam.zero_grad", "gcn.GCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss.backward", "torch.Adam.step", "gcn.GCN.eval", "gcn.GCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "print", "print", "copy.deepcopy", "gcn.GCN.state_dict", "torch.nll_loss.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "_train_with_early_stopping", "(", "self", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "patience", ",", "verbose", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'=== training gcn model ==='", ")", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n", "early_stopping", "=", "patience", "\n", "best_loss_val", "=", "100", "\n", "\n", "for", "i", "in", "range", "(", "train_iters", ")", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "verbose", "and", "i", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch {}, training loss: {}'", ".", "format", "(", "i", ",", "loss_train", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "\n", "# def eval_class(output, labels):", "\n", "#     preds = output.max(1)[1].type_as(labels)", "\n", "#     return f1_score(labels.cpu().numpy(), preds.cpu().numpy(), average='micro') + \\", "\n", "#         f1_score(labels.cpu().numpy(), preds.cpu().numpy(), average='macro')", "\n", "\n", "# perf_sum = eval_class(output[idx_val], labels[idx_val])", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "\n", "if", "best_loss_val", ">", "loss_val", ":", "\n", "                ", "best_loss_val", "=", "loss_val", "\n", "self", ".", "output", "=", "output", "\n", "weights", "=", "deepcopy", "(", "self", ".", "state_dict", "(", ")", ")", "\n", "patience", "=", "early_stopping", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "", "if", "i", ">", "early_stopping", "and", "patience", "<=", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ":", "\n", "             ", "print", "(", "'=== early stopping at {0}, loss_val = {1} ==='", ".", "format", "(", "i", ",", "best_loss_val", ")", ")", "\n", "", "self", ".", "load_state_dict", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.test": [[294, 311], ["gcn.GCN.eval", "gcn.GCN.predict", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "test", "(", "self", ",", "idx_test", ")", ":", "\n", "        ", "\"\"\"Evaluate GCN performance on test set.\n\n        Parameters\n        ----------\n        idx_test :\n            node testing indices\n        \"\"\"", "\n", "self", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "predict", "(", ")", "\n", "# output = self.output", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_test", "]", ",", "self", ".", "labels", "[", "idx_test", "]", ")", "\n", "acc_test", "=", "utils", ".", "accuracy", "(", "output", "[", "idx_test", "]", ",", "self", ".", "labels", "[", "idx_test", "]", ")", "\n", "print", "(", "\"Test set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn.GCN.predict": [[313, 343], ["gcn.GCN.eval", "gcn.GCN.forward", "deeprobust.graph.utils.is_sparse_tensor", "gcn.GCN.forward", "type", "deeprobust.graph.utils.to_tensor", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["", "def", "predict", "(", "self", ",", "features", "=", "None", ",", "adj", "=", "None", ")", ":", "\n", "        ", "\"\"\"By default, the inputs should be unnormalized adjacency\n\n        Parameters\n        ----------\n        features :\n            node features. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n        adj :\n            adjcency matrix. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n\n\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of GCN\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "if", "features", "is", "None", "and", "adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "", "else", ":", "\n", "            ", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "                ", "features", ",", "adj", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "features", "=", "features", "\n", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_F.__init__": [[23, 31], ["torch.nn.modules.module.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "r_gcn.GGCL_F.reset_parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "dropout", "=", "0.6", ")", ":", "\n", "        ", "super", "(", "GGCL_F", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "weight_miu", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_F.reset_parameters": [[32, 35], ["torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_miu", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_F.forward": [[36, 45], ["torch.dropout", "torch.dropout", "torch.dropout", "torch.elu", "torch.elu", "torch.elu", "torch.relu", "torch.relu", "torch.relu", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ",", "adj_norm1", ",", "adj_norm2", ",", "gamma", "=", "1", ")", ":", "\n", "        ", "features", "=", "F", ".", "dropout", "(", "features", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "self", ".", "miu", "=", "F", ".", "elu", "(", "torch", ".", "mm", "(", "features", ",", "self", ".", "weight_miu", ")", ")", "\n", "self", ".", "sigma", "=", "F", ".", "relu", "(", "torch", ".", "mm", "(", "features", ",", "self", ".", "weight_sigma", ")", ")", "\n", "# torch.mm(previous_sigma, self.weight_sigma)", "\n", "Att", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "self", ".", "sigma", ")", "\n", "miu_out", "=", "adj_norm1", "@", "(", "self", ".", "miu", "*", "Att", ")", "\n", "sigma_out", "=", "adj_norm2", "@", "(", "self", ".", "sigma", "*", "Att", "*", "Att", ")", "\n", "return", "miu_out", ",", "sigma_out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_D.__init__": [[49, 58], ["torch.nn.modules.module.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "r_gcn.GGCL_D.reset_parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "GGCL_D", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "weight_miu", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "# self.register_parameter('bias', None)", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_D.reset_parameters": [[59, 62], ["torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_miu", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GGCL_D.forward": [[63, 73], ["torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.elu", "torch.elu", "torch.elu", "torch.relu", "torch.relu", "torch.relu", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "miu", ",", "sigma", ",", "adj_norm1", ",", "adj_norm2", ",", "gamma", "=", "1", ")", ":", "\n", "        ", "miu", "=", "F", ".", "dropout", "(", "miu", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "sigma", "=", "F", ".", "dropout", "(", "sigma", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "miu", "=", "F", ".", "elu", "(", "miu", "@", "self", ".", "weight_miu", ")", "\n", "sigma", "=", "F", ".", "relu", "(", "sigma", "@", "self", ".", "weight_sigma", ")", "\n", "\n", "Att", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "sigma", ")", "\n", "mean_out", "=", "adj_norm1", "@", "(", "miu", "*", "Att", ")", "\n", "sigma_out", "=", "adj_norm2", "@", "(", "sigma", "*", "Att", "*", "Att", ")", "\n", "return", "mean_out", ",", "sigma_out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.__init__": [[20, 29], ["torch.nn.modules.module.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "r_gcn.GaussianConvolution.reset_parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], ["class", "GGCL_F", "(", "Module", ")", ":", "\n", "    ", "\"\"\"Graph Gaussian Convolution Layer (GGCL) when the input is feature\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "dropout", "=", "0.6", ")", ":", "\n", "        ", "super", "(", "GGCL_F", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "weight_miu", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters": [[30, 34], ["torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["self", ".", "reset_parameters", "(", ")", "\n", "\n", "", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_miu", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_sigma", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.forward": [[35, 45], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["None"], ["\n", "", "def", "forward", "(", "self", ",", "features", ",", "adj_norm1", ",", "adj_norm2", ",", "gamma", "=", "1", ")", ":", "\n", "        ", "features", "=", "F", ".", "dropout", "(", "features", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "self", ".", "miu", "=", "F", ".", "elu", "(", "torch", ".", "mm", "(", "features", ",", "self", ".", "weight_miu", ")", ")", "\n", "self", ".", "sigma", "=", "F", ".", "relu", "(", "torch", ".", "mm", "(", "features", ",", "self", ".", "weight_sigma", ")", ")", "\n", "# torch.mm(previous_sigma, self.weight_sigma)", "\n", "Att", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "self", ".", "sigma", ")", "\n", "miu_out", "=", "adj_norm1", "@", "(", "self", ".", "miu", "*", "Att", ")", "\n", "sigma_out", "=", "adj_norm2", "@", "(", "self", ".", "sigma", "*", "Att", "*", "Att", ")", "\n", "return", "miu_out", ",", "sigma_out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.__repr__": [[54, 58], ["str", "str"], "methods", ["None"], ["self", ".", "weight_miu", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "# self.register_parameter('bias', None)", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.__init__": [[62, 87], ["torch.nn.modules.module.Module.__init__", "r_gcn.GaussianConvolution", "r_gcn.GaussianConvolution", "torch.distributions.multivariate_normal.MultivariateNormal", "torch.distributions.multivariate_normal.MultivariateNormal", "torch.distributions.multivariate_normal.MultivariateNormal", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.diag_embed", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["\n", "", "def", "forward", "(", "self", ",", "miu", ",", "sigma", ",", "adj_norm1", ",", "adj_norm2", ",", "gamma", "=", "1", ")", ":", "\n", "        ", "miu", "=", "F", ".", "dropout", "(", "miu", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "sigma", "=", "F", ".", "dropout", "(", "sigma", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "miu", "=", "F", ".", "elu", "(", "miu", "@", "self", ".", "weight_miu", ")", "\n", "sigma", "=", "F", ".", "relu", "(", "sigma", "@", "self", ".", "weight_sigma", ")", "\n", "\n", "Att", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "sigma", ")", "\n", "mean_out", "=", "adj_norm1", "@", "(", "miu", "*", "Att", ")", "\n", "sigma_out", "=", "adj_norm2", "@", "(", "sigma", "*", "Att", "*", "Att", ")", "\n", "return", "mean_out", ",", "sigma_out", "\n", "\n", "\n", "", "", "class", "GaussianConvolution", "(", "Module", ")", ":", "\n", "    ", "\"\"\"[Deprecated] Alternative gaussion convolution layer.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ")", ":", "\n", "        ", "super", "(", "GaussianConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "weight_miu", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "# self.sigma = Parameter(torch.FloatTensor(out_features))", "\n", "# self.register_parameter('bias', None)", "\n", "self", ".", "reset_parameters", "(", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.forward": [[88, 106], ["r_gcn.RGCN.gc1", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "r_gcn.RGCN.gc2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.elu", "torch.elu", "torch.elu", "torch.relu", "torch.relu", "torch.relu", "torch.elu", "torch.elu", "torch.elu", "torch.relu", "torch.relu", "torch.relu", "r_gcn.RGCN.gaussian.sample().to", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "r_gcn.RGCN.gaussian.sample"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.sample"], ["\n", "", "def", "reset_parameters", "(", "self", ")", ":", "\n", "# TODO", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_miu", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_sigma", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "previous_miu", ",", "previous_sigma", ",", "adj_norm1", "=", "None", ",", "adj_norm2", "=", "None", ",", "gamma", "=", "1", ")", ":", "\n", "\n", "        ", "if", "adj_norm1", "is", "None", "and", "adj_norm2", "is", "None", ":", "\n", "            ", "return", "torch", ".", "mm", "(", "previous_miu", ",", "self", ".", "weight_miu", ")", ",", "torch", ".", "mm", "(", "previous_miu", ",", "self", ".", "weight_miu", ")", "\n", "# torch.mm(previous_sigma, self.weight_sigma)", "\n", "\n", "", "Att", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "previous_sigma", ")", "\n", "M", "=", "adj_norm1", "@", "(", "previous_miu", "*", "Att", ")", "@", "self", ".", "weight_miu", "\n", "Sigma", "=", "adj_norm2", "@", "(", "previous_sigma", "*", "Att", "*", "Att", ")", "@", "self", ".", "weight_sigma", "\n", "return", "M", ",", "Sigma", "\n", "\n", "# M = torch.mm(torch.mm(adj, previous_miu * A), self.weight_miu)", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.fit": [[179, 232], ["deeprobust.graph.utils.to_tensor", "r_gcn.RGCN._normalize_adj", "r_gcn.RGCN._normalize_adj", "print", "r_gcn.RGCN._initialize", "adj.todense", "features.todense", "r_gcn.RGCN._train_without_val", "r_gcn.RGCN._train_with_val"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_without_val", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_with_val"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "train_iters", "=", "200", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train RGCN.\n\n        Parameters\n        ----------\n        features :\n            node features\n        adj :\n            the adjacency matrix. The format could be torch.tensor or scipy matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices. If not given (None), GCN training process will not adpot early stopping\n        train_iters : int\n            number of training epochs\n        verbose : bool\n            whether to show verbose logs\n\n        Examples\n        --------\n        We can first load dataset and then train RGCN.\n\n        >>> from deeprobust.graph.data import PrePtbDataset, Dataset\n        >>> from deeprobust.graph.defense import RGCN\n        >>> # load clean graph data\n        >>> data = Dataset(root='/tmp/', name='cora', seed=15)\n        >>> adj, features, labels = data.adj, data.features, data.labels\n        >>> idx_train, idx_val, idx_test = data.idx_train, data.idx_val, data.idx_test\n        >>> # load perturbed graph data\n        >>> perturbed_data = PrePtbDataset(root='/tmp/', name='cora')\n        >>> perturbed_adj = perturbed_data.adj\n        >>> # train defense model\n        >>> model = RGCN(nnodes=perturbed_adj.shape[0], nfeat=features.shape[1],\n                         nclass=labels.max()+1, nhid=32, device='cpu')\n        >>> model.fit(features, perturbed_adj, labels, idx_train, idx_val,\n                      train_iters=200, verbose=True)\n        >>> model.test(idx_test)\n\n        \"\"\"", "\n", "\n", "adj", ",", "features", ",", "labels", "=", "utils", ".", "to_tensor", "(", "adj", ".", "todense", "(", ")", ",", "features", ".", "todense", "(", ")", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "self", ".", "features", ",", "self", ".", "labels", "=", "features", ",", "labels", "\n", "self", ".", "adj_norm1", "=", "self", ".", "_normalize_adj", "(", "adj", ",", "power", "=", "-", "1", "/", "2", ")", "\n", "self", ".", "adj_norm2", "=", "self", ".", "_normalize_adj", "(", "adj", ",", "power", "=", "-", "1", ")", "\n", "print", "(", "'=== training rgcn model ==='", ")", "\n", "self", ".", "_initialize", "(", ")", "\n", "if", "idx_val", "is", "None", ":", "\n", "            ", "self", ".", "_train_without_val", "(", "labels", ",", "idx_train", ",", "train_iters", ",", "verbose", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_train_with_val", "(", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_without_val": [[120, 136], ["print", "torch.Adam", "torch.Adam", "torch.Adam", "r_gcn.RGCN.train", "range", "r_gcn.RGCN.eval", "r_gcn.RGCN.forward", "r_gcn.RGCN.parameters", "torch.Adam.zero_grad", "r_gcn.RGCN.forward", "r_gcn.RGCN.loss", "r_gcn.RGCN.backward", "torch.Adam.step", "print", "r_gcn.RGCN.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "class", "RGCN", "(", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_with_val": [[137, 168], ["print", "torch.Adam", "torch.Adam", "torch.Adam", "range", "print", "r_gcn.RGCN.parameters", "r_gcn.RGCN.train", "torch.Adam.zero_grad", "r_gcn.RGCN.forward", "r_gcn.RGCN.loss", "r_gcn.RGCN.backward", "torch.Adam.step", "r_gcn.RGCN.eval", "r_gcn.RGCN.forward", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "r_gcn.RGCN.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["\n", "\n", "def", "__init__", "(", "self", ",", "nnodes", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "gamma", "=", "1.0", ",", "beta1", "=", "5e-4", ",", "beta2", "=", "5e-4", ",", "lr", "=", "0.01", ",", "dropout", "=", "0.6", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "RGCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "device", "=", "device", "\n", "# adj_norm = normalize(adj)", "\n", "# first turn original features to distribution", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "beta1", "=", "beta1", "\n", "self", ".", "beta2", "=", "beta2", "\n", "self", ".", "nclass", "=", "nclass", "\n", "self", ".", "nhid", "=", "nhid", "//", "2", "\n", "# self.gc1 = GaussianConvolution(nfeat, nhid, dropout=dropout)", "\n", "# self.gc2 = GaussianConvolution(nhid, nclass, dropout)", "\n", "self", ".", "gc1", "=", "GGCL_F", "(", "nfeat", ",", "nhid", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "gc2", "=", "GGCL_D", "(", "nhid", ",", "nclass", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "# self.gaussian = MultivariateNormal(torch.zeros(self.nclass), torch.eye(self.nclass))", "\n", "self", ".", "gaussian", "=", "MultivariateNormal", "(", "torch", ".", "zeros", "(", "nnodes", ",", "self", ".", "nclass", ")", ",", "\n", "torch", ".", "diag_embed", "(", "torch", ".", "ones", "(", "nnodes", ",", "self", ".", "nclass", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.test": [[170, 178], ["torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["self", ".", "features", ",", "self", ".", "labels", "=", "None", ",", "None", "\n", "\n", "", "def", "forward", "(", "self", ")", ":", "\n", "        ", "features", "=", "self", ".", "features", "\n", "miu", ",", "sigma", "=", "self", ".", "gc1", "(", "features", ",", "self", ".", "adj_norm1", ",", "self", ".", "adj_norm2", ",", "self", ".", "gamma", ")", "\n", "miu", ",", "sigma", "=", "self", ".", "gc2", "(", "miu", ",", "sigma", ",", "self", ".", "adj_norm1", ",", "self", ".", "adj_norm2", ",", "self", ".", "gamma", ")", "\n", "output", "=", "miu", "+", "self", ".", "gaussian", ".", "sample", "(", ")", ".", "to", "(", "self", ".", "device", ")", "*", "torch", ".", "sqrt", "(", "sigma", "+", "1e-8", ")", "\n", "return", "F", ".", "log_softmax", "(", "output", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.predict": [[294, 304], ["r_gcn.RGCN.eval", "r_gcn.RGCN.forward"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "def", "predict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of RGCN\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "return", "self", ".", "forward", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._loss": [[305, 316], ["torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "kl_loss.sum.sum.sum", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "miu1.pow"], "methods", ["None"], ["", "def", "_loss", "(", "self", ",", "input", ",", "labels", ")", ":", "\n", "        ", "loss", "=", "F", ".", "nll_loss", "(", "input", ",", "labels", ")", "\n", "miu1", "=", "self", ".", "gc1", ".", "miu", "\n", "sigma1", "=", "self", ".", "gc1", ".", "sigma", "\n", "kl_loss", "=", "0.5", "*", "(", "miu1", ".", "pow", "(", "2", ")", "+", "sigma1", "-", "torch", ".", "log", "(", "1e-8", "+", "sigma1", ")", ")", ".", "mean", "(", "1", ")", "\n", "kl_loss", "=", "kl_loss", ".", "sum", "(", ")", "\n", "norm2", "=", "torch", ".", "norm", "(", "self", ".", "gc1", ".", "weight_miu", ",", "2", ")", ".", "pow", "(", "2", ")", "+", "torch", ".", "norm", "(", "self", ".", "gc1", ".", "weight_sigma", ",", "2", ")", ".", "pow", "(", "2", ")", "\n", "\n", "# print(f'gcn_loss: {loss.item()}, kl_loss: {self.beta1 * kl_loss.item()}, norm2: {self.beta2 * norm2.item()}')", "\n", "return", "loss", "+", "self", ".", "beta1", "*", "kl_loss", "+", "self", ".", "beta2", "*", "norm2", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize": [[188, 191], ["r_gcn.RGCN.gc1.reset_parameters", "r_gcn.RGCN.gc2.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.GaussianConvolution.reset_parameters"], []], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._normalize_adj": [[192, 200], ["A.sum().pow", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "A.sum", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], []], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.PGD.__init__": [[31, 41], ["dict", "torch.optim.Optimizer.__init__", "group.setdefault", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "proxs", ",", "alphas", ",", "lr", "=", "required", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "weight_decay", "=", "0", ")", ":", "\n", "        ", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "nesterov", "=", "False", ")", "\n", "\n", "\n", "super", "(", "PGD", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'proxs'", ",", "proxs", ")", "\n", "group", ".", "setdefault", "(", "'alphas'", ",", "alphas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.PGD.__setstate__": [[42, 48], ["super().__setstate__", "group.setdefault", "group.setdefault", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.SGD.__setstate__"], ["", "", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "PGD", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'nesterov'", ",", "False", ")", "\n", "group", ".", "setdefault", "(", "'proxs'", ",", "proxs", ")", "\n", "group", ".", "setdefault", "(", "'alphas'", ",", "alphas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.PGD.step": [[49, 65], ["zip", "prox_operator"], "methods", ["None"], ["", "", "def", "step", "(", "self", ",", "delta", "=", "0", ",", "closure", "=", "None", ")", ":", "\n", "         ", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "lr", "=", "group", "[", "'lr'", "]", "\n", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "dampening", "=", "group", "[", "'dampening'", "]", "\n", "nesterov", "=", "group", "[", "'nesterov'", "]", "\n", "proxs", "=", "group", "[", "'proxs'", "]", "\n", "alphas", "=", "group", "[", "'alphas'", "]", "\n", "\n", "# apply the proximal operator to each parameter in a group", "\n", "for", "param", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "for", "prox_operator", ",", "alpha", "in", "zip", "(", "proxs", ",", "alphas", ")", ":", "\n", "# param.data.add_(lr, -param.grad.data)", "\n", "# param.data.add_(delta)", "\n", "                    ", "param", ".", "data", "=", "prox_operator", "(", "param", ".", "data", ",", "alpha", "=", "alpha", "*", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.__init__": [[71, 73], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "nuclear_norm", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.prox_l1": [[74, 79], ["torch.mul", "torch.sign", "torch.clamp", "torch.abs"], "methods", ["None"], ["", "def", "prox_l1", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Proximal operator for l1 norm.\n        \"\"\"", "\n", "data", "=", "torch", ".", "mul", "(", "torch", ".", "sign", "(", "data", ")", ",", "torch", ".", "clamp", "(", "torch", ".", "abs", "(", "data", ")", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.prox_nuclear": [[80, 90], ["numpy.linalg.svd", "S.sum", "torch.diag", "torch.matmul", "data.cpu", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.clamp", "torch.matmul", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["None"], ["", "def", "prox_nuclear", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Proximal operator for nuclear norm (trace norm).\n        \"\"\"", "\n", "U", ",", "S", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "data", ".", "cpu", "(", ")", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "# print(\"nuclear norm: %.4f\" % self.nuclear_norm)", "\n", "\n", "diag_S", "=", "torch", ".", "diag", "(", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "U", ",", "diag_S", ")", ",", "V", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.prox_nuclear_truncated_2": [[91, 112], ["tl.set_backend", "tl.truncated_svd", "torch.clamp.sum", "torch.clamp", "torch.tensor().cuda", "torch.sparse.FloatTensor", "torch.spmm", "torch.matmul", "data.cpu", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.Size", "torch.tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "len", "len", "range", "range", "len", "len"], "methods", ["None"], ["", "def", "prox_nuclear_truncated_2", "(", "self", ",", "data", ",", "alpha", ",", "k", "=", "50", ")", ":", "\n", "        ", "import", "tensorly", "as", "tl", "\n", "tl", ".", "set_backend", "(", "'pytorch'", ")", "\n", "U", ",", "S", ",", "V", "=", "tl", ".", "truncated_svd", "(", "data", ".", "cpu", "(", ")", ",", "n_eigenvecs", "=", "k", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "# print(\"nuclear norm: %.4f\" % self.nuclear_norm)", "\n", "\n", "S", "=", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", "\n", "\n", "# diag_S = torch.diag(torch.clamp(S-alpha, min=0))", "\n", "# U = torch.spmm(U, diag_S)", "\n", "# V = torch.matmul(U, V)", "\n", "\n", "# make diag_S sparse matrix", "\n", "indices", "=", "torch", ".", "tensor", "(", "(", "range", "(", "0", ",", "len", "(", "S", ")", ")", ",", "range", "(", "0", ",", "len", "(", "S", ")", ")", ")", ")", ".", "cuda", "(", ")", "\n", "values", "=", "S", "\n", "diag_S", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ",", "values", ",", "torch", ".", "Size", "(", "(", "len", "(", "S", ")", ",", "len", "(", "S", ")", ")", ")", ")", "\n", "V", "=", "torch", ".", "spmm", "(", "diag_S", ",", "V", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "U", ",", "V", ")", "\n", "return", "V", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.prox_nuclear_truncated": [[113, 122], ["torch.nonzero().t", "scipy.csr_matrix", "scipy.linalg.svds", "S.sum", "torch.diag", "torch.matmul", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.clamp", "torch.matmul", "torch.nonzero", "values.cpu().numpy", "torch.nonzero().t.cpu().numpy", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "values.cpu", "torch.nonzero().t.cpu"], "methods", ["None"], ["", "def", "prox_nuclear_truncated", "(", "self", ",", "data", ",", "alpha", ",", "k", "=", "50", ")", ":", "\n", "        ", "indices", "=", "torch", ".", "nonzero", "(", "data", ")", ".", "t", "(", ")", "\n", "values", "=", "data", "[", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", "]", "# modify this based on dimensionality", "\n", "data_sparse", "=", "sp", ".", "csr_matrix", "(", "(", "values", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "U", ",", "S", ",", "V", "=", "sp", ".", "linalg", ".", "svds", "(", "data_sparse", ",", "k", "=", "k", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "diag_S", "=", "torch", ".", "diag", "(", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "U", ",", "diag_S", ")", ",", "V", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.ProxOperators.prox_nuclear_cuda": [[123, 138], ["torch.svd", "torch.clamp.sum", "torch.clamp", "torch.tensor().cuda", "torch.sparse.FloatTensor", "torch.spmm", "torch.matmul", "torch.Size", "torch.matmul.t_", "torch.tensor", "range", "range"], "methods", ["None"], ["", "def", "prox_nuclear_cuda", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "\n", "        ", "U", ",", "S", ",", "V", "=", "torch", ".", "svd", "(", "data", ")", "\n", "# self.nuclear_norm = S.sum()", "\n", "# print(f\"rank = {len(S.nonzero())}\")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "S", "=", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", "\n", "indices", "=", "torch", ".", "tensor", "(", "[", "range", "(", "0", ",", "U", ".", "shape", "[", "0", "]", ")", ",", "range", "(", "0", ",", "U", ".", "shape", "[", "0", "]", ")", "]", ")", ".", "cuda", "(", ")", "\n", "values", "=", "S", "\n", "diag_S", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ",", "values", ",", "torch", ".", "Size", "(", "U", ".", "shape", ")", ")", "\n", "# diag_S = torch.diag(torch.clamp(S-alpha, min=0))", "\n", "# print(f\"rank_after = {len(diag_S.nonzero())}\")", "\n", "V", "=", "torch", ".", "spmm", "(", "diag_S", ",", "V", ".", "t_", "(", ")", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "U", ",", "V", ")", "\n", "return", "V", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.SGD.__init__": [[143, 157], ["dict", "torch.optim.Optimizer.__init__", "ValueError", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "required", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "nesterov", "=", "False", ")", ":", "\n", "        ", "if", "lr", "is", "not", "required", "and", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid weight_decay value: {}\"", ".", "format", "(", "weight_decay", ")", ")", "\n", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "dampening", "=", "dampening", ",", "\n", "weight_decay", "=", "weight_decay", ",", "nesterov", "=", "nesterov", ")", "\n", "if", "nesterov", "and", "(", "momentum", "<=", "0", "or", "dampening", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Nesterov momentum requires a momentum and zero dampening\"", ")", "\n", "", "super", "(", "SGD", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.SGD.__setstate__": [[158, 162], ["super().__setstate__", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.SGD.__setstate__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "SGD", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'nesterov'", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgd.SGD.step": [[163, 201], ["closure", "p.data.add_", "d_p.add.add.add_", "torch.clone().detach", "torch.clone().detach.mul_().add_", "d_p.add.add.add", "torch.clone", "torch.clone().detach.mul_"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.rl.nstep_replay_mem.NstepReplayMem.add"], ["", "", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "dampening", "=", "group", "[", "'dampening'", "]", "\n", "nesterov", "=", "group", "[", "'nesterov'", "]", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "d_p", "=", "p", ".", "grad", ".", "data", "\n", "if", "weight_decay", "!=", "0", ":", "\n", "                    ", "d_p", ".", "add_", "(", "weight_decay", ",", "p", ".", "data", ")", "\n", "", "if", "momentum", "!=", "0", ":", "\n", "                    ", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "torch", ".", "clone", "(", "d_p", ")", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "1", "-", "dampening", ",", "d_p", ")", "\n", "", "if", "nesterov", ":", "\n", "                        ", "d_p", "=", "d_p", ".", "add", "(", "momentum", ",", "buf", ")", "\n", "", "else", ":", "\n", "                        ", "d_p", "=", "buf", "\n", "\n", "", "", "p", ".", "data", ".", "add_", "(", "-", "group", "[", "'lr'", "]", ",", "d_p", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.fit_": [[107, 119], ["deeprobust.graph.utils.to_tensor", "r_gcn.RGCN._normalize_adj", "r_gcn.RGCN._normalize_adj", "print", "r_gcn.RGCN._initialize", "adj.todense", "r_gcn.RGCN._train_without_val", "r_gcn.RGCN._train_with_val"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._normalize_adj", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._initialize", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_without_val", "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN._train_with_val"], ["# Sigma = torch.mm(torch.mm(adj, previous_sigma * A * A), self.weight_sigma)", "\n", "\n", "# TODO sparse implemention", "\n", "# support = torch.mm(input, self.weight)", "\n", "# output = torch.spmm(adj, support)", "\n", "# return output + self.bias", "\n", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "' ('", "+", "str", "(", "self", ".", "in_features", ")", "+", "' -> '", "+", "str", "(", "self", ".", "out_features", ")", "+", "')'", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.r_gcn.RGCN.loss": [[179, 187], ["torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "kl_loss.sum.sum.sum", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "r_gcn.RGCN.miu1.pow"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "train_iters", "=", "200", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.__init__": [[30, 39], ["model.to"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "__init__", "(", "self", ",", "model", ",", "args", ",", "device", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "best_val_acc", "=", "0", "\n", "self", ".", "best_val_loss", "=", "10", "\n", "self", ".", "best_graph", "=", "None", "\n", "self", ".", "weights", "=", "None", "\n", "self", ".", "estimator", "=", "None", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.fit": [[40, 102], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "EstimateAdj().to", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "deeprobust.graph.defense.pgd.PGD", "warnings.warn", "deeprobust.graph.defense.pgd.PGD", "time.time", "range", "print", "print", "print", "print", "prognn.ProGNN.model.load_state_dict", "prognn.ProGNN.model.parameters", "EstimateAdj().to.parameters", "EstimateAdj().to.parameters", "EstimateAdj().to.parameters", "prognn.EstimateAdj", "prognn.ProGNN.train_gcn", "range", "range", "int", "prognn.ProGNN.train_adj", "int", "prognn.ProGNN.train_gcn", "time.time"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_gcn", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_adj", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_gcn"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Train Pro-GNN.\n\n        Parameters\n        ----------\n        features :\n            node features\n        adj :\n            the adjacency matrix. The format could be torch.tensor or scipy matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices\n        \"\"\"", "\n", "args", "=", "self", ".", "args", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "args", ".", "lr", ",", "weight_decay", "=", "args", ".", "weight_decay", ")", "\n", "estimator", "=", "EstimateAdj", "(", "adj", ",", "symmetric", "=", "args", ".", "symmetric", ",", "device", "=", "self", ".", "device", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "optimizer_adj", "=", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "\n", "momentum", "=", "0.9", ",", "lr", "=", "args", ".", "lr_adj", ")", "\n", "\n", "self", ".", "optimizer_l1", "=", "PGD", "(", "estimator", ".", "parameters", "(", ")", ",", "\n", "proxs", "=", "[", "prox_operators", ".", "prox_l1", "]", ",", "\n", "lr", "=", "args", ".", "lr_adj", ",", "alphas", "=", "[", "args", ".", "alpha", "]", ")", "\n", "\n", "# warnings.warn(\"If you find the nuclear proximal operator runs too slow on Pubmed, you can  uncomment line 67-71 and use prox_nuclear_cuda to perform the proximal on gpu.\")", "\n", "# if args.dataset == \"pubmed\":", "\n", "#     self.optimizer_nuclear = PGD(estimator.parameters(),", "\n", "#               proxs=[prox_operators.prox_nuclear_cuda],", "\n", "#               lr=args.lr_adj, alphas=[args.beta])", "\n", "# else:", "\n", "warnings", ".", "warn", "(", "\"If you find the nuclear proximal operator runs too slow, you can modify line 77 to use prox_operators.prox_nuclear_cuda instead of prox_operators.prox_nuclear to perform the proximal on GPU. See details in https://github.com/ChandlerBang/Pro-GNN/issues/1\"", ")", "\n", "self", ".", "optimizer_nuclear", "=", "PGD", "(", "estimator", ".", "parameters", "(", ")", ",", "\n", "proxs", "=", "[", "prox_operators", ".", "prox_nuclear", "]", ",", "\n", "lr", "=", "args", ".", "lr_adj", ",", "alphas", "=", "[", "args", ".", "beta", "]", ")", "\n", "\n", "# Train model", "\n", "t_total", "=", "time", ".", "time", "(", ")", "\n", "for", "epoch", "in", "range", "(", "args", ".", "epochs", ")", ":", "\n", "            ", "if", "args", ".", "only_gcn", ":", "\n", "                ", "self", ".", "train_gcn", "(", "epoch", ",", "features", ",", "estimator", ".", "estimated_adj", ",", "\n", "labels", ",", "idx_train", ",", "idx_val", ")", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "range", "(", "int", "(", "args", ".", "outer_steps", ")", ")", ":", "\n", "                    ", "self", ".", "train_adj", "(", "epoch", ",", "features", ",", "adj", ",", "labels", ",", "\n", "idx_train", ",", "idx_val", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "int", "(", "args", ".", "inner_steps", ")", ")", ":", "\n", "                    ", "self", ".", "train_gcn", "(", "epoch", ",", "features", ",", "estimator", ".", "estimated_adj", ",", "\n", "labels", ",", "idx_train", ",", "idx_val", ")", "\n", "\n", "", "", "", "print", "(", "\"Optimization Finished!\"", ")", "\n", "print", "(", "\"Total time elapsed: {:.4f}s\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "t_total", ")", ")", "\n", "print", "(", "args", ")", "\n", "\n", "# Testing", "\n", "print", "(", "\"picking the best model according to validation performance\"", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "self", ".", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_gcn": [[103, 148], ["estimator.normalize", "time.time", "prognn.ProGNN.model.train", "prognn.ProGNN.optimizer.zero_grad", "prognn.ProGNN.model", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "torch.nll_loss.backward", "prognn.ProGNN.optimizer.step", "prognn.ProGNN.model.eval", "prognn.ProGNN.model", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "estimator.normalize.detach", "copy.deepcopy", "estimator.normalize.detach", "copy.deepcopy", "prognn.ProGNN.model.state_dict", "print", "prognn.ProGNN.model.state_dict", "print", "print", "prognn.ProGNN.best_val_acc.item", "prognn.ProGNN.best_val_loss.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item", "time.time"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy"], ["", "def", "train_gcn", "(", "self", ",", "epoch", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", ")", ":", "\n", "        ", "args", "=", "self", ".", "args", "\n", "estimator", "=", "self", ".", "estimator", "\n", "adj", "=", "estimator", ".", "normalize", "(", ")", "\n", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "output", "=", "self", ".", "model", "(", "features", ",", "adj", ")", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "acc_train", "=", "accuracy", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "loss_train", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Evaluate validation set performance separately,", "\n", "# deactivates dropout during validation run.", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "output", "=", "self", ".", "model", "(", "features", ",", "adj", ")", "\n", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "acc_val", "=", "accuracy", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "\n", "if", "acc_val", ">", "self", ".", "best_val_acc", ":", "\n", "            ", "self", ".", "best_val_acc", "=", "acc_val", "\n", "self", ".", "best_graph", "=", "adj", ".", "detach", "(", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "if", "args", ".", "debug", ":", "\n", "                ", "print", "(", "'\\t=== saving current graph/gcn, best_val_acc: %s'", "%", "self", ".", "best_val_acc", ".", "item", "(", ")", ")", "\n", "\n", "", "", "if", "loss_val", "<", "self", ".", "best_val_loss", ":", "\n", "            ", "self", ".", "best_val_loss", "=", "loss_val", "\n", "self", ".", "best_graph", "=", "adj", ".", "detach", "(", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "if", "args", ".", "debug", ":", "\n", "                ", "print", "(", "f'\\t=== saving current graph/gcn, best_val_loss: %s'", "%", "self", ".", "best_val_loss", ".", "item", "(", ")", ")", "\n", "\n", "", "", "if", "args", ".", "debug", ":", "\n", "            ", "if", "epoch", "%", "1", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch: {:04d}'", ".", "format", "(", "epoch", "+", "1", ")", ",", "\n", "'loss_train: {:.4f}'", ".", "format", "(", "loss_train", ".", "item", "(", ")", ")", ",", "\n", "'acc_train: {:.4f}'", ".", "format", "(", "acc_train", ".", "item", "(", ")", ")", ",", "\n", "'loss_val: {:.4f}'", ".", "format", "(", "loss_val", ".", "item", "(", ")", ")", ",", "\n", "'acc_val: {:.4f}'", ".", "format", "(", "acc_val", ".", "item", "(", ")", ")", ",", "\n", "'time: {:.4f}s'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "t", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.train_adj": [[151, 238], ["time.time", "estimator.train", "prognn.ProGNN.optimizer_adj.zero_grad", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "estimator.normalize", "prognn.ProGNN.model", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "loss_diffiential.backward", "prognn.ProGNN.optimizer_adj.step", "prognn.ProGNN.optimizer_l1.zero_grad", "prognn.ProGNN.optimizer_l1.step", "estimator.estimated_adj.data.copy_", "prognn.ProGNN.model.eval", "estimator.normalize", "prognn.ProGNN.model", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "print", "prognn.ProGNN.feature_smoothing", "prognn.ProGNN.optimizer_nuclear.zero_grad", "prognn.ProGNN.optimizer_nuclear.step", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "estimator.normalize.detach", "copy.deepcopy", "estimator.normalize.detach", "copy.deepcopy", "estimator.estimated_adj.t", "deeprobust.graph.utils.accuracy.item", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item", "prognn.ProGNN.model.state_dict", "print", "prognn.ProGNN.model.state_dict", "print", "print", "time.time", "prognn.ProGNN.best_val_acc.item", "prognn.ProGNN.best_val_loss.item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "torch.nll_loss.item", "prognn.ProGNN.item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "torch.norm.item", "total_loss.item", "loss_nuclear.item", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.feature_smoothing", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "", "def", "train_adj", "(", "self", ",", "epoch", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", ")", ":", "\n", "        ", "estimator", "=", "self", ".", "estimator", "\n", "args", "=", "self", ".", "args", "\n", "if", "args", ".", "debug", ":", "\n", "            ", "print", "(", "\"\\n=== train_adj ===\"", ")", "\n", "", "t", "=", "time", ".", "time", "(", ")", "\n", "estimator", ".", "train", "(", ")", "\n", "self", ".", "optimizer_adj", ".", "zero_grad", "(", ")", "\n", "\n", "loss_l1", "=", "torch", ".", "norm", "(", "estimator", ".", "estimated_adj", ",", "1", ")", "\n", "loss_fro", "=", "torch", ".", "norm", "(", "estimator", ".", "estimated_adj", "-", "adj", ",", "p", "=", "'fro'", ")", "\n", "normalized_adj", "=", "estimator", ".", "normalize", "(", ")", "\n", "\n", "if", "args", ".", "lambda_", ":", "\n", "            ", "loss_smooth_feat", "=", "self", ".", "feature_smoothing", "(", "estimator", ".", "estimated_adj", ",", "features", ")", "\n", "", "else", ":", "\n", "            ", "loss_smooth_feat", "=", "0", "*", "loss_l1", "\n", "\n", "", "output", "=", "self", ".", "model", "(", "features", ",", "normalized_adj", ")", "\n", "loss_gcn", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "acc_train", "=", "accuracy", "(", "output", "[", "idx_train", "]", ",", "labels", "[", "idx_train", "]", ")", "\n", "\n", "loss_symmetric", "=", "torch", ".", "norm", "(", "estimator", ".", "estimated_adj", "-", "estimator", ".", "estimated_adj", ".", "t", "(", ")", ",", "p", "=", "\"fro\"", ")", "\n", "\n", "loss_diffiential", "=", "loss_fro", "+", "args", ".", "gamma", "*", "loss_gcn", "+", "args", ".", "lambda_", "*", "loss_smooth_feat", "+", "args", ".", "phi", "*", "loss_symmetric", "\n", "\n", "loss_diffiential", ".", "backward", "(", ")", "\n", "\n", "self", ".", "optimizer_adj", ".", "step", "(", ")", "\n", "loss_nuclear", "=", "0", "*", "loss_fro", "\n", "if", "args", ".", "beta", "!=", "0", ":", "\n", "            ", "self", ".", "optimizer_nuclear", ".", "zero_grad", "(", ")", "\n", "self", ".", "optimizer_nuclear", ".", "step", "(", ")", "\n", "loss_nuclear", "=", "prox_operators", ".", "nuclear_norm", "\n", "\n", "", "self", ".", "optimizer_l1", ".", "zero_grad", "(", ")", "\n", "self", ".", "optimizer_l1", ".", "step", "(", ")", "\n", "\n", "total_loss", "=", "loss_fro", "+", "args", ".", "gamma", "*", "loss_gcn", "+", "args", ".", "alpha", "*", "loss_l1", "+", "args", ".", "beta", "*", "loss_nuclear", "+", "args", ".", "phi", "*", "loss_symmetric", "\n", "\n", "estimator", ".", "estimated_adj", ".", "data", ".", "copy_", "(", "torch", ".", "clamp", "(", "\n", "estimator", ".", "estimated_adj", ".", "data", ",", "min", "=", "0", ",", "max", "=", "1", ")", ")", "\n", "\n", "# Evaluate validation set performance separately,", "\n", "# deactivates dropout during validation run.", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "normalized_adj", "=", "estimator", ".", "normalize", "(", ")", "\n", "output", "=", "self", ".", "model", "(", "features", ",", "normalized_adj", ")", "\n", "\n", "loss_val", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "acc_val", "=", "accuracy", "(", "output", "[", "idx_val", "]", ",", "labels", "[", "idx_val", "]", ")", "\n", "print", "(", "'Epoch: {:04d}'", ".", "format", "(", "epoch", "+", "1", ")", ",", "\n", "'acc_train: {:.4f}'", ".", "format", "(", "acc_train", ".", "item", "(", ")", ")", ",", "\n", "'loss_val: {:.4f}'", ".", "format", "(", "loss_val", ".", "item", "(", ")", ")", ",", "\n", "'acc_val: {:.4f}'", ".", "format", "(", "acc_val", ".", "item", "(", ")", ")", ",", "\n", "'time: {:.4f}s'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "t", ")", ")", "\n", "\n", "if", "acc_val", ">", "self", ".", "best_val_acc", ":", "\n", "            ", "self", ".", "best_val_acc", "=", "acc_val", "\n", "self", ".", "best_graph", "=", "normalized_adj", ".", "detach", "(", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "if", "args", ".", "debug", ":", "\n", "                ", "print", "(", "f'\\t=== saving current graph/gcn, best_val_acc: %s'", "%", "self", ".", "best_val_acc", ".", "item", "(", ")", ")", "\n", "\n", "", "", "if", "loss_val", "<", "self", ".", "best_val_loss", ":", "\n", "            ", "self", ".", "best_val_loss", "=", "loss_val", "\n", "self", ".", "best_graph", "=", "normalized_adj", ".", "detach", "(", ")", "\n", "self", ".", "weights", "=", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "if", "args", ".", "debug", ":", "\n", "                ", "print", "(", "f'\\t=== saving current graph/gcn, best_val_loss: %s'", "%", "self", ".", "best_val_loss", ".", "item", "(", ")", ")", "\n", "\n", "", "", "if", "args", ".", "debug", ":", "\n", "            ", "if", "epoch", "%", "1", "==", "0", ":", "\n", "                ", "print", "(", "'Epoch: {:04d}'", ".", "format", "(", "epoch", "+", "1", ")", ",", "\n", "'loss_fro: {:.4f}'", ".", "format", "(", "loss_fro", ".", "item", "(", ")", ")", ",", "\n", "'loss_gcn: {:.4f}'", ".", "format", "(", "loss_gcn", ".", "item", "(", ")", ")", ",", "\n", "'loss_feat: {:.4f}'", ".", "format", "(", "loss_smooth_feat", ".", "item", "(", ")", ")", ",", "\n", "'loss_symmetric: {:.4f}'", ".", "format", "(", "loss_symmetric", ".", "item", "(", ")", ")", ",", "\n", "'delta_l1_norm: {:.4f}'", ".", "format", "(", "torch", ".", "norm", "(", "estimator", ".", "estimated_adj", "-", "adj", ",", "1", ")", ".", "item", "(", ")", ")", ",", "\n", "'loss_l1: {:.4f}'", ".", "format", "(", "loss_l1", ".", "item", "(", ")", ")", ",", "\n", "'loss_total: {:.4f}'", ".", "format", "(", "total_loss", ".", "item", "(", ")", ")", ",", "\n", "'loss_nuclear: {:.4f}'", ".", "format", "(", "loss_nuclear", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.test": [[240, 255], ["print", "prognn.ProGNN.model.eval", "prognn.ProGNN.model", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "deeprobust.graph.utils.accuracy", "print", "deeprobust.graph.utils.accuracy.item", "prognn.ProGNN.estimator.normalize", "torch.nll_loss.item", "deeprobust.graph.utils.accuracy.item"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["", "", "", "def", "test", "(", "self", ",", "features", ",", "labels", ",", "idx_test", ")", ":", "\n", "        ", "\"\"\"Evaluate the performance of ProGNN on test set\n        \"\"\"", "\n", "print", "(", "\"\\t=== testing ===\"", ")", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "adj", "=", "self", ".", "best_graph", "\n", "if", "self", ".", "best_graph", "is", "None", ":", "\n", "            ", "adj", "=", "self", ".", "estimator", ".", "normalize", "(", ")", "\n", "", "output", "=", "self", ".", "model", "(", "features", ",", "adj", ")", "\n", "loss_test", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_test", "]", ",", "labels", "[", "idx_test", "]", ")", "\n", "acc_test", "=", "accuracy", "(", "output", "[", "idx_test", "]", ",", "labels", "[", "idx_test", "]", ")", "\n", "print", "(", "\"\\tTest set results:\"", ",", "\n", "\"loss= {:.4f}\"", ".", "format", "(", "loss_test", ".", "item", "(", ")", ")", ",", "\n", "\"accuracy= {:.4f}\"", ".", "format", "(", "acc_test", ".", "item", "(", ")", ")", ")", "\n", "return", "acc_test", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.ProGNN.feature_smoothing": [[256, 273], ["adj.sum", "adj.sum.flatten", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "r_inv.pow().flatten.pow().flatten.pow().flatten", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.trace", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "adj.t", "r_inv.pow().flatten.pow().flatten.pow", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "X.t"], "methods", ["None"], ["", "def", "feature_smoothing", "(", "self", ",", "adj", ",", "X", ")", ":", "\n", "        ", "adj", "=", "(", "adj", ".", "t", "(", ")", "+", "adj", ")", "/", "2", "\n", "rowsum", "=", "adj", ".", "sum", "(", "1", ")", "\n", "r_inv", "=", "rowsum", ".", "flatten", "(", ")", "\n", "D", "=", "torch", ".", "diag", "(", "r_inv", ")", "\n", "L", "=", "D", "-", "adj", "\n", "\n", "r_inv", "=", "r_inv", "+", "1e-3", "\n", "r_inv", "=", "r_inv", ".", "pow", "(", "-", "1", "/", "2", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "torch", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "torch", ".", "diag", "(", "r_inv", ")", "\n", "# L = r_mat_inv @ L", "\n", "L", "=", "r_mat_inv", "@", "L", "@", "r_mat_inv", "\n", "\n", "XLXT", "=", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "X", ".", "t", "(", ")", ",", "L", ")", ",", "X", ")", "\n", "loss_smooth_feat", "=", "torch", ".", "trace", "(", "XLXT", ")", "\n", "return", "loss_smooth_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj.__init__": [[280, 287], ["torch.Module.__init__", "len", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "prognn.EstimateAdj._init_estimation", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj._init_estimation"], ["def", "__init__", "(", "self", ",", "adj", ",", "symmetric", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", "EstimateAdj", ",", "self", ")", ".", "__init__", "(", ")", "\n", "n", "=", "len", "(", "adj", ")", "\n", "self", ".", "estimated_adj", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "n", ",", "n", ")", ")", "\n", "self", ".", "_init_estimation", "(", "adj", ")", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj._init_estimation": [[288, 292], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "len", "prognn.EstimateAdj.estimated_adj.data.copy_"], "methods", ["None"], ["", "def", "_init_estimation", "(", "self", ",", "adj", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "n", "=", "len", "(", "adj", ")", "\n", "self", ".", "estimated_adj", ".", "data", ".", "copy_", "(", "adj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj.forward": [[293, 295], ["None"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "estimated_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj.normalize": [[296, 305], ["prognn.EstimateAdj._normalize", "prognn.EstimateAdj.estimated_adj.t", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj._normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "normalize", "(", "self", ")", ":", "\n", "\n", "        ", "if", "self", ".", "symmetric", ":", "\n", "            ", "adj", "=", "(", "self", ".", "estimated_adj", "+", "self", ".", "estimated_adj", ".", "t", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "adj", "=", "self", ".", "estimated_adj", "\n", "\n", "", "normalized_adj", "=", "self", ".", "_normalize", "(", "adj", "+", "torch", ".", "eye", "(", "adj", ".", "shape", "[", "0", "]", ")", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "return", "normalized_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.prognn.EstimateAdj._normalize": [[306, 314], ["mx.sum", "mx.sum.pow().flatten", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "mx.sum.pow", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf"], "methods", ["None"], ["", "def", "_normalize", "(", "self", ",", "mx", ")", ":", "\n", "        ", "rowsum", "=", "mx", ".", "sum", "(", "1", ")", "\n", "r_inv", "=", "rowsum", ".", "pow", "(", "-", "1", "/", "2", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "torch", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "torch", ".", "diag", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", "@", "mx", "\n", "mx", "=", "mx", "@", "r_mat_inv", "\n", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.BaseEmbedding.__init__": [[23, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "embedding", "=", "None", "\n", "self", ".", "model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.BaseEmbedding.evaluate_node_classification": [[27, 73], ["sklearn.linear_model.LogisticRegression.fit", "sklearn.linear_model.LogisticRegression.predict", "sklearn.metrics.f1_score", "sklearn.metrics.f1_score", "sklearn.metrics.accuracy_score", "print", "print", "sklearn.preprocessing.normalize", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["", "def", "evaluate_node_classification", "(", "self", ",", "labels", ",", "idx_train", ",", "idx_test", ",", "\n", "normalize_embedding", "=", "True", ",", "lr_params", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate the node embeddings on the node classification task..\n\n        Parameters\n        ---------\n        labels: np.ndarray, shape [n_nodes]\n            The ground truth labels\n        normalize_embedding: bool\n            Whether to normalize the embeddings\n        idx_train: np.array\n            Indices of training nodes\n        idx_test: np.array\n            Indices of test nodes\n        lr_params: dict\n            Parameters for the LogisticRegression model\n\n        Returns\n        -------\n        [numpy.array, float, float] :\n            Predictions from LR, micro F1 score and macro F1 score\n        \"\"\"", "\n", "\n", "embedding_matrix", "=", "self", ".", "embedding", "\n", "\n", "if", "normalize_embedding", ":", "\n", "            ", "embedding_matrix", "=", "normalize", "(", "embedding_matrix", ")", "\n", "\n", "", "features_train", "=", "embedding_matrix", "[", "idx_train", "]", "\n", "features_test", "=", "embedding_matrix", "[", "idx_test", "]", "\n", "labels_train", "=", "labels", "[", "idx_train", "]", "\n", "labels_test", "=", "labels", "[", "idx_test", "]", "\n", "\n", "if", "lr_params", "is", "None", ":", "\n", "            ", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "1000", ",", "multi_class", "=", "'auto'", ")", "\n", "", "else", ":", "\n", "            ", "lr", "=", "LogisticRegression", "(", "**", "lr_params", ")", "\n", "", "lr", ".", "fit", "(", "features_train", ",", "labels_train", ")", "\n", "\n", "lr_z_predict", "=", "lr", ".", "predict", "(", "features_test", ")", "\n", "f1_micro", "=", "f1_score", "(", "labels_test", ",", "lr_z_predict", ",", "average", "=", "'micro'", ")", "\n", "f1_macro", "=", "f1_score", "(", "labels_test", ",", "lr_z_predict", ",", "average", "=", "'macro'", ")", "\n", "test_acc", "=", "accuracy_score", "(", "labels_test", ",", "lr_z_predict", ")", "\n", "print", "(", "'Micro F1:'", ",", "f1_micro", ")", "\n", "print", "(", "'Macro F1:'", ",", "f1_macro", ")", "\n", "return", "lr_z_predict", ",", "f1_micro", ",", "f1_macro", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.BaseEmbedding.evaluate_link_prediction": [[75, 107], ["sklearn.metrics.average_precision_score", "print", "print", "sklearn.preprocessing.normalize", "sklearn.metrics.roc_auc_score", "print"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["", "def", "evaluate_link_prediction", "(", "self", ",", "adj", ",", "node_pairs", ",", "normalize_embedding", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate the node embeddings on the link prediction task.\n\n        adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        node_pairs: numpy.array, shape [n_pairs, 2]\n            Node pairs\n        normalize_embedding: bool\n            Whether to normalize the embeddings\n\n        Returns\n        -------\n        [numpy.array, float, float]\n            Inner product of embeddings, Area under ROC curve (AUC) score and average precision (AP) score\n        \"\"\"", "\n", "\n", "embedding_matrix", "=", "self", ".", "embedding", "\n", "if", "normalize_embedding", ":", "\n", "            ", "embedding_matrix", "=", "normalize", "(", "embedding_matrix", ")", "\n", "\n", "", "true", "=", "adj", "[", "node_pairs", "[", ":", ",", "0", "]", ",", "node_pairs", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "scores", "=", "(", "embedding_matrix", "[", "node_pairs", "[", ":", ",", "0", "]", "]", "*", "embedding_matrix", "[", "node_pairs", "[", ":", ",", "1", "]", "]", ")", ".", "sum", "(", "1", ")", "\n", "# print(np.unique(true, return_counts=True))", "\n", "try", ":", "\n", "            ", "auc_score", "=", "roc_auc_score", "(", "true", ",", "scores", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "auc_score", "=", "0.00", "\n", "print", "(", "'ROC error'", ")", "\n", "", "ap_score", "=", "average_precision_score", "(", "true", ",", "scores", ")", "\n", "print", "(", "\"AUC:\"", ",", "auc_score", ")", "\n", "print", "(", "\"AP:\"", ",", "ap_score", ")", "\n", "return", "scores", ",", "auc_score", ",", "ap_score", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.Node2Vec.__init__": [[134, 138], ["node_embedding.BaseEmbedding.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "# self.fit = self.node2vec_snap", "\n", "        ", "super", "(", "Node2Vec", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fit", "=", "self", ".", "node2vec", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.Node2Vec.node2vec": [[139, 171], ["node_embedding.sample_n2v_random_walks", "gensim.models.Word2Vec", "list", "map", "numpy.fromiter().argsort", "numpy.fromiter", "map"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sample_n2v_random_walks"], ["", "def", "node2vec", "(", "self", ",", "adj", ",", "embedding_dim", "=", "64", ",", "walk_length", "=", "30", ",", "walks_per_node", "=", "10", ",", "\n", "workers", "=", "8", ",", "window_size", "=", "10", ",", "num_neg_samples", "=", "1", ",", "p", "=", "4", ",", "q", "=", "1", ")", ":", "\n", "        ", "\"\"\"Compute Node2Vec embeddings for the given graph.\n\n        Parameters\n        ----------\n        adj : sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        embedding_dim : int, optional\n            Dimension of the embedding\n        walks_per_node : int, optional\n            Number of walks sampled from each node\n        walk_length : int, optional\n            Length of each random walk\n        workers : int, optional\n            Number of threads (see gensim.differentiable_models.Word2Vec process)\n        window_size : int, optional\n            Window size (see gensim.differentiable_models.Word2Vec)\n        num_neg_samples : int, optional\n            Number of negative samples (see gensim.differentiable_models.Word2Vec)\n        p : float\n            The hyperparameter p in node2vec\n        q : float\n            The hyperparameter q in node2vec\n        \"\"\"", "\n", "\n", "\n", "walks", "=", "sample_n2v_random_walks", "(", "adj", ",", "walk_length", ",", "walks_per_node", ",", "p", "=", "p", ",", "q", "=", "q", ")", "\n", "walks", "=", "[", "list", "(", "map", "(", "str", ",", "walk", ")", ")", "for", "walk", "in", "walks", "]", "\n", "self", ".", "model", "=", "Word2Vec", "(", "walks", ",", "size", "=", "embedding_dim", ",", "window", "=", "window_size", ",", "min_count", "=", "0", ",", "sg", "=", "1", ",", "workers", "=", "workers", ",", "\n", "iter", "=", "1", ",", "negative", "=", "num_neg_samples", ",", "hs", "=", "0", ",", "compute_loss", "=", "True", ")", "\n", "self", ".", "embedding", "=", "self", ".", "model", ".", "wv", ".", "vectors", "[", "np", ".", "fromiter", "(", "map", "(", "int", ",", "self", ".", "model", ".", "wv", ".", "index2word", ")", ",", "np", ".", "int32", ")", ".", "argsort", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.DeepWalk.__init__": [[203, 211], ["node_embedding.BaseEmbedding.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "type", "=", "\"skipgram\"", ")", ":", "\n", "        ", "super", "(", "DeepWalk", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "type", "==", "\"skipgram\"", ":", "\n", "            ", "self", ".", "fit", "=", "self", ".", "deepwalk_skipgram", "\n", "", "elif", "type", "==", "\"svd\"", ":", "\n", "            ", "self", ".", "fit", "=", "self", ".", "deepwalk_svd", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.DeepWalk.deepwalk_skipgram": [[212, 239], ["node_embedding.sample_random_walks", "gensim.models.Word2Vec", "list", "map", "numpy.fromiter().argsort", "numpy.fromiter", "map"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sample_random_walks"], ["", "", "def", "deepwalk_skipgram", "(", "self", ",", "adj", ",", "embedding_dim", "=", "64", ",", "walk_length", "=", "80", ",", "walks_per_node", "=", "10", ",", "\n", "workers", "=", "8", ",", "window_size", "=", "10", ",", "num_neg_samples", "=", "1", ")", ":", "\n", "        ", "\"\"\"Compute DeepWalk embeddings for the given graph using the skip-gram formulation.\n\n        Parameters\n        ----------\n        adj : sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        embedding_dim : int, optional\n            Dimension of the embedding\n        walks_per_node : int, optional\n            Number of walks sampled from each node\n        walk_length : int, optional\n            Length of each random walk\n        workers : int, optional\n            Number of threads (see gensim.differentiable_models.Word2Vec process)\n        window_size : int, optional\n            Window size (see gensim.differentiable_models.Word2Vec)\n        num_neg_samples : int, optional\n            Number of negative samples (see gensim.differentiable_models.Word2Vec)\n        \"\"\"", "\n", "\n", "walks", "=", "sample_random_walks", "(", "adj", ",", "walk_length", ",", "walks_per_node", ")", "\n", "walks", "=", "[", "list", "(", "map", "(", "str", ",", "walk", ")", ")", "for", "walk", "in", "walks", "]", "\n", "self", ".", "model", "=", "Word2Vec", "(", "walks", ",", "size", "=", "embedding_dim", ",", "window", "=", "window_size", ",", "min_count", "=", "0", ",", "sg", "=", "1", ",", "workers", "=", "workers", ",", "\n", "iter", "=", "1", ",", "negative", "=", "num_neg_samples", ",", "hs", "=", "0", ",", "compute_loss", "=", "True", ")", "\n", "self", ".", "embedding", "=", "self", ".", "model", ".", "wv", ".", "vectors", "[", "np", ".", "fromiter", "(", "map", "(", "int", ",", "self", ".", "model", ".", "wv", ".", "index2word", ")", ",", "np", ".", "int32", ")", ".", "argsort", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.DeepWalk.deepwalk_svd": [[241, 280], ["node_embedding.sum_of_powers_of_transition_matrix", "scipy.diags", "adj.sum", "M.copy", "numpy.log", "log_M.toarray.toarray.multiply", "node_embedding.DeepWalk.svd_embedding", "numpy.linalg.norm", "adj.sum", "log_M.toarray.toarray.toarray", "sum_of_powers_of_transition_matrix.dot", "Fu.dot"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sum_of_powers_of_transition_matrix", "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.DeepWalk.svd_embedding"], ["", "def", "deepwalk_svd", "(", "self", ",", "adj", ",", "window_size", "=", "10", ",", "embedding_dim", "=", "64", ",", "num_neg_samples", "=", "1", ",", "sparse", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute DeepWalk embeddings for the given graph using the matrix factorization formulation.\n        adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n            Adjacency matrix of the graph\n        window_size: int\n            Size of the window\n        embedding_dim: int\n            Size of the embedding\n        num_neg_samples: int\n            Number of negative samples\n        sparse: bool\n            Whether to perform sparse operations\n        Returns\n        ------\n        np.ndarray, shape [num_nodes, embedding_dim]\n            Embedding matrix.\n        \"\"\"", "\n", "sum_powers_transition", "=", "sum_of_powers_of_transition_matrix", "(", "adj", ",", "window_size", ")", "\n", "\n", "deg", "=", "adj", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg", "[", "deg", "==", "0", "]", "=", "1", "\n", "deg_matrix", "=", "sp", ".", "diags", "(", "1", "/", "deg", ")", "\n", "\n", "volume", "=", "adj", ".", "sum", "(", ")", "\n", "\n", "M", "=", "sum_powers_transition", ".", "dot", "(", "deg_matrix", ")", "*", "volume", "/", "(", "num_neg_samples", "*", "window_size", ")", "\n", "\n", "log_M", "=", "M", ".", "copy", "(", ")", "\n", "log_M", "[", "M", ">", "1", "]", "=", "np", ".", "log", "(", "log_M", "[", "M", ">", "1", "]", ")", "\n", "log_M", "=", "log_M", ".", "multiply", "(", "M", ">", "1", ")", "\n", "\n", "if", "not", "sparse", ":", "\n", "            ", "log_M", "=", "log_M", ".", "toarray", "(", ")", "\n", "\n", "", "Fu", ",", "Fv", "=", "self", ".", "svd_embedding", "(", "log_M", ",", "embedding_dim", ",", "sparse", ")", "\n", "\n", "loss", "=", "np", ".", "linalg", ".", "norm", "(", "Fu", ".", "dot", "(", "Fv", ".", "T", ")", "-", "log_M", ",", "ord", "=", "'fro'", ")", "\n", "self", ".", "embedding", "=", "Fu", "\n", "return", "Fu", ",", "Fv", ",", "loss", ",", "log_M", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.DeepWalk.svd_embedding": [[281, 301], ["numpy.diag", "scipy.linalg.svds", "numpy.linalg.svd", "U.dot", "numpy.sqrt", "numpy.sqrt().dot", "numpy.sqrt"], "methods", ["None"], ["", "def", "svd_embedding", "(", "self", ",", "x", ",", "embedding_dim", ",", "sparse", "=", "False", ")", ":", "\n", "        ", "\"\"\"Computes an embedding by selection the top (embedding_dim) largest singular-values/vectors.\n        :param x: sp.csr_matrix or np.ndarray\n            The matrix that we want to embed\n        :param embedding_dim: int\n            Dimension of the embedding\n        :param sparse: bool\n            Whether to perform sparse operations\n        :return: np.ndarray, shape [?, embedding_dim], np.ndarray, shape [?, embedding_dim]\n            Embedding matrices.\n        \"\"\"", "\n", "if", "sparse", ":", "\n", "            ", "U", ",", "s", ",", "V", "=", "sp", ".", "linalg", ".", "svds", "(", "x", ",", "embedding_dim", ")", "\n", "", "else", ":", "\n", "            ", "U", ",", "s", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "x", ")", "\n", "\n", "", "S", "=", "np", ".", "diag", "(", "s", ")", "\n", "Fu", "=", "U", ".", "dot", "(", "np", ".", "sqrt", "(", "S", ")", ")", "[", ":", ",", ":", "embedding_dim", "]", "\n", "Fv", "=", "np", ".", "sqrt", "(", "S", ")", ".", "dot", "(", "V", ")", "[", ":", "embedding_dim", ",", ":", "]", ".", "T", "\n", "return", "Fu", ",", "Fv", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sample_random_walks": [[303, 329], ["scipy.csr_matrix", "_random_walk().reshape", "numpy.random.randint", "node_embedding._random_walk"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding._random_walk"], ["", "", "def", "sample_random_walks", "(", "adj", ",", "walk_length", ",", "walks_per_node", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample random walks of fixed length from each node in the graph in parallel.\n    Parameters\n    ----------\n    adj : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Sparse adjacency matrix\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    seed : int or None\n        Random seed\n    Returns\n    -------\n    walks : np.ndarray, shape [num_walks * num_nodes, walk_length]\n        The sampled random walks\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "100000", ")", "\n", "", "adj", "=", "sp", ".", "csr_matrix", "(", "adj", ")", "\n", "random_walks", "=", "_random_walk", "(", "adj", ".", "indptr", ",", "\n", "adj", ".", "indices", ",", "\n", "walk_length", ",", "\n", "walks_per_node", ",", "\n", "seed", ")", ".", "reshape", "(", "[", "-", "1", ",", "walk_length", "]", ")", "\n", "return", "random_walks", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding._random_walk": [[331, 362], ["numba.jit", "numpy.random.seed", "range", "numpy.array", "len", "range", "range", "walks.append", "numpy.random.choice"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "_random_walk", "(", "indptr", ",", "indices", ",", "walk_length", ",", "walks_per_node", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Sample r random walks of length l per node in parallel from the graph.\n    Parameters\n    ----------\n    indptr : array-like\n        Pointer for the edges of each node\n    indices : array-like\n        Edges for each node\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    seed : int\n        Random seed\n    Returns\n    -------\n    walks : array-like, shape [r*N*l]\n        The sampled random walks\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "N", "=", "len", "(", "indptr", ")", "-", "1", "\n", "walks", "=", "[", "]", "\n", "\n", "for", "ir", "in", "range", "(", "walks_per_node", ")", ":", "\n", "        ", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "for", "il", "in", "range", "(", "walk_length", ")", ":", "\n", "                ", "walks", ".", "append", "(", "n", ")", "\n", "n", "=", "np", ".", "random", ".", "choice", "(", "indices", "[", "indptr", "[", "n", "]", ":", "indptr", "[", "n", "+", "1", "]", "]", ")", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "walks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sample_n2v_random_walks": [[363, 395], ["scipy.csr_matrix", "node_embedding._n2v_random_walk", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding._n2v_random_walk"], ["", "def", "sample_n2v_random_walks", "(", "adj", ",", "walk_length", ",", "walks_per_node", ",", "p", ",", "q", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample node2vec random walks of fixed length from each node in the graph in parallel.\n    Parameters\n    ----------\n    adj : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Sparse adjacency matrix\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    p: float\n        The probability to go back\n    q: float,\n        The probability to go explore undiscovered parts of the graphs\n    seed : int or None\n        Random seed\n    Returns\n    -------\n    walks : np.ndarray, shape [num_walks * num_nodes, walk_length]\n        The sampled random walks\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "100000", ")", "\n", "", "adj", "=", "sp", ".", "csr_matrix", "(", "adj", ")", "\n", "random_walks", "=", "_n2v_random_walk", "(", "adj", ".", "indptr", ",", "\n", "adj", ".", "indices", ",", "\n", "walk_length", ",", "\n", "walks_per_node", ",", "\n", "p", ",", "\n", "q", ",", "\n", "seed", ")", "\n", "return", "random_walks", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.random_choice": [[396, 413], ["numba.jit", "numpy.searchsorted", "numpy.cumsum", "numpy.random.random"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "random_choice", "(", "arr", ",", "p", ")", ":", "\n", "    ", "\"\"\"Similar to `numpy.random.choice` and it suppors p=option in numba.\n    refer to <https://github.com/numba/numba/issues/2539#issuecomment-507306369>\n\n    Parameters\n    ----------\n    arr : 1-D array-like\n    p : 1-D array-like\n        The probabilities associated with each entry in arr\n\n    Returns\n    -------\n    samples : ndarray\n        The generated random samples\n    \"\"\"", "\n", "return", "arr", "[", "np", ".", "searchsorted", "(", "np", ".", "cumsum", "(", "p", ")", ",", "np", ".", "random", ".", "random", "(", ")", ",", "side", "=", "\"right\"", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding._n2v_random_walk": [[414, 470], ["numba.jit", "numpy.random.seed", "range", "len", "range", "numpy.empty", "range", "numpy.array", "enumerate", "node_embedding.random_choice", "walk.append", "numpy.any", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.random_choice"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "_n2v_random_walk", "(", "indptr", ",", "\n", "indices", ",", "\n", "walk_length", ",", "\n", "walks_per_node", ",", "\n", "p", ",", "\n", "q", ",", "\n", "seed", ")", ":", "\n", "    ", "\"\"\"Sample r random walks of length l per node in parallel from the graph.\n    Parameters\n    ----------\n    indptr : array-like\n        Pointer for the edges of each node\n    indices : array-like\n        Edges for each node\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    p: float\n        The probability to go back\n    q: float,\n        The probability to go explore undiscovered parts of the graphs\n    seed : int\n        Random seed\n    Returns\n    -------\n    walks : list generator, shape [r, N*l]\n        The sampled random walks\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "N", "=", "len", "(", "indptr", ")", "-", "1", "\n", "for", "_", "in", "range", "(", "walks_per_node", ")", ":", "\n", "        ", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "walk", "=", "[", "n", "]", "\n", "current_node", "=", "n", "\n", "previous_node", "=", "N", "\n", "previous_node_neighbors", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "_", "in", "range", "(", "walk_length", "-", "1", ")", ":", "\n", "                ", "neighbors", "=", "indices", "[", "indptr", "[", "current_node", "]", ":", "indptr", "[", "current_node", "+", "1", "]", "]", "\n", "if", "neighbors", ".", "size", "==", "0", ":", "\n", "                    ", "break", "\n", "\n", "", "probability", "=", "np", ".", "array", "(", "[", "1", "/", "q", "]", "*", "neighbors", ".", "size", ")", "\n", "probability", "[", "previous_node", "==", "neighbors", "]", "=", "1", "/", "p", "\n", "\n", "for", "i", ",", "nbr", "in", "enumerate", "(", "neighbors", ")", ":", "\n", "                    ", "if", "np", ".", "any", "(", "nbr", "==", "previous_node_neighbors", ")", ":", "\n", "                        ", "probability", "[", "i", "]", "=", "1.", "\n", "\n", "", "", "norm_probability", "=", "probability", "/", "np", ".", "sum", "(", "probability", ")", "\n", "current_node", "=", "random_choice", "(", "neighbors", ",", "norm_probability", ")", "\n", "walk", ".", "append", "(", "current_node", ")", "\n", "previous_node_neighbors", "=", "neighbors", "\n", "previous_node", "=", "current_node", "\n", "", "yield", "walk", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.node_embedding.sum_of_powers_of_transition_matrix": [[471, 497], ["scipy.diags().dot", "range", "adj.sum", "last.dot.dot", "scipy.diags"], "function", ["None"], ["", "", "", "def", "sum_of_powers_of_transition_matrix", "(", "adj", ",", "pow", ")", ":", "\n", "    ", "\"\"\"Computes \\sum_{r=1}^{pow) (D^{-1}A)^r.\n\n    Parameters\n    -----\n    adj: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    pow: int\n        Power exponent\n\n    Returns\n    ----\n    sp.csr_matrix\n        Sum of powers of the transition matrix of a graph.\n    \"\"\"", "\n", "deg", "=", "adj", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg", "[", "deg", "==", "0", "]", "=", "1", "\n", "transition_matrix", "=", "sp", ".", "diags", "(", "1", "/", "deg", ")", ".", "dot", "(", "adj", ")", "\n", "\n", "sum_of_powers", "=", "transition_matrix", "\n", "last", "=", "transition_matrix", "\n", "for", "i", "in", "range", "(", "1", ",", "pow", ")", ":", "\n", "        ", "last", "=", "last", ".", "dot", "(", "transition_matrix", ")", "\n", "sum_of_powers", "+=", "last", "\n", "\n", "", "return", "sum_of_powers", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.__init__": [[63, 68], ["deeprobust.graph.defense.GCN.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "weight_decay", "=", "5e-4", ",", "with_relu", "=", "True", ",", "with_bias", "=", "True", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "GCNSVD", ",", "self", ")", ".", "__init__", "(", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", ",", "lr", ",", "weight_decay", ",", "with_relu", ",", "with_bias", ",", "device", "=", "device", ")", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "k", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.fit": [[69, 106], ["gcn_preprocess.GCNSVD.truncatedSVD", "deeprobust.graph.utils.to_tensor", "super().fit"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.truncatedSVD", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "k", "=", "50", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"First perform rank-k approximation of adjacency matrix via\n        truncated SVD, and then train the gcn model on the processed graph,\n        when idx_val is not None, pick the best model according to\n        the validation loss.\n\n        Parameters\n        ----------\n        features :\n            node features\n        adj :\n            the adjacency matrix. The format could be torch.tensor or scipy matrix\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices. If not given (None), GCN training process will not adpot early stopping\n        k : int\n            number of singular values and vectors to compute.\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        \"\"\"", "\n", "\n", "modified_adj", "=", "self", ".", "truncatedSVD", "(", "adj", ",", "k", "=", "k", ")", "\n", "self", ".", "k", "=", "k", "\n", "# modified_adj_tensor = utils.sparse_mx_to_torch_sparse_tensor(self.modified_adj)", "\n", "features", ",", "modified_adj", ",", "labels", "=", "utils", ".", "to_tensor", "(", "features", ",", "modified_adj", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "super", "(", ")", ".", "fit", "(", "features", ",", "modified_adj", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", "=", "train_iters", ",", "initialize", "=", "initialize", ",", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.truncatedSVD": [[107, 138], ["print", "scipy.issparse", "data.asfptype.asfptype.asfptype", "scipy.linalg.svds", "print", "numpy.diag", "numpy.linalg.svd", "print", "numpy.diag", "print", "len", "len", "len", "S.nonzero", "S.nonzero", "numpy.diag.nonzero"], "methods", ["None"], ["", "def", "truncatedSVD", "(", "self", ",", "data", ",", "k", "=", "50", ")", ":", "\n", "        ", "\"\"\"Truncated SVD on input data.\n\n        Parameters\n        ----------\n        data :\n            input matrix to be decomposed\n        k : int\n            number of singular values and vectors to compute.\n\n        Returns\n        -------\n        numpy.array\n            reconstructed matrix.\n        \"\"\"", "\n", "print", "(", "'=== GCN-SVD: rank={} ==='", ".", "format", "(", "k", ")", ")", "\n", "if", "sp", ".", "issparse", "(", "data", ")", ":", "\n", "            ", "data", "=", "data", ".", "asfptype", "(", ")", "\n", "U", ",", "S", ",", "V", "=", "sp", ".", "linalg", ".", "svds", "(", "data", ",", "k", "=", "k", ")", "\n", "print", "(", "\"rank_after = {}\"", ".", "format", "(", "len", "(", "S", ".", "nonzero", "(", ")", "[", "0", "]", ")", ")", ")", "\n", "diag_S", "=", "np", ".", "diag", "(", "S", ")", "\n", "", "else", ":", "\n", "            ", "U", ",", "S", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "data", ")", "\n", "U", "=", "U", "[", ":", ",", ":", "k", "]", "\n", "S", "=", "S", "[", ":", "k", "]", "\n", "V", "=", "V", "[", ":", "k", ",", ":", "]", "\n", "print", "(", "\"rank_before = {}\"", ".", "format", "(", "len", "(", "S", ".", "nonzero", "(", ")", "[", "0", "]", ")", ")", ")", "\n", "diag_S", "=", "np", ".", "diag", "(", "S", ")", "\n", "print", "(", "\"rank_after = {}\"", ".", "format", "(", "len", "(", "diag_S", ".", "nonzero", "(", ")", "[", "0", "]", ")", ")", ")", "\n", "\n", "", "return", "U", "@", "diag_S", "@", "V", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.predict": [[139, 170], ["gcn_preprocess.GCNSVD.eval", "gcn_preprocess.GCNSVD.forward", "gcn_preprocess.GCNSVD.truncatedSVD", "deeprobust.graph.utils.is_sparse_tensor", "gcn_preprocess.GCNSVD.forward", "type", "deeprobust.graph.utils.to_tensor", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNSVD.truncatedSVD", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["", "def", "predict", "(", "self", ",", "features", "=", "None", ",", "adj", "=", "None", ")", ":", "\n", "        ", "\"\"\"By default, the inputs should be unnormalized adjacency\n\n        Parameters\n        ----------\n        features :\n            node features. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n        adj :\n            adjcency matrix. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n\n\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of GCNSVD\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "if", "features", "is", "None", "and", "adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "", "else", ":", "\n", "            ", "adj", "=", "self", ".", "truncatedSVD", "(", "adj", ",", "k", "=", "self", ".", "k", ")", "\n", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "                ", "features", ",", "adj", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "features", "=", "features", "\n", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.__init__": [[220, 225], ["deeprobust.graph.defense.GCN.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "binary_feature", "=", "True", ",", "dropout", "=", "0.5", ",", "lr", "=", "0.01", ",", "weight_decay", "=", "5e-4", ",", "with_relu", "=", "True", ",", "with_bias", "=", "True", ",", "device", "=", "'cpu'", ")", ":", "\n", "\n", "        ", "super", "(", "GCNJaccard", ",", "self", ")", ".", "__init__", "(", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", ",", "lr", ",", "weight_decay", ",", "with_relu", ",", "with_bias", ",", "device", "=", "device", ")", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "binary_feature", "=", "binary_feature", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit": [[226, 262], ["gcn_preprocess.GCNJaccard.drop_dissimilar_edges", "deeprobust.graph.utils.to_tensor", "super().fit"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.drop_dissimilar_edges", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.fit"], ["", "def", "fit", "(", "self", ",", "features", ",", "adj", ",", "labels", ",", "idx_train", ",", "idx_val", "=", "None", ",", "threshold", "=", "0.01", ",", "train_iters", "=", "200", ",", "initialize", "=", "True", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"First drop dissimilar edges with similarity smaller than given\n        threshold and then train the gcn model on the processed graph.\n        When idx_val is not None, pick the best model according to the\n        validation loss.\n\n        Parameters\n        ----------\n        features :\n            node features. The format can be numpy.array or scipy matrix\n        adj :\n            the adjacency matrix.\n        labels :\n            node labels\n        idx_train :\n            node training indices\n        idx_val :\n            node validation indices. If not given (None), GCN training process will not adpot early stopping\n        threshold : float\n            similarity threshold for dropping edges. If two connected nodes with similarity smaller than threshold, the edge between them will be removed.\n        train_iters : int\n            number of training epochs\n        initialize : bool\n            whether to initialize parameters before training\n        verbose : bool\n            whether to show verbose logs\n        \"\"\"", "\n", "\n", "self", ".", "threshold", "=", "threshold", "\n", "modified_adj", "=", "self", ".", "drop_dissimilar_edges", "(", "features", ",", "adj", ")", "\n", "# modified_adj_tensor = utils.sparse_mx_to_torch_sparse_tensor(self.modified_adj)", "\n", "features", ",", "modified_adj", ",", "labels", "=", "utils", ".", "to_tensor", "(", "features", ",", "modified_adj", ",", "labels", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "modified_adj", "=", "modified_adj", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "labels", "=", "labels", "\n", "super", "(", ")", ".", "fit", "(", "features", ",", "modified_adj", ",", "labels", ",", "idx_train", ",", "idx_val", ",", "train_iters", "=", "train_iters", ",", "initialize", "=", "initialize", ",", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.drop_dissimilar_edges": [[263, 284], ["scipy.triu", "scipy.issparse", "print", "scipy.issparse", "scipy.csr_matrix", "gcn_preprocess.dropedge_dis", "scipy.triu.transpose", "features.todense", "gcn_preprocess.dropedge_jaccard", "gcn_preprocess.dropedge_cosine"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_dis", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_jaccard", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_cosine"], ["", "def", "drop_dissimilar_edges", "(", "self", ",", "features", ",", "adj", ",", "metric", "=", "'similarity'", ")", ":", "\n", "        ", "\"\"\"Drop dissimilar edges.(Faster version using numba)\n        \"\"\"", "\n", "if", "not", "sp", ".", "issparse", "(", "adj", ")", ":", "\n", "            ", "adj", "=", "sp", ".", "csr_matrix", "(", "adj", ")", "\n", "\n", "", "adj_triu", "=", "sp", ".", "triu", "(", "adj", ",", "format", "=", "'csr'", ")", "\n", "\n", "if", "sp", ".", "issparse", "(", "features", ")", ":", "\n", "            ", "features", "=", "features", ".", "todense", "(", ")", ".", "A", "# make it easier for njit processing", "\n", "\n", "", "if", "metric", "==", "'distance'", ":", "\n", "            ", "removed_cnt", "=", "dropedge_dis", "(", "adj_triu", ".", "data", ",", "adj_triu", ".", "indptr", ",", "adj_triu", ".", "indices", ",", "features", ",", "threshold", "=", "self", ".", "threshold", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "binary_feature", ":", "\n", "                ", "removed_cnt", "=", "dropedge_jaccard", "(", "adj_triu", ".", "data", ",", "adj_triu", ".", "indptr", ",", "adj_triu", ".", "indices", ",", "features", ",", "threshold", "=", "self", ".", "threshold", ")", "\n", "", "else", ":", "\n", "                ", "removed_cnt", "=", "dropedge_cosine", "(", "adj_triu", ".", "data", ",", "adj_triu", ".", "indptr", ",", "adj_triu", ".", "indices", ",", "features", ",", "threshold", "=", "self", ".", "threshold", ")", "\n", "", "", "print", "(", "'removed %s edges in the original graph'", "%", "removed_cnt", ")", "\n", "modified_adj", "=", "adj_triu", "+", "adj_triu", ".", "transpose", "(", ")", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.predict": [[285, 316], ["gcn_preprocess.GCNJaccard.eval", "gcn_preprocess.GCNJaccard.forward", "gcn_preprocess.GCNJaccard.drop_dissimilar_edges", "deeprobust.graph.utils.is_sparse_tensor", "gcn_preprocess.GCNJaccard.forward", "type", "deeprobust.graph.utils.to_tensor", "deeprobust.graph.utils.normalize_adj_tensor", "deeprobust.graph.utils.normalize_adj_tensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard.drop_dissimilar_edges", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.is_sparse_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.to_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor", "home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["", "def", "predict", "(", "self", ",", "features", "=", "None", ",", "adj", "=", "None", ")", ":", "\n", "        ", "\"\"\"By default, the inputs should be unnormalized adjacency\n\n        Parameters\n        ----------\n        features :\n            node features. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n        adj :\n            adjcency matrix. If `features` and `adj` are not given, this function will use previous stored `features` and `adj` from training to make predictions.\n\n\n        Returns\n        -------\n        torch.FloatTensor\n            output (log probabilities) of GCNJaccard\n        \"\"\"", "\n", "\n", "self", ".", "eval", "(", ")", "\n", "if", "features", "is", "None", "and", "adj", "is", "None", ":", "\n", "            ", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "", "else", ":", "\n", "            ", "adj", "=", "self", ".", "drop_dissimilar_edges", "(", "features", ",", "adj", ")", "\n", "if", "type", "(", "adj", ")", "is", "not", "torch", ".", "Tensor", ":", "\n", "                ", "features", ",", "adj", "=", "utils", ".", "to_tensor", "(", "features", ",", "adj", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "features", "=", "features", "\n", "if", "utils", ".", "is_sparse_tensor", "(", "adj", ")", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "adj_norm", "=", "utils", ".", "normalize_adj_tensor", "(", "adj", ")", "\n", "", "return", "self", ".", "forward", "(", "self", ".", "features", ",", "self", ".", "adj_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard._drop_dissimilar_edges": [[317, 350], ["scipy.csr_matrix.copy().tolil", "print", "tqdm.tqdm.tqdm", "print", "scipy.issparse", "scipy.csr_matrix", "numpy.array", "scipy.csr_matrix.copy", "sp.csr_matrix.copy().tolil.nonzero", "gcn_preprocess.GCNJaccard._jaccard_similarity", "gcn_preprocess.GCNJaccard._cosine_similarity"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard._jaccard_similarity", "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard._cosine_similarity"], ["", "", "def", "_drop_dissimilar_edges", "(", "self", ",", "features", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Drop dissimilar edges. (Slower version)\n        \"\"\"", "\n", "if", "not", "sp", ".", "issparse", "(", "adj", ")", ":", "\n", "            ", "adj", "=", "sp", ".", "csr_matrix", "(", "adj", ")", "\n", "", "modified_adj", "=", "adj", ".", "copy", "(", ")", ".", "tolil", "(", ")", "\n", "\n", "# preprocessing based on features", "\n", "print", "(", "'=== GCN-Jaccrad ==='", ")", "\n", "edges", "=", "np", ".", "array", "(", "modified_adj", ".", "nonzero", "(", ")", ")", ".", "T", "\n", "removed_cnt", "=", "0", "\n", "for", "edge", "in", "tqdm", "(", "edges", ")", ":", "\n", "            ", "n1", "=", "edge", "[", "0", "]", "\n", "n2", "=", "edge", "[", "1", "]", "\n", "if", "n1", ">", "n2", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "self", ".", "binary_feature", ":", "\n", "                ", "J", "=", "self", ".", "_jaccard_similarity", "(", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", ")", "\n", "\n", "if", "J", "<", "self", ".", "threshold", ":", "\n", "                    ", "modified_adj", "[", "n1", ",", "n2", "]", "=", "0", "\n", "modified_adj", "[", "n2", ",", "n1", "]", "=", "0", "\n", "removed_cnt", "+=", "1", "\n", "", "", "else", ":", "\n", "# For not binary feature, use cosine similarity", "\n", "                ", "C", "=", "self", ".", "_cosine_similarity", "(", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", ")", "\n", "if", "C", "<", "self", ".", "threshold", ":", "\n", "                    ", "modified_adj", "[", "n1", ",", "n2", "]", "=", "0", "\n", "modified_adj", "[", "n2", ",", "n1", "]", "=", "0", "\n", "removed_cnt", "+=", "1", "\n", "", "", "", "print", "(", "'removed %s edges in the original graph'", "%", "removed_cnt", ")", "\n", "return", "modified_adj", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard._jaccard_similarity": [[351, 355], ["a.multiply().count_nonzero", "a.multiply", "a.count_nonzero", "b.count_nonzero"], "methods", ["None"], ["", "def", "_jaccard_similarity", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "intersection", "=", "a", ".", "multiply", "(", "b", ")", ".", "count_nonzero", "(", ")", "\n", "J", "=", "intersection", "*", "1.0", "/", "(", "a", ".", "count_nonzero", "(", ")", "+", "b", ".", "count_nonzero", "(", ")", "-", "intersection", ")", "\n", "return", "J", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.GCNJaccard._cosine_similarity": [[356, 360], ["numpy.sqrt", "numpy.sqrt", "numpy.square().sum", "numpy.square().sum", "numpy.square", "numpy.square"], "methods", ["None"], ["", "def", "_cosine_similarity", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "inner_product", "=", "(", "a", "*", "b", ")", ".", "sum", "(", ")", "\n", "C", "=", "inner_product", "/", "(", "np", ".", "sqrt", "(", "np", ".", "square", "(", "a", ")", ".", "sum", "(", ")", ")", "*", "np", ".", "sqrt", "(", "np", ".", "square", "(", "b", ")", ".", "sum", "(", ")", ")", "+", "1e-10", ")", "\n", "return", "C", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.__dropedge_jaccard": [[361, 379], ["range", "range", "len", "a.multiply().count_nonzero", "a.multiply", "a.count_nonzero", "b.count_nonzero"], "function", ["None"], ["", "", "def", "__dropedge_jaccard", "(", "A", ",", "iA", ",", "jA", ",", "features", ",", "threshold", ")", ":", "\n", "# deprecated: for sparse feature matrix...", "\n", "    ", "removed_cnt", "=", "0", "\n", "for", "row", "in", "range", "(", "len", "(", "iA", ")", "-", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "iA", "[", "row", "]", ",", "iA", "[", "row", "+", "1", "]", ")", ":", "\n", "# print(row, jA[i], A[i])", "\n", "            ", "n1", "=", "row", "\n", "n2", "=", "jA", "[", "i", "]", "\n", "a", ",", "b", "=", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", "\n", "\n", "intersection", "=", "a", ".", "multiply", "(", "b", ")", ".", "count_nonzero", "(", ")", "\n", "J", "=", "intersection", "*", "1.0", "/", "(", "a", ".", "count_nonzero", "(", ")", "+", "b", ".", "count_nonzero", "(", ")", "-", "intersection", ")", "\n", "\n", "if", "J", "<", "threshold", ":", "\n", "                ", "A", "[", "i", "]", "=", "0", "\n", "# A[n2, n1] = 0", "\n", "removed_cnt", "+=", "1", "\n", "", "", "", "return", "removed_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_jaccard": [[380, 397], ["range", "range", "len", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.count_nonzero"], "function", ["None"], ["", "@", "njit", "\n", "def", "dropedge_jaccard", "(", "A", ",", "iA", ",", "jA", ",", "features", ",", "threshold", ")", ":", "\n", "    ", "removed_cnt", "=", "0", "\n", "for", "row", "in", "range", "(", "len", "(", "iA", ")", "-", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "iA", "[", "row", "]", ",", "iA", "[", "row", "+", "1", "]", ")", ":", "\n", "# print(row, jA[i], A[i])", "\n", "            ", "n1", "=", "row", "\n", "n2", "=", "jA", "[", "i", "]", "\n", "a", ",", "b", "=", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", "\n", "intersection", "=", "np", ".", "count_nonzero", "(", "a", "*", "b", ")", "\n", "J", "=", "intersection", "*", "1.0", "/", "(", "np", ".", "count_nonzero", "(", "a", ")", "+", "np", ".", "count_nonzero", "(", "b", ")", "-", "intersection", ")", "\n", "\n", "if", "J", "<", "threshold", ":", "\n", "                ", "A", "[", "i", "]", "=", "0", "\n", "# A[n2, n1] = 0", "\n", "removed_cnt", "+=", "1", "\n", "", "", "", "return", "removed_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_cosine": [[399, 416], ["range", "range", "len", "numpy.sqrt", "numpy.sqrt", "numpy.square().sum", "numpy.square().sum", "numpy.square", "numpy.square"], "function", ["None"], ["", "@", "njit", "\n", "def", "dropedge_cosine", "(", "A", ",", "iA", ",", "jA", ",", "features", ",", "threshold", ")", ":", "\n", "    ", "removed_cnt", "=", "0", "\n", "for", "row", "in", "range", "(", "len", "(", "iA", ")", "-", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "iA", "[", "row", "]", ",", "iA", "[", "row", "+", "1", "]", ")", ":", "\n", "# print(row, jA[i], A[i])", "\n", "            ", "n1", "=", "row", "\n", "n2", "=", "jA", "[", "i", "]", "\n", "a", ",", "b", "=", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", "\n", "inner_product", "=", "(", "a", "*", "b", ")", ".", "sum", "(", ")", "\n", "C", "=", "inner_product", "/", "(", "np", ".", "sqrt", "(", "np", ".", "square", "(", "a", ")", ".", "sum", "(", ")", ")", "*", "np", ".", "sqrt", "(", "np", ".", "square", "(", "b", ")", ".", "sum", "(", ")", ")", "+", "1e-8", ")", "\n", "\n", "if", "C", "<", "threshold", ":", "\n", "                ", "A", "[", "i", "]", "=", "0", "\n", "# A[n2, n1] = 0", "\n", "removed_cnt", "+=", "1", "\n", "", "", "", "return", "removed_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_dis": [[417, 432], ["range", "range", "len", "numpy.linalg.norm"], "function", ["None"], ["", "@", "njit", "\n", "def", "dropedge_dis", "(", "A", ",", "iA", ",", "jA", ",", "features", ",", "threshold", ")", ":", "\n", "    ", "removed_cnt", "=", "0", "\n", "for", "row", "in", "range", "(", "len", "(", "iA", ")", "-", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "iA", "[", "row", "]", ",", "iA", "[", "row", "+", "1", "]", ")", ":", "\n", "# print(row, jA[i], A[i])", "\n", "            ", "n1", "=", "row", "\n", "n2", "=", "jA", "[", "i", "]", "\n", "C", "=", "np", ".", "linalg", ".", "norm", "(", "features", "[", "n1", "]", "-", "features", "[", "n2", "]", ")", "\n", "if", "C", ">", "threshold", ":", "\n", "                ", "A", "[", "i", "]", "=", "0", "\n", "# A[n2, n1] = 0", "\n", "removed_cnt", "+=", "1", "\n", "\n", "", "", "", "return", "removed_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.gcn_preprocess.dropedge_both": [[433, 452], ["range", "range", "len", "numpy.linalg.norm", "numpy.sqrt", "numpy.square().sum", "numpy.square().sum", "numpy.square", "numpy.square"], "function", ["None"], ["", "@", "njit", "\n", "def", "dropedge_both", "(", "A", ",", "iA", ",", "jA", ",", "features", ",", "threshold1", "=", "2.5", ",", "threshold2", "=", "0.01", ")", ":", "\n", "    ", "removed_cnt", "=", "0", "\n", "for", "row", "in", "range", "(", "len", "(", "iA", ")", "-", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "iA", "[", "row", "]", ",", "iA", "[", "row", "+", "1", "]", ")", ":", "\n", "# print(row, jA[i], A[i])", "\n", "            ", "n1", "=", "row", "\n", "n2", "=", "jA", "[", "i", "]", "\n", "C1", "=", "np", ".", "linalg", ".", "norm", "(", "features", "[", "n1", "]", "-", "features", "[", "n2", "]", ")", "\n", "\n", "a", ",", "b", "=", "features", "[", "n1", "]", ",", "features", "[", "n2", "]", "\n", "inner_product", "=", "(", "a", "*", "b", ")", ".", "sum", "(", ")", "\n", "C2", "=", "inner_product", "/", "(", "np", ".", "sqrt", "(", "np", ".", "square", "(", "a", ")", ".", "sum", "(", ")", "+", "np", ".", "square", "(", "b", ")", ".", "sum", "(", ")", ")", "+", "1e-6", ")", "\n", "if", "C1", ">", "threshold1", "or", "threshold2", "<", "0", ":", "\n", "                ", "A", "[", "i", "]", "=", "0", "\n", "# A[n2, n1] = 0", "\n", "removed_cnt", "+=", "1", "\n", "\n", "", "", "", "return", "removed_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.__init__": [[29, 37], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "print"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "print", "(", "'CUDA not availiable, using cpu...'", ")", "\n", "self", ".", "device", "=", "'cpu'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.generate": [[38, 71], ["fgsmtraining.FGSMtraining.parse_params", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "range", "fgsmtraining.FGSMtraining.model.parameters", "print", "fgsmtraining.FGSMtraining.train", "fgsmtraining.FGSMtraining.test", "os.path.isdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "print", "os.mkdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "fgsmtraining.FGSMtraining.model.state_dict", "fgsmtraining.FGSMtraining.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test"], ["", "def", "generate", "(", "self", ",", "train_loader", ",", "test_loader", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"FGSM adversarial training process.\n\n        Parameters\n        ----------\n        train_loader :\n            training data loader\n        test_loader :\n            testing data loader\n        kwargs :\n            kwargs\n        \"\"\"", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "device", "=", "torch", ".", "device", "(", "self", ".", "device", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "lr_train", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "epoch_num", "+", "1", ")", ":", "\n", "\n", "            ", "print", "(", "epoch", ",", "flush", "=", "True", ")", "\n", "self", ".", "train", "(", "self", ".", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "device", ",", "test_loader", ")", "\n", "\n", "if", "(", "self", ".", "save_model", ")", ":", "\n", "                ", "if", "os", ".", "path", ".", "isdir", "(", "'./'", "+", "self", ".", "save_dir", ")", ":", "\n", "                    ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'./'", "+", "self", ".", "save_dir", "+", "\"/\"", "+", "self", ".", "save_name", ")", "\n", "print", "(", "\"model saved in \"", "+", "'./'", "+", "self", ".", "save_dir", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\"make new directory and save model in \"", "+", "'./'", "+", "self", ".", "save_dir", ")", "\n", "os", ".", "mkdir", "(", "'./'", "+", "self", ".", "save_dir", ")", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'./'", "+", "self", ".", "save_dir", "+", "\"/\"", "+", "self", ".", "save_name", ")", "\n", "\n", "", "", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.parse_params": [[72, 106], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "save_dir", "=", "\"defense_models\"", ",", "\n", "save_model", "=", "True", ",", "\n", "save_name", "=", "\"mnist_fgsmtraining_0.2.pt\"", ",", "\n", "epsilon", "=", "0.2", ",", "\n", "epoch_num", "=", "50", ",", "\n", "lr_train", "=", "0.005", ",", "\n", "momentum", "=", "0.1", ")", ":", "\n", "        ", "\"\"\"parse_params.\n\n        Parameters\n        ----------\n        save_dir :\n            dir\n        save_model :\n            Whether to save model\n        save_name :\n            model name\n        epsilon :\n            attack perturbation constraint\n        epoch_num :\n            number of training epoch\n        lr_train :\n            training learning rate\n        momentum :\n            momentum for optimizor\n        \"\"\"", "\n", "self", ".", "save_model", "=", "True", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_name", "=", "save_name", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "epoch_num", "=", "epoch_num", "\n", "self", ".", "lr_train", "=", "lr_train", "\n", "self", ".", "momentum", "=", "momentum", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.train": [[107, 148], ["fgsmtraining.FGSMtraining.model.train", "enumerate", "optimizer.zero_grad", "fgsmtraining.FGSMtraining.adv_data", "fgsmtraining.FGSMtraining.calculate_loss", "fgsmtraining.FGSMtraining.backward", "optimizer.step", "output.argmax", "output.argmax.eq().sum().item", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "fgsmtraining.FGSMtraining.item", "output.argmax.eq", "len", "len", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        training process.\n\n        Parameters\n        ----------\n        device :\n            device\n        train_loader :\n            training data loader\n        optimizer :\n            optimizer\n        epoch :\n            training epoch\n        \"\"\"", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "data_adv", ",", "output", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ")", "\n", "\n", "loss", "=", "self", ".", "calculate_loss", "(", "output", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "10", "*", "bs", ")", ")", ")", "\n", "correct", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.test": [[150, 195], ["model.eval", "len", "len", "print", "print", "model", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "model.argmax", "model.argmax.eq().sum().item", "fgsmtraining.FGSMtraining.adv_data", "fgsmtraining.FGSMtraining.calculate_loss().item", "output_adv.argmax", "output_adv.argmax.eq().sum().item", "data.to", "target.to", "len", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "model.argmax.eq().sum", "fgsmtraining.FGSMtraining.calculate_loss", "output_adv.argmax.eq().sum", "len", "len", "model.argmax.eq", "output_adv.argmax.eq", "target.view_as", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss"], ["", "", "", "def", "test", "(", "self", ",", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "        ", "\"\"\"\n        testing process.\n\n        Parameters\n        ----------\n        model :\n            model\n        device :\n            device\n        test_loader :\n            testing dataloder\n        \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "test_loss_adv", "=", "0", "\n", "correct_adv", "=", "0", "\n", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "# print clean accuracy", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "# print adversarial accuracy", "\n", "data_adv", ",", "output_adv", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ")", "\n", "\n", "test_loss_adv", "+=", "self", ".", "calculate_loss", "(", "output_adv", ",", "target", ",", "redmode", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred_adv", "=", "output_adv", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct_adv", "+=", "pred_adv", ".", "eq", "(", "target", ".", "view_as", "(", "pred_adv", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "test_loss_adv", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Clean loss: {:.3f}, Clean Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n", "print", "(", "'\\nTest set: Adv loss: {:.3f}, Adv Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss_adv", ",", "correct_adv", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct_adv", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.adv_data": [[196, 219], ["deeprobust.image.attack.fgsm.FGSM", "deeprobust.image.attack.fgsm.FGSM.generate", "fgsmtraining.FGSMtraining.model", "fgsmtraining.FGSMtraining.flatten"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate"], ["", "def", "adv_data", "(", "self", ",", "data", ",", "output", ",", "ep", "=", "0.3", ",", "num_steps", "=", "40", ")", ":", "\n", "        ", "\"\"\"Generate adversarial data for training.\n\n        Parameters\n        ----------\n        data :\n            data\n        output :\n            output\n        ep :\n            epsilon, perturbation budget.\n        num_steps :\n            iteration steps\n        \"\"\"", "\n", "# \"\"\"", "\n", "# Generate input(adversarial) data for training.", "\n", "\n", "# \"\"\"", "\n", "adversary", "=", "FGSM", "(", "self", ".", "model", ")", "\n", "data_adv", "=", "adversary", ".", "generate", "(", "data", ",", "output", ".", "flatten", "(", ")", ",", "epsilon", "=", "ep", ")", "\n", "output", "=", "self", ".", "model", "(", "data_adv", ")", "\n", "\n", "return", "data_adv", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fgsmtraining.FGSMtraining.calculate_loss": [[220, 227], ["torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy"], "methods", ["None"], ["", "def", "calculate_loss", "(", "self", ",", "output", ",", "target", ",", "redmode", "=", "'mean'", ")", ":", "\n", "        ", "\"\"\"\n        Calculate loss for training.\n        \"\"\"", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "redmode", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.LIDclassifier.train": [[14, 54], ["LIDclassifier..model.train", "enumerate", "optimizer.zero_grad", "LIDclassifier..adv_data", "LIDclassifier..calculate_loss", "LIDclassifier..backward", "optimizer.step", "output.argmax", "output.argmax.eq().sum().item", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "LIDclassifier..item", "output.argmax.eq", "len", "len", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"train process.\n\n    Parameters\n    ----------\n    device :\n        device(option:'cpu', 'cuda')\n    train_loader :\n        train data loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "        ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "data_adv", ",", "output", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ",", "num_steps", "=", "self", ".", "num_steps", ")", "\n", "\n", "loss", "=", "self", ".", "calculate_loss", "(", "output", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "10", "*", "bs", ")", ")", ")", "\n", "", "correct", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.LIDclassifier.get_lid": [[55, 136], ["len", "print", "int", "tqdm", "np.asarray", "np.asarray", "np.asarray", "np.concatenate", "merge_and_generate_labels", "K.function", "np.minimum", "np.zeros", "np.zeros", "np.zeros", "enumerate", "np.ceil", "range", "LIDclassifier.get_lid.estimate"], "function", ["None"], ["", "", "def", "get_lid", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "k", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"get_lid.\n\n    Parameters\n    ----------\n    model :\n        model\n    X_test :\n        clean data\n    X_test_noisy :\n        noisy data\n    X_test_adv :\n        adversarial data\n    k :\n        k\n    batch_size :\n        batch_size\n    \"\"\"", "\n", "funcs", "=", "[", "K", ".", "function", "(", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ",", "K", ".", "learning_phase", "(", ")", "]", ",", "[", "out", "]", ")", "\n", "for", "out", "in", "get_layer_wise_activations", "(", "model", ",", "dataset", ")", "]", "\n", "\n", "lid_dim", "=", "len", "(", "funcs", ")", "\n", "print", "(", "\"Number of layers to estimate: \"", ",", "lid_dim", ")", "\n", "\n", "def", "estimate", "(", "i_batch", ")", ":", "\n", "\n", "        ", "start", "=", "i_batch", "*", "batch_size", "\n", "end", "=", "np", ".", "minimum", "(", "len", "(", "X", ")", ",", "(", "i_batch", "+", "1", ")", "*", "batch_size", ")", "\n", "n_feed", "=", "end", "-", "start", "\n", "lid_batch", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "lid_batch_adv", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "lid_batch_noisy", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "\n", "for", "i", ",", "func", "in", "enumerate", "(", "funcs", ")", ":", "\n", "            ", "X_act", "=", "func", "(", "[", "X", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_act", "=", "np", ".", "asarray", "(", "X_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_act: \", X_act.shape)", "\n", "\n", "X_adv_act", "=", "func", "(", "[", "X_adv", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_adv_act", "=", "np", ".", "asarray", "(", "X_adv_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_adv_act: \", X_adv_act.shape)", "\n", "\n", "X_noisy_act", "=", "func", "(", "[", "X_noisy", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_noisy_act", "=", "np", ".", "asarray", "(", "X_noisy_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_noisy_act: \", X_noisy_act.shape)", "\n", "\n", "# random clean samples", "\n", "# Maximum likelihood estimation of local intrinsic dimensionality (LID)", "\n", "lid_batch", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch: \", lid_batch.shape)", "\n", "lid_batch_adv", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_adv_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_adv: \", lid_batch_adv.shape)", "\n", "lid_batch_noisy", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_noisy_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_noisy: \", lid_batch_noisy.shape)", "\n", "\n", "", "return", "lid_batch", ",", "lid_batch_noisy", ",", "lid_batch_adv", "\n", "\n", "", "lids", "=", "[", "]", "\n", "lids_adv", "=", "[", "]", "\n", "lids_noisy", "=", "[", "]", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "X", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "\n", "for", "i_batch", "in", "tqdm", "(", "range", "(", "n_batches", ")", ")", ":", "\n", "\n", "        ", "lid_batch", ",", "lid_batch_noisy", ",", "lid_batch_adv", "=", "estimate", "(", "i_batch", ")", "\n", "lids", ".", "extend", "(", "lid_batch", ")", "\n", "lids_adv", ".", "extend", "(", "lid_batch_adv", ")", "\n", "lids_noisy", ".", "extend", "(", "lid_batch_noisy", ")", "\n", "# print(\"lids: \", lids.shape)", "\n", "# print(\"lids_adv: \", lids_noisy.shape)", "\n", "# print(\"lids_noisy: \", lids_noisy.shape)", "\n", "\n", "", "lids_normal", "=", "np", ".", "asarray", "(", "lids", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "lids_noisy", "=", "np", ".", "asarray", "(", "lids_noisy", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "lids_adv", "=", "np", ".", "asarray", "(", "lids_adv", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "lids_pos", "=", "lids_adv", "\n", "lids_neg", "=", "np", ".", "concatenate", "(", "(", "lids_normal", ",", "lids_noisy", ")", ")", "\n", "artifacts", ",", "labels", "=", "merge_and_generate_labels", "(", "lids_pos", ",", "lids_neg", ")", "\n", "\n", "return", "artifacts", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.__init__": [[12, 15], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.parse_params": [[16, 21], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Parse user defined parameters\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.generate": [[93, 95], ["None"], "methods", ["None"], ["", "def", "generate", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.train": [[38, 51], ["None"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"train.\n\n        Parameters\n        ----------\n        train_loader :\n            training data\n        optimizer :\n            training optimizer\n        epoch :\n            training epoch\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.test": [[52, 61], ["None"], "methods", ["None"], ["", "def", "test", "(", "self", ",", "test_loader", ")", ":", "\n", "        ", "\"\"\"test.\n\n        Parameters\n        ----------\n        test_loader :\n            testing data\n        \"\"\"", "\n", "return", "True", "\n", "", "def", "adv_data", "(", "self", ",", "model", ",", "data", ",", "target", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.adv_data": [[61, 78], ["None"], "methods", ["None"], ["", "def", "adv_data", "(", "self", ",", "model", ",", "data", ",", "target", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Generate adversarial examples for adversarial training.\n        Overide this function to generate customize adv examples.\n\n        Parameters\n        ----------\n        model :\n            victim model\n        data :\n            original data\n        target :\n            target labels\n        kwargs :\n            parameters\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.loss": [[79, 92], ["None"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "output", ",", "target", ")", ":", "\n", "        ", "\"\"\"\n        Calculate training loss. \n        Overide this function to customize loss.\n        \n        Parameters\n        ----------\n        output :\n            model outputs\n        target :\n            true labels\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.base_defense.BaseDefense.save_model": [[96, 101], ["None"], "methods", ["None"], ["", "def", "save_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Save model.\n        \"\"\"", "\n", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.__init__": [[24, 32], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "print", "(", "'CUDA not availiable, using cpu...'", ")", "\n", "self", ".", "device", "=", "'cpu'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.generate": [[33, 58], ["fast.Fast.parse_params", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "range", "fast.Fast.model.parameters", "print", "fast.Fast.train", "fast.Fast.test", "os.path.isdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "print", "os.mkdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "fast.Fast.model.state_dict", "fast.Fast.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test"], ["", "def", "generate", "(", "self", ",", "train_loader", ",", "test_loader", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        FGSM defense process:\n        \"\"\"", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "device", "=", "torch", ".", "device", "(", "self", ".", "device", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "lr_train", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "epoch_num", "+", "1", ")", ":", "\n", "\n", "            ", "print", "(", "epoch", ",", "flush", "=", "True", ")", "\n", "self", ".", "train", "(", "self", ".", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "device", ",", "test_loader", ")", "\n", "\n", "if", "(", "self", ".", "save_model", ")", ":", "\n", "                ", "if", "os", ".", "path", ".", "isdir", "(", "'./'", "+", "self", ".", "save_dir", ")", ":", "\n", "                    ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'./'", "+", "self", ".", "save_dir", "+", "\"/\"", "+", "self", ".", "save_name", ")", "\n", "print", "(", "\"model saved in \"", "+", "'./'", "+", "self", ".", "save_dir", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\"make new directory and save model in \"", "+", "'./'", "+", "self", ".", "save_dir", ")", "\n", "os", ".", "mkdir", "(", "'./'", "+", "self", ".", "save_dir", ")", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'./'", "+", "self", ".", "save_dir", "+", "\"/\"", "+", "self", ".", "save_name", ")", "\n", "\n", "", "", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.parse_params": [[59, 77], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "save_dir", "=", "\"defense_models\"", ",", "\n", "save_model", "=", "True", ",", "\n", "save_name", "=", "\"fast_mnist_fgsmtraining_0.2.pt\"", ",", "\n", "epsilon", "=", "0.2", ",", "\n", "epoch_num", "=", "30", ",", "\n", "lr_train", "=", "0.005", ",", "\n", "momentum", "=", "0.1", ")", ":", "\n", "# \"\"\"", "\n", "# Set parameters for fast training.", "\n", "# \"\"\"", "\n", "        ", "self", ".", "save_model", "=", "True", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_name", "=", "save_name", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "epoch_num", "=", "epoch_num", "\n", "self", ".", "lr_train", "=", "lr_train", "\n", "self", ".", "momentum", "=", "momentum", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.train": [[78, 108], ["fast.Fast.model.train", "enumerate", "optimizer.zero_grad", "fast.Fast.adv_data", "fast.Fast.calculate_loss", "fast.Fast.backward", "optimizer.step", "output.argmax", "output.argmax.eq().sum().item", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "fast.Fast.item", "output.argmax.eq", "len", "len", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Training process.\n        \"\"\"", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "data_adv", ",", "output", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ")", "\n", "\n", "loss", "=", "self", ".", "calculate_loss", "(", "output", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "                ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "10", "*", "bs", ")", ")", ")", "\n", "correct", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.test": [[110, 147], ["model.eval", "len", "len", "print", "print", "model", "torch.nll_loss().item", "torch.nll_loss().item", "torch.nll_loss().item", "model.argmax", "model.argmax.eq().sum().item", "fast.Fast.adv_data", "fast.Fast.calculate_loss().item", "output_adv.argmax", "output_adv.argmax.eq().sum().item", "data.to", "target.to", "len", "len", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "model.argmax.eq().sum", "fast.Fast.calculate_loss", "output_adv.argmax.eq().sum", "len", "len", "model.argmax.eq", "output_adv.argmax.eq", "target.view_as", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss"], ["", "", "", "def", "test", "(", "self", ",", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "        ", "\"\"\"\n        Testing process.\n\n        \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "test_loss_adv", "=", "0", "\n", "correct_adv", "=", "0", "\n", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "# print clean accuracy", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "# print adversarial accuracy", "\n", "data_adv", ",", "output_adv", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ")", "\n", "\n", "test_loss_adv", "+=", "self", ".", "calculate_loss", "(", "output_adv", ",", "target", ",", "redmode", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred_adv", "=", "output_adv", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct_adv", "+=", "pred_adv", ".", "eq", "(", "target", ".", "view_as", "(", "pred_adv", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "test_loss_adv", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Clean loss: {:.3f}, Clean Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n", "print", "(", "'\\nTest set: Adv loss: {:.3f}, Adv Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss_adv", ",", "correct_adv", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct_adv", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.adv_data": [[148, 161], ["torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "torch.zeros_like().uniform_().to", "deeprobust.image.attack.fgsm.FGSM", "deeprobust.image.attack.fgsm.FGSM.generate", "fast.Fast.model", "fast.Fast.flatten", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like().uniform_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate"], ["", "def", "adv_data", "(", "self", ",", "data", ",", "output", ",", "ep", "=", "0.3", ",", "num_steps", "=", "40", ")", ":", "\n", "# \"\"\"", "\n", "# Generate input(adversarial) data for training.", "\n", "\n", "# \"\"\"", "\n", "        ", "delta", "=", "torch", ".", "zeros_like", "(", "data", ")", ".", "uniform_", "(", "-", "ep", ",", "ep", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "data", "=", "delta", "+", "data", "\n", "\n", "adversary", "=", "FGSM", "(", "self", ".", "model", ")", "\n", "data_adv", "=", "adversary", ".", "generate", "(", "data", ",", "output", ".", "flatten", "(", ")", ",", "epsilon", "=", "ep", ")", "\n", "output", "=", "self", ".", "model", "(", "data_adv", ")", "\n", "\n", "return", "data_adv", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.fast.Fast.calculate_loss": [[162, 169], ["torch.nll_loss", "torch.nll_loss", "torch.nll_loss"], "methods", ["None"], ["", "def", "calculate_loss", "(", "self", ",", "output", ",", "target", ",", "redmode", "=", "'mean'", ")", ":", "\n", "        ", "\"\"\"\n        Calculate loss for training.\n        \"\"\"", "\n", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "redmode", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.train": [[31, 83], ["logger.info", "model.train", "enumerate", "optimizer.zero_grad", "TherEncoding.Thermometer", "encoding.permute.permute", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "encoding.permute.permute", "model", "torch.nll_loss", "F.nll_loss.backward", "optimizer.step", "model.argmax", "output.argmax.eq().sum().item", "input", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "F.nll_loss.item", "output.argmax.eq", "len", "len", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.Thermometer", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"training process.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    train_loader :\n        training data loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "logger", ".", "info", "(", "'trainging'", ")", "\n", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "        ", "optimizer", ".", "zero_grad", "(", ")", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "encoding", "=", "Thermometer", "(", "data", ",", "LEVELS", ")", "\n", "encoding", "=", "encoding", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ",", "4", ")", "\n", "encoding", "=", "torch", ".", "flatten", "(", "encoding", ",", "start_dim", "=", "3", ")", "\n", "encoding", "=", "encoding", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "\n", "#print(encoding.size())", "\n", "\n", "#ipdb.set_trace()", "\n", "output", "=", "model", "(", "encoding", ")", "\n", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print(pred,target)", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "10", "*", "bs", ")", ")", ")", "\n", "correct", "=", "0", "\n", "", "a", "=", "input", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.test": [[85, 111], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "TherEncoding.Thermometer", "encoding.permute.permute", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "encoding.permute.permute", "model", "torch.nll_loss().item", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "torch.nll_loss", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.Thermometer", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "encoding", "=", "Thermometer", "(", "data", ",", "LEVELS", ")", "\n", "encoding", "=", "encoding", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ",", "4", ")", "\n", "encoding", "=", "torch", ".", "flatten", "(", "encoding", ",", "start_dim", "=", "3", ")", "\n", "encoding", "=", "encoding", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "\n", "# print clean accuracy", "\n", "output", "=", "model", "(", "encoding", ")", "\n", "test_loss", "+=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Clean loss: {:.3f}, Clean Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.Thermometer": [[112, 124], ["TherEncoding.one_hot", "TherEncoding.one_hot_to_thermometer"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.one_hot", "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.one_hot_to_thermometer"], ["", "def", "Thermometer", "(", "x", ",", "levels", ",", "flattened", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Output\n    ------\n    Thermometer Encoding of the input.\n    \"\"\"", "\n", "\n", "onehot", "=", "one_hot", "(", "x", ",", "levels", ")", "\n", "\n", "thermometer", "=", "one_hot_to_thermometer", "(", "onehot", ",", "levels", ")", "\n", "\n", "return", "thermometer", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.one_hot": [[125, 139], ["torch.ceil().long.size", "torch.ceil().long.unsqueeze_", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.zeros().float().to().scatter_", "torch.zeros().float().to().scatter_", "torch.zeros().float().to().scatter_", "torch.zeros().float().to().scatter_", "torch.ceil", "torch.ceil", "torch.ceil", "torch.ceil", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "one_hot", "(", "x", ",", "levels", ")", ":", "\n", "    ", "\"\"\"\n    Output\n    ------\n    One hot Encoding of the input.\n    \"\"\"", "\n", "\n", "batch_size", ",", "channel", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "x", "=", "x", ".", "unsqueeze_", "(", "4", ")", "\n", "x", "=", "torch", ".", "ceil", "(", "x", "*", "(", "LEVELS", "-", "1", ")", ")", ".", "long", "(", ")", "\n", "onehot", "=", "torch", ".", "zeros", "(", "batch_size", ",", "channel", ",", "H", ",", "W", ",", "levels", ")", ".", "float", "(", ")", ".", "to", "(", "'cuda'", ")", ".", "scatter_", "(", "4", ",", "x", ",", "1", ")", "\n", "#print(onehot)", "\n", "\n", "return", "onehot", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.TherEncoding.one_hot_to_thermometer": [[140, 154], ["torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum"], "function", ["None"], ["", "def", "one_hot_to_thermometer", "(", "x", ",", "levels", ",", "flattened", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Convert One hot Encoding to Thermometer Encoding.\n    \"\"\"", "\n", "\n", "if", "flattened", ":", "\n", "        ", "pass", "\n", "#TODO: check how to flatten", "\n", "\n", "", "thermometer", "=", "torch", ".", "cumsum", "(", "x", ",", "dim", "=", "4", ")", "\n", "\n", "if", "flattened", ":", "\n", "        ", "pass", "\n", "", "return", "thermometer", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.__init__": [[30, 38], ["model.to", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "print"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "print", "(", "'CUDA not available, using cpu...'", ")", "\n", "self", ".", "device", "=", "'cpu'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "\n", "", "self", ".", "model", "=", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.generate": [[39, 79], ["trades.TRADES.parse_params", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "range", "trades.TRADES.model.parameters", "deeprobust.image.utils.adjust_learning_rate", "trades.TRADES.train", "trades.TRADES.test", "os.path.exists", "os.makedirs", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "trades.TRADES.model.state_dict", "os.path.join", "deeprobust.image.utils.adjust_learning_rate.state_dict", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.adjust_learning_rate", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test"], ["", "def", "generate", "(", "self", ",", "train_loader", ",", "test_loader", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"generate robust model.\n\n        Parameters\n        ----------\n        train_loader :\n            train_loader\n        test_loader :\n            test_loader\n        kwargs :\n            kwargs\n        \"\"\"", "\n", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "self", ".", "seed", ")", "\n", "\n", "loader_kwargs", "=", "{", "'num_workers'", ":", "1", ",", "'pin_memory'", ":", "True", "}", "if", "(", "self", ".", "device", "==", "'cuda'", ")", "else", "{", "}", "\n", "\n", "# init model, Net() can be also used here for training", "\n", "optimizer", "=", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "epochs", "+", "1", ")", ":", "\n", "# adjust learning rate for SGD", "\n", "            ", "optimizer", "=", "adjust_learning_rate", "(", "optimizer", ",", "epoch", ",", "self", ".", "lr", ")", "\n", "\n", "# adversarial training", "\n", "self", ".", "train", "(", "self", ".", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "\n", "# evaluation on natural examples", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "device", ",", "test_loader", ")", "\n", "\n", "# save checkpoint", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "save_dir", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "self", ".", "save_dir", ")", "\n", "", "if", "epoch", "%", "self", ".", "save_freq", "==", "0", ":", "\n", "                ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'trade_model-nn-epoch{}.pt'", ".", "format", "(", "epoch", ")", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'opt-nn-checkpoint_epoch{}.tar'", ".", "format", "(", "epoch", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.parse_params": [[80, 120], ["None"], "methods", ["None"], ["", "", "", "def", "parse_params", "(", "self", ",", "\n", "epochs", "=", "100", ",", "\n", "lr", "=", "0.01", ",", "\n", "momentum", "=", "0.9", ",", "\n", "epsilon", "=", "0.3", ",", "\n", "num_steps", "=", "40", ",", "\n", "step_size", "=", "0.01", ",", "\n", "beta", "=", "1.0", ",", "\n", "seed", "=", "1", ",", "\n", "log_interval", "=", "100", ",", "\n", "save_dir", "=", "\"./defense_model\"", ",", "\n", "save_freq", "=", "10", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param epoch : int \n            - pgd training epoch\n        :param save_dir : str \n            - directory path to save model\n        :param epsilon : float \n            - perturb constraint of pgd adversary example used to train defense model\n        :param num_steps : int \n            - the perturb \n        :param perturb_step_size : float \n            - step_size \n        :param lr : float \n            - learning rate for adversary training process\n        :param momentum : float \n            - parameter for optimizer in training process\n        \"\"\"", "\n", "self", ".", "epochs", "=", "epochs", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "step_size", "=", "step_size", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "log_interval", "=", "log_interval", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_freq", "=", "save_freq", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.test": [[121, 140], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "len", "model", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "pred.eq().sum().item", "len", "data.to", "target.to", "model.max", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "pred.eq().sum", "pred.eq", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "test", "(", "self", ",", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "                ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "size_average", "=", "False", ")", ".", "item", "(", ")", "\n", "pred", "=", "output", ".", "max", "(", "1", ",", "keepdim", "=", "True", ")", "[", "1", "]", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "print", "(", "'Test: Clean loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "test_accuracy", "=", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "return", "test_loss", ",", "test_accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.train": [[141, 167], ["trades.TRADES.model.train", "enumerate", "optimizer.zero_grad", "trades.TRADES.trades_loss", "trades.TRADES.backward", "optimizer.step", "data.to", "target.to", "print", "len", "trades.TRADES.item", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.trades_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "self", ".", "device", ")", ",", "target", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# calculate robust loss", "\n", "loss", "=", "self", ".", "trades_loss", "(", "model", "=", "self", ".", "model", ",", "\n", "x_natural", "=", "data", ",", "\n", "y", "=", "target", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "step_size", "=", "self", ".", "step_size", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ",", "\n", "perturb_steps", "=", "self", ".", "num_steps", ",", "\n", "beta", "=", "self", ".", "beta", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# print progress", "\n", "if", "batch_idx", "%", "self", ".", "log_interval", "==", "0", ":", "\n", "                ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.trades.TRADES.trades_loss": [[168, 242], ["torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "model.eval", "len", "model.train", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "optimizer.zero_grad", "model", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "x_natural.detach", "range", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.KLDivLoss.", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.clamp.requires_grad_", "torch.clamp.requires_grad_", "torch.clamp.requires_grad_", "torch.clamp.requires_grad_", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.SGD", "torch.SGD", "torch.SGD", "torch.SGD", "range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.KLDivLoss.", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.clamp.detach", "torch.clamp.detach", "torch.clamp.detach", "torch.clamp.detach", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.randn().cuda().detach", "torch.SGD.zero_grad", "loss.backward", "torch.autograd.Variable.grad.view().norm", "torch.autograd.Variable.grad.view().norm", "torch.autograd.Variable.grad.view().norm", "torch.autograd.Variable.grad.view().norm", "torch.autograd.Variable.grad.div_", "torch.autograd.Variable.grad.div_", "torch.autograd.Variable.grad.div_", "torch.autograd.Variable.grad.div_", "torch.SGD.step", "torch.autograd.Variable.data.add_", "torch.autograd.Variable.data.add_", "torch.autograd.Variable.data.add_", "torch.autograd.Variable.data.add_", "torch.autograd.Variable.data.clamp_().sub_", "torch.autograd.Variable.data.clamp_().sub_", "torch.autograd.Variable.data.clamp_().sub_", "torch.autograd.Variable.data.clamp_().sub_", "torch.autograd.Variable.data.renorm_", "torch.autograd.Variable.data.renorm_", "torch.autograd.Variable.data.renorm_", "torch.autograd.Variable.data.renorm_", "model", "model", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.autograd.Variable.grad.view().norm.view", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "model", "model", "grad.detach", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.KLDivLoss.", "torch.autograd.Variable.grad.view", "torch.autograd.Variable.grad.view", "torch.autograd.Variable.grad.view", "torch.autograd.Variable.grad.view", "torch.autograd.Variable.data.clamp_", "torch.autograd.Variable.data.clamp_", "torch.autograd.Variable.data.clamp_", "torch.autograd.Variable.data.clamp_", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "model", "model"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "", "", "def", "trades_loss", "(", "self", ",", "\n", "model", ",", "\n", "x_natural", ",", "\n", "y", ",", "\n", "optimizer", ",", "\n", "step_size", "=", "0.003", ",", "\n", "epsilon", "=", "0.031", ",", "\n", "perturb_steps", "=", "10", ",", "\n", "beta", "=", "1.0", ",", "\n", "distance", "=", "'l_inf'", ")", ":", "\n", "\n", "# define KL-loss", "\n", "        ", "criterion_kl", "=", "nn", ".", "KLDivLoss", "(", "size_average", "=", "False", ")", "\n", "model", ".", "eval", "(", ")", "\n", "batch_size", "=", "len", "(", "x_natural", ")", "\n", "\n", "# generate adversarial example", "\n", "x_adv", "=", "x_natural", ".", "detach", "(", ")", "+", "0.001", "*", "torch", ".", "randn", "(", "x_natural", ".", "shape", ")", ".", "cuda", "(", ")", ".", "detach", "(", ")", "\n", "\n", "if", "distance", "==", "'l_inf'", ":", "\n", "            ", "for", "_", "in", "range", "(", "perturb_steps", ")", ":", "\n", "                ", "x_adv", ".", "requires_grad_", "(", ")", "\n", "with", "torch", ".", "enable_grad", "(", ")", ":", "\n", "                    ", "loss_kl", "=", "criterion_kl", "(", "F", ".", "log_softmax", "(", "model", "(", "x_adv", ")", ",", "dim", "=", "1", ")", ",", "\n", "F", ".", "softmax", "(", "model", "(", "x_natural", ")", ",", "dim", "=", "1", ")", ")", "\n", "", "grad", "=", "torch", ".", "autograd", ".", "grad", "(", "loss_kl", ",", "[", "x_adv", "]", ")", "[", "0", "]", "\n", "x_adv", "=", "x_adv", ".", "detach", "(", ")", "+", "step_size", "*", "torch", ".", "sign", "(", "grad", ".", "detach", "(", ")", ")", "\n", "x_adv", "=", "torch", ".", "min", "(", "torch", ".", "max", "(", "x_adv", ",", "x_natural", "-", "epsilon", ")", ",", "x_natural", "+", "epsilon", ")", "\n", "x_adv", "=", "torch", ".", "clamp", "(", "x_adv", ",", "0.0", ",", "1.0", ")", "\n", "\n", "", "", "elif", "distance", "==", "'l_2'", ":", "\n", "\n", "            ", "delta", "=", "0.001", "*", "torch", ".", "randn", "(", "x_natural", ".", "shape", ")", ".", "cuda", "(", ")", ".", "detach", "(", ")", "\n", "delta", "=", "Variable", "(", "delta", ".", "data", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# Setup optimizers", "\n", "optimizer_delta", "=", "optim", ".", "SGD", "(", "[", "delta", "]", ",", "lr", "=", "epsilon", "/", "perturb_steps", "*", "2", ")", "\n", "\n", "for", "_", "in", "range", "(", "perturb_steps", ")", ":", "\n", "                ", "adv", "=", "x_natural", "+", "delta", "\n", "\n", "# optimize", "\n", "optimizer_delta", ".", "zero_grad", "(", ")", "\n", "with", "torch", ".", "enable_grad", "(", ")", ":", "\n", "                    ", "loss", "=", "(", "-", "1", ")", "*", "criterion_kl", "(", "F", ".", "log_softmax", "(", "model", "(", "adv", ")", ",", "dim", "=", "1", ")", ",", "\n", "F", ".", "softmax", "(", "model", "(", "x_natural", ")", ",", "dim", "=", "1", ")", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "# renorming gradient", "\n", "grad_norms", "=", "delta", ".", "grad", ".", "view", "(", "batch_size", ",", "-", "1", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "\n", "delta", ".", "grad", ".", "div_", "(", "grad_norms", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "# avoid nan or inf if gradient is 0", "\n", "if", "(", "grad_norms", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "                    ", "delta", ".", "grad", "[", "grad_norms", "==", "0", "]", "=", "torch", ".", "randn_like", "(", "delta", ".", "grad", "[", "grad_norms", "==", "0", "]", ")", "\n", "", "optimizer_delta", ".", "step", "(", ")", "\n", "\n", "# projection", "\n", "delta", ".", "data", ".", "add_", "(", "x_natural", ")", "\n", "delta", ".", "data", ".", "clamp_", "(", "0", ",", "1", ")", ".", "sub_", "(", "x_natural", ")", "\n", "delta", ".", "data", ".", "renorm_", "(", "p", "=", "2", ",", "dim", "=", "0", ",", "maxnorm", "=", "epsilon", ")", "\n", "", "x_adv", "=", "Variable", "(", "x_natural", "+", "delta", ",", "requires_grad", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "x_adv", "=", "torch", ".", "clamp", "(", "x_adv", ",", "0.0", ",", "1.0", ")", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "x_adv", "=", "Variable", "(", "torch", ".", "clamp", "(", "x_adv", ",", "0.0", ",", "1.0", ")", ",", "requires_grad", "=", "False", ")", "\n", "# zero gradient", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "# calculate robust loss", "\n", "logits", "=", "model", "(", "x_natural", ")", "\n", "loss_natural", "=", "F", ".", "cross_entropy", "(", "logits", ",", "y", ")", "\n", "loss_robust", "=", "(", "1.0", "/", "batch_size", ")", "*", "criterion_kl", "(", "F", ".", "log_softmax", "(", "model", "(", "x_adv", ")", ",", "dim", "=", "1", ")", ",", "\n", "F", ".", "softmax", "(", "model", "(", "x_natural", ")", ",", "dim", "=", "1", ")", ")", "\n", "loss", "=", "loss_natural", "+", "beta", "*", "loss_robust", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.__init__": [[30, 38], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "print"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "print", "(", "'CUDA not availiable, using cpu...'", ")", "\n", "self", ".", "device", "=", "'cpu'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.generate": [[39, 76], ["pgdtraining.PGDtraining.parse_params", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "range", "pgdtraining.PGDtraining.model.parameters", "print", "pgdtraining.PGDtraining.train", "pgdtraining.PGDtraining.test", "torch.optim.lr_scheduler.MultiStepLR.step", "torch.optim.lr_scheduler.MultiStepLR.step", "torch.optim.lr_scheduler.MultiStepLR.step", "torch.optim.lr_scheduler.MultiStepLR.step", "os.path.isdir", "str", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "print", "os.mkdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "pgdtraining.PGDtraining.model.state_dict", "pgdtraining.PGDtraining.model.state_dict", "str", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "def", "generate", "(", "self", ",", "train_loader", ",", "test_loader", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call this function to generate robust model.\n\n        Parameters\n        ----------\n        train_loader :\n            training data loader\n        test_loader :\n            testing data loader\n        kwargs :\n            kwargs\n        \"\"\"", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "device", "=", "torch", ".", "device", "(", "self", ".", "device", ")", "\n", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "lr", ")", "\n", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "milestones", "=", "[", "75", ",", "100", "]", ",", "gamma", "=", "0.1", ")", "\n", "save_model", "=", "True", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "epoch", "+", "1", ")", ":", "\n", "            ", "print", "(", "'Training epoch: '", ",", "epoch", ",", "flush", "=", "True", ")", "\n", "self", ".", "train", "(", "self", ".", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "device", ",", "test_loader", ")", "\n", "\n", "if", "(", "self", ".", "save_model", "and", "epoch", "%", "self", ".", "save_per_epoch", "==", "0", ")", ":", "\n", "                ", "if", "os", ".", "path", ".", "isdir", "(", "str", "(", "self", ".", "save_dir", ")", ")", ":", "\n", "                    ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "str", "(", "self", ".", "save_dir", ")", "+", "self", ".", "save_name", "+", "'_epoch'", "+", "str", "(", "epoch", ")", "+", "'.pth'", ")", "\n", "print", "(", "\"model saved in \"", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\"make new directory and save model in \"", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "os", ".", "mkdir", "(", "'./'", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "str", "(", "self", ".", "save_dir", ")", "+", "self", ".", "save_name", "+", "'_epoch'", "+", "str", "(", "epoch", ")", "+", "'.pth'", ")", "\n", "\n", "", "", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.parse_params": [[77, 121], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "epoch_num", "=", "100", ",", "\n", "save_dir", "=", "\"./defense_models\"", ",", "\n", "save_name", "=", "\"mnist_pgdtraining_0.3\"", ",", "\n", "save_model", "=", "True", ",", "\n", "epsilon", "=", "8.0", "/", "255.0", ",", "\n", "num_steps", "=", "10", ",", "\n", "perturb_step_size", "=", "0.01", ",", "\n", "lr", "=", "0.1", ",", "\n", "momentum", "=", "0.1", ",", "\n", "save_per_epoch", "=", "10", ")", ":", "\n", "        ", "\"\"\"Parameter parser.\n\n        Parameters\n        ----------\n        epoch_num : int\n            epoch\n        save_dir : str\n            model dir\n        save_name : str\n            model name\n        save_model : bool\n            Whether to save model\n        epsilon : float\n            attack constraint\n        num_steps : int\n            PGD attack iteration time\n        perturb_step_size : float\n            perturb step size\n        lr : float\n            learning rate for adversary training process\n        momentum : float\n            momentum for optimizor\n        \"\"\"", "\n", "self", ".", "epoch", "=", "epoch_num", "\n", "self", ".", "save_model", "=", "True", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_name", "=", "save_name", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "perturb_step_size", "=", "perturb_step_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "save_per_epoch", "=", "save_per_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.train": [[122, 166], ["pgdtraining.PGDtraining.model.train", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "enumerate", "optimizer.zero_grad", "pgdtraining.PGDtraining.adv_data", "pgdtraining.PGDtraining.calculate_loss", "pgdtraining.PGDtraining.backward", "optimizer.step", "output.argmax", "output.argmax.eq().sum().item", "torch.lr_scheduler.MultiStepLR.step", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "pgdtraining.PGDtraining.item", "output.argmax.eq", "len", "len", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        training process.\n\n        Parameters\n        ----------\n        device :\n            device\n        train_loader :\n            training data loader\n        optimizer :\n            optimizer\n        epoch :\n            training epoch\n        \"\"\"", "\n", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "#scheduler = StepLR(optimizer, step_size = 10, gamma = 0.5)", "\n", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "milestones", "=", "[", "70", "]", ",", "gamma", "=", "0.1", ")", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "data_adv", ",", "output", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ",", "num_steps", "=", "self", ".", "num_steps", ",", "perturb_step_size", "=", "self", ".", "perturb_step_size", ")", "\n", "loss", "=", "self", ".", "calculate_loss", "(", "output", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "20", "==", "0", ":", "\n", "                ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "bs", ")", ")", ")", "\n", "", "correct", "=", "0", "\n", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.test": [[168, 213], ["model.eval", "len", "len", "print", "print", "model", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "model.argmax", "model.argmax.eq().sum().item", "pgdtraining.PGDtraining.adv_data", "pgdtraining.PGDtraining.calculate_loss().item", "output_adv.argmax", "output_adv.argmax.eq().sum().item", "data.to", "target.to", "len", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "model.argmax.eq().sum", "pgdtraining.PGDtraining.calculate_loss", "output_adv.argmax.eq().sum", "len", "len", "model.argmax.eq", "output_adv.argmax.eq", "target.view_as", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss"], ["", "", "def", "test", "(", "self", ",", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "        ", "\"\"\"\n        testing process.\n\n        Parameters\n        ----------\n        model :\n            model\n        device :\n            device\n        test_loader :\n            testing dataloder\n        \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "test_loss_adv", "=", "0", "\n", "correct_adv", "=", "0", "\n", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "# print clean accuracy", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "# print adversarial accuracy", "\n", "data_adv", ",", "output_adv", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ",", "num_steps", "=", "self", ".", "num_steps", ")", "\n", "\n", "test_loss_adv", "+=", "self", ".", "calculate_loss", "(", "output_adv", ",", "target", ",", "redmode", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred_adv", "=", "output_adv", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct_adv", "+=", "pred_adv", ".", "eq", "(", "target", ".", "view_as", "(", "pred_adv", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "test_loss_adv", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Clean loss: {:.3f}, Clean Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n", "print", "(", "'\\nTest set: Adv loss: {:.3f}, Adv Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss_adv", ",", "correct_adv", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct_adv", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.adv_data": [[214, 224], ["deeprobust.image.attack.pgd.PGD", "deeprobust.image.attack.pgd.PGD.generate", "pgdtraining.PGDtraining.model", "pgdtraining.PGDtraining.flatten"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate"], ["", "def", "adv_data", "(", "self", ",", "data", ",", "output", ",", "ep", "=", "0.3", ",", "num_steps", "=", "10", ",", "perturb_step_size", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"\n        Generate input(adversarial) data for training.\n        \"\"\"", "\n", "\n", "adversary", "=", "PGD", "(", "self", ".", "model", ")", "\n", "data_adv", "=", "adversary", ".", "generate", "(", "data", ",", "output", ".", "flatten", "(", ")", ",", "epsilon", "=", "ep", ",", "num_steps", "=", "num_steps", ",", "step_size", "=", "perturb_step_size", ")", "\n", "output", "=", "self", ".", "model", "(", "data_adv", ")", "\n", "\n", "return", "data_adv", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.pgdtraining.PGDtraining.calculate_loss": [[225, 232], ["torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy"], "methods", ["None"], ["", "def", "calculate_loss", "(", "self", ",", "output", ",", "target", ",", "redmode", "=", "'mean'", ")", ":", "\n", "        ", "\"\"\"\n        Calculate loss for training.\n        \"\"\"", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "redmode", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.PieceWiseConstantLrSchedulerMaker.__init__": [[38, 41], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "milestones", ":", "List", "[", "int", "]", ",", "gamma", ":", "float", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.PieceWiseConstantLrSchedulerMaker.__call__": [[42, 44], ["torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "optimizer", ")", ":", "\n", "        ", "return", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "milestones", "=", "self", ".", "milestones", ",", "gamma", "=", "self", ".", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.IPGDAttackMethodMaker.__init__": [[48, 55], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "eps", ",", "sigma", ",", "nb_iters", ",", "norm", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "eps", "=", "eps", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "nb_iters", "=", "nb_iters", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.IPGDAttackMethodMaker.__call__": [[56, 58], ["deeprobust.image.attack.YOPOpgd.FASTPGD"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "DEVICE", ")", ":", "\n", "        ", "return", "YOPOpgd", ".", "FASTPGD", "(", "self", ".", "eps", ",", "self", ".", "sigma", ",", "self", ".", "nb_iters", ",", "self", ".", "norm", ",", "DEVICE", ",", "self", ".", "mean", ",", "self", ".", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.__init__": [[85, 88], ["YOPO.AvgMeter.reset"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.reset"], ["def", "__init__", "(", "self", ",", "name", "=", "'No name'", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.reset": [[89, 94], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "sum", "=", "0", "\n", "self", ".", "mean", "=", "0", "\n", "self", ".", "num", "=", "0", "\n", "self", ".", "now", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.update": [[95, 104], ["math.isnan", "print", "float"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "mean_var", ",", "count", "=", "1", ")", ":", "\n", "        ", "if", "math", ".", "isnan", "(", "mean_var", ")", ":", "\n", "            ", "mean_var", "=", "1e6", "\n", "print", "(", "'Avgmeter getting Nan!'", ")", "\n", "", "self", ".", "now", "=", "mean_var", "\n", "self", ".", "num", "+=", "count", "\n", "\n", "self", ".", "sum", "+=", "mean_var", "*", "count", "\n", "self", ".", "mean", "=", "float", "(", "self", ".", "sum", ")", "/", "self", ".", "num", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.Hamiltonian.__init__": [[142, 146], ["torch.nn.modules.loss._Loss.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "layer", ",", "reg_cof", "=", "1e-4", ")", ":", "\n", "        ", "super", "(", "Hamiltonian", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layer", "=", "layer", "\n", "self", ".", "reg_cof", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.Hamiltonian.forward": [[147, 151], ["YOPO.Hamiltonian.layer", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "p", ")", ":", "\n", "        ", "y", "=", "self", ".", "layer", "(", "x", ")", "\n", "H", "=", "torch", ".", "sum", "(", "y", "*", "p", ")", "\n", "return", "H", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.CrossEntropyWithWeightPenlty.__init__": [[153, 159], ["torch.nn.modules.loss._Loss.__init__", "torch.CrossEntropyLoss().to", "torch.CrossEntropyLoss().to", "torch.CrossEntropyLoss().to", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["    ", "def", "__init__", "(", "self", ",", "module", ",", "DEVICE", ",", "reg_cof", "=", "1e-4", ")", ":", "\n", "        ", "super", "(", "CrossEntropyWithWeightPenlty", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "reg_cof", "=", "reg_cof", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", ".", "to", "(", "DEVICE", ")", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.CrossEntropyWithWeightPenlty.__call__": [[160, 166], ["YOPO.CrossEntropyWithWeightPenlty.criterion", "YOPO.cal_l2_norm"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.cal_l2_norm"], ["", "def", "__call__", "(", "self", ",", "pred", ",", "label", ")", ":", "\n", "        ", "cross_loss", "=", "self", ".", "criterion", "(", "pred", ",", "label", ")", "\n", "weight_loss", "=", "cal_l2_norm", "(", "self", ".", "module", ")", "\n", "\n", "loss", "=", "cross_loss", "+", "self", ".", "reg_cof", "*", "weight_loss", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.__init__": [[177, 184], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "Hamiltonian_func", ",", "param_optimizer", ",", "\n", "inner_steps", "=", "2", ",", "sigma", "=", "0.008", ",", "eps", "=", "0.03", ")", ":", "\n", "        ", "self", ".", "inner_steps", "=", "inner_steps", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "Hamiltonian_func", "=", "Hamiltonian_func", "\n", "self", ".", "param_optimizer", "=", "param_optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step": [[185, 215], ["p.detach.detach.detach", "range", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "loss.backward", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "YOPO.FastGradientLayerOneTrainer.Hamiltonian_func", "[].sign", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "eta.detach.detach.detach", "eta.detach.detach.requires_grad_", "eta.detach.detach.retain_grad", "YOPO.FastGradientLayerOneTrainer.Hamiltonian_func", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "inp", ",", "p", ",", "eta", ")", ":", "\n", "        ", "p", "=", "p", ".", "detach", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "            ", "tmp_inp", "=", "inp", "+", "eta", "\n", "tmp_inp", "=", "torch", ".", "clamp", "(", "tmp_inp", ",", "0", ",", "1", ")", "\n", "H", "=", "self", ".", "Hamiltonian_func", "(", "tmp_inp", ",", "p", ")", "\n", "\n", "eta_grad_sign", "=", "torch", ".", "autograd", ".", "grad", "(", "H", ",", "eta", ",", "only_inputs", "=", "True", ",", "retain_graph", "=", "False", ")", "[", "0", "]", ".", "sign", "(", ")", "\n", "\n", "eta", "=", "eta", "-", "eta_grad_sign", "*", "self", ".", "sigma", "\n", "\n", "eta", "=", "torch", ".", "clamp", "(", "eta", ",", "-", "1.0", "*", "self", ".", "eps", ",", "self", ".", "eps", ")", "\n", "eta", "=", "torch", ".", "clamp", "(", "inp", "+", "eta", ",", "0.0", ",", "1.0", ")", "-", "inp", "\n", "eta", "=", "eta", ".", "detach", "(", ")", "\n", "eta", ".", "requires_grad_", "(", ")", "\n", "eta", ".", "retain_grad", "(", ")", "\n", "\n", "#self.param_optimizer.zero_grad()", "\n", "\n", "", "yofo_inp", "=", "eta", "+", "inp", "\n", "yofo_inp", "=", "torch", ".", "clamp", "(", "yofo_inp", ",", "0", ",", "1", ")", "\n", "\n", "loss", "=", "-", "1.0", "*", "self", ".", "Hamiltonian_func", "(", "yofo_inp", ",", "p", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "#self.param_optimizer.step()", "\n", "#self.param_optimizer.zero_grad()", "\n", "\n", "return", "yofo_inp", ",", "eta", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.SGDOptimizerMaker.__init__": [[252, 256], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lr", "=", "0.1", ",", "momentum", "=", "0.9", ",", "weight_decay", "=", "1e-4", ")", ":", "\n", "        ", "self", ".", "lr", "=", "lr", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.SGDOptimizerMaker.__call__": [[257, 259], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "params", ")", ":", "\n", "        ", "return", "torch", ".", "optim", ".", "SGD", "(", "params", ",", "lr", "=", "self", ".", "lr", ",", "momentum", "=", "self", ".", "momentum", ",", "weight_decay", "=", "self", ".", "weight_decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.torch_accuracy": [[59, 81], ["max", "output.size", "output.topk", "pred.t.t", "pred.t.eq", "target.view().expand_as", "is_correct[].view().float().sum", "ans.append", "is_correct[].view().float().sum.mul_", "target.view", "is_correct[].view().float", "is_correct[].view"], "function", ["None"], ["", "", "def", "torch_accuracy", "(", "output", ",", "target", ",", "topk", "=", "(", "1", ",", ")", ")", "->", "List", "[", "torch", ".", "Tensor", "]", ":", "\n", "    ", "'''\n    param output, target: should be torch Variable\n    '''", "\n", "# assert isinstance(output, torch.cuda.Tensor), 'expecting Torch Tensor'", "\n", "# assert isinstance(target, torch.Tensor), 'expecting Torch Tensor'", "\n", "# print(type(output))", "\n", "\n", "topn", "=", "max", "(", "topk", ")", "\n", "batch_size", "=", "output", ".", "size", "(", "0", ")", "\n", "\n", "_", ",", "pred", "=", "output", ".", "topk", "(", "topn", ",", "1", ",", "True", ",", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "\n", "is_correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred", ")", ")", "\n", "\n", "ans", "=", "[", "]", "\n", "for", "i", "in", "topk", ":", "\n", "        ", "is_correct_i", "=", "is_correct", "[", ":", "i", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "ans", ".", "append", "(", "is_correct_i", ".", "mul_", "(", "100.0", "/", "batch_size", ")", ")", "\n", "\n", "", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.load_checkpoint": [[105, 122], ["os.path.isfile", "print", "torch.load", "torch.load", "torch.load", "print", "print", "net.load_state_dict", "print", "optimizer.load_state_dict", "print", "lr_scheduler.load_state_dict"], "function", ["None"], ["", "", "def", "load_checkpoint", "(", "file_name", ",", "net", "=", "None", ",", "optimizer", "=", "None", ",", "lr_scheduler", "=", "None", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "        ", "print", "(", "\"=> loading checkpoint '{}'\"", ".", "format", "(", "file_name", ")", ")", "\n", "check_point", "=", "torch", ".", "load", "(", "file_name", ")", "\n", "if", "net", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Loading network state dict'", ")", "\n", "net", ".", "load_state_dict", "(", "check_point", "[", "'state_dict'", "]", ")", "\n", "", "if", "optimizer", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Loading optimizer state dict'", ")", "\n", "optimizer", ".", "load_state_dict", "(", "check_point", "[", "'optimizer_state_dict'", "]", ")", "\n", "", "if", "lr_scheduler", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Loading lr_scheduler state dict'", ")", "\n", "lr_scheduler", ".", "load_state_dict", "(", "check_point", "[", "'lr_scheduler_state_dict'", "]", ")", "\n", "\n", "", "return", "check_point", "[", "'epoch'", "]", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"=> no checkpoint found at '{}'\"", ".", "format", "(", "file_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.make_symlink": [[124, 133], ["os.path.exists", "os.path.exists", "os.remove", "os.symlink", "print"], "function", ["None"], ["", "", "def", "make_symlink", "(", "source", ",", "link_name", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "link_name", ")", ":", "\n", "#print(\"Link name already exist! Removing '{}' and overwriting\".format(link_name))", "\n", "        ", "os", ".", "remove", "(", "link_name", ")", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "source", ")", ":", "\n", "        ", "os", ".", "symlink", "(", "source", ",", "link_name", ")", "\n", "return", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Source path not exists'", ")", "\n", "#print('SymLink Wrong!')", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.add_path": [[135, 139], ["print", "sys.path.append"], "function", ["None"], ["", "", "def", "add_path", "(", "path", ")", ":", "\n", "    ", "if", "path", "not", "in", "sys", ".", "path", ":", "\n", "        ", "print", "(", "'Adding {}'", ".", "format", "(", "path", ")", ")", "\n", "sys", ".", "path", ".", "append", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.cal_l2_norm": [[167, 174], ["layer.named_parameters", "torch.norm", "torch.norm", "torch.norm"], "function", ["None"], ["", "", "def", "cal_l2_norm", "(", "layer", ":", "torch", ".", "nn", ".", "Module", ")", ":", "\n", " ", "loss", "=", "0.", "\n", "for", "name", ",", "param", "in", "layer", ".", "named_parameters", "(", ")", ":", "\n", "     ", "if", "name", "==", "'weight'", ":", "\n", "         ", "loss", "=", "loss", "+", "0.5", "*", "torch", ".", "norm", "(", "param", ",", ")", "**", "2", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.eval_one_epoch": [[216, 248], ["torch.device", "torch.device", "torch.device", "net.eval", "tqdm.tqdm", "YOPO.AvgMeter", "YOPO.AvgMeter", "tqdm.tqdm.set_description", "data.to.to", "label.to.to", "collections.OrderedDict", "tqdm.tqdm.set_postfix", "torch.no_grad", "torch.no_grad", "torch.no_grad", "net", "YOPO.torch_accuracy", "YOPO.AvgMeter.update", "AttackMethod.attack", "acc[].item", "torch.no_grad", "torch.no_grad", "torch.no_grad", "net", "YOPO.torch_accuracy", "YOPO.AvgMeter.update", "acc[].item"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.torch_accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.update", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.torch_accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.AvgMeter.update"], ["", "", "def", "eval_one_epoch", "(", "net", ",", "batch_generator", ",", "DEVICE", "=", "torch", ".", "device", "(", "'cuda:0'", ")", ",", "AttackMethod", "=", "None", ")", ":", "\n", "    ", "net", ".", "eval", "(", ")", "\n", "pbar", "=", "tqdm", "(", "batch_generator", ")", "\n", "clean_accuracy", "=", "AvgMeter", "(", ")", "\n", "adv_accuracy", "=", "AvgMeter", "(", ")", "\n", "\n", "pbar", ".", "set_description", "(", "'Evaluating'", ")", "\n", "for", "(", "data", ",", "label", ")", "in", "pbar", ":", "\n", "        ", "data", "=", "data", ".", "to", "(", "DEVICE", ")", "\n", "label", "=", "label", ".", "to", "(", "DEVICE", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "pred", "=", "net", "(", "data", ")", "\n", "acc", "=", "torch_accuracy", "(", "pred", ",", "label", ",", "(", "1", ",", ")", ")", "\n", "clean_accuracy", ".", "update", "(", "acc", "[", "0", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "if", "AttackMethod", "is", "not", "None", ":", "\n", "            ", "adv_inp", "=", "AttackMethod", ".", "attack", "(", "net", ",", "data", ",", "label", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "pred", "=", "net", "(", "adv_inp", ")", "\n", "acc", "=", "torch_accuracy", "(", "pred", ",", "label", ",", "(", "1", ",", ")", ")", "\n", "adv_accuracy", ".", "update", "(", "acc", "[", "0", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "", "pbar_dic", "=", "OrderedDict", "(", ")", "\n", "pbar_dic", "[", "'CleanAcc'", "]", "=", "'{:.2f}'", ".", "format", "(", "clean_accuracy", ".", "mean", ")", "\n", "pbar_dic", "[", "'AdvAcc'", "]", "=", "'{:.2f}'", ".", "format", "(", "adv_accuracy", ".", "mean", ")", "\n", "\n", "pbar", ".", "set_postfix", "(", "pbar_dic", ")", "\n", "\n", "adv_acc", "=", "adv_accuracy", ".", "mean", "if", "AttackMethod", "is", "not", "None", "else", "0", "\n", "", "return", "clean_accuracy", ".", "mean", ",", "adv_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.main": [[260, 346], ["YOPO.SGDOptimizerMaker", "YOPO.PieceWiseConstantLrSchedulerMaker", "YOPO.IPGDAttackMethodMaker", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "torch.device", "torch.device", "torch.device", "deeprobust.image.netmodels.YOPOCNN.Net", "YOPOCNN.Net.to", "YOPO.CrossEntropyWithWeightPenlty", "SGDOptimizerMaker.", "PieceWiseConstantLrSchedulerMaker.", "YOPO.Hamiltonian", "torch.optim.SGD", "torch.optim.lr_scheduler.MultiStepLR", "YOPO.FastGradientLayerOneTrainer", "deeprobust.image.utils.create_train_dataset", "deeprobust.image.utils.create_test_dataset", "IPGDAttackMethodMaker.", "YOPOCNN.Net.other_layers.parameters", "YOPOCNN.Net.layer_one.parameters", "os.path.join", "os.path.isfile", "YOPO.load_checkpoint", "time.time", "YOPO.train_one_epoch", "print", "create_lr_scheduler.step", "optim.lr_scheduler.MultiStepLR.step", "deeprobust.image.utils.save_checkpoint", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "create_lr_scheduler.get_lr", "create_lr_scheduler.get_lr", "time.time", "os.path.join", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.create_train_dataset", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.create_test_dataset", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.load_checkpoint", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.train_one_epoch", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.save_checkpoint"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "num_epochs", "=", "40", "\n", "val_interval", "=", "1", "\n", "weight_decay", "=", "5e-4", "\n", "\n", "inner_iters", "=", "10", "\n", "K", "=", "5", "\n", "sigma", "=", "0.01", "\n", "eps", "=", "0.3", "\n", "lr", "=", "1e-2", "\n", "momentum", "=", "0.9", "\n", "create_optimizer", "=", "SGDOptimizerMaker", "(", "lr", "=", "1e-2", "/", "K", ",", "momentum", "=", "0.9", ",", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "create_lr_scheduler", "=", "PieceWiseConstantLrSchedulerMaker", "(", "milestones", "=", "[", "30", ",", "35", ",", "39", "]", ",", "gamma", "=", "0.1", ")", "\n", "\n", "create_loss_function", "=", "None", "\n", "\n", "create_attack_method", "=", "None", "\n", "\n", "create_evaluation_attack_method", "=", "IPGDAttackMethodMaker", "(", "eps", "=", "0.3", ",", "sigma", "=", "0.01", ",", "nb_iters", "=", "40", ",", "norm", "=", "np", ".", "inf", ",", "\n", "mean", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ")", ",", "\n", "std", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "[", "1", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ")", ")", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--model_dir'", ",", "default", "=", "\"./trained_models\"", ")", "\n", "parser", ".", "add_argument", "(", "'--resume'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "metavar", "=", "'PATH'", ",", "\n", "help", "=", "'path to latest checkpoint (default: none)'", ")", "\n", "parser", ".", "add_argument", "(", "'-b'", ",", "'--batch_size'", ",", "default", "=", "256", ",", "type", "=", "int", ",", "\n", "metavar", "=", "'N'", ",", "help", "=", "'mini-batch size'", ")", "\n", "parser", ".", "add_argument", "(", "'-d'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'Which gpu to use'", ")", "\n", "parser", ".", "add_argument", "(", "'-adv_coef'", ",", "default", "=", "1.0", ",", "type", "=", "float", ",", "\n", "help", "=", "'Specify the weight for adversarial loss'", ")", "\n", "parser", ".", "add_argument", "(", "'--auto-continue'", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Continue from the latest checkpoint'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "DEVICE", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "\n", "net", "=", "YOPOCNN", ".", "Net", "(", ")", "\n", "net", ".", "to", "(", "DEVICE", ")", "\n", "criterion", "=", "CrossEntropyWithWeightPenlty", "(", "net", ".", "other_layers", ",", "DEVICE", ",", "weight_decay", ")", "#.to(DEVICE)", "\n", "optimizer", "=", "create_optimizer", "(", "net", ".", "other_layers", ".", "parameters", "(", ")", ")", "\n", "lr_scheduler", "=", "create_lr_scheduler", "(", "optimizer", ")", "\n", "\n", "Hamiltonian_func", "=", "Hamiltonian", "(", "net", ".", "layer_one", ",", "weight_decay", ")", "\n", "layer_one_optimizer", "=", "optim", ".", "SGD", "(", "net", ".", "layer_one", ".", "parameters", "(", ")", ",", "lr", "=", "lr_scheduler", ".", "get_lr", "(", ")", "[", "0", "]", ",", "momentum", "=", "0.9", ",", "weight_decay", "=", "5e-4", ")", "\n", "lyaer_one_optimizer_lr_scheduler", "=", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "layer_one_optimizer", ",", "\n", "milestones", "=", "[", "15", ",", "19", "]", ",", "gamma", "=", "0.1", ")", "\n", "LayerOneTrainer", "=", "FastGradientLayerOneTrainer", "(", "Hamiltonian_func", ",", "layer_one_optimizer", ",", "\n", "inner_iters", ",", "sigma", ",", "eps", ")", "\n", "\n", "ds_train", "=", "utils", ".", "create_train_dataset", "(", "args", ".", "batch_size", ")", "\n", "ds_val", "=", "utils", ".", "create_test_dataset", "(", "args", ".", "batch_size", ")", "\n", "\n", "EvalAttack", "=", "create_evaluation_attack_method", "(", "DEVICE", ")", "\n", "\n", "now_epoch", "=", "0", "\n", "\n", "if", "args", ".", "auto_continue", ":", "\n", "        ", "args", ".", "resume", "=", "os", ".", "path", ".", "join", "(", "args", ".", "model_dir", ",", "'last.checkpoint'", ")", "\n", "", "if", "args", ".", "resume", "is", "not", "None", "and", "os", ".", "path", ".", "isfile", "(", "args", ".", "resume", ")", ":", "\n", "        ", "now_epoch", "=", "load_checkpoint", "(", "args", ".", "resume", ",", "net", ",", "optimizer", ",", "lr_scheduler", ")", "\n", "\n", "", "now_train_time", "=", "0", "\n", "while", "True", ":", "\n", "        ", "if", "now_epoch", ">", "num_epochs", ":", "\n", "            ", "break", "\n", "", "now_epoch", "=", "now_epoch", "+", "1", "\n", "\n", "descrip_str", "=", "'Training epoch:{}/{} -- lr:{}'", ".", "format", "(", "now_epoch", ",", "num_epochs", ",", "\n", "lr_scheduler", ".", "get_lr", "(", ")", "[", "0", "]", ")", "\n", "s_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "#train", "\n", "acc", ",", "yopoacc", "=", "train_one_epoch", "(", "net", ",", "ds_train", ",", "optimizer", ",", "eps", ",", "criterion", ",", "LayerOneTrainer", ",", "K", ",", "\n", "DEVICE", ",", "descrip_str", ")", "\n", "\n", "now_train_time", "=", "now_train_time", "+", "time", ".", "time", "(", ")", "-", "s_time", "\n", "tb_train_dic", "=", "{", "'Acc'", ":", "acc", ",", "'YoPoAcc'", ":", "yopoacc", "}", "\n", "print", "(", "tb_train_dic", ")", "\n", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "lyaer_one_optimizer_lr_scheduler", ".", "step", "(", ")", "\n", "utils", ".", "save_checkpoint", "(", "now_epoch", ",", "net", ",", "optimizer", ",", "lr_scheduler", ",", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "args", ".", "model_dir", ",", "'epoch-{}.checkpoint'", ".", "format", "(", "now_epoch", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.train_one_epoch": [[347, 408], ["torch.device", "torch.device", "torch.device", "net.train", "tqdm.tqdm", "tqdm.tqdm.set_description", "enumerate", "data.to.to", "label.to.to", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "eta.to.to", "eta.to.requires_grad_", "optimizer.zero_grad", "LayerOneTrainner.param_optimizer.zero_grad", "range", "optimizer.step", "LayerOneTrainner.param_optimizer.step", "optimizer.zero_grad", "LayerOneTrainner.param_optimizer.zero_grad", "tqdm.tqdm.set_postfix", "collections.OrderedDict", "net", "criterion", "TotalLoss.backward", "LayerOneTrainner.step", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.no_grad", "torch.no_grad", "torch.no_grad", "eta.to.detach", "YOPO.torch_accuracy", "acc[].item", "criterion.item", "net", "[].item", "YOPO.torch_accuracy"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.torch_accuracy", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.torch_accuracy"], ["", "", "def", "train_one_epoch", "(", "net", ",", "batch_generator", ",", "optimizer", ",", "eps", ",", "\n", "criterion", ",", "LayerOneTrainner", ",", "K", ",", "\n", "DEVICE", "=", "torch", ".", "device", "(", "'cuda:0'", ")", ",", "descrip_str", "=", "'Training'", ")", ":", "\n", "    ", "'''\n    :param attack_freq:  Frequencies of training with adversarial examples. -1 indicates natural training\n    :param AttackMethod: the attack method, None represents natural training\n    :return:  None    #(clean_acc, adv_acc)\n    '''", "\n", "net", ".", "train", "(", ")", "\n", "pbar", "=", "tqdm", "(", "batch_generator", ")", "\n", "yofoacc", "=", "-", "1", "\n", "cleanacc", "=", "-", "1", "\n", "cleanloss", "=", "-", "1", "\n", "pbar", ".", "set_description", "(", "descrip_str", ")", "\n", "for", "i", ",", "(", "data", ",", "label", ")", "in", "enumerate", "(", "pbar", ")", ":", "\n", "        ", "data", "=", "data", ".", "to", "(", "DEVICE", ")", "\n", "label", "=", "label", ".", "to", "(", "DEVICE", ")", "\n", "\n", "eta", "=", "torch", ".", "FloatTensor", "(", "*", "data", ".", "shape", ")", ".", "uniform_", "(", "-", "eps", ",", "eps", ")", "\n", "eta", "=", "eta", ".", "to", "(", "label", ".", "device", ")", "\n", "eta", ".", "requires_grad_", "(", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "LayerOneTrainner", ".", "param_optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "K", ")", ":", "\n", "            ", "pbar_dic", "=", "OrderedDict", "(", ")", "\n", "TotalLoss", "=", "0", "\n", "\n", "pred", "=", "net", "(", "data", "+", "eta", ".", "detach", "(", ")", ")", "\n", "\n", "loss", "=", "criterion", "(", "pred", ",", "label", ")", "\n", "TotalLoss", "=", "TotalLoss", "+", "loss", "\n", "wgrad", "=", "net", ".", "conv1", ".", "weight", ".", "grad", "\n", "TotalLoss", ".", "backward", "(", ")", "\n", "net", ".", "conv1", ".", "weight", ".", "grad", "=", "wgrad", "\n", "\n", "\n", "p", "=", "-", "1.0", "*", "net", ".", "layer_one_out", ".", "grad", "\n", "yofo_inp", ",", "eta", "=", "LayerOneTrainner", ".", "step", "(", "data", ",", "p", ",", "eta", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "if", "j", "==", "0", ":", "\n", "                    ", "acc", "=", "torch_accuracy", "(", "pred", ",", "label", ",", "(", "1", ",", ")", ")", "\n", "cleanacc", "=", "acc", "[", "0", "]", ".", "item", "(", ")", "\n", "cleanloss", "=", "loss", ".", "item", "(", ")", "\n", "\n", "", "if", "j", "==", "K", "-", "1", ":", "\n", "                    ", "yofo_pred", "=", "net", "(", "yofo_inp", ")", "\n", "yofoacc", "=", "torch_accuracy", "(", "yofo_pred", ",", "label", ",", "(", "1", ",", ")", ")", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "", "", "", "optimizer", ".", "step", "(", ")", "\n", "LayerOneTrainner", ".", "param_optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "LayerOneTrainner", ".", "param_optimizer", ".", "zero_grad", "(", ")", "\n", "pbar_dic", "[", "'Acc'", "]", "=", "'{:.2f}'", ".", "format", "(", "cleanacc", ")", "\n", "pbar_dic", "[", "'loss'", "]", "=", "'{:.2f}'", ".", "format", "(", "cleanloss", ")", "\n", "pbar_dic", "[", "'YoPoAcc'", "]", "=", "'{:.2f}'", ".", "format", "(", "yofoacc", ")", "\n", "pbar", ".", "set_postfix", "(", "pbar_dic", ")", "\n", "\n", "", "return", "cleanacc", ",", "yofoacc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.__init__": [[45, 51], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "proxy", ",", "proxy_optim", ",", "gamma", ")", ":", "\n", "        ", "super", "(", "pgd_AWP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "proxy", "=", "proxy", "\n", "self", ".", "proxy_optim", "=", "proxy_optim", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.calc_awp": [[52, 76], ["AWP.pgd_AWP.proxy.load_state_dict", "AWP.pgd_AWP.proxy.train", "AWP.pgd_AWP.proxy", "AWP.pgd_AWP.proxy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "AWP.pgd_AWP.proxy_optim.zero_grad", "torch.cross_entropy.backward", "AWP.pgd_AWP.proxy_optim.step", "AWP.diff_in_weights", "AWP.pgd_AWP.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.diff_in_weights"], ["", "def", "calc_awp", "(", "self", ",", "adv_samples", ",", "clean_samples", ",", "labels", ",", "weight", ",", "weight1", ",", "temp", ",", "adv_connect", ",", "adv_upweight", ")", ":", "\n", "        ", "self", ".", "proxy", ".", "load_state_dict", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "self", ".", "proxy", ".", "train", "(", ")", "\n", "\n", "# compute adv loss", "\n", "logits_clean", ",", "features_clean", "=", "self", ".", "proxy", "(", "clean_samples", ",", "feat", "=", "True", ")", "\n", "#loss_clean = F.cross_entropy(logits_clean, labels)", "\n", "\n", "# compute adv loss", "\n", "logits_adv", ",", "features_adv", "=", "self", ".", "proxy", "(", "adv_samples", ",", "feat", "=", "True", ")", "\n", "#loss_adv = F.cross_entropy(logits_adv, labels)", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits_adv", ",", "labels", ")", "\n", "\n", "# final loss", "\n", "loss", "=", "-", "1", "*", "loss", "\n", "\n", "self", ".", "proxy_optim", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "proxy_optim", ".", "step", "(", ")", "\n", "\n", "# the adversary weight perturb", "\n", "diff", "=", "diff_in_weights", "(", "self", ".", "model", ",", "self", ".", "proxy", ")", "\n", "return", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.perturb": [[77, 79], ["AWP.add_into_weights"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.add_into_weights"], ["", "def", "perturb", "(", "self", ",", "diff", ")", ":", "\n", "        ", "add_into_weights", "(", "self", ".", "model", ",", "diff", ",", "coeff", "=", "1.0", "*", "self", ".", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.restore": [[80, 82], ["AWP.add_into_weights"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.add_into_weights"], ["", "def", "restore", "(", "self", ",", "diff", ")", ":", "\n", "        ", "add_into_weights", "(", "self", ".", "model", ",", "diff", ",", "coeff", "=", "-", "1.0", "*", "self", ".", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.__init__": [[91, 99], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "print"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "print", "(", "'CUDA not availiable, using cpu...'", ")", "\n", "self", ".", "device", "=", "'cpu'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.generate": [[100, 138], ["AWP.AWP_AT.parse_params", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "range", "AWP.AWP_AT.model.parameters", "print", "AWP.AWP_AT.train", "AWP.AWP_AT.test", "scheduler.step", "os.path.isdir", "str", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "print", "os.mkdir", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "AWP.AWP_AT.model.state_dict", "AWP.AWP_AT.model.state_dict", "str", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step"], ["", "def", "generate", "(", "self", ",", "train_loader", ",", "test_loader", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Call this function to generate robust model.\n\n        Parameters\n        ----------\n        train_loader :\n            training data loader\n        test_loader :\n            testing data loader\n        kwargs :\n            kwargs\n        \"\"\"", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "device", "=", "torch", ".", "device", "(", "self", ".", "device", ")", "\n", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "lr", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "milestones", "=", "[", "75", ",", "100", "]", ",", "gamma", "=", "0.1", ")", "\n", "save_model", "=", "True", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "epoch", "+", "1", ")", ":", "\n", "            ", "print", "(", "'Training epoch: '", ",", "epoch", ",", "flush", "=", "True", ")", "\n", "\n", "self", ".", "train", "(", "self", ".", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "device", ",", "test_loader", ")", "\n", "\n", "if", "(", "self", ".", "save_model", "and", "epoch", "%", "self", ".", "save_per_epoch", "==", "0", ")", ":", "\n", "                ", "if", "os", ".", "path", ".", "isdir", "(", "str", "(", "self", ".", "save_dir", ")", ")", ":", "\n", "                    ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "str", "(", "self", ".", "save_dir", ")", "+", "self", ".", "save_name", "+", "'_epoch'", "+", "str", "(", "epoch", ")", "+", "'.pth'", ")", "\n", "print", "(", "\"model saved in \"", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\"make new directory and save model in \"", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "os", ".", "mkdir", "(", "'./'", "+", "str", "(", "self", ".", "save_dir", ")", ")", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "str", "(", "self", ".", "save_dir", ")", "+", "self", ".", "save_name", "+", "'_epoch'", "+", "str", "(", "epoch", ")", "+", "'.pth'", ")", "\n", "\n", "", "", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.parse_params": [[139, 183], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "epoch_num", "=", "100", ",", "\n", "save_dir", "=", "\"./defense_models\"", ",", "\n", "save_name", "=", "\"AWP_pgdtraining_0.3\"", ",", "\n", "save_model", "=", "True", ",", "\n", "epsilon", "=", "8.0", "/", "255.0", ",", "\n", "num_steps", "=", "10", ",", "\n", "perturb_step_size", "=", "0.01", ",", "\n", "lr", "=", "0.1", ",", "\n", "momentum", "=", "0.1", ",", "\n", "save_per_epoch", "=", "10", ")", ":", "\n", "        ", "\"\"\"Parameter parser.\n\n        Parameters\n        ----------\n        epoch_num : int\n            epoch\n        save_dir : str\n            model dir\n        save_name : str\n            model name\n        save_model : bool\n            Whether to save model\n        epsilon : float\n            attack constraint\n        num_steps : int\n            PGD attack iteration time\n        perturb_step_size : float\n            perturb step size\n        lr : float\n            learning rate for adversary training process\n        momentum : float\n            momentum for optimizor\n        \"\"\"", "\n", "self", ".", "epoch", "=", "epoch_num", "\n", "self", ".", "save_model", "=", "True", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_name", "=", "save_name", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "perturb_step_size", "=", "perturb_step_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "save_per_epoch", "=", "save_per_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.train": [[184, 235], ["AWP.AWP_AT.model.train", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "torch.lr_scheduler.MultiStepLR", "AWP.pgd_AWP", "enumerate", "optimizer.zero_grad", "AWP.AWP_AT.adv_data", "pgd_AWP.calc_awp", "pgd_AWP.perturb", "AWP.AWP_AT.calculate_loss", "AWP.AWP_AT.backward", "optimizer.step", "output.argmax", "output.argmax.eq().sum().item", "torch.lr_scheduler.MultiStepLR.step", "data.to", "target.to", "print", "output.argmax.eq().sum", "len", "AWP.AWP_AT.item", "output.argmax.eq", "len", "len", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.calc_awp", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.pgd_AWP.perturb", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "self", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        training process.\n\n        Parameters\n        ----------\n        device :\n            device\n        train_loader :\n            training data loader\n        optimizer :\n            optimizer\n        epoch :\n            training epoch\n        \"\"\"", "\n", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "correct", "=", "0", "\n", "bs", "=", "train_loader", ".", "batch_size", "\n", "#scheduler = StepLR(optimizer, step_size = 10, gamma = 0.5)", "\n", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "milestones", "=", "[", "70", "]", ",", "gamma", "=", "0.1", ")", "\n", "awp_adversary", "=", "pgd_AWP", "(", "model", "=", "self", ".", "model", ",", "proxy", "=", "proxy", ",", "proxy_optim", "=", "proxy_optim", ",", "gamma", "=", "opt", ".", "awp_gamma", ")", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "data_adv", ",", "output", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ",", "num_steps", "=", "self", ".", "num_steps", ",", "perturb_step_size", "=", "self", ".", "perturb_step_size", ")", "\n", "\n", "awp", "=", "awp_adversary", ".", "calc_awp", "(", "adv_samples", "=", "adv_samples", ",", "clean_samples", "=", "clean_samples", ",", "labels", "=", "labels", ",", "weight", "=", "opt", ".", "weight", ",", "weight1", "=", "opt", ".", "weight1", ",", "temp", "=", "opt", ".", "temp", ",", "adv_connect", "=", "opt", ".", "adv_connect", ",", "adv_upweight", "=", "opt", ".", "adv_upweight", ")", "\n", "awp_adversary", ".", "perturb", "(", "awp", ")", "\n", "\n", "\n", "loss", "=", "self", ".", "calculate_loss", "(", "output", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "20", "==", "0", ":", "\n", "                ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\\tAccuracy:{:.2f}%'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ",", "100", "*", "correct", "/", "(", "bs", ")", ")", ")", "\n", "", "correct", "=", "0", "\n", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.test": [[237, 282], ["model.eval", "len", "len", "print", "print", "model", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "torch.cross_entropy().item", "model.argmax", "model.argmax.eq().sum().item", "AWP.AWP_AT.adv_data", "AWP.AWP_AT.calculate_loss().item", "output_adv.argmax", "output_adv.argmax.eq().sum().item", "data.to", "target.to", "len", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "model.argmax.eq().sum", "AWP.AWP_AT.calculate_loss", "output_adv.argmax.eq().sum", "len", "len", "model.argmax.eq", "output_adv.argmax.eq", "target.view_as", "target.view_as"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss"], ["", "", "def", "test", "(", "self", ",", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "        ", "\"\"\"\n        testing process.\n\n        Parameters\n        ----------\n        model :\n            model\n        device :\n            device\n        test_loader :\n            testing dataloder\n        \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "test_loss_adv", "=", "0", "\n", "correct_adv", "=", "0", "\n", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "\n", "# print clean accuracy", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "# print adversarial accuracy", "\n", "data_adv", ",", "output_adv", "=", "self", ".", "adv_data", "(", "data", ",", "target", ",", "ep", "=", "self", ".", "epsilon", ",", "num_steps", "=", "self", ".", "num_steps", ")", "\n", "\n", "test_loss_adv", "+=", "self", ".", "calculate_loss", "(", "output_adv", ",", "target", ",", "redmode", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred_adv", "=", "output_adv", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct_adv", "+=", "pred_adv", ".", "eq", "(", "target", ".", "view_as", "(", "pred_adv", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "test_loss_adv", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Clean loss: {:.3f}, Clean Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n", "print", "(", "'\\nTest set: Adv loss: {:.3f}, Adv Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss_adv", ",", "correct_adv", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct_adv", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.adv_data": [[283, 293], ["deeprobust.image.attack.pgd.PGD", "deeprobust.image.attack.pgd.PGD.generate", "AWP.AWP_AT.model", "AWP.AWP_AT.flatten"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate"], ["", "def", "adv_data", "(", "self", ",", "data", ",", "output", ",", "ep", "=", "0.3", ",", "num_steps", "=", "10", ",", "perturb_step_size", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"\n        Generate input(adversarial) data for training.\n        \"\"\"", "\n", "\n", "adversary", "=", "PGD", "(", "self", ".", "model", ")", "\n", "data_adv", "=", "adversary", ".", "generate", "(", "data", ",", "output", ".", "flatten", "(", ")", ",", "epsilon", "=", "ep", ",", "num_steps", "=", "num_steps", ",", "step_size", "=", "perturb_step_size", ")", "\n", "output", "=", "self", ".", "model", "(", "data_adv", ")", "\n", "\n", "return", "data_adv", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.AWP_AT.calculate_loss": [[294, 301], ["torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy"], "methods", ["None"], ["", "def", "calculate_loss", "(", "self", ",", "output", ",", "target", ",", "redmode", "=", "'mean'", ")", ":", "\n", "        ", "\"\"\"\n        Calculate loss for training.\n        \"\"\"", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "redmode", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.diff_in_weights": [[24, 35], ["OrderedDict", "model.state_dict", "proxy.state_dict", "zip", "model.state_dict.items", "proxy.state_dict.items", "len", "old_w.size", "old_w.norm", "diff_w.norm"], "function", ["None"], ["def", "diff_in_weights", "(", "model", ",", "proxy", ")", ":", "\n", "    ", "diff_dict", "=", "OrderedDict", "(", ")", "\n", "model_state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "proxy_state_dict", "=", "proxy", ".", "state_dict", "(", ")", "\n", "for", "(", "old_k", ",", "old_w", ")", ",", "(", "new_k", ",", "new_w", ")", "in", "zip", "(", "model_state_dict", ".", "items", "(", ")", ",", "proxy_state_dict", ".", "items", "(", ")", ")", ":", "\n", "        ", "if", "len", "(", "old_w", ".", "size", "(", ")", ")", "<=", "1", ":", "\n", "            ", "continue", "\n", "", "if", "'weight'", "in", "old_k", ":", "\n", "            ", "diff_w", "=", "new_w", "-", "old_w", "\n", "diff_dict", "[", "old_k", "]", "=", "old_w", ".", "norm", "(", ")", "/", "(", "diff_w", ".", "norm", "(", ")", "+", "EPS", ")", "*", "diff_w", "\n", "", "", "return", "diff_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.defense.AWP.add_into_weights": [[37, 43], ["diff.keys", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.named_parameters", "param.add_"], "function", ["None"], ["", "def", "add_into_weights", "(", "model", ",", "diff", ",", "coeff", "=", "1.0", ")", ":", "\n", "    ", "names_in_diff", "=", "diff", ".", "keys", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "name", "in", "names_in_diff", ":", "\n", "                ", "param", ".", "add_", "(", "coeff", "*", "diff", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.evaluation_attack.run_attack": [[14, 50], ["enumerate", "len", "print", "print", "print", "model", "torch.nll_loss().item", "model.argmax", "output.argmax.eq().sum().item", "data.to", "target.to", "random.choice", "attackmethod.generate", "list", "list", "attackmethod.generate", "attackmethod.generate", "torch.nll_loss", "output.argmax.eq().sum", "range", "range", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate"], ["def", "run_attack", "(", "attackmethod", ",", "batch_size", ",", "batch_num", ",", "device", ",", "test_loader", ",", "random_targeted", "=", "False", ",", "target_label", "=", "-", "1", ",", "**", "kwargs", ")", ":", "\n", "    ", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "samplenum", "=", "1000", "\n", "count", "=", "0", "\n", "classnum", "=", "10", "\n", "for", "count", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "test_loader", ")", ":", "\n", "        ", "if", "count", "==", "batch_num", ":", "\n", "            ", "break", "\n", "", "print", "(", "'batch:{}'", ".", "format", "(", "count", ")", ")", "\n", "\n", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "if", "(", "random_targeted", "==", "True", ")", ":", "\n", "            ", "r", "=", "list", "(", "range", "(", "0", ",", "target", ")", ")", "+", "list", "(", "range", "(", "target", "+", "1", ",", "classnum", ")", ")", "\n", "target_label", "=", "random", ".", "choice", "(", "r", ")", "\n", "adv_example", "=", "attackmethod", ".", "generate", "(", "data", ",", "target", ",", "target_label", "=", "target_label", ",", "**", "kwargs", ")", "\n", "\n", "", "elif", "(", "target_label", ">=", "0", ")", ":", "\n", "            ", "adv_example", "=", "attackmethod", ".", "generate", "(", "data", ",", "target", ",", "target_label", "=", "target_label", ",", "**", "kwargs", ")", "\n", "\n", "", "else", ":", "\n", "            ", "adv_example", "=", "attackmethod", ".", "generate", "(", "data", ",", "target", ",", "**", "kwargs", ")", "\n", "\n", "", "output", "=", "model", "(", "adv_example", ")", "\n", "test_loss", "+=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability.", "\n", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "batch_num", "=", "count", "+", "1", "\n", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "print", "(", "\"===== ACCURACY =====\"", ")", "\n", "print", "(", "'Attack Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "batch_num", "*", "batch_size", ",", "\n", "100.", "*", "correct", "/", "(", "batch_num", "*", "batch_size", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.evaluation_attack.load_net": [[51, 63], ["Net.ResNet18.load_state_dict", "Net.ResNet18.eval", "Net", "Net.ResNet18", "torch.load", "torch.load"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet18"], ["", "def", "load_net", "(", "attack_model", ",", "filename", ",", "path", ")", ":", "\n", "    ", "if", "(", "attack_model", "==", "\"CNN\"", ")", ":", "\n", "        ", "from", "deeprobust", ".", "image", ".", "netmodels", ".", "CNN", "import", "Net", "\n", "\n", "model", "=", "Net", "(", ")", "\n", "", "if", "(", "attack_model", "==", "\"ResNet18\"", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "resnet", "as", "Net", "\n", "model", "=", "Net", ".", "ResNet18", "(", ")", "\n", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "path", "+", "filename", ")", ")", "\n", "model", ".", "eval", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.evaluation_attack.generate_dataloader": [[64, 93], ["torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "torchvision.datasets.MNIST", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "torchvision.datasets.CIFAR10", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "torchvision.transforms.Compose", "torchvision.datasets.CIFAR10", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.ToTensor"], "function", ["None"], ["", "def", "generate_dataloader", "(", "dataset", ",", "batch_size", ")", ":", "\n", "    ", "if", "(", "dataset", "==", "\"MNIST\"", ")", ":", "\n", "        ", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "MNIST", "(", "'deeprobust/image/data'", ",", "train", "=", "False", ",", "\n", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", ")", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ")", "\n", "print", "(", "\"Loading MNIST dataset.\"", ")", "\n", "\n", "", "elif", "(", "dataset", "==", "\"CIFAR\"", "or", "args", ".", "dataset", "==", "'CIFAR10'", ")", ":", "\n", "        ", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "CIFAR10", "(", "'deeprobust/image/data'", ",", "train", "=", "False", ",", "\n", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", ")", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ")", "\n", "classes", "=", "(", "'plane'", ",", "'car'", ",", "'bird'", ",", "'cat'", ",", "'deer'", ",", "'dog'", ",", "'frog'", ",", "'horse'", ",", "'ship'", ",", "'truck'", ")", "\n", "print", "(", "\"Loading CIFAR10 dataset.\"", ")", "\n", "\n", "", "elif", "(", "dataset", "==", "\"ImageNet\"", ")", ":", "\n", "        ", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "CIFAR10", "(", "'deeprobust/image/data'", ",", "train", "=", "False", ",", "\n", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", ")", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ")", "\n", "print", "(", "\"Loading ImageNet dataset.\"", ")", "\n", "", "return", "test_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.evaluation_attack.parameter_parser": [[94, 125], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "parameter_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Run attack algorithms.\"", ",", "usage", "=", "'Use -h for more information.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--attack_method\"", ",", "\n", "default", "=", "'PGD'", ",", "\n", "help", "=", "\"Choose a attack algorithm from: PGD(default), FGSM, LBFGS, CW, deepfool, onepixel, Nattack\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--attack_model\"", ",", "\n", "default", "=", "\"CNN\"", ",", "\n", "help", "=", "\"Choose network structure from: CNN, ResNet\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--path\"", ",", "\n", "default", "=", "\"./trained_models/\"", ",", "\n", "help", "=", "\"Type the path where the model is saved.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--file_name\"", ",", "\n", "default", "=", "'MNIST_CNN_epoch_20.pt'", ",", "\n", "help", "=", "\"Type the file_name of the model that is to be attack. The model structure should be matched with the ATTACK_MODEL parameter.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dataset\"", ",", "\n", "default", "=", "'MNIST'", ",", "\n", "help", "=", "\"Choose a dataset from: MNIST(default), CIFAR(or CIFAR10), ImageNet\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--epsilon\"", ",", "type", "=", "float", ",", "default", "=", "0.3", ")", "\n", "parser", ".", "add_argument", "(", "\"--batch_num\"", ",", "type", "=", "int", ",", "default", "=", "1000", ")", "\n", "parser", ".", "add_argument", "(", "\"--batch_size\"", ",", "type", "=", "int", ",", "default", "=", "1000", ")", "\n", "parser", ".", "add_argument", "(", "\"--num_steps\"", ",", "type", "=", "int", ",", "default", "=", "40", ")", "\n", "parser", ".", "add_argument", "(", "\"--step_size\"", ",", "type", "=", "float", ",", "default", "=", "0.01", ")", "\n", "parser", ".", "add_argument", "(", "\"--random_targeted\"", ",", "type", "=", "bool", ",", "default", "=", "False", ",", "\n", "help", "=", "\"default: False. By setting this parameter be True, the program would random generate target labels for the input samples.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--target_label\"", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"default: -1. Generate all attack Fixed target label.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--device\"", ",", "default", "=", "'cuda'", ",", "\n", "help", "=", "\"Choose the device.\"", ")", "\n", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.__init__": [[324, 413], ["numpy.fabs", "numpy.size", "scipy._lib._util.check_random_state", "max", "isinstance", "getattr", "numpy.any", "numpy.any", "ValueError", "hasattr", "optimizer.DifferentialEvolutionSolver.dither.sort", "numpy.array", "ValueError", "optimizer.DifferentialEvolutionSolver.init_population_array", "getattr", "ValueError", "numpy.all", "len", "numpy.size", "numpy.all", "optimizer.DifferentialEvolutionSolver.init_population_lhs", "numpy.isfinite", "numpy.array", "numpy.array", "numpy.isfinite", "optimizer.DifferentialEvolutionSolver.init_population_random", "ValueError"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_array", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_lhs", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_random"], ["def", "__init__", "(", "self", ",", "func", ",", "bounds", ",", "args", "=", "(", ")", ",", "\n", "strategy", "=", "'best1bin'", ",", "maxiter", "=", "1000", ",", "popsize", "=", "15", ",", "\n", "tol", "=", "0.01", ",", "mutation", "=", "(", "0.5", ",", "1", ")", ",", "recombination", "=", "0.7", ",", "seed", "=", "None", ",", "\n", "maxfun", "=", "np", ".", "inf", ",", "callback", "=", "None", ",", "disp", "=", "False", ",", "polish", "=", "True", ",", "\n", "init", "=", "'latinhypercube'", ",", "atol", "=", "0", ")", ":", "\n", "\n", "        ", "if", "strategy", "in", "self", ".", "_binomial", ":", "\n", "            ", "self", ".", "mutation_func", "=", "getattr", "(", "self", ",", "self", ".", "_binomial", "[", "strategy", "]", ")", "\n", "", "elif", "strategy", "in", "self", ".", "_exponential", ":", "\n", "            ", "self", ".", "mutation_func", "=", "getattr", "(", "self", ",", "self", ".", "_exponential", "[", "strategy", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Please select a valid mutation strategy\"", ")", "\n", "", "self", ".", "strategy", "=", "strategy", "\n", "\n", "self", ".", "callback", "=", "callback", "\n", "self", ".", "polish", "=", "polish", "\n", "\n", "# relative and absolute tolerances for convergence", "\n", "self", ".", "tol", ",", "self", ".", "atol", "=", "tol", ",", "atol", "\n", "\n", "# Mutation constant should be in [0, 2). If specified as a sequence", "\n", "# then dithering is performed.", "\n", "self", ".", "scale", "=", "mutation", "\n", "if", "(", "not", "np", ".", "all", "(", "np", ".", "isfinite", "(", "mutation", ")", ")", "or", "\n", "np", ".", "any", "(", "np", ".", "array", "(", "mutation", ")", ">=", "2", ")", "or", "\n", "np", ".", "any", "(", "np", ".", "array", "(", "mutation", ")", "<", "0", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'The mutation constant must be a float in '", "\n", "'U[0, 2), or specified as a tuple(min, max)'", "\n", "' where min < max and min, max are in U[0, 2).'", ")", "\n", "\n", "", "self", ".", "dither", "=", "None", "\n", "if", "hasattr", "(", "mutation", ",", "'__iter__'", ")", "and", "len", "(", "mutation", ")", ">", "1", ":", "\n", "            ", "self", ".", "dither", "=", "[", "mutation", "[", "0", "]", ",", "mutation", "[", "1", "]", "]", "\n", "self", ".", "dither", ".", "sort", "(", ")", "\n", "\n", "", "self", ".", "cross_over_probability", "=", "recombination", "\n", "\n", "self", ".", "func", "=", "func", "\n", "self", ".", "args", "=", "args", "\n", "\n", "# convert tuple of lower and upper bounds to limits", "\n", "# [(low_0, high_0), ..., (low_n, high_n]", "\n", "#     -> [[low_0, ..., low_n], [high_0, ..., high_n]]", "\n", "self", ".", "limits", "=", "np", ".", "array", "(", "bounds", ",", "dtype", "=", "'float'", ")", ".", "T", "\n", "if", "(", "np", ".", "size", "(", "self", ".", "limits", ",", "0", ")", "!=", "2", "or", "not", "\n", "np", ".", "all", "(", "np", ".", "isfinite", "(", "self", ".", "limits", ")", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'bounds should be a sequence containing '", "\n", "'real valued (min, max) pairs for each value'", "\n", "' in x'", ")", "\n", "\n", "", "if", "maxiter", "is", "None", ":", "# the default used to be None", "\n", "            ", "maxiter", "=", "1000", "\n", "", "self", ".", "maxiter", "=", "maxiter", "\n", "if", "maxfun", "is", "None", ":", "# the default used to be None", "\n", "            ", "maxfun", "=", "np", ".", "inf", "\n", "", "self", ".", "maxfun", "=", "maxfun", "\n", "\n", "# population is scaled to between [0, 1].", "\n", "# We have to scale between parameter <-> population", "\n", "# save these arguments for _scale_parameter and", "\n", "# _unscale_parameter. This is an optimization", "\n", "self", ".", "__scale_arg1", "=", "0.5", "*", "(", "self", ".", "limits", "[", "0", "]", "+", "self", ".", "limits", "[", "1", "]", ")", "\n", "self", ".", "__scale_arg2", "=", "np", ".", "fabs", "(", "self", ".", "limits", "[", "0", "]", "-", "self", ".", "limits", "[", "1", "]", ")", "\n", "\n", "self", ".", "parameter_count", "=", "np", ".", "size", "(", "self", ".", "limits", ",", "1", ")", "\n", "\n", "self", ".", "random_number_generator", "=", "check_random_state", "(", "seed", ")", "\n", "\n", "# default population initialization is a latin hypercube design, but", "\n", "# there are other population initializations possible.", "\n", "# the minimum is 5 because 'best2bin' requires a population that's at", "\n", "# least 5 long", "\n", "self", ".", "num_population_members", "=", "max", "(", "5", ",", "popsize", "*", "self", ".", "parameter_count", ")", "\n", "\n", "self", ".", "population_shape", "=", "(", "self", ".", "num_population_members", ",", "\n", "self", ".", "parameter_count", ")", "\n", "\n", "self", ".", "_nfev", "=", "0", "\n", "if", "isinstance", "(", "init", ",", "string_types", ")", ":", "\n", "            ", "if", "init", "==", "'latinhypercube'", ":", "\n", "                ", "self", ".", "init_population_lhs", "(", ")", "\n", "", "elif", "init", "==", "'random'", ":", "\n", "                ", "self", ".", "init_population_random", "(", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "self", ".", "__init_error_msg", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "init_population_array", "(", "init", ")", "\n", "\n", "", "self", ".", "disp", "=", "disp", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_lhs": [[414, 451], ["numpy.zeros_like", "range", "rng.permutation", "numpy.ones", "rng.random_sample", "numpy.linspace", "range"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.random_sample"], ["", "def", "init_population_lhs", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initializes the population with Latin Hypercube Sampling.\n        Latin Hypercube Sampling ensures that each parameter is uniformly\n        sampled over its range.\n        \"\"\"", "\n", "rng", "=", "self", ".", "random_number_generator", "\n", "\n", "# Each parameter range needs to be sampled uniformly. The scaled", "\n", "# parameter range ([0, 1)) needs to be split into", "\n", "# `self.num_population_members` segments, each of which has the following", "\n", "# size:", "\n", "segsize", "=", "1.0", "/", "self", ".", "num_population_members", "\n", "\n", "# Within each segment we sample from a uniform random distribution.", "\n", "# We need to do this sampling for each parameter.", "\n", "samples", "=", "(", "segsize", "*", "rng", ".", "random_sample", "(", "self", ".", "population_shape", ")", "\n", "\n", "# Offset each segment to cover the entire parameter range [0, 1)", "\n", "+", "np", ".", "linspace", "(", "0.", ",", "1.", ",", "self", ".", "num_population_members", ",", "\n", "endpoint", "=", "False", ")", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "\n", "# Create an array for population of candidate solutions.", "\n", "self", ".", "population", "=", "np", ".", "zeros_like", "(", "samples", ")", "\n", "\n", "# Initialize population of candidate solutions by permutation of the", "\n", "# random samples.", "\n", "for", "j", "in", "range", "(", "self", ".", "parameter_count", ")", ":", "\n", "            ", "order", "=", "rng", ".", "permutation", "(", "range", "(", "self", ".", "num_population_members", ")", ")", "\n", "self", ".", "population", "[", ":", ",", "j", "]", "=", "samples", "[", "order", ",", "j", "]", "\n", "\n", "# reset population energies", "\n", "", "self", ".", "population_energies", "=", "(", "np", ".", "ones", "(", "self", ".", "num_population_members", ")", "*", "\n", "np", ".", "inf", ")", "\n", "\n", "# reset number of function evaluations counter", "\n", "self", ".", "_nfev", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_random": [[452, 466], ["rng.random_sample", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.global_attack.topology_attack.PGDAttack.random_sample"], ["", "def", "init_population_random", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initialises the population at random.  This type of initialization\n        can possess clustering, Latin Hypercube sampling is generally better.\n        \"\"\"", "\n", "rng", "=", "self", ".", "random_number_generator", "\n", "self", ".", "population", "=", "rng", ".", "random_sample", "(", "self", ".", "population_shape", ")", "\n", "\n", "# reset population energies", "\n", "self", ".", "population_energies", "=", "(", "np", ".", "ones", "(", "self", ".", "num_population_members", ")", "*", "\n", "np", ".", "inf", ")", "\n", "\n", "# reset number of function evaluations counter", "\n", "self", ".", "_nfev", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.init_population_array": [[467, 500], ["numpy.asfarray", "numpy.clip", "numpy.size", "ValueError", "optimizer.DifferentialEvolutionSolver._unscale_parameters", "numpy.ones", "numpy.size", "len"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._unscale_parameters"], ["", "def", "init_population_array", "(", "self", ",", "init", ")", ":", "\n", "        ", "\"\"\"\n        Initialises the population with a user specified population.\n        Parameters\n        ----------\n        init : np.ndarray\n            Array specifying subset of the initial population. The array should\n            have shape (M, len(x)), where len(x) is the number of parameters.\n            The population is clipped to the lower and upper `bounds`.\n        \"\"\"", "\n", "# make sure you're using a float array", "\n", "popn", "=", "np", ".", "asfarray", "(", "init", ")", "\n", "\n", "if", "(", "np", ".", "size", "(", "popn", ",", "0", ")", "<", "5", "or", "\n", "popn", ".", "shape", "[", "1", "]", "!=", "self", ".", "parameter_count", "or", "\n", "len", "(", "popn", ".", "shape", ")", "!=", "2", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"The population supplied needs to have shape\"", "\n", "\" (M, len(x)), where M > 4.\"", ")", "\n", "\n", "# scale values and clip to bounds, assigning to population", "\n", "", "self", ".", "population", "=", "np", ".", "clip", "(", "self", ".", "_unscale_parameters", "(", "popn", ")", ",", "0", ",", "1", ")", "\n", "\n", "self", ".", "num_population_members", "=", "np", ".", "size", "(", "self", ".", "population", ",", "0", ")", "\n", "\n", "self", ".", "population_shape", "=", "(", "self", ".", "num_population_members", ",", "\n", "self", ".", "parameter_count", ")", "\n", "\n", "# reset population energies", "\n", "self", ".", "population_energies", "=", "(", "np", ".", "ones", "(", "self", ".", "num_population_members", ")", "*", "\n", "np", ".", "inf", ")", "\n", "\n", "# reset number of function evaluations counter", "\n", "self", ".", "_nfev", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.x": [[501, 511], ["optimizer.DifferentialEvolutionSolver._scale_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._scale_parameters"], ["", "@", "property", "\n", "def", "x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The best solution from the solver\n        Returns\n        -------\n        x : ndarray\n            The best solution from the solver.\n        \"\"\"", "\n", "return", "self", ".", "_scale_parameters", "(", "self", ".", "population", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.convergence": [[512, 520], ["numpy.std", "numpy.abs", "numpy.mean"], "methods", ["None"], ["", "@", "property", "\n", "def", "convergence", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The standard deviation of the population energies divided by their\n        mean.\n        \"\"\"", "\n", "return", "(", "np", ".", "std", "(", "self", ".", "population_energies", ")", "/", "\n", "np", ".", "abs", "(", "np", ".", "mean", "(", "self", ".", "population_energies", ")", "+", "_MACHEPS", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.solve": [[521, 610], ["numpy.all", "scipy._lib.six.xrange", "scipy.optimize.OptimizeResult", "numpy.isinf", "optimizer.DifferentialEvolutionSolver._calculate_population_energies", "scipy.optimize.minimize", "optimizer.DifferentialEvolutionSolver.next"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._calculate_population_energies", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next"], ["", "def", "solve", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Runs the DifferentialEvolutionSolver.\n        Returns\n        -------\n        res : OptimizeResult\n            The optimization result represented as a ``OptimizeResult`` object.\n            Important attributes are: ``x`` the solution array, ``success`` a\n            Boolean flag indicating if the optimizer exited successfully and\n            ``message`` which describes the cause of the termination. See\n            `OptimizeResult` for a description of other attributes.  If `polish`\n            was employed, and a lower minimum was obtained by the polishing,\n            then OptimizeResult also contains the ``jac`` attribute.\n        \"\"\"", "\n", "nit", ",", "warning_flag", "=", "0", ",", "False", "\n", "status_message", "=", "_status_message", "[", "'success'", "]", "\n", "\n", "# The population may have just been initialized (all entries are", "\n", "# np.inf). If it has you have to calculate the initial energies.", "\n", "# Although this is also done in the evolve generator it's possible", "\n", "# that someone can set maxiter=0, at which point we still want the", "\n", "# initial energies to be calculated (the following loop isn't run).", "\n", "if", "np", ".", "all", "(", "np", ".", "isinf", "(", "self", ".", "population_energies", ")", ")", ":", "\n", "            ", "self", ".", "_calculate_population_energies", "(", ")", "\n", "\n", "# do the optimisation.", "\n", "", "for", "nit", "in", "xrange", "(", "1", ",", "self", ".", "maxiter", "+", "1", ")", ":", "\n", "# evolve the population by a generation", "\n", "            ", "try", ":", "\n", "                ", "next", "(", "self", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "warning_flag", "=", "True", "\n", "status_message", "=", "_status_message", "[", "'maxfev'", "]", "\n", "break", "\n", "\n", "", "if", "self", ".", "disp", ":", "\n", "                ", "print", "(", "\"differential_evolution step %d: f(x)= %g\"", "\n", "%", "(", "nit", ",", "\n", "self", ".", "population_energies", "[", "0", "]", ")", ")", "\n", "\n", "# should the solver terminate?", "\n", "", "convergence", "=", "self", ".", "convergence", "\n", "\n", "if", "(", "self", ".", "callback", "and", "\n", "self", ".", "callback", "(", "self", ".", "_scale_parameters", "(", "self", ".", "population", "[", "0", "]", ")", ",", "\n", "convergence", "=", "self", ".", "tol", "/", "convergence", ")", "is", "True", ")", ":", "\n", "\n", "                ", "warning_flag", "=", "True", "\n", "status_message", "=", "(", "'callback function requested stop early '", "\n", "'by returning True'", ")", "\n", "break", "\n", "\n", "", "intol", "=", "(", "np", ".", "std", "(", "self", ".", "population_energies", ")", "<=", "\n", "self", ".", "atol", "+", "\n", "self", ".", "tol", "*", "np", ".", "abs", "(", "np", ".", "mean", "(", "self", ".", "population_energies", ")", ")", ")", "\n", "if", "warning_flag", "or", "intol", ":", "\n", "                ", "break", "\n", "\n", "", "", "else", ":", "\n", "            ", "status_message", "=", "_status_message", "[", "'maxiter'", "]", "\n", "warning_flag", "=", "True", "\n", "\n", "", "DE_result", "=", "OptimizeResult", "(", "\n", "x", "=", "self", ".", "x", ",", "\n", "fun", "=", "self", ".", "population_energies", "[", "0", "]", ",", "\n", "nfev", "=", "self", ".", "_nfev", ",", "\n", "nit", "=", "nit", ",", "\n", "message", "=", "status_message", ",", "\n", "success", "=", "(", "warning_flag", "is", "not", "True", ")", ")", "\n", "\n", "if", "self", ".", "polish", ":", "\n", "            ", "result", "=", "minimize", "(", "self", ".", "func", ",", "\n", "np", ".", "copy", "(", "DE_result", ".", "x", ")", ",", "\n", "method", "=", "'L-BFGS-B'", ",", "\n", "bounds", "=", "self", ".", "limits", ".", "T", ",", "\n", "args", "=", "self", ".", "args", ")", "\n", "\n", "self", ".", "_nfev", "+=", "result", ".", "nfev", "\n", "DE_result", ".", "nfev", "=", "self", ".", "_nfev", "\n", "\n", "if", "result", ".", "fun", "<", "DE_result", ".", "fun", ":", "\n", "                ", "DE_result", ".", "fun", "=", "result", ".", "fun", "\n", "DE_result", ".", "x", "=", "result", ".", "x", "\n", "DE_result", ".", "jac", "=", "result", ".", "jac", "\n", "# to keep internal state consistent", "\n", "self", ".", "population_energies", "[", "0", "]", "=", "result", ".", "fun", "\n", "self", ".", "population", "[", "0", "]", "=", "self", ".", "_unscale_parameters", "(", "result", ".", "x", ")", "\n", "\n", "", "", "return", "DE_result", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._calculate_population_energies": [[611, 650], ["max", "numpy.array", "optimizer.DifferentialEvolutionSolver.func", "numpy.argmin", "min", "len", "optimizer.DifferentialEvolutionSolver._scale_parameters"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._scale_parameters"], ["", "def", "_calculate_population_energies", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Calculate the energies of all the population members at the same time.\n        Puts the best member in first place. Useful if the population has just\n        been initialised.\n        \"\"\"", "\n", "\n", "##############", "\n", "## CHANGES: self.func operates on the entire parameters array", "\n", "##############", "\n", "itersize", "=", "max", "(", "0", ",", "min", "(", "len", "(", "self", ".", "population", ")", ",", "self", ".", "maxfun", "-", "self", ".", "_nfev", "+", "1", ")", ")", "\n", "candidates", "=", "self", ".", "population", "[", ":", "itersize", "]", "\n", "parameters", "=", "np", ".", "array", "(", "[", "self", ".", "_scale_parameters", "(", "c", ")", "for", "c", "in", "candidates", "]", ")", "# TODO: vectorize", "\n", "energies", "=", "self", ".", "func", "(", "parameters", ",", "*", "self", ".", "args", ")", "\n", "self", ".", "population_energies", "=", "energies", "\n", "self", ".", "_nfev", "+=", "itersize", "\n", "\n", "# for index, candidate in enumerate(self.population):", "\n", "#     if self._nfev > self.maxfun:", "\n", "#         break", "\n", "\n", "#     parameters = self._scale_parameters(candidate)", "\n", "#     self.population_energies[index] = self.func(parameters,", "\n", "#                                                 *self.args)", "\n", "#     self._nfev += 1", "\n", "\n", "##############", "\n", "##############", "\n", "\n", "\n", "\n", "minval", "=", "np", ".", "argmin", "(", "self", ".", "population_energies", ")", "\n", "\n", "# put the lowest energy into the best solution position.", "\n", "lowest_energy", "=", "self", ".", "population_energies", "[", "minval", "]", "\n", "self", ".", "population_energies", "[", "minval", "]", "=", "self", ".", "population_energies", "[", "0", "]", "\n", "self", ".", "population_energies", "[", "0", "]", "=", "lowest_energy", "\n", "\n", "self", ".", "population", "[", "[", "0", ",", "minval", "]", ",", ":", "]", "=", "self", ".", "population", "[", "[", "minval", ",", "0", "]", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.__iter__": [[651, 653], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.__next__": [[654, 730], ["numpy.all", "max", "numpy.array", "numpy.array", "optimizer.DifferentialEvolutionSolver.func", "enumerate", "numpy.isinf", "optimizer.DifferentialEvolutionSolver._calculate_population_energies", "min", "optimizer.DifferentialEvolutionSolver._ensure_constraint", "zip", "optimizer.DifferentialEvolutionSolver._mutate", "optimizer.DifferentialEvolutionSolver._scale_parameters", "optimizer.DifferentialEvolutionSolver.random_number_generator.rand", "range"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._calculate_population_energies", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._ensure_constraint", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._mutate", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._scale_parameters"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evolve the population by a single generation\n        Returns\n        -------\n        x : ndarray\n            The best solution from the solver.\n        fun : float\n            Value of objective function obtained from the best solution.\n        \"\"\"", "\n", "# the population may have just been initialized (all entries are", "\n", "# np.inf). If it has you have to calculate the initial energies", "\n", "if", "np", ".", "all", "(", "np", ".", "isinf", "(", "self", ".", "population_energies", ")", ")", ":", "\n", "            ", "self", ".", "_calculate_population_energies", "(", ")", "\n", "\n", "", "if", "self", ".", "dither", "is", "not", "None", ":", "\n", "            ", "self", ".", "scale", "=", "(", "self", ".", "random_number_generator", ".", "rand", "(", ")", "\n", "*", "(", "self", ".", "dither", "[", "1", "]", "-", "self", ".", "dither", "[", "0", "]", ")", "+", "self", ".", "dither", "[", "0", "]", ")", "\n", "\n", "##############", "\n", "## CHANGES: self.func operates on the entire parameters array", "\n", "##############", "\n", "\n", "", "itersize", "=", "max", "(", "0", ",", "min", "(", "self", ".", "num_population_members", ",", "self", ".", "maxfun", "-", "self", ".", "_nfev", "+", "1", ")", ")", "\n", "trials", "=", "np", ".", "array", "(", "[", "self", ".", "_mutate", "(", "c", ")", "for", "c", "in", "range", "(", "itersize", ")", "]", ")", "# TODO: vectorize", "\n", "for", "trial", "in", "trials", ":", "self", ".", "_ensure_constraint", "(", "trial", ")", "\n", "parameters", "=", "np", ".", "array", "(", "[", "self", ".", "_scale_parameters", "(", "trial", ")", "for", "trial", "in", "trials", "]", ")", "\n", "energies", "=", "self", ".", "func", "(", "parameters", ",", "*", "self", ".", "args", ")", "\n", "self", ".", "_nfev", "+=", "itersize", "\n", "\n", "for", "candidate", ",", "(", "energy", ",", "trial", ")", "in", "enumerate", "(", "zip", "(", "energies", ",", "trials", ")", ")", ":", "\n", "# if the energy of the trial candidate is lower than the", "\n", "# original population member then replace it", "\n", "            ", "if", "energy", "<", "self", ".", "population_energies", "[", "candidate", "]", ":", "\n", "                ", "self", ".", "population", "[", "candidate", "]", "=", "trial", "\n", "self", ".", "population_energies", "[", "candidate", "]", "=", "energy", "\n", "\n", "# if the trial candidate also has a lower energy than the", "\n", "# best solution then replace that as well", "\n", "if", "energy", "<", "self", ".", "population_energies", "[", "0", "]", ":", "\n", "                    ", "self", ".", "population_energies", "[", "0", "]", "=", "energy", "\n", "self", ".", "population", "[", "0", "]", "=", "trial", "\n", "\n", "# for candidate in range(self.num_population_members):", "\n", "#     if self._nfev > self.maxfun:", "\n", "#         raise StopIteration", "\n", "\n", "#     # create a trial solution", "\n", "#     trial = self._mutate(candidate)", "\n", "\n", "#     # ensuring that it's in the range [0, 1)", "\n", "#     self._ensure_constraint(trial)", "\n", "\n", "#     # scale from [0, 1) to the actual parameter value", "\n", "#     parameters = self._scale_parameters(trial)", "\n", "\n", "#     # determine the energy of the objective function", "\n", "#     energy = self.func(parameters, *self.args)", "\n", "#     self._nfev += 1", "\n", "\n", "#     # if the energy of the trial candidate is lower than the", "\n", "#     # original population member then replace it", "\n", "#     if energy < self.population_energies[candidate]:", "\n", "#         self.population[candidate] = trial", "\n", "#         self.population_energies[candidate] = energy", "\n", "\n", "#         # if the trial candidate also has a lower energy than the", "\n", "#         # best solution then replace that as well", "\n", "#         if energy < self.population_energies[0]:", "\n", "#             self.population_energies[0] = energy", "\n", "#             self.population[0] = trial", "\n", "\n", "##############", "\n", "##############", "\n", "\n", "", "", "", "return", "self", ".", "x", ",", "self", ".", "population_energies", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.next": [[731, 743], ["optimizer.DifferentialEvolutionSolver.__next__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.__next__"], ["", "def", "next", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evolve the population by a single generation\n        Returns\n        -------\n        x : ndarray\n            The best solution from the solver.\n        fun : float\n            Value of objective function obtained from the best solution.\n        \"\"\"", "\n", "# next() is required for compatibility with Python2.7.", "\n", "return", "self", ".", "__next__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._scale_parameters": [[744, 749], ["None"], "methods", ["None"], ["", "def", "_scale_parameters", "(", "self", ",", "trial", ")", ":", "\n", "        ", "\"\"\"\n        scale from a number between 0 and 1 to parameters.\n        \"\"\"", "\n", "return", "self", ".", "__scale_arg1", "+", "(", "trial", "-", "0.5", ")", "*", "self", ".", "__scale_arg2", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._unscale_parameters": [[750, 755], ["None"], "methods", ["None"], ["", "def", "_unscale_parameters", "(", "self", ",", "parameters", ")", ":", "\n", "        ", "\"\"\"\n        scale from parameters to a number between 0 and 1.\n        \"\"\"", "\n", "return", "(", "parameters", "-", "self", ".", "__scale_arg1", ")", "/", "self", ".", "__scale_arg2", "+", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._ensure_constraint": [[756, 762], ["numpy.where", "optimizer.DifferentialEvolutionSolver.random_number_generator.rand"], "methods", ["None"], ["", "def", "_ensure_constraint", "(", "self", ",", "trial", ")", ":", "\n", "        ", "\"\"\"\n        make sure the parameters lie between the limits\n        \"\"\"", "\n", "for", "index", "in", "np", ".", "where", "(", "(", "trial", "<", "0", ")", "|", "(", "trial", ">", "1", ")", ")", "[", "0", "]", ":", "\n", "            ", "trial", "[", "index", "]", "=", "self", ".", "random_number_generator", ".", "rand", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._mutate": [[763, 800], ["numpy.copy", "rng.randint", "optimizer.DifferentialEvolutionSolver.mutation_func", "optimizer.DifferentialEvolutionSolver.mutation_func", "rng.rand", "numpy.where", "optimizer.DifferentialEvolutionSolver._select_samples", "optimizer.DifferentialEvolutionSolver._select_samples", "rng.rand"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._select_samples", "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._select_samples"], ["", "", "def", "_mutate", "(", "self", ",", "candidate", ")", ":", "\n", "        ", "\"\"\"\n        create a trial vector based on a mutation strategy\n        \"\"\"", "\n", "trial", "=", "np", ".", "copy", "(", "self", ".", "population", "[", "candidate", "]", ")", "\n", "\n", "rng", "=", "self", ".", "random_number_generator", "\n", "\n", "fill_point", "=", "rng", ".", "randint", "(", "0", ",", "self", ".", "parameter_count", ")", "\n", "\n", "if", "self", ".", "strategy", "in", "[", "'currenttobest1exp'", ",", "'currenttobest1bin'", "]", ":", "\n", "            ", "bprime", "=", "self", ".", "mutation_func", "(", "candidate", ",", "\n", "self", ".", "_select_samples", "(", "candidate", ",", "5", ")", ")", "\n", "", "else", ":", "\n", "            ", "bprime", "=", "self", ".", "mutation_func", "(", "self", ".", "_select_samples", "(", "candidate", ",", "5", ")", ")", "\n", "\n", "", "if", "self", ".", "strategy", "in", "self", ".", "_binomial", ":", "\n", "            ", "crossovers", "=", "rng", ".", "rand", "(", "self", ".", "parameter_count", ")", "\n", "crossovers", "=", "crossovers", "<", "self", ".", "cross_over_probability", "\n", "# the last one is always from the bprime vector for binomial", "\n", "# If you fill in modulo with a loop you have to set the last one to", "\n", "# true. If you don't use a loop then you can have any random entry", "\n", "# be True.", "\n", "crossovers", "[", "fill_point", "]", "=", "True", "\n", "trial", "=", "np", ".", "where", "(", "crossovers", ",", "bprime", ",", "trial", ")", "\n", "return", "trial", "\n", "\n", "", "elif", "self", ".", "strategy", "in", "self", ".", "_exponential", ":", "\n", "            ", "i", "=", "0", "\n", "while", "(", "i", "<", "self", ".", "parameter_count", "and", "\n", "rng", ".", "rand", "(", ")", "<", "self", ".", "cross_over_probability", ")", ":", "\n", "\n", "                ", "trial", "[", "fill_point", "]", "=", "bprime", "[", "fill_point", "]", "\n", "fill_point", "=", "(", "fill_point", "+", "1", ")", "%", "self", ".", "parameter_count", "\n", "i", "+=", "1", "\n", "\n", "", "return", "trial", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._best1": [[801, 808], ["None"], "methods", ["None"], ["", "", "def", "_best1", "(", "self", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        best1bin, best1exp\n        \"\"\"", "\n", "r0", ",", "r1", "=", "samples", "[", ":", "2", "]", "\n", "return", "(", "self", ".", "population", "[", "0", "]", "+", "self", ".", "scale", "*", "\n", "(", "self", ".", "population", "[", "r0", "]", "-", "self", ".", "population", "[", "r1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._rand1": [[809, 816], ["None"], "methods", ["None"], ["", "def", "_rand1", "(", "self", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        rand1bin, rand1exp\n        \"\"\"", "\n", "r0", ",", "r1", ",", "r2", "=", "samples", "[", ":", "3", "]", "\n", "return", "(", "self", ".", "population", "[", "r0", "]", "+", "self", ".", "scale", "*", "\n", "(", "self", ".", "population", "[", "r1", "]", "-", "self", ".", "population", "[", "r2", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._randtobest1": [[817, 827], ["numpy.copy"], "methods", ["None"], ["", "def", "_randtobest1", "(", "self", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        randtobest1bin, randtobest1exp\n        \"\"\"", "\n", "r0", ",", "r1", ",", "r2", "=", "samples", "[", ":", "3", "]", "\n", "bprime", "=", "np", ".", "copy", "(", "self", ".", "population", "[", "r0", "]", ")", "\n", "bprime", "+=", "self", ".", "scale", "*", "(", "self", ".", "population", "[", "0", "]", "-", "bprime", ")", "\n", "bprime", "+=", "self", ".", "scale", "*", "(", "self", ".", "population", "[", "r1", "]", "-", "\n", "self", ".", "population", "[", "r2", "]", ")", "\n", "return", "bprime", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._currenttobest1": [[828, 837], ["None"], "methods", ["None"], ["", "def", "_currenttobest1", "(", "self", ",", "candidate", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        currenttobest1bin, currenttobest1exp\n        \"\"\"", "\n", "r0", ",", "r1", "=", "samples", "[", ":", "2", "]", "\n", "bprime", "=", "(", "self", ".", "population", "[", "candidate", "]", "+", "self", ".", "scale", "*", "\n", "(", "self", ".", "population", "[", "0", "]", "-", "self", ".", "population", "[", "candidate", "]", "+", "\n", "self", ".", "population", "[", "r0", "]", "-", "self", ".", "population", "[", "r1", "]", ")", ")", "\n", "return", "bprime", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._best2": [[838, 848], ["None"], "methods", ["None"], ["", "def", "_best2", "(", "self", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        best2bin, best2exp\n        \"\"\"", "\n", "r0", ",", "r1", ",", "r2", ",", "r3", "=", "samples", "[", ":", "4", "]", "\n", "bprime", "=", "(", "self", ".", "population", "[", "0", "]", "+", "self", ".", "scale", "*", "\n", "(", "self", ".", "population", "[", "r0", "]", "+", "self", ".", "population", "[", "r1", "]", "-", "\n", "self", ".", "population", "[", "r2", "]", "-", "self", ".", "population", "[", "r3", "]", ")", ")", "\n", "\n", "return", "bprime", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._rand2": [[849, 859], ["None"], "methods", ["None"], ["", "def", "_rand2", "(", "self", ",", "samples", ")", ":", "\n", "        ", "\"\"\"\n        rand2bin, rand2exp\n        \"\"\"", "\n", "r0", ",", "r1", ",", "r2", ",", "r3", ",", "r4", "=", "samples", "\n", "bprime", "=", "(", "self", ".", "population", "[", "r0", "]", "+", "self", ".", "scale", "*", "\n", "(", "self", ".", "population", "[", "r1", "]", "+", "self", ".", "population", "[", "r2", "]", "-", "\n", "self", ".", "population", "[", "r3", "]", "-", "self", ".", "population", "[", "r4", "]", ")", ")", "\n", "\n", "return", "bprime", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver._select_samples": [[860, 870], ["list", "list.remove", "optimizer.DifferentialEvolutionSolver.random_number_generator.shuffle", "range"], "methods", ["None"], ["", "def", "_select_samples", "(", "self", ",", "candidate", ",", "number_samples", ")", ":", "\n", "        ", "\"\"\"\n        obtain random integers from range(self.num_population_members),\n        without replacement.  You can't have the original candidate either.\n        \"\"\"", "\n", "idxs", "=", "list", "(", "range", "(", "self", ".", "num_population_members", ")", ")", "\n", "idxs", ".", "remove", "(", "candidate", ")", "\n", "self", ".", "random_number_generator", ".", "shuffle", "(", "idxs", ")", "\n", "idxs", "=", "idxs", "[", ":", "number_samples", "]", "\n", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.AdamOptimizer.__init__": [[880, 884], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "shape", ")", ":", "\n", "        ", "self", ".", "m", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "self", ".", "v", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "self", ".", "t", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.AdamOptimizer.__call__": [[885, 916], ["numpy.sqrt"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "gradient", ",", "learning_rate", ",", "beta1", "=", "0.9", ",", "beta2", "=", "0.999", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "        ", "\"\"\"Updates internal parameters of the optimizer and returns\n        the change that should be applied to the variable.\n        Parameters\n        ----------\n        gradient : `np.ndarray`\n            the gradient of the loss w.r.t. to the variable\n        learning_rate: float\n            the learning rate in the current iteration\n        beta1: float\n            decay rate for calculating the exponentially\n            decaying average of past gradients\n        beta2: float\n            decay rate for calculating the exponentially\n            decaying average of past squared gradients\n        epsilon: float\n            small value to avoid division by zero\n        \"\"\"", "\n", "\n", "self", ".", "t", "+=", "1", "\n", "\n", "self", ".", "m", "=", "beta1", "*", "self", ".", "m", "+", "(", "1", "-", "beta1", ")", "*", "gradient", "\n", "self", ".", "v", "=", "beta2", "*", "self", ".", "v", "+", "(", "1", "-", "beta2", ")", "*", "gradient", "**", "2", "\n", "\n", "bias_correction_1", "=", "1", "-", "beta1", "**", "self", ".", "t", "\n", "bias_correction_2", "=", "1", "-", "beta2", "**", "self", ".", "t", "\n", "\n", "m_hat", "=", "self", ".", "m", "/", "bias_correction_1", "\n", "v_hat", "=", "self", ".", "v", "/", "bias_correction_2", "\n", "\n", "return", "-", "learning_rate", "*", "m_hat", "/", "(", "np", ".", "sqrt", "(", "v_hat", ")", "+", "epsilon", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.differential_evolution": [[28, 196], ["optimizer.DifferentialEvolutionSolver", "optimizer.DifferentialEvolutionSolver.solve"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.DifferentialEvolutionSolver.solve"], ["def", "differential_evolution", "(", "func", ",", "bounds", ",", "args", "=", "(", ")", ",", "strategy", "=", "'best1bin'", ",", "\n", "maxiter", "=", "1000", ",", "popsize", "=", "15", ",", "tol", "=", "0.01", ",", "\n", "mutation", "=", "(", "0.5", ",", "1", ")", ",", "recombination", "=", "0.7", ",", "seed", "=", "None", ",", "\n", "callback", "=", "None", ",", "disp", "=", "False", ",", "polish", "=", "True", ",", "\n", "init", "=", "'latinhypercube'", ",", "atol", "=", "0", ")", ":", "\n", "    ", "\"\"\"Finds the global minimum of a multivariate function.\n    Differential Evolution is stochastic in nature (does not use gradient\n    methods) to find the minimium, and can search large areas of candidate\n    space, but often requires larger numbers of function evaluations than\n    conventional gradient based techniques.\n    The algorithm is due to Storn and Price [1]_.\n    Parameters\n    ----------\n    func : callable\n        The objective function to be minimized.  Must be in the form\n        ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array\n        and ``args`` is a  tuple of any additional fixed parameters needed to\n        completely specify the function.\n    bounds : sequence\n        Bounds for variables.  ``(min, max)`` pairs for each element in ``x``,\n        defining the lower and upper bounds for the optimizing argument of\n        `func`. It is required to have ``len(bounds) == len(x)``.\n        ``len(bounds)`` is used to determine the number of parameters in ``x``.\n    args : tuple, optional\n        Any additional fixed parameters needed to\n        completely specify the objective function.\n    strategy : str, optional\n        The differential evolution strategy to use. Should be one of:\n            - 'best1bin'\n            - 'best1exp'\n            - 'rand1exp'\n            - 'randtobest1exp'\n            - 'currenttobest1exp'\n            - 'best2exp'\n            - 'rand2exp'\n            - 'randtobest1bin'\n            - 'currenttobest1bin'\n            - 'best2bin'\n            - 'rand2bin'\n            - 'rand1bin'\n        The default is 'best1bin'.\n    maxiter : int, optional\n        The maximum number of generations over which the entire population is\n        evolved. The maximum number of function evaluations (with no polishing)\n        is: ``(maxiter + 1) * popsize * len(x)``\n    popsize : int, optional\n        A multiplier for setting the total population size.  The population has\n        ``popsize * len(x)`` individuals (unless the initial population is\n        supplied via the `init` keyword).\n    tol : float, optional\n        Relative tolerance for convergence, the solving stops when\n        ``np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))``,\n        where and `atol` and `tol` are the absolute and relative tolerance\n        respectively.\n    mutation : float or tuple(float, float), optional\n        The mutation constant. In the literature this is also known as\n        differential weight, being denoted by F.\n        If specified as a float it should be in the range [0, 2].\n        If specified as a tuple ``(min, max)`` dithering is employed. Dithering\n        randomly changes the mutation constant on a generation by generation\n        basis. The mutation constant for that generation is taken from\n        ``U[min, max)``. Dithering can help speed convergence significantly.\n        Increasing the mutation constant increases the search radius, but will\n        slow down convergence.\n    recombination : float, optional\n        The recombination constant, should be in the range [0, 1]. In the\n        literature this is also known as the crossover probability, being\n        denoted by CR. Increasing this value allows a larger number of mutants\n        to progress into the next generation, but at the risk of population\n        stability.\n    seed : int or `np.random.RandomState`, optional\n        If `seed` is not specified the `np.RandomState` singleton is used.\n        If `seed` is an int, a new `np.random.RandomState` instance is used,\n        seeded with seed.\n        If `seed` is already a `np.random.RandomState instance`, then that\n        `np.random.RandomState` instance is used.\n        Specify `seed` for repeatable minimizations.\n    disp : bool, optional\n        Display status messages\n    callback : callable, `callback(xk, convergence=val)`, optional\n        A function to follow the progress of the minimization. ``xk`` is\n        the current value of ``x0``. ``val`` represents the fractional\n        value of the population convergence.  When ``val`` is greater than one\n        the function halts. If callback returns `True`, then the minimization\n        is halted (any polishing is still carried out).\n    polish : bool, optional\n        If True (default), then `scipy.optimize.minimize` with the `L-BFGS-B`\n        method is used to polish the best population member at the end, which\n        can improve the minimization slightly.\n    init : str or array-like, optional\n        Specify which type of population initialization is performed. Should be\n        one of:\n            - 'latinhypercube'\n            - 'random'\n            - array specifying the initial population. The array should have\n              shape ``(M, len(x))``, where len(x) is the number of parameters.\n              `init` is clipped to `bounds` before use.\n        The default is 'latinhypercube'. Latin Hypercube sampling tries to\n        maximize coverage of the available parameter space. 'random'\n        initializes the population randomly - this has the drawback that\n        clustering can occur, preventing the whole of parameter space being\n        covered. Use of an array to specify a population subset could be used,\n        for example, to create a tight bunch of initial guesses in an location\n        where the solution is known to exist, thereby reducing time for\n        convergence.\n    atol : float, optional\n        Absolute tolerance for convergence, the solving stops when\n        ``np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))``,\n        where and `atol` and `tol` are the absolute and relative tolerance\n        respectively.\n    Returns\n    -------\n    res : OptimizeResult\n        The optimization result represented as a `OptimizeResult` object.\n        Important attributes are: ``x`` the solution array, ``success`` a\n        Boolean flag indicating if the optimizer exited successfully and\n        ``message`` which describes the cause of the termination. See\n        `OptimizeResult` for a description of other attributes.  If `polish`\n        was employed, and a lower minimum was obtained by the polishing, then\n        OptimizeResult also contains the ``jac`` attribute.\n    Notes\n    -----\n    Differential evolution is a stochastic population based method that is\n    useful for global optimization problems. At each pass through the population\n    the algorithm mutates each candidate solution by mixing with other candidate\n    solutions to create a trial candidate. There are several strategies [2]_ for\n    creating trial candidates, which suit some problems more than others. The\n    'best1bin' strategy is a good starting point for many systems. In this\n    strategy two members of the population are randomly chosen. Their difference\n    is used to mutate the best member (the `best` in `best1bin`), :math:`b_0`,\n    so far:\n    .. math::\n        b' = b_0 + mutation * (population[rand0] - population[rand1])\n    A trial vector is then constructed. Starting with a randomly chosen 'i'th\n    parameter the trial is sequentially filled (in modulo) with parameters from\n    `b'` or the original candidate. The choice of whether to use `b'` or the\n    original candidate is made with a binomial distribution (the 'bin' in\n    'best1bin') - a random number in [0, 1) is generated.  If this number is\n    less than the `recombination` constant then the parameter is loaded from\n    `b'`, otherwise it is loaded from the original candidate.  The final\n    parameter is always loaded from `b'`.  Once the trial candidate is built\n    its fitness is assessed. If the trial is better than the original candidate\n    then it takes its place. If it is also better than the best overall\n    candidate it also replaces that.\n    To improve your chances of finding a global minimum use higher `popsize`\n    values, with higher `mutation` and (dithering), but lower `recombination`\n    values. This has the effect of widening the search radius, but slowing\n    convergence.\n    .. versionadded:: 0.15.0\n    \n    References\n    ----------\n    .. [1] Storn, R and Price, K, Differential Evolution - a Simple and\n           Efficient Heuristic for Global Optimization over Continuous Spaces,\n           Journal of Global Optimization, 1997, 11, 341 - 359.\n    .. [2] http://www1.icsi.berkeley.edu/~storn/code.html\n    .. [3] http://en.wikipedia.org/wiki/Differential_evolution\n    \"\"\"", "\n", "\n", "solver", "=", "DifferentialEvolutionSolver", "(", "func", ",", "bounds", ",", "args", "=", "args", ",", "\n", "strategy", "=", "strategy", ",", "maxiter", "=", "maxiter", ",", "\n", "popsize", "=", "popsize", ",", "tol", "=", "tol", ",", "\n", "mutation", "=", "mutation", ",", "\n", "recombination", "=", "recombination", ",", "\n", "seed", "=", "seed", ",", "polish", "=", "polish", ",", "\n", "callback", "=", "callback", ",", "\n", "disp", "=", "disp", ",", "init", "=", "init", ",", "atol", "=", "atol", ")", "\n", "return", "solver", ".", "solve", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.create_train_dataset": [[9, 21], ["torchvision.Compose", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "torch.utils.data.DataLoader", "torchvision.ToTensor"], "function", ["None"], ["def", "encode_onehot", "(", "labels", ")", ":", "\n", "    ", "\"\"\"Convert label to onehot format.\n\n    Parameters\n    ----------\n    labels : numpy.array\n        node labels\n\n    Returns\n    -------\n    numpy.array\n        onehot labels\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.create_test_dataset": [[22, 29], ["torchvision.Compose", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "torch.utils.data.DataLoader", "torchvision.ToTensor"], "function", ["None"], ["eye", "=", "np", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", "\n", "\n", "", "def", "tensor2onehot", "(", "labels", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.download_model": [[30, 36], ["print", "urllib.request.urlretrieve", "Exception"], "function", ["None"], []], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.save_checkpoint": [[37, 45], ["os.path.exists", "torch.save", "net.state_dict", "optimizer.state_dict", "lr_scheduler.state_dict", "print"], "function", ["None"], ["\n", "\n", "eye", "=", "torch", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", ".", "to", "(", "labels", ".", "device", ")", "\n", "\n", "", "def", "preprocess", "(", "adj", ",", "features", ",", "labels", ",", "preprocess_adj", "=", "False", ",", "preprocess_feature", "=", "False", ",", "sparse", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.load_checkpoint": [[49, 66], ["os.path.isfile", "print", "torch.load", "print", "print", "net.load_state_dict", "print", "optimizer.load_state_dict", "print", "lr_scheduler.load_state_dict"], "function", ["None"], ["\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.make_symlink": [[67, 80], ["os.path.exists", "os.path.exists", "print", "os.remove", "os.symlink", "print"], "function", ["None"], ["if", "preprocess_adj", ":", "\n", "        ", "adj", "=", "normalize_adj", "(", "adj", ")", "\n", "\n", "", "if", "preprocess_feature", ":", "\n", "        ", "features", "=", "normalize_feature", "(", "features", ")", "\n", "\n", "", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "if", "sparse", ":", "\n", "        ", "adj", "=", "sparse_mx_to_torch_sparse_tensor", "(", "adj", ")", "\n", "features", "=", "sparse_mx_to_torch_sparse_tensor", "(", "features", ")", "\n", "", "else", ":", "\n", "        ", "features", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "features", ".", "todense", "(", ")", ")", ")", "\n", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ".", "todense", "(", ")", ")", "\n", "", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.tab_printer": [[82, 93], ["vars", "sorted", "texttable.Texttable", "texttable.Texttable.add_rows", "print", "vars.keys", "texttable.Texttable.draw", "k.replace().capitalize", "k.replace"], "function", ["None"], ["", "def", "to_tensor", "(", "adj", ",", "features", ",", "labels", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.onehot_like": [[94, 116], ["numpy.zeros_like"], "function", ["None"], ["\n", "if", "sp", ".", "issparse", "(", "adj", ")", ":", "\n", "        ", "adj", "=", "sparse_mx_to_torch_sparse_tensor", "(", "adj", ")", "\n", "", "else", ":", "\n", "        ", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ")", "\n", "", "if", "sp", ".", "issparse", "(", "features", ")", ":", "\n", "        ", "features", "=", "sparse_mx_to_torch_sparse_tensor", "(", "features", ")", "\n", "", "else", ":", "\n", "        ", "features", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "features", ")", ")", "\n", "\n", "", "if", "labels", "is", "None", ":", "\n", "        ", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "", "def", "normalize_feature", "(", "mx", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum": [[117, 122], ["reversed", "range", "x.sum.sum", "x.sum.dim"], "function", ["None"], []], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.arctanh": [[123, 129], ["numpy.log"], "function", ["None"], ["\n", "if", "type", "(", "mx", ")", "is", "not", "sp", ".", "lil", ".", "lil_matrix", ":", "\n", "        ", "mx", "=", "mx", ".", "tolil", "(", ")", "\n", "", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.l2r_dist": [[130, 135], ["utils.reduce_sum", "reduce_sum.sqrt"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum"], ["r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "return", "mx", "\n", "\n", "", "def", "normalize_adj", "(", "mx", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.l2_dist": [[137, 140], ["utils.reduce_sum"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum"], []], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.l1_dist": [[142, 145], ["torch.abs", "utils.reduce_sum"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum"], []], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.l2_norm": [[147, 150], ["utils.reduce_sum", "reduce_sum.sqrt"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum"], ["\n", "\n", "# TODO: maybe using coo format would be better?", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.l1_norm": [[152, 154], ["utils.reduce_sum", "x.abs"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.reduce_sum"], ["        ", "mx", "=", "mx", ".", "tolil", "(", ")", "\n", "", "if", "mx", "[", "0", ",", "0", "]", "==", "0", ":", "\n", "        ", "mx", "=", "mx", "+", "sp", ".", "eye", "(", "mx", ".", "shape", "[", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.adjust_learning_rate": [[155, 168], ["None"], "function", ["None"], ["", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", "/", "2", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "mx", "=", "mx", ".", "dot", "(", "r_mat_inv", ")", "\n", "return", "mx", "\n", "\n", "", "def", "normalize_sparse_tensor", "(", "adj", ",", "fill_value", "=", "1", ")", ":", "\n", "    ", "\"\"\"Normalize sparse tensor. Need to import torch_scatter\n    \"\"\"", "\n", "edge_index", "=", "adj", ".", "_indices", "(", ")", "\n", "edge_weight", "=", "adj", ".", "_values", "(", ")", "\n", "num_nodes", "=", "adj", ".", "size", "(", "0", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.progress_bar": [[169, 211], ["int", "sys.stdout.write", "range", "sys.stdout.write", "range", "sys.stdout.write", "time.time", "L.append", "L.append", "sys.stdout.write", "range", "range", "sys.stdout.write", "sys.stdout.flush", "time.time", "int", "sys.stdout.write", "sys.stdout.write", "L.append", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "format_time", "format_time", "len", "int", "int"], "function", ["None"], ["edge_index", ",", "edge_weight", "=", "add_self_loops", "(", "\n", "edge_index", ",", "edge_weight", ",", "fill_value", ",", "num_nodes", ")", "\n", "\n", "row", ",", "col", "=", "edge_index", "\n", "from", "torch_scatter", "import", "scatter_add", "\n", "deg", "=", "scatter_add", "(", "edge_weight", ",", "row", ",", "dim", "=", "0", ",", "dim_size", "=", "num_nodes", ")", "\n", "deg_inv_sqrt", "=", "deg", ".", "pow", "(", "-", "0.5", ")", "\n", "deg_inv_sqrt", "[", "deg_inv_sqrt", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "\n", "values", "=", "deg_inv_sqrt", "[", "row", "]", "*", "edge_weight", "*", "deg_inv_sqrt", "[", "col", "]", "\n", "\n", "shape", "=", "adj", ".", "shape", "\n", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index", ",", "values", ",", "shape", ")", "\n", "\n", "", "def", "add_self_loops", "(", "edge_index", ",", "edge_weight", "=", "None", ",", "fill_value", "=", "1", ",", "num_nodes", "=", "None", ")", ":", "\n", "# num_nodes = maybe_num_nodes(edge_index, num_nodes)", "\n", "\n", "    ", "loop_index", "=", "torch", ".", "arange", "(", "0", ",", "num_nodes", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "device", "=", "edge_index", ".", "device", ")", "\n", "loop_index", "=", "loop_index", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ")", "\n", "\n", "if", "edge_weight", "is", "not", "None", ":", "\n", "        ", "assert", "edge_weight", ".", "numel", "(", ")", "==", "edge_index", ".", "size", "(", "1", ")", "\n", "loop_weight", "=", "edge_weight", ".", "new_full", "(", "(", "num_nodes", ",", ")", ",", "fill_value", ")", "\n", "edge_weight", "=", "torch", ".", "cat", "(", "[", "edge_weight", ",", "loop_weight", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "edge_index", "=", "torch", ".", "cat", "(", "[", "edge_index", ",", "loop_index", "]", ",", "dim", "=", "1", ")", "\n", "\n", "return", "edge_index", ",", "edge_weight", "\n", "\n", "", "def", "normalize_adj_tensor", "(", "adj", ",", "sparse", "=", "False", ")", ":", "\n", "    ", "\"\"\"Normalize adjacency tensor matrix.\n    \"\"\"", "\n", "# device = torch.device(\"cuda\" if adj.is_cuda else \"cpu\")", "\n", "device", "=", "adj", ".", "device", "\n", "if", "sparse", ":", "\n", "# warnings.warn('If you find the training process is too slow, you can uncomment line 207 in deeprobust/graph/utils.py. Note that you need to install torch_sparse')", "\n", "# TODO if this is too slow, uncomment the following code,", "\n", "# but you need to install torch_scatter", "\n", "# return normalize_sparse_tensor(adj)", "\n", "        ", "adj", "=", "to_scipy", "(", "adj", ")", "\n", "mx", "=", "normalize_adj", "(", "adj", ")", "\n", "return", "sparse_mx_to_torch_sparse_tensor", "(", "mx", ")", ".", "to", "(", "device", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.VGG.__init__": [[26, 30], ["torch.Module.__init__", "vgg.VGG._make_layers", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.VGG._make_layers"], ["def", "__init__", "(", "self", ",", "vgg_name", ")", ":", "\n", "        ", "super", "(", "VGG", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "features", "=", "self", ".", "_make_layers", "(", "cfg", "[", "vgg_name", "]", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "512", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.VGG.forward": [[31, 36], ["vgg.VGG.features", "vgg.VGG.view", "vgg.VGG.classifier", "vgg.VGG.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "features", "(", "x", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "classifier", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.VGG._make_layers": [[37, 50], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_layers", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "in_channels", "=", "3", "\n", "for", "x", "in", "cfg", ":", "\n", "            ", "if", "x", "==", "'M'", ":", "\n", "                ", "layers", "+=", "[", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "]", "\n", "", "else", ":", "\n", "                ", "layers", "+=", "[", "nn", ".", "Conv2d", "(", "in_channels", ",", "x", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "x", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "in_channels", "=", "x", "\n", "", "", "layers", "+=", "[", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.test": [[53, 84], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.cross_entropy", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "\"\"\"test.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    test_loader :\n        test_loader\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "#test_loss += F.nll_loss(output, target, reduction='sum').item()  # sum up batch loss", "\n", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.vgg.train": [[85, 117], ["model.train", "enumerate", "optimizer.zero_grad", "model", "torch.cross_entropy", "F.cross_entropy.backward", "optimizer.step", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "print", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "len", "len", "F.cross_entropy.item"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"train.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    train_loader :\n        train_loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "# lr = util.adjust_learning_rate(optimizer, epoch, args) # don't need it if we use Adam", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "        ", "data", ",", "target", "=", "torch", ".", "tensor", "(", "data", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "tensor", "(", "target", ")", ".", "to", "(", "device", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "# loss = F.nll_loss(output, target)", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", "/", "data", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.__init__": [[19, 40], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "int", "int"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "in_channel1", "=", "1", ",", "out_channel1", "=", "32", ",", "out_channel2", "=", "64", ",", "H", "=", "28", ",", "W", "=", "28", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "H", "=", "H", "\n", "self", ".", "W", "=", "W", "\n", "self", ".", "out_channel2", "=", "out_channel2", "\n", "\n", "## define two convolutional layers", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_channel1", ",", "\n", "out_channels", "=", "out_channel1", ",", "\n", "kernel_size", "=", "5", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "(", "2", ",", "2", ")", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "out_channel1", ",", "\n", "out_channels", "=", "out_channel2", ",", "\n", "kernel_size", "=", "5", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "(", "2", ",", "2", ")", ")", "\n", "\n", "## define two linear layers", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "int", "(", "H", "/", "4", ")", "*", "int", "(", "W", "/", "4", ")", "*", "out_channel2", ",", "1024", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "1024", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.forward": [[41, 50], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "CNN.Net.view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "CNN.Net.fc2", "CNN.Net.conv1", "CNN.Net.conv2", "CNN.Net.fc1", "int", "int"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "int", "(", "self", ".", "H", "/", "4", ")", "*", "int", "(", "self", ".", "W", "/", "4", ")", "*", "self", ".", "out_channel2", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.get_logits": [[51, 60], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "CNN.Net.view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "CNN.Net.fc2", "CNN.Net.conv1", "CNN.Net.conv2", "CNN.Net.fc1", "int", "int"], "methods", ["None"], ["", "def", "get_logits", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "int", "(", "self", ".", "H", "/", "4", ")", "*", "int", "(", "self", ".", "W", "/", "4", ")", "*", "self", ".", "out_channel2", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.train": [[61, 91], ["model.train", "enumerate", "optimizer.zero_grad", "model", "torch.cross_entropy", "F.cross_entropy.backward", "optimizer.step", "data.to", "target.to", "print", "len", "F.cross_entropy.item", "len", "len"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"train network.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device(option:'cpu','cuda')\n    train_loader :\n        training data loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "        ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.test": [[93, 122], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.cross_entropy().item", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "torch.cross_entropy", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "\"\"\"test network.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device(option:'cpu', 'cuda')\n    test_loader :\n        testing data loader\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.train_model.train": [[16, 100], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "train_model.feed_dataset", "torch.SGD", "lr_scheduler.StepLR", "range", "MODEL.Net().to", "MODEL.VGG().to.parameters", "print", "MODEL.train", "MODEL.test", "lr_scheduler.StepLR.step", "MODEL.ResNet18().to", "os.path.isdir", "MODEL.Net", "MODEL.ResNet34().to", "print", "torch.save", "torch.save", "torch.save", "torch.save", "os.mkdir", "print", "torch.save", "torch.save", "torch.save", "torch.save", "MODEL.ResNet18", "MODEL.ResNet50().to", "MODEL.VGG().to.state_dict", "MODEL.VGG().to.state_dict", "MODEL.ResNet34", "MODEL.densenet_cifar().to", "MODEL.ResNet50", "MODEL.VGG().to", "str", "str", "MODEL.densenet_cifar", "MODEL.VGG().to", "MODEL.VGG", "MODEL.VGG().to", "MODEL.VGG", "MODEL.VGG().to", "MODEL.VGG", "MODEL.VGG"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.train_model.feed_dataset", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet18", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet34", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet50", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.densenet_cifar", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "train", "(", "model", ",", "data", ",", "device", ",", "maxepoch", ",", "data_path", "=", "'./'", ",", "save_per_epoch", "=", "10", ",", "seed", "=", "100", ")", ":", "\n", "    ", "\"\"\"train.\n\n    Parameters\n    ----------\n    model :\n        model(option:'CNN', 'ResNet18', 'ResNet34', 'ResNet50', 'densenet', 'vgg11', 'vgg13', 'vgg16', 'vgg19')\n    data :\n        data(option:'MNIST','CIFAR10')\n    device :\n        device(option:'cpu', 'cuda')\n    maxepoch :\n        training epoch\n    data_path :\n        data path(default = './')\n    save_per_epoch :\n        save_per_epoch(default = 10)\n    seed :\n        seed\n\n    Examples\n    --------\n    >>>import deeprobust.image.netmodels.train_model as trainmodel\n    >>>trainmodel.train('CNN', 'MNIST', 'cuda', 20)\n    \"\"\"", "\n", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "\n", "train_loader", ",", "test_loader", "=", "feed_dataset", "(", "data", ",", "data_path", ")", "\n", "\n", "if", "(", "model", "==", "'CNN'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "CNN", "as", "MODEL", "\n", "#from deeprobust.image.netmodels.CNN import Net", "\n", "train_net", "=", "MODEL", ".", "Net", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "elif", "(", "model", "==", "'ResNet18'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "resnet", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "ResNet18", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "elif", "(", "model", "==", "'ResNet34'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "resnet", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "ResNet34", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "elif", "(", "model", "==", "'ResNet50'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "resnet", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "ResNet50", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "elif", "(", "model", "==", "'densenet'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "densenet", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "densenet_cifar", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "elif", "(", "model", "==", "'vgg11'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "vgg", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "VGG", "(", "'VGG11'", ")", ".", "to", "(", "device", ")", "\n", "", "elif", "(", "model", "==", "'vgg13'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "vgg", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "VGG", "(", "'VGG13'", ")", ".", "to", "(", "device", ")", "\n", "", "elif", "(", "model", "==", "'vgg16'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "vgg", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "VGG", "(", "'VGG16'", ")", ".", "to", "(", "device", ")", "\n", "", "elif", "(", "model", "==", "'vgg19'", ")", ":", "\n", "        ", "import", "deeprobust", ".", "image", ".", "netmodels", ".", "vgg", "as", "MODEL", "\n", "train_net", "=", "MODEL", ".", "VGG", "(", "'VGG19'", ")", ".", "to", "(", "device", ")", "\n", "\n", "\n", "\n", "", "optimizer", "=", "optim", ".", "SGD", "(", "train_net", ".", "parameters", "(", ")", ",", "lr", "=", "0.1", ",", "momentum", "=", "0.5", ")", "\n", "scheduler", "=", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "100", ",", "gamma", "=", "0.1", ")", "\n", "save_model", "=", "True", "\n", "for", "epoch", "in", "range", "(", "1", ",", "maxepoch", "+", "1", ")", ":", "## 5 batches", "\n", "\n", "        ", "print", "(", "epoch", ")", "\n", "MODEL", ".", "train", "(", "train_net", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", "\n", "MODEL", ".", "test", "(", "train_net", ",", "device", ",", "test_loader", ")", "\n", "\n", "if", "(", "save_model", "and", "(", "epoch", "%", "(", "save_per_epoch", ")", "==", "0", "or", "epoch", "==", "maxepoch", ")", ")", ":", "\n", "            ", "if", "os", ".", "path", ".", "isdir", "(", "'./trained_models/'", ")", ":", "\n", "                ", "print", "(", "'Save model.'", ")", "\n", "torch", ".", "save", "(", "train_net", ".", "state_dict", "(", ")", ",", "'./trained_models/'", "+", "data", "+", "\"_\"", "+", "model", "+", "\"_epoch_\"", "+", "str", "(", "epoch", ")", "+", "\".pt\"", ")", "\n", "", "else", ":", "\n", "                ", "os", ".", "mkdir", "(", "'./trained_models/'", ")", "\n", "print", "(", "'Make directory and save model.'", ")", "\n", "torch", ".", "save", "(", "train_net", ".", "state_dict", "(", ")", ",", "'./trained_models/'", "+", "data", "+", "\"_\"", "+", "model", "+", "\"_epoch_\"", "+", "str", "(", "epoch", ")", "+", "\".pt\"", ")", "\n", "", "", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.train_model.feed_dataset": [[101, 144], ["torchvision.transforms.Compose", "torchvision.transforms.Compose", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torchvision.transforms.RandomCrop", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.ToTensor", "torchvision.transforms.ToTensor", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize"], "function", ["None"], ["", "", "def", "feed_dataset", "(", "data", ",", "data_dict", ")", ":", "\n", "    ", "if", "(", "data", "==", "'CIFAR10'", ")", ":", "\n", "        ", "transform_train", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "RandomCrop", "(", "32", ",", "padding", "=", "5", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "#transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),", "\n", "]", ")", "\n", "\n", "transform_val", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "#transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),", "\n", "]", ")", "\n", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "CIFAR10", "(", "data_dict", ",", "train", "=", "True", ",", "download", "=", "True", ",", "\n", "transform", "=", "transform_train", ")", ",", "\n", "batch_size", "=", "128", ",", "shuffle", "=", "True", ")", "#, **kwargs)", "\n", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "CIFAR10", "(", "data_dict", ",", "train", "=", "False", ",", "download", "=", "True", ",", "\n", "transform", "=", "transform_val", ")", ",", "\n", "batch_size", "=", "1000", ",", "shuffle", "=", "True", ")", "#, **kwargs)", "\n", "\n", "", "elif", "(", "data", "==", "'MNIST'", ")", ":", "\n", "        ", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "MNIST", "(", "data_dict", ",", "train", "=", "True", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "(", "0.1307", ",", ")", ",", "(", "0.3081", ",", ")", ")", "]", ")", ")", ",", "\n", "batch_size", "=", "128", ",", "\n", "shuffle", "=", "True", ")", "\n", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "MNIST", "(", "'../data'", ",", "train", "=", "False", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "(", "0.1307", ",", ")", ",", "(", "0.3081", ",", ")", ")", "]", ")", ")", ",", "\n", "batch_size", "=", "1000", ",", "\n", "shuffle", "=", "True", ")", "\n", "\n", "", "elif", "(", "data", "==", "'ImageNet'", ")", ":", "\n", "        ", "pass", "\n", "\n", "", "return", "train_loader", ",", "test_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN_multilayer.Net.__init__": [[16, 37], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "int", "int"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel1", "=", "1", ",", "out_channel1", "=", "32", ",", "out_channel2", "=", "64", ",", "H", "=", "28", ",", "W", "=", "28", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "H", "=", "H", "\n", "self", ".", "W", "=", "W", "\n", "self", ".", "out_channel2", "=", "out_channel2", "\n", "\n", "## define two convolutional layers", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_channel1", ",", "\n", "out_channels", "=", "out_channel1", ",", "\n", "kernel_size", "=", "5", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "(", "2", ",", "2", ")", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "out_channel1", ",", "\n", "out_channels", "=", "out_channel2", ",", "\n", "kernel_size", "=", "5", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "(", "2", ",", "2", ")", ")", "\n", "\n", "## define two linear layers", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "int", "(", "H", "/", "4", ")", "*", "int", "(", "W", "/", "4", ")", "*", "out_channel2", ",", "1024", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "1024", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN_multilayer.Net.forward": [[38, 47], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "x.view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "CNN_multilayer.Net.fc2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "CNN_multilayer.Net.conv1", "CNN_multilayer.Net.conv2", "CNN_multilayer.Net.fc1", "int", "int"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "layers", "[", "0", "]", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "self", ".", "layers", "[", "1", "]", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "self", ".", "layers", "[", "2", "]", "=", "F", ".", "relu", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "self", ".", "layers", "[", "3", "]", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ",", "2", ")", "\n", "self", ".", "layers", "[", "4", "]", "=", "x", ".", "view", "(", "-", "1", ",", "int", "(", "self", ".", "H", "/", "4", ")", "*", "int", "(", "self", ".", "W", "/", "4", ")", "*", "self", ".", "out_channel2", ")", "\n", "self", ".", "layers", "[", "5", "]", "=", "F", ".", "relu", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "self", ".", "layers", "[", "6", "]", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "F", ".", "log_softmax", "(", "layers", "[", "6", "]", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN_multilayer.train": [[59, 89], ["model.train", "enumerate", "optimizer.zero_grad", "model", "torch.nll_loss", "F.nll_loss.backward", "optimizer.step", "data.to", "target.to", "print", "len", "F.nll_loss.item", "len", "len"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"train.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    train_loader :\n        train_loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "        ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "#print every 10", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN_multilayer.test": [[91, 120], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.nll_loss().item", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "torch.nll_loss", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "\"\"\"test.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    test_loader :\n        test_loader\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "test_loss", "+=", "F", ".", "nll_loss", "(", "output", ",", "target", ",", "reduction", "=", "'sum'", ")", ".", "item", "(", ")", "# sum up batch loss", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.BasicBlock.__init__": [[22, 34], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.BasicBlock.forward": [[36, 42], ["torch.relu", "torch.relu", "torch.relu", "resnet.BasicBlock.bn2", "resnet.BasicBlock.shortcut", "torch.relu", "torch.relu", "torch.relu", "resnet.BasicBlock.bn1", "resnet.BasicBlock.conv2", "resnet.BasicBlock.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.Bottleneck.__init__": [[47, 61], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.Bottleneck.forward": [[63, 70], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "resnet.Bottleneck.bn3", "resnet.Bottleneck.shortcut", "torch.relu", "torch.relu", "torch.relu", "resnet.Bottleneck.bn1", "resnet.Bottleneck.bn2", "resnet.Bottleneck.conv3", "resnet.Bottleneck.conv1", "resnet.Bottleneck.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.Net.__init__": [[73, 95], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "resnet.Net._make_layer", "resnet.Net._make_layer", "resnet.Net._make_layer", "resnet.Net._make_layer", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "num_classes", "=", "10", ")", ":", "\n", "        ", "\"\"\"__init__.\n\n        Parameters\n        ----------\n        block :\n            block\n        num_blocks :\n            num_blocks\n        num_classes :\n            num_classes\n        \"\"\"", "\n", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "64", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "num_blocks", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "num_blocks", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "num_blocks", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "num_blocks", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.Net._make_layer": [[96, 103], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.Net.forward": [[104, 114], ["torch.relu", "torch.relu", "torch.relu", "resnet.Net.layer1", "resnet.Net.layer2", "resnet.Net.layer3", "resnet.Net.layer4", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "resnet.Net.view", "resnet.Net.linear", "resnet.Net.bn1", "resnet.Net.size", "resnet.Net.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "layer4", "(", "out", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "4", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet18": [[116, 118], ["resnet.Net"], "function", ["None"], ["", "", "def", "ResNet18", "(", ")", ":", "\n", "    ", "return", "Net", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet34": [[119, 121], ["resnet.Net"], "function", ["None"], ["", "def", "ResNet34", "(", ")", ":", "\n", "    ", "return", "Net", "(", "BasicBlock", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet50": [[122, 124], ["resnet.Net"], "function", ["None"], ["", "def", "ResNet50", "(", ")", ":", "\n", "    ", "return", "Net", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet101": [[125, 127], ["resnet.Net"], "function", ["None"], ["", "def", "ResNet101", "(", ")", ":", "\n", "    ", "return", "Net", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "23", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.ResNet152": [[128, 130], ["resnet.Net"], "function", ["None"], ["", "def", "ResNet152", "(", ")", ":", "\n", "    ", "return", "Net", "(", "Bottleneck", ",", "[", "3", ",", "8", ",", "36", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.test": [[132, 151], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.cross_entropy", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "#test_loss += F.nll_loss(output, target, reduction='sum').item()  # sum up batch loss", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.resnet.train": [[152, 169], ["model.train", "enumerate", "optimizer.zero_grad", "model", "torch.cross_entropy", "F.cross_entropy.backward", "optimizer.step", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "print", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "F.cross_entropy.item", "len", "len"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "\n", "# lr = util.adjust_learning_rate(optimizer, epoch, args) # don't need it if we use Adam", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "        ", "data", ",", "target", "=", "torch", ".", "tensor", "(", "data", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "tensor", "(", "target", ")", ".", "to", "(", "device", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "# loss = F.nll_loss(output, target)", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.Bottleneck.__init__": [[17, 23], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "growth_rate", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "4", "*", "growth_rate", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "4", "*", "growth_rate", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "4", "*", "growth_rate", ",", "growth_rate", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.Bottleneck.forward": [[24, 29], ["densenet.Bottleneck.conv1", "densenet.Bottleneck.conv2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "densenet.Bottleneck.bn1", "densenet.Bottleneck.bn2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "F", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "conv2", "(", "F", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "x", "]", ",", "1", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.Transition.__init__": [[32, 36], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ")", ":", "\n", "        ", "super", "(", "Transition", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.Transition.forward": [[37, 41], ["densenet.Transition.conv", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "torch.relu", "torch.relu", "torch.relu", "densenet.Transition.bn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv", "(", "F", ".", "relu", "(", "self", ".", "bn", "(", "x", ")", ")", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "2", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet.__init__": [[48, 78], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "densenet.DenseNet._make_dense_layers", "int", "densenet.Transition", "densenet.DenseNet._make_dense_layers", "int", "densenet.Transition", "densenet.DenseNet._make_dense_layers", "int", "densenet.Transition", "densenet.DenseNet._make_dense_layers", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Linear", "torch.Linear", "torch.Linear", "math.floor", "math.floor", "math.floor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet._make_dense_layers", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet._make_dense_layers", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet._make_dense_layers", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet._make_dense_layers"], ["def", "__init__", "(", "self", ",", "block", ",", "nblocks", ",", "growth_rate", "=", "12", ",", "reduction", "=", "0.5", ",", "num_classes", "=", "10", ")", ":", "\n", "        ", "super", "(", "DenseNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "growth_rate", "=", "growth_rate", "\n", "\n", "num_planes", "=", "2", "*", "growth_rate", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "num_planes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "dense1", "=", "self", ".", "_make_dense_layers", "(", "block", ",", "num_planes", ",", "nblocks", "[", "0", "]", ")", "\n", "num_planes", "+=", "nblocks", "[", "0", "]", "*", "growth_rate", "\n", "out_planes", "=", "int", "(", "math", ".", "floor", "(", "num_planes", "*", "reduction", ")", ")", "\n", "self", ".", "trans1", "=", "Transition", "(", "num_planes", ",", "out_planes", ")", "\n", "num_planes", "=", "out_planes", "\n", "\n", "self", ".", "dense2", "=", "self", ".", "_make_dense_layers", "(", "block", ",", "num_planes", ",", "nblocks", "[", "1", "]", ")", "\n", "num_planes", "+=", "nblocks", "[", "1", "]", "*", "growth_rate", "\n", "out_planes", "=", "int", "(", "math", ".", "floor", "(", "num_planes", "*", "reduction", ")", ")", "\n", "self", ".", "trans2", "=", "Transition", "(", "num_planes", ",", "out_planes", ")", "\n", "num_planes", "=", "out_planes", "\n", "\n", "self", ".", "dense3", "=", "self", ".", "_make_dense_layers", "(", "block", ",", "num_planes", ",", "nblocks", "[", "2", "]", ")", "\n", "num_planes", "+=", "nblocks", "[", "2", "]", "*", "growth_rate", "\n", "out_planes", "=", "int", "(", "math", ".", "floor", "(", "num_planes", "*", "reduction", ")", ")", "\n", "self", ".", "trans3", "=", "Transition", "(", "num_planes", ",", "out_planes", ")", "\n", "num_planes", "=", "out_planes", "\n", "\n", "self", ".", "dense4", "=", "self", ".", "_make_dense_layers", "(", "block", ",", "num_planes", ",", "nblocks", "[", "3", "]", ")", "\n", "num_planes", "+=", "nblocks", "[", "3", "]", "*", "growth_rate", "\n", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "num_planes", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "num_planes", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet._make_dense_layers": [[79, 85], ["range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_dense_layers", "(", "self", ",", "block", ",", "in_planes", ",", "nblock", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nblock", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "in_planes", ",", "self", ".", "growth_rate", ")", ")", "\n", "in_planes", "+=", "self", ".", "growth_rate", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet.forward": [[86, 96], ["densenet.DenseNet.conv1", "densenet.DenseNet.trans1", "densenet.DenseNet.trans2", "densenet.DenseNet.trans3", "densenet.DenseNet.dense4", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "densenet.DenseNet.view", "densenet.DenseNet.linear", "densenet.DenseNet.dense1", "densenet.DenseNet.dense2", "densenet.DenseNet.dense3", "torch.relu", "torch.relu", "torch.relu", "densenet.DenseNet.size", "densenet.DenseNet.bn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "trans1", "(", "self", ".", "dense1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "trans2", "(", "self", ".", "dense2", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "trans3", "(", "self", ".", "dense3", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "dense4", "(", "out", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "F", ".", "relu", "(", "self", ".", "bn", "(", "out", ")", ")", ",", "4", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet121": [[97, 101], ["densenet.DenseNet"], "function", ["None"], ["", "", "def", "DenseNet121", "(", ")", ":", "\n", "    ", "\"\"\"DenseNet121.\n    \"\"\"", "\n", "return", "DenseNet", "(", "Bottleneck", ",", "[", "6", ",", "12", ",", "24", ",", "16", "]", ",", "growth_rate", "=", "32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet169": [[102, 106], ["densenet.DenseNet"], "function", ["None"], ["", "def", "DenseNet169", "(", ")", ":", "\n", "    ", "\"\"\"DenseNet169.\n    \"\"\"", "\n", "return", "DenseNet", "(", "Bottleneck", ",", "[", "6", ",", "12", ",", "32", ",", "32", "]", ",", "growth_rate", "=", "32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet201": [[107, 111], ["densenet.DenseNet"], "function", ["None"], ["", "def", "DenseNet201", "(", ")", ":", "\n", "    ", "\"\"\"DenseNet201.\n    \"\"\"", "\n", "return", "DenseNet", "(", "Bottleneck", ",", "[", "6", ",", "12", ",", "48", ",", "32", "]", ",", "growth_rate", "=", "32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.DenseNet161": [[112, 116], ["densenet.DenseNet"], "function", ["None"], ["", "def", "DenseNet161", "(", ")", ":", "\n", "    ", "\"\"\"DenseNet161.\n    \"\"\"", "\n", "return", "DenseNet", "(", "Bottleneck", ",", "[", "6", ",", "12", ",", "36", ",", "24", "]", ",", "growth_rate", "=", "48", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.densenet_cifar": [[117, 121], ["densenet.DenseNet"], "function", ["None"], ["", "def", "densenet_cifar", "(", ")", ":", "\n", "    ", "\"\"\"densenet_cifar.\n    \"\"\"", "\n", "return", "DenseNet", "(", "Bottleneck", ",", "[", "6", ",", "12", ",", "24", ",", "16", "]", ",", "growth_rate", "=", "12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.test": [[122, 153], ["model.eval", "len", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.cross_entropy", "model.argmax", "output.argmax.eq().sum().item", "len", "data.to", "target.to", "len", "output.argmax.eq().sum", "output.argmax.eq", "target.view_as"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "test", "(", "model", ",", "device", ",", "test_loader", ")", ":", "\n", "    ", "\"\"\"test.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    test_loader :\n        test_loader\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_loss", "=", "0", "\n", "correct", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", ",", "target", "in", "test_loader", ":", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "device", ")", ",", "target", ".", "to", "(", "device", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "#test_loss += F.nll_loss(output, target, reduction='sum').item()  # sum up batch loss", "\n", "\n", "test_loss", "+=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "pred", "=", "output", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "# get the index of the max log-probability", "\n", "correct", "+=", "pred", ".", "eq", "(", "target", ".", "view_as", "(", "pred", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "test_loss", "/=", "len", "(", "test_loader", ".", "dataset", ")", "\n", "\n", "print", "(", "'\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'", ".", "format", "(", "\n", "test_loss", ",", "correct", ",", "len", "(", "test_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train": [[154, 186], ["model.train", "enumerate", "optimizer.zero_grad", "model", "torch.cross_entropy", "F.cross_entropy.backward", "optimizer.step", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "print", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "len", "len", "F.cross_entropy.item"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "train", "(", "model", ",", "device", ",", "train_loader", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"train.\n\n    Parameters\n    ----------\n    model :\n        model\n    device :\n        device\n    train_loader :\n        train_loader\n    optimizer :\n        optimizer\n    epoch :\n        epoch\n    \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "# lr = util.adjust_learning_rate(optimizer, epoch, args) # don't need it if we use Adam", "\n", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "        ", "data", ",", "target", "=", "torch", ".", "tensor", "(", "data", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "tensor", "(", "target", ")", ".", "to", "(", "device", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "model", "(", "data", ")", "\n", "# loss = F.nll_loss(output, target)", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "output", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "batch_idx", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "'Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", "*", "len", "(", "data", ")", ",", "len", "(", "train_loader", ".", "dataset", ")", ",", "\n", "100.", "*", "batch_idx", "/", "len", "(", "train_loader", ")", ",", "loss", ".", "item", "(", ")", "/", "data", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.YOPOCNN.Net.__init__": [[15, 60], ["torch.Module.__init__", "torch.ReLU", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.ModuleList", "YOPOCNN.Net.other_layers.append", "YOPOCNN.Net.other_layers.append", "YOPOCNN.Net.modules", "torch.init.constant_", "torch.init.constant_", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "isinstance", "torch.init.kaiming_normal_", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.Conv2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.MaxPool2d", "torch.Linear", "torch.Dropout", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "drop", "=", "0.5", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_channels", "=", "1", "\n", "self", ".", "num_labels", "=", "10", "\n", "\n", "activ", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "self", ".", "num_channels", ",", "32", ",", "3", ")", "\n", "self", ".", "layer_one", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'conv1'", ",", "self", ".", "conv1", ")", ",", "\n", "(", "'relu1'", ",", "activ", ")", ",", "]", ")", ")", "\n", "\n", "self", ".", "feature_extractor", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'conv2'", ",", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "3", ")", ")", ",", "\n", "(", "'relu2'", ",", "activ", ")", ",", "\n", "(", "'maxpool1'", ",", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ")", ",", "\n", "(", "'conv3'", ",", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "3", ")", ")", ",", "\n", "(", "'relu3'", ",", "activ", ")", ",", "\n", "(", "'conv4'", ",", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "3", ")", ")", ",", "\n", "(", "'relu4'", ",", "activ", ")", ",", "\n", "(", "'maxpool2'", ",", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ")", ",", "\n", "]", ")", ")", "\n", "\n", "self", ".", "classifier", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'fc1'", ",", "nn", ".", "Linear", "(", "64", "*", "4", "*", "4", ",", "200", ")", ")", ",", "\n", "(", "'relu1'", ",", "activ", ")", ",", "\n", "(", "'drop'", ",", "nn", ".", "Dropout", "(", "drop", ")", ")", ",", "\n", "(", "'fc2'", ",", "nn", ".", "Linear", "(", "200", ",", "200", ")", ")", ",", "\n", "(", "'relu2'", ",", "activ", ")", ",", "\n", "(", "'fc3'", ",", "nn", ".", "Linear", "(", "200", ",", "self", ".", "num_labels", ")", ")", ",", "\n", "]", ")", ")", "\n", "self", ".", "other_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "other_layers", ".", "append", "(", "self", ".", "feature_extractor", ")", "\n", "self", ".", "other_layers", ".", "append", "(", "self", ".", "classifier", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "nn", ".", "init", ".", "constant_", "(", "self", ".", "classifier", ".", "fc3", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "classifier", ".", "fc3", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.YOPOCNN.Net.forward": [[61, 69], ["YOPOCNN.Net.layer_one", "YOPOCNN.Net.layer_one_out.requires_grad_", "YOPOCNN.Net.layer_one_out.retain_grad", "YOPOCNN.Net.feature_extractor", "YOPOCNN.Net.classifier", "YOPOCNN.Net.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "y", "=", "self", ".", "layer_one", "(", "input", ")", "\n", "self", ".", "layer_one_out", "=", "y", "\n", "self", ".", "layer_one_out", ".", "requires_grad_", "(", ")", "\n", "self", ".", "layer_one_out", ".", "retain_grad", "(", ")", "\n", "features", "=", "self", ".", "feature_extractor", "(", "y", ")", "\n", "logits", "=", "self", ".", "classifier", "(", "features", ".", "view", "(", "-", "1", ",", "64", "*", "4", "*", "4", ")", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActBlock.__init__": [[13, 23], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "PreActBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActBlock.forward": [[25, 32], ["torch.relu", "torch.relu", "torch.relu", "preact_resnet.PreActBlock.conv1", "preact_resnet.PreActBlock.conv2", "preact_resnet.PreActBlock.bn1", "hasattr", "preact_resnet.PreActBlock.shortcut", "torch.relu", "torch.relu", "torch.relu", "preact_resnet.PreActBlock.bn2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "if", "hasattr", "(", "self", ",", "'shortcut'", ")", "else", "x", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "F", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "+=", "shortcut", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActBottleneck.__init__": [[38, 50], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "PreActBottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActBottleneck.forward": [[52, 60], ["torch.relu", "torch.relu", "torch.relu", "preact_resnet.PreActBottleneck.conv1", "preact_resnet.PreActBottleneck.conv2", "preact_resnet.PreActBottleneck.conv3", "preact_resnet.PreActBottleneck.bn1", "hasattr", "preact_resnet.PreActBottleneck.shortcut", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "preact_resnet.PreActBottleneck.bn2", "preact_resnet.PreActBottleneck.bn3"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "shortcut", "=", "self", ".", "shortcut", "(", "out", ")", "if", "hasattr", "(", "self", ",", "'shortcut'", ")", "else", "x", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "F", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "conv3", "(", "F", ".", "relu", "(", "self", ".", "bn3", "(", "out", ")", ")", ")", "\n", "out", "+=", "shortcut", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet.__init__": [[66, 76], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "preact_resnet.PreActResNet._make_layer", "preact_resnet.PreActResNet._make_layer", "preact_resnet.PreActResNet._make_layer", "preact_resnet.PreActResNet._make_layer", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer"], ["def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "num_classes", "=", "10", ")", ":", "\n", "        ", "super", "(", "PreActResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "64", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "num_blocks", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "num_blocks", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "num_blocks", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "num_blocks", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "512", "*", "block", ".", "expansion", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet._make_layer": [[77, 84], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet.forward": [[85, 96], ["preact_resnet.PreActResNet.conv1", "preact_resnet.PreActResNet.layer1", "preact_resnet.PreActResNet.layer2", "preact_resnet.PreActResNet.layer3", "preact_resnet.PreActResNet.layer4", "torch.relu", "torch.relu", "torch.relu", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "preact_resnet.PreActResNet.view", "preact_resnet.PreActResNet.linear", "preact_resnet.PreActResNet.bn", "preact_resnet.PreActResNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "layer4", "(", "out", ")", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn", "(", "out", ")", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "4", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.preact_resnet.PreActResNet18": [[98, 102], ["preact_resnet.PreActResNet"], "function", ["None"], ["", "", "def", "PreActResNet18", "(", ")", ":", "\n", "    ", "\"\"\"PreActResNet18.\n    \"\"\"", "\n", "return", "PreActResNet", "(", "PreActBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.LBFGS.__init__": [[15, 17], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "label", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "super", "(", "LBFGS", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.LBFGS.generate": [[18, 44], ["lbfgs.LBFGS.check_type_device", "lbfgs.LBFGS.parse_params", "lbfgs.optimize"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.optimize"], ["", "def", "generate", "(", "self", ",", "image", ",", "label", ",", "target_label", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call this function to generate adversarial examples.\n\n        Parameters\n        ----------\n        image :\n            original image\n        label :\n            target label\n        kwargs :\n            user defined paremeters\n        \"\"\"", "\n", "assert", "self", ".", "check_type_device", "(", "image", ",", "label", ")", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "self", ".", "target_label", "=", "target_label", "\n", "adv_img", ",", "self", ".", "dist", ",", "self", ".", "loss", "=", "optimize", "(", "self", ".", "model", ",", "\n", "self", ".", "image", ",", "\n", "self", ".", "label", ",", "\n", "self", ".", "target_label", ",", "\n", "self", ".", "bounds", ",", "\n", "self", ".", "epsilon", ",", "\n", "self", ".", "maxiter", ",", "\n", "self", ".", "class_num", ",", "\n", "self", ".", "device", ")", "\n", "return", "adv_img", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.LBFGS.distance": [[45, 47], ["None"], "methods", ["None"], ["", "def", "distance", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.LBFGS.loss": [[48, 50], ["None"], "methods", ["None"], ["", "def", "loss", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.LBFGS.parse_params": [[51, 79], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "clip_max", "=", "1", ",", "\n", "clip_min", "=", "0", ",", "\n", "class_num", "=", "10", ",", "\n", "epsilon", "=", "1e-5", ",", "#step of finding initial c", "\n", "maxiter", "=", "20", ",", "#maximum of iteration in lbfgs optimization", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Parse the user defined parameters.\n\n        Parameters\n        ----------\n        clip_max :\n            maximum pixel value\n        clip_min :\n            minimum pixel value\n        class_num :\n            total number of class\n        epsilon :\n            step length for binary seach\n        maxiter :\n            maximum number of iterations\n        \"\"\"", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "maxiter", "=", "maxiter", "\n", "self", ".", "class_num", "=", "class_num", "\n", "self", ".", "bounds", "=", "(", "clip_min", ",", "clip_max", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.lbfgs.optimize": [[80, 209], ["image[].to().detach().numpy", "torch.tensor", "torch.tensor", "torch.tensor", "target_dist.unsqueeze_().long().to.unsqueeze_().long().to", "x0.flatten().astype.flatten().astype", "len", "print", "range", "print", "print", "lbfgs.optimize.lbfgs_b"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "optimize", "(", "model", ",", "image", ",", "label", ",", "target_label", ",", "bounds", ",", "epsilon", ",", "maxiter", ",", "class_num", ",", "device", ")", ":", "\n", "    ", "x_t", "=", "image", "\n", "x0", "=", "image", "[", "0", "]", ".", "to", "(", "'cpu'", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "min_", ",", "max_", "=", "bounds", "\n", "\n", "target_dist", "=", "torch", ".", "tensor", "(", "target_label", ")", "\n", "target_dist", "=", "target_dist", ".", "unsqueeze_", "(", "0", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "# store the shape for later and operate on the flattened input", "\n", "\n", "shape", "=", "x0", ".", "shape", "\n", "dtype", "=", "x0", ".", "dtype", "\n", "x0", "=", "x0", ".", "flatten", "(", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "n", "=", "len", "(", "x0", ")", "\n", "bounds", "=", "[", "(", "min_", ",", "max_", ")", "]", "*", "n", "\n", "\n", "def", "distance", "(", "x", ",", "y", ")", ":", "\n", "# calculate the distance", "\n", "        ", "x", "=", "torch", ".", "from_numpy", "(", "x", ")", ".", "double", "(", ")", "\n", "y", "=", "torch", ".", "from_numpy", "(", "y", ")", ".", "double", "(", ")", "\n", "\n", "dist_squ", "=", "torch", ".", "norm", "(", "x", "-", "y", ")", "\n", "return", "dist_squ", "**", "2", "\n", "\n", "", "def", "loss", "(", "x", ",", "c", ")", ":", "\n", "#calculate the target function", "\n", "        ", "v1", "=", "distance", "(", "x0", ",", "x", ")", "\n", "\n", "x", "=", "torch", ".", "tensor", "(", "x", ".", "astype", "(", "dtype", ")", ".", "reshape", "(", "shape", ")", ")", "\n", "x", "=", "x", ".", "unsqueeze_", "(", "0", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "predict", "=", "model", "(", "x", ")", "\n", "v2", "=", "F", ".", "nll_loss", "(", "predict", ",", "target_dist", ")", "\n", "\n", "v", "=", "c", "*", "v1", "+", "v2", "\n", "#print(v)", "\n", "return", "np", ".", "float64", "(", "v", ")", "\n", "\n", "", "def", "pending_attack", "(", "target_model", ",", "adv_exp", ",", "target_label", ")", ":", "\n", "# pending if the attack success", "\n", "        ", "adv_exp", "=", "adv_exp", ".", "reshape", "(", "shape", ")", ".", "astype", "(", "dtype", ")", "\n", "adv_exp", "=", "torch", ".", "from_numpy", "(", "adv_exp", ")", "\n", "adv_exp", "=", "adv_exp", ".", "unsqueeze_", "(", "0", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "predict1", "=", "target_model", "(", "adv_exp", ")", "\n", "label", "=", "predict1", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "if", "label", "==", "target_label", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "def", "lbfgs_b", "(", "c", ")", ":", "\n", "\n", "#initial the variables", "\n", "        ", "approx_grad_eps", "=", "(", "max_", "-", "min_", ")", "/", "100", "\n", "print", "(", "'in lbfgs_b:'", ",", "'c ='", ",", "c", ")", "\n", "\n", "#start optimization", "\n", "optimize_output", ",", "f", ",", "d", "=", "so", ".", "fmin_l_bfgs_b", "(", "\n", "loss", ",", "\n", "x0", ",", "\n", "args", "=", "(", "c", ",", ")", ",", "\n", "approx_grad", "=", "True", ",", "\n", "bounds", "=", "bounds", ",", "\n", "m", "=", "15", ",", "\n", "maxiter", "=", "maxiter", ",", "\n", "factr", "=", "1e10", ",", "#optimization accuracy", "\n", "maxls", "=", "5", ",", "\n", "epsilon", "=", "approx_grad_eps", ")", "\n", "print", "(", "'finish optimization'", ")", "\n", "\n", "# LBFGS-B does not always exactly respect the boundaries", "\n", "if", "np", ".", "amax", "(", "optimize_output", ")", ">", "max_", "or", "np", ".", "amin", "(", "optimize_output", ")", "<", "min_", ":", "# pragma: no coverage", "\n", "            ", "logging", ".", "info", "(", "'Input out of bounds (min, max = {}, {}). Performing manual clip.'", ".", "format", "(", "\n", "np", ".", "amin", "(", "optimize_output", ")", ",", "np", ".", "amax", "(", "optimize_output", ")", ")", ")", "\n", "\n", "optimize_output", "=", "np", ".", "clip", "(", "optimize_output", ",", "min_", ",", "max_", ")", "\n", "\n", "#optimize_output = optimize_output.reshape(shape).astype(dtype)", "\n", "#test_input = torch.from_numpy(optimize_output)", "\n", "#print(test_input)", "\n", "#test_input = test_input.unsqueeze_(0).float()", "\n", "", "is_adversarial", "=", "pending_attack", "(", "target_model", "=", "model", ",", "adv_exp", "=", "optimize_output", ",", "target_label", "=", "target_label", ")", "\n", "return", "optimize_output", ",", "is_adversarial", "\n", "\n", "#x_new, isadv = lbfgs_b(0)", "\n", "\n", "\n", "# finding initial c", "\n", "", "c", "=", "epsilon", "\n", "print", "(", "'finding initial c:'", ")", "\n", "\n", "for", "i", "in", "range", "(", "30", ")", ":", "\n", "        ", "c", "=", "2", "*", "c", "\n", "x_new", ",", "is_adversarial", "=", "lbfgs_b", "(", "c", ")", "\n", "if", "is_adversarial", "==", "False", ":", "\n", "            ", "break", "\n", "\n", "", "", "print", "(", "'start binary search:'", ")", "\n", "if", "is_adversarial", "==", "True", ":", "# pragma: no cover", "\n", "        ", "print", "(", "'Could not find an adversarial; maybe the model returns wrong gradients'", ")", "\n", "return", "\n", "\n", "", "print", "(", "'c_high:'", ",", "c", ")", "\n", "\n", "# binary search", "\n", "c_low", "=", "0", "\n", "c_high", "=", "c", "\n", "while", "c_high", "-", "c_low", ">=", "epsilon", ":", "\n", "        ", "print", "(", "c_high", ",", "' '", ",", "c_low", ")", "\n", "c_half", "=", "(", "c_low", "+", "c_high", ")", "/", "2", "\n", "x_new", ",", "is_adversarial", "=", "lbfgs_b", "(", "c_half", ")", "\n", "\n", "if", "is_adversarial", ":", "\n", "            ", "c_low", "=", "c_half", "\n", "", "else", ":", "\n", "            ", "c_high", "=", "c_half", "\n", "\n", "", "", "x_new", ",", "is_adversarial", "=", "lbfgs_b", "(", "c_low", ")", "\n", "dis", "=", "distance", "(", "x_new", ",", "x0", ")", "\n", "mintargetfunc", "=", "loss", "(", "x_new", ",", "c_low", ")", "\n", "\n", "x_new", "=", "x_new", ".", "astype", "(", "dtype", ")", "\n", "x_new", "=", "x_new", ".", "reshape", "(", "shape", ")", "\n", "\n", "x_new", "=", "torch", ".", "from_numpy", "(", "x_new", ")", ".", "unsqueeze_", "(", "0", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "return", "x_new", ",", "dis", ",", "mintargetfunc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.__init__": [[40, 44], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "super", "(", "CarliniWagner", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.generate": [[45, 73], ["cw.CarliniWagner.check_type_device", "cw.CarliniWagner.parse_params", "cw.CarliniWagner.cw"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.cw"], ["", "def", "generate", "(", "self", ",", "image", ",", "label", ",", "target_label", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call this function to generate adversarial examples.\n\n        Parameters\n        ----------\n        image :\n            original image\n        label :\n            target label\n        kwargs :\n            user defined paremeters\n        \"\"\"", "\n", "\n", "assert", "self", ".", "check_type_device", "(", "image", ",", "label", ")", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "self", ".", "target", "=", "target_label", "\n", "return", "self", ".", "cw", "(", "self", ".", "model", ",", "\n", "self", ".", "image", ",", "\n", "self", ".", "label", ",", "\n", "self", ".", "target", ",", "\n", "self", ".", "confidence", ",", "\n", "self", ".", "clip_max", ",", "\n", "self", ".", "clip_min", ",", "\n", "self", ".", "max_iterations", ",", "\n", "self", ".", "initial_const", ",", "\n", "self", ".", "binary_search_steps", ",", "\n", "self", ".", "learning_rate", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.parse_params": [[75, 120], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "classnum", "=", "10", ",", "\n", "confidence", "=", "1e-4", ",", "\n", "clip_max", "=", "1", ",", "\n", "clip_min", "=", "0", ",", "\n", "max_iterations", "=", "1000", ",", "\n", "initial_const", "=", "1e-2", ",", "\n", "binary_search_steps", "=", "5", ",", "\n", "learning_rate", "=", "0.00001", ",", "\n", "abort_early", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parse the user defined parameters.\n\n        Parameters\n        ----------\n        classnum :\n            number of class\n        confidence :\n            confidence\n        clip_max :\n            maximum pixel value\n        clip_min :\n            minimum pixel value\n        max_iterations :\n            maximum number of iterations\n        initial_const :\n            initialization of binary search\n        binary_search_steps :\n            step number of binary search\n        learning_rate :\n            learning rate\n        abort_early :\n            Set abort_early = True to allow early stop\n        \"\"\"", "\n", "\n", "self", ".", "classnum", "=", "classnum", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "abort_early", "=", "abort_early", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.cw": [[121, 195], ["cw.CarliniWagner.to_attack_space", "cw.CarliniWagner.to_model_space", "img_ori.to.to.to", "range", "img_adv.to.to.detach", "image.cpu", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "deeprobust.image.optimizer.AdamOptimizer", "range", "cw.CarliniWagner.numpy", "cw.CarliniWagner.to_model_space", "img_adv.to.to.to", "model.get_logits", "cw.CarliniWagner.pending_f", "cw.CarliniWagner.loss_function", "print", "print", "adv_grid.to", "loss_grad.to", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "deeprobust.image.optimizer.AdamOptimizer.", "gradient.cpu().detach().numpy", "gradient.cpu().detach", "gradient.cpu"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.to_attack_space", "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.to_model_space", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.to_model_space", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.get_logits", "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.pending_f", "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.loss_function", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "cw", "(", "self", ",", "model", ",", "image", ",", "label", ",", "target", ",", "confidence", ",", "clip_max", ",", "clip_min", ",", "max_iterations", ",", "initial_const", ",", "binary_search_steps", ",", "learning_rate", ")", ":", "\n", "#change the input image", "\n", "        ", "img_tanh", "=", "self", ".", "to_attack_space", "(", "image", ".", "cpu", "(", ")", ")", "\n", "img_ori", ",", "_", "=", "self", ".", "to_model_space", "(", "img_tanh", ")", "\n", "img_ori", "=", "img_ori", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "#binary search initialization", "\n", "c", "=", "initial_const", "\n", "c_low", "=", "0", "\n", "c_high", "=", "np", ".", "inf", "\n", "found_adv", "=", "False", "\n", "last_loss", "=", "np", ".", "inf", "\n", "\n", "for", "step", "in", "range", "(", "binary_search_steps", ")", ":", "\n", "\n", "#initialize w : perturbed image in tanh space", "\n", "            ", "w", "=", "torch", ".", "from_numpy", "(", "img_tanh", ".", "numpy", "(", ")", ")", "\n", "\n", "optimizer", "=", "AdamOptimizer", "(", "img_tanh", ".", "shape", ")", "\n", "\n", "is_adversarial", "=", "False", "\n", "\n", "for", "iteration", "in", "range", "(", "max_iterations", ")", ":", "\n", "\n", "# adversary example", "\n", "                ", "img_adv", ",", "adv_grid", "=", "self", ".", "to_model_space", "(", "w", ")", "\n", "img_adv", "=", "img_adv", ".", "to", "(", "self", ".", "device", ")", "\n", "img_adv", ".", "requires_grad", "=", "True", "\n", "\n", "#output of the layer before softmax", "\n", "output", "=", "model", ".", "get_logits", "(", "img_adv", ")", "\n", "\n", "#pending success", "\n", "is_adversarial", "=", "self", ".", "pending_f", "(", "img_adv", ")", "\n", "\n", "#calculate loss function and gradient of loss funcition on x", "\n", "loss", ",", "loss_grad", "=", "self", ".", "loss_function", "(", "\n", "img_adv", ",", "c", ",", "self", ".", "target", ",", "img_ori", ",", "self", ".", "confidence", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", "\n", ")", "\n", "\n", "\n", "#calculate gradient of loss function on w", "\n", "gradient", "=", "adv_grid", ".", "to", "(", "self", ".", "device", ")", "*", "loss_grad", ".", "to", "(", "self", ".", "device", ")", "\n", "w", "=", "w", "+", "torch", ".", "from_numpy", "(", "optimizer", "(", "gradient", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "learning_rate", ")", ")", ".", "float", "(", ")", "\n", "\n", "if", "is_adversarial", ":", "\n", "                    ", "found_adv", "=", "True", "\n", "\n", "#do binary search on c", "\n", "", "", "if", "found_adv", ":", "\n", "                ", "c_high", "=", "c", "\n", "", "else", ":", "\n", "                ", "c_low", "=", "c", "\n", "\n", "", "if", "c_high", "==", "np", ".", "inf", ":", "\n", "                ", "c", "*=", "10", "\n", "", "else", ":", "\n", "                ", "c", "=", "(", "c_high", "+", "c_low", ")", "/", "2", "\n", "\n", "", "if", "(", "step", "%", "10", "==", "0", ")", ":", "\n", "                ", "print", "(", "\"iteration:{:.0f},loss:{:.4f}\"", ".", "format", "(", "step", ",", "loss", ")", ")", "\n", "\n", "# if (step == 50):", "\n", "#     learning_rate = learning_rate/100", "\n", "\n", "#abort early", "\n", "", "if", "(", "self", ".", "abort_early", "==", "True", "and", "(", "step", "%", "10", ")", "==", "0", "and", "step", ">", "100", ")", ":", "\n", "                ", "print", "(", "\"early abortion?\"", ",", "loss", ",", "last_loss", ")", "\n", "if", "not", "(", "loss", "<=", "0.9999", "*", "last_loss", ")", ":", "\n", "                    ", "break", "\n", "", "last_loss", "=", "loss", "\n", "\n", "\n", "", "", "return", "img_adv", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.loss_function": [[196, 235], ["cw.CarliniWagner.model.get_logits().to", "torch.from_numpy().double", "torch.from_numpy().double", "torch.from_numpy().double", "torch.from_numpy().double", "numpy.argmax", "max", "max.backward", "numpy.sum", "cw.CarliniWagner.model.get_logits", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "deeprobust.image.utils.onehot_like", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.zeros", "numpy.ones", "cw.CarliniWagner.double"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.get_logits", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.onehot_like"], ["", "def", "loss_function", "(", "\n", "self", ",", "x_p", ",", "const", ",", "target", ",", "reconstructed_original", ",", "confidence", ",", "min_", ",", "max_", ")", ":", "\n", "        ", "\"\"\"Returns the loss and the gradient of the loss w.r.t. x,\n        assuming that logits = model(x).\"\"\"", "\n", "\n", "## get the output of model before softmax", "\n", "x_p", ".", "requires_grad", "=", "True", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_p", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "## find the largest class except the target class", "\n", "targetlabel_mask", "=", "(", "torch", ".", "from_numpy", "(", "onehot_like", "(", "np", ".", "zeros", "(", "self", ".", "classnum", ")", ",", "target", ")", ")", ")", ".", "double", "(", ")", "\n", "secondlargest_mask", "=", "(", "torch", ".", "from_numpy", "(", "np", ".", "ones", "(", "self", ".", "classnum", ")", ")", "-", "targetlabel_mask", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "secondlargest", "=", "np", ".", "argmax", "(", "(", "logits", ".", "double", "(", ")", "*", "secondlargest_mask", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "is_adv_loss", "=", "logits", "[", "0", "]", "[", "secondlargest", "]", "-", "logits", "[", "0", "]", "[", "target", "]", "\n", "\n", "# is_adv is True as soon as the is_adv_loss goes below 0", "\n", "# but sometimes we want additional confidence", "\n", "is_adv_loss", "+=", "confidence", "\n", "\n", "if", "is_adv_loss", "==", "0", ":", "\n", "            ", "is_adv_loss_grad", "=", "0", "\n", "", "else", ":", "\n", "            ", "is_adv_loss", ".", "backward", "(", ")", "\n", "is_adv_loss_grad", "=", "x_p", ".", "grad", "\n", "\n", "", "is_adv_loss", "=", "max", "(", "0", ",", "is_adv_loss", ")", "\n", "\n", "s", "=", "max_", "-", "min_", "\n", "squared_l2_distance", "=", "np", ".", "sum", "(", "(", "(", "x_p", "-", "reconstructed_original", ")", "**", "2", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "/", "s", "**", "2", "\n", "total_loss", "=", "squared_l2_distance", "+", "const", "*", "is_adv_loss", "\n", "\n", "\n", "squared_l2_distance_grad", "=", "(", "2", "/", "s", "**", "2", ")", "*", "(", "x_p", "-", "reconstructed_original", ")", "\n", "\n", "#print(is_adv_loss_grad)", "\n", "total_loss_grad", "=", "squared_l2_distance_grad", "+", "const", "*", "is_adv_loss_grad", "\n", "return", "total_loss", ",", "total_loss_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.pending_f": [[236, 251], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "targetlabel_mask.to.to.to", "secondlargest_mask.to.to.to", "numpy.max", "numpy.max", "deeprobust.image.utils.onehot_like", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.zeros", "numpy.ones", "cw.CarliniWagner.model.get_logits().double().to", "cw.CarliniWagner.model.get_logits().double().to", "cw.CarliniWagner.model.get_logits().double", "cw.CarliniWagner.model.get_logits().double", "cw.CarliniWagner.model.get_logits", "cw.CarliniWagner.model.get_logits"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.image.utils.onehot_like", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.get_logits", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.CNN.Net.get_logits"], ["", "def", "pending_f", "(", "self", ",", "x_p", ")", ":", "\n", "        ", "\"\"\"Pending is the loss function is less than 0\n        \"\"\"", "\n", "targetlabel_mask", "=", "torch", ".", "from_numpy", "(", "onehot_like", "(", "np", ".", "zeros", "(", "self", ".", "classnum", ")", ",", "self", ".", "target", ")", ")", "\n", "secondlargest_mask", "=", "torch", ".", "from_numpy", "(", "np", ".", "ones", "(", "self", ".", "classnum", ")", ")", "-", "targetlabel_mask", "\n", "targetlabel_mask", "=", "targetlabel_mask", ".", "to", "(", "self", ".", "device", ")", "\n", "secondlargest_mask", "=", "secondlargest_mask", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "Zx_i", "=", "np", ".", "max", "(", "(", "self", ".", "model", ".", "get_logits", "(", "x_p", ")", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "*", "secondlargest_mask", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "Zx_t", "=", "np", ".", "max", "(", "(", "self", ".", "model", ".", "get_logits", "(", "x_p", ")", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "*", "targetlabel_mask", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "if", "(", "Zx_i", "-", "Zx_t", "<", "-", "self", ".", "confidence", ")", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.to_attack_space": [[252, 265], ["x.detach.detach.detach", "numpy.arctanh"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.arctanh"], ["", "", "def", "to_attack_space", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "detach", "(", ")", "\n", "# map from [min_, max_] to [-1, +1]", "\n", "# x'=(x- 0.5 * (max+min) / 0.5 * (max-min))", "\n", "a", "=", "(", "self", ".", "clip_min", "+", "self", ".", "clip_max", ")", "/", "2", "\n", "b", "=", "(", "self", ".", "clip_max", "-", "self", ".", "clip_min", ")", "/", "2", "\n", "x", "=", "(", "x", "-", "a", ")", "/", "b", "\n", "\n", "# from [-1, +1] to approx. (-1, +1)", "\n", "x", "=", "x", "*", "0.999999", "\n", "\n", "# from (-1, +1) to (-inf, +inf)", "\n", "return", "np", ".", "arctanh", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.cw.CarliniWagner.to_model_space": [[266, 283], ["numpy.tanh", "numpy.square"], "methods", ["None"], ["", "def", "to_model_space", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Transforms an input from the attack space\n        to the model space. This transformation and\n        the returned gradient are elementwise.\"\"\"", "\n", "\n", "# from (-inf, +inf) to (-1, +1)", "\n", "x", "=", "np", ".", "tanh", "(", "x", ")", "\n", "\n", "grad", "=", "1", "-", "np", ".", "square", "(", "x", ")", "\n", "\n", "# map from (-1, +1) to (min_, max_)", "\n", "a", "=", "(", "self", ".", "clip_min", "+", "self", ".", "clip_max", ")", "/", "2", "\n", "b", "=", "(", "self", ".", "clip_max", "-", "self", ".", "clip_min", ")", "/", "2", "\n", "x", "=", "x", "*", "b", "+", "a", "\n", "\n", "grad", "=", "grad", "*", "b", "\n", "return", "x", ",", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.parse_params": [[12, 28], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "gan", ",", "confidence", "=", "0", ",", "targeted", "=", "False", ",", "learning_rate", "=", "1e-1", ",", "\n", "binary_search_steps", "=", "5", ",", "max_iterations", "=", "10000", ",", "abort_early", "=", "False", ",", "initial_const", "=", "1", ",", "\n", "clip_min", "=", "0", ",", "clip_max", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "TARGETED", "=", "targeted", "\n", "self", ".", "LEARNING_RATE", "=", "learning_rate", "\n", "self", ".", "MAX_ITERATIONS", "=", "max_iterations", "\n", "self", ".", "BINARY_SEARCH_STEPS", "=", "binary_search_steps", "\n", "self", ".", "ABORT_EARLY", "=", "abort_early", "\n", "self", ".", "CONFIDENCE", "=", "confidence", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "gan", "=", "gan", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "repeat", "=", "binary_search_steps", ">=", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.get_or_guess_labels": [[29, 45], ["labels.float", "torch.softmax", "torch.softmax", "torch.softmax", "l2_attack.CarliniL2.model", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["None"], ["", "def", "get_or_guess_labels", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Get the label to use in generating an adversarial example for x.\n        The kwargs are fed directly from the kwargs of the attack.\n        If 'y' is in kwargs, use that as the label.\n        Otherwise, use the model's prediction as the label.\n        \"\"\"", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "labels", "=", "y", "\n", "", "else", ":", "\n", "            ", "preds", "=", "F", ".", "softmax", "(", "self", ".", "model", "(", "x", ")", ")", "\n", "preds_max", "=", "torch", ".", "max", "(", "preds", ",", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "original_predictions", "=", "(", "preds", "==", "preds_max", ")", "\n", "labels", "=", "original_predictions", "\n", "del", "preds", "\n", "", "return", "labels", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.atanh": [[46, 48], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "atanh", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "0.5", "*", "torch", ".", "log", "(", "(", "1", "+", "x", ")", "/", "(", "1", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.to_one_hot": [[49, 55], ["torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "one_hot.scatter_.scatter_.zero_", "x.unsqueeze.unsqueeze.unsqueeze", "one_hot.scatter_.scatter_.scatter_", "x.unsqueeze.unsqueeze.get_device", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "to_one_hot", "(", "self", ",", "x", ")", ":", "\n", "        ", "one_hot", "=", "torch", ".", "FloatTensor", "(", "x", ".", "shape", "[", "0", "]", ",", "10", ")", ".", "to", "(", "x", ".", "get_device", "(", ")", ")", "\n", "one_hot", ".", "zero_", "(", ")", "\n", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "\n", "one_hot", "=", "one_hot", ".", "scatter_", "(", "1", ",", "x", ",", "1", ")", "\n", "return", "one_hot", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.generate": [[56, 175], ["l2_attack.CarliniL2.get_or_guess_labels", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "l2_attack.CarliniL2.gan", "range", "numpy.array", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "len", "l2_attack.CarliniL2.to_one_hot", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "range", "range", "sum", "torch.argmax.clone", "torch.argmax.clone", "torch.argmax.clone", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "l2_attack.CarliniL2.long", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.optim.Adam.zero_grad", "torch.optim.Adam.zero_grad", "torch.optim.Adam.zero_grad", "l2_attack.CarliniL2.gan", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "l2_attack.CarliniL2.model", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "loss.backward", "torch.optim.Adam.step", "torch.optim.Adam.step", "torch.optim.Adam.step", "enumerate", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.Parameter.to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "zip", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "l2_attack.CarliniL2.generate.compare"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.get_or_guess_labels", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.l2_attack.CarliniL2.to_one_hot", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "generate", "(", "self", ",", "imgs", ",", "y", ",", "start", ")", ":", "\n", "\n", "        ", "batch_size", "=", "imgs", ".", "shape", "[", "0", "]", "\n", "labs", "=", "self", ".", "get_or_guess_labels", "(", "imgs", ",", "y", ")", "\n", "\n", "def", "compare", "(", "x", ",", "y", ")", ":", "\n", "            ", "if", "self", ".", "TARGETED", "is", "None", ":", "return", "True", "\n", "\n", "if", "sum", "(", "x", ".", "shape", ")", "!=", "0", ":", "\n", "                ", "x", "=", "x", ".", "clone", "(", ")", "\n", "if", "self", ".", "TARGETED", ":", "\n", "                    ", "x", "[", "y", "]", "-=", "self", ".", "CONFIDENCE", "\n", "", "else", ":", "\n", "                    ", "x", "[", "y", "]", "+=", "self", ".", "CONFIDENCE", "\n", "", "x", "=", "torch", ".", "argmax", "(", "x", ")", "\n", "", "if", "self", ".", "TARGETED", ":", "\n", "                ", "return", "x", "==", "y", "\n", "", "else", ":", "\n", "                ", "return", "x", "!=", "y", "\n", "\n", "# set the lower and upper bounds accordingly", "\n", "", "", "lower_bound", "=", "torch", ".", "zeros", "(", "batch_size", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "CONST", "=", "torch", ".", "ones", "(", "batch_size", ")", ".", "to", "(", "self", ".", "device", ")", "*", "self", ".", "initial_const", "\n", "upper_bound", "=", "(", "torch", ".", "ones", "(", "batch_size", ")", "*", "1e10", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# the best l2, score, and image attack", "\n", "o_bestl2", "=", "[", "1e10", "]", "*", "batch_size", "\n", "o_bestscore", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "o_bestattack", "=", "self", ".", "gan", "(", "start", ")", "\n", "\n", "# check if the input label is one-hot, if not, then change it into one-hot vector", "\n", "if", "len", "(", "labs", ".", "shape", ")", "==", "1", ":", "\n", "            ", "tlabs", "=", "self", ".", "to_one_hot", "(", "labs", ".", "long", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "tlabs", "=", "labs", "\n", "\n", "", "for", "outer_step", "in", "range", "(", "self", ".", "BINARY_SEARCH_STEPS", ")", ":", "\n", "# completely reset adam's internal state.", "\n", "            ", "modifier", "=", "nn", ".", "Parameter", "(", "start", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "[", "modifier", ",", "]", ",", "lr", "=", "self", ".", "learning_rate", ")", "\n", "\n", "bestl2", "=", "[", "1e10", "]", "*", "batch_size", "\n", "bestscore", "=", "-", "1", "*", "torch", ".", "ones", "(", "batch_size", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# The last iteration (if we run many steps) repeat the search once.", "\n", "if", "self", ".", "repeat", "and", "outer_step", "==", "self", ".", "BINARY_SEARCH_STEPS", "-", "1", ":", "\n", "                ", "CONST", "=", "upper_bound", "\n", "", "prev", "=", "1e6", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "MAX_ITERATIONS", ")", ":", "\n", "                ", "optimizer", ".", "zero_grad", "(", ")", "\n", "nimgs", "=", "self", ".", "gan", "(", "modifier", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "\n", "# distance to the input data", "\n", "l2dist", "=", "torch", ".", "sum", "(", "torch", ".", "sum", "(", "torch", ".", "sum", "(", "(", "nimgs", "-", "imgs", ")", "**", "2", ",", "1", ")", ",", "1", ")", ",", "1", ")", "\n", "loss2", "=", "torch", ".", "sum", "(", "l2dist", ")", "\n", "\n", "# prediction BEFORE-SOFTMAX of the model", "\n", "scores", "=", "self", ".", "model", "(", "nimgs", ")", "\n", "\n", "# compute the probability of the label class versus the maximum other", "\n", "other", "=", "torch", ".", "max", "(", "(", "(", "1", "-", "tlabs", ")", "*", "scores", "-", "tlabs", "*", "10000", ")", ",", "1", ")", "[", "0", "]", "\n", "real", "=", "torch", ".", "sum", "(", "tlabs", "*", "scores", ",", "1", ")", "\n", "\n", "if", "self", ".", "TARGETED", ":", "\n", "# if targeted, optimize for making the other class most likely", "\n", "                    ", "loss1", "=", "torch", ".", "max", "(", "torch", ".", "zeros_like", "(", "other", ")", ",", "other", "-", "real", "+", "self", ".", "CONFIDENCE", ")", "\n", "", "else", ":", "\n", "# if untargeted, optimize for making this class least likely.", "\n", "                    ", "loss1", "=", "torch", ".", "max", "(", "torch", ".", "zeros_like", "(", "other", ")", ",", "real", "-", "other", "+", "self", ".", "CONFIDENCE", ")", "\n", "\n", "# sum up the losses", "\n", "", "loss1", "=", "torch", ".", "sum", "(", "CONST", "*", "loss1", ")", "\n", "loss", "=", "loss1", "+", "loss2", "\n", "\n", "# update the modifier", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# check if we should abort search if we're getting nowhere.", "\n", "if", "self", ".", "ABORT_EARLY", "and", "i", "%", "(", "(", "self", ".", "MAX_ITERATIONS", "//", "10", ")", "or", "1", ")", "==", "0", ":", "\n", "                    ", "if", "loss", ">", "prev", "*", ".9999", ":", "\n", "# print('Stop early')", "\n", "                        ", "break", "\n", "", "prev", "=", "loss", "\n", "\n", "# adjust the best result found so far", "\n", "", "for", "e", ",", "(", "l2", ",", "sc", ",", "ii", ")", "in", "enumerate", "(", "zip", "(", "l2dist", ",", "scores", ",", "nimgs", ")", ")", ":", "\n", "                    ", "lab", "=", "torch", ".", "argmax", "(", "tlabs", "[", "e", "]", ")", "\n", "\n", "if", "l2", "<", "bestl2", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "                        ", "bestl2", "[", "e", "]", "=", "l2", "\n", "bestscore", "[", "e", "]", "=", "torch", ".", "argmax", "(", "sc", ")", "\n", "\n", "", "if", "l2", "<", "o_bestl2", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "                        ", "o_bestl2", "[", "e", "]", "=", "l2", "\n", "o_bestscore", "[", "e", "]", "=", "torch", ".", "argmax", "(", "sc", ")", "\n", "o_bestattack", "[", "e", "]", "=", "ii", "\n", "\n", "# adjust the constant as needed", "\n", "", "", "", "for", "e", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "if", "compare", "(", "bestscore", "[", "e", "]", ",", "torch", ".", "argmax", "(", "tlabs", "[", "e", "]", ")", ".", "float", "(", ")", ")", "and", "bestscore", "[", "e", "]", "!=", "-", "1", ":", "\n", "# success, divide CONST by two", "\n", "                    ", "upper_bound", "[", "e", "]", "=", "min", "(", "upper_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "                        ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "# failure, either multiply by 10 if no solution found yet", "\n", "#          or do binary search with the known upper bound", "\n", "                    ", "lower_bound", "[", "e", "]", "=", "max", "(", "lower_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "                        ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "                        ", "CONST", "[", "e", "]", "*=", "10", "\n", "\n", "# return the best solution found", "\n", "", "", "", "", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "return", "o_bestattack", "", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.fgsm.FGSM.__init__": [[16, 19], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "\n", "        ", "super", "(", "FGSM", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.fgsm.FGSM.generate": [[20, 48], ["label.type.type.type", "fgsm.FGSM.check_type_device", "fgsm.FGSM.parse_params", "fgsm.fgm"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.fgsm.fgm"], ["", "def", "generate", "(", "self", ",", "image", ",", "label", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\"\n        Call this function to generate FGSM adversarial examples.\n\n        Parameters\n        ----------\n        image :\n            original image\n        label :\n            target label\n        kwargs :\n            user defined paremeters\n        \"\"\"", "\n", "\n", "label", "=", "label", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "\n", "## check and parse parameters for attack", "\n", "assert", "self", ".", "check_type_device", "(", "image", ",", "label", ")", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "return", "fgm", "(", "self", ".", "model", ",", "\n", "self", ".", "image", ",", "\n", "self", ".", "label", ",", "\n", "self", ".", "epsilon", ",", "\n", "self", ".", "order", ",", "\n", "self", ".", "clip_min", ",", "\n", "self", ".", "clip_max", ",", "\n", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.fgsm.FGSM.parse_params": [[49, 82], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "epsilon", "=", "0.2", ",", "\n", "order", "=", "np", ".", "inf", ",", "\n", "clip_max", "=", "None", ",", "\n", "clip_min", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parse the user defined parameters.\n        :param model: victim model\n        :param image: original attack images\n        :param label: target labels\n        :param epsilon: perturbation constraint\n        :param order: constraint type\n        :param clip_min: minimum pixel value\n        :param clip_max: maximum pixel value\n        :param device: device type, cpu or gpu\n\n        :type image: [N*C*H*W],floatTensor\n        :type label: int\n        :type epsilon: float\n        :type order: int\n        :type clip_min: float\n        :type clip_max: float\n        :type device: string('cpu' or 'cuda')\n\n        :return: perturbed images\n        :rtype: [N*C*H*W], floatTensor\n\n        \"\"\"", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "order", "=", "order", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.fgsm.fgm": [[84, 120], ["image.cpu().detach().numpy", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.SGD", "optim.SGD.zero_grad", "loss.backward", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.CrossEntropyLoss", "model", "image.cpu().detach", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().to.grad.data.sign", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "ValueError", "image.cpu", "numpy.linalg.norm", "gradient[].data.cpu().numpy", "gradient[].data.cpu"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "", "def", "fgm", "(", "model", ",", "image", ",", "label", ",", "epsilon", ",", "order", ",", "clip_min", ",", "clip_max", ",", "device", ")", ":", "\n", "    ", "imageArray", "=", "image", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "X_fgsm", "=", "torch", ".", "tensor", "(", "imageArray", ")", ".", "to", "(", "device", ")", "\n", "\n", "#print(image.data)", "\n", "\n", "X_fgsm", ".", "requires_grad", "=", "True", "\n", "\n", "opt", "=", "optim", ".", "SGD", "(", "[", "X_fgsm", "]", ",", "lr", "=", "1e-3", ")", "\n", "opt", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "(", "model", "(", "X_fgsm", ")", ",", "label", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "#print(X_fgsm)", "\n", "#print(X_fgsm.grad)", "\n", "if", "order", "==", "np", ".", "inf", ":", "\n", "        ", "d", "=", "epsilon", "*", "X_fgsm", ".", "grad", ".", "data", ".", "sign", "(", ")", "\n", "", "elif", "order", "==", "2", ":", "\n", "        ", "gradient", "=", "X_fgsm", ".", "grad", "\n", "d", "=", "torch", ".", "zeros", "(", "gradient", ".", "shape", ",", "device", "=", "device", ")", "\n", "for", "i", "in", "range", "(", "gradient", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "norm_grad", "=", "gradient", "[", "i", "]", ".", "data", "/", "LA", ".", "norm", "(", "gradient", "[", "i", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "d", "[", "i", "]", "=", "norm_grad", "*", "epsilon", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Other p norms may need other algorithms'", ")", "\n", "\n", "", "x_adv", "=", "X_fgsm", "+", "d", "\n", "\n", "if", "clip_max", "==", "None", "and", "clip_min", "==", "None", ":", "\n", "        ", "clip_max", "=", "np", ".", "inf", "\n", "clip_min", "=", "-", "np", ".", "inf", "\n", "\n", "", "x_adv", "=", "torch", ".", "clamp", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Nattack.NATTACK.__init__": [[16, 20], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "super", "(", "NATTACK", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Nattack.NATTACK.generate": [[21, 37], ["Nattack.NATTACK.parse_params", "Nattack.attack", "Nattack.NATTACK.check_type_device"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack", "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device"], ["", "def", "generate", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call this function to generate adversarial examples.\n\n        Parameters\n        ----------\n        kwargs :\n            user defined paremeters\n        \"\"\"", "\n", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "return", "attack", "(", "self", ".", "model", ",", "self", ".", "dataloader", ",", "self", ".", "classnum", ",", "\n", "self", ".", "clip_max", ",", "self", ".", "clip_min", ",", "self", ".", "epsilon", ",", "\n", "self", ".", "population", ",", "self", ".", "max_iterations", ",", "\n", "self", ".", "learning_rate", ",", "self", ".", "sigma", ",", "self", ".", "target_or_not", ")", "\n", "assert", "self", ".", "check_type_device", "(", "self", ".", "dataloader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Nattack.NATTACK.parse_params": [[38, 87], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "dataloader", ",", "\n", "classnum", ",", "\n", "target_or_not", "=", "False", ",", "\n", "clip_max", "=", "1", ",", "\n", "clip_min", "=", "0", ",", "\n", "epsilon", "=", "0.2", ",", "\n", "population", "=", "300", ",", "\n", "max_iterations", "=", "400", ",", "\n", "learning_rate", "=", "2", ",", "\n", "sigma", "=", "0.1", "\n", ")", ":", "\n", "        ", "\"\"\"parse_params.\n\n        Parameters\n        ----------\n        dataloader :\n            dataloader\n        classnum :\n            classnum\n        target_or_not :\n            target_or_not\n        clip_max :\n            maximum pixel value\n        clip_min :\n            minimum pixel value\n        epsilon :\n            perturb constraint    \n        population :\n            population\n        max_iterations :\n            maximum number of iterations\n        learning_rate :\n            learning rate\n        sigma :\n            sigma\n        \"\"\"", "\n", "\n", "self", ".", "dataloader", "=", "dataloader", "\n", "self", ".", "classnum", "=", "classnum", "\n", "self", ".", "target_or_not", "=", "target_or_not", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "population", "=", "population", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "sigma", "=", "sigma", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Nattack.attack": [[88, 185], ["logging.basicConfig", "logging.getLogger", "logging.getLogger.setLevel", "logging.getLogger.info", "enumerate", "print", "inputs.size", "inputs.size", "inputs.size", "deeprobust.image.utils.arctanh", "model.forward", "range", "model.forward.argmax", "print", "torch.from_numpy().float", "numpy.clip", "proj_g_z.float.float", "model.forward", "numpy.zeros", "numpy.clip", "numpy.array", "faillist.append", "print", "print", "print", "str", "deeprobust.image.utils.arctanh.repeat", "numpy.clip().float", "logging.debug", "model.forward", "torch.from_numpy", "faillist.__len__", "torch.from_numpy", "str", "numpy.mean", "numpy.std", "numpy.random.randn", "numpy.tanh", "numpy.clip", "print", "print", "successlist.append", "printlist.append", "model.forward.detach().numpy", "numpy.dot().reshape", "sum", "numpy.abs().max", "model.forward.detach().numpy", "str", "str", "model.forward.detach", "numpy.dot", "numpy.abs", "model.forward.detach", "model.forward.argmax", "str", "torch.from_numpy().float.reshape"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.image.utils.arctanh", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "", "def", "attack", "(", "model", ",", "loader", ",", "classnum", ",", "clip_max", ",", "clip_min", ",", "epsilon", ",", "population", ",", "max_iterations", ",", "learning_rate", ",", "sigma", ",", "target_or_not", ")", ":", "\n", "\n", "    ", "logging", ".", "basicConfig", "(", "format", "=", "'%(asctime)s - %(levelname)s: %(message)s'", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "'log_nattack'", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "info", "(", "'Start attack.'", ")", "\n", "\n", "#initialization", "\n", "totalImages", "=", "0", "\n", "succImages", "=", "0", "\n", "faillist", "=", "[", "]", "\n", "successlist", "=", "[", "]", "\n", "printlist", "=", "[", "]", "\n", "\n", "for", "i", ",", "(", "inputs", ",", "targets", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "\n", "        ", "success", "=", "False", "\n", "print", "(", "'attack picture No. '", "+", "str", "(", "i", ")", ")", "\n", "\n", "c", "=", "inputs", ".", "size", "(", "1", ")", "# chanel", "\n", "l", "=", "inputs", ".", "size", "(", "2", ")", "# length", "\n", "w", "=", "inputs", ".", "size", "(", "3", ")", "# width", "\n", "\n", "mu", "=", "arctanh", "(", "(", "inputs", "*", "2", ")", "-", "1", ")", "\n", "#mu = torch.from_numpy(np.random.randn(1, c, l, w) * 0.001).float()  # random initialize mean", "\n", "predict", "=", "model", ".", "forward", "(", "inputs", ")", "\n", "\n", "## skip wrongly classified samples", "\n", "if", "predict", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "!=", "targets", ":", "\n", "            ", "print", "(", "'skip the wrong example '", ",", "i", ")", "\n", "continue", "\n", "", "totalImages", "+=", "1", "\n", "\n", "## finding most possible mean", "\n", "for", "runstep", "in", "range", "(", "max_iterations", ")", ":", "\n", "\n", "# sample points from normal distribution", "\n", "            ", "eps", "=", "torch", ".", "from_numpy", "(", "np", ".", "random", ".", "randn", "(", "population", ",", "c", ",", "l", ",", "w", ")", ")", ".", "float", "(", ")", "\n", "z", "=", "mu", ".", "repeat", "(", "population", ",", "1", ",", "1", ",", "1", ")", "+", "sigma", "*", "eps", "\n", "\n", "# calculate g_z", "\n", "g_z", "=", "np", ".", "tanh", "(", "z", ")", "*", "1", "/", "2", "+", "1", "/", "2", "\n", "\n", "# testing whether exists successful attack every 10 iterations.", "\n", "if", "runstep", "%", "10", "==", "0", ":", "\n", "\n", "                ", "realdist", "=", "g_z", "-", "inputs", "\n", "\n", "realclipdist", "=", "np", ".", "clip", "(", "realdist", ",", "-", "epsilon", ",", "epsilon", ")", ".", "float", "(", ")", "\n", "realclipinput", "=", "realclipdist", "+", "inputs", "\n", "\n", "info", "=", "'inputs.shape__'", "+", "str", "(", "inputs", ".", "shape", ")", "\n", "logging", ".", "debug", "(", "info", ")", "\n", "\n", "predict", "=", "model", ".", "forward", "(", "realclipinput", ")", "\n", "\n", "#pending attack", "\n", "if", "(", "target_or_not", "==", "False", ")", ":", "\n", "\n", "                    ", "if", "sum", "(", "predict", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "!=", "targets", ")", ">", "0", "and", "(", "np", ".", "abs", "(", "realclipdist", ")", ".", "max", "(", ")", "<=", "epsilon", ")", ":", "\n", "                        ", "succImages", "+=", "1", "\n", "success", "=", "True", "\n", "print", "(", "'succeed attack Images: '", "+", "str", "(", "succImages", ")", "+", "'     totalImages: '", "+", "str", "(", "totalImages", ")", ")", "\n", "print", "(", "'steps: '", "+", "str", "(", "runstep", ")", ")", "\n", "successlist", ".", "append", "(", "i", ")", "\n", "printlist", ".", "append", "(", "runstep", ")", "\n", "break", "\n", "\n", "# calculate distance", "\n", "", "", "", "dist", "=", "g_z", "-", "inputs", "\n", "clipdist", "=", "np", ".", "clip", "(", "dist", ",", "-", "epsilon", ",", "epsilon", ")", "\n", "proj_g_z", "=", "inputs", "+", "clipdist", "\n", "proj_g_z", "=", "proj_g_z", ".", "float", "(", ")", "\n", "outputs", "=", "model", ".", "forward", "(", "proj_g_z", ")", "\n", "\n", "# get cw loss on sampled images", "\n", "target_onehot", "=", "np", ".", "zeros", "(", "(", "1", ",", "classnum", ")", ")", "\n", "target_onehot", "[", "0", "]", "[", "targets", "]", "=", "1.", "\n", "real", "=", "(", "target_onehot", "*", "outputs", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ".", "sum", "(", "1", ")", "\n", "other", "=", "(", "(", "1.", "-", "target_onehot", ")", "*", "outputs", ".", "detach", "(", ")", ".", "numpy", "(", ")", "-", "target_onehot", "*", "10000.", ")", ".", "max", "(", "1", ")", "\n", "loss1", "=", "np", ".", "clip", "(", "real", "-", "other", ",", "a_min", "=", "0", ",", "a_max", "=", "1e10", ")", "\n", "Reward", "=", "0.5", "*", "loss1", "\n", "\n", "# update mean by nes", "\n", "A", "=", "(", "(", "Reward", "-", "np", ".", "mean", "(", "Reward", ")", ")", "/", "(", "np", ".", "std", "(", "Reward", ")", "+", "1e-7", ")", ")", "\n", "A", "=", "np", ".", "array", "(", "A", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "mu", "=", "mu", "-", "torch", ".", "from_numpy", "(", "(", "learning_rate", "/", "(", "population", "*", "sigma", ")", ")", "*", "\n", "(", "(", "np", ".", "dot", "(", "eps", ".", "reshape", "(", "population", ",", "-", "1", ")", ".", "T", ",", "A", ")", ")", ".", "reshape", "(", "1", ",", "1", ",", "28", ",", "28", ")", ")", ")", "\n", "\n", "", "if", "not", "success", ":", "\n", "            ", "faillist", ".", "append", "(", "i", ")", "\n", "print", "(", "'failed:'", ",", "faillist", ".", "__len__", "(", ")", ")", "\n", "print", "(", "'....................................'", ")", "\n", "", "else", ":", "\n", "#print('succeed:',successlist.__len__())", "\n", "            ", "print", "(", "'....................................'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.get_model": [[24, 33], ["models.resnet18.eval", "models.resnet18.to", "torchvision.vgg16", "torchvision.resnet18"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "get_model", "(", "model", ",", "device", ")", ":", "\n", "    ", "if", "model", "==", "'vgg16'", ":", "\n", "        ", "net", "=", "models", ".", "vgg16", "(", "pretrained", "=", "True", ")", "\n", "", "elif", "model", "==", "'resnet18'", ":", "\n", "        ", "net", "=", "models", ".", "resnet18", "(", "pretrained", "=", "True", ")", "\n", "\n", "", "net", ".", "eval", "(", ")", "\n", "net", "=", "net", ".", "to", "(", "device", ")", "\n", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.data_input_init": [[34, 45], ["torchvision.Compose", "torchvision.Resize", "torchvision.CenterCrop", "torchvision.ToTensor", "torchvision.Normalize"], "function", ["None"], ["", "def", "data_input_init", "(", "xi", ")", ":", "\n", "    ", "mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", "\n", "std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "256", ")", ",", "\n", "transforms", ".", "CenterCrop", "(", "224", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "mean", ",", "\n", "std", "=", "std", ")", "]", ")", "\n", "\n", "return", "(", "mean", ",", "std", ",", "transform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.proj_lp": [[46, 53], ["torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "min", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "function", ["None"], ["", "def", "proj_lp", "(", "v", ",", "xi", ",", "p", ")", ":", "\n", "# Project on the lp ball centered at 0 and of radius xi", "\n", "    ", "if", "p", "==", "np", ".", "inf", ":", "\n", "        ", "v", "=", "torch", ".", "clamp", "(", "v", ",", "-", "xi", ",", "xi", ")", "\n", "", "else", ":", "\n", "        ", "v", "=", "v", "*", "min", "(", "1", ",", "xi", "/", "(", "torch", ".", "norm", "(", "v", ",", "p", ")", "+", "0.00001", ")", ")", "\n", "", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.get_fooling_rate": [[54, 77], ["len", "tqdm.tqdm", "print", "model.parameters", "Universal.data_input_init", "PIL.Image.open", "tf", "image.to.unsqueeze", "image.to.to", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "model", "model"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.data_input_init", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "get_fooling_rate", "(", "data_list", ",", "v", ",", "model", ",", "device", ")", ":", "\n", "    ", "f", "=", "data_input_init", "(", "0", ")", "[", "2", "]", "\n", "num_images", "=", "len", "(", "data_list", ")", "\n", "\n", "fooled", "=", "0.0", "\n", "\n", "for", "name", "in", "tqdm", "(", "data_list", ")", ":", "\n", "        ", "image", "=", "Image", ".", "open", "(", "name", ")", "\n", "image", "=", "tf", "(", "image", ")", "\n", "image", "=", "image", ".", "unsqueeze", "(", "0", ")", "\n", "image", "=", "image", ".", "to", "(", "device", ")", "\n", "_", ",", "pred", "=", "torch", ".", "max", "(", "model", "(", "image", ")", ",", "1", ")", "\n", "_", ",", "adv_pred", "=", "torch", ".", "max", "(", "model", "(", "image", "+", "v", ")", ",", "1", ")", "\n", "if", "(", "pred", "!=", "adv_pred", ")", ":", "\n", "            ", "fooled", "+=", "1", "\n", "\n", "# Compute the fooling rate", "\n", "", "", "fooling_rate", "=", "fooled", "/", "num_images", "\n", "print", "(", "'Fooling Rate = '", ",", "fooling_rate", ")", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "return", "fooling_rate", ",", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.universal_adversarial_perturbation": [[78, 143], ["time.time", "Universal.data_input_init", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "proj_lp.requires_grad_", "len", "enumerate", "Universal.get_fooling_rate", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "model", "model", "deeprobust.image.attack.deepfool", "deeprobust.image.attack.deepfool.generate", "deeprobust.image.attack.deepfool.getpurb", "print", "Universal.proj_lp", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "str", "torch.norm().detach().cpu().numpy", "torch.norm().detach().cpu().numpy", "torch.norm().detach().cpu().numpy", "torch.norm().detach().cpu().numpy", "torch.norm().detach().cpu().numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.norm().detach().cpu", "torch.norm().detach().cpu", "torch.norm().detach().cpu", "torch.norm().detach().cpu", "torch.norm().detach().cpu", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.data_input_init", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.get_fooling_rate", "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.deepfool", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate", "home.repos.pwc.inspect_result.rinnesz_clga.attack.Universal.proj_lp", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "universal_adversarial_perturbation", "(", "dataloader", ",", "model", ",", "device", ",", "xi", "=", "10", ",", "delta", "=", "0.2", ",", "max_iter_uni", "=", "10", ",", "p", "=", "np", ".", "inf", ",", "\n", "num_classes", "=", "10", ",", "overshoot", "=", "0.02", ",", "max_iter_df", "=", "10", ",", "t_p", "=", "0.2", ")", ":", "\n", "    ", "\"\"\"universal_adversarial_perturbation.\n\n    Parameters\n    ----------\n    dataloader :\n        dataloader\n    model :\n        target model\n    device :\n        device\n    xi :\n        controls the l_p magnitude of the perturbation\n    delta :\n        controls the desired fooling rate (default = 80% fooling rate)\n    max_iter_uni :\n        maximum number of iteration (default = 10*num_images)\n    p :\n        norm to be used (default = np.inf)\n    num_classes :\n        num_classes (default = 10)\n    overshoot :\n        to prevent vanishing updates (default = 0.02)\n    max_iter_df :\n        maximum number of iterations for deepfool (default = 10)\n    t_p :\n        truth percentage, for how many flipped labels in a batch. (default = 0.2)\n\n    Returns\n    -------\n        the universal perturbation matrix.\n    \"\"\"", "\n", "time_start", "=", "time", ".", "time", "(", ")", "\n", "mean", ",", "std", ",", "tf", "=", "data_input_init", "(", "xi", ")", "\n", "v", "=", "torch", ".", "zeros", "(", "1", ",", "3", ",", "224", ",", "224", ")", ".", "to", "(", "device", ")", "\n", "v", ".", "requires_grad_", "(", ")", "\n", "\n", "fooling_rate", "=", "0.0", "\n", "num_images", "=", "len", "(", "data_list", ")", "\n", "itr", "=", "0", "\n", "\n", "while", "fooling_rate", "<", "1", "-", "delta", "and", "itr", "<", "max_iter_uni", ":", "\n", "\n", "# Iterate over the dataset and compute the purturbation incrementally", "\n", "\n", "        ", "for", "i", ",", "(", "img", ",", "label", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "_", ",", "pred", "=", "torch", ".", "max", "(", "model", "(", "img", ")", ",", "1", ")", "\n", "_", ",", "adv_pred", "=", "torch", ".", "max", "(", "model", "(", "img", "+", "v", ")", ",", "1", ")", "\n", "\n", "if", "(", "pred", "==", "adv_pred", ")", ":", "\n", "                ", "perturb", "=", "deepfool", "(", "model", ",", "device", ")", "\n", "_", "=", "perturb", ".", "generate", "(", "img", "+", "v", ",", "num_classed", "=", "num_classed", ",", "overshoot", "=", "overshoot", ",", "max_iter", "=", "max_iter_df", ")", "\n", "dr", ",", "iter", "=", "perturb", ".", "getpurb", "(", ")", "\n", "if", "(", "iter", "<", "max_iter_df", "-", "1", ")", ":", "\n", "                    ", "v", "=", "v", "+", "torch", ".", "from_numpy", "(", "dr", ")", ".", "to", "(", "device", ")", "\n", "v", "=", "proj_lp", "(", "v", ",", "xi", ",", "p", ")", "\n", "\n", "", "", "if", "(", "k", "%", "10", "==", "0", ")", ":", "\n", "                ", "print", "(", "'Norm of v: '", "+", "str", "(", "torch", ".", "norm", "(", "v", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "\n", "", "", "fooling_rate", ",", "model", "=", "get_fooling_rate", "(", "data_list", ",", "v", ",", "model", ",", "device", ")", "\n", "itr", "=", "itr", "+", "1", "\n", "\n", "", "return", "v", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize": [[9, 11], ["None"], "function", ["None"], ["def", "normalize", "(", "image", ",", "mean", ",", "std", ")", ":", "\n", "    ", "return", "(", "image", "-", "mean", ")", "/", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.preprocess": [[12, 19], ["numpy.transpose", "numpy.array().reshape", "numpy.array().reshape", "BPDA.normalize", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["", "def", "preprocess", "(", "image", ")", ":", "\n", "    ", "image", "=", "image", "/", "255", "\n", "image", "=", "np", ".", "transpose", "(", "image", ",", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "mean", "=", "np", ".", "array", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "1", ")", ")", "\n", "std", "=", "np", ".", "array", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "1", ")", ")", "\n", "image", "=", "normalize", "(", "image", ",", "mean", ",", "std", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.image2tensor": [[20, 25], ["torch.Tensor", "torch.Tensor", "img_t.unsqueeze.unsqueeze", "img_t.unsqueeze.requires_grad_"], "function", ["None"], ["", "def", "image2tensor", "(", "image", ")", ":", "\n", "    ", "img_t", "=", "torch", ".", "Tensor", "(", "image", ")", "\n", "img_t", "=", "img_t", ".", "unsqueeze", "(", "0", ")", "\n", "img_t", ".", "requires_grad_", "(", ")", "\n", "return", "img_t", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.label2tensor": [[26, 30], ["numpy.array", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "label2tensor", "(", "label", ")", ":", "\n", "    ", "target", "=", "np", ".", "array", "(", "[", "label", "]", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "target", ")", ".", "long", "(", ")", "\n", "return", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.get_img_grad_given_label": [[31, 40], ["model", "torch.CrossEntropyLoss", "nn.CrossEntropyLoss.", "ce.backward", "image.grad.clone", "model.zero_grad", "image.grad.data.zero_"], "function", ["None"], ["", "def", "get_img_grad_given_label", "(", "image", ",", "label", ",", "model", ")", ":", "\n", "    ", "logits", "=", "model", "(", "image", ")", "\n", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "loss", "=", "ce", "(", "logits", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "ret", "=", "image", ".", "grad", ".", "clone", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "image", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.get_cw_grad": [[41, 52], ["model", "torch.CrossEntropyLoss", "torch.MSELoss", "loss.backward", "adv.grad.clone", "model.zero_grad", "adv.grad.data.zero_", "origin.grad.data.zero_", "nn.CrossEntropyLoss.", "nn.MSELoss.", "nn.MSELoss."], "function", ["None"], ["", "def", "get_cw_grad", "(", "adv", ",", "origin", ",", "label", ",", "model", ")", ":", "\n", "    ", "logits", "=", "model", "(", "adv", ")", "\n", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "l2", "=", "nn", ".", "MSELoss", "(", ")", "\n", "loss", "=", "ce", "(", "logits", ",", "label", ")", "+", "l2", "(", "0", ",", "origin", "-", "adv", ")", "/", "l2", "(", "0", ",", "origin", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "ret", "=", "adv", ".", "grad", ".", "clone", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "adv", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "origin", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.l2_norm": [[53, 58], ["adv.detach().numpy.detach().numpy", "img.detach().numpy.detach().numpy", "numpy.sum", "numpy.sum", "adv.detach().numpy.detach", "img.detach().numpy.detach", "numpy.square", "numpy.square"], "function", ["None"], ["", "def", "l2_norm", "(", "adv", ",", "img", ")", ":", "\n", "    ", "adv", "=", "adv", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "img", "=", "img", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "ret", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "adv", "-", "img", ")", ")", "/", "np", ".", "sum", "(", "np", ".", "square", "(", "img", ")", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.clip_bound": [[59, 66], ["numpy.array().reshape", "numpy.array().reshape", "numpy.clip", "np.clip.astype", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "clip_bound", "(", "adv", ")", ":", "\n", "    ", "mean", "=", "np", ".", "array", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "1", ")", ")", "\n", "std", "=", "np", ".", "array", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "reshape", "(", "(", "3", ",", "1", ",", "1", ")", ")", "\n", "adv", "=", "adv", "*", "std", "+", "mean", "\n", "adv", "=", "np", ".", "clip", "(", "adv", ",", "0.", ",", "1.", ")", "\n", "adv", "=", "(", "adv", "-", "mean", ")", "/", "std", "\n", "return", "adv", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.identity_transform": [[67, 69], ["x.detach().clone", "x.detach"], "function", ["None"], ["", "def", "identity_transform", "(", "x", ")", ":", "\n", "    ", "return", "x", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.BPDA_attack": [[70, 94], ["BPDA.label2tensor", "image.detach().numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy.requires_grad_", "range", "torch.from_numpy.detach().numpy", "transform_func", "transform_func.requires_grad_", "torch.MSELoss", "nn.MSELoss.", "l2.backward", "BPDA.get_cw_grad", "print", "BPDA.clip_bound", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy.requires_grad_", "image.detach", "torch.sign", "torch.sign", "torch.sign.numpy().sum", "torch.from_numpy.detach().numpy", "print", "print", "torch.from_numpy.detach", "torch.sign.numpy", "torch.argmax", "torch.argmax", "torch.max().detach().numpy", "torch.max().detach().numpy", "torch.argmax", "torch.argmax", "BPDA.l2_norm", "torch.sign.numpy", "torch.from_numpy.detach", "model", "model", "torch.max().detach", "torch.max().detach", "torch.max", "torch.max", "torch.abs", "torch.abs"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.label2tensor", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.get_cw_grad", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.clip_bound", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.l2_norm"], ["", "def", "BPDA_attack", "(", "image", ",", "target", ",", "model", ",", "step_size", "=", "1.", ",", "iterations", "=", "10", ",", "linf", "=", "False", ",", "transform_func", "=", "identity_transform", ")", ":", "\n", "    ", "target", "=", "label2tensor", "(", "target", ")", "\n", "adv", "=", "image", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "adv", "=", "torch", ".", "from_numpy", "(", "adv", ")", "\n", "adv", ".", "requires_grad_", "(", ")", "\n", "for", "_", "in", "range", "(", "iterations", ")", ":", "\n", "        ", "adv_def", "=", "transform_func", "(", "adv", ")", "\n", "adv_def", ".", "requires_grad_", "(", ")", "\n", "l2", "=", "nn", ".", "MSELoss", "(", ")", "\n", "loss", "=", "l2", "(", "0", ",", "adv_def", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "g", "=", "get_cw_grad", "(", "adv_def", ",", "image", ",", "target", ",", "model", ")", "\n", "if", "linf", ":", "\n", "            ", "g", "=", "torch", ".", "sign", "(", "g", ")", "\n", "", "print", "(", "g", ".", "numpy", "(", ")", ".", "sum", "(", ")", ")", "\n", "adv", "=", "adv", ".", "detach", "(", ")", ".", "numpy", "(", ")", "-", "step_size", "*", "g", ".", "numpy", "(", ")", "\n", "adv", "=", "clip_bound", "(", "adv", ")", "\n", "adv", "=", "torch", ".", "from_numpy", "(", "adv", ")", "\n", "adv", ".", "requires_grad_", "(", ")", "\n", "if", "linf", ":", "\n", "            ", "print", "(", "'label'", ",", "torch", ".", "argmax", "(", "model", "(", "adv", ")", ")", ",", "'linf'", ",", "torch", ".", "max", "(", "torch", ".", "abs", "(", "adv", "-", "image", ")", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'label'", ",", "torch", ".", "argmax", "(", "model", "(", "adv", ")", ")", ",", "'l2'", ",", "l2_norm", "(", "adv", ",", "image", ")", ")", "\n", "", "", "return", "adv", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.DeepFool.__init__": [[13, 17], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "super", "(", "DeepFool", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.DeepFool.generate": [[18, 57], ["deepfool.DeepFool.check_type_device", "torch.cuda.is_available", "deepfool.DeepFool.parse_params", "deepfool.deepfool", "image.cuda", "deepfool.DeepFool.model.cuda"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.deepfool"], ["", "def", "generate", "(", "self", ",", "image", ",", "label", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call this function to generate adversarial examples.\n\n        Parameters\n        ----------\n        image : 1*H*W*3\n            original image\n        label : int\n            target label\n        kwargs :\n            user defined paremeters\n       \n        Returns\n        -------\n        adv_img :\n            adversarial examples\n        \"\"\"", "\n", "\n", "\n", "#check type device", "\n", "assert", "self", ".", "check_type_device", "(", "image", ",", "label", ")", "\n", "is_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "if", "(", "is_cuda", "and", "self", ".", "device", "==", "'cuda'", ")", ":", "\n", "            ", "self", ".", "image", "=", "image", ".", "cuda", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "image", "=", "image", "\n", "\n", "", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "adv_img", ",", "self", ".", "r", ",", "self", ".", "ite", "=", "deepfool", "(", "self", ".", "model", ",", "\n", "self", ".", "image", ",", "\n", "self", ".", "num_classes", ",", "\n", "self", ".", "overshoot", ",", "\n", "self", ".", "max_iteration", ",", "\n", "self", ".", "device", ")", "\n", "return", "adv_img", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.DeepFool.getpert": [[58, 60], ["None"], "methods", ["None"], ["", "def", "getpert", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "r", ",", "self", ".", "ite", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.DeepFool.parse_params": [[61, 81], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "num_classes", "=", "10", ",", "\n", "overshoot", "=", "0.02", ",", "\n", "max_iteration", "=", "50", ")", ":", "\n", "        ", "\"\"\"\n        Parse the user defined parameters\n\n        Parameters\n        ----------\n        num_classes : int\n            limits the number of classes to test against. (default = 10)\n        overshoot : float\n            used as a termination criterion to prevent vanishing updates (default = 0.02).\n        max_iteration : int\n            maximum number of iteration for deepfool (default = 50)\n        \"\"\"", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "overshoot", "=", "overshoot", "\n", "self", ".", "max_iteration", "=", "max_iteration", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.deepfool.deepfool": [[82, 138], ["model.forward().data.cpu().numpy().flatten", "copy.deepcopy().requires_grad_", "numpy.zeros", "numpy.zeros", "model.forward", "range", "numpy.array().flatten().argsort", "image.cpu().numpy", "fs[].backward", "pert_image.detach().requires_grad_.grad.data.cpu().numpy().copy", "range", "numpy.float32", "pert_image.detach().requires_grad_", "model.forward", "model.forward().data.cpu().numpy", "copy.deepcopy", "range", "torch.autograd.gradcheck.zero_gradients", "fs[].backward", "pert_image.detach().requires_grad_.grad.data.cpu().numpy().copy", "numpy.linalg.norm", "numpy.array().flatten", "image.cpu", "pert_image.detach().requires_grad_.grad.data.cpu().numpy", "abs", "numpy.linalg.norm", "torch.from_numpy().to", "pert_image.detach", "numpy.argmax", "model.forward().data.cpu", "pert_image.detach().requires_grad_.grad.data.cpu().numpy", "w_k.flatten", "model.forward.data.cpu().numpy().flatten", "numpy.array", "pert_image.detach().requires_grad_.grad.data.cpu", "torch.from_numpy", "pert_image.detach().requires_grad_.grad.data.cpu", "model.forward.data.cpu().numpy", "model.forward", "model.forward.data.cpu"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward"], ["", "", "def", "deepfool", "(", "model", ",", "image", ",", "num_classes", ",", "overshoot", ",", "max_iter", ",", "device", ")", ":", "\n", "    ", "f_image", "=", "model", ".", "forward", "(", "image", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "output", "=", "(", "np", ".", "array", "(", "f_image", ")", ")", ".", "flatten", "(", ")", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "output", "=", "output", "[", "0", ":", "num_classes", "]", "\n", "label", "=", "output", "[", "0", "]", "\n", "\n", "input_shape", "=", "image", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "shape", "\n", "x", "=", "copy", ".", "deepcopy", "(", "image", ")", ".", "requires_grad_", "(", "True", ")", "\n", "w", "=", "np", ".", "zeros", "(", "input_shape", ")", "\n", "r_tot", "=", "np", ".", "zeros", "(", "input_shape", ")", "\n", "\n", "fs", "=", "model", ".", "forward", "(", "x", ")", "\n", "fs_list", "=", "[", "fs", "[", "0", ",", "output", "[", "k", "]", "]", "for", "k", "in", "range", "(", "num_classes", ")", "]", "\n", "current_pred_label", "=", "label", "\n", "\n", "for", "i", "in", "range", "(", "max_iter", ")", ":", "\n", "\n", "        ", "pert", "=", "np", ".", "inf", "\n", "fs", "[", "0", ",", "output", "[", "0", "]", "]", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "grad_orig", "=", "x", ".", "grad", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "copy", "(", ")", "\n", "\n", "for", "k", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "            ", "zero_gradients", "(", "x", ")", "\n", "\n", "fs", "[", "0", ",", "output", "[", "k", "]", "]", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "cur_grad", "=", "x", ".", "grad", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "copy", "(", ")", "\n", "\n", "# set new w_k and new f_k", "\n", "w_k", "=", "cur_grad", "-", "grad_orig", "\n", "f_k", "=", "(", "fs", "[", "0", ",", "output", "[", "k", "]", "]", "-", "fs", "[", "0", ",", "output", "[", "0", "]", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "pert_k", "=", "abs", "(", "f_k", ")", "/", "np", ".", "linalg", ".", "norm", "(", "w_k", ".", "flatten", "(", ")", ")", "\n", "\n", "# determine which w_k to use", "\n", "if", "pert_k", "<", "pert", ":", "\n", "                ", "pert", "=", "pert_k", "\n", "w", "=", "w_k", "\n", "\n", "# compute r_i and r_tot", "\n", "# Added 1e-4 for numerical stability", "\n", "", "", "r_i", "=", "(", "pert", "+", "1e-4", ")", "*", "w", "/", "np", ".", "linalg", ".", "norm", "(", "w", ")", "\n", "r_tot", "=", "np", ".", "float32", "(", "r_tot", "+", "r_i", ")", "\n", "\n", "pert_image", "=", "image", "+", "(", "1", "+", "overshoot", ")", "*", "torch", ".", "from_numpy", "(", "r_tot", ")", ".", "to", "(", "device", ")", "\n", "\n", "x", "=", "pert_image", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", "\n", "fs", "=", "model", ".", "forward", "(", "x", ")", "\n", "\n", "if", "(", "not", "np", ".", "argmax", "(", "fs", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ")", "==", "label", ")", ":", "\n", "            ", "break", "\n", "\n", "\n", "", "", "r_tot", "=", "(", "1", "+", "overshoot", ")", "*", "r_tot", "\n", "\n", "return", "pert_image", ",", "r_tot", ",", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.pgd.PGD.__init__": [[16, 19], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], []], "home.repos.pwc.inspect_result.rinnesz_clga.attack.pgd.PGD.generate": [[20, 51], ["label.type.type.type", "pgd.PGD.check_type_device", "pgd.PGD.parse_params", "pgd.pgd_attack"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.pgd.pgd_attack"], ["\n", "\n", "def", "__init__", "(", "self", ",", "params", ",", "proxs", ",", "alphas", ",", "lr", "=", "required", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "weight_decay", "=", "0", ")", ":", "\n", "        ", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "nesterov", "=", "False", ")", "\n", "\n", "\n", "super", "(", "PGD", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'proxs'", ",", "proxs", ")", "\n", "group", ".", "setdefault", "(", "'alphas'", ",", "alphas", ")", "\n", "\n", "", "", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "PGD", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'nesterov'", ",", "False", ")", "\n", "group", ".", "setdefault", "(", "'proxs'", ",", "proxs", ")", "\n", "group", ".", "setdefault", "(", "'alphas'", ",", "alphas", ")", "\n", "\n", "", "", "def", "step", "(", "self", ",", "delta", "=", "0", ",", "closure", "=", "None", ")", ":", "\n", "         ", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "lr", "=", "group", "[", "'lr'", "]", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.pgd.PGD.parse_params": [[53, 89], ["None"], "methods", ["None"], ["momentum", "=", "group", "[", "'momentum'", "]", "\n", "dampening", "=", "group", "[", "'dampening'", "]", "\n", "nesterov", "=", "group", "[", "'nesterov'", "]", "\n", "proxs", "=", "group", "[", "'proxs'", "]", "\n", "alphas", "=", "group", "[", "'alphas'", "]", "\n", "\n", "# apply the proximal operator to each parameter in a group", "\n", "for", "param", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "for", "prox_operator", ",", "alpha", "in", "zip", "(", "proxs", ",", "alphas", ")", ":", "\n", "# param.data.add_(lr, -param.grad.data)", "\n", "# param.data.add_(delta)", "\n", "                    ", "param", ".", "data", "=", "prox_operator", "(", "param", ".", "data", ",", "alpha", "=", "alpha", "*", "lr", ")", "\n", "\n", "\n", "", "", "", "", "", "class", "ProxOperators", "(", ")", ":", "\n", "    ", "\"\"\"Proximal Operators.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "nuclear_norm", "=", "None", "\n", "\n", "", "def", "prox_l1", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Proximal operator for l1 norm.\n        \"\"\"", "\n", "data", "=", "torch", ".", "mul", "(", "torch", ".", "sign", "(", "data", ")", ",", "torch", ".", "clamp", "(", "torch", ".", "abs", "(", "data", ")", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "data", "\n", "\n", "", "def", "prox_nuclear", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Proximal operator for nuclear norm (trace norm).\n        \"\"\"", "\n", "U", ",", "S", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "data", ".", "cpu", "(", ")", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "# print(\"nuclear norm: %.4f\" % self.nuclear_norm)", "\n", "\n", "diag_S", "=", "torch", ".", "diag", "(", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "U", ",", "diag_S", ")", ",", "V", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.pgd.pgd_attack": [[90, 152], ["model", "X.detach().cpu().numpy", "numpy.random.uniform", "numpy.clip", "torch.tensor().to().float", "torch.tensor().to().float", "torch.tensor().to().float", "torch.tensor().to().float", "range", "model", "loss.backward", "X.detach().cpu", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.CrossEntropyLoss", "print", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "range", "X_pgd.detach.detach", "X_pgd.detach.requires_grad_", "X_pgd.detach.retain_grad", "model", "loss.backward", "torch.min", "torch.min", "torch.min", "torch.min", "delta.grad.zero_", "X_pgd.detach.grad.data.sign", "torch.CrossEntropyLoss", "model", "norms", "norms().clamp", "torch.max", "torch.max", "torch.max", "torch.max", "X.detach", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "model.max", "delta.grad.detach", "delta.grad.detach", "delta.detach", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "norms", "model.data.max", "delta.detach"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["\n", "", "def", "prox_nuclear_truncated_2", "(", "self", ",", "data", ",", "alpha", ",", "k", "=", "50", ")", ":", "\n", "        ", "import", "tensorly", "as", "tl", "\n", "tl", ".", "set_backend", "(", "'pytorch'", ")", "\n", "U", ",", "S", ",", "V", "=", "tl", ".", "truncated_svd", "(", "data", ".", "cpu", "(", ")", ",", "n_eigenvecs", "=", "k", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "# print(\"nuclear norm: %.4f\" % self.nuclear_norm)", "\n", "\n", "S", "=", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", "\n", "\n", "# diag_S = torch.diag(torch.clamp(S-alpha, min=0))", "\n", "# U = torch.spmm(U, diag_S)", "\n", "# V = torch.matmul(U, V)", "\n", "\n", "# make diag_S sparse matrix", "\n", "indices", "=", "torch", ".", "tensor", "(", "(", "range", "(", "0", ",", "len", "(", "S", ")", ")", ",", "range", "(", "0", ",", "len", "(", "S", ")", ")", ")", ")", ".", "cuda", "(", ")", "\n", "values", "=", "S", "\n", "diag_S", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ",", "values", ",", "torch", ".", "Size", "(", "(", "len", "(", "S", ")", ",", "len", "(", "S", ")", ")", ")", ")", "\n", "V", "=", "torch", ".", "spmm", "(", "diag_S", ",", "V", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "U", ",", "V", ")", "\n", "return", "V", "\n", "\n", "", "def", "prox_nuclear_truncated", "(", "self", ",", "data", ",", "alpha", ",", "k", "=", "50", ")", ":", "\n", "        ", "indices", "=", "torch", ".", "nonzero", "(", "data", ")", ".", "t", "(", ")", "\n", "values", "=", "data", "[", "indices", "[", "0", "]", ",", "indices", "[", "1", "]", "]", "# modify this based on dimensionality", "\n", "data_sparse", "=", "sp", ".", "csr_matrix", "(", "(", "values", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "U", ",", "S", ",", "V", "=", "sp", ".", "linalg", ".", "svds", "(", "data_sparse", ",", "k", "=", "k", ")", "\n", "U", ",", "S", ",", "V", "=", "torch", ".", "FloatTensor", "(", "U", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "S", ")", ".", "cuda", "(", ")", ",", "torch", ".", "FloatTensor", "(", "V", ")", ".", "cuda", "(", ")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "diag_S", "=", "torch", ".", "diag", "(", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", ")", "\n", "return", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "U", ",", "diag_S", ")", ",", "V", ")", "\n", "\n", "", "def", "prox_nuclear_cuda", "(", "self", ",", "data", ",", "alpha", ")", ":", "\n", "\n", "        ", "U", ",", "S", ",", "V", "=", "torch", ".", "svd", "(", "data", ")", "\n", "# self.nuclear_norm = S.sum()", "\n", "# print(f\"rank = {len(S.nonzero())}\")", "\n", "self", ".", "nuclear_norm", "=", "S", ".", "sum", "(", ")", "\n", "S", "=", "torch", ".", "clamp", "(", "S", "-", "alpha", ",", "min", "=", "0", ")", "\n", "indices", "=", "torch", ".", "tensor", "(", "[", "range", "(", "0", ",", "U", ".", "shape", "[", "0", "]", ")", ",", "range", "(", "0", ",", "U", ".", "shape", "[", "0", "]", ")", "]", ")", ".", "cuda", "(", ")", "\n", "values", "=", "S", "\n", "diag_S", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ",", "values", ",", "torch", ".", "Size", "(", "U", ".", "shape", ")", ")", "\n", "# diag_S = torch.diag(torch.clamp(S-alpha, min=0))", "\n", "# print(f\"rank_after = {len(diag_S.nonzero())}\")", "\n", "V", "=", "torch", ".", "spmm", "(", "diag_S", ",", "V", ".", "t_", "(", ")", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "U", ",", "V", ")", "\n", "return", "V", "\n", "\n", "\n", "", "", "class", "SGD", "(", "Optimizer", ")", ":", "\n", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "required", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "nesterov", "=", "False", ")", ":", "\n", "        ", "if", "lr", "is", "not", "required", "and", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid weight_decay value: {}\"", ".", "format", "(", "weight_decay", ")", ")", "\n", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "dampening", "=", "dampening", ",", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.__init__": [[11, 14], ["None"], "methods", ["None"], ["class", "BaseAttack", "(", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.generate": [[15, 29], ["None"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "model", ",", "nnodes", ",", "attack_structure", "=", "True", ",", "attack_features", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.parse_params": [[30, 35], ["None"], "methods", ["None"], ["        ", "super", "(", "BaseAttack", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "surrogate", "=", "model", "\n", "self", ".", "nnodes", "=", "nnodes", "\n", "self", ".", "attack_structure", "=", "attack_structure", "\n", "self", ".", "attack_features", "=", "attack_features", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device": [[36, 84], ["torch.tensor.cuda", "torch.tensor.cuda", "base_attack.BaseAttack.model.cuda", "torch.tensor.float", "torch.tensor.float().clone().detach().requires_grad_", "torch.tensor.long", "torch.tensor.cpu", "torch.tensor.cpu", "base_attack.BaseAttack.model.cpu", "ValueError", "type", "torch.tensor.astype", "torch.tensor", "ValueError", "type", "torch.tensor.astype", "torch.tensor", "ValueError", "torch.tensor.float().clone().detach", "type", "type", "torch.tensor.float().clone", "torch.tensor.float"], "methods", ["None"], ["self", ".", "device", "=", "device", "\n", "self", ".", "modified_adj", "=", "None", "\n", "self", ".", "modified_features", "=", "None", "\n", "if", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "nclass", "=", "model", ".", "nclass", "\n", "self", ".", "nfeat", "=", "model", ".", "nfeat", "\n", "self", ".", "hidden_sizes", "=", "model", ".", "hidden_sizes", "\n", "\n", "", "", "def", "attack", "(", "self", ",", "ori_adj", ",", "n_perturbations", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate attacks on the input graph.\n\n        Parameters\n        ----------\n        ori_adj : scipy.sparse.csr_matrix\n            Original (unperturbed) adjacency matrix.\n        n_perturbations : int\n            Number of edge removals/additions.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "pass", "\n", "\n", "", "def", "check_adj", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric and unweighted.\n        \"\"\"", "\n", "assert", "np", ".", "abs", "(", "adj", "-", "adj", ".", "T", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n", "assert", "adj", ".", "tocsr", "(", ")", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "\n", "", "def", "check_adj_tensor", "(", "self", ",", "adj", ")", ":", "\n", "        ", "\"\"\"Check if the modified adjacency is symmetric, unweighted, all-zero diagonal.\n        \"\"\"", "\n", "assert", "torch", ".", "abs", "(", "adj", "-", "adj", ".", "t", "(", ")", ")", ".", "sum", "(", ")", "==", "0", ",", "\"Input graph is not symmetric\"", "\n", "assert", "adj", ".", "max", "(", ")", "==", "1", ",", "\"Max value should be 1!\"", "\n", "assert", "adj", ".", "min", "(", ")", "==", "0", ",", "\"Min value should be 0!\"", "\n", "diag", "=", "adj", ".", "diag", "(", ")", "\n", "assert", "diag", ".", "max", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "assert", "diag", ".", "min", "(", ")", "==", "0", ",", "\"Diagonal should be 0!\"", "\n", "\n", "\n", "", "def", "save_adj", "(", "self", ",", "root", "=", "r'/tmp/'", ",", "name", "=", "'mod_adj'", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.get_or_predict_lable": [[85, 89], ["base_attack.BaseAttack.model", "base_attack.BaseAttack.argmax"], "methods", ["None"], []], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.__init__": [[33, 36], ["deeprobust.image.attack.base_attack.BaseAttack.__init__"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "'cuda'", ")", ":", "\n", "\n", "        ", "super", "(", "Onepixel", ",", "self", ")", ".", "__init__", "(", "model", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.generate": [[37, 64], ["label.type.type.type", "onepixel.Onepixel.check_type_device", "onepixel.Onepixel.parse_params", "onepixel.Onepixel.one_pixel"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.base_attack.BaseAttack.check_type_device", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.one_pixel"], ["", "def", "generate", "(", "self", ",", "image", ",", "label", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call this function to generate Onepixel adversarial examples.\n\n        Parameters\n        ----------\n        image :1*3*W*H\n            original image\n        label :\n            target label\n        kwargs :\n            user defined paremeters\n        \"\"\"", "\n", "\n", "label", "=", "label", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "\n", "## check and parse parameters for attack", "\n", "assert", "self", ".", "check_type_device", "(", "image", ",", "label", ")", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "return", "self", ".", "one_pixel", "(", "self", ".", "image", ",", "\n", "self", ".", "label", ",", "\n", "self", ".", "targeted_attack", ",", "\n", "self", ".", "pixels", ",", "\n", "self", ".", "maxiter", ",", "\n", "self", ".", "popsize", ",", "\n", "self", ".", "print_log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.get_pred": [[65, 67], ["None"], "methods", ["None"], ["", "def", "get_pred", "(", ")", ":", "\n", "        ", "return", "self", ".", "adv_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.parse_params": [[68, 106], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "pixels", "=", "1", ",", "\n", "maxiter", "=", "100", ",", "\n", "popsize", "=", "400", ",", "\n", "samples", "=", "100", ",", "\n", "targeted_attack", "=", "False", ",", "\n", "print_log", "=", "True", ",", "\n", "target", "=", "0", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Parse the user-defined params.\n\n        Parameters\n        ----------\n        pixels :\n            maximum number of manipulated pixels\n        maxiter :\n            maximum number of iteration\n        popsize :\n            population size\n        samples :\n            samples\n        targeted_attack :\n            targeted attack or not\n        print_log :\n            Set print_log = True to print out details in the searching algorithm\n        target :\n            target label (if targeted attack is set to be True)\n        \"\"\"", "\n", "\n", "self", ".", "pixels", "=", "pixels", "\n", "self", ".", "maxiter", "=", "maxiter", "\n", "self", ".", "popsize", "=", "popsize", "\n", "self", ".", "samples", "=", "samples", "\n", "self", ".", "targeted_attack", "=", "targeted_attack", "\n", "self", ".", "print_log", "=", "print_log", "\n", "self", ".", "target", "=", "target", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.Onepixel.one_pixel": [[108, 144], ["max", "numpy.zeros", "deeprobust.image.optimizer.differential_evolution", "onepixel.perturb_image", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "torch.autograd.Variable().cuda", "numpy.argmax", "onepixel.predict_classes", "onepixel.attack_success", "range", "torch.softmax().data.cpu().numpy", "torch.softmax().data.cpu().numpy", "torch.softmax().data.cpu().numpy", "torch.softmax().data.cpu().numpy", "torch.softmax().data.cpu().numpy", "len", "len", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "len", "numpy.random.random", "numpy.random.random", "torch.softmax().data.cpu", "torch.softmax().data.cpu", "torch.softmax().data.cpu", "torch.softmax().data.cpu", "torch.softmax().data.cpu", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "onepixel.Onepixel.model"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.image.optimizer.differential_evolution", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.perturb_image", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.predict_classes", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.attack_success"], ["", "def", "one_pixel", "(", "self", ",", "img", ",", "label", ",", "targeted_attack", "=", "False", ",", "target", "=", "0", ",", "pixels", "=", "1", ",", "maxiter", "=", "75", ",", "popsize", "=", "400", ",", "print_log", "=", "False", ")", ":", "\n", "# label: a number", "\n", "\n", "        ", "target_calss", "=", "target", "if", "targeted_attack", "else", "label", "\n", "\n", "bounds", "=", "[", "(", "0", ",", "32", ")", ",", "(", "0", ",", "32", ")", ",", "(", "0", ",", "255", ")", ",", "(", "0", ",", "255", ")", ",", "(", "0", ",", "255", ")", "]", "*", "pixels", "\n", "\n", "popmul", "=", "max", "(", "1", ",", "popsize", "/", "len", "(", "bounds", ")", ")", "\n", "\n", "predict_fn", "=", "lambda", "xs", ":", "predict_classes", "(", "\n", "xs", ",", "img", ",", "target_calss", ",", "self", ".", "model", ",", "targeted_attack", ",", "self", ".", "device", ")", "\n", "callback_fn", "=", "lambda", "x", ",", "convergence", ":", "attack_success", "(", "\n", "x", ",", "img", ",", "target_calss", ",", "self", ".", "model", ",", "targeted_attack", ",", "print_log", ",", "self", ".", "device", ")", "\n", "\n", "inits", "=", "np", ".", "zeros", "(", "[", "popmul", "*", "len", "(", "bounds", ")", ",", "len", "(", "bounds", ")", "]", ")", "\n", "for", "init", "in", "inits", ":", "\n", "            ", "for", "i", "in", "range", "(", "pixels", ")", ":", "\n", "                ", "init", "[", "i", "*", "5", "+", "0", "]", "=", "np", ".", "random", ".", "random", "(", ")", "*", "32", "\n", "init", "[", "i", "*", "5", "+", "1", "]", "=", "np", ".", "random", ".", "random", "(", ")", "*", "32", "\n", "init", "[", "i", "*", "5", "+", "2", "]", "=", "np", ".", "random", ".", "normal", "(", "128", ",", "127", ")", "\n", "init", "[", "i", "*", "5", "+", "3", "]", "=", "np", ".", "random", ".", "normal", "(", "128", ",", "127", ")", "\n", "init", "[", "i", "*", "5", "+", "4", "]", "=", "np", ".", "random", ".", "normal", "(", "128", ",", "127", ")", "\n", "\n", "", "", "attack_result", "=", "differential_evolution", "(", "predict_fn", ",", "bounds", ",", "maxiter", "=", "maxiter", ",", "popsize", "=", "popmul", ",", "\n", "recombination", "=", "1", ",", "atol", "=", "-", "1", ",", "callback", "=", "callback_fn", ",", "polish", "=", "False", ",", "init", "=", "inits", ")", "\n", "\n", "attack_image", "=", "perturb_image", "(", "attack_result", ".", "x", ",", "img", ")", "\n", "attack_var", "=", "Variable", "(", "attack_image", ",", "volatile", "=", "True", ")", ".", "cuda", "(", ")", "\n", "predicted_probs", "=", "F", ".", "softmax", "(", "self", ".", "model", "(", "attack_var", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", "\n", "\n", "predicted_class", "=", "np", ".", "argmax", "(", "predicted_probs", ")", "\n", "\n", "if", "(", "not", "targeted_attack", "and", "predicted_class", "!=", "label", ")", "or", "(", "targeted_attack", "and", "predicted_class", "==", "target_calss", ")", ":", "\n", "            ", "self", ".", "adv_pred", "=", "predicted_class", "\n", "return", "attack_image", "\n", "", "return", "[", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.perturb_image": [[145, 165], ["len", "img.repeat", "np.array.astype", "numpy.array", "numpy.split", "len"], "function", ["None"], ["", "", "def", "perturb_image", "(", "xs", ",", "img", ")", ":", "\n", "\n", "    ", "if", "xs", ".", "ndim", "<", "2", ":", "\n", "        ", "xs", "=", "np", ".", "array", "(", "[", "xs", "]", ")", "\n", "", "batch", "=", "len", "(", "xs", ")", "\n", "imgs", "=", "img", ".", "repeat", "(", "batch", ",", "1", ",", "1", ",", "1", ")", "\n", "xs", "=", "xs", ".", "astype", "(", "int", ")", "\n", "\n", "count", "=", "0", "\n", "\n", "for", "x", "in", "xs", ":", "\n", "        ", "pixels", "=", "np", ".", "split", "(", "x", ",", "len", "(", "x", ")", "/", "5", ")", "\n", "for", "pixel", "in", "pixels", ":", "\n", "            ", "x_pos", ",", "y_pos", ",", "r", ",", "g", ",", "b", "=", "pixel", "\n", "imgs", "[", "count", ",", "0", ",", "x_pos", ",", "y_pos", "]", "=", "(", "r", "/", "255.0", "-", "0.4914", ")", "/", "0.2023", "\n", "imgs", "[", "count", ",", "1", ",", "x_pos", ",", "y_pos", "]", "=", "(", "g", "/", "255.0", "-", "0.4822", ")", "/", "0.1994", "\n", "imgs", "[", "count", ",", "2", ",", "x_pos", ",", "y_pos", "]", "=", "(", "b", "/", "255.0", "-", "0.4465", ")", "/", "0.2010", "\n", "", "count", "+=", "1", "\n", "\n", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.predict_classes": [[166, 171], ["perturb_image().to", "torch.softmax().data.cpu().numpy", "onepixel.perturb_image", "img.clone", "torch.softmax().data.cpu", "torch.softmax", "net"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.perturb_image"], ["", "def", "predict_classes", "(", "xs", ",", "img", ",", "target_calss", ",", "net", ",", "minimize", "=", "True", ",", "device", "=", "'cuda'", ")", ":", "\n", "    ", "imgs_perturbed", "=", "perturb_image", "(", "xs", ",", "img", ".", "clone", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "predictions", "=", "F", ".", "softmax", "(", "net", "(", "imgs_perturbed", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", ":", ",", "target_calss", "]", "\n", "\n", "return", "predictions", "if", "minimize", "else", "1", "-", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.attack_success": [[172, 182], ["perturb_image().to", "numpy.argmax", "torch.softmax().data.cpu().numpy", "print", "onepixel.perturb_image", "img.clone", "torch.softmax().data.cpu", "torch.softmax", "net"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.onepixel.perturb_image"], ["", "def", "attack_success", "(", "x", ",", "img", ",", "target_calss", ",", "net", ",", "targeted_attack", "=", "False", ",", "print_log", "=", "False", ",", "device", "=", "'cuda'", ")", ":", "\n", "\n", "    ", "attack_image", "=", "perturb_image", "(", "x", ",", "img", ".", "clone", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "confidence", "=", "F", ".", "softmax", "(", "net", "(", "attack_image", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", "\n", "pred", "=", "np", ".", "argmax", "(", "confidence", ")", "\n", "\n", "if", "(", "print_log", ")", ":", "\n", "        ", "print", "(", "\"Confidence: %.4f\"", "%", "confidence", "[", "target_calss", "]", ")", "\n", "", "if", "(", "targeted_attack", "and", "pred", "==", "target_calss", ")", "or", "(", "not", "targeted_attack", "and", "pred", "!=", "target_calss", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.__init__": [[24, 43], ["torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "torch.nn.CrossEntropyLoss().to", "mean.to", "std.to", "numpy.array().astype", "numpy.array().astype", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["def", "__init__", "(", "self", ",", "eps", "=", "6", "/", "255.0", ",", "sigma", "=", "3", "/", "255.0", ",", "nb_iter", "=", "20", ",", "\n", "norm", "=", "np", ".", "inf", ",", "DEVICE", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "\n", "mean", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ")", ",", "\n", "std", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "[", "1.0", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ")", ",", "random_start", "=", "True", ")", ":", "\n", "        ", "'''\n        :param eps: maximum distortion of adversarial examples\n        :param sigma: single step size\n        :param nb_iter: number of attack iterations\n        :param norm: which norm to bound the perturbations\n        '''", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "nb_iter", "=", "nb_iter", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", ".", "to", "(", "DEVICE", ")", "\n", "self", ".", "DEVICE", "=", "DEVICE", "\n", "self", ".", "_mean", "=", "mean", ".", "to", "(", "DEVICE", ")", "\n", "self", ".", "_std", "=", "std", ".", "to", "(", "DEVICE", ")", "\n", "self", ".", "random_start", "=", "random_start", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.single_attack": [[44, 83], ["net", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "[].sign", "YOPOpgd.FASTPGD.criterion", "[].sign", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad"], "methods", ["None"], ["", "def", "single_attack", "(", "self", ",", "net", ",", "inp", ",", "label", ",", "eta", ",", "target", "=", "None", ")", ":", "\n", "        ", "'''\n        Given the original image and the perturbation computed so far, computes\n        a new perturbation.\n        :param net:\n        :param inp: original image\n        :param label:\n        :param eta: perturbation computed so far\n        :return: a new perturbation\n        '''", "\n", "\n", "adv_inp", "=", "inp", "+", "eta", "\n", "\n", "#net.zero_grad()", "\n", "\n", "pred", "=", "net", "(", "adv_inp", ")", "\n", "if", "target", "is", "not", "None", ":", "\n", "            ", "targets", "=", "torch", ".", "sum", "(", "pred", "[", ":", ",", "target", "]", ")", "\n", "grad_sign", "=", "torch", ".", "autograd", ".", "grad", "(", "targets", ",", "adv_in", ",", "only_inputs", "=", "True", ",", "retain_graph", "=", "False", ")", "[", "0", "]", ".", "sign", "(", ")", "\n", "\n", "", "else", ":", "\n", "            ", "loss", "=", "self", ".", "criterion", "(", "pred", ",", "label", ")", "\n", "grad_sign", "=", "torch", ".", "autograd", ".", "grad", "(", "loss", ",", "adv_inp", ",", "\n", "only_inputs", "=", "True", ",", "retain_graph", "=", "False", ")", "[", "0", "]", ".", "sign", "(", ")", "\n", "\n", "", "adv_inp", "=", "adv_inp", "+", "grad_sign", "*", "(", "self", ".", "sigma", "/", "self", ".", "_std", ")", "\n", "tmp_adv_inp", "=", "adv_inp", "*", "self", ".", "_std", "+", "self", ".", "_mean", "\n", "\n", "tmp_inp", "=", "inp", "*", "self", ".", "_std", "+", "self", ".", "_mean", "\n", "tmp_adv_inp", "=", "torch", ".", "clamp", "(", "tmp_adv_inp", ",", "0", ",", "1", ")", "## clip into 0-1", "\n", "#tmp_adv_inp = (tmp_adv_inp - self._mean) / self._std", "\n", "tmp_eta", "=", "tmp_adv_inp", "-", "tmp_inp", "\n", "\n", "#tmp_eta = clip_eta(tmp_eta, norm=self.norm, eps=self.eps, DEVICE=self.DEVICE)", "\n", "if", "self", ".", "norm", "==", "np", ".", "inf", ":", "\n", "            ", "tmp_eta", "=", "torch", ".", "clamp", "(", "tmp_eta", ",", "-", "self", ".", "eps", ",", "self", ".", "eps", ")", "\n", "\n", "", "eta", "=", "tmp_eta", "/", "self", ".", "_std", "\n", "return", "eta", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.attack": [[84, 107], ["YOPOpgd.FASTPGD.to", "net.eval", "range", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "YOPOpgd.FASTPGD.single_attack", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.single_attack"], ["", "def", "attack", "(", "self", ",", "net", ",", "inp", ",", "label", ",", "target", "=", "None", ")", ":", "\n", "\n", "        ", "if", "self", ".", "random_start", ":", "\n", "            ", "eta", "=", "torch", ".", "FloatTensor", "(", "*", "inp", ".", "shape", ")", ".", "uniform_", "(", "-", "self", ".", "eps", ",", "self", ".", "eps", ")", "\n", "", "else", ":", "\n", "            ", "eta", "=", "torch", ".", "zeros_like", "(", "inp", ")", "\n", "", "eta", "=", "eta", ".", "to", "(", "self", ".", "DEVICE", ")", "\n", "eta", "=", "(", "eta", "-", "self", ".", "_mean", ")", "/", "self", ".", "_std", "\n", "net", ".", "eval", "(", ")", "\n", "\n", "inp", ".", "requires_grad", "=", "True", "\n", "eta", ".", "requires_grad", "=", "True", "\n", "for", "i", "in", "range", "(", "self", ".", "nb_iter", ")", ":", "\n", "            ", "eta", "=", "self", ".", "single_attack", "(", "net", ",", "inp", ",", "label", ",", "eta", ",", "target", ")", "\n", "#print(i)", "\n", "\n", "#print(eta.max())", "\n", "", "adv_inp", "=", "inp", "+", "eta", "\n", "tmp_adv_inp", "=", "adv_inp", "*", "self", ".", "_std", "+", "self", ".", "_mean", "\n", "tmp_adv_inp", "=", "torch", ".", "clamp", "(", "tmp_adv_inp", ",", "0", ",", "1", ")", "\n", "adv_inp", "=", "(", "tmp_adv_inp", "-", "self", ".", "_mean", ")", "/", "self", ".", "_std", "\n", "\n", "return", "adv_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to": [[108, 113], ["YOPOpgd.FASTPGD._mean.to", "YOPOpgd.FASTPGD._std.to", "YOPOpgd.FASTPGD.criterion.to"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "self", ".", "DEVICE", "=", "device", "\n", "self", ".", "_mean", "=", "self", ".", "_mean", ".", "to", "(", "device", ")", "\n", "self", ".", "_std", "=", "self", ".", "_std", ".", "to", "(", "device", ")", "\n", "self", ".", "criterion", "=", "self", ".", "criterion", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.gcn.GCN.__init__": [[8, 26], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "gcn.GCN.modules", "torch.PReLU", "torch.PReLU", "torch.Parameter", "torch.Parameter", "gcn.GCN.bias1.data.fill_", "torch.Parameter", "torch.Parameter", "gcn.GCN.bias2.data.fill_", "gcn.GCN.register_parameter", "gcn.GCN.register_parameter", "gcn.GCN.weights_init", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.weights_init"], ["from", "deeprobust", ".", "graph", "import", "utils", "\n", "from", "copy", "import", "deepcopy", "\n", "from", "sklearn", ".", "metrics", "import", "f1_score", "\n", "\n", "class", "GraphConvolution", "(", "Module", ")", ":", "\n", "    ", "\"\"\"Simple GCN layer, similar to https://github.com/tkipf/pygcn\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "with_bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "GraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "if", "with_bias", ":", "\n", "            ", "self", ".", "bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.gcn.GCN.weights_init": [[27, 32], ["isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "m.bias.data.fill_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "weight", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.gcn.GCN.forward": [[34, 54], ["deeprobust.graph.utils.normalize_adj_tensor", "gcn.GCN.fc1", "gcn.GCN.act", "gcn.GCN.dropout", "gcn.GCN.fc2", "gcn.GCN.act", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.spmm", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.graph.utils.normalize_adj_tensor"], ["        ", "\"\"\" Graph Convolutional Layer forward function\n        \"\"\"", "\n", "if", "input", ".", "data", ".", "is_sparse", ":", "\n", "            ", "support", "=", "torch", ".", "spmm", "(", "input", ",", "self", ".", "weight", ")", "\n", "", "else", ":", "\n", "            ", "support", "=", "torch", ".", "mm", "(", "input", ",", "self", ".", "weight", ")", "\n", "", "output", "=", "torch", ".", "spmm", "(", "adj", ",", "support", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "return", "output", "+", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "return", "output", "\n", "\n", "", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "' ('", "+", "str", "(", "self", ".", "in_features", ")", "+", "' -> '", "+", "str", "(", "self", ".", "out_features", ")", "+", "')'", "\n", "\n", "\n", "", "", "class", "GCN", "(", "nn", ".", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.__init__": [[9, 18], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "num_hidden", ":", "int", ",", "num_proj_hidden", ":", "int", ",", "tau", ":", "float", "=", "0.5", ")", ":", "\n", "        ", "super", "(", "GRACE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "tau", ":", "float", "=", "tau", "\n", "\n", "self", ".", "fc1", "=", "torch", ".", "nn", ".", "Linear", "(", "num_hidden", ",", "num_proj_hidden", ")", "\n", "self", ".", "fc2", "=", "torch", ".", "nn", ".", "Linear", "(", "num_proj_hidden", ",", "num_hidden", ")", "\n", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.forward": [[19, 21], ["model.GRACE.encoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "adj", ",", "sparse", "=", "False", ")", ":", "\n", "        ", "return", "self", ".", "encoder", "(", "x", ",", "adj", ",", "sparse", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.projection": [[22, 25], ["torch.elu", "torch.elu", "model.GRACE.fc2", "model.GRACE.fc1"], "methods", ["None"], ["", "def", "projection", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "z", "=", "F", ".", "elu", "(", "self", ".", "fc1", "(", "z", ")", ")", "\n", "return", "self", ".", "fc2", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.sim": [[26, 30], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.normalize.t"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["", "def", "sim", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "z1", "=", "F", ".", "normalize", "(", "z1", ")", "\n", "z2", "=", "F", ".", "normalize", "(", "z2", ")", "\n", "return", "torch", ".", "mm", "(", "z1", ",", "z2", ".", "t", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.semi_loss": [[31, 37], ["f", "f", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "model.GRACE.sim", "model.GRACE.sim", "torch.log", "torch.log", "torch.log", "torch.log", "f.diag", "f.diag", "f.sum", "f.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim"], ["", "def", "semi_loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "f", "=", "lambda", "x", ":", "torch", ".", "exp", "(", "x", "/", "self", ".", "tau", ")", "\n", "refl_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", ",", "z1", ")", ")", "\n", "between_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", ",", "z2", ")", ")", "\n", "\n", "return", "-", "torch", ".", "log", "(", "between_sim", ".", "diag", "(", ")", "/", "(", "refl_sim", ".", "sum", "(", "1", ")", "+", "between_sim", ".", "sum", "(", "1", ")", "-", "refl_sim", ".", "diag", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.batched_semi_loss": [[38, 57], ["z1.size", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "f", "f", "losses.append", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "model.GRACE.sim", "model.GRACE.sim", "torch.log", "torch.log", "torch.log", "torch.log", "between_sim[].diag", "refl_sim[].diag", "f.sum", "f.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim"], ["", "def", "batched_semi_loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ",", "batch_size", ":", "int", ")", ":", "\n", "# Space complexity: O(BN) (semi_loss: O(N^2))", "\n", "        ", "device", "=", "z1", ".", "device", "\n", "num_nodes", "=", "z1", ".", "size", "(", "0", ")", "\n", "num_batches", "=", "(", "num_nodes", "-", "1", ")", "//", "batch_size", "+", "1", "\n", "f", "=", "lambda", "x", ":", "torch", ".", "exp", "(", "x", "/", "self", ".", "tau", ")", "\n", "indices", "=", "torch", ".", "arange", "(", "0", ",", "num_nodes", ")", ".", "to", "(", "device", ")", "\n", "losses", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_batches", ")", ":", "\n", "            ", "mask", "=", "indices", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", "\n", "refl_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", "[", "mask", "]", ",", "z1", ")", ")", "# [B, N]", "\n", "between_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", "[", "mask", "]", ",", "z2", ")", ")", "# [B, N]", "\n", "\n", "losses", ".", "append", "(", "-", "torch", ".", "log", "(", "between_sim", "[", ":", ",", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ".", "diag", "(", ")", "\n", "/", "(", "refl_sim", ".", "sum", "(", "1", ")", "+", "between_sim", ".", "sum", "(", "1", ")", "\n", "-", "refl_sim", "[", ":", ",", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ".", "diag", "(", ")", ")", ")", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.differentiable_models.model.GRACE.loss": [[58, 73], ["model.GRACE.projection", "model.GRACE.projection", "model.GRACE.semi_loss", "model.GRACE.semi_loss", "model.GRACE.batched_semi_loss", "model.GRACE.batched_semi_loss", "ret.mean", "ret.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.batched_semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.batched_semi_loss"], ["", "def", "loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ",", "mean", ":", "bool", "=", "True", ",", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "h1", "=", "self", ".", "projection", "(", "z1", ")", "\n", "h2", "=", "self", ".", "projection", "(", "z2", ")", "\n", "\n", "if", "batch_size", "is", "None", ":", "\n", "            ", "l1", "=", "self", ".", "semi_loss", "(", "h1", ",", "h2", ")", "\n", "l2", "=", "self", ".", "semi_loss", "(", "h2", ",", "h1", ")", "\n", "", "else", ":", "\n", "            ", "l1", "=", "self", ".", "batched_semi_loss", "(", "h1", ",", "h2", ",", "batch_size", ")", "\n", "l2", "=", "self", ".", "batched_semi_loss", "(", "h2", ",", "h1", ",", "batch_size", ")", "\n", "\n", "", "ret", "=", "(", "l1", "+", "l2", ")", "*", "0.5", "\n", "ret", "=", "ret", ".", "mean", "(", ")", "if", "mean", "else", "ret", ".", "sum", "(", ")", "\n", "\n", "return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.MulticlassEvaluator.__init__": [[108, 110], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.MulticlassEvaluator._eval": [[111, 118], ["y_true.view.view.view", "y_pred.view.view.view", "y_true.view.view.size"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_eval", "(", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "y_true", "=", "y_true", ".", "view", "(", "-", "1", ")", "\n", "y_pred", "=", "y_pred", ".", "view", "(", "-", "1", ")", "\n", "total", "=", "y_true", ".", "size", "(", "0", ")", "\n", "correct", "=", "(", "y_true", "==", "y_pred", ")", ".", "to", "(", "torch", ".", "float32", ")", ".", "sum", "(", ")", "\n", "return", "(", "correct", "/", "total", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.MulticlassEvaluator.eval": [[119, 121], ["eval.MulticlassEvaluator._eval"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator._eval"], ["", "def", "eval", "(", "self", ",", "res", ")", ":", "\n", "        ", "return", "{", "'acc'", ":", "self", ".", "_eval", "(", "**", "res", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.__init__": [[124, 126], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator._eval": [[127, 134], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "torch.cat().to", "sklearn.metrics.roc_auc_score", "torch.cat().to.detach().cpu().numpy", "torch.cat().to.detach().cpu().numpy", "torch.cat().to.detach().cpu().numpy", "ranking_scores.detach().cpu().numpy", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().to.detach().cpu", "torch.cat().to.detach().cpu", "torch.cat().to.detach().cpu", "ranking_scores.detach().cpu", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.cat().to.detach", "torch.cat().to.detach", "torch.cat().to.detach", "ranking_scores.detach"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "@", "staticmethod", "\n", "def", "_eval", "(", "scores", ",", "negative_edge_index", ",", "target_edge_index", ")", ":", "\n", "        ", "edge_index", "=", "torch", ".", "cat", "(", "[", "negative_edge_index", ",", "target_edge_index", "]", ",", "-", "1", ")", "\n", "ranking_scores", "=", "scores", "[", "edge_index", "[", "0", "]", ",", "edge_index", "[", "1", "]", "]", "\n", "ranking_labels", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "negative_edge_index", ".", "shape", "[", "1", "]", ")", ",", "torch", ".", "ones", "(", "target_edge_index", ".", "shape", "[", "1", "]", ")", "]", ")", ".", "to", "(", "scores", ".", "device", ")", "\n", "auc", "=", "roc_auc_score", "(", "ranking_labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "ranking_scores", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "auc", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval": [[135, 137], ["eval.LPEvaluator._eval"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator._eval"], ["", "def", "eval", "(", "self", ",", "res", ")", ":", "\n", "        ", "return", "self", ".", "_eval", "(", "**", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.get_idx_split": [[13, 40], ["float", "data.x.size", "int", "torch.randperm", "torch.randperm", "torch.randperm", "split.startswith", "split.startswith", "split.split", "RuntimeError"], "function", ["None"], ["def", "get_idx_split", "(", "data", ",", "split", ",", "preload_split", ")", ":", "\n", "    ", "if", "split", "[", ":", "4", "]", "==", "'rand'", ":", "\n", "        ", "train_ratio", "=", "float", "(", "split", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "num_nodes", "=", "data", ".", "x", ".", "size", "(", "0", ")", "\n", "train_size", "=", "int", "(", "num_nodes", "*", "train_ratio", ")", "\n", "indices", "=", "torch", ".", "randperm", "(", "num_nodes", ")", "\n", "return", "{", "\n", "'train'", ":", "indices", "[", ":", "train_size", "]", ",", "\n", "'val'", ":", "indices", "[", "train_size", ":", "2", "*", "train_size", "]", ",", "\n", "'test'", ":", "indices", "[", "2", "*", "train_size", ":", "]", "\n", "}", "\n", "", "elif", "split", ".", "startswith", "(", "'cora'", ")", "or", "split", ".", "startswith", "(", "'citeseer'", ")", ":", "\n", "        ", "return", "{", "\n", "'train'", ":", "data", ".", "train_mask", ",", "\n", "'test'", ":", "data", ".", "test_mask", ",", "\n", "'val'", ":", "data", ".", "val_mask", "\n", "}", "\n", "", "elif", "split", "==", "'preloaded'", ":", "\n", "        ", "assert", "preload_split", "is", "not", "None", ",", "'use preloaded split, but preloaded_split is None'", "\n", "train_mask", ",", "test_mask", ",", "val_mask", "=", "preload_split", "\n", "return", "{", "\n", "'train'", ":", "train_mask", ",", "\n", "'test'", ":", "test_mask", ",", "\n", "'val'", ":", "val_mask", "\n", "}", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "f'Unknown split type {split}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.log_regression": [[42, 105], ["z.detach().to.detach().to", "z.detach().to.size", "data.y.view().to", "pGRACE.model.LogReg().to", "torch.optim.Adam", "eval.get_idx_split", "torch.LogSoftmax", "torch.NLLLoss", "range", "data.y.max().item", "LogReg().to.parameters", "v.to", "LogReg().to.train", "torch.optim.Adam.zero_grad", "LogReg().to.", "nn.NLLLoss.", "nll_loss.backward", "torch.optim.Adam.step", "z.detach().to.detach", "data.y.view", "pGRACE.model.LogReg", "get_idx_split.items", "nn.LogSoftmax.", "data.y.max", "print", "evaluator.eval", "evaluator.eval", "evaluator.eval", "y[].view", "LogReg().to.argmax().view", "y[].view", "LogReg().to.argmax().view", "y[].view", "LogReg().to.argmax().view", "LogReg().to.argmax", "LogReg().to.argmax", "LogReg().to.argmax", "LogReg().to.", "LogReg().to.", "LogReg().to."], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.get_idx_split", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval"], ["", "", "def", "log_regression", "(", "z", ",", "\n", "data", ",", "\n", "evaluator", ",", "\n", "num_epochs", ":", "int", "=", "5000", ",", "\n", "test_device", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "split", ":", "str", "=", "'rand:0.1'", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", "preload_split", "=", "None", ",", "\n", ")", ":", "\n", "    ", "test_device", "=", "z", ".", "device", "if", "test_device", "is", "None", "else", "test_device", "\n", "z", "=", "z", ".", "detach", "(", ")", ".", "to", "(", "test_device", ")", "\n", "num_hidden", "=", "z", ".", "size", "(", "1", ")", "\n", "y", "=", "data", ".", "y", ".", "view", "(", "-", "1", ")", ".", "to", "(", "test_device", ")", "\n", "num_classes", "=", "data", ".", "y", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", "\n", "classifier", "=", "LogReg", "(", "num_hidden", ",", "num_classes", ")", ".", "to", "(", "test_device", ")", "\n", "optimizer", "=", "Adam", "(", "classifier", ".", "parameters", "(", ")", ",", "lr", "=", "0.01", ",", "weight_decay", "=", "0.0", ")", "\n", "\n", "split", "=", "get_idx_split", "(", "data", ",", "split", ",", "preload_split", ")", "\n", "split", "=", "{", "k", ":", "v", ".", "to", "(", "test_device", ")", "for", "k", ",", "v", "in", "split", ".", "items", "(", ")", "}", "\n", "f", "=", "nn", ".", "LogSoftmax", "(", "dim", "=", "-", "1", ")", "\n", "nll_loss", "=", "nn", ".", "NLLLoss", "(", ")", "\n", "\n", "best_test_acc", "=", "0", "\n", "best_val_acc", "=", "0", "\n", "best_epoch", "=", "0", "\n", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "classifier", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "output", "=", "classifier", "(", "z", "[", "split", "[", "'train'", "]", "]", ")", "\n", "loss", "=", "nll_loss", "(", "f", "(", "output", ")", ",", "y", "[", "split", "[", "'train'", "]", "]", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "(", "epoch", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "            ", "if", "'val'", "in", "split", ":", "\n", "# val split is available", "\n", "                ", "test_acc", "=", "evaluator", ".", "eval", "(", "{", "\n", "'y_true'", ":", "y", "[", "split", "[", "'test'", "]", "]", ".", "view", "(", "-", "1", ",", "1", ")", ",", "\n", "'y_pred'", ":", "classifier", "(", "z", "[", "split", "[", "'test'", "]", "]", ")", ".", "argmax", "(", "-", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "}", ")", "[", "'acc'", "]", "\n", "val_acc", "=", "evaluator", ".", "eval", "(", "{", "\n", "'y_true'", ":", "y", "[", "split", "[", "'val'", "]", "]", ".", "view", "(", "-", "1", ",", "1", ")", ",", "\n", "'y_pred'", ":", "classifier", "(", "z", "[", "split", "[", "'val'", "]", "]", ")", ".", "argmax", "(", "-", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "}", ")", "[", "'acc'", "]", "\n", "if", "val_acc", ">", "best_val_acc", ":", "\n", "                    ", "best_val_acc", "=", "val_acc", "\n", "best_test_acc", "=", "test_acc", "\n", "best_epoch", "=", "epoch", "\n", "", "", "else", ":", "\n", "                ", "acc", "=", "evaluator", ".", "eval", "(", "{", "\n", "'y_true'", ":", "y", "[", "split", "[", "'test'", "]", "]", ".", "view", "(", "-", "1", ",", "1", ")", ",", "\n", "'y_pred'", ":", "classifier", "(", "z", "[", "split", "[", "'test'", "]", "]", ")", ".", "argmax", "(", "-", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "}", ")", "[", "'acc'", "]", "\n", "if", "best_test_acc", "<", "acc", ":", "\n", "                    ", "best_test_acc", "=", "acc", "\n", "best_epoch", "=", "epoch", "\n", "", "", "if", "verbose", ":", "\n", "                ", "print", "(", "f'logreg epoch {epoch}: best test acc {best_test_acc}'", ")", "\n", "\n", "", "", "", "return", "{", "'acc'", ":", "best_test_acc", ",", "'model'", ":", "classifier", ",", "'split'", ":", "split", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.link_prediction": [[139, 200], ["z.detach().to.detach().to", "z.detach().to.size", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor.to_dense().to", "torch.nonzero().t", "torch.nonzero().t", "torch.nonzero().t", "pGRACE.model.LogReg().to", "torch.optim.Adam", "range", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "LogReg().to.parameters", "LogReg().to.train", "torch.optim.Adam.zero_grad", "LogReg().to.", "torch.normalize", "torch.mm", "torch.mm", "torch.mm", "torch_geometric.utils.structured_negative_sampling", "loss.backward", "torch.optim.Adam.step", "z.detach().to.detach", "torch.sparse.FloatTensor.to_dense", "torch.nonzero", "torch.nonzero", "torch.nonzero", "pGRACE.model.LogReg", "F.normalize.t", "eval..", "torch.log().sum", "torch.log().sum", "torch.log().sum", "evaluator.eval", "evaluator.eval", "torch.ones", "torch.ones", "torch.ones", "torch.eye", "torch.eye", "torch.eye", "print", "torch.log", "torch.log", "torch.log", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.netmodels.densenet.train", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.defense.YOPO.FastGradientLayerOneTrainer.step", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.eval.LPEvaluator.eval"], ["", "", "def", "link_prediction", "(", "z", ",", "\n", "edge_index", ",", "\n", "train_edge_index", ",", "\n", "val_edge_index", ",", "\n", "test_edge_index", ",", "\n", "num_nodes", ",", "\n", "evaluator", ",", "\n", "num_epochs", ":", "int", "=", "5000", ",", "\n", "test_device", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "test_device", "=", "z", ".", "device", "if", "test_device", "is", "None", "else", "test_device", "\n", "z", "=", "z", ".", "detach", "(", ")", ".", "to", "(", "test_device", ")", "\n", "num_hidden", "=", "z", ".", "size", "(", "1", ")", "\n", "observed_edge_sp_adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index", ",", "\n", "torch", ".", "ones", "(", "edge_index", ".", "shape", "[", "1", "]", ")", ".", "to", "(", "test_device", ")", ",", "\n", "[", "num_nodes", ",", "num_nodes", "]", ")", "\n", "observed_edge_adj", "=", "observed_edge_sp_adj", ".", "to_dense", "(", ")", ".", "to", "(", "test_device", ")", "\n", "negative_edges", "=", "1", "-", "observed_edge_adj", "-", "torch", ".", "eye", "(", "num_nodes", ")", ".", "to", "(", "test_device", ")", "\n", "negative_edge_index", "=", "torch", ".", "nonzero", "(", "negative_edges", ")", ".", "t", "(", ")", "\n", "\n", "projecter", "=", "LogReg", "(", "num_hidden", ",", "num_hidden", ")", ".", "to", "(", "test_device", ")", "\n", "optimizer", "=", "Adam", "(", "projecter", ".", "parameters", "(", ")", ",", "lr", "=", "0.01", ",", "weight_decay", "=", "0.0", ")", "\n", "\n", "best_test_auc", "=", "0", "\n", "best_val_auc", "=", "0", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "projecter", ".", "train", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "output", "=", "projecter", "(", "z", ")", "\n", "output", "=", "F", ".", "normalize", "(", "output", ")", "\n", "scores", "=", "torch", ".", "mm", "(", "output", ",", "output", ".", "t", "(", ")", ")", "\n", "\n", "edge_index_with_self_loops", "=", "add_self_loops", "(", "train_edge_index", ")", "[", "0", "]", "\n", "train_u", ",", "train_i", ",", "train_j", "=", "structured_negative_sampling", "(", "edge_index_with_self_loops", ",", "num_nodes", ")", "\n", "train_u", "=", "train_u", "[", ":", "train_edge_index", ".", "shape", "[", "1", "]", "]", "\n", "train_i", "=", "train_i", "[", ":", "train_edge_index", ".", "shape", "[", "1", "]", "]", "\n", "train_j", "=", "train_j", "[", ":", "train_edge_index", ".", "shape", "[", "1", "]", "]", "\n", "loss", "=", "-", "torch", ".", "log", "(", "torch", ".", "sigmoid", "(", "scores", "[", "train_u", ",", "train_i", "]", "-", "scores", "[", "train_u", ",", "train_j", "]", ")", ")", ".", "sum", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "(", "epoch", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "            ", "test_auc", "=", "evaluator", ".", "eval", "(", "{", "\n", "'scores'", ":", "scores", ",", "\n", "'negative_edge_index'", ":", "negative_edge_index", ",", "\n", "'target_edge_index'", ":", "test_edge_index", "\n", "}", ")", "\n", "val_auc", "=", "evaluator", ".", "eval", "(", "{", "\n", "'scores'", ":", "scores", ",", "\n", "'negative_edge_index'", ":", "negative_edge_index", ",", "\n", "'target_edge_index'", ":", "val_edge_index", "\n", "}", ")", "\n", "if", "val_auc", ">", "best_val_auc", ":", "\n", "                ", "best_val_auc", "=", "val_auc", "\n", "best_test_auc", "=", "test_auc", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "f'logreg epoch {epoch}: best test acc {best_test_auc}'", ")", "\n", "\n", "", "", "", "return", "{", "'auc'", ":", "best_test_auc", ",", "'model'", ":", "projecter", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.dataset.get_dataset": [[9, 36], ["name.startswith", "torch_geometric.datasets.TUDataset", "torch_geometric.datasets.Coauthor", "torch_geometric.datasets.Coauthor", "torch_geometric.datasets.WikiCS", "torch_geometric.datasets.Amazon", "torch_geometric.datasets.Amazon", "ogb.nodeproppred.PygNodePropPredDataset", "os.join", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "torch_geometric.NormalizeFeatures", "os.join", "torch_geometric.NormalizeFeatures"], "function", ["None"], ["from", "deeprobust", ".", "graph", ".", "utils", "import", "get_train_val_test", ",", "get_train_val_test_gcn", "\n", "import", "zipfile", "\n", "\n", "class", "Dataset", "(", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.Encoder.__init__": [[11, 34], ["torch.nn.Module.__init__", "range", "model.Encoder.conv.append", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "range", "torch.nn.ModuleList", "torch.nn.ModuleList", "base_model().jittable", "model.Encoder.conv.append", "base_model", "base_model", "model.Encoder.conv.append", "base_model", "base_model", "base_model"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["self", ".", "encoder", "=", "encoder", "\n", "self", ".", "tau", ":", "float", "=", "tau", "\n", "\n", "self", ".", "fc1", "=", "torch", ".", "nn", ".", "Linear", "(", "num_hidden", ",", "num_proj_hidden", ")", "\n", "self", ".", "fc2", "=", "torch", ".", "nn", ".", "Linear", "(", "num_proj_hidden", ",", "num_hidden", ")", "\n", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "adj", ",", "sparse", "=", "False", ")", ":", "\n", "        ", "return", "self", ".", "encoder", "(", "x", ",", "adj", ",", "sparse", ")", "\n", "\n", "", "def", "projection", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "z", "=", "F", ".", "elu", "(", "self", ".", "fc1", "(", "z", ")", ")", "\n", "return", "self", ".", "fc2", "(", "z", ")", "\n", "\n", "", "def", "sim", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "z1", "=", "F", ".", "normalize", "(", "z1", ")", "\n", "z2", "=", "F", ".", "normalize", "(", "z2", ")", "\n", "return", "torch", ".", "mm", "(", "z1", ",", "z2", ".", "t", "(", ")", ")", "\n", "\n", "", "def", "semi_loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "f", "=", "lambda", "x", ":", "torch", ".", "exp", "(", "x", "/", "self", ".", "tau", ")", "\n", "refl_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", ",", "z1", ")", ")", "\n", "between_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", ",", "z2", ")", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.Encoder.forward": [[35, 47], ["range", "model.Encoder.activation", "range", "model.Encoder.activation", "model.Encoder.fc_skip", "sum", "hs.append", "model.Encoder.activation"], "methods", ["None"], ["\n", "return", "-", "torch", ".", "log", "(", "between_sim", ".", "diag", "(", ")", "/", "(", "refl_sim", ".", "sum", "(", "1", ")", "+", "between_sim", ".", "sum", "(", "1", ")", "-", "refl_sim", ".", "diag", "(", ")", ")", ")", "\n", "\n", "", "def", "batched_semi_loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ",", "batch_size", ":", "int", ")", ":", "\n", "# Space complexity: O(BN) (semi_loss: O(N^2))", "\n", "        ", "device", "=", "z1", ".", "device", "\n", "num_nodes", "=", "z1", ".", "size", "(", "0", ")", "\n", "num_batches", "=", "(", "num_nodes", "-", "1", ")", "//", "batch_size", "+", "1", "\n", "f", "=", "lambda", "x", ":", "torch", ".", "exp", "(", "x", "/", "self", ".", "tau", ")", "\n", "indices", "=", "torch", ".", "arange", "(", "0", ",", "num_nodes", ")", ".", "to", "(", "device", ")", "\n", "losses", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_batches", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.__init__": [[50, 59], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__"], ["between_sim", "=", "f", "(", "self", ".", "sim", "(", "z1", "[", "mask", "]", ",", "z2", ")", ")", "# [B, N]", "\n", "\n", "losses", ".", "append", "(", "-", "torch", ".", "log", "(", "between_sim", "[", ":", ",", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ".", "diag", "(", ")", "\n", "/", "(", "refl_sim", ".", "sum", "(", "1", ")", "+", "between_sim", ".", "sum", "(", "1", ")", "\n", "-", "refl_sim", "[", ":", ",", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ".", "diag", "(", ")", ")", ")", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "losses", ")", "\n", "\n", "", "def", "loss", "(", "self", ",", "z1", ":", "torch", ".", "Tensor", ",", "z2", ":", "torch", ".", "Tensor", ",", "mean", ":", "bool", "=", "True", ",", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "h1", "=", "self", ".", "projection", "(", "z1", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.forward": [[60, 62], ["model.GRACE.encoder"], "methods", ["None"], ["h2", "=", "self", ".", "projection", "(", "z2", ")", "\n", "\n", "if", "batch_size", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection": [[63, 66], ["torch.elu", "torch.elu", "model.GRACE.fc2", "model.GRACE.fc1"], "methods", ["None"], ["            ", "l1", "=", "self", ".", "semi_loss", "(", "h1", ",", "h2", ")", "\n", "l2", "=", "self", ".", "semi_loss", "(", "h2", ",", "h1", ")", "\n", "", "else", ":", "\n", "            ", "l1", "=", "self", ".", "batched_semi_loss", "(", "h1", ",", "h2", ",", "batch_size", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim": [[67, 71], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.normalize.t"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize", "home.repos.pwc.inspect_result.rinnesz_clga.attack.BPDA.normalize"], ["l2", "=", "self", ".", "batched_semi_loss", "(", "h2", ",", "h1", ",", "batch_size", ")", "\n", "\n", "", "ret", "=", "(", "l1", "+", "l2", ")", "*", "0.5", "\n", "ret", "=", "ret", ".", "mean", "(", ")", "if", "mean", "else", "ret", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.semi_loss": [[72, 78], ["f", "f", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "model.GRACE.sim", "model.GRACE.sim", "torch.log", "torch.log", "torch.log", "torch.log", "f.diag", "f.diag", "f.sum", "f.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim"], ["return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.batched_semi_loss": [[79, 98], ["z1.size", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "f", "f", "losses.append", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "model.GRACE.sim", "model.GRACE.sim", "torch.log", "torch.log", "torch.log", "torch.log", "between_sim[].diag", "refl_sim[].diag", "f.sum", "f.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.sim"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.loss": [[99, 114], ["model.GRACE.projection", "model.GRACE.projection", "model.GRACE.semi_loss", "model.GRACE.semi_loss", "model.GRACE.batched_semi_loss", "model.GRACE.batched_semi_loss", "ret.mean", "ret.sum"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.projection", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.batched_semi_loss", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.GRACE.batched_semi_loss"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__": [[117, 123], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "model.LogReg.modules", "model.LogReg.weights_init"], "methods", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.__init__", "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.weights_init"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.weights_init": [[124, 129], ["isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "m.bias.data.fill_"], "methods", ["None"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.model.LogReg.forward": [[130, 133], ["model.LogReg.fc"], "methods", ["None"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature": [[7, 13], ["x.clone.clone", "torch.empty().uniform_", "torch.empty", "x.clone.size"], "function", ["None"], ["def", "drop_feature", "(", "x", ",", "drop_prob", ")", ":", "\n", "    ", "drop_mask", "=", "torch", ".", "empty", "(", "(", "x", ".", "size", "(", "1", ")", ",", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "x", ".", "device", ")", ".", "uniform_", "(", "0", ",", "1", ")", "<", "drop_prob", "\n", "x", "=", "x", ".", "clone", "(", ")", "\n", "x", "[", ":", ",", "drop_mask", "]", "=", "0", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_feature_weighted": [[15, 26], ["w.where.where", "torch.bernoulli().to", "x.clone.clone", "w.where.mean", "torch.ones_like", "torch.bernoulli"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "drop_feature_weighted", "(", "x", ",", "w", ",", "p", ":", "float", ",", "threshold", ":", "float", "=", "0.7", ")", ":", "\n", "    ", "w", "=", "w", "/", "w", ".", "mean", "(", ")", "*", "p", "\n", "w", "=", "w", ".", "where", "(", "w", "<", "threshold", ",", "torch", ".", "ones_like", "(", "w", ")", "*", "threshold", ")", "\n", "drop_prob", "=", "w", "\n", "\n", "drop_mask", "=", "torch", ".", "bernoulli", "(", "drop_prob", ")", ".", "to", "(", "torch", ".", "bool", ")", "\n", "\n", "x", "=", "x", ".", "clone", "(", ")", "\n", "x", "[", ":", ",", "drop_mask", "]", "=", "0.", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights": [[28, 35], ["x.to().to.to().to", "w.log.log", "x.to().to.t", "x.to().to.to", "w.log.max", "w.log.max", "w.log.mean"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "feature_drop_weights", "(", "x", ",", "node_c", ")", ":", "\n", "    ", "x", "=", "x", ".", "to", "(", "torch", ".", "bool", ")", ".", "to", "(", "torch", ".", "float32", ")", "\n", "w", "=", "x", ".", "t", "(", ")", "@", "node_c", "\n", "w", "=", "w", ".", "log", "(", ")", "\n", "s", "=", "(", "w", ".", "max", "(", ")", "-", "w", ")", "/", "(", "w", ".", "max", "(", ")", "-", "w", ".", "mean", "(", ")", ")", "\n", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.feature_drop_weights_dense": [[37, 44], ["x.abs.abs", "w.log.log", "x.abs.t", "w.log.max", "w.log.max", "w.log.mean"], "function", ["None"], ["", "def", "feature_drop_weights_dense", "(", "x", ",", "node_c", ")", ":", "\n", "    ", "x", "=", "x", ".", "abs", "(", ")", "\n", "w", "=", "x", ".", "t", "(", ")", "@", "node_c", "\n", "w", "=", "w", ".", "log", "(", ")", "\n", "s", "=", "(", "w", ".", "max", "(", ")", "-", "w", ")", "/", "(", "w", ".", "max", "(", ")", "-", "w", ".", "mean", "(", ")", ")", "\n", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.drop_edge_weighted": [[46, 52], ["edge_weights.where.where", "torch.bernoulli().to", "edge_weights.where.mean", "torch.ones_like", "torch.bernoulli"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "drop_edge_weighted", "(", "edge_index", ",", "edge_weights", ",", "p", ":", "float", ",", "threshold", ":", "float", "=", "1.", ")", ":", "\n", "    ", "edge_weights", "=", "edge_weights", "/", "edge_weights", ".", "mean", "(", ")", "*", "p", "\n", "edge_weights", "=", "edge_weights", ".", "where", "(", "edge_weights", "<", "threshold", ",", "torch", ".", "ones_like", "(", "edge_weights", ")", "*", "threshold", ")", "\n", "sel_mask", "=", "torch", ".", "bernoulli", "(", "1.", "-", "edge_weights", ")", ".", "to", "(", "torch", ".", "bool", ")", "\n", "\n", "return", "edge_index", "[", ":", ",", "sel_mask", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.degree_drop_weights": [[54, 62], ["torch_geometric.utils.to_undirected", "torch_geometric.utils.degree", "deg[].to", "torch.log", "torch.log.max", "torch.log.max", "torch.log.mean"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "degree_drop_weights", "(", "edge_index", ")", ":", "\n", "    ", "edge_index_", "=", "to_undirected", "(", "edge_index", ")", "\n", "deg", "=", "degree", "(", "edge_index_", "[", "1", "]", ")", "\n", "deg_col", "=", "deg", "[", "edge_index", "[", "1", "]", "]", ".", "to", "(", "torch", ".", "float32", ")", "\n", "s_col", "=", "torch", ".", "log", "(", "deg_col", ")", "\n", "weights", "=", "(", "s_col", ".", "max", "(", ")", "-", "s_col", ")", "/", "(", "s_col", ".", "max", "(", ")", "-", "s_col", ".", "mean", "(", ")", ")", "\n", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.pr_drop_weights": [[64, 81], ["pGRACE.utils.compute_pr", "pv[].to", "pv[].to", "torch.log", "torch.log", "s.max", "s.max", "s.mean"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.compute_pr", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "def", "pr_drop_weights", "(", "edge_index", ",", "aggr", ":", "str", "=", "'sink'", ",", "k", ":", "int", "=", "10", ")", ":", "\n", "    ", "pv", "=", "compute_pr", "(", "edge_index", ",", "k", "=", "k", ")", "\n", "pv_row", "=", "pv", "[", "edge_index", "[", "0", "]", "]", ".", "to", "(", "torch", ".", "float32", ")", "\n", "pv_col", "=", "pv", "[", "edge_index", "[", "1", "]", "]", ".", "to", "(", "torch", ".", "float32", ")", "\n", "s_row", "=", "torch", ".", "log", "(", "pv_row", ")", "\n", "s_col", "=", "torch", ".", "log", "(", "pv_col", ")", "\n", "if", "aggr", "==", "'sink'", ":", "\n", "        ", "s", "=", "s_col", "\n", "", "elif", "aggr", "==", "'source'", ":", "\n", "        ", "s", "=", "s_row", "\n", "", "elif", "aggr", "==", "'mean'", ":", "\n", "        ", "s", "=", "(", "s_col", "+", "s_row", ")", "*", "0.5", "\n", "", "else", ":", "\n", "        ", "s", "=", "s_col", "\n", "", "weights", "=", "(", "s", ".", "max", "(", ")", "-", "s", ")", "/", "(", "s", ".", "max", "(", ")", "-", "s", ".", "mean", "(", ")", ")", "\n", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.functional.evc_drop_weights": [[83, 94], ["pGRACE.utils.eigenvector_centrality", "evc.where.where", "evc.where.log", "torch.zeros_like", "evc.log.max", "evc.log.max", "evc.log.mean"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.eigenvector_centrality"], ["", "def", "evc_drop_weights", "(", "data", ")", ":", "\n", "    ", "evc", "=", "eigenvector_centrality", "(", "data", ")", "\n", "evc", "=", "evc", ".", "where", "(", "evc", ">", "0", ",", "torch", ".", "zeros_like", "(", "evc", ")", ")", "\n", "evc", "=", "evc", "+", "1e-8", "\n", "s", "=", "evc", ".", "log", "(", ")", "\n", "\n", "edge_index", "=", "data", ".", "edge_index", "\n", "s_row", ",", "s_col", "=", "s", "[", "edge_index", "[", "0", "]", "]", ",", "s", "[", "edge_index", "[", "1", "]", "]", "\n", "s", "=", "s_col", "\n", "\n", "return", "(", "s", ".", "max", "(", ")", "-", "s", ")", "/", "(", "s", ".", "max", "(", ")", "-", "s", ".", "mean", "(", ")", ")", "", "", ""]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.get_base_model": [[11, 37], ["torch_geometric.nn.GATConv", "torch.Sequential", "torch_geometric.nn.GINConv", "torch.Linear", "torch.ELU", "torch.Linear"], "function", ["None"], ["\n", "eye", "=", "np", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", "\n", "\n", "", "def", "tensor2onehot", "(", "labels", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.get_activation": [[39, 50], ["torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.PReLU"], "function", ["None"], ["\n", "\n", "eye", "=", "torch", ".", "eye", "(", "labels", ".", "max", "(", ")", "+", "1", ")", "\n", "onehot_mx", "=", "eye", "[", "labels", "]", "\n", "return", "onehot_mx", ".", "to", "(", "labels", ".", "device", ")", "\n", "\n", "", "def", "preprocess", "(", "adj", ",", "features", ",", "labels", ",", "preprocess_adj", "=", "False", ",", "preprocess_feature", "=", "False", ",", "sparse", "=", "False", ",", "device", "=", "'cpu'", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.compute_pr": [[52, 64], ["torch_geometric.utils.degree", "torch.ones().to().to", "torch.ones().to().to", "torch.ones().to().to", "range", "edge_index.max().item", "torch_scatter.scatter", "torch.ones().to", "torch.ones().to", "torch.ones().to", "edge_index.max", "torch.ones", "torch.ones", "torch.ones"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], []], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.eigenvector_centrality": [[66, 71], ["torch_geometric.utils.to_networkx", "networkx.eigenvector_centrality_numpy", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "range", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["\n", "if", "preprocess_adj", ":", "\n", "        ", "adj", "=", "normalize_adj", "(", "adj", ")", "\n", "\n", "", "if", "preprocess_feature", ":", "\n", "        ", "features", "=", "normalize_feature", "(", "features", ")", "\n"]], "home.repos.pwc.inspect_result.rinnesz_clga.pGRACE.utils.generate_split": [[73, 90], ["int", "int", "torch.utils.data.random_split", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.arange", "torch.arange", "torch.arange", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to", "home.repos.pwc.inspect_result.rinnesz_clga.attack.YOPOpgd.FASTPGD.to"], ["", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "if", "sparse", ":", "\n", "        ", "adj", "=", "sparse_mx_to_torch_sparse_tensor", "(", "adj", ")", "\n", "features", "=", "sparse_mx_to_torch_sparse_tensor", "(", "features", ")", "\n", "", "else", ":", "\n", "        ", "features", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "features", ".", "todense", "(", ")", ")", ")", "\n", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ".", "todense", "(", ")", ")", "\n", "", "return", "adj", ".", "to", "(", "device", ")", ",", "features", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "def", "to_tensor", "(", "adj", ",", "features", ",", "labels", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "    "]]}