{"home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.__init__": [[26, 29], ["allennlp.predictors.predictor.Predictor.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Model", ",", "dataset_reader", ":", "DatasetReader", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ",", "dataset_reader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.predict": [[30, 32], ["dygie.DyGIEPredictor.predict_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json"], ["", "def", "predict", "(", "self", ",", "document", ")", ":", "\n", "        ", "return", "self", ".", "predict_json", "(", "document", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.predict_tokenized": [[33, 36], ["dygie.DyGIEPredictor._words_list_to_instance", "dygie.DyGIEPredictor.predict_instance"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.predict_instance"], ["", "def", "predict_tokenized", "(", "self", ",", "tokenized_document", ":", "List", "[", "str", "]", ")", "->", "JsonDict", ":", "\n", "        ", "instance", "=", "self", ".", "_words_list_to_instance", "(", "tokenized_document", ")", "\n", "return", "self", ".", "predict_instance", "(", "instance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor._json_to_instance": [[37, 40], ["dygie.DyGIEPredictor._dataset_reader.text_to_instance"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance"], ["", "@", "overrides", "\n", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "return", "self", ".", "_dataset_reader", ".", "text_to_instance", "(", "json_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.dump_line": [[41, 45], ["json.dumps"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "dump_line", "(", "self", ",", "outputs", ")", ":", "\n", "# Need to override to tell Python how to deal with Numpy ints.", "\n", "        ", "return", "json", ".", "dumps", "(", "outputs", ",", "default", "=", "int", ")", "+", "\"\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.dygie.DyGIEPredictor.predict_instance": [[47, 74], ["model._get_prediction_device", "allennlp.data.Batch", "allennlp.data.Batch.index_instances", "allennlp.nn.util.move_to_device", "model.make_output_human_readable().to_json", "allennlp.data.Batch.as_tensor_dict", "warnings.warn", "metadata.to_json", "model.make_output_human_readable", "model"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.make_output_human_readable"], ["", "@", "overrides", "\n", "def", "predict_instance", "(", "self", ",", "instance", ")", ":", "\n", "        ", "\"\"\"\n        An instance is an entire document, represented as a list of sentences.\n        \"\"\"", "\n", "model", "=", "self", ".", "_model", "\n", "cuda_device", "=", "model", ".", "_get_prediction_device", "(", ")", "\n", "\n", "# Try to predict this batch.", "\n", "try", ":", "\n", "            ", "dataset", "=", "Batch", "(", "[", "instance", "]", ")", "\n", "dataset", ".", "index_instances", "(", "model", ".", "vocab", ")", "\n", "model_input", "=", "util", ".", "move_to_device", "(", "dataset", ".", "as_tensor_dict", "(", ")", ",", "cuda_device", ")", "\n", "prediction", "=", "model", ".", "make_output_human_readable", "(", "model", "(", "**", "model_input", ")", ")", ".", "to_json", "(", ")", "\n", "# If we run out of GPU memory, warn user and indicate that this document failed.", "\n", "# This way, prediction doesn't grind to a halt every time we run out of GPU.", "\n", "", "except", "RuntimeError", "as", "err", ":", "\n", "# doc_key, dataset, sentences, message", "\n", "            ", "metadata", "=", "instance", "[", "\"metadata\"", "]", ".", "metadata", "\n", "doc_key", "=", "metadata", ".", "doc_key", "\n", "msg", "=", "(", "f\"Encountered a RunTimeError on document {doc_key}. Skipping this example.\"", "\n", "f\" Error message:\\n{err.args[0]}.\"", ")", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "prediction", "=", "metadata", ".", "to_json", "(", ")", "\n", "prediction", "[", "\"_FAILED_PREDICTION\"", "]", "=", "True", "\n", "\n", "", "return", "prediction", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.predictors.spart_predictor.SpartPredictor._json_to_instance": [[18, 46], ["allennlp.data.fields.TextField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.Instance", "allennlp.data.Token", "len", "spans.append", "span_masks.append", "allennlp.data.fields.MetadataField", "allennlp.data.fields.SpanField", "spart.data.dataset_readers.spart_reader.create_mask", "allennlp.data.fields.ArrayField", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_mask"], ["  ", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "    ", "if", "\"text\"", "in", "json_dict", ":", "\n", "      ", "text", "=", "json_dict", "[", "\"text\"", "]", "\n", "words", "=", "[", "text", "[", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "t", "in", "json_dict", "[", "\"tokens\"", "]", "]", "\n", "", "else", ":", "\n", "      ", "words", "=", "json_dict", "[", "\"tokens\"", "]", "\n", "\n", "", "tokens", "=", "[", "Token", "(", "w", ")", "for", "w", "in", "words", "]", "\n", "# Attribut (_dataset_reader._token_indexers ) wird durch unseren DataReader hinzugef\u00fcgt!", "\n", "# Nicht allgemein g\u00fcltig...", "\n", "token_indexers", "=", "self", ".", "_dataset_reader", ".", "_token_indexers", "\n", "sequence", "=", "TextField", "(", "tokens", ",", "token_indexers", "=", "token_indexers", ")", "\n", "\n", "context_size", "=", "len", "(", "words", ")", "+", "1", "\n", "spans", "=", "[", "]", "\n", "span_masks", "=", "[", "]", "\n", "for", "start", ",", "end", "in", "enumerate_spans", "(", "tokens", ",", "max_span_width", "=", "self", ".", "_dataset_reader", ".", "_max_span_width", ")", ":", "\n", "      ", "spans", ".", "append", "(", "SpanField", "(", "start", ",", "end", ",", "sequence", ")", ")", "\n", "span_masks", ".", "append", "(", "create_mask", "(", "start", ",", "end", ",", "context_size", ")", ")", "\n", "\n", "", "span_field", "=", "ListField", "(", "spans", ")", "\n", "# span_tuples = [(span.span_start, span.span_end) for span in spans]", "\n", "span_mask_field", "=", "ListField", "(", "[", "ArrayField", "(", "np", ".", "array", "(", "si", ",", "dtype", "=", "np", ".", "int", ")", ",", "dtype", "=", "np", ".", "int", ")", "for", "si", "in", "span_masks", "]", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", ",", "\n", "\"metadata\"", ":", "MetadataField", "(", "{", "\"words\"", ":", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "}", ")", ",", "\n", "\"spans\"", ":", "span_field", ",", "\n", "\"span_masks\"", ":", "span_mask_field", "}", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.spart_predictor.SpartPredictor.predict_json": [[47, 50], ["super().predict_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json"], ["", "def", "predict_json", "(", "self", ",", "inputs", ":", "JsonDict", ")", "->", "JsonDict", ":", "\n", "    ", "output_dict", "=", "super", "(", ")", ".", "predict_json", "(", "inputs", ")", "\n", "return", "output_dict", "[", "\"relations\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.predictors.spart_predictor.SpartPredictor.predict_batch_json": [[52, 55], ["super().predict_batch_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json"], ["", "def", "predict_batch_json", "(", "self", ",", "inputs", ":", "List", "[", "JsonDict", "]", ")", "->", "List", "[", "JsonDict", "]", ":", "\n", "    ", "output", "=", "super", "(", ")", ".", "predict_batch_json", "(", "inputs", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics.__init__": [[30, 32], ["event_metrics.EventMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics.__call__": [[33, 46], ["zip", "event_metrics.EventMetrics._score_triggers", "event_metrics.EventMetrics._score_arguments"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics._score_triggers", "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics._score_arguments"], ["", "@", "overrides", "\n", "def", "__call__", "(", "self", ",", "predicted_events_list", ",", "metadata_list", ")", ":", "\n", "        ", "for", "predicted_events", ",", "metadata", "in", "zip", "(", "predicted_events_list", ",", "metadata_list", ")", ":", "\n", "# Trigger scoring.", "\n", "            ", "predicted_triggers", "=", "predicted_events", "[", "\"trigger_dict\"", "]", "\n", "gold_triggers", "=", "metadata", ".", "events", ".", "trigger_dict", "\n", "self", ".", "_score_triggers", "(", "predicted_triggers", ",", "gold_triggers", ")", "\n", "\n", "# Argument scoring.", "\n", "predicted_arguments", "=", "predicted_events", "[", "\"argument_dict\"", "]", "\n", "gold_arguments", "=", "metadata", ".", "events", ".", "argument_dict", "\n", "self", ".", "_score_arguments", "(", "\n", "predicted_triggers", ",", "gold_triggers", ",", "predicted_arguments", ",", "gold_arguments", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics._score_triggers": [[47, 57], ["len", "len", "predicted_triggers.items"], "methods", ["None"], ["", "", "def", "_score_triggers", "(", "self", ",", "predicted_triggers", ",", "gold_triggers", ")", ":", "\n", "        ", "self", ".", "_gold_triggers", "+=", "len", "(", "gold_triggers", ")", "\n", "self", ".", "_predicted_triggers", "+=", "len", "(", "predicted_triggers", ")", "\n", "for", "token_ix", ",", "pred", "in", "predicted_triggers", ".", "items", "(", ")", ":", "\n", "            ", "label", "=", "pred", "[", "0", "]", "\n", "# Check whether the offsets match, and whether the labels match.", "\n", "if", "token_ix", "in", "gold_triggers", ":", "\n", "                ", "self", ".", "_matched_trigger_ids", "+=", "1", "\n", "if", "gold_triggers", "[", "token_ix", "]", "==", "label", ":", "\n", "                    ", "self", ".", "_matched_trigger_classes", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics._score_arguments": [[58, 90], ["event_metrics.EventMetrics._score_arguments.format"], "methods", ["None"], ["", "", "", "", "def", "_score_arguments", "(", "self", ",", "predicted_triggers", ",", "gold_triggers", ",", "predicted_arguments", ",", "gold_arguments", ")", ":", "\n", "# Note that the index of the trigger doesn't actually need to be correct to get full credit;", "\n", "# the event type and event role need to be correct (see Sec. 3 of paper).", "\n", "        ", "def", "format", "(", "arg_dict", ",", "trigger_dict", ",", "prediction", "=", "False", ")", ":", "\n", "# Make it a list of [index, event_type, arg_label].", "\n", "            ", "res", "=", "[", "]", "\n", "for", "(", "trigger_ix", ",", "arg_ix", ")", ",", "label", "in", "arg_dict", ".", "items", "(", ")", ":", "\n", "# If it doesn't match a trigger, don't predict it (enforced in decoding).", "\n", "                ", "if", "trigger_ix", "not", "in", "trigger_dict", ":", "\n", "                    ", "continue", "\n", "", "event_type", "=", "trigger_dict", "[", "trigger_ix", "]", "\n", "# TODO(dwadden) This is clunky; it's because predictions have confidence scores.", "\n", "if", "prediction", ":", "\n", "                    ", "event_type", "=", "event_type", "[", "0", "]", "\n", "label", "=", "label", "[", "0", "]", "\n", "", "res", ".", "append", "(", "(", "arg_ix", ",", "event_type", ",", "label", ")", ")", "\n", "", "return", "res", "\n", "\n", "", "formatted_gold_arguments", "=", "format", "(", "gold_arguments", ",", "gold_triggers", ",", "prediction", "=", "False", ")", "\n", "formatted_predicted_arguments", "=", "format", "(", "predicted_arguments", ",", "predicted_triggers", ",", "prediction", "=", "True", ")", "\n", "\n", "self", ".", "_gold_arguments", "+=", "len", "(", "formatted_gold_arguments", ")", "\n", "self", ".", "_predicted_arguments", "+=", "len", "(", "formatted_predicted_arguments", ")", "\n", "\n", "# Go through each predicted arg and look for a match.", "\n", "for", "entry", "in", "formatted_predicted_arguments", ":", "\n", "# No credit if not associated with a predicted trigger.", "\n", "            ", "class_match", "=", "int", "(", "any", "(", "[", "entry", "==", "gold", "for", "gold", "in", "formatted_gold_arguments", "]", ")", ")", "\n", "id_match", "=", "int", "(", "any", "(", "[", "entry", "[", ":", "2", "]", "==", "gold", "[", ":", "2", "]", "for", "gold", "in", "formatted_gold_arguments", "]", ")", ")", "\n", "\n", "self", ".", "_matched_argument_classes", "+=", "class_match", "\n", "self", ".", "_matched_argument_ids", "+=", "id_match", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics.get_metric": [[92, 113], ["dygie.training.f1.compute_f1", "dygie.training.f1.compute_f1", "dygie.training.f1.compute_f1", "dygie.training.f1.compute_f1", "event_metrics.EventMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "        ", "res", "=", "{", "}", "\n", "\n", "# Triggers", "\n", "res", "[", "\"trig_id_precision\"", "]", ",", "res", "[", "\"trig_id_recall\"", "]", ",", "res", "[", "\"trig_id_f1\"", "]", "=", "compute_f1", "(", "\n", "self", ".", "_predicted_triggers", ",", "self", ".", "_gold_triggers", ",", "self", ".", "_matched_trigger_ids", ")", "\n", "res", "[", "\"trig_class_precision\"", "]", ",", "res", "[", "\"trig_class_recall\"", "]", ",", "res", "[", "\"trig_class_f1\"", "]", "=", "compute_f1", "(", "\n", "self", ".", "_predicted_triggers", ",", "self", ".", "_gold_triggers", ",", "self", ".", "_matched_trigger_classes", ")", "\n", "\n", "# Arguments", "\n", "res", "[", "\"arg_id_precision\"", "]", ",", "res", "[", "\"arg_id_recall\"", "]", ",", "res", "[", "\"arg_id_f1\"", "]", "=", "compute_f1", "(", "\n", "self", ".", "_predicted_arguments", ",", "self", ".", "_gold_arguments", ",", "self", ".", "_matched_argument_ids", ")", "\n", "res", "[", "\"arg_class_precision\"", "]", ",", "res", "[", "\"arg_class_recall\"", "]", ",", "res", "[", "\"arg_class_f1\"", "]", "=", "compute_f1", "(", "\n", "self", ".", "_predicted_arguments", ",", "self", ".", "_gold_arguments", ",", "self", ".", "_matched_argument_classes", ")", "\n", "\n", "# Reset counts if at end of epoch.", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.EventMetrics.reset": [[114, 124], ["None"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_gold_triggers", "=", "0", "\n", "self", ".", "_predicted_triggers", "=", "0", "\n", "self", ".", "_matched_trigger_ids", "=", "0", "\n", "self", ".", "_matched_trigger_classes", "=", "0", "\n", "self", ".", "_gold_arguments", "=", "0", "\n", "self", ".", "_predicted_arguments", "=", "0", "\n", "self", ".", "_matched_argument_ids", "=", "0", "\n", "self", ".", "_matched_argument_classes", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.ArgumentStats.__init__": [[130, 132], ["event_metrics.ArgumentStats.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.ArgumentStats.__call__": [[133, 146], ["event_metrics._invert_arguments", "collections.Counter", "len", "len", "collections.Counter.items"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.training.event_metrics._invert_arguments"], ["", "@", "overrides", "\n", "def", "__call__", "(", "self", ",", "predicted_events_list", ")", ":", "\n", "        ", "for", "predicted_events", "in", "predicted_events_list", ":", "\n", "            ", "predicted_arguments", "=", "_invert_arguments", "(", "predicted_events", "[", "\"argument_dict\"", "]", ",", "\n", "predicted_events", "[", "\"trigger_dict\"", "]", ")", "\n", "# Count how many times each span appears as an argument.", "\n", "span_counts", "=", "Counter", "(", ")", "\n", "for", "prediction", "in", "predicted_arguments", ":", "\n", "                ", "span_counts", "[", "prediction", "[", "0", "]", "]", "+=", "1", "\n", "# Count how many spans appear more than once.", "\n", "", "repeated", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "span_counts", ".", "items", "(", ")", "if", "v", ">", "1", "}", "\n", "self", ".", "_total_arguments", "+=", "len", "(", "span_counts", ")", "\n", "self", ".", "_repeated_arguments", "+=", "len", "(", "repeated", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.ArgumentStats.get_metric": [[147, 159], ["dict", "event_metrics.ArgumentStats.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "# Fraction of event arguments associated with multiple triggers.", "\n", "        ", "args_multiple", "=", "(", "self", ".", "_repeated_arguments", "/", "self", ".", "_total_arguments", "\n", "if", "self", ".", "_total_arguments", "\n", "else", "0", ")", "\n", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "res", "=", "dict", "(", "args_multiple", "=", "args_multiple", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics.ArgumentStats.reset": [[160, 164], ["None"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_total_arguments", "=", "0", "\n", "self", ".", "_repeated_arguments", "=", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.training.event_metrics._invert_arguments": [[9, 23], ["set", "arguments.items", "set.add"], "function", ["None"], ["def", "_invert_arguments", "(", "arguments", ",", "triggers", ")", ":", "\n", "    ", "\"\"\"\n    For scoring the argument, we don't need the trigger spans to match exactly. We just need the\n    trigger label corresponding to the predicted trigger span to be correct.\n    \"\"\"", "\n", "# Can't use a dict because multiple triggers could share the same argument.", "\n", "inverted", "=", "set", "(", ")", "\n", "for", "k", ",", "v", "in", "arguments", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "[", "0", "]", "in", "triggers", ":", "# If it's not, the trigger this arg points to is null. TODO(dwadden) check.", "\n", "            ", "trigger_label", "=", "triggers", "[", "k", "[", "0", "]", "]", "\n", "to_append", "=", "(", "k", "[", "1", "]", ",", "trigger_label", ",", "v", ")", "\n", "inverted", ".", "add", "(", "to_append", ")", "\n", "\n", "", "", "return", "inverted", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.relation_metrics.RelationMetrics.__init__": [[12, 14], ["relation_metrics.RelationMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.relation_metrics.RelationMetrics.__call__": [[18, 28], ["zip", "len", "len", "predicted_relations.items"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "__call__", "(", "self", ",", "predicted_relation_list", ",", "metadata_list", ")", ":", "\n", "        ", "for", "predicted_relations", ",", "metadata", "in", "zip", "(", "predicted_relation_list", ",", "metadata_list", ")", ":", "\n", "            ", "gold_relations", "=", "metadata", ".", "relation_dict", "\n", "self", ".", "_total_gold", "+=", "len", "(", "gold_relations", ")", "\n", "self", ".", "_total_predicted", "+=", "len", "(", "predicted_relations", ")", "\n", "for", "(", "span_1", ",", "span_2", ")", ",", "label", "in", "predicted_relations", ".", "items", "(", ")", ":", "\n", "                ", "ix", "=", "(", "span_1", ",", "span_2", ")", "\n", "if", "ix", "in", "gold_relations", "and", "gold_relations", "[", "ix", "]", "==", "label", ":", "\n", "                    ", "self", ".", "_total_matched", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.relation_metrics.RelationMetrics.get_metric": [[29, 38], ["dygie.training.f1.compute_f1", "relation_metrics.RelationMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "", "", "", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "        ", "precision", ",", "recall", ",", "f1", "=", "compute_f1", "(", "self", ".", "_total_predicted", ",", "self", ".", "_total_gold", ",", "self", ".", "_total_matched", ")", "\n", "\n", "# Reset counts if at end of epoch.", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "return", "precision", ",", "recall", ",", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.relation_metrics.RelationMetrics.reset": [[39, 44], ["None"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_total_gold", "=", "0", "\n", "self", ".", "_total_predicted", "=", "0", "\n", "self", ".", "_total_matched", "=", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.training.f1.safe_div": [[6, 11], ["None"], "function", ["None"], ["def", "safe_div", "(", "num", ",", "denom", ")", ":", "\n", "    ", "if", "denom", ">", "0", ":", "\n", "        ", "return", "num", "/", "denom", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.f1.compute_f1": [[13, 18], ["f1.safe_div", "f1.safe_div", "f1.safe_div"], "function", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div"], ["", "", "def", "compute_f1", "(", "predicted", ",", "gold", ",", "matched", ")", ":", "\n", "    ", "precision", "=", "safe_div", "(", "matched", ",", "predicted", ")", "\n", "recall", "=", "safe_div", "(", "matched", ",", "gold", ")", "\n", "f1", "=", "safe_div", "(", "2", "*", "precision", "*", "recall", ",", "precision", "+", "recall", ")", "\n", "return", "precision", ",", "recall", ",", "f1", "\n", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.training.ner_metrics.NERMetrics.__init__": [[17, 21], ["ner_metrics.NERMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["def", "__init__", "(", "self", ",", "number_of_classes", ":", "int", ",", "none_label", ":", "int", "=", "0", ")", ":", "\n", "        ", "self", ".", "number_of_classes", "=", "number_of_classes", "\n", "self", ".", "none_label", "=", "none_label", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.ner_metrics.NERMetrics.__call__": [[22, 37], ["predictions.cpu.cpu.cpu", "gold_labels.cpu.cpu.cpu", "mask.cpu.cpu.cpu", "range", "mask.cpu.cpu.bool", "mask.cpu.cpu.bool", "mask.cpu.cpu.bool", "mask.cpu.cpu.bool"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "__call__", "(", "self", ",", "\n", "predictions", ":", "torch", ".", "Tensor", ",", "\n", "gold_labels", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "predictions", "=", "predictions", ".", "cpu", "(", ")", "\n", "gold_labels", "=", "gold_labels", ".", "cpu", "(", ")", "\n", "mask", "=", "mask", ".", "cpu", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "number_of_classes", ")", ":", "\n", "            ", "if", "i", "==", "self", ".", "none_label", ":", "\n", "                ", "continue", "\n", "", "self", ".", "_true_positives", "+=", "(", "(", "predictions", "==", "i", ")", "*", "(", "gold_labels", "==", "i", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_false_positives", "+=", "(", "(", "predictions", "==", "i", ")", "*", "(", "gold_labels", "!=", "i", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_true_negatives", "+=", "(", "(", "predictions", "!=", "i", ")", "*", "(", "gold_labels", "!=", "i", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_false_negatives", "+=", "(", "(", "predictions", "!=", "i", ")", "*", "(", "gold_labels", "==", "i", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.ner_metrics.NERMetrics.get_metric": [[38, 58], ["dygie.training.f1.compute_f1", "ner_metrics.NERMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        A tuple of the following metrics based on the accumulated count statistics:\n        precision : float\n        recall : float\n        f1-measure : float\n        \"\"\"", "\n", "predicted", "=", "self", ".", "_true_positives", "+", "self", ".", "_false_positives", "\n", "gold", "=", "self", ".", "_true_positives", "+", "self", ".", "_false_negatives", "\n", "matched", "=", "self", ".", "_true_positives", "\n", "precision", ",", "recall", ",", "f1_measure", "=", "compute_f1", "(", "predicted", ",", "gold", ",", "matched", ")", "\n", "\n", "# Reset counts if at end of epoch.", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "return", "precision", ",", "recall", ",", "f1_measure", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.training.ner_metrics.NERMetrics.reset": [[59, 65], ["None"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_true_positives", "=", "0", "\n", "self", ".", "_false_positives", "=", "0", "\n", "self", ".", "_true_negatives", "=", "0", "\n", "self", ".", "_false_negatives", "=", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE.__init__": [[58, 170], ["allennlp.nn.InitializerApplicator", "allennlp.nn.InitializerApplicator", "allennlp.models.model.Model.__init__", "allennlp.modules.span_extractors.EndpointSpanExtractor", "allennlp.modules.span_extractors.EndpointSpanExtractor", "dygie.DyGIE._get_display_metrics", "dygie.DyGIE._endpoint_trigger_span_extractor.get_output_dim", "dygie.DyGIE._endpoint_span_extractor.get_output_dim", "allennlp.common.params.Params", "dygie.models.ner.NERTagger.from_params", "dygie.models.coref.CorefResolver.from_params", "dygie.models.relation.RelationExtractor.from_params", "dygie.models.events.EventExtractor.from_params", "initializer", "context_layer.get_output_dim", "context_layer.get_output_dim", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "allennlp.modules.span_extractors.SelfAttentiveSpanExtractor", "dygie.DyGIE._attentive_span_extractor.get_output_dim", "dygie.DyGIE._attentive_span_extractor.get_output_dim", "allennlp.modules.FeedForward", "module_initializer", "allennlp.common.params.Params.pop", "allennlp.common.params.Params.pop", "allennlp.common.params.Params.pop", "dygie.DyGIE._embedder.get_output_dim", "allennlp.common.params.Params.pop", "context_layer.get_output_dim", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._get_display_metrics"], ["dataset", ".", "index_instances", "(", "model", ".", "vocab", ")", "\n", "model_input", "=", "util", ".", "move_to_device", "(", "dataset", ".", "as_tensor_dict", "(", ")", ",", "cuda_device", ")", "\n", "prediction", "=", "model", ".", "make_output_human_readable", "(", "model", "(", "**", "model_input", ")", ")", ".", "to_json", "(", ")", "\n", "# If we run out of GPU memory, warn user and indicate that this document failed.", "\n", "# This way, prediction doesn't grind to a halt every time we run out of GPU.", "\n", "", "except", "RuntimeError", "as", "err", ":", "\n", "# doc_key, dataset, sentences, message", "\n", "            ", "metadata", "=", "instance", "[", "\"metadata\"", "]", ".", "metadata", "\n", "doc_key", "=", "metadata", ".", "doc_key", "\n", "msg", "=", "(", "f\"Encountered a RunTimeError on document {doc_key}. Skipping this example.\"", "\n", "f\" Error message:\\n{err.args[0]}.\"", ")", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "prediction", "=", "metadata", ".", "to_json", "(", ")", "\n", "prediction", "[", "\"_FAILED_PREDICTION\"", "]", "=", "True", "\n", "\n", "", "return", "prediction", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._get_display_metrics": [[171, 188], ["ValueError"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch": [[189, 193], ["x.squeeze"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE.forward": [[194, 328], ["dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._debatch", "dygie.DyGIE._embedder", "dygie.DyGIE._debatch", "dygie.DyGIE._lexical_dropout", "dygie.DyGIE._debatch", "dygie.DyGIE.sum().long", "dygie.DyGIE._context_layer", "torch.relu().long", "torch.relu().long", "dygie.DyGIE._endpoint_span_extractor", "torch.relu().long", "torch.relu().long", "dygie.DyGIE._endpoint_trigger_span_extractor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "dict", "relation_labels.long.long.long", "argument_labels.long.long.long", "len", "NotImplementedError", "allennlp.nn.util.get_text_field_mask().float", "dygie.DyGIE._attentive_span_extractor", "dygie.DyGIE._attentive_span_extractor", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "dygie.DyGIE._coref.compute_representations", "dygie.DyGIE._coref.coref_propagation", "dygie.DyGIE._coref.update_spans", "dygie.DyGIE._ner", "dygie.DyGIE._coref.predict_labels", "dygie.DyGIE._relation", "dygie.DyGIE._events", "dygie.DyGIE.sum", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "dygie.DyGIE.get", "allennlp.nn.util.get_text_field_mask", "torch.relu().long.float", "torch.relu().long.float", "dygie.DyGIE.get", "dygie.DyGIE.get", "dygie.DyGIE.get"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE._debatch", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.compute_representations", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.coref_propagation", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.update_spans", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.predict_labels", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_text_field_mask"], []], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE.update_span_embeddings": [[329, 341], ["span_embeddings.clone", "range", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.clone"], []], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE.make_output_human_readable": [[342, 388], ["copy.deepcopy", "zip", "zip", "zip", "dygie.data.dataset_readers.document.Cluster", "dygie.DyGIE._coref.make_output_human_readable", "enumerate"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.make_output_human_readable"], []], "home.repos.pwc.inspect_result.mslars_mare.models.dygie.DyGIE.get_metrics": [[389, 420], ["dygie.DyGIE._coref.get_metrics", "dygie.DyGIE._ner.get_metrics", "dygie.DyGIE._relation.get_metrics", "dygie.DyGIE._events.get_metrics", "dict", "dict.items", "list", "len", "len", "list", "dygie.DyGIE.keys", "set", "list", "list", "list", "dygie.DyGIE.keys", "list", "dygie.DyGIE.items", "dygie.DyGIE.keys", "dygie.DyGIE.keys", "list", "list", "dygie.DyGIE.items", "dygie.DyGIE.items", "dygie.DyGIE.items"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.get_metrics", "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.get_metrics", "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.get_metrics", "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.get_metrics"], []], "home.repos.pwc.inspect_result.mslars_mare.models.shared.cumsum_shifted": [[8, 17], ["xs.cumsum", "torch.zeros", "torch.cat"], "function", ["None"], ["def", "cumsum_shifted", "(", "xs", ")", ":", "\n", "    ", "\"\"\"\n    Assumes `xs` is a 1-d array.\n    The usual cumsum has elements [x[1], x[1] + x[2], ...]. This one has elements\n    [0, x[1], x[1] + x[2], ...]. Useful for calculating sentence offsets.\n    \"\"\"", "\n", "cs", "=", "xs", ".", "cumsum", "(", "dim", "=", "0", ")", "\n", "shift", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "cs", ".", "device", ")", "# Put on correct device.", "\n", "return", "torch", ".", "cat", "(", "[", "shift", ",", "cs", "[", ":", "-", "1", "]", "]", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.shared.batch_identity": [[19, 26], ["torch.eye().unsqueeze", "torch.eye().unsqueeze.repeat", "torch.eye"], "function", ["None"], ["", "def", "batch_identity", "(", "batch_size", ",", "matrix_size", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Tile the identity matrix along axis 0, `batch_size` times.\n    \"\"\"", "\n", "ident", "=", "torch", ".", "eye", "(", "matrix_size", ",", "*", "args", ",", "**", "kwargs", ")", ".", "unsqueeze", "(", "0", ")", "\n", "res", "=", "ident", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.shared.fields_to_batches": [[28, 51], ["len", "len", "ValueError", "list", "d.keys", "set", "lengths.values", "range", "lengths.values"], "function", ["None"], ["", "def", "fields_to_batches", "(", "d", ",", "keys_to_ignore", "=", "[", "]", ")", ":", "\n", "    ", "\"\"\"\n    The input is a dict whose items are batched tensors. The output is a list of dictionaries - one\n    per entry in the batch - with the slices of the tensors for that entry. Here's an example.\n    Input:\n    d = {\"a\": [[1, 2], [3,4]], \"b\": [1, 2]}\n    Output:\n    res = [{\"a\": [1, 2], \"b\": 1}, {\"a\": [3, 4], \"b\": 2}].\n    \"\"\"", "\n", "keys", "=", "[", "key", "for", "key", "in", "d", ".", "keys", "(", ")", "if", "key", "not", "in", "keys_to_ignore", "]", "\n", "\n", "# Make sure all input dicts have same length. If they don't, there's a problem.", "\n", "lengths", "=", "{", "k", ":", "len", "(", "d", "[", "k", "]", ")", "for", "k", "in", "keys", "}", "\n", "if", "len", "(", "set", "(", "lengths", ".", "values", "(", ")", ")", ")", "!=", "1", ":", "\n", "        ", "msg", "=", "f\"fields have different lengths: {lengths}.\"", "\n", "# If there's a doc key, add it to specify where the error is.", "\n", "if", "\"doc_key\"", "in", "d", ":", "\n", "            ", "msg", "=", "f\"For document {d['doc_key']}, \"", "+", "msg", "\n", "", "raise", "ValueError", "(", "msg", ")", "\n", "\n", "", "length", "=", "list", "(", "lengths", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "res", "=", "[", "{", "k", ":", "d", "[", "k", "]", "[", "i", "]", "for", "k", "in", "keys", "}", "for", "i", "in", "range", "(", "length", ")", "]", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.shared.batches_to_fields": [[53, 69], ["batches[].keys", "batch.items", "set", "set", "ValueError", "res[].append", "entry.keys"], "function", ["None"], ["", "def", "batches_to_fields", "(", "batches", ")", ":", "\n", "    ", "\"\"\"\n    The inverse of `fields_to_batches`.\n    \"\"\"", "\n", "# Make sure all the keys match.", "\n", "first_keys", "=", "batches", "[", "0", "]", ".", "keys", "(", ")", "\n", "for", "entry", "in", "batches", "[", "1", ":", "]", ":", "\n", "        ", "if", "set", "(", "entry", ".", "keys", "(", ")", ")", "!=", "set", "(", "first_keys", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Keys to not match on all entries.\"", ")", "\n", "\n", "", "", "res", "=", "{", "k", ":", "[", "]", "for", "k", "in", "first_keys", "}", "\n", "for", "batch", "in", "batches", ":", "\n", "        ", "for", "k", ",", "v", "in", "batch", ".", "items", "(", ")", ":", "\n", "            ", "res", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "\n", "", "", "return", "res", "\n", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor.__init__": [[31, 121], ["allennlp.models.model.Model.__init__", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "allennlp.modules.token_embedders.Embedding", "set", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "vocab.get_vocab_size", "vocab.get_vocab_size", "vocab.get_token_index", "make_feedforward", "dygie.models.entity_beam_pruner.make_pruner", "make_feedforward", "torch.nn.Sequential", "make_feedforward", "dygie.models.entity_beam_pruner.make_pruner", "make_feedforward", "torch.nn.Linear", "dygie.training.event_metrics.EventMetrics", "vocab.get_namespaces", "vocab.get_namespaces", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "make_feedforward.get_output_dim", "torch.nn.Linear", "x.split", "make_feedforward.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__", "home.repos.pwc.inspect_result.mslars_mare.models.entity_beam_pruner.make_pruner", "home.repos.pwc.inspect_result.mslars_mare.models.entity_beam_pruner.make_pruner", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split"], ["def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "make_feedforward", ":", "Callable", ",", "\n", "text_emb_dim", ":", "int", ",", "\n", "trigger_emb_dim", ":", "int", ",", "# Triggers are represented via span embeddings (but can have different width than arg spans).", "\n", "span_emb_dim", ":", "int", ",", "# Arguments are represented via span embeddings.", "\n", "feature_size", ":", "int", ",", "\n", "trigger_spans_per_word", ":", "float", ",", "\n", "argument_spans_per_word", ":", "float", ",", "\n", "loss_weights", ":", "Dict", "[", "str", ",", "float", "]", ",", "\n", "context_window", ":", "int", "=", "0", ",", "\n", "regularizer", ":", "Optional", "[", "RegularizerApplicator", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", "EventExtractor", ",", "self", ")", ".", "__init__", "(", "vocab", ",", "regularizer", ")", "\n", "\n", "self", ".", "_trigger_namespaces", "=", "[", "entry", "for", "entry", "in", "vocab", ".", "get_namespaces", "(", ")", "\n", "if", "\"trigger_labels\"", "in", "entry", "]", "\n", "self", ".", "_argument_namespaces", "=", "[", "entry", "for", "entry", "in", "vocab", ".", "get_namespaces", "(", ")", "\n", "if", "\"argument_labels\"", "in", "entry", "]", "\n", "\n", "self", ".", "_n_trigger_labels", "=", "{", "name", ":", "vocab", ".", "get_vocab_size", "(", "name", ")", "\n", "for", "name", "in", "self", ".", "_trigger_namespaces", "}", "\n", "self", ".", "_n_argument_labels", "=", "{", "name", ":", "vocab", ".", "get_vocab_size", "(", "name", ")", "\n", "for", "name", "in", "self", ".", "_argument_namespaces", "}", "\n", "\n", "# Context window", "\n", "self", ".", "_context_window", "=", "context_window", "# If greater than 0, concatenate context as features.", "\n", "context_window_dim", "=", "4", "*", "self", ".", "_context_window", "*", "text_emb_dim", "\n", "# 2 (arg context + trig context) * 2 (left context + right context) * context_window + text_emb_size", "\n", "\n", "# Make sure the null trigger label is always 0.", "\n", "for", "namespace", "in", "self", ".", "_trigger_namespaces", ":", "\n", "            ", "null_label", "=", "vocab", ".", "get_token_index", "(", "\"\"", ",", "namespace", ")", "\n", "assert", "null_label", "==", "0", "# If not, the dummy class won't correspond to the null label.", "\n", "\n", "# Create trigger scorers and pruners.", "\n", "", "self", ".", "_trigger_scorers", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_trigger_pruners", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "for", "trigger_namespace", "in", "self", ".", "_trigger_namespaces", ":", "\n", "# The trigger pruner.", "\n", "            ", "trigger_candidate_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "trigger_emb_dim", ")", "\n", "self", ".", "_trigger_pruners", "[", "trigger_namespace", "]", "=", "make_pruner", "(", "trigger_candidate_feedforward", ")", "\n", "# The trigger scorer.", "\n", "trigger_scorer_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "trigger_emb_dim", ")", "\n", "self", ".", "_trigger_scorers", "[", "namespace", "]", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "trigger_scorer_feedforward", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "trigger_scorer_feedforward", ".", "get_output_dim", "(", ")", ",", "\n", "self", ".", "_n_trigger_labels", "[", "trigger_namespace", "]", "-", "1", ")", ")", ")", "\n", "\n", "# Create argument scorers and pruners.", "\n", "", "self", ".", "_mention_pruners", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_argument_feedforwards", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_argument_scorers", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "for", "argument_namespace", "in", "self", ".", "_argument_namespaces", ":", "\n", "# The argument pruner.", "\n", "            ", "mention_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "span_emb_dim", ")", "\n", "self", ".", "_mention_pruners", "[", "argument_namespace", "]", "=", "make_pruner", "(", "mention_feedforward", ")", "\n", "# The argument scorer. The `+ 2` is there because I include indicator features for", "\n", "# whether the trigger is before or inside the arg span.", "\n", "\n", "# set argument feedforward", "\n", "argument_feedforward_dim", "=", "trigger_emb_dim", "+", "span_emb_dim", "+", "feature_size", "+", "2", "+", "context_window_dim", "\n", "# feature size + 2 = bucket distance embedding + 2 position features", "\n", "argument_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "argument_feedforward_dim", ")", "\n", "self", ".", "_argument_feedforwards", "[", "argument_namespace", "]", "=", "argument_feedforward", "\n", "self", ".", "_argument_scorers", "[", "argument_namespace", "]", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "argument_feedforward", ".", "get_output_dim", "(", ")", ",", "self", ".", "_n_argument_labels", "[", "argument_namespace", "]", ")", "\n", "\n", "# Weight on trigger labeling and argument labeling.", "\n", "", "self", ".", "_loss_weights", "=", "loss_weights", "\n", "\n", "# Distance embeddings.", "\n", "self", ".", "_num_distance_buckets", "=", "10", "# Just use 10 which is the default.", "\n", "self", ".", "_distance_embedding", "=", "Embedding", "(", "embedding_dim", "=", "feature_size", ",", "\n", "num_embeddings", "=", "self", ".", "_num_distance_buckets", ")", "\n", "\n", "self", ".", "_trigger_spans_per_word", "=", "trigger_spans_per_word", "\n", "self", ".", "_argument_spans_per_word", "=", "argument_spans_per_word", "\n", "\n", "# Metrics", "\n", "# Make a metric for each dataset (not each namespace).", "\n", "namespaces", "=", "self", ".", "_trigger_namespaces", "+", "self", ".", "_argument_namespaces", "\n", "datasets", "=", "set", "(", "[", "x", ".", "split", "(", "\"__\"", ")", "[", "0", "]", "for", "x", "in", "namespaces", "]", ")", "\n", "self", ".", "_metrics", "=", "{", "dataset", ":", "EventMetrics", "(", ")", "for", "dataset", "in", "datasets", "}", "\n", "\n", "self", ".", "_active_namespaces", "=", "{", "\"trigger\"", ":", "None", ",", "\"argument\"", ":", "None", "}", "\n", "self", ".", "_active_dataset", "=", "None", "\n", "\n", "# Trigger and argument loss.", "\n", "self", ".", "_trigger_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"sum\"", ")", "\n", "self", ".", "_argument_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"sum\"", ",", "ignore_index", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor.forward": [[124, 231], ["events.EventExtractor._compute_trigger_scores", "torch.floor().long", "torch.max", "torch.min", "trigger_pruner", "allennlp.nn.util.batched_index_select", "top_trig_mask.unsqueeze.unsqueeze.unsqueeze", "torch.floor().long", "torch.max", "torch.min", "mention_pruner", "top_arg_mask.unsqueeze.unsqueeze.unsqueeze", "allennlp.nn.util.batched_index_select", "events.EventExtractor._compute_trig_arg_embeddings", "events.EventExtractor._compute_argument_scores", "events.EventExtractor.predict", "torch.ones_like", "torch.ones_like", "events.EventExtractor._get_trigger_loss", "events.EventExtractor._get_pruned_gold_arguments", "events.EventExtractor._get_argument_loss", "metrics", "torch.floor", "torch.ones_like", "torch.floor", "torch.ones_like", "len", "len", "sentence_lengths.float", "sentence_lengths.float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_trigger_scores", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_trig_arg_embeddings", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_argument_scores", "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.predict", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_trigger_loss", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_pruned_gold_arguments", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_argument_loss"], ["", "@", "overrides", "\n", "def", "forward", "(", "self", ",", "# type: ignore", "\n", "trigger_spans", ":", "torch", ".", "IntTensor", ",", "\n", "trigger_mask", ":", "torch", ".", "IntTensor", ",", "\n", "trigger_embeddings", ":", "torch", ".", "Tensor", ",", "\n", "spans", ":", "torch", ".", "IntTensor", ",", "\n", "span_mask", ":", "torch", ".", "IntTensor", ",", "\n", "span_embeddings", ":", "torch", ".", "Tensor", ",", "# TODO: make sure types are init correctly", "\n", "text_mask", ":", "torch", ".", "IntTensor", ",", "\n", "text_embeddings", ":", "torch", ".", "Tensor", ",", "\n", "sentence_lengths", ":", "torch", ".", "IntTensor", ",", "\n", "trigger_labels", ":", "torch", ".", "IntTensor", ",", "\n", "argument_labels", ":", "torch", ".", "IntTensor", ",", "\n", "ner_labels", ":", "torch", ".", "IntTensor", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        The trigger embeddings are just the contextualized token embeddings, and the trigger mask is\n        the text mask. For the arguments, we consider all the spans.\n        \"\"\"", "\n", "self", ".", "_active_dataset", "=", "metadata", ".", "dataset", "\n", "self", ".", "_active_namespaces", "=", "{", "\"trigger\"", ":", "f\"{self._active_dataset}__trigger_labels\"", ",", "\n", "\"argument\"", ":", "f\"{self._active_dataset}__argument_labels\"", "}", "\n", "\n", "# Compute trigger scores.", "\n", "trigger_scores", "=", "self", ".", "_compute_trigger_scores", "(", "\n", "trigger_embeddings", ",", "trigger_mask", ")", "\n", "\n", "# Get trigger candidates for event argument labeling.", "\n", "num_trigs_to_keep", "=", "torch", ".", "floor", "(", "\n", "sentence_lengths", ".", "float", "(", ")", "*", "self", ".", "_trigger_spans_per_word", ")", ".", "long", "(", ")", "\n", "num_trigs_to_keep", "=", "torch", ".", "max", "(", "num_trigs_to_keep", ",", "\n", "torch", ".", "ones_like", "(", "num_trigs_to_keep", ")", ")", "\n", "num_trigs_to_keep", "=", "torch", ".", "min", "(", "num_trigs_to_keep", ",", "\n", "15", "*", "torch", ".", "ones_like", "(", "num_trigs_to_keep", ")", ")", "\n", "\n", "trigger_pruner", "=", "self", ".", "_trigger_pruners", "[", "self", ".", "_active_namespaces", "[", "\"trigger\"", "]", "]", "\n", "(", "top_trig_embeddings", ",", "top_trig_mask", ",", "\n", "top_trig_indices", ",", "top_trig_scores", ",", "num_trigs_kept", ")", "=", "trigger_pruner", "(", "\n", "trigger_embeddings", ",", "trigger_mask", ",", "num_trigs_to_keep", ",", "trigger_scores", ")", "\n", "\n", "top_trig_spans", "=", "util", ".", "batched_index_select", "(", "trigger_spans", ",", "\n", "top_trig_indices", ")", "\n", "top_trig_mask", "=", "top_trig_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "# Compute the number of argument spans to keep.", "\n", "num_arg_spans_to_keep", "=", "torch", ".", "floor", "(", "\n", "sentence_lengths", ".", "float", "(", ")", "*", "self", ".", "_argument_spans_per_word", ")", ".", "long", "(", ")", "\n", "num_arg_spans_to_keep", "=", "torch", ".", "max", "(", "num_arg_spans_to_keep", ",", "\n", "torch", ".", "ones_like", "(", "num_arg_spans_to_keep", ")", ")", "\n", "num_arg_spans_to_keep", "=", "torch", ".", "min", "(", "num_arg_spans_to_keep", ",", "\n", "30", "*", "torch", ".", "ones_like", "(", "num_arg_spans_to_keep", ")", ")", "\n", "\n", "# If we're using gold event arguments, include the gold labels.", "\n", "mention_pruner", "=", "self", ".", "_mention_pruners", "[", "self", ".", "_active_namespaces", "[", "\"argument\"", "]", "]", "\n", "gold_labels", "=", "None", "\n", "(", "top_arg_embeddings", ",", "top_arg_mask", ",", "\n", "top_arg_indices", ",", "top_arg_scores", ",", "num_arg_spans_kept", ")", "=", "mention_pruner", "(", "\n", "span_embeddings", ",", "span_mask", ",", "num_arg_spans_to_keep", ",", "gold_labels", ")", "\n", "\n", "top_arg_mask", "=", "top_arg_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "top_arg_spans", "=", "util", ".", "batched_index_select", "(", "spans", ",", "\n", "top_arg_indices", ")", "\n", "\n", "# Compute trigger / argument pair embeddings.", "\n", "trig_arg_embeddings", "=", "self", ".", "_compute_trig_arg_embeddings", "(", "\n", "top_trig_embeddings", ",", "top_arg_embeddings", ",", "top_trig_spans", ",", "top_arg_spans", ",", "text_mask", ",", "text_embeddings", ")", "\n", "argument_scores", "=", "self", ".", "_compute_argument_scores", "(", "\n", "trig_arg_embeddings", ",", "top_trig_scores", ",", "top_arg_scores", ",", "top_arg_mask", ")", "\n", "\n", "# Assemble inputs to do prediction.", "\n", "output_dict", "=", "{", "\"top_trigger_spans\"", ":", "top_trig_spans", ",", "\n", "\"top_argument_spans\"", ":", "top_arg_spans", ",", "\n", "\"trigger_scores\"", ":", "trigger_scores", ",", "\n", "\"argument_scores\"", ":", "argument_scores", ",", "\n", "\"num_triggers_kept\"", ":", "num_trigs_kept", ",", "\n", "\"num_argument_spans_kept\"", ":", "num_arg_spans_kept", ",", "\n", "\"trigger_mask\"", ":", "trigger_mask", ",", "\n", "\"trigger_spans\"", ":", "trigger_spans", ",", "\n", "\"sentence_lengths\"", ":", "sentence_lengths", "}", "\n", "\n", "prediction_dicts", ",", "predictions", "=", "self", ".", "predict", "(", "output_dict", ",", "metadata", ")", "\n", "\n", "output_dict", "=", "{", "\"predictions\"", ":", "predictions", "}", "\n", "\n", "# Evaluate loss and F1 if labels were provided.", "\n", "if", "trigger_labels", "is", "not", "None", "and", "argument_labels", "is", "not", "None", ":", "\n", "# Compute the loss for both triggers and arguments.", "\n", "            ", "trigger_loss", "=", "self", ".", "_get_trigger_loss", "(", "trigger_scores", ",", "trigger_labels", ",", "trigger_mask", ")", "\n", "\n", "gold_arguments", "=", "self", ".", "_get_pruned_gold_arguments", "(", "\n", "argument_labels", ",", "top_trig_indices", ",", "top_arg_indices", ",", "top_trig_mask", ",", "top_arg_mask", ")", "\n", "\n", "argument_loss", "=", "self", ".", "_get_argument_loss", "(", "argument_scores", ",", "gold_arguments", ")", "\n", "\n", "# Compute F1.", "\n", "assert", "len", "(", "prediction_dicts", ")", "==", "len", "(", "metadata", ")", "# Make sure length of predictions is right.", "\n", "\n", "# Compute metrics for this label namespace.", "\n", "metrics", "=", "self", ".", "_metrics", "[", "self", ".", "_active_dataset", "]", "\n", "metrics", "(", "prediction_dicts", ",", "metadata", ")", "\n", "\n", "loss", "=", "(", "self", ".", "_loss_weights", "[", "\"trigger\"", "]", "*", "trigger_loss", "+", "\n", "self", ".", "_loss_weights", "[", "\"arguments\"", "]", "*", "argument_loss", ")", "\n", "\n", "output_dict", "[", "\"loss\"", "]", "=", "loss", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_trig_arg_embeddings": [[236, 293], ["top_trig_embeddings.size", "top_arg_embeddings.size", "top_trig_embeddings.unsqueeze", "top_trig_embeddings.unsqueeze.repeat", "top_arg_embeddings.unsqueeze", "top_arg_embeddings.unsqueeze.repeat", "events.EventExtractor._compute_distance_embeddings", "torch.cat", "events.EventExtractor._get_context", "events.EventExtractor._get_context", "trig_emb_extras.append", "arg_emb_extras.append", "torch.cat().unsqueeze", "torch.cat().unsqueeze.repeat", "torch.cat", "torch.cat().unsqueeze", "torch.cat().unsqueeze.repeat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_distance_embeddings", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_context", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_context"], ["", "def", "_compute_trig_arg_embeddings", "(", "self", ",", "\n", "top_trig_embeddings", ",", "\n", "top_arg_embeddings", ",", "\n", "top_trig_spans", ",", "\n", "top_arg_spans", ",", "\n", "text_mask", ",", "\n", "text_emb", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create trigger / argument pair embeddings, consisting of:\n        - The embeddings of the trigger and argument pair.\n        - Optionally, the embeddings of the trigger and argument labels.\n        - Optionally, embeddings of the words surrounding the trigger and argument.\n        \"\"\"", "\n", "trig_emb_extras", "=", "[", "]", "\n", "arg_emb_extras", "=", "[", "]", "\n", "\n", "if", "self", ".", "_context_window", ">", "0", ":", "\n", "# Include words in a window around trigger and argument.", "\n", "            ", "trigger_context", "=", "self", ".", "_get_context", "(", "\n", "top_trig_spans", "[", ":", ",", ":", ",", "0", "]", ",", "top_trig_spans", "[", ":", ",", ":", ",", "1", "]", ",", "text_emb", ")", "\n", "argument_context", "=", "self", ".", "_get_context", "(", "\n", "top_arg_spans", "[", ":", ",", ":", ",", "0", "]", ",", "top_arg_spans", "[", ":", ",", ":", ",", "1", "]", ",", "text_emb", ")", "\n", "trig_emb_extras", ".", "append", "(", "trigger_context", ")", "\n", "arg_emb_extras", ".", "append", "(", "argument_context", ")", "\n", "\n", "\n", "# Tile trigs and args so they can be combined", "\n", "", "num_trigs", "=", "top_trig_embeddings", ".", "size", "(", "1", ")", "\n", "num_args", "=", "top_arg_embeddings", ".", "size", "(", "1", ")", "\n", "\n", "trig_emb_expanded", "=", "top_trig_embeddings", ".", "unsqueeze", "(", "2", ")", "\n", "trig_emb_tiled", "=", "trig_emb_expanded", ".", "repeat", "(", "1", ",", "1", ",", "num_args", ",", "1", ")", "\n", "\n", "arg_emb_expanded", "=", "top_arg_embeddings", ".", "unsqueeze", "(", "1", ")", "\n", "arg_emb_tiled", "=", "arg_emb_expanded", ".", "repeat", "(", "1", ",", "num_trigs", ",", "1", ",", "1", ")", "\n", "\n", "# Compute distance embeddings", "\n", "distance_embeddings", "=", "self", ".", "_compute_distance_embeddings", "(", "top_trig_spans", ",", "top_arg_spans", ")", "\n", "# similarity_embeddings = trig_emb_expanded * arg_emb_expanded", "\n", "\n", "# Integrate all embeddings by concat", "\n", "# pair_embeddings_list = [trig_emb_tiled, arg_emb_tiled, distance_embeddings]", "\n", "pair_embeddings_list", "=", "[", "trig_emb_tiled", ",", "arg_emb_tiled", ",", "distance_embeddings", "]", "\n", "pair_embeddings", "=", "torch", ".", "cat", "(", "pair_embeddings_list", ",", "dim", "=", "3", ")", "\n", "\n", "if", "trig_emb_extras", ":", "\n", "            ", "trig_extras_expanded", "=", "torch", ".", "cat", "(", "trig_emb_extras", ",", "dim", "=", "-", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "trig_extras_tiled", "=", "trig_extras_expanded", ".", "repeat", "(", "1", ",", "1", ",", "num_args", ",", "1", ")", "\n", "pair_embeddings", "=", "torch", ".", "cat", "(", "[", "pair_embeddings", ",", "trig_extras_tiled", "]", ",", "dim", "=", "3", ")", "\n", "\n", "", "if", "arg_emb_extras", ":", "\n", "            ", "arg_extras_expanded", "=", "torch", ".", "cat", "(", "arg_emb_extras", ",", "dim", "=", "-", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "arg_extras_tiled", "=", "arg_extras_expanded", ".", "repeat", "(", "1", ",", "num_trigs", ",", "1", ",", "1", ")", "\n", "pair_embeddings", "=", "torch", ".", "cat", "(", "[", "pair_embeddings", ",", "arg_extras_tiled", "]", ",", "dim", "=", "3", ")", "\n", "\n", "", "return", "pair_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_distance_embeddings": [[295, 337], ["top_trig_spans.size", "top_arg_spans.size", "top_trig_spans.unsqueeze().repeat", "top_arg_spans.unsqueeze().repeat", "torch.min", "allennlp.nn.util.bucket_values", "events.EventExtractor._distance_embedding", "trigger_before.float().unsqueeze", "trigger_overlap.float().unsqueeze", "torch.cat", "dist_start2end.abs", "dist_end2start.abs", "top_trig_spans.unsqueeze", "top_arg_spans.unsqueeze", "trigger_before.float", "trigger_overlap.float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.bucket_values"], ["", "def", "_compute_distance_embeddings", "(", "self", ",", "top_trig_spans", ",", "top_arg_spans", ")", ":", "\n", "        ", "\"\"\"\n        Compute integer distance and positional features of two tensors of span interval indices\n        of different size. Embeds the bucketed distance values.\n        :param top_trigger_spans: Size (batch_size, num_trig_spans, 2), 2 for (trigger_start_index, trigger_end_index)\n        :param top_arg_spans: Size (batch_size, num_arg_spans, 2), 2 for (arg_start_index, arg_end_index)\n        return res: Tensor of size (batch_size, num_args consists of concat of:\n                - dist: size (batch_size, num_trig_spans, num_arg_spans) containing the integer distance values.\n                - trigger_before_feature: size idem size, boolean feature indicating that trigger comes before argument.\n                - trigger_overlap_feature: size idem, boolean feature indicating that trigger overlaps with argument.\n        \"\"\"", "\n", "# tile the span matrices", "\n", "num_trigs", "=", "top_trig_spans", ".", "size", "(", "1", ")", "\n", "num_spans", "=", "top_arg_spans", ".", "size", "(", "1", ")", "\n", "trig_span_tiled", "=", "top_trig_spans", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "num_spans", ",", "1", ")", "\n", "arg_span_tiled", "=", "top_arg_spans", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "num_trigs", ",", "1", ",", "1", ")", "\n", "\n", "# get start_idc and end_idc", "\n", "trig_span_starts", "=", "trig_span_tiled", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "trig_span_ends", "=", "trig_span_tiled", "[", ":", ",", ":", ",", ":", ",", "1", "]", "\n", "arg_span_starts", "=", "arg_span_tiled", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "arg_span_ends", "=", "arg_span_tiled", "[", ":", ",", ":", ",", ":", ",", "1", "]", "\n", "\n", "# compute all distances, abs().min is the correct dist value", "\n", "dist_start2end", "=", "trig_span_starts", "-", "arg_span_ends", "\n", "dist_end2start", "=", "trig_span_ends", "-", "arg_span_starts", "\n", "dist", "=", "torch", ".", "min", "(", "dist_start2end", ".", "abs", "(", ")", ",", "dist_end2start", ".", "abs", "(", ")", ")", "\n", "# When the trigger overlaps with the arg span, also set the distance to zero.", "\n", "# Overlap happens when the trigger is not outside before or after the span.", "\n", "trigger_before", "=", "(", "trig_span_starts", "<=", "trig_span_ends", ")", "&", "(", "trig_span_ends", "<", "arg_span_starts", ")", "\n", "trigger_after", "=", "(", "arg_span_starts", "<=", "arg_span_ends", ")", "&", "(", "arg_span_ends", "<", "trig_span_starts", ")", "\n", "trigger_overlap", "=", "~", "(", "trigger_before", "|", "trigger_after", ")", "\n", "dist", "[", "trigger_overlap", "]", "=", "0", "\n", "\n", "# compute bucketed embeddings and add before, overlap boolean feature", "\n", "dist_buckets", "=", "util", ".", "bucket_values", "(", "dist", ",", "self", ".", "_num_distance_buckets", ")", "\n", "dist_emb", "=", "self", ".", "_distance_embedding", "(", "dist_buckets", ")", "\n", "trigger_before_feature", "=", "trigger_before", ".", "float", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "trigger_overlap_feature", "=", "trigger_overlap", ".", "float", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "res", "=", "torch", ".", "cat", "(", "[", "dist_emb", ",", "trigger_before_feature", ",", "trigger_overlap_feature", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_trigger_scores": [[342, 356], ["trigger_scorer", "trigger_mask.unsqueeze", "allennlp.nn.util.replace_masked_values", "torch.cat.new_zeros", "torch.cat", "trigger_mask.unsqueeze.bool", "torch.cat.size", "torch.cat.size"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values"], ["", "def", "_compute_trigger_scores", "(", "self", ",", "trigger_embeddings", ",", "trigger_mask", ")", ":", "\n", "        ", "\"\"\"\n        Compute trigger scores for all tokens.\n        \"\"\"", "\n", "trigger_scorer", "=", "self", ".", "_trigger_scorers", "[", "self", ".", "_active_namespaces", "[", "\"trigger\"", "]", "]", "\n", "trigger_scores", "=", "trigger_scorer", "(", "trigger_embeddings", ")", "\n", "# Give large negative scores to masked-out elements.", "\n", "mask", "=", "trigger_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "trigger_scores", "=", "util", ".", "replace_masked_values", "(", "trigger_scores", ",", "mask", ".", "bool", "(", ")", ",", "-", "1e20", ")", "\n", "dummy_dims", "=", "[", "trigger_scores", ".", "size", "(", "0", ")", ",", "trigger_scores", ".", "size", "(", "1", ")", ",", "1", "]", "\n", "dummy_scores", "=", "trigger_scores", ".", "new_zeros", "(", "*", "dummy_dims", ")", "\n", "trigger_scores", "=", "torch", ".", "cat", "(", "(", "dummy_scores", ",", "trigger_scores", ")", ",", "-", "1", ")", "\n", "# Give large negative scores to the masked-out values.", "\n", "return", "trigger_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._compute_argument_scores": [[357, 385], ["pairwise_embeddings.size", "pairwise_embeddings.size", "pairwise_embeddings.size", "pairwise_embeddings.view", "argument_feedforward", "argument_scorer", "argument_scorer.view", "torch.cat.new_zeros", "top_trig_scores.unsqueeze", "top_arg_scores.transpose().unsqueeze", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat", "top_arg_scores.transpose"], "methods", ["None"], ["", "def", "_compute_argument_scores", "(", "self", ",", "pairwise_embeddings", ",", "top_trig_scores", ",", "top_arg_scores", ",", "\n", "top_arg_mask", ",", "prepend_zeros", "=", "True", ")", ":", "\n", "        ", "batch_size", "=", "pairwise_embeddings", ".", "size", "(", "0", ")", "\n", "max_num_trigs", "=", "pairwise_embeddings", ".", "size", "(", "1", ")", "\n", "max_num_args", "=", "pairwise_embeddings", ".", "size", "(", "2", ")", "\n", "argument_feedforward", "=", "self", ".", "_argument_feedforwards", "[", "self", ".", "_active_namespaces", "[", "\"argument\"", "]", "]", "\n", "\n", "feature_dim", "=", "argument_feedforward", ".", "input_dim", "\n", "embeddings_flat", "=", "pairwise_embeddings", ".", "view", "(", "-", "1", ",", "feature_dim", ")", "\n", "\n", "arguments_projected_flat", "=", "argument_feedforward", "(", "embeddings_flat", ")", "\n", "\n", "argument_scorer", "=", "self", ".", "_argument_scorers", "[", "self", ".", "_active_namespaces", "[", "\"argument\"", "]", "]", "\n", "argument_scores_flat", "=", "argument_scorer", "(", "arguments_projected_flat", ")", "\n", "\n", "argument_scores", "=", "argument_scores_flat", ".", "view", "(", "batch_size", ",", "max_num_trigs", ",", "max_num_args", ",", "-", "1", ")", "\n", "\n", "# Add the mention scores for each of the candidates.", "\n", "\n", "argument_scores", "+=", "(", "top_trig_scores", ".", "unsqueeze", "(", "-", "1", ")", "+", "\n", "top_arg_scores", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", "\n", "\n", "shape", "=", "[", "argument_scores", ".", "size", "(", "0", ")", ",", "argument_scores", ".", "size", "(", "1", ")", ",", "argument_scores", ".", "size", "(", "2", ")", ",", "1", "]", "\n", "dummy_scores", "=", "argument_scores", ".", "new_zeros", "(", "*", "shape", ")", "\n", "\n", "if", "prepend_zeros", ":", "\n", "            ", "argument_scores", "=", "torch", ".", "cat", "(", "[", "dummy_scores", ",", "argument_scores", "]", ",", "-", "1", ")", "\n", "", "return", "argument_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor.predict": [[390, 411], ["dygie.models.shared.fields_to_batches", "zip", "events.EventExtractor._decode_trigger", "events.EventExtractor._decode_arguments", "events.EventExtractor._assemble_predictions", "prediction_dicts.append", "predictions.append", "v.detach().cpu", "output_dict.items", "v.detach"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.shared.fields_to_batches", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._decode_trigger", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._decode_arguments", "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._assemble_predictions"], ["", "def", "predict", "(", "self", ",", "output_dict", ",", "document", ")", ":", "\n", "        ", "\"\"\"\n        Take the output and convert it into a list of dicts. Each entry is a sentence. Each key is a\n        pair of span indices for that sentence, and each value is the relation label on that span\n        pair.\n        \"\"\"", "\n", "# debatch output to sentence", "\n", "outputs", "=", "fields_to_batches", "(", "{", "k", ":", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", "for", "k", ",", "v", "in", "output_dict", ".", "items", "(", ")", "}", ")", "\n", "\n", "prediction_dicts", "=", "[", "]", "\n", "predictions", "=", "[", "]", "\n", "\n", "# Collect predictions for each sentence in minibatch.", "\n", "for", "output", ",", "sentence", "in", "zip", "(", "outputs", ",", "document", ")", ":", "\n", "            ", "decoded_trig", "=", "self", ".", "_decode_trigger", "(", "output", ")", "\n", "decoded_args", "=", "self", ".", "_decode_arguments", "(", "output", ",", "decoded_trig", ")", "\n", "predicted_events", "=", "self", ".", "_assemble_predictions", "(", "decoded_trig", ",", "decoded_args", ",", "sentence", ")", "\n", "prediction_dicts", ".", "append", "(", "{", "\"trigger_dict\"", ":", "decoded_trig", ",", "\"argument_dict\"", ":", "decoded_args", "}", ")", "\n", "predictions", ".", "append", "(", "predicted_events", ")", "\n", "\n", "", "return", "prediction_dicts", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._decode_trigger": [[412, 433], ["trigger_scores.max", "torch.nn.functional.softmax", "torch.nn.functional.softmax.max", "zip", "trigger_mask.bool", "events.EventExtractor.vocab.get_token_from_index", "pred_trigger.item", "trigger_score_raw.item", "trigger_score_softmax.item", "tuple", "trigger_span.tolist"], "methods", ["None"], ["", "def", "_decode_trigger", "(", "self", ",", "output", ")", ":", "\n", "        ", "trigger_scores", "=", "output", "[", "\"trigger_scores\"", "]", "\n", "trigger_mask", "=", "output", "[", "\"trigger_mask\"", "]", "\n", "trigger_spans", "=", "output", "[", "\"trigger_spans\"", "]", "\n", "\n", "predicted_scores_raw", ",", "predicted_triggers", "=", "trigger_scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "softmax_scores", "=", "F", ".", "softmax", "(", "trigger_scores", ",", "dim", "=", "1", ")", "\n", "predicted_scores_softmax", ",", "_", "=", "softmax_scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "trigger_dict", "=", "{", "}", "\n", "# TODO(dwadden) Can speed this up with array ops.", "\n", "ix", "=", "(", "predicted_triggers", ">", "0", ")", "&", "trigger_mask", ".", "bool", "(", ")", "\n", "zip_pred", "=", "zip", "(", "predicted_triggers", "[", "ix", "]", ",", "predicted_scores_raw", "[", "ix", "]", ",", "\n", "predicted_scores_softmax", "[", "ix", "]", ",", "trigger_spans", "[", "ix", "]", ")", "\n", "for", "pred_trigger", ",", "trigger_score_raw", ",", "trigger_score_softmax", ",", "trigger_span", "in", "zip_pred", ":", "\n", "            ", "predicted_label", "=", "self", ".", "vocab", ".", "get_token_from_index", "(", "\n", "pred_trigger", ".", "item", "(", ")", ",", "namespace", "=", "self", ".", "_active_namespaces", "[", "\"trigger\"", "]", ")", "\n", "trigger_dict", "[", "tuple", "(", "trigger_span", ".", "tolist", "(", ")", ")", "]", "=", "(", "predicted_label", ",", "\n", "trigger_score_raw", ".", "item", "(", ")", ",", "\n", "trigger_score_softmax", ".", "item", "(", ")", ")", "\n", "\n", "", "return", "trigger_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._decode_arguments": [[434, 458], ["argument_scores.max", "torch.nn.functional.softmax", "torch.nn.functional.softmax.max", "itertools.product", "range", "range", "tuple", "tuple", "predicted_arguments[].item", "[].tolist", "[].tolist", "predicted_scores_raw[].item", "predicted_scores_softmax[].item", "events.EventExtractor.vocab.get_token_from_index"], "methods", ["None"], ["", "def", "_decode_arguments", "(", "self", ",", "output", ",", "decoded_trig", ")", ":", "\n", "# TODO(dwadden) Vectorize.", "\n", "        ", "argument_dict", "=", "{", "}", "\n", "argument_scores", "=", "output", "[", "\"argument_scores\"", "]", "\n", "predicted_scores_raw", ",", "predicted_arguments", "=", "argument_scores", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "# The null argument has label -1.", "\n", "predicted_arguments", "-=", "1", "\n", "softmax_scores", "=", "F", ".", "softmax", "(", "argument_scores", ",", "dim", "=", "-", "1", ")", "\n", "predicted_scores_softmax", ",", "_", "=", "softmax_scores", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "\n", "for", "i", ",", "j", "in", "itertools", ".", "product", "(", "range", "(", "output", "[", "\"num_triggers_kept\"", "]", ")", ",", "\n", "range", "(", "output", "[", "\"num_argument_spans_kept\"", "]", ")", ")", ":", "\n", "            ", "trig_span", "=", "tuple", "(", "output", "[", "\"top_trigger_spans\"", "]", "[", "i", "]", ".", "tolist", "(", ")", ")", "\n", "arg_span", "=", "tuple", "(", "output", "[", "\"top_argument_spans\"", "]", "[", "j", "]", ".", "tolist", "(", ")", ")", "\n", "arg_label", "=", "predicted_arguments", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "# Only include the argument if its putative trigger is predicted as a real trigger.", "\n", "if", "arg_label", ">=", "0", "and", "trig_span", "in", "decoded_trig", ":", "\n", "                ", "arg_score_raw", "=", "predicted_scores_raw", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "arg_score_softmax", "=", "predicted_scores_softmax", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "label_name", "=", "self", ".", "vocab", ".", "get_token_from_index", "(", "\n", "arg_label", ",", "namespace", "=", "self", ".", "_active_namespaces", "[", "\"argument\"", "]", ")", "\n", "argument_dict", "[", "(", "trig_span", ",", "arg_span", ")", "]", "=", "(", "label_name", ",", "arg_score_raw", ",", "arg_score_softmax", ")", "\n", "\n", "", "", "return", "argument_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._assemble_predictions": [[459, 476], ["trigger_dict.items", "dygie.data.dataset_readers.document.PredictedEvents", "this_event.append", "event_arguments.items", "sorted", "this_event.extend", "events_json.append", "sorted.append", "list", "list", "argument_dict.items", "list", "list"], "methods", ["None"], ["", "def", "_assemble_predictions", "(", "self", ",", "trigger_dict", ",", "argument_dict", ",", "sentence", ")", ":", "\n", "        ", "events_json", "=", "[", "]", "\n", "for", "trigger_span", ",", "trigger_label", "in", "trigger_dict", ".", "items", "(", ")", ":", "\n", "            ", "this_event", "=", "[", "]", "\n", "this_event", ".", "append", "(", "list", "(", "trigger_span", ")", "+", "list", "(", "trigger_label", ")", ")", "\n", "event_arguments", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "argument_dict", ".", "items", "(", ")", "if", "k", "[", "0", "]", "==", "trigger_span", "}", "\n", "this_event_args", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "event_arguments", ".", "items", "(", ")", ":", "\n", "                ", "entry", "=", "list", "(", "k", "[", "1", "]", ")", "+", "list", "(", "v", ")", "\n", "this_event_args", ".", "append", "(", "entry", ")", "\n", "", "this_event_args", "=", "sorted", "(", "this_event_args", ",", "key", "=", "lambda", "entry", ":", "entry", "[", "0", "]", ")", "\n", "this_event", ".", "extend", "(", "this_event_args", ")", "\n", "events_json", ".", "append", "(", "this_event", ")", "\n", "\n", "", "events", "=", "document", ".", "PredictedEvents", "(", "events_json", ",", "sentence", ",", "sentence_offsets", "=", "True", ")", "\n", "\n", "return", "events", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_pruned_gold_arguments": [[481, 503], ["zip", "torch.cat", "top_trig_masks.bool", "top_arg_masks.bool", "[].unsqueeze", "arguments.append", "arg_mask.transpose().unsqueeze", "arg_mask.transpose"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_pruned_gold_arguments", "(", "argument_labels", ",", "top_trig_indices", ",", "top_arg_indices", ",", "\n", "top_trig_masks", ",", "top_arg_masks", ")", ":", "\n", "        ", "\"\"\"\n        Loop over each slice and get the labels for the spans from that slice.\n        All labels are offset by 1 so that the \"null\" label gets class zero. This is the desired\n        behavior for the softmax. Labels corresponding to masked relations keep the label -1, which\n        the softmax loss ignores.\n        \"\"\"", "\n", "arguments", "=", "[", "]", "\n", "\n", "zipped", "=", "zip", "(", "argument_labels", ",", "top_trig_indices", ",", "top_arg_indices", ",", "\n", "top_trig_masks", ".", "bool", "(", ")", ",", "top_arg_masks", ".", "bool", "(", ")", ")", "\n", "\n", "for", "sliced", ",", "trig_ixs", ",", "arg_ixs", ",", "trig_mask", ",", "arg_mask", "in", "zipped", ":", "\n", "            ", "entry", "=", "sliced", "[", "trig_ixs", "]", "[", ":", ",", "arg_ixs", "]", ".", "unsqueeze", "(", "0", ")", "\n", "mask_entry", "=", "trig_mask", "&", "arg_mask", ".", "transpose", "(", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "entry", "[", "mask_entry", "]", "+=", "1", "\n", "entry", "[", "~", "mask_entry", "]", "=", "-", "1", "\n", "arguments", ".", "append", "(", "entry", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "arguments", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_trigger_loss": [[504, 512], ["trigger_scores.view", "trigger_labels.view", "trigger_mask.view().bool", "events.EventExtractor._trigger_loss", "trigger_mask.view"], "methods", ["None"], ["", "def", "_get_trigger_loss", "(", "self", ",", "trigger_scores", ",", "trigger_labels", ",", "trigger_mask", ")", ":", "\n", "        ", "n_trigger_labels", "=", "self", ".", "_n_trigger_labels", "[", "self", ".", "_active_namespaces", "[", "\"trigger\"", "]", "]", "\n", "trigger_scores_flat", "=", "trigger_scores", ".", "view", "(", "-", "1", ",", "n_trigger_labels", ")", "\n", "trigger_labels_flat", "=", "trigger_labels", ".", "view", "(", "-", "1", ")", "\n", "mask_flat", "=", "trigger_mask", ".", "view", "(", "-", "1", ")", ".", "bool", "(", ")", "\n", "\n", "loss", "=", "self", ".", "_trigger_loss", "(", "trigger_scores_flat", "[", "mask_flat", "]", ",", "trigger_labels_flat", "[", "mask_flat", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_argument_loss": [[513, 525], ["argument_scores.view", "argument_labels.view", "events.EventExtractor._argument_loss"], "methods", ["None"], ["", "def", "_get_argument_loss", "(", "self", ",", "argument_scores", ",", "argument_labels", ")", ":", "\n", "        ", "\"\"\"\n        Compute cross-entropy loss on argument labels.\n        \"\"\"", "\n", "n_argument_labels", "=", "self", ".", "_n_argument_labels", "[", "self", ".", "_active_namespaces", "[", "\"argument\"", "]", "]", "\n", "# Need to add one for the null class.", "\n", "scores_flat", "=", "argument_scores", ".", "view", "(", "-", "1", ",", "n_argument_labels", "+", "1", ")", "\n", "# Need to add 1 so that the null label is 0, to line up with indices into prediction matrix.", "\n", "labels_flat", "=", "argument_labels", ".", "view", "(", "-", "1", ")", "\n", "# Compute cross-entropy loss.", "\n", "loss", "=", "self", ".", "_argument_loss", "(", "scores_flat", ",", "labels_flat", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor.get_metrics": [[526, 545], ["events.EventExtractor._metrics.items", "itertools.product", "metrics.get_metric", "res.update", "res.update", "metrics.get_metric.items", "sum", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "res", "=", "{", "}", "\n", "for", "namespace", ",", "metrics", "in", "self", ".", "_metrics", ".", "items", "(", ")", ":", "\n", "            ", "f1_metrics", "=", "metrics", ".", "get_metric", "(", "reset", ")", "\n", "f1_metrics", "=", "{", "f\"{namespace}_{k}\"", ":", "v", "for", "k", ",", "v", "in", "f1_metrics", ".", "items", "(", ")", "}", "\n", "res", ".", "update", "(", "f1_metrics", ")", "\n", "\n", "", "prod", "=", "itertools", ".", "product", "(", "[", "\"trig_id\"", ",", "\"trig_class\"", ",", "\"arg_id\"", ",", "\"arg_class\"", "]", ",", "\n", "[", "\"precision\"", ",", "\"recall\"", ",", "\"f1\"", "]", ")", "\n", "names", "=", "[", "f\"{task}_{metric}\"", "for", "task", ",", "metric", "in", "prod", "]", "\n", "\n", "res_avg", "=", "{", "}", "\n", "for", "name", "in", "names", ":", "\n", "            ", "values", "=", "[", "res", "[", "key", "]", "for", "key", "in", "res", "if", "name", "in", "key", "]", "\n", "res_avg", "[", "f\"MEAN__{name}\"", "]", "=", "sum", "(", "values", ")", "/", "len", "(", "values", ")", "if", "values", "else", "0", "\n", "res", ".", "update", "(", "res_avg", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.events.EventExtractor._get_context": [[547, 579], ["text_emb.size", "span_starts.size", "torch.zeros", "torch.cat", "enumerate", "torch.cat", "span_starts.size", "span_ends.size", "zip", "zip", "torch.cat().unsqueeze", "torch.cat.append", "torch.cat().view().unsqueeze", "torch.cat().unsqueeze.append", "torch.cat", "torch.cat().view", "torch.cat"], "methods", ["None"], ["", "def", "_get_context", "(", "self", ",", "span_starts", ",", "span_ends", ",", "text_emb", ")", ":", "\n", "        ", "\"\"\"\n        Given span start and end (inclusive), get the context on either side.\n        \"\"\"", "\n", "# The text_emb are already zero-padded on the right, which is correct.", "\n", "assert", "span_starts", ".", "size", "(", ")", "==", "span_ends", ".", "size", "(", ")", "\n", "batch_size", ",", "seq_length", ",", "emb_size", "=", "text_emb", ".", "size", "(", ")", "\n", "num_candidates", "=", "span_starts", ".", "size", "(", "1", ")", "\n", "padding", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "_context_window", ",", "emb_size", ",", "device", "=", "text_emb", ".", "device", ")", "\n", "# [batch_size, seq_length + 2 x context_window, emb_size]", "\n", "padded_emb", "=", "torch", ".", "cat", "(", "[", "padding", ",", "text_emb", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "\n", "pad_batch", "=", "[", "]", "\n", "for", "batch_ix", ",", "(", "start_ixs", ",", "end_ixs", ")", "in", "enumerate", "(", "zip", "(", "span_starts", ",", "span_ends", ")", ")", ":", "\n", "            ", "pad_entry", "=", "[", "]", "\n", "for", "start_ix", ",", "end_ix", "in", "zip", "(", "start_ixs", ",", "end_ixs", ")", ":", "\n", "# The starts are inclusive, ends are exclusive.", "\n", "                ", "left_start", "=", "start_ix", "\n", "left_end", "=", "start_ix", "+", "self", ".", "_context_window", "\n", "right_start", "=", "end_ix", "+", "self", ".", "_context_window", "+", "1", "\n", "right_end", "=", "end_ix", "+", "2", "*", "self", ".", "_context_window", "+", "1", "\n", "left_pad", "=", "padded_emb", "[", "batch_ix", ",", "left_start", ":", "left_end", "]", "\n", "right_pad", "=", "padded_emb", "[", "batch_ix", ",", "right_start", ":", "right_end", "]", "\n", "pad", "=", "torch", ".", "cat", "(", "[", "left_pad", ",", "right_pad", "]", ",", "dim", "=", "0", ")", ".", "view", "(", "-", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "pad_entry", ".", "append", "(", "pad", ")", "\n", "\n", "", "pad_entry", "=", "torch", ".", "cat", "(", "pad_entry", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "pad_batch", ".", "append", "(", "pad_entry", ")", "\n", "\n", "", "pad_batch", "=", "torch", ".", "cat", "(", "pad_batch", ",", "dim", "=", "0", ")", "\n", "\n", "return", "pad_batch", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor.__init__": [[29, 67], ["allennlp.models.model.Model.__init__", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.ModuleDict", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "vocab.get_vocab_size", "make_feedforward", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "dygie.models.entity_beam_pruner.Pruner", "make_feedforward", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "dygie.training.relation_metrics.RelationMetrics", "vocab.get_namespaces", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "make_feedforward.get_output_dim", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "make_feedforward.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "make_feedforward", ":", "Callable", ",", "\n", "span_emb_dim", ":", "int", ",", "\n", "feature_size", ":", "int", ",", "\n", "spans_per_word", ":", "float", ",", "\n", "positive_label_weight", ":", "float", "=", "1.0", ",", "\n", "regularizer", ":", "Optional", "[", "RegularizerApplicator", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "vocab", ",", "regularizer", ")", "\n", "\n", "self", ".", "_namespaces", "=", "[", "entry", "for", "entry", "in", "vocab", ".", "get_namespaces", "(", ")", "if", "\"relation_labels\"", "in", "entry", "]", "\n", "self", ".", "_n_labels", "=", "{", "name", ":", "vocab", ".", "get_vocab_size", "(", "name", ")", "for", "name", "in", "self", ".", "_namespaces", "}", "\n", "\n", "self", ".", "_mention_pruners", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_relation_feedforwards", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_relation_scorers", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_relation_metrics", "=", "{", "}", "\n", "\n", "for", "namespace", "in", "self", ".", "_namespaces", ":", "\n", "            ", "mention_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "span_emb_dim", ")", "\n", "feedforward_scorer", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "mention_feedforward", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "mention_feedforward", ".", "get_output_dim", "(", ")", ",", "1", ")", ")", ")", "\n", "self", ".", "_mention_pruners", "[", "namespace", "]", "=", "Pruner", "(", "feedforward_scorer", ")", "\n", "\n", "relation_scorer_dim", "=", "3", "*", "span_emb_dim", "\n", "relation_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "relation_scorer_dim", ")", "\n", "self", ".", "_relation_feedforwards", "[", "namespace", "]", "=", "relation_feedforward", "\n", "relation_scorer", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "relation_feedforward", ".", "get_output_dim", "(", ")", ",", "self", ".", "_n_labels", "[", "namespace", "]", ")", "\n", "self", ".", "_relation_scorers", "[", "namespace", "]", "=", "relation_scorer", "\n", "\n", "self", ".", "_relation_metrics", "[", "namespace", "]", "=", "RelationMetrics", "(", ")", "\n", "\n", "", "self", ".", "_spans_per_word", "=", "spans_per_word", "\n", "self", ".", "_active_namespace", "=", "None", "\n", "\n", "self", ".", "_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"sum\"", ",", "ignore_index", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor.forward": [[68, 111], ["relation.RelationExtractor._prune_spans", "relation.RelationExtractor._compute_relation_scores", "relation.RelationExtractor.predict", "relation.RelationExtractor._compute_span_pair_embeddings", "top_spans.detach().cpu", "relation.RelationExtractor.detach().cpu", "num_spans_to_keep.detach().cpu", "relation.RelationExtractor._get_pruned_gold_relations", "relation.RelationExtractor._get_cross_entropy_loss", "relation_metrics", "len", "len", "top_spans.detach", "relation.RelationExtractor.detach", "num_spans_to_keep.detach"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._prune_spans", "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._compute_relation_scores", "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.predict", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_span_pair_embeddings", "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_pruned_gold_relations", "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_cross_entropy_loss"], ["", "@", "overrides", "\n", "def", "forward", "(", "self", ",", "# type: ignore", "\n", "spans", ":", "torch", ".", "IntTensor", ",", "\n", "span_mask", ",", "\n", "span_embeddings", ",", "# TODO(dwadden) add type.", "\n", "sentence_lengths", ",", "\n", "relation_labels", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        TODO(dwadden) Write documentation.\n        \"\"\"", "\n", "self", ".", "_active_namespace", "=", "f\"{metadata.dataset}__relation_labels\"", "\n", "\n", "(", "top_span_embeddings", ",", "top_span_mention_scores", ",", "\n", "num_spans_to_keep", ",", "top_span_mask", ",", "\n", "top_span_indices", ",", "top_spans", ")", "=", "self", ".", "_prune_spans", "(", "\n", "spans", ",", "span_mask", ",", "span_embeddings", ",", "sentence_lengths", ")", "\n", "\n", "relation_scores", "=", "self", ".", "_compute_relation_scores", "(", "\n", "self", ".", "_compute_span_pair_embeddings", "(", "top_span_embeddings", ")", ",", "top_span_mention_scores", ")", "\n", "\n", "prediction_dict", ",", "predictions", "=", "self", ".", "predict", "(", "top_spans", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "relation_scores", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "num_spans_to_keep", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "metadata", ")", "\n", "\n", "output_dict", "=", "{", "\"predictions\"", ":", "predictions", "}", "\n", "\n", "# Evaluate loss and F1 if labels were provided.", "\n", "if", "relation_labels", "is", "not", "None", ":", "\n", "# Compute cross-entropy loss.", "\n", "            ", "gold_relations", "=", "self", ".", "_get_pruned_gold_relations", "(", "\n", "relation_labels", ",", "top_span_indices", ",", "top_span_mask", ")", "\n", "\n", "cross_entropy", "=", "self", ".", "_get_cross_entropy_loss", "(", "relation_scores", ",", "gold_relations", ")", "\n", "\n", "# Compute F1.", "\n", "assert", "len", "(", "prediction_dict", ")", "==", "len", "(", "metadata", ")", "# Make sure length of predictions is right.", "\n", "relation_metrics", "=", "self", ".", "_relation_metrics", "[", "self", ".", "_active_namespace", "]", "\n", "relation_metrics", "(", "prediction_dict", ",", "metadata", ")", "\n", "\n", "output_dict", "[", "\"loss\"", "]", "=", "cross_entropy", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._prune_spans": [[112, 132], ["spans.size", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "torch.ceil().long", "pruner", "top_span_mask.unsqueeze.unsqueeze.unsqueeze", "allennlp.nn.util.flatten_and_batch_shift_indices", "allennlp.nn.util.batched_index_select", "torch.ceil", "torch.ceil", "torch.ceil", "torch.ceil", "sentence_lengths.float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select"], ["", "def", "_prune_spans", "(", "self", ",", "spans", ",", "span_mask", ",", "span_embeddings", ",", "sentence_lengths", ")", ":", "\n", "# Prune", "\n", "        ", "num_spans", "=", "spans", ".", "size", "(", "1", ")", "# Max number of spans for the minibatch.", "\n", "\n", "# Keep different number of spans for each minibatch entry.", "\n", "num_spans_to_keep", "=", "torch", ".", "ceil", "(", "sentence_lengths", ".", "float", "(", ")", "*", "self", ".", "_spans_per_word", ")", ".", "long", "(", ")", "\n", "\n", "pruner", "=", "self", ".", "_mention_pruners", "[", "self", ".", "_active_namespace", "]", "\n", "(", "top_span_embeddings", ",", "top_span_mask", ",", "\n", "top_span_indices", ",", "top_span_mention_scores", ",", "num_spans_kept", ")", "=", "pruner", "(", "\n", "span_embeddings", ",", "span_mask", ",", "num_spans_to_keep", ")", "\n", "\n", "top_span_mask", "=", "top_span_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "flat_top_span_indices", "=", "util", ".", "flatten_and_batch_shift_indices", "(", "top_span_indices", ",", "num_spans", ")", "\n", "top_spans", "=", "util", ".", "batched_index_select", "(", "spans", ",", "\n", "top_span_indices", ",", "\n", "flat_top_span_indices", ")", "\n", "\n", "return", "top_span_embeddings", ",", "top_span_mention_scores", ",", "num_spans_to_keep", ",", "top_span_mask", ",", "top_span_indices", ",", "top_spans", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor.predict": [[133, 145], ["zip", "relation.RelationExtractor._predict_sentence", "preds_dict.append", "predictions.append"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._predict_sentence"], ["", "def", "predict", "(", "self", ",", "top_spans", ",", "relation_scores", ",", "num_spans_to_keep", ",", "metadata", ")", ":", "\n", "        ", "preds_dict", "=", "[", "]", "\n", "predictions", "=", "[", "]", "\n", "zipped", "=", "zip", "(", "top_spans", ",", "relation_scores", ",", "num_spans_to_keep", ",", "metadata", ")", "\n", "\n", "for", "top_spans_sent", ",", "relation_scores_sent", ",", "num_spans_sent", ",", "sentence", "in", "zipped", ":", "\n", "            ", "pred_dict_sent", ",", "predictions_sent", "=", "self", ".", "_predict_sentence", "(", "\n", "top_spans_sent", ",", "relation_scores_sent", ",", "num_spans_sent", ",", "sentence", ")", "\n", "preds_dict", ".", "append", "(", "pred_dict_sent", ")", "\n", "predictions", ".", "append", "(", "predictions_sent", ")", "\n", "\n", "", "return", "preds_dict", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._predict_sentence": [[146, 178], ["num_spans_to_keep.item", "relation_scores.max", "torch.softmax", "torch.softmax", "torch.softmax.max", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "keep_mask.bool.bool.bool", "ix.nonzero", "tuple", "len", "predicted_labels[].item", "predicted_scores_raw[].item", "predicted_scores_softmax[].item", "relation.RelationExtractor.vocab.get_token_from_index", "predictions.append", "top_spans.tolist", "dygie.data.dataset_readers.document.PredictedRelation"], "methods", ["None"], ["", "def", "_predict_sentence", "(", "self", ",", "top_spans", ",", "relation_scores", ",", "num_spans_to_keep", ",", "sentence", ")", ":", "\n", "        ", "keep", "=", "num_spans_to_keep", ".", "item", "(", ")", "\n", "top_spans", "=", "[", "tuple", "(", "x", ")", "for", "x", "in", "top_spans", ".", "tolist", "(", ")", "]", "\n", "\n", "# Iterate over all span pairs and labels. Record the span if the label isn't null.", "\n", "predicted_scores_raw", ",", "predicted_labels", "=", "relation_scores", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "softmax_scores", "=", "F", ".", "softmax", "(", "relation_scores", ",", "dim", "=", "-", "1", ")", "\n", "predicted_scores_softmax", ",", "_", "=", "softmax_scores", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "predicted_labels", "-=", "1", "# Subtract 1 so that null labels get -1.", "\n", "\n", "keep_mask", "=", "torch", ".", "zeros", "(", "len", "(", "top_spans", ")", ")", "\n", "keep_mask", "[", ":", "keep", "]", "=", "1", "\n", "keep_mask", "=", "keep_mask", ".", "bool", "(", ")", "\n", "\n", "ix", "=", "(", "predicted_labels", ">=", "0", ")", "&", "keep_mask", "\n", "\n", "res_dict", "=", "{", "}", "\n", "predictions", "=", "[", "]", "\n", "\n", "for", "i", ",", "j", "in", "ix", ".", "nonzero", "(", "as_tuple", "=", "False", ")", ":", "\n", "            ", "span_1", "=", "top_spans", "[", "i", "]", "\n", "span_2", "=", "top_spans", "[", "j", "]", "\n", "label", "=", "predicted_labels", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "raw_score", "=", "predicted_scores_raw", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "softmax_score", "=", "predicted_scores_softmax", "[", "i", ",", "j", "]", ".", "item", "(", ")", "\n", "\n", "label_name", "=", "self", ".", "vocab", ".", "get_token_from_index", "(", "label", ",", "namespace", "=", "self", ".", "_active_namespace", ")", "\n", "res_dict", "[", "(", "span_1", ",", "span_2", ")", "]", "=", "label_name", "\n", "list_entry", "=", "(", "span_1", "[", "0", "]", ",", "span_1", "[", "1", "]", ",", "span_2", "[", "0", "]", ",", "span_2", "[", "1", "]", ",", "label_name", ",", "raw_score", ",", "softmax_score", ")", "\n", "predictions", ".", "append", "(", "document", ".", "PredictedRelation", "(", "list_entry", ",", "sentence", ",", "sentence_offsets", "=", "True", ")", ")", "\n", "\n", "", "return", "res_dict", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor.get_metrics": [[180, 199], ["relation.RelationExtractor._relation_metrics.items", "metrics.get_metric", "namespace.replace", "res.update", "res.update", "sum", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "\"Loop over the metrics for all namespaces, and return as dict.\"", "\n", "res", "=", "{", "}", "\n", "for", "namespace", ",", "metrics", "in", "self", ".", "_relation_metrics", ".", "items", "(", ")", ":", "\n", "            ", "precision", ",", "recall", ",", "f1", "=", "metrics", ".", "get_metric", "(", "reset", ")", "\n", "prefix", "=", "namespace", ".", "replace", "(", "\"_labels\"", ",", "\"\"", ")", "\n", "to_update", "=", "{", "f\"{prefix}_precision\"", ":", "precision", ",", "\n", "f\"{prefix}_recall\"", ":", "recall", ",", "\n", "f\"{prefix}_f1\"", ":", "f1", "}", "\n", "res", ".", "update", "(", "to_update", ")", "\n", "\n", "", "res_avg", "=", "{", "}", "\n", "for", "name", "in", "[", "\"precision\"", ",", "\"recall\"", ",", "\"f1\"", "]", ":", "\n", "            ", "values", "=", "[", "res", "[", "key", "]", "for", "key", "in", "res", "if", "name", "in", "key", "]", "\n", "res_avg", "[", "f\"MEAN__relation_{name}\"", "]", "=", "sum", "(", "values", ")", "/", "len", "(", "values", ")", "if", "values", "else", "0", "\n", "res", ".", "update", "(", "res_avg", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._compute_span_pair_embeddings": [[200, 220], ["top_span_embeddings.size", "top_span_embeddings.unsqueeze", "top_span_embeddings.unsqueeze.repeat", "top_span_embeddings.unsqueeze", "top_span_embeddings.unsqueeze.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_span_pair_embeddings", "(", "top_span_embeddings", ":", "torch", ".", "FloatTensor", ")", ":", "\n", "        ", "\"\"\"\n        TODO(dwadden) document me and add comments.\n        \"\"\"", "\n", "# Shape: (batch_size, num_spans_to_keep, num_spans_to_keep, embedding_size)", "\n", "num_candidates", "=", "top_span_embeddings", ".", "size", "(", "1", ")", "\n", "\n", "embeddings_1_expanded", "=", "top_span_embeddings", ".", "unsqueeze", "(", "2", ")", "\n", "embeddings_1_tiled", "=", "embeddings_1_expanded", ".", "repeat", "(", "1", ",", "1", ",", "num_candidates", ",", "1", ")", "\n", "\n", "embeddings_2_expanded", "=", "top_span_embeddings", ".", "unsqueeze", "(", "1", ")", "\n", "embeddings_2_tiled", "=", "embeddings_2_expanded", ".", "repeat", "(", "1", ",", "num_candidates", ",", "1", ",", "1", ")", "\n", "\n", "similarity_embeddings", "=", "embeddings_1_expanded", "*", "embeddings_2_expanded", "\n", "\n", "pair_embeddings_list", "=", "[", "embeddings_1_tiled", ",", "embeddings_2_tiled", ",", "similarity_embeddings", "]", "\n", "pair_embeddings", "=", "torch", ".", "cat", "(", "pair_embeddings_list", ",", "dim", "=", "3", ")", "\n", "\n", "return", "pair_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._compute_relation_scores": [[221, 246], ["pairwise_embeddings.size", "pairwise_embeddings.size", "pairwise_embeddings.view", "relation_feedforward", "relation_scorer", "relation_scorer.view", "torch.cat.new_zeros", "torch.cat.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "top_span_mention_scores.unsqueeze", "top_span_mention_scores.transpose().unsqueeze", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "top_span_mention_scores.transpose"], "methods", ["None"], ["", "def", "_compute_relation_scores", "(", "self", ",", "pairwise_embeddings", ",", "top_span_mention_scores", ")", ":", "\n", "        ", "relation_feedforward", "=", "self", ".", "_relation_feedforwards", "[", "self", ".", "_active_namespace", "]", "\n", "relation_scorer", "=", "self", ".", "_relation_scorers", "[", "self", ".", "_active_namespace", "]", "\n", "\n", "batch_size", "=", "pairwise_embeddings", ".", "size", "(", "0", ")", "\n", "max_num_spans", "=", "pairwise_embeddings", ".", "size", "(", "1", ")", "\n", "feature_dim", "=", "relation_feedforward", ".", "input_dim", "\n", "\n", "embeddings_flat", "=", "pairwise_embeddings", ".", "view", "(", "-", "1", ",", "feature_dim", ")", "\n", "\n", "relation_projected_flat", "=", "relation_feedforward", "(", "embeddings_flat", ")", "\n", "relation_scores_flat", "=", "relation_scorer", "(", "relation_projected_flat", ")", "\n", "\n", "relation_scores", "=", "relation_scores_flat", ".", "view", "(", "batch_size", ",", "max_num_spans", ",", "max_num_spans", ",", "-", "1", ")", "\n", "\n", "# Add the mention scores for each of the candidates.", "\n", "\n", "relation_scores", "+=", "(", "top_span_mention_scores", ".", "unsqueeze", "(", "-", "1", ")", "+", "\n", "top_span_mention_scores", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", "\n", "\n", "shape", "=", "[", "relation_scores", ".", "size", "(", "0", ")", ",", "relation_scores", ".", "size", "(", "1", ")", ",", "relation_scores", ".", "size", "(", "2", ")", ",", "1", "]", "\n", "dummy_scores", "=", "relation_scores", ".", "new_zeros", "(", "*", "shape", ")", "\n", "\n", "relation_scores", "=", "torch", ".", "cat", "(", "[", "dummy_scores", ",", "relation_scores", "]", ",", "-", "1", ")", "\n", "return", "relation_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_pruned_gold_relations": [[247, 267], ["zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "top_span_masks.bool", "[].unsqueeze", "relations.append", "top_span_mask.transpose().unsqueeze", "top_span_mask.transpose"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_pruned_gold_relations", "(", "relation_labels", ",", "top_span_indices", ",", "top_span_masks", ")", ":", "\n", "        ", "\"\"\"\n        Loop over each slice and get the labels for the spans from that slice.\n        All labels are offset by 1 so that the \"null\" label gets class zero. This is the desired\n        behavior for the softmax. Labels corresponding to masked relations keep the label -1, which\n        the softmax loss ignores.\n        \"\"\"", "\n", "# TODO(dwadden) Test and possibly optimize.", "\n", "relations", "=", "[", "]", "\n", "\n", "zipped", "=", "zip", "(", "relation_labels", ",", "top_span_indices", ",", "top_span_masks", ".", "bool", "(", ")", ")", "\n", "for", "sliced", ",", "ixs", ",", "top_span_mask", "in", "zipped", ":", "\n", "            ", "entry", "=", "sliced", "[", "ixs", "]", "[", ":", ",", "ixs", "]", ".", "unsqueeze", "(", "0", ")", "\n", "mask_entry", "=", "top_span_mask", "&", "top_span_mask", ".", "transpose", "(", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "entry", "[", "mask_entry", "]", "+=", "1", "\n", "entry", "[", "~", "mask_entry", "]", "=", "-", "1", "\n", "relations", ".", "append", "(", "entry", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "relations", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_cross_entropy_loss": [[268, 281], ["relation_scores.view", "relation_labels.view", "relation.RelationExtractor._loss"], "methods", ["None"], ["", "def", "_get_cross_entropy_loss", "(", "self", ",", "relation_scores", ",", "relation_labels", ")", ":", "\n", "        ", "\"\"\"\n        Compute cross-entropy loss on relation labels. Ignore diagonal entries and entries giving\n        relations between masked out spans.\n        \"\"\"", "\n", "# Need to add one for the null class.", "\n", "n_labels", "=", "self", ".", "_n_labels", "[", "self", ".", "_active_namespace", "]", "+", "1", "\n", "scores_flat", "=", "relation_scores", ".", "view", "(", "-", "1", ",", "n_labels", ")", "\n", "# Need to add 1 so that the null label is 0, to line up with indices into prediction matrix.", "\n", "labels_flat", "=", "relation_labels", ".", "view", "(", "-", "1", ")", "\n", "# Compute cross-entropy loss.", "\n", "loss", "=", "self", ".", "_loss", "(", "scores_flat", ",", "labels_flat", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.__init__": [[36, 73], ["allennlp.models.model.Model.__init__", "torch.nn.ModuleDict", "torch.nn.CrossEntropyLoss", "vocab.get_vocab_size", "vocab.get_token_index", "make_feedforward", "torch.nn.Sequential", "dygie.training.ner_metrics.NERMetrics", "vocab.get_namespaces", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "torch.nn.Linear", "make_feedforward.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "make_feedforward", ":", "Callable", ",", "\n", "span_emb_dim", ":", "int", ",", "\n", "regularizer", ":", "Optional", "[", "RegularizerApplicator", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", "NERTagger", ",", "self", ")", ".", "__init__", "(", "vocab", ",", "regularizer", ")", "\n", "\n", "self", ".", "_namespaces", "=", "[", "entry", "for", "entry", "in", "vocab", ".", "get_namespaces", "(", ")", "if", "\"ner_labels\"", "in", "entry", "]", "\n", "\n", "# Number of classes determine the output dimension of the final layer", "\n", "self", ".", "_n_labels", "=", "{", "name", ":", "vocab", ".", "get_vocab_size", "(", "name", ")", "for", "name", "in", "self", ".", "_namespaces", "}", "\n", "\n", "# Null label is needed to keep track of when calculating the metrics", "\n", "for", "namespace", "in", "self", ".", "_namespaces", ":", "\n", "            ", "null_label", "=", "vocab", ".", "get_token_index", "(", "\"\"", ",", "namespace", ")", "\n", "assert", "null_label", "==", "0", "# If not, the dummy class won't correspond to the null label.", "\n", "\n", "# The output dim is 1 less than the number of labels because we don't score the null label;", "\n", "# we just give it a score of 0 by default.", "\n", "\n", "# Create a separate scorer and metric for each dataset we're dealing with.", "\n", "", "self", ".", "_ner_scorers", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "self", ".", "_ner_metrics", "=", "{", "}", "\n", "\n", "for", "namespace", "in", "self", ".", "_namespaces", ":", "\n", "            ", "mention_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "span_emb_dim", ")", "\n", "self", ".", "_ner_scorers", "[", "namespace", "]", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "mention_feedforward", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "\n", "mention_feedforward", ".", "get_output_dim", "(", ")", ",", "\n", "self", ".", "_n_labels", "[", "namespace", "]", "-", "1", ")", ")", ")", "\n", "\n", "self", ".", "_ner_metrics", "[", "namespace", "]", "=", "NERMetrics", "(", "self", ".", "_n_labels", "[", "namespace", "]", ",", "null_label", ")", "\n", "\n", "", "self", ".", "_active_namespace", "=", "None", "\n", "\n", "self", ".", "_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"sum\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.forward": [[74, 121], ["scorer", "span_mask.unsqueeze", "allennlp.nn.util.replace_masked_values", "torch.cat.new_zeros", "torch.cat", "torch.cat.max", "ner.NERTagger.predict", "span_mask.unsqueeze.bool", "torch.cat.size", "torch.cat.size", "torch.cat.detach().cpu", "spans.detach().cpu", "span_mask.detach().cpu", "metrics", "torch.cat.view", "ner_labels.view", "span_mask.view().bool", "ner.NERTagger._loss", "torch.cat.detach", "spans.detach", "span_mask.detach", "span_mask.view"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values", "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.predict"], ["", "@", "overrides", "\n", "def", "forward", "(", "self", ",", "# type: ignore", "\n", "spans", ":", "torch", ".", "IntTensor", ",", "\n", "span_mask", ":", "torch", ".", "IntTensor", ",", "\n", "span_embeddings", ":", "torch", ".", "IntTensor", ",", "\n", "sentence_lengths", ":", "torch", ".", "Tensor", ",", "\n", "ner_labels", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        TODO(dwadden) Write documentation.\n        \"\"\"", "\n", "\n", "# Shape: (Batch size, Number of Spans, Span Embedding Size)", "\n", "# span_embeddings", "\n", "\n", "self", ".", "_active_namespace", "=", "f\"{metadata.dataset}__ner_labels\"", "\n", "scorer", "=", "self", ".", "_ner_scorers", "[", "self", ".", "_active_namespace", "]", "\n", "\n", "ner_scores", "=", "scorer", "(", "span_embeddings", ")", "\n", "# Give large negative scores to masked-out elements.", "\n", "mask", "=", "span_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "ner_scores", "=", "util", ".", "replace_masked_values", "(", "ner_scores", ",", "mask", ".", "bool", "(", ")", ",", "-", "1e20", ")", "\n", "# The dummy_scores are the score for the null label.", "\n", "dummy_dims", "=", "[", "ner_scores", ".", "size", "(", "0", ")", ",", "ner_scores", ".", "size", "(", "1", ")", ",", "1", "]", "\n", "dummy_scores", "=", "ner_scores", ".", "new_zeros", "(", "*", "dummy_dims", ")", "\n", "ner_scores", "=", "torch", ".", "cat", "(", "(", "dummy_scores", ",", "ner_scores", ")", ",", "-", "1", ")", "\n", "\n", "_", ",", "predicted_ner", "=", "ner_scores", ".", "max", "(", "2", ")", "\n", "\n", "predictions", "=", "self", ".", "predict", "(", "ner_scores", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "spans", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "span_mask", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "metadata", ")", "\n", "output_dict", "=", "{", "\"predictions\"", ":", "predictions", "}", "\n", "\n", "if", "ner_labels", "is", "not", "None", ":", "\n", "            ", "metrics", "=", "self", ".", "_ner_metrics", "[", "self", ".", "_active_namespace", "]", "\n", "metrics", "(", "predicted_ner", ",", "ner_labels", ",", "span_mask", ")", "\n", "ner_scores_flat", "=", "ner_scores", ".", "view", "(", "-", "1", ",", "self", ".", "_n_labels", "[", "self", ".", "_active_namespace", "]", ")", "\n", "ner_labels_flat", "=", "ner_labels", ".", "view", "(", "-", "1", ")", "\n", "mask_flat", "=", "span_mask", ".", "view", "(", "-", "1", ")", ".", "bool", "(", ")", "\n", "\n", "loss", "=", "self", ".", "_loss", "(", "ner_scores_flat", "[", "mask_flat", "]", ",", "ner_labels_flat", "[", "mask_flat", "]", ")", "\n", "\n", "output_dict", "[", "\"loss\"", "]", "=", "loss", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.predict": [[122, 148], ["zip", "ner_scores_sent.max", "torch.nn.functional.softmax", "torch.nn.functional.softmax.max", "zip", "predictions.append", "span_mask_sent.bool", "ner.NERTagger.vocab.get_token_from_index", "label_span.tolist", "dygie.data.dataset_readers.document.PredictedNER", "predictions_sent.append", "label.item", "label_score_raw.item", "label_score_softmax.item"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "ner_scores", ",", "spans", ",", "span_mask", ",", "metadata", ")", ":", "\n", "# TODO(dwadden) Make sure the iteration works in documents with a single sentence.", "\n", "# Zipping up and iterating iterates over the zeroth dimension of each tensor; this", "\n", "# corresponds to iterating over sentences.", "\n", "        ", "predictions", "=", "[", "]", "\n", "zipped", "=", "zip", "(", "ner_scores", ",", "spans", ",", "span_mask", ",", "metadata", ")", "\n", "for", "ner_scores_sent", ",", "spans_sent", ",", "span_mask_sent", ",", "sentence", "in", "zipped", ":", "\n", "            ", "predicted_scores_raw", ",", "predicted_labels", "=", "ner_scores_sent", ".", "max", "(", "dim", "=", "1", ")", "\n", "softmax_scores", "=", "F", ".", "softmax", "(", "ner_scores_sent", ",", "dim", "=", "1", ")", "\n", "predicted_scores_softmax", ",", "_", "=", "softmax_scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "ix", "=", "(", "predicted_labels", "!=", "0", ")", "&", "span_mask_sent", ".", "bool", "(", ")", "\n", "\n", "predictions_sent", "=", "[", "]", "\n", "zip_pred", "=", "zip", "(", "predicted_labels", "[", "ix", "]", ",", "predicted_scores_raw", "[", "ix", "]", ",", "\n", "predicted_scores_softmax", "[", "ix", "]", ",", "spans_sent", "[", "ix", "]", ")", "\n", "for", "label", ",", "label_score_raw", ",", "label_score_softmax", ",", "label_span", "in", "zip_pred", ":", "\n", "                ", "label_str", "=", "self", ".", "vocab", ".", "get_token_from_index", "(", "label", ".", "item", "(", ")", ",", "self", ".", "_active_namespace", ")", "\n", "span_start", ",", "span_end", "=", "label_span", ".", "tolist", "(", ")", "\n", "ner", "=", "[", "span_start", ",", "span_end", ",", "label_str", ",", "label_score_raw", ".", "item", "(", ")", ",", "\n", "label_score_softmax", ".", "item", "(", ")", "]", "\n", "prediction", "=", "document", ".", "PredictedNER", "(", "ner", ",", "sentence", ",", "sentence_offsets", "=", "True", ")", "\n", "predictions_sent", ".", "append", "(", "prediction", ")", "\n", "\n", "", "predictions", ".", "append", "(", "predictions_sent", ")", "\n", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.get_metrics": [[150, 169], ["ner.NERTagger._ner_metrics.items", "metrics.get_metric", "namespace.replace", "res.update", "res.update", "sum", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "\"Loop over the metrics for all namespaces, and return as dict.\"", "\n", "res", "=", "{", "}", "\n", "for", "namespace", ",", "metrics", "in", "self", ".", "_ner_metrics", ".", "items", "(", ")", ":", "\n", "            ", "precision", ",", "recall", ",", "f1", "=", "metrics", ".", "get_metric", "(", "reset", ")", "\n", "prefix", "=", "namespace", ".", "replace", "(", "\"_labels\"", ",", "\"\"", ")", "\n", "to_update", "=", "{", "f\"{prefix}_precision\"", ":", "precision", ",", "\n", "f\"{prefix}_recall\"", ":", "recall", ",", "\n", "f\"{prefix}_f1\"", ":", "f1", "}", "\n", "res", ".", "update", "(", "to_update", ")", "\n", "\n", "", "res_avg", "=", "{", "}", "\n", "for", "name", "in", "[", "\"precision\"", ",", "\"recall\"", ",", "\"f1\"", "]", ":", "\n", "            ", "values", "=", "[", "res", "[", "key", "]", "for", "key", "in", "res", "if", "name", "in", "key", "]", "\n", "res_avg", "[", "f\"MEAN__ner_{name}\"", "]", "=", "sum", "(", "values", ")", "/", "len", "(", "values", ")", "if", "values", "else", "0", "\n", "res", ".", "update", "(", "res_avg", ")", "\n", "\n", "", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.__init__": [[48, 91], ["allennlp.models.model.Model.__init__", "allennlp.modules.token_embedders.Embedding", "make_feedforward", "allennlp.modules.TimeDistributed", "make_feedforward", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "dygie.models.entity_beam_pruner.Pruner", "allennlp.modules.TimeDistributed", "allennlp_models.coref.metrics.mention_recall.MentionRecall", "allennlp_models.coref.metrics.conll_coref_scores.ConllCorefScores", "allennlp.modules.FeedForward", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "make_feedforward.get_output_dim", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "make_feedforward.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "make_feedforward", ":", "Callable", ",", "\n", "span_emb_dim", ":", "int", ",", "\n", "feature_size", ":", "int", ",", "\n", "spans_per_word", ":", "float", ",", "\n", "max_antecedents", ":", "int", ",", "\n", "coref_prop", ":", "int", "=", "0", ",", "\n", "coref_prop_dropout_f", ":", "float", "=", "0.0", ",", "\n", "regularizer", ":", "Optional", "[", "RegularizerApplicator", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", "CorefResolver", ",", "self", ")", ".", "__init__", "(", "vocab", ",", "regularizer", ")", "\n", "\n", "# 10 possible distance buckets.", "\n", "self", ".", "_num_distance_buckets", "=", "10", "\n", "self", ".", "_spans_per_word", "=", "spans_per_word", "\n", "self", ".", "_max_antecedents", "=", "max_antecedents", "\n", "\n", "self", ".", "_distance_embedding", "=", "Embedding", "(", "embedding_dim", "=", "feature_size", ",", "\n", "num_embeddings", "=", "self", ".", "_num_distance_buckets", ")", "\n", "\n", "antecedent_input_dim", "=", "3", "*", "span_emb_dim", "+", "feature_size", "\n", "antecedent_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "antecedent_input_dim", ")", "\n", "self", ".", "_antecedent_feedforward", "=", "TimeDistributed", "(", "antecedent_feedforward", ")", "\n", "\n", "mention_feedforward", "=", "make_feedforward", "(", "input_dim", "=", "span_emb_dim", ")", "\n", "feedforward_scorer", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "mention_feedforward", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "mention_feedforward", ".", "get_output_dim", "(", ")", ",", "1", ")", ")", ")", "\n", "self", ".", "_mention_pruner", "=", "Pruner", "(", "feedforward_scorer", ")", "\n", "self", ".", "_antecedent_scorer", "=", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "\n", "antecedent_feedforward", ".", "get_output_dim", "(", ")", ",", "1", ")", ")", "\n", "\n", "self", ".", "_mention_recall", "=", "MentionRecall", "(", ")", "\n", "self", ".", "_conll_coref_scores", "=", "ConllCorefScores", "(", ")", "\n", "\n", "self", ".", "coref_prop", "=", "coref_prop", "\n", "self", ".", "_f_network", "=", "FeedForward", "(", "input_dim", "=", "2", "*", "span_emb_dim", ",", "\n", "num_layers", "=", "1", ",", "\n", "hidden_dims", "=", "span_emb_dim", ",", "\n", "activations", "=", "torch", ".", "nn", ".", "Sigmoid", "(", ")", ",", "\n", "dropout", "=", "coref_prop_dropout_f", ")", "\n", "\n", "self", ".", "antecedent_softmax", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.update_spans": [[92, 113], ["span_embeddings_batched.clone", "enumerate", "[].view"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.clone"], ["", "def", "update_spans", "(", "self", ",", "output_dict", ",", "span_embeddings_batched", ",", "indices", ")", ":", "\n", "        ", "new_span_embeddings_batched", "=", "span_embeddings_batched", ".", "clone", "(", ")", "\n", "offsets", "=", "{", "}", "\n", "for", "key", "in", "indices", ":", "\n", "            ", "offset", "=", "0", "\n", "while", "indices", "[", "key", "]", "[", "offset", "]", "==", "0", ":", "\n", "                ", "offset", "+=", "1", "\n", "", "offsets", "[", "key", "]", "=", "offset", "\n", "", "for", "doc_key", "in", "output_dict", ":", "\n", "            ", "span_ix", "=", "output_dict", "[", "doc_key", "]", "[", "\"span_ix\"", "]", "\n", "top_span_embeddings", "=", "output_dict", "[", "doc_key", "]", "[", "\"top_span_embeddings\"", "]", "\n", "for", "ix", ",", "el", "in", "enumerate", "(", "output_dict", "[", "doc_key", "]", "[", "\"top_span_indices\"", "]", ".", "view", "(", "-", "1", ")", ")", ":", "\n", "# This floor division is correct. We're doing division with a remainder, where", "\n", "# `row_ix` is the quotient (plus an offset added at the end) and `col_ix` is the", "\n", "# remainder. This converts from a span index to a row and column index in the span", "\n", "# embedding matrix.", "\n", "                ", "row_ix", "=", "span_ix", "[", "el", "]", "//", "span_embeddings_batched", ".", "shape", "[", "1", "]", "+", "offsets", "[", "doc_key", "]", "\n", "col_ix", "=", "span_ix", "[", "el", "]", "%", "span_embeddings_batched", ".", "shape", "[", "1", "]", "\n", "new_span_embeddings_batched", "[", "row_ix", ",", "col_ix", "]", "=", "top_span_embeddings", "[", "0", ",", "ix", "]", "\n", "\n", "", "", "return", "new_span_embeddings_batched", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.coref_propagation": [[114, 118], ["coref.CorefResolver.coref_propagation_doc"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.coref_propagation_doc"], ["", "def", "coref_propagation", "(", "self", ",", "output_dict", ")", ":", "\n", "        ", "for", "doc_key", "in", "output_dict", ":", "\n", "            ", "output_dict", "[", "doc_key", "]", "=", "self", ".", "coref_propagation_doc", "(", "output_dict", "[", "doc_key", "]", ")", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.coref_propagation_doc": [[119, 158], ["range", "top_span_embeddings.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "coref.CorefResolver._f_network", "coref.CorefResolver.get_coref_scores", "antecedent_indices.max", "coref.CorefResolver.antecedent_softmax", "allennlp.nn.util.batched_index_select().unsqueeze", "antecedent_indices.unsqueeze().unsqueeze().repeat", "top_span_embeddings.unsqueeze().repeat", "coref.CorefResolver._mention_pruner._scorer", "allennlp.nn.util.batched_index_select", "antecedent_indices.unsqueeze().unsqueeze", "top_span_embeddings.unsqueeze", "antecedent_indices.unsqueeze", "allennlp.nn.util.batched_index_select().unsqueeze.permute", "torch.gather().permute", "torch.gather().permute", "torch.gather().permute", "torch.gather().permute", "torch.gather", "torch.gather", "torch.gather", "torch.gather"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.get_coref_scores", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select"], ["", "def", "coref_propagation_doc", "(", "self", ",", "output_dict", ")", ":", "\n", "        ", "coreference_scores", "=", "output_dict", "[", "\"coreference_scores\"", "]", "\n", "top_span_embeddings", "=", "output_dict", "[", "\"top_span_embeddings\"", "]", "\n", "antecedent_indices", "=", "output_dict", "[", "\"antecedent_indices\"", "]", "\n", "for", "t", "in", "range", "(", "self", ".", "coref_prop", ")", ":", "\n", "            ", "assert", "coreference_scores", ".", "shape", "[", "1", "]", "==", "antecedent_indices", ".", "shape", "[", "0", "]", "\n", "assert", "coreference_scores", ".", "shape", "[", "2", "]", "-", "1", "==", "antecedent_indices", ".", "shape", "[", "1", "]", "\n", "assert", "top_span_embeddings", ".", "shape", "[", "1", "]", "==", "coreference_scores", ".", "shape", "[", "1", "]", "\n", "assert", "antecedent_indices", ".", "max", "(", ")", "<=", "top_span_embeddings", ".", "shape", "[", "1", "]", "\n", "\n", "antecedent_distribution", "=", "self", ".", "antecedent_softmax", "(", "coreference_scores", ")", "[", ":", ",", ":", ",", "1", ":", "]", "\n", "top_span_emb_repeated", "=", "top_span_embeddings", ".", "repeat", "(", "\n", "antecedent_distribution", ".", "shape", "[", "2", "]", ",", "1", ",", "1", ")", "\n", "if", "antecedent_indices", ".", "shape", "[", "0", "]", "==", "antecedent_indices", ".", "shape", "[", "1", "]", ":", "\n", "                ", "selected_top_span_embs", "=", "util", ".", "batched_index_select", "(", "\n", "top_span_emb_repeated", ",", "antecedent_indices", ")", ".", "unsqueeze", "(", "0", ")", "\n", "entity_embs", "=", "(", "selected_top_span_embs", ".", "permute", "(", "\n", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "*", "antecedent_distribution", ")", ".", "permute", "(", "[", "1", ",", "2", ",", "3", ",", "0", "]", ")", ".", "sum", "(", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "ant_var1", "=", "antecedent_indices", ".", "unsqueeze", "(", "\n", "0", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "top_span_embeddings", ".", "shape", "[", "-", "1", "]", ")", "\n", "top_var1", "=", "top_span_embeddings", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "\n", "1", ",", "antecedent_distribution", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ")", "\n", "entity_embs", "=", "(", "torch", ".", "gather", "(", "top_var1", ",", "2", ",", "ant_var1", ")", ".", "permute", "(", "\n", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "*", "antecedent_distribution", ")", ".", "permute", "(", "[", "1", ",", "2", ",", "3", ",", "0", "]", ")", ".", "sum", "(", "dim", "=", "2", ")", "\n", "\n", "", "f_network_input", "=", "torch", ".", "cat", "(", "[", "top_span_embeddings", ",", "entity_embs", "]", ",", "dim", "=", "-", "1", ")", "\n", "f_weights", "=", "self", ".", "_f_network", "(", "f_network_input", ")", "\n", "top_span_embeddings", "=", "f_weights", "*", "top_span_embeddings", "+", "(", "1.0", "-", "f_weights", ")", "*", "entity_embs", "\n", "\n", "coreference_scores", "=", "self", ".", "get_coref_scores", "(", "\n", "top_span_embeddings", ",", "\n", "self", ".", "_mention_pruner", ".", "_scorer", "(", "\n", "top_span_embeddings", ")", ",", "output_dict", "[", "\"antecedent_indices\"", "]", ",", "\n", "output_dict", "[", "\"valid_antecedent_offsets\"", "]", ",", "output_dict", "[", "\"valid_antecedent_log_mask\"", "]", ")", "\n", "\n", "", "output_dict", "[", "\"coreference_scores\"", "]", "=", "coreference_scores", "\n", "output_dict", "[", "\"top_span_embeddings\"", "]", "=", "top_span_embeddings", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.compute_representations": [[161, 196], ["len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "uniq_keys.append", "sentence_lengths[].sum().item", "coref.CorefResolver._compute_representations_doc", "sentence_lengths[].sum"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_representations_doc"], ["", "def", "compute_representations", "(", "self", ",", "# type: ignore", "\n", "spans_batched", ":", "torch", ".", "IntTensor", ",", "\n", "span_mask_batched", ",", "\n", "span_embeddings_batched", ",", "# TODO(dwadden) add type.", "\n", "sentence_lengths", ",", "\n", "coref_labels_batched", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "metadata", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Run the forward pass. Since we can only have coreferences between spans in the same\n        document, we loop over the documents in the batch. This function assumes that the inputs are\n        in order, but may go across documents.\n        \"\"\"", "\n", "output_docs", "=", "{", "}", "\n", "# TODO(dwadden) Update this when I implement multiple documents per minibatch.", "\n", "doc_keys", "=", "[", "metadata", ".", "doc_key", "]", "*", "len", "(", "metadata", ")", "\n", "uniq_keys", "=", "[", "]", "\n", "for", "entry", "in", "doc_keys", ":", "\n", "            ", "if", "entry", "not", "in", "uniq_keys", ":", "\n", "                ", "uniq_keys", ".", "append", "(", "entry", ")", "\n", "\n", "", "", "indices", "=", "{", "}", "\n", "for", "key", "in", "uniq_keys", ":", "\n", "            ", "ix_list", "=", "[", "1", "if", "entry", "==", "key", "else", "0", "for", "entry", "in", "doc_keys", "]", "\n", "indices", "[", "key", "]", "=", "ix_list", "\n", "doc_metadata", "=", "metadata", "\n", "ix", "=", "torch", ".", "tensor", "(", "ix_list", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "# If we don't have coref labels, leave as None; else get the right batch.", "\n", "coref_labels", "=", "(", "coref_labels_batched", "[", "ix", "]", "\n", "if", "coref_labels_batched", "is", "not", "None", "\n", "else", "coref_labels_batched", ")", "\n", "if", "sentence_lengths", "[", "ix", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ">", "1", ":", "\n", "                ", "output_docs", "[", "key", "]", "=", "self", ".", "_compute_representations_doc", "(", "\n", "spans_batched", "[", "ix", "]", ",", "span_mask_batched", "[", "ix", "]", ",", "span_embeddings_batched", "[", "ix", "]", ",", "\n", "sentence_lengths", "[", "ix", "]", ",", "ix", ",", "coref_labels", ",", "doc_metadata", ")", "\n", "", "", "return", "output_docs", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.predict_labels": [[197, 201], ["coref.CorefResolver.collect_losses", "coref.CorefResolver.predict_labels_doc"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.collect_losses", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.predict_labels_doc"], ["", "def", "predict_labels", "(", "self", ",", "output_docs", ",", "metadata", ")", ":", "\n", "        ", "for", "key", "in", "output_docs", ":", "\n", "            ", "output_docs", "[", "key", "]", "=", "self", ".", "predict_labels_doc", "(", "output_docs", "[", "key", "]", ")", "\n", "", "return", "self", ".", "collect_losses", "(", "output_docs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.collect_losses": [[202, 232], ["entry.get", "any", "ValueError", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "output_docs.values", "all", "len", "entry[].unsqueeze", "output_docs.values"], "methods", ["None"], ["", "def", "collect_losses", "(", "self", ",", "output_docs", ")", ":", "\n", "        ", "uniq_keys", "=", "[", "el", "for", "el", "in", "output_docs", "]", "\n", "losses", "=", "[", "entry", ".", "get", "(", "\"loss\"", ")", "for", "entry", "in", "output_docs", ".", "values", "(", ")", "]", "\n", "# If we're predicting, there won't be a loss.", "\n", "no_loss", "=", "[", "loss", "is", "None", "for", "loss", "in", "losses", "]", "\n", "if", "any", "(", "no_loss", ")", "and", "not", "all", "(", "no_loss", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"All docs in batch should either have a loss, or not have one.\"", ")", "\n", "", "no_loss", "=", "no_loss", "[", "0", "]", "\n", "\n", "if", "no_loss", ":", "\n", "            ", "loss", "=", "None", "\n", "", "else", ":", "\n", "            ", "losses", "=", "torch", ".", "cat", "(", "[", "entry", "[", "\"loss\"", "]", ".", "unsqueeze", "(", "0", ")", "for", "entry", "in", "output_docs", ".", "values", "(", ")", "]", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "losses", ")", "\n", "\n", "# At train time, return a separate output dict for each document.", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "output", "=", "{", "\"doc\"", ":", "output_docs", "}", "\n", "# At test time, we evaluate a whole document at a time. Just return the results for that", "\n", "# document.", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "uniq_keys", ")", "==", "1", "\n", "key", "=", "uniq_keys", "[", "0", "]", "\n", "output", "=", "output_docs", "[", "key", "]", "\n", "\n", "# Add the loss if we have one.", "\n", "", "if", "loss", "is", "not", "None", ":", "\n", "            ", "output", "[", "\"loss\"", "]", "=", "loss", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_representations_doc": [[233, 308], ["span_mask_batched.view().nonzero().squeeze", "coref.CorefResolver._flatten_spans", "coref.CorefResolver._flatten_coref_labels", "sentence_lengths.sum().item", "spans.size", "max", "torch.ones().unsqueeze", "torch.ones().unsqueeze", "torch.ones().unsqueeze", "torch.ones().unsqueeze", "coref.CorefResolver._mention_pruner", "top_span_mask.unsqueeze.unsqueeze.unsqueeze", "allennlp.nn.util.flatten_and_batch_shift_indices", "allennlp.nn.util.batched_index_select", "min", "coref.CorefResolver._generate_valid_antecedents", "coref.CorefResolver.get_coref_scores", "int", "allennlp.nn.util.get_device_of", "span_mask_batched.view().nonzero", "sentence_lengths.sum", "math.ceil", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "span_mask_batched.view"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._flatten_spans", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._flatten_coref_labels", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._generate_valid_antecedents", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.get_coref_scores", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of"], ["", "def", "_compute_representations_doc", "(", "\n", "self", ",", "# type: ignore", "\n", "spans_batched", ":", "torch", ".", "IntTensor", ",", "\n", "span_mask_batched", ",", "\n", "span_embeddings_batched", ",", "# TODO(dwadden) add type.", "\n", "sentence_lengths", ",", "\n", "ix", ",", "\n", "coref_labels_batched", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "# pylint: disable=arguments-differ", "\n", "        ", "\"\"\"\n        Run the forward pass for a single document.\n\n        Important: This function assumes that sentences are going to be passed in in sorted order,\n        from the same document.\n        \"\"\"", "\n", "# TODO(dwadden) How to handle case where only one span from a cluster makes it into the", "\n", "# minibatch? Should I get rid of the cluster?", "\n", "# TODO(dwadden) Write quick unit tests for correctness, time permitting.", "\n", "span_ix", "=", "span_mask_batched", ".", "view", "(", "-", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "# Indices of the spans to keep.", "\n", "spans", ",", "span_embeddings", "=", "self", ".", "_flatten_spans", "(", "\n", "spans_batched", ",", "span_ix", ",", "span_embeddings_batched", ",", "sentence_lengths", ")", "\n", "coref_labels", "=", "self", ".", "_flatten_coref_labels", "(", "coref_labels_batched", ",", "span_ix", ")", "\n", "\n", "document_length", "=", "sentence_lengths", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "num_spans", "=", "spans", ".", "size", "(", "1", ")", "\n", "\n", "# Prune based on mention scores. Make sure we keep at least 1.", "\n", "num_spans_to_keep", "=", "max", "(", "2", ",", "int", "(", "math", ".", "ceil", "(", "self", ".", "_spans_per_word", "*", "document_length", ")", ")", ")", "\n", "\n", "# Since there's only one minibatch, there aren't any masked spans for us. The span mask is", "\n", "# always 1.", "\n", "span_mask", "=", "torch", ".", "ones", "(", "num_spans", ",", "device", "=", "spans_batched", ".", "device", ")", ".", "unsqueeze", "(", "0", ")", "\n", "(", "top_span_embeddings", ",", "top_span_mask", ",", "\n", "top_span_indices", ",", "top_span_mention_scores", ",", "num_items_kept", ")", "=", "self", ".", "_mention_pruner", "(", "\n", "span_embeddings", ",", "span_mask", ",", "num_spans_to_keep", ")", "\n", "top_span_mask", "=", "top_span_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# Shape: (batch_size * num_spans_to_keep)", "\n", "flat_top_span_indices", "=", "util", ".", "flatten_and_batch_shift_indices", "(", "top_span_indices", ",", "num_spans", ")", "\n", "\n", "# Compute final predictions for which spans to consider as mentions.", "\n", "# Shape: (batch_size, num_spans_to_keep, 2)", "\n", "top_spans", "=", "util", ".", "batched_index_select", "(", "spans", ",", "\n", "top_span_indices", ",", "\n", "flat_top_span_indices", ")", "\n", "\n", "# Compute indices for antecedent spans to consider.", "\n", "max_antecedents", "=", "min", "(", "self", ".", "_max_antecedents", ",", "num_spans_to_keep", ")", "\n", "\n", "# Shapes:", "\n", "# (num_spans_to_keep, max_antecedents),", "\n", "# (1, max_antecedents),", "\n", "# (1, num_spans_to_keep, max_antecedents)", "\n", "valid_antecedent_indices", ",", "valid_antecedent_offsets", ",", "valid_antecedent_log_mask", "=", "self", ".", "_generate_valid_antecedents", "(", "num_spans_to_keep", ",", "max_antecedents", ",", "util", ".", "get_device_of", "(", "span_embeddings", ")", ")", "\n", "\n", "coreference_scores", "=", "self", ".", "get_coref_scores", "(", "\n", "top_span_embeddings", ",", "top_span_mention_scores", ",", "valid_antecedent_indices", ",", "\n", "valid_antecedent_offsets", ",", "valid_antecedent_log_mask", ")", "\n", "\n", "output_dict", "=", "{", "\"top_spans\"", ":", "top_spans", ",", "\n", "\"antecedent_indices\"", ":", "valid_antecedent_indices", ",", "\n", "\"valid_antecedent_log_mask\"", ":", "valid_antecedent_log_mask", ",", "\n", "\"valid_antecedent_offsets\"", ":", "valid_antecedent_offsets", ",", "\n", "\"top_span_indices\"", ":", "top_span_indices", ",", "\n", "\"top_span_mask\"", ":", "top_span_mask", ",", "\n", "\"top_span_embeddings\"", ":", "top_span_embeddings", ",", "\n", "\"flat_top_span_indices\"", ":", "flat_top_span_indices", ",", "\n", "\"coref_labels\"", ":", "coref_labels", ",", "\n", "\"coreference_scores\"", ":", "coreference_scores", ",", "\n", "\"sentence_lengths\"", ":", "sentence_lengths", ",", "\n", "\"span_ix\"", ":", "span_ix", ",", "\n", "\"metadata\"", ":", "metadata", "}", "\n", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.get_coref_scores": [[309, 331], ["allennlp.nn.util.flattened_index_select", "allennlp.nn.util.flattened_index_select().squeeze", "coref.CorefResolver._compute_span_pair_embeddings", "coref.CorefResolver._compute_coreference_scores", "allennlp.nn.util.flattened_index_select"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flattened_index_select", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_span_pair_embeddings", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_coreference_scores", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flattened_index_select"], ["", "def", "get_coref_scores", "(", "self", ",", "\n", "top_span_embeddings", ",", "\n", "top_span_mention_scores", ",", "\n", "valid_antecedent_indices", ",", "\n", "valid_antecedent_offsets", ",", "\n", "valid_antecedent_log_mask", ")", ":", "\n", "        ", "candidate_antecedent_embeddings", "=", "util", ".", "flattened_index_select", "(", "top_span_embeddings", ",", "\n", "valid_antecedent_indices", ")", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents)", "\n", "candidate_antecedent_mention_scores", "=", "util", ".", "flattened_index_select", "(", "top_span_mention_scores", ",", "\n", "valid_antecedent_indices", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "# Compute antecedent scores.", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents, embedding_size)", "\n", "span_pair_embeddings", "=", "self", ".", "_compute_span_pair_embeddings", "(", "top_span_embeddings", ",", "\n", "candidate_antecedent_embeddings", ",", "\n", "valid_antecedent_offsets", ")", "\n", "# Shape: (batch_size, num_spans_to_keep, 1 + max_antecedents)", "\n", "coreference_scores", "=", "self", ".", "_compute_coreference_scores", "(", "span_pair_embeddings", ",", "\n", "top_span_mention_scores", ",", "\n", "candidate_antecedent_mention_scores", ",", "\n", "valid_antecedent_log_mask", ")", "\n", "return", "coreference_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.predict_labels_doc": [[332, 386], ["coreference_scores.max", "allennlp.nn.util.batched_index_select", "allennlp.nn.util.flattened_index_select().squeeze", "valid_antecedent_log_mask.long", "coref.CorefResolver._compute_antecedent_gold_labels", "allennlp.nn.util.masked_log_softmax", "coref.CorefResolver._make_evaluation_metadata", "coref.CorefResolver._mention_recall", "coref.CorefResolver._conll_coref_scores", "coref_labels.unsqueeze", "coref.CorefResolver.log", "allennlp.nn.util.logsumexp().sum", "valid_antecedent_indices.unsqueeze", "allennlp.nn.util.flattened_index_select", "allennlp.nn.util.logsumexp"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_antecedent_gold_labels", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_log_softmax", "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._make_evaluation_metadata", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flattened_index_select", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.logsumexp"], ["", "def", "predict_labels_doc", "(", "self", ",", "output_dict", ")", ":", "\n", "# Shape: (batch_size, num_spans_to_keep)", "\n", "        ", "coref_labels", "=", "output_dict", "[", "\"coref_labels\"", "]", "\n", "coreference_scores", "=", "output_dict", "[", "\"coreference_scores\"", "]", "\n", "_", ",", "predicted_antecedents", "=", "coreference_scores", ".", "max", "(", "2", ")", "\n", "# Subtract one here because index 0 is the \"no antecedent\" class,", "\n", "# so this makes the indices line up with actual spans if the prediction", "\n", "# is greater than -1.", "\n", "predicted_antecedents", "-=", "1", "\n", "\n", "output_dict", "[", "\"predicted_antecedents\"", "]", "=", "predicted_antecedents", "\n", "\n", "top_span_indices", "=", "output_dict", "[", "\"top_span_indices\"", "]", "\n", "flat_top_span_indices", "=", "output_dict", "[", "\"flat_top_span_indices\"", "]", "\n", "valid_antecedent_indices", "=", "output_dict", "[", "\"antecedent_indices\"", "]", "\n", "valid_antecedent_log_mask", "=", "output_dict", "[", "\"valid_antecedent_log_mask\"", "]", "\n", "top_spans", "=", "output_dict", "[", "\"top_spans\"", "]", "\n", "top_span_mask", "=", "output_dict", "[", "\"top_span_mask\"", "]", "\n", "metadata", "=", "output_dict", "[", "\"metadata\"", "]", "\n", "sentence_lengths", "=", "output_dict", "[", "\"sentence_lengths\"", "]", "\n", "\n", "if", "coref_labels", "is", "not", "None", ":", "\n", "# Find the gold labels for the spans which we kept.", "\n", "            ", "pruned_gold_labels", "=", "util", ".", "batched_index_select", "(", "coref_labels", ".", "unsqueeze", "(", "-", "1", ")", ",", "\n", "top_span_indices", ",", "\n", "flat_top_span_indices", ")", "\n", "\n", "antecedent_labels", "=", "util", ".", "flattened_index_select", "(", "pruned_gold_labels", ",", "\n", "valid_antecedent_indices", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "# There's an integer wrap-around happening here. It occurs in the original code.", "\n", "antecedent_labels", "+=", "valid_antecedent_log_mask", ".", "long", "(", ")", "\n", "\n", "# Compute labels.", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents + 1)", "\n", "gold_antecedent_labels", "=", "self", ".", "_compute_antecedent_gold_labels", "(", "pruned_gold_labels", ",", "\n", "antecedent_labels", ")", "\n", "# Now, compute the loss using the negative marginal log-likelihood.", "\n", "coreference_log_probs", "=", "util", ".", "masked_log_softmax", "(", "coreference_scores", ",", "top_span_mask", ")", "\n", "correct_antecedent_log_probs", "=", "coreference_log_probs", "+", "gold_antecedent_labels", ".", "log", "(", ")", "\n", "negative_marginal_log_likelihood", "=", "-", "util", ".", "logsumexp", "(", "correct_antecedent_log_probs", ")", ".", "sum", "(", ")", "\n", "\n", "# Need to get cluster data in same form as for original AllenNLP coref code so that the", "\n", "# evaluation code works.", "\n", "evaluation_metadata", "=", "self", ".", "_make_evaluation_metadata", "(", "metadata", ",", "sentence_lengths", ")", "\n", "\n", "self", ".", "_mention_recall", "(", "top_spans", ",", "evaluation_metadata", ")", "\n", "\n", "# TODO(dwadden) Shouldnt need to do the unsqueeze here; figure out what's happening.", "\n", "self", ".", "_conll_coref_scores", "(", "\n", "top_spans", ",", "valid_antecedent_indices", ".", "unsqueeze", "(", "0", ")", ",", "predicted_antecedents", ",", "evaluation_metadata", ")", "\n", "\n", "output_dict", "[", "\"loss\"", "]", "=", "negative_marginal_log_likelihood", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.make_output_human_readable": [[387, 460], ["output_dict[].detach().cpu", "output_dict[].detach().cpu", "output_dict[].detach().cpu", "zip", "enumerate", "batch_clusters.append", "output_dict[].detach", "output_dict[].detach", "output_dict[].detach", "zip", "clusters[].append", "top_spans[].item", "top_spans[].item", "len", "clusters.append", "span[].item", "span[].item"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "make_output_human_readable", "(", "self", ",", "output_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Converts the list of spans and predicted antecedent indices into clusters\n        of spans for each element in the batch.\n\n        Parameters\n        ----------\n        output_dict : ``Dict[str, torch.Tensor]``, required.\n            The result of calling :func:`forward` on an instance or batch of instances.\n\n        Returns\n        -------\n        The same output dictionary, but with an additional ``clusters`` key:\n\n        clusters : ``List[List[List[Tuple[int, int]]]]``\n            A nested list, representing, for each instance in the batch, the list of clusters,\n            which are in turn comprised of a list of (start, end) inclusive spans into the\n            original document.\n        \"\"\"", "\n", "\n", "# A tensor of shape (batch_size, num_spans_to_keep, 2), representing", "\n", "# the start and end indices of each span.", "\n", "batch_top_spans", "=", "output_dict", "[", "\"top_spans\"", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "\n", "# A tensor of shape (batch_size, num_spans_to_keep) representing, for each span,", "\n", "# the index into ``antecedent_indices`` which specifies the antecedent span. Additionally,", "\n", "# the index can be -1, specifying that the span has no predicted antecedent.", "\n", "batch_predicted_antecedents", "=", "output_dict", "[", "\"predicted_antecedents\"", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "\n", "# A tensor of shape (num_spans_to_keep, max_antecedents), representing the indices", "\n", "# of the predicted antecedents with respect to the 2nd dimension of ``batch_top_spans``", "\n", "# for each antecedent we considered.", "\n", "antecedent_indices", "=", "output_dict", "[", "\"antecedent_indices\"", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "batch_clusters", ":", "List", "[", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", "]", "=", "[", "]", "\n", "\n", "# Calling zip() on two tensors results in an iterator over their", "\n", "# first dimension. This is iterating over instances in the batch.", "\n", "for", "top_spans", ",", "predicted_antecedents", "in", "zip", "(", "batch_top_spans", ",", "batch_predicted_antecedents", ")", ":", "\n", "            ", "spans_to_cluster_ids", ":", "Dict", "[", "Tuple", "[", "int", ",", "int", "]", ",", "int", "]", "=", "{", "}", "\n", "clusters", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", "=", "[", "]", "\n", "\n", "for", "i", ",", "(", "span", ",", "predicted_antecedent", ")", "in", "enumerate", "(", "zip", "(", "top_spans", ",", "predicted_antecedents", ")", ")", ":", "\n", "                ", "if", "predicted_antecedent", "<", "0", ":", "\n", "# We don't care about spans which are", "\n", "# not co-referent with anything.", "\n", "                    ", "continue", "\n", "\n", "# Find the right cluster to update with this span.", "\n", "", "predicted_index", "=", "antecedent_indices", "[", "i", ",", "predicted_antecedent", "]", "\n", "\n", "antecedent_span", "=", "(", "top_spans", "[", "predicted_index", ",", "0", "]", ".", "item", "(", ")", ",", "\n", "top_spans", "[", "predicted_index", ",", "1", "]", ".", "item", "(", ")", ")", "\n", "\n", "# Check if we've seen the span before.", "\n", "if", "antecedent_span", "in", "spans_to_cluster_ids", ":", "\n", "                    ", "predicted_cluster_id", ":", "int", "=", "spans_to_cluster_ids", "[", "antecedent_span", "]", "\n", "", "else", ":", "\n", "# We start a new cluster.", "\n", "                    ", "predicted_cluster_id", "=", "len", "(", "clusters", ")", "\n", "# Append a new cluster containing only this span.", "\n", "clusters", ".", "append", "(", "[", "antecedent_span", "]", ")", "\n", "# Record the new id of this span.", "\n", "spans_to_cluster_ids", "[", "antecedent_span", "]", "=", "predicted_cluster_id", "\n", "\n", "# Now add the span we are currently considering.", "\n", "", "span_start", ",", "span_end", "=", "span", "[", "0", "]", ".", "item", "(", ")", ",", "span", "[", "1", "]", ".", "item", "(", ")", "\n", "clusters", "[", "predicted_cluster_id", "]", ".", "append", "(", "(", "span_start", ",", "span_end", ")", ")", "\n", "spans_to_cluster_ids", "[", "(", "span_start", ",", "span_end", ")", "]", "=", "predicted_cluster_id", "\n", "", "batch_clusters", ".", "append", "(", "clusters", ")", "\n", "\n", "", "output_dict", "[", "\"predicted_clusters\"", "]", "=", "batch_clusters", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver.get_metrics": [[461, 470], ["coref.CorefResolver._mention_recall.get_metric", "coref.CorefResolver._conll_coref_scores.get_metric"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "mention_recall", "=", "self", ".", "_mention_recall", ".", "get_metric", "(", "reset", ")", "\n", "coref_precision", ",", "coref_recall", ",", "coref_f1", "=", "self", ".", "_conll_coref_scores", ".", "get_metric", "(", "reset", ")", "\n", "\n", "return", "{", "\"coref_precision\"", ":", "coref_precision", ",", "\n", "\"coref_recall\"", ":", "coref_recall", ",", "\n", "\"coref_f1\"", ":", "coref_f1", ",", "\n", "\"coref_mention_recall\"", ":", "mention_recall", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._generate_valid_antecedents": [[471, 527], ["allennlp.nn.util.get_range_vector().unsqueeze", "torch.relu().long", "torch.relu().long", "allennlp.nn.util.get_range_vector", "torch.relu", "torch.relu", "allennlp.nn.util.get_range_vector", "raw_antecedent_indices.float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector"], ["", "@", "staticmethod", "\n", "def", "_generate_valid_antecedents", "(", "num_spans_to_keep", ":", "int", ",", "\n", "max_antecedents", ":", "int", ",", "\n", "device", ":", "int", ")", "->", "Tuple", "[", "torch", ".", "IntTensor", ",", "\n", "torch", ".", "IntTensor", ",", "\n", "torch", ".", "FloatTensor", "]", ":", "\n", "        ", "\"\"\"\n        This method generates possible antecedents per span which survived the pruning\n        stage. This procedure is `generic across the batch`. The reason this is the case is\n        that each span in a batch can be coreferent with any previous span, but here we\n        are computing the possible `indices` of these spans. So, regardless of the batch,\n        the 1st span _cannot_ have any antecedents, because there are none to select from.\n        Similarly, each element can only predict previous spans, so this returns a matrix\n        of shape (num_spans_to_keep, max_antecedents), where the (i,j)-th index is equal to\n        (i - 1) - j if j <= i, or zero otherwise.\n\n        Parameters\n        ----------\n        num_spans_to_keep : ``int``, required.\n            The number of spans that were kept while pruning.\n        max_antecedents : ``int``, required.\n            The maximum number of antecedent spans to consider for every span.\n        device: ``int``, required.\n            The CUDA device to use.\n\n        Returns\n        -------\n        valid_antecedent_indices : ``torch.IntTensor``\n            The indices of every antecedent to consider with respect to the top k spans.\n            Has shape ``(num_spans_to_keep, max_antecedents)``.\n        valid_antecedent_offsets : ``torch.IntTensor``\n            The distance between the span and each of its antecedents in terms of the number\n            of considered spans (i.e not the word distance between the spans).\n            Has shape ``(1, max_antecedents)``.\n        valid_antecedent_log_mask : ``torch.FloatTensor``\n            The logged mask representing whether each antecedent span is valid. Required since\n            different spans have different numbers of valid antecedents. For example, the first\n            span in the document should have no valid antecedents.\n            Has shape ``(1, num_spans_to_keep, max_antecedents)``.\n        \"\"\"", "\n", "# Shape: (num_spans_to_keep, 1)", "\n", "target_indices", "=", "util", ".", "get_range_vector", "(", "num_spans_to_keep", ",", "device", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# Shape: (1, max_antecedents)", "\n", "valid_antecedent_offsets", "=", "(", "util", ".", "get_range_vector", "(", "max_antecedents", ",", "device", ")", "+", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# This is a broadcasted subtraction.", "\n", "# Shape: (num_spans_to_keep, max_antecedents)", "\n", "raw_antecedent_indices", "=", "target_indices", "-", "valid_antecedent_offsets", "\n", "\n", "# Shape: (1, num_spans_to_keep, max_antecedents)", "\n", "valid_antecedent_log_mask", "=", "(", "raw_antecedent_indices", ">=", "0", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ".", "log", "(", ")", "\n", "\n", "# Shape: (num_spans_to_keep, max_antecedents)", "\n", "valid_antecedent_indices", "=", "F", ".", "relu", "(", "raw_antecedent_indices", ".", "float", "(", ")", ")", ".", "long", "(", ")", "\n", "return", "valid_antecedent_indices", ",", "valid_antecedent_offsets", ",", "valid_antecedent_log_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_span_pair_embeddings": [[528, 581], ["top_span_embeddings.unsqueeze().expand_as", "coref.CorefResolver._distance_embedding", "antecedent_distance_embeddings.expand.expand.unsqueeze", "antecedent_distance_embeddings.expand.expand.expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "allennlp.nn.util.bucket_values", "antecedent_embeddings.size", "antecedent_embeddings.size", "antecedent_embeddings.size", "antecedent_distance_embeddings.expand.expand.size", "top_span_embeddings.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.bucket_values"], ["", "def", "_compute_span_pair_embeddings", "(", "self", ",", "\n", "top_span_embeddings", ":", "torch", ".", "FloatTensor", ",", "\n", "antecedent_embeddings", ":", "torch", ".", "FloatTensor", ",", "\n", "antecedent_offsets", ":", "torch", ".", "FloatTensor", ")", ":", "\n", "        ", "\"\"\"\n        Computes an embedding representation of pairs of spans for the pairwise scoring function\n        to consider. This includes both the original span representations, the element-wise\n        similarity of the span representations, and an embedding representation of the distance\n        between the two spans.\n\n        Parameters\n        ----------\n        top_span_embeddings : ``torch.FloatTensor``, required.\n            Embedding representations of the top spans. Has shape\n            (batch_size, num_spans_to_keep, embedding_size).\n        antecedent_embeddings : ``torch.FloatTensor``, required.\n            Embedding representations of the antecedent spans we are considering\n            for each top span. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents, embedding_size).\n        antecedent_offsets : ``torch.IntTensor``, required.\n            The offsets between each top span and its antecedent spans in terms\n            of spans we are considering. Has shape (1, max_antecedents).\n\n        Returns\n        -------\n        span_pair_embeddings : ``torch.FloatTensor``\n            Embedding representation of the pair of spans to consider. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents, embedding_size)\n        \"\"\"", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents, embedding_size)", "\n", "target_embeddings", "=", "top_span_embeddings", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "antecedent_embeddings", ")", "\n", "\n", "# Shape: (1, max_antecedents, embedding_size)", "\n", "antecedent_distance_embeddings", "=", "self", ".", "_distance_embedding", "(", "\n", "util", ".", "bucket_values", "(", "antecedent_offsets", ",", "\n", "num_total_buckets", "=", "self", ".", "_num_distance_buckets", ")", ")", "\n", "\n", "# Shape: (1, 1, max_antecedents, embedding_size)", "\n", "antecedent_distance_embeddings", "=", "antecedent_distance_embeddings", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "expanded_distance_embeddings_shape", "=", "(", "antecedent_embeddings", ".", "size", "(", "0", ")", ",", "\n", "antecedent_embeddings", ".", "size", "(", "1", ")", ",", "\n", "antecedent_embeddings", ".", "size", "(", "2", ")", ",", "\n", "antecedent_distance_embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents, embedding_size)", "\n", "antecedent_distance_embeddings", "=", "antecedent_distance_embeddings", ".", "expand", "(", "*", "expanded_distance_embeddings_shape", ")", "\n", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents, embedding_size)", "\n", "span_pair_embeddings", "=", "torch", ".", "cat", "(", "[", "target_embeddings", ",", "\n", "antecedent_embeddings", ",", "\n", "antecedent_embeddings", "*", "target_embeddings", ",", "\n", "antecedent_distance_embeddings", "]", ",", "-", "1", ")", "\n", "return", "span_pair_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_antecedent_gold_labels": [[582, 621], ["top_coref_labels.expand_as", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_antecedent_gold_labels", "(", "top_coref_labels", ":", "torch", ".", "IntTensor", ",", "\n", "antecedent_labels", ":", "torch", ".", "IntTensor", ")", ":", "\n", "        ", "\"\"\"\n        Generates a binary indicator for every pair of spans. This label is one if and\n        only if the pair of spans belong to the same cluster. The labels are augmented\n        with a dummy antecedent at the zeroth position, which represents the prediction\n        that a span does not have any antecedent.\n\n        Parameters\n        ----------\n        top_coref_labels : ``torch.IntTensor``, required.\n            The cluster id label for every span. The id is arbitrary,\n            as we just care about the clustering. Has shape (batch_size, num_spans_to_keep).\n        antecedent_labels : ``torch.IntTensor``, required.\n            The cluster id label for every antecedent span. The id is arbitrary,\n            as we just care about the clustering. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents).\n\n        Returns\n        -------\n        pairwise_labels_with_dummy_label : ``torch.FloatTensor``\n            A binary tensor representing whether a given pair of spans belong to\n            the same cluster in the gold clustering.\n            Has shape (batch_size, num_spans_to_keep, max_antecedents + 1).\n\n        \"\"\"", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents)", "\n", "target_labels", "=", "top_coref_labels", ".", "expand_as", "(", "antecedent_labels", ")", "\n", "same_cluster_indicator", "=", "(", "target_labels", "==", "antecedent_labels", ")", ".", "float", "(", ")", "\n", "non_dummy_indicator", "=", "(", "target_labels", ">=", "0", ")", ".", "float", "(", ")", "\n", "pairwise_labels", "=", "same_cluster_indicator", "*", "non_dummy_indicator", "\n", "\n", "# Shape: (batch_size, num_spans_to_keep, 1)", "\n", "dummy_labels", "=", "(", "1", "-", "pairwise_labels", ")", ".", "prod", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents + 1)", "\n", "pairwise_labels_with_dummy_label", "=", "torch", ".", "cat", "(", "[", "dummy_labels", ",", "pairwise_labels", "]", ",", "-", "1", ")", "\n", "return", "pairwise_labels_with_dummy_label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_coreference_scores": [[622, 670], ["coref.CorefResolver._antecedent_scorer().squeeze", "coref.CorefResolver.new_zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "coref.CorefResolver.size", "coref.CorefResolver.size", "coref.CorefResolver._antecedent_scorer", "coref.CorefResolver._antecedent_feedforward"], "methods", ["None"], ["", "def", "_compute_coreference_scores", "(", "self", ",", "\n", "pairwise_embeddings", ":", "torch", ".", "FloatTensor", ",", "\n", "top_span_mention_scores", ":", "torch", ".", "FloatTensor", ",", "\n", "antecedent_mention_scores", ":", "torch", ".", "FloatTensor", ",", "\n", "antecedent_log_mask", ":", "torch", ".", "FloatTensor", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Computes scores for every pair of spans. Additionally, a dummy label is included,\n        representing the decision that the span is not coreferent with anything. For the dummy\n        label, the score is always zero. For the true antecedent spans, the score consists of\n        the pairwise antecedent score and the unary mention scores for the span and its\n        antecedent. The factoring allows the model to blame many of the absent links on bad\n        spans, enabling the pruning strategy used in the forward pass.\n\n        Parameters\n        ----------\n        pairwise_embeddings: ``torch.FloatTensor``, required.\n            Embedding representations of pairs of spans. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents, encoding_dim)\n        top_span_mention_scores: ``torch.FloatTensor``, required.\n            Mention scores for every span. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents).\n        antecedent_mention_scores: ``torch.FloatTensor``, required.\n            Mention scores for every antecedent. Has shape\n            (batch_size, num_spans_to_keep, max_antecedents).\n        antecedent_log_mask: ``torch.FloatTensor``, required.\n            The log of the mask for valid antecedents.\n\n        Returns\n        -------\n        coreference_scores: ``torch.FloatTensor``\n            A tensor of shape (batch_size, num_spans_to_keep, max_antecedents + 1),\n            representing the unormalised score for each (span, antecedent) pair\n            we considered.\n\n        \"\"\"", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents)", "\n", "antecedent_scores", "=", "self", ".", "_antecedent_scorer", "(", "\n", "self", ".", "_antecedent_feedforward", "(", "pairwise_embeddings", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "antecedent_scores", "+=", "top_span_mention_scores", "+", "antecedent_mention_scores", "\n", "antecedent_scores", "+=", "antecedent_log_mask", "\n", "\n", "# Shape: (batch_size, num_spans_to_keep, 1)", "\n", "shape", "=", "[", "antecedent_scores", ".", "size", "(", "0", ")", ",", "antecedent_scores", ".", "size", "(", "1", ")", ",", "1", "]", "\n", "dummy_scores", "=", "antecedent_scores", ".", "new_zeros", "(", "*", "shape", ")", "\n", "\n", "# Shape: (batch_size, num_spans_to_keep, max_antecedents + 1)", "\n", "coreference_scores", "=", "torch", ".", "cat", "(", "[", "dummy_scores", ",", "antecedent_scores", "]", ",", "-", "1", ")", "\n", "return", "coreference_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._flatten_spans": [[671, 690], ["dygie.models.shared.cumsum_shifted().unsqueeze().unsqueeze", "spans_offset.view", "spans_flat[].unsqueeze", "span_embeddings_batched.view", "emb_flat[].unsqueeze", "dygie.models.shared.cumsum_shifted().unsqueeze", "dygie.models.shared.cumsum_shifted"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.shared.cumsum_shifted"], ["", "def", "_flatten_spans", "(", "self", ",", "spans_batched", ",", "span_ix", ",", "span_embeddings_batched", ",", "sentence_lengths", ")", ":", "\n", "        ", "\"\"\"\n        Spans are input with each minibatch as a sentence. For coref, it's easier to flatten them out\n        and consider all sentences together as a document.\n        \"\"\"", "\n", "# Get feature size and indices of good spans", "\n", "feature_size", "=", "self", ".", "_mention_pruner", ".", "_scorer", "[", "0", "]", ".", "_module", ".", "input_dim", "\n", "\n", "# Change the span offsets to document-level, flatten, and keep good ones.", "\n", "sentence_offset", "=", "shared", ".", "cumsum_shifted", "(", "sentence_lengths", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "spans_offset", "=", "spans_batched", "+", "sentence_offset", "\n", "spans_flat", "=", "spans_offset", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "spans_flat", "=", "spans_flat", "[", "span_ix", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# Flatten the span embeddings and keep the good ones.", "\n", "emb_flat", "=", "span_embeddings_batched", ".", "view", "(", "-", "1", ",", "feature_size", ")", "\n", "span_embeddings_flat", "=", "emb_flat", "[", "span_ix", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "return", "spans_flat", ",", "span_embeddings_flat", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._flatten_coref_labels": [[691, 701], ["labels_flat.unsqueeze.unsqueeze.unsqueeze", "coref_labels_batched.view"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_flatten_coref_labels", "(", "coref_labels_batched", ",", "span_ix", ")", ":", "\n", "        ", "\"Flatten the coref labels.\"", "\n", "# If we don't have labels, return None.", "\n", "if", "coref_labels_batched", "is", "None", ":", "\n", "            ", "return", "coref_labels_batched", "\n", "\n", "", "labels_flat", "=", "coref_labels_batched", ".", "view", "(", "-", "1", ")", "[", "span_ix", "]", "\n", "labels_flat", "=", "labels_flat", ".", "unsqueeze", "(", "0", ")", "\n", "return", "labels_flat", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._make_evaluation_metadata": [[702, 727], ["dygie.models.shared.cumsum_shifted().tolist", "zip", "entry.cluster_dict.items", "dict", "dygie.models.shared.cumsum_shifted", "cluster_dict.values", "cluster_dict[].append"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.shared.cumsum_shifted"], ["", "@", "staticmethod", "\n", "def", "_make_evaluation_metadata", "(", "metadata", ",", "sentence_lengths", ")", ":", "\n", "        ", "\"\"\"\n        Get cluster metadata in form to feed into evaluation scripts. For each entry in minibatch,\n        return a dict with a metadata field, which is a list whose entries are lists specifying the\n        spans involved in a given cluster.\n        For coreference evaluation, we need to make the span indices with respect to the entire\n        \"document\" (i.e. all sentences in minibatch), rather than with respect to each sentence.\n        \"\"\"", "\n", "# TODO(dwadden) Write tests to make sure sentence starts match lengths of sentences in", "\n", "# metadata.", "\n", "# As elsewhere, we assume the batch size will always be 1.", "\n", "cluster_dict", "=", "{", "}", "\n", "sentence_offset", "=", "shared", ".", "cumsum_shifted", "(", "sentence_lengths", ")", ".", "tolist", "(", ")", "\n", "for", "entry", ",", "sentence_start", "in", "zip", "(", "metadata", ",", "sentence_offset", ")", ":", "\n", "            ", "for", "span", ",", "cluster_id", "in", "entry", ".", "cluster_dict", ".", "items", "(", ")", ":", "\n", "                ", "span_offset", "=", "(", "span", "[", "0", "]", "+", "sentence_start", ",", "span", "[", "1", "]", "+", "sentence_start", ")", "\n", "if", "cluster_id", "in", "cluster_dict", ":", "\n", "                    ", "cluster_dict", "[", "cluster_id", "]", ".", "append", "(", "span_offset", ")", "\n", "", "else", ":", "\n", "                    ", "cluster_dict", "[", "cluster_id", "]", "=", "[", "span_offset", "]", "\n", "\n", "# The `values` method returns an iterator, and I need a list.", "\n", "", "", "", "clusters", "=", "[", "val", "for", "val", "in", "cluster_dict", ".", "values", "(", ")", "]", "\n", "return", "[", "dict", "(", "clusters", "=", "clusters", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.entity_beam_pruner.Pruner.__init__": [[45, 54], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "self", ",", "scorer", ":", "torch", ".", "nn", ".", "Module", ",", "entity_beam", ":", "bool", "=", "False", ",", "gold_beam", ":", "bool", "=", "False", ",", "\n", "min_score_to_keep", ":", "float", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# If gold beam is on, then entity beam must be off and min_score_to_keep must be None.", "\n", "assert", "not", "(", "gold_beam", "and", "(", "(", "min_score_to_keep", "is", "not", "None", ")", "or", "entity_beam", ")", ")", "\n", "self", ".", "_scorer", "=", "scorer", "\n", "self", ".", "_entity_beam", "=", "entity_beam", "\n", "self", ".", "_gold_beam", "=", "gold_beam", "\n", "self", ".", "_min_score_to_keep", "=", "min_score_to_keep", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.entity_beam_pruner.Pruner.forward": [[55, 193], ["isinstance", "mask.unsqueeze.unsqueeze.unsqueeze", "embeddings.size", "max", "allennlp.nn.util.replace_masked_values", "entity_beam_pruner.Pruner.topk", "allennlp.nn.util.get_mask_from_sequence_lengths", "top_indices_mask.bool.bool.bool", "torch.where.squeeze", "torch.where.max", "fill_value.unsqueeze.unsqueeze.unsqueeze", "torch.where", "torch.sort", "allennlp.nn.util.flatten_and_batch_shift_indices", "allennlp.nn.util.batched_index_select", "allennlp.nn.util.batched_index_select", "sequence_mask.squeeze().bool.squeeze().bool.squeeze().bool", "top_mask.long.long.long", "allennlp.nn.util.batched_index_select", "mask.unsqueeze.unsqueeze.size", "class_scores.max", "entity_beam_pruner.Pruner.unsqueeze", "torch.sum().squeeze", "torch.min", "torch.sum", "torch.sum.max().item", "ValueError", "mask.unsqueeze.unsqueeze.bool", "torch.ones", "torch.where", "entity_beam_pruner.Pruner.unsqueeze", "entity_beam_pruner.Pruner._scorer", "entity_beam_pruner.Pruner.size", "entity_beam_pruner.Pruner.dim", "sequence_mask.squeeze().bool.squeeze().bool.squeeze", "torch.zeros_like", "torch.sum", "torch.sum.max", "torch.ones_like", "entity_beam_pruner.Pruner.size"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_mask_from_sequence_lengths", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select"], ["", "@", "overrides", "\n", "def", "forward", "(", "self", ",", "# pylint: disable=arguments-differ", "\n", "embeddings", ":", "torch", ".", "FloatTensor", ",", "\n", "mask", ":", "torch", ".", "LongTensor", ",", "\n", "num_items_to_keep", ":", "Union", "[", "int", ",", "torch", ".", "LongTensor", "]", ",", "\n", "class_scores", ":", "torch", ".", "FloatTensor", "=", "None", ",", "\n", "gold_labels", ":", "torch", ".", "long", "=", "None", ")", "->", "Tuple", "[", "torch", ".", "FloatTensor", ",", "torch", ".", "LongTensor", ",", "\n", "torch", ".", "LongTensor", ",", "torch", ".", "FloatTensor", "]", ":", "\n", "        ", "\"\"\"\n        Extracts the top-k scoring items with respect to the scorer. We additionally return\n        the indices of the top-k in their original order, not ordered by score, so that downstream\n        components can rely on the original ordering (e.g., for knowing what spans are valid\n        antecedents in a coreference resolution model). May use the same k for all sentences in\n        minibatch, or different k for each.\n\n        Parameters\n        ----------\n        embeddings : ``torch.FloatTensor``, required.\n            A tensor of shape (batch_size, num_items, embedding_size), containing an embedding for\n            each item in the list that we want to prune.\n        mask : ``torch.LongTensor``, required.\n            A tensor of shape (batch_size, num_items), denoting unpadded elements of\n            ``embeddings``.\n        num_items_to_keep : ``Union[int, torch.LongTensor]``, required.\n            If a tensor of shape (batch_size), specifies the number of items to keep for each\n            individual sentence in minibatch.\n            If an int, keep the same number of items for all sentences.\n        class_scores:\n           Class scores to be used with entity beam.\n        candidate_labels: If in debugging mode, use gold labels to get beam.\n\n        Returns\n        -------\n        top_embeddings : ``torch.FloatTensor``\n            The representations of the top-k scoring items.\n            Has shape (batch_size, max_num_items_to_keep, embedding_size).\n        top_mask : ``torch.LongTensor``\n            The corresponding mask for ``top_embeddings``.\n            Has shape (batch_size, max_num_items_to_keep).\n        top_indices : ``torch.IntTensor``\n            The indices of the top-k scoring items into the original ``embeddings``\n            tensor. This is returned because it can be useful to retain pointers to\n            the original items, if each item is being scored by multiple distinct\n            scorers, for instance. Has shape (batch_size, max_num_items_to_keep).\n        top_item_scores : ``torch.FloatTensor``\n            The values of the top-k scoring items.\n            Has shape (batch_size, max_num_items_to_keep, 1).\n        num_items_kept\n        \"\"\"", "\n", "# If an int was given for number of items to keep, construct tensor by repeating the value.", "\n", "if", "isinstance", "(", "num_items_to_keep", ",", "int", ")", ":", "\n", "            ", "batch_size", "=", "mask", ".", "size", "(", "0", ")", "\n", "# Put the tensor on same device as the mask.", "\n", "num_items_to_keep", "=", "num_items_to_keep", "*", "torch", ".", "ones", "(", "[", "batch_size", "]", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "device", "=", "mask", ".", "device", ")", "\n", "\n", "", "mask", "=", "mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "num_items", "=", "embeddings", ".", "size", "(", "1", ")", "\n", "\n", "# Shape: (batch_size, num_items, 1)", "\n", "# If entity beam is one, use the class scores. Else ignore them and use the scorer.", "\n", "if", "self", ".", "_entity_beam", ":", "\n", "            ", "scores", ",", "_", "=", "class_scores", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "scores", "=", "scores", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# If gold beam is one, give a score of 0 wherever the gold label is non-zero (indicating a", "\n", "# non-null label), otherwise give a large negative number.", "\n", "", "elif", "self", ".", "_gold_beam", ":", "\n", "            ", "scores", "=", "torch", ".", "where", "(", "gold_labels", ">", "0", ",", "\n", "torch", ".", "zeros_like", "(", "gold_labels", ",", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "-", "1e20", "*", "torch", ".", "ones_like", "(", "gold_labels", ",", "dtype", "=", "torch", ".", "float", ")", ")", "\n", "scores", "=", "scores", ".", "unsqueeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "self", ".", "_scorer", "(", "embeddings", ")", "\n", "\n", "# If we're only keeping items that score above a given threshold, change the number of kept", "\n", "# items here.", "\n", "", "if", "self", ".", "_min_score_to_keep", "is", "not", "None", ":", "\n", "            ", "num_good_items", "=", "torch", ".", "sum", "(", "scores", ">", "self", ".", "_min_score_to_keep", ",", "dim", "=", "1", ")", ".", "squeeze", "(", ")", "\n", "num_items_to_keep", "=", "torch", ".", "min", "(", "num_items_to_keep", ",", "num_good_items", ")", "\n", "# If gold beam is on, keep the gold items.", "\n", "", "if", "self", ".", "_gold_beam", ":", "\n", "            ", "num_items_to_keep", "=", "torch", ".", "sum", "(", "gold_labels", ">", "0", ",", "dim", "=", "1", ")", "\n", "\n", "# Always keep at least one item to avoid edge case with empty matrix.", "\n", "", "max_items_to_keep", "=", "max", "(", "num_items_to_keep", ".", "max", "(", ")", ".", "item", "(", ")", ",", "1", ")", "\n", "\n", "if", "scores", ".", "size", "(", "-", "1", ")", "!=", "1", "or", "scores", ".", "dim", "(", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "f\"The scorer passed to Pruner must produce a tensor of shape\"", "\n", "f\"(batch_size, num_items, 1), but found shape {scores.size()}\"", ")", "\n", "# Make sure that we don't select any masked items by setting their scores to be very", "\n", "# negative.  These are logits, typically, so -1e20 should be plenty negative.", "\n", "# NOTE(`mask` needs to be a byte tensor now.)", "\n", "", "scores", "=", "util", ".", "replace_masked_values", "(", "scores", ",", "mask", ".", "bool", "(", ")", ",", "-", "1e20", ")", "\n", "\n", "# Shape: (batch_size, max_num_items_to_keep, 1)", "\n", "_", ",", "top_indices", "=", "scores", ".", "topk", "(", "max_items_to_keep", ",", "1", ")", "\n", "\n", "# Mask based on number of items to keep for each sentence.", "\n", "# Shape: (batch_size, max_num_items_to_keep)", "\n", "top_indices_mask", "=", "util", ".", "get_mask_from_sequence_lengths", "(", "num_items_to_keep", ",", "max_items_to_keep", ")", "\n", "top_indices_mask", "=", "top_indices_mask", ".", "bool", "(", ")", "\n", "\n", "# Shape: (batch_size, max_num_items_to_keep)", "\n", "top_indices", "=", "top_indices", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Fill all masked indices with largest \"top\" index for that sentence, so that all masked", "\n", "# indices will be sorted to the end.", "\n", "# Shape: (batch_size, 1)", "\n", "fill_value", ",", "_", "=", "top_indices", ".", "max", "(", "dim", "=", "1", ")", "\n", "fill_value", "=", "fill_value", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# Shape: (batch_size, max_num_items_to_keep)", "\n", "top_indices", "=", "torch", ".", "where", "(", "top_indices_mask", ",", "top_indices", ",", "fill_value", ")", "\n", "\n", "# Now we order the selected indices in increasing order with", "\n", "# respect to their indices (and hence, with respect to the", "\n", "# order they originally appeared in the ``embeddings`` tensor).", "\n", "top_indices", ",", "_", "=", "torch", ".", "sort", "(", "top_indices", ",", "1", ")", "\n", "\n", "# Shape: (batch_size * max_num_items_to_keep)", "\n", "# torch.index_select only accepts 1D indices, but here", "\n", "# we need to select items for each element in the batch.", "\n", "flat_top_indices", "=", "util", ".", "flatten_and_batch_shift_indices", "(", "top_indices", ",", "num_items", ")", "\n", "\n", "# Shape: (batch_size, max_num_items_to_keep, embedding_size)", "\n", "top_embeddings", "=", "util", ".", "batched_index_select", "(", "embeddings", ",", "top_indices", ",", "flat_top_indices", ")", "\n", "\n", "# Combine the masks on spans that are out-of-bounds, and the mask on spans that are outside", "\n", "# the top k for each sentence.", "\n", "# Shape: (batch_size, max_num_items_to_keep)", "\n", "sequence_mask", "=", "util", ".", "batched_index_select", "(", "mask", ",", "top_indices", ",", "flat_top_indices", ")", "\n", "sequence_mask", "=", "sequence_mask", ".", "squeeze", "(", "-", "1", ")", ".", "bool", "(", ")", "\n", "top_mask", "=", "top_indices_mask", "&", "sequence_mask", "\n", "top_mask", "=", "top_mask", ".", "long", "(", ")", "\n", "\n", "# Shape: (batch_size, max_num_items_to_keep, 1)", "\n", "top_scores", "=", "util", ".", "batched_index_select", "(", "scores", ",", "top_indices", ",", "flat_top_indices", ")", "\n", "\n", "return", "top_embeddings", ",", "top_mask", ",", "top_indices", ",", "top_scores", ",", "num_items_to_keep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.entity_beam_pruner.make_pruner": [[14, 25], ["torch.nn.Sequential", "entity_beam_pruner.Pruner", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "torch.nn.Linear", "scorer.get_output_dim"], "function", ["None"], ["def", "make_pruner", "(", "scorer", ",", "entity_beam", "=", "False", ",", "gold_beam", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Create a pruner that either takes outputs of other scorers (i.e. entity beam), or uses its own\n    scorer (the `default_scorer`).\n    \"\"\"", "\n", "item_scorer", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "scorer", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "scorer", ".", "get_output_dim", "(", ")", ",", "1", ")", ")", ")", "\n", "min_score_to_keep", "=", "1e-10", "if", "entity_beam", "else", "None", "\n", "\n", "return", "Pruner", "(", "item_scorer", ",", "entity_beam", ",", "gold_beam", ",", "min_score_to_keep", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.dygie_test.TestDyGIE.setUp": [[11, 17], ["super().setUp", "dygie_test.TestDyGIE.set_up_model"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# TODO(dwadden) create smaller model for testing.", "\n", "        ", "super", "(", "TestDyGIE", ",", "self", ")", ".", "setUp", "(", ")", "\n", "self", ".", "config_file", "=", "\"tests/fixtures/dygie_test_full.jsonnet\"", "\n", "self", ".", "data_file", "=", "\"tests/fixtures/scierc_article.json\"", "\n", "self", ".", "set_up_model", "(", "self", ".", "config_file", ",", "self", ".", "data_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.dygie_test.TestDyGIE.test_dygie_model_can_train_save_and_load": [[18, 20], ["dygie_test.TestDyGIE.ensure_model_can_train_save_and_load"], "methods", ["None"], ["", "def", "test_dygie_model_can_train_save_and_load", "(", "self", ")", ":", "\n", "        ", "self", ".", "ensure_model_can_train_save_and_load", "(", "self", ".", "param_file", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.coref_test.TestCoref.setUp": [[15, 21], ["super().setUp", "coref_test.TestCoref.set_up_model"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# TODO(dwadden) create smaller model for testing.", "\n", "        ", "super", "(", "TestCoref", ",", "self", ")", ".", "setUp", "(", ")", "\n", "self", ".", "config_file", "=", "\"tests/fixtures/dygie_test.jsonnet\"", "\n", "self", ".", "data_file", "=", "\"tests/fixtures/scierc_article.json\"", "\n", "self", ".", "set_up_model", "(", "self", ".", "config_file", ",", "self", ".", "data_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref_test.TestCoref.get_raw_data": [[22, 28], ["open", "lines.append", "json.loads"], "methods", ["None"], ["", "def", "get_raw_data", "(", "self", ")", ":", "\n", "        ", "lines", "=", "[", "]", "\n", "with", "open", "(", "self", ".", "data_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "lines", ".", "append", "(", "json", ".", "loads", "(", "line", ")", ")", "\n", "", "", "return", "lines", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.coref_test.TestCoref.test_coref_make_evaluation_metadata": [[29, 55], ["coref_test.TestCoref.dataset.as_tensor_dict", "allennlp.nn.util.get_text_field_mask().float", "allennlp.nn.util.get_text_field_mask().float.sum().long", "coref_test.TestCoref.model._coref._make_evaluation_metadata", "sorted", "util.get_text_field_mask().float.sum().long.tolist", "allennlp.nn.util.get_text_field_mask", "allennlp.nn.util.get_text_field_mask().float.sum", "len", "list", "coref_test.TestCoref.get_raw_data"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._make_evaluation_metadata", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_text_field_mask", "home.repos.pwc.inspect_result.mslars_mare.models.coref_test.TestCoref.get_raw_data"], ["", "def", "test_coref_make_evaluation_metadata", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        To compute coreference evaluation metrics, the evaluator needs access to the list of\n        coreference clusters, given in the same form as the original input. I check to make sure\n        that the clusters I pass in are indeed equivalent to the original input.\n        \"\"\"", "\n", "# Pull together the relevant training data.", "\n", "data", "=", "self", ".", "dataset", ".", "as_tensor_dict", "(", ")", "\n", "metadata", "=", "data", "[", "\"metadata\"", "]", "\n", "text_mask", "=", "util", ".", "get_text_field_mask", "(", "data", "[", "\"text\"", "]", ")", ".", "float", "(", ")", "\n", "sentence_lengths", "=", "text_mask", ".", "sum", "(", "dim", "=", "1", ")", ".", "long", "(", ")", "\n", "# Make sure the sentence lengths from the text mask are the same as the number of tokens.", "\n", "assert", "sentence_lengths", ".", "tolist", "(", ")", "==", "[", "len", "(", "entry", "[", "\"sentence\"", "]", ")", "for", "entry", "in", "metadata", "]", "\n", "\n", "# Convert metadata back to form used for coref evaluation", "\n", "evaluation_metadata", "=", "self", ".", "model", ".", "_coref", ".", "_make_evaluation_metadata", "(", "metadata", ",", "sentence_lengths", ")", "\n", "clusters_metadata", "=", "evaluation_metadata", "[", "0", "]", "[", "\"clusters\"", "]", "\n", "# Convert from tuples to list to facilitate comparison.", "\n", "clusters_metadata", "=", "[", "[", "list", "(", "span", ")", "for", "span", "in", "cluster", "]", "for", "cluster", "in", "clusters_metadata", "]", "\n", "\n", "# Get the raw data, and sort to match the metadata.", "\n", "clusters_raw", "=", "self", ".", "get_raw_data", "(", ")", "[", "0", "]", "[", "\"clusters\"", "]", "\n", "clusters_raw", "=", "sorted", "(", "clusters_raw", ",", "key", "=", "lambda", "entry", ":", "entry", "[", "0", "]", "[", "0", "]", ")", "\n", "\n", "# Compare the raw data to the converted metadata I have.", "\n", "assert", "clusters_metadata", "==", "clusters_raw", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.setUp": [[17, 22], ["super().setUp", "relation_test.TestRelation.set_up_model"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", "TestRelation", ",", "self", ")", ".", "setUp", "(", ")", "\n", "self", ".", "config_file", "=", "\"tests/fixtures/dygie_test.jsonnet\"", "\n", "self", ".", "data_file", "=", "\"tests/fixtures/scierc_article.json\"", "\n", "self", ".", "set_up_model", "(", "self", ".", "config_file", ",", "self", ".", "data_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.test_decode": [[23, 50], ["torch.tensor", "torch.tensor", "torch.tensor", "relation_test.TestRelation.model._relation.decode", "relation_test.TestRelation.model.vocab.get_token_from_index", "relation_test.TestRelation.test_decode.convert"], "methods", ["None"], ["", "def", "test_decode", "(", "self", ")", ":", "\n", "        ", "def", "convert", "(", "x", ")", ":", "\n", "            ", "return", "self", ".", "model", ".", "vocab", ".", "get_token_from_index", "(", "x", ",", "namespace", "=", "\"relation_labels\"", ")", "\n", "\n", "", "top_spans", "=", "torch", ".", "tensor", "(", "[", "[", "[", "0", ",", "2", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "3", "]", "]", ",", "\n", "[", "[", "1", ",", "6", "]", ",", "[", "2", ",", "4", "]", ",", "[", "3", ",", "8", "]", "]", ",", "\n", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", "]", "]", ")", "\n", "predicted_relations", "=", "torch", ".", "tensor", "(", "[", "[", "[", "-", "1", ",", "-", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "-", "1", ",", "0", ",", "-", "1", "]", "]", ",", "\n", "[", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "1", ",", "-", "1", ",", "2", "]", ",", "\n", "[", "-", "1", ",", "-", "1", ",", "4", "]", "]", ",", "\n", "[", "[", "1", ",", "1", ",", "2", "]", ",", "\n", "[", "1", ",", "3", ",", "2", "]", ",", "\n", "[", "-", "1", ",", "2", ",", "1", "]", "]", "]", ")", "\n", "num_spans_to_keep", "=", "torch", ".", "tensor", "(", "[", "2", ",", "3", ",", "0", "]", ")", "\n", "predict_dict", "=", "{", "\"top_spans\"", ":", "top_spans", ",", "\n", "\"predicted_relations\"", ":", "predicted_relations", ",", "\n", "\"num_spans_to_keep\"", ":", "num_spans_to_keep", "}", "\n", "decoded", "=", "self", ".", "model", ".", "_relation", ".", "decode", "(", "predict_dict", ")", "\n", "expected", "=", "[", "{", "(", "(", "1", ",", "3", ")", ",", "(", "0", ",", "2", ")", ")", ":", "convert", "(", "1", ")", "}", ",", "\n", "{", "(", "(", "2", ",", "4", ")", ",", "(", "1", ",", "6", ")", ")", ":", "convert", "(", "1", ")", ",", "\n", "(", "(", "2", ",", "4", ")", ",", "(", "3", ",", "8", ")", ")", ":", "convert", "(", "2", ")", ",", "\n", "(", "(", "3", ",", "8", ")", ",", "(", "3", ",", "8", ")", ")", ":", "convert", "(", "4", ")", "}", ",", "\n", "{", "}", "]", "\n", "assert", "expected", "==", "decoded", "[", "\"decoded_relations_dict\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.test_compute_span_pair_embeddings": [[51, 65], ["torch.randn", "relation_test.TestRelation.model._relation._compute_span_pair_embeddings", "torch.cat", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.coref.CorefResolver._compute_span_pair_embeddings"], ["", "def", "test_compute_span_pair_embeddings", "(", "self", ")", ":", "\n", "        ", "top_span_embeddings", "=", "torch", ".", "randn", "(", "[", "3", ",", "51", ",", "1160", "]", ")", "# Make up random embeddings.", "\n", "\n", "embeddings", "=", "self", ".", "model", ".", "_relation", ".", "_compute_span_pair_embeddings", "(", "top_span_embeddings", ")", "\n", "\n", "batch_ix", "=", "1", "\n", "ix1", "=", "22", "\n", "ix2", "=", "43", "\n", "emb1", "=", "top_span_embeddings", "[", "batch_ix", ",", "ix1", "]", "\n", "emb2", "=", "top_span_embeddings", "[", "batch_ix", ",", "ix2", "]", "\n", "emb_prod", "=", "emb1", "*", "emb2", "\n", "emb", "=", "torch", ".", "cat", "(", "[", "emb1", ",", "emb2", ",", "emb_prod", "]", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "emb", ",", "embeddings", "[", "batch_ix", ",", "ix1", ",", "ix2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.test_compute_relation_scores": [[66, 84], ["relation_test.TestRelation.model.eval", "torch.randn", "torch.randn", "relation._compute_relation_scores", "relation._relation_scorer", "torch.cat", "torch.allclose", "relation._relation_feedforward", "pairwise_embeddings[].unsqueeze", "torch.tensor", "torch.cat.squeeze"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._compute_relation_scores"], ["", "def", "test_compute_relation_scores", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "# Need eval on in order to reproduce.", "\n", "relation", "=", "self", ".", "model", ".", "_relation", "\n", "pairwise_embeddings", "=", "torch", ".", "randn", "(", "3", ",", "46", ",", "46", ",", "3480", ",", "requires_grad", "=", "True", ")", "\n", "top_span_mention_scores", "=", "torch", ".", "randn", "(", "3", ",", "46", ",", "1", ",", "requires_grad", "=", "True", ")", "\n", "\n", "scores", "=", "relation", ".", "_compute_relation_scores", "(", "pairwise_embeddings", ",", "top_span_mention_scores", ")", "\n", "\n", "batch_ix", "=", "0", "\n", "ix1", "=", "31", "\n", "ix2", "=", "4", "\n", "\n", "score", "=", "relation", ".", "_relation_scorer", "(", "\n", "relation", ".", "_relation_feedforward", "(", "pairwise_embeddings", "[", "batch_ix", ",", "ix1", ",", "ix2", "]", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "score", "+=", "top_span_mention_scores", "[", "batch_ix", ",", "ix1", "]", "+", "top_span_mention_scores", "[", "batch_ix", ",", "ix2", "]", "\n", "score", "=", "torch", ".", "cat", "(", "[", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ",", "score", ".", "squeeze", "(", ")", "]", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "scores", "[", "batch_ix", ",", "ix1", ",", "ix2", "]", ",", "score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.test_get_pruned_gold_relations": [[85, 112], ["torch.tensor", "torch.tensor", "torch.tensor().unsqueeze", "relation_test.TestRelation.model._relation._get_pruned_gold_relations", "torch.tensor", "torch.equal", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_pruned_gold_relations"], ["", "def", "test_get_pruned_gold_relations", "(", "self", ")", ":", "\n", "# Getting the pruned gold labels should add one to the input relation labels, then set all", "\n", "# the masked entries to -1.", "\n", "        ", "relation_labels", "=", "torch", ".", "tensor", "(", "[", "[", "[", "-", "1", ",", "-", "1", ",", "2", ",", "3", "]", ",", "\n", "[", "1", ",", "-", "1", ",", "-", "1", ",", "0", "]", ",", "\n", "[", "-", "1", ",", "3", ",", "-", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", ",", "\n", "[", "[", "0", ",", "2", ",", "1", ",", "2", "]", ",", "\n", "[", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "3", ",", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "-", "1", ",", "0", ",", "1", ",", "-", "1", "]", "]", "]", ")", "\n", "top_span_indices", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "3", "]", ",", "\n", "[", "0", ",", "2", ",", "2", "]", "]", ")", "\n", "top_span_masks", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", "]", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "labels", "=", "self", ".", "model", ".", "_relation", ".", "_get_pruned_gold_relations", "(", "\n", "relation_labels", ",", "top_span_indices", ",", "top_span_masks", ")", "\n", "\n", "expected_labels", "=", "torch", ".", "tensor", "(", "[", "[", "[", "0", ",", "0", ",", "4", "]", ",", "\n", "[", "2", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", "]", ",", "\n", "[", "[", "1", ",", "2", ",", "-", "1", "]", ",", "\n", "[", "4", ",", "0", ",", "-", "1", "]", ",", "\n", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", ")", "\n", "\n", "assert", "torch", ".", "equal", "(", "labels", ",", "expected_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.relation_test.TestRelation.test_cross_entropy_ignore_index": [[113, 137], ["torch.randn", "torch.tensor", "torch.tensor", "relation_test.TestRelation.model._relation._get_cross_entropy_loss", "torch.allclose", "range", "range", "relation_scores[].unsqueeze", "gold_relations[].unsqueeze", "relation_test.TestRelation.model._relation._loss"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.relation.RelationExtractor._get_cross_entropy_loss"], ["", "def", "test_cross_entropy_ignore_index", "(", "self", ")", ":", "\n", "# Make sure that the cross entropy loss is ignoring entries whose gold label is -1, which", "\n", "# corresponds, to masked-out entries.", "\n", "        ", "relation_scores", "=", "torch", ".", "randn", "(", "2", ",", "3", ",", "3", ",", "self", ".", "model", ".", "_relation", ".", "_n_labels", "+", "1", ")", "\n", "gold_relations", "=", "torch", ".", "tensor", "(", "[", "[", "[", "0", ",", "0", ",", "4", "]", ",", "\n", "[", "2", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", "]", ",", "\n", "[", "[", "1", ",", "2", ",", "-", "1", "]", ",", "\n", "[", "4", ",", "0", ",", "-", "1", "]", ",", "\n", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", ")", "\n", "\n", "# Calculate the loss with a loop over entries.", "\n", "total_loss", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", "\n", "for", "fold", "in", "[", "0", ",", "1", "]", ":", "\n", "            ", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                    ", "scores_entry", "=", "relation_scores", "[", "fold", ",", "i", ",", "j", "]", ".", "unsqueeze", "(", "0", ")", "\n", "gold_entry", "=", "gold_relations", "[", "fold", ",", "i", ",", "j", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "gold_entry", ">=", "0", ":", "\n", "                        ", "loss_entry", "=", "self", ".", "model", ".", "_relation", ".", "_loss", "(", "scores_entry", ",", "gold_entry", ")", "\n", "total_loss", "+=", "loss_entry", "\n", "\n", "", "", "", "", "model_loss", "=", "self", ".", "model", ".", "_relation", ".", "_get_cross_entropy_loss", "(", "relation_scores", ",", "gold_relations", ")", "\n", "assert", "torch", ".", "allclose", "(", "total_loss", ",", "model_loss", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.__init__": [[59, 93], ["allennlp.models.model.Model.__init__", "vocab.get_vocab_size", "vocab.get_vocab_size", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.Dropout", "torch.nn.BCEWithLogitsLoss", "torch.nn.CrossEntropyLoss", "list", "list.remove", "list", "list.remove", "spart.metrics.fbeta_multi.FBetaMultiLabelMeasure", "spart.metrics.fbeta_measure.FBetaMeasure", "vocab.get_index_to_token_vocabulary", "vocab.get_index_to_token_vocabulary"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "text_field_embedder", ":", "TextFieldEmbedder", ",", "\n", "hidden_size", ":", "int", "=", "768", ",", "\n", "size_embedding", ":", "int", "=", "25", ",", "\n", "dropout", ":", "float", "=", "0.1", ",", "\n", "rel_filter_threshold", ":", "float", "=", "0.5", ",", "\n", "max_pairs", ":", "int", "=", "1000", ")", "->", "None", ":", "\n", "        ", "super", "(", "Spart", ",", "self", ")", ".", "__init__", "(", "vocab", ")", "\n", "\n", "self", ".", "_text_field_embedder", "=", "text_field_embedder", "\n", "\n", "self", ".", "_rel_filter_threshold", "=", "rel_filter_threshold", "\n", "self", ".", "_relation_types", "=", "vocab", ".", "get_vocab_size", "(", "\"rel_labels\"", ")", "\n", "self", ".", "_entity_types", "=", "vocab", ".", "get_vocab_size", "(", "\"ner_labels\"", ")", "\n", "self", ".", "_cls_token", "=", "2", "# TODO nur f\u00fcr https://huggingface.co/german-nlp-group/electra-base-german-uncased/blob/main/vocab.txt", "\n", "self", ".", "_max_pairs", "=", "max_pairs", "\n", "self", ".", "_bert", "=", "self", ".", "_text_field_embedder", ".", "token_embedder_tokens", ".", "_modules", "[", "\"_matched_embedder\"", "]", ".", "transformer_model", "\n", "\n", "self", ".", "rel_classifier", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "3", "+", "size_embedding", "*", "2", ",", "self", ".", "_relation_types", ")", "\n", "self", ".", "entity_classifier", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "2", "+", "size_embedding", ",", "self", ".", "_entity_types", ")", "\n", "self", ".", "size_embeddings", "=", "nn", ".", "Embedding", "(", "100", ",", "size_embedding", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "_rel_loss", "=", "nn", ".", "BCEWithLogitsLoss", "(", "reduction", "=", "'none'", ")", "\n", "self", ".", "_ents_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "# TODO BCEWithLogitsLoss", "\n", "\n", "ner_labels", "=", "list", "(", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"ner_labels\"", ")", ")", "\n", "ner_labels", ".", "remove", "(", "0", ")", "\n", "\n", "rel_labels", "=", "list", "(", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"rel_labels\"", ")", ")", "\n", "rel_labels", ".", "remove", "(", "0", ")", "\n", "self", ".", "_f1_relation", "=", "FBetaMultiLabelMeasure", "(", "average", "=", "\"micro\"", ",", "threshold", "=", "self", ".", "_rel_filter_threshold", ")", "\n", "self", ".", "_f1_entities", "=", "FBetaMeasure", "(", "average", "=", "\"micro\"", ",", "labels", "=", "ner_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.forward": [[94, 215], ["spart.Spart._text_field_embedder", "torch.cat", "spart.Spart.size_embeddings", "spart.Spart._classify_entities", "range", "range", "torch.ones", "spart.Spart._filter_spans", "rel_sample_masks.float().unsqueeze.float().unsqueeze.float().unsqueeze", "torch.cat.unsqueeze().repeat", "torch.zeros().to", "torch.cat.unsqueeze().repeat", "torch.zeros().to", "spart.Spart._classify_relations", "torch.sigmoid", "spart.Spart.convert_predictions", "spart.Spart.compute_loss", "spart.Spart._f1_entities", "spart.Spart._f1_relation", "entity_ctx.unsqueeze", "max", "max", "entity_clf[].unsqueeze", "rel_clf[].unsqueeze", "rel_span_indices[].unsqueeze", "spans[].unsqueeze", "entity_sample_masks[].unsqueeze", "sorted", "torch.zeros().to.squeeze", "rel_labels.bool().squeeze", "spart.Spart._bert", "rel_sample_masks.float().unsqueeze.float().unsqueeze.float", "torch.cat.unsqueeze", "min", "torch.zeros", "torch.cat.unsqueeze", "min", "torch.zeros", "spart.Spart._bert", "rel_labels.bool"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._classify_entities", "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._filter_spans", "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._classify_relations", "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.convert_predictions", "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.compute_loss"], ["", "def", "forward", "(", "self", ",", "# type: ignore", "\n", "tokens", ":", "TextFieldTensors", ",", "\n", "spans", ":", "torch", ".", "IntTensor", ",", "\n", "ner_labels", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "rel_span_indices", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "rel_labels", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "span_masks", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "relation_masks", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "rels_sample_masks", ":", "torch", ".", "BoolTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "Dict", "]", ":", "\n", "        ", "embedded_text_input", "=", "self", ".", "_text_field_embedder", "(", "tokens", ")", "\n", "try", ":", "\n", "            ", "entity_ctx", "=", "self", ".", "_bert", "(", "tokens", "[", "\"tokens\"", "]", "[", "\"token_ids\"", "]", ")", ".", "last_hidden_state", "[", ":", ",", "0", ",", ":", "]", "\n", "", "except", "AttributeError", ":", "\n", "            ", "entity_ctx", "=", "self", ".", "_bert", "(", "tokens", "[", "\"tokens\"", "]", "[", "\"token_ids\"", "]", ")", "[", "0", "]", "[", ":", ",", "0", ",", ":", "]", "\n", "", "embedded_text_input", "=", "torch", ".", "cat", "(", "(", "entity_ctx", ".", "unsqueeze", "(", "1", ")", ",", "embedded_text_input", ")", ",", "dim", "=", "1", ")", "\n", "batch_size", "=", "embedded_text_input", ".", "shape", "[", "0", "]", "\n", "\n", "entity_sizes", "=", "spans", "[", ":", ",", ":", ",", "1", "]", "-", "spans", "[", ":", ",", ":", ",", "0", "]", "+", "1", "\n", "\n", "size_embeddings", "=", "self", ".", "size_embeddings", "(", "entity_sizes", ")", "\n", "\n", "entity_clf", ",", "entity_spans_pool", "=", "self", ".", "_classify_entities", "(", "embedded_text_input", ",", "\n", "span_masks", ",", "size_embeddings", ",", "entity_ctx", ")", "\n", "\n", "# TODO If we have no gold entities, we cannot specify relation candidates!", "\n", "# entity_max_logits_index = entity_clf.max(dim=2).indices", "\n", "# relation_candidates = []", "\n", "# relation_masks = []", "\n", "# for batch in range(entity_max_logits_index.shape[0]):", "\n", "#", "\n", "#     entity_indices = entity_max_logits_index[batch].nonzero(as_tuple=True)[0]", "\n", "#", "\n", "#     new_candidates = list(itertools.permutations(entity_indices.tolist(), 2))", "\n", "#", "\n", "#     for nc in new_candidates:", "\n", "#", "\n", "#         start_entity_span = tuple(spans[batch][nc[0]].tolist())", "\n", "#         end_entity_span = tuple(spans[batch][nc[1]].tolist())", "\n", "#", "\n", "#         relation_masks += [create_rel_mask(start_entity_span, end_entity_span, embedded_text_input.shape[1])]", "\n", "#", "\n", "#     relation_candidates += []", "\n", "\n", "#TODO  wir haben zur evaluation KEINE Label, die zu diesen labeln passen, wir m\u00fcssen die von Span Labeling usw. wieder nutzen!", "\n", "# rel_span_indices = torch.tensor(relation_candidates, device=entity_clf.device)", "\n", "\n", "# classify relations", "\n", "if", "rel_labels", "is", "None", ":", "\n", "            ", "ctx_size", "=", "embedded_text_input", ".", "shape", "[", "1", "]", "\n", "\n", "entity_sample_masks", "=", "torch", ".", "ones", "(", "(", "batch_size", ",", "entity_clf", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "rel_span_indices", ",", "relation_masks", ",", "rel_sample_masks", "=", "self", ".", "_filter_spans", "(", "entity_clf", ",", "spans", ",", "entity_sample_masks", ",", "ctx_size", ")", "\n", "\n", "rel_sample_masks", "=", "rel_sample_masks", ".", "float", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "h_large", "=", "embedded_text_input", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "max", "(", "min", "(", "rel_span_indices", ".", "shape", "[", "1", "]", ",", "self", ".", "_max_pairs", ")", ",", "1", ")", ",", "1", ",", "1", ")", "\n", "rel_clf", "=", "torch", ".", "zeros", "(", "[", "batch_size", ",", "rel_span_indices", ".", "shape", "[", "1", "]", ",", "self", ".", "_relation_types", "]", ")", ".", "to", "(", "\n", "self", ".", "rel_classifier", ".", "weight", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "h_large", "=", "embedded_text_input", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "max", "(", "min", "(", "rel_span_indices", ".", "shape", "[", "1", "]", ",", "self", ".", "_max_pairs", ")", ",", "1", ")", ",", "1", ",", "\n", "1", ")", "\n", "rel_clf", "=", "torch", ".", "zeros", "(", "[", "batch_size", ",", "rel_span_indices", ".", "shape", "[", "1", "]", ",", "self", ".", "_relation_types", "]", ")", ".", "to", "(", "\n", "self", ".", "rel_classifier", ".", "weight", ".", "device", ")", "\n", "\n", "# obtain relation logits", "\n", "# chunk processing to reduce memory usage", "\n", "", "for", "i", "in", "range", "(", "0", ",", "rel_span_indices", ".", "shape", "[", "1", "]", ",", "self", ".", "_max_pairs", ")", ":", "\n", "# classify relation candidates", "\n", "            ", "chunk_rel_logits", "=", "self", ".", "_classify_relations", "(", "entity_spans_pool", ",", "size_embeddings", ",", "\n", "rel_span_indices", ",", "relation_masks", ",", "h_large", ",", "i", ")", "\n", "chunk_rel_clf", "=", "torch", ".", "sigmoid", "(", "chunk_rel_logits", ")", "\n", "rel_clf", "[", ":", ",", "i", ":", "i", "+", "self", ".", "_max_pairs", ",", ":", "]", "=", "chunk_rel_clf", "\n", "\n", "", "converted_relations", "=", "[", "]", "\n", "\n", "for", "batch", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "batch_pred_entities", ",", "batch_pred_relations", "=", "self", ".", "convert_predictions", "(", "entity_clf", "[", "batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "rel_clf", "[", "batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "rel_span_indices", "[", "batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "spans", "[", "batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "entity_sample_masks", "[", "batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "_rel_filter_threshold", ",", ")", "\n", "\n", "batch_converted_relations", "=", "[", "]", "\n", "for", "pred_relation", "in", "batch_pred_relations", "[", "0", "]", ":", "\n", "\n", "                ", "h_name", ",", "t_name", "=", "sorted", "(", "relation_args_names", "[", "pred_relation", "[", "2", "]", "]", ")", "\n", "converted_relation", "=", "{", "\n", "\"name\"", ":", "pred_relation", "[", "2", "]", ",", "\n", "\"ents\"", ":", "[", "\n", "{", "\n", "\"name\"", ":", "h_name", ",", "\n", "\"start\"", ":", "pred_relation", "[", "0", "]", "[", "0", "]", ",", "\n", "\"end\"", ":", "pred_relation", "[", "0", "]", "[", "1", "]", ",", "\n", "}", ",", "\n", "{", "\n", "\"name\"", ":", "t_name", ",", "\n", "\"start\"", ":", "pred_relation", "[", "1", "]", "[", "0", "]", ",", "\n", "\"end\"", ":", "pred_relation", "[", "1", "]", "[", "1", "]", ",", "\n", "}", ",", "\n", "]", "\n", "}", "\n", "\n", "batch_converted_relations", "+=", "[", "converted_relation", "]", "\n", "\n", "", "converted_relations", "+=", "[", "batch_converted_relations", "]", "\n", "\n", "", "if", "ner_labels", "and", "rel_labels", ":", "\n", "\n", "            ", "batch_loss", "=", "self", ".", "compute_loss", "(", "entity_logits", "=", "entity_clf", ",", "rel_logits", "=", "rel_clf", ",", "rel_types", "=", "rel_labels", ",", "\n", "entity_types", "=", "ner_labels", ",", "\n", "rel_sample_masks", "=", "rels_sample_masks", ")", "\n", "\n", "self", ".", "_f1_entities", "(", "entity_clf", ",", "ner_labels", ")", "\n", "#self._f1_relation(rel_clf, rel_labels.bool())", "\n", "self", ".", "_f1_relation", "(", "rel_clf", ".", "squeeze", "(", ")", ",", "rel_labels", ".", "bool", "(", ")", ".", "squeeze", "(", ")", ")", "\n", "\n", "return", "{", "\"loss\"", ":", "batch_loss", "}", "\n", "\n", "", "return", "{", "\"relations\"", ":", "converted_relations", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.get_metrics": [[216, 226], ["spart.Spart._f1_entities.get_metric", "spart.Spart._f1_relation.get_metric"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "ent_metrics", "=", "self", ".", "_f1_entities", ".", "get_metric", "(", "reset", "=", "reset", ")", "\n", "rel_metrics", "=", "self", ".", "_f1_relation", ".", "get_metric", "(", "reset", "=", "reset", ")", "\n", "return", "{", "\n", "\"ner_p\"", ":", "ent_metrics", "[", "\"precision\"", "]", ",", "\n", "\"ner_r\"", ":", "ent_metrics", "[", "\"recall\"", "]", ",", "\n", "\"ner_f\"", ":", "ent_metrics", "[", "\"fscore\"", "]", ",", "\n", "\"rel_p\"", ":", "rel_metrics", "[", "\"precision\"", "]", ",", "\n", "\"rel_r\"", ":", "rel_metrics", "[", "\"recall\"", "]", ",", "\n", "\"rel_f\"", ":", "rel_metrics", "[", "\"fscore\"", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.convert_predictions": [[228, 266], ["batch_entity_clf.argmax", "span_masks.long", "range", "spart.Spart._convert_pred_entities", "spart.Spart._convert_pred_relations", "batch_pred_entities.append", "batch_pred_relations.append"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._convert_pred_entities", "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._convert_pred_relations"], ["", "def", "convert_predictions", "(", "self", ",", "batch_entity_clf", ":", "torch", ".", "tensor", ",", "batch_rel_clf", ":", "torch", ".", "tensor", ",", "\n", "batch_rels", ":", "torch", ".", "tensor", ",", "spans", ",", "span_masks", ",", "rel_filter_threshold", ":", "float", ",", "\n", "no_overlapping", ":", "bool", "=", "False", ")", ":", "\n", "# get maximum activation (index of predicted entity type)", "\n", "        ", "batch_entity_types", "=", "batch_entity_clf", ".", "argmax", "(", "dim", "=", "-", "1", ")", "\n", "# apply entity sample mask", "\n", "batch_entity_types", "*=", "span_masks", ".", "long", "(", ")", "\n", "\n", "# apply threshold to relations", "\n", "batch_rel_clf", "[", "batch_rel_clf", "<", "rel_filter_threshold", "]", "=", "0", "\n", "\n", "batch_pred_entities", "=", "[", "]", "\n", "batch_pred_relations", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_rel_clf", ".", "shape", "[", "0", "]", ")", ":", "\n", "# get model predictions for sample", "\n", "            ", "entity_types", "=", "batch_entity_types", "[", "i", "]", "\n", "entity_spans", "=", "spans", "[", "i", "]", "\n", "entity_clf", "=", "batch_entity_clf", "[", "i", "]", "\n", "rel_clf", "=", "batch_rel_clf", "[", "i", "]", "\n", "rels", "=", "batch_rels", "[", "i", "]", "\n", "\n", "# convert predicted entities", "\n", "sample_pred_entities", "=", "self", ".", "_convert_pred_entities", "(", "entity_types", ",", "entity_spans", ",", "\n", "entity_clf", ")", "\n", "\n", "# convert predicted relations", "\n", "sample_pred_relations", "=", "self", ".", "_convert_pred_relations", "(", "rel_clf", ",", "rels", ",", "\n", "entity_types", ",", "entity_spans", ")", "\n", "\n", "# if no_overlapping:", "\n", "#     sample_pred_entities, sample_pred_relations = remove_overlapping(sample_pred_entities,", "\n", "#                                                                      sample_pred_relations)", "\n", "\n", "batch_pred_entities", ".", "append", "(", "sample_pred_entities", ")", "\n", "batch_pred_relations", ".", "append", "(", "sample_pred_relations", ")", "\n", "\n", "", "return", "batch_pred_entities", ",", "batch_pred_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart.compute_loss": [[267, 296], ["entity_logits.view.view.view", "entity_types.view.view.view", "entity_sample_masks.view().float.view().float.view().float", "spart.Spart._ents_loss", "rel_sample_masks.view().float.view().float.view().float", "rel_sample_masks.view().float.view().float.sum", "entity_sample_masks.view().float.view().float.sum", "rel_sample_masks.view().float.sum.item", "rel_logits.view.view.view", "rel_types.view.view.view", "spart.Spart._rel_loss", "entity_sample_masks.view().float.view().float.view", "rel_sample_masks.view().float.view().float.view", "rel_types.view.view.float", "spart.Spart.sum"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "entity_logits", ",", "rel_logits", ",", "rel_sample_masks", ",", "entity_types", ",", "rel_types", ")", ":", "\n", "        ", "entity_sample_masks", "=", "entity_types", "!=", "-", "1", "\n", "entity_types", "[", "entity_types", "==", "-", "1", "]", "=", "0", "\n", "entity_logits", "=", "entity_logits", ".", "view", "(", "-", "1", ",", "entity_logits", ".", "shape", "[", "-", "1", "]", ")", "\n", "entity_types", "=", "entity_types", ".", "view", "(", "-", "1", ")", "\n", "entity_sample_masks", "=", "entity_sample_masks", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", "\n", "\n", "entity_loss", "=", "self", ".", "_ents_loss", "(", "entity_logits", ",", "entity_types", ")", "\n", "entity_loss", "=", "(", "entity_loss", "*", "entity_sample_masks", ")", ".", "sum", "(", ")", "/", "entity_sample_masks", ".", "sum", "(", ")", "\n", "\n", "# relation loss", "\n", "#rel_sample_masks = rel_types != -1", "\n", "#rel_types[rel_types == -1] = 0", "\n", "rel_sample_masks", "=", "rel_sample_masks", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", "\n", "rel_count", "=", "rel_sample_masks", ".", "sum", "(", ")", "\n", "\n", "if", "rel_count", ".", "item", "(", ")", "!=", "0", ":", "\n", "            ", "rel_logits", "=", "rel_logits", ".", "view", "(", "-", "1", ",", "rel_logits", ".", "shape", "[", "-", "1", "]", ")", "\n", "rel_types", "=", "rel_types", ".", "view", "(", "-", "1", ",", "rel_types", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "rel_loss", "=", "self", ".", "_rel_loss", "(", "rel_logits", ",", "rel_types", ".", "float", "(", ")", ")", "\n", "rel_loss", "=", "rel_loss", ".", "sum", "(", "-", "1", ")", "/", "rel_loss", ".", "shape", "[", "-", "1", "]", "\n", "rel_loss", "=", "(", "rel_loss", "*", "rel_sample_masks", ")", ".", "sum", "(", ")", "/", "rel_count", "\n", "\n", "# joint loss", "\n", "return", "entity_loss", "+", "rel_loss", "\n", "", "else", ":", "\n", "# corner case: no positive/negative relation samples", "\n", "            ", "return", "entity_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._classify_entities": [[297, 312], ["torch.cat", "spart.Spart.dropout", "spart.Spart.entity_classifier", "h.unsqueeze().repeat", "entity_spans_pool.max", "entity_ctx.unsqueeze().repeat", "h.unsqueeze", "entity_masks.unsqueeze", "entity_ctx.unsqueeze"], "methods", ["None"], ["", "", "def", "_classify_entities", "(", "self", ",", "h", ",", "entity_masks", ",", "size_embeddings", ",", "entity_ctx", ")", ":", "\n", "# max pool entity candidate spans", "\n", "        ", "m", "=", "(", "entity_masks", ".", "unsqueeze", "(", "-", "1", ")", "==", "0", ")", ".", "float", "(", ")", "*", "(", "-", "1e30", ")", "\n", "entity_spans_pool", "=", "m", "+", "h", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "entity_masks", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ")", "\n", "entity_spans_pool", "=", "entity_spans_pool", ".", "max", "(", "dim", "=", "2", ")", "[", "0", "]", "\n", "\n", "# create candidate representations including context, max pooled span and size embedding", "\n", "entity_repr", "=", "torch", ".", "cat", "(", "[", "entity_ctx", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "entity_spans_pool", ".", "shape", "[", "1", "]", ",", "1", ")", ",", "\n", "entity_spans_pool", ",", "size_embeddings", "]", ",", "dim", "=", "2", ")", "\n", "entity_repr", "=", "self", ".", "dropout", "(", "entity_repr", ")", "\n", "\n", "# classify entity candidates", "\n", "entity_clf", "=", "self", ".", "entity_classifier", "(", "entity_repr", ")", "\n", "\n", "return", "entity_clf", ",", "entity_spans_pool", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._classify_relations": [[314, 348], ["spart.batch_index", "entity_pairs.view.view.view", "spart.batch_index", "size_pair_embeddings.view.view.view", "torch.cat", "spart.Spart.dropout", "spart.Spart.rel_classifier", "rel_ctx.max", "rel_masks.to().any", "rel_masks.to"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.batch_index", "home.repos.pwc.inspect_result.mslars_mare.models.spart.batch_index"], ["", "def", "_classify_relations", "(", "self", ",", "entity_spans", ",", "size_embeddings", ",", "relations", ",", "rel_masks", ",", "h", ",", "chunk_start", ")", ":", "\n", "        ", "batch_size", "=", "relations", ".", "shape", "[", "0", "]", "\n", "\n", "# create chunks if necessary", "\n", "if", "relations", ".", "shape", "[", "1", "]", ">", "self", ".", "_max_pairs", ":", "\n", "            ", "relations", "=", "relations", "[", ":", ",", "chunk_start", ":", "chunk_start", "+", "self", ".", "_max_pairs", "]", "\n", "rel_masks", "=", "rel_masks", "[", ":", ",", "chunk_start", ":", "chunk_start", "+", "self", ".", "_max_pairs", "]", "\n", "h", "=", "h", "[", ":", ",", ":", "relations", ".", "shape", "[", "1", "]", ",", ":", "]", "\n", "\n", "# get pairs of entity candidate representations", "\n", "", "entity_pairs", "=", "batch_index", "(", "entity_spans", ",", "relations", ")", "\n", "entity_pairs", "=", "entity_pairs", ".", "view", "(", "batch_size", ",", "entity_pairs", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "\n", "# get corresponding size embeddings", "\n", "size_pair_embeddings", "=", "batch_index", "(", "size_embeddings", ",", "relations", ")", "\n", "size_pair_embeddings", "=", "size_pair_embeddings", ".", "view", "(", "batch_size", ",", "size_pair_embeddings", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "\n", "# relation context (context between entity candidate pair)", "\n", "# mask non entity candidate tokens", "\n", "m", "=", "(", "(", "rel_masks", "==", "0", ")", ".", "float", "(", ")", "*", "(", "-", "1e30", ")", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "rel_ctx", "=", "m", "+", "h", "\n", "# max pooling", "\n", "rel_ctx", "=", "rel_ctx", ".", "max", "(", "dim", "=", "2", ")", "[", "0", "]", "\n", "# set the context vector of neighboring or adjacent entity candidates to zero", "\n", "rel_ctx", "[", "rel_masks", ".", "to", "(", "torch", ".", "uint8", ")", ".", "any", "(", "-", "1", ")", "==", "0", "]", "=", "0", "\n", "\n", "# create relation candidate representations including context, max pooled entity candidate pairs", "\n", "# and corresponding size embeddings", "\n", "rel_repr", "=", "torch", ".", "cat", "(", "[", "rel_ctx", ",", "entity_pairs", ",", "size_pair_embeddings", "]", ",", "dim", "=", "2", ")", "\n", "rel_repr", "=", "self", ".", "dropout", "(", "rel_repr", ")", "\n", "\n", "# classify relation candidates", "\n", "chunk_rel_logits", "=", "self", ".", "rel_classifier", "(", "rel_repr", ")", "\n", "return", "chunk_rel_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._filter_spans": [[349, 392], ["range", "padded_stack().to", "padded_stack().to", "padded_stack().to", "entity_clf.argmax", "entity_sample_masks.long", "[].tolist", "non_zero_indices.tolist.tolist.tolist", "zip", "zip", "padded_stack().to.append", "padded_stack().to.append", "padded_stack().to.append", "padded_stack().to.append", "padded_stack().to.append", "padded_stack().to.append", "spart.padded_stack", "spart.padded_stack", "spart.padded_stack", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.stack", "torch.tensor", "rels.append", "rel_masks.append", "sample_masks.append", "torch.tensor", "spart.data.dataset_readers.spart_reader.create_rel_mask"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.padded_stack", "home.repos.pwc.inspect_result.mslars_mare.models.spart.padded_stack", "home.repos.pwc.inspect_result.mslars_mare.models.spart.padded_stack", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_rel_mask"], ["", "def", "_filter_spans", "(", "self", ",", "entity_clf", ",", "entity_spans", ",", "entity_sample_masks", ",", "ctx_size", ")", ":", "\n", "        ", "batch_size", "=", "entity_clf", ".", "shape", "[", "0", "]", "\n", "entity_logits_max", "=", "entity_clf", ".", "argmax", "(", "dim", "=", "-", "1", ")", "*", "entity_sample_masks", ".", "long", "(", ")", "# get entity type (including none)", "\n", "batch_relations", "=", "[", "]", "\n", "batch_rel_masks", "=", "[", "]", "\n", "batch_rel_sample_masks", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "rels", "=", "[", "]", "\n", "rel_masks", "=", "[", "]", "\n", "sample_masks", "=", "[", "]", "\n", "\n", "# get spans classified as entities", "\n", "non_zero_indices", "=", "(", "entity_logits_max", "[", "i", "]", "!=", "0", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "non_zero_spans", "=", "entity_spans", "[", "i", "]", "[", "non_zero_indices", "]", ".", "tolist", "(", ")", "\n", "non_zero_indices", "=", "non_zero_indices", ".", "tolist", "(", ")", "\n", "\n", "# create relations and masks", "\n", "for", "i1", ",", "s1", "in", "zip", "(", "non_zero_indices", ",", "non_zero_spans", ")", ":", "\n", "                ", "for", "i2", ",", "s2", "in", "zip", "(", "non_zero_indices", ",", "non_zero_spans", ")", ":", "\n", "                    ", "if", "i1", "!=", "i2", ":", "\n", "                        ", "rels", ".", "append", "(", "(", "i1", ",", "i2", ")", ")", "\n", "rel_masks", ".", "append", "(", "torch", ".", "tensor", "(", "spart_reader", ".", "create_rel_mask", "(", "s1", ",", "s2", ",", "ctx_size", ")", ")", ")", "\n", "sample_masks", ".", "append", "(", "1", ")", "\n", "\n", "", "", "", "if", "not", "rels", ":", "\n", "# case: no more than two spans classified as entities", "\n", "                ", "batch_relations", ".", "append", "(", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "batch_rel_masks", ".", "append", "(", "torch", ".", "tensor", "(", "[", "[", "0", "]", "*", "ctx_size", "]", ",", "dtype", "=", "torch", ".", "bool", ")", ")", "\n", "batch_rel_sample_masks", ".", "append", "(", "torch", ".", "tensor", "(", "[", "0", "]", ",", "dtype", "=", "torch", ".", "bool", ")", ")", "\n", "", "else", ":", "\n", "# case: more than two spans classified as entities", "\n", "                ", "batch_relations", ".", "append", "(", "torch", ".", "tensor", "(", "rels", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "batch_rel_masks", ".", "append", "(", "torch", ".", "stack", "(", "rel_masks", ")", ")", "\n", "batch_rel_sample_masks", ".", "append", "(", "torch", ".", "tensor", "(", "sample_masks", ",", "dtype", "=", "torch", ".", "bool", ")", ")", "\n", "\n", "# stack", "\n", "", "", "device", "=", "self", ".", "rel_classifier", ".", "weight", ".", "device", "\n", "batch_relations", "=", "padded_stack", "(", "batch_relations", ")", ".", "to", "(", "device", ")", "\n", "batch_rel_masks", "=", "padded_stack", "(", "batch_rel_masks", ")", ".", "to", "(", "device", ")", "\n", "batch_rel_sample_masks", "=", "padded_stack", "(", "batch_rel_sample_masks", ")", ".", "to", "(", "device", ")", "\n", "\n", "return", "batch_relations", ",", "batch_rel_masks", ",", "batch_rel_sample_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._convert_pred_entities": [[393, 420], ["entity_types.nonzero().view", "torch.gather().view", "range", "entity_types.nonzero().view.tolist", "pred_entity_types[].item", "pred_entity_spans[].tolist", "pred_entity_scores[].item", "converted_preds.append", "entity_types.nonzero", "torch.gather", "spart.Spart.vocab.get_index_to_token_vocabulary", "pred_entity_types.unsqueeze"], "methods", ["None"], ["", "def", "_convert_pred_entities", "(", "self", ",", "entity_types", ":", "torch", ".", "tensor", ",", "entity_spans", ":", "torch", ".", "tensor", ",", "\n", "entity_scores", ":", "torch", ".", "tensor", ")", ":", "\n", "\n", "# get entities that are not classified as 'None'", "\n", "        ", "valid_entity_indices", "=", "entity_types", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "if", "not", "valid_entity_indices", ".", "tolist", "(", ")", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "pred_entity_types", "=", "entity_types", "[", "valid_entity_indices", "]", "\n", "pred_entity_spans", "=", "entity_spans", "[", "valid_entity_indices", "]", "\n", "pred_entity_scores", "=", "torch", ".", "gather", "(", "entity_scores", "[", "valid_entity_indices", "]", ",", "1", ",", "\n", "pred_entity_types", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "# convert to tuples (start, end, type, score)", "\n", "converted_preds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "pred_entity_types", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "label_idx", "=", "pred_entity_types", "[", "i", "]", ".", "item", "(", ")", "\n", "entity_type", "=", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"ner_labels\"", ")", "[", "label_idx", "]", "\n", "\n", "start", ",", "end", "=", "pred_entity_spans", "[", "i", "]", ".", "tolist", "(", ")", "\n", "score", "=", "pred_entity_scores", "[", "i", "]", ".", "item", "(", ")", "\n", "\n", "converted_pred", "=", "(", "start", ",", "end", ",", "entity_type", ",", "score", ")", "\n", "converted_preds", ".", "append", "(", "converted_pred", ")", "\n", "\n", "", "return", "converted_preds", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.Spart._convert_pred_relations": [[421, 468], ["rel_clf.view.view.view", "rel_clf.view.view.nonzero().view", "entity_spans[].long", "torch.zeros", "set", "range", "torch.stack", "pred_rel_types[].item", "pred_rel_scores[].item", "spans[].tolist", "spans[].tolist", "spart._adjust_rel", "rel_clf.view.view.nonzero", "spart.Spart.vocab.get_index_to_token_vocabulary", "[].item", "[].item", "spart.Spart.vocab.get_index_to_token_vocabulary", "spart.Spart.vocab.get_index_to_token_vocabulary", "set.add", "converted_rels.append", "tuple", "range", "list"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.spart._adjust_rel"], ["", "def", "_convert_pred_relations", "(", "self", ",", "rel_clf", ":", "torch", ".", "tensor", ",", "rels", ":", "torch", ".", "tensor", ",", "\n", "entity_types", ":", "torch", ".", "tensor", ",", "entity_spans", ":", "torch", ".", "tensor", ")", ":", "\n", "        ", "rel_class_count", "=", "rel_clf", ".", "shape", "[", "1", "]", "\n", "rel_clf", "=", "rel_clf", ".", "view", "(", "-", "1", ")", "\n", "\n", "# get predicted relation labels and corresponding entity pairs", "\n", "rel_nonzero", "=", "rel_clf", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "pred_rel_scores", "=", "rel_clf", "[", "rel_nonzero", "]", "\n", "\n", "pred_rel_types", "=", "(", "rel_nonzero", "%", "rel_class_count", ")", "+", "1", "# model does not predict None class (+1)", "\n", "valid_rel_indices", "=", "rel_nonzero", "//", "rel_class_count", "\n", "valid_rels", "=", "rels", "[", "valid_rel_indices", "]", "\n", "\n", "# get masks of entities in relation", "\n", "pred_rel_entity_spans", "=", "entity_spans", "[", "valid_rels", "]", ".", "long", "(", ")", "\n", "\n", "# get predicted entity types", "\n", "pred_rel_entity_types", "=", "torch", ".", "zeros", "(", "[", "valid_rels", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "if", "valid_rels", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "pred_rel_entity_types", "=", "torch", ".", "stack", "(", "[", "entity_types", "[", "valid_rels", "[", "j", "]", "]", "for", "j", "in", "range", "(", "valid_rels", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n", "# convert to tuples ((head start, head end, head type), (tail start, tail end, tail type), rel type, score))", "\n", "", "converted_rels", "=", "[", "]", "\n", "check", "=", "set", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "pred_rel_types", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "label_idx", "=", "pred_rel_types", "[", "i", "]", ".", "item", "(", ")", "\n", "pred_rel_type", "=", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"rel_labels\"", ")", "[", "label_idx", "-", "1", "]", "\n", "pred_head_type_idx", ",", "pred_tail_type_idx", "=", "pred_rel_entity_types", "[", "i", "]", "[", "0", "]", ".", "item", "(", ")", ",", "pred_rel_entity_types", "[", "i", "]", "[", "\n", "1", "]", ".", "item", "(", ")", "\n", "pred_head_type", "=", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"ner_labels\"", ")", "[", "pred_head_type_idx", "]", "\n", "pred_tail_type", "=", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "\"ner_labels\"", ")", "[", "pred_tail_type_idx", "]", "\n", "score", "=", "pred_rel_scores", "[", "i", "]", ".", "item", "(", ")", "\n", "\n", "spans", "=", "pred_rel_entity_spans", "[", "i", "]", "\n", "head_start", ",", "head_end", "=", "spans", "[", "0", "]", ".", "tolist", "(", ")", "\n", "tail_start", ",", "tail_end", "=", "spans", "[", "1", "]", ".", "tolist", "(", ")", "\n", "\n", "converted_rel", "=", "(", "(", "head_start", ",", "head_end", ",", "pred_head_type", ")", ",", "\n", "(", "tail_start", ",", "tail_end", ",", "pred_tail_type", ")", ",", "pred_rel_type", ")", "\n", "converted_rel", "=", "_adjust_rel", "(", "converted_rel", ")", "\n", "\n", "if", "converted_rel", "not", "in", "check", ":", "\n", "                ", "check", ".", "add", "(", "converted_rel", ")", "\n", "converted_rels", ".", "append", "(", "tuple", "(", "list", "(", "converted_rel", ")", "+", "[", "score", "]", ")", ")", "\n", "\n", "", "", "return", "converted_rels", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.batch_index": [[14, 22], ["Exception", "torch.stack", "spart.padded_stack", "range", "range"], "function", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.padded_stack"], ["def", "batch_index", "(", "tensor", ",", "index", ",", "pad", "=", "False", ")", ":", "\n", "    ", "if", "tensor", ".", "shape", "[", "0", "]", "!=", "index", ".", "shape", "[", "0", "]", ":", "\n", "        ", "raise", "Exception", "(", ")", "\n", "\n", "", "if", "not", "pad", ":", "\n", "        ", "return", "torch", ".", "stack", "(", "[", "tensor", "[", "i", "]", "[", "index", "[", "i", "]", "]", "for", "i", "in", "range", "(", "index", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "padded_stack", "(", "[", "tensor", "[", "i", "]", "[", "index", "[", "i", "]", "]", "for", "i", "in", "range", "(", "index", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.padded_stack": [[24, 36], ["len", "torch.stack", "max", "spart.extend_tensor", "padded_tensors.append", "range"], "function", ["home.repos.pwc.inspect_result.mslars_mare.models.spart.extend_tensor"], ["", "", "def", "padded_stack", "(", "tensors", ",", "padding", "=", "0", ")", ":", "\n", "    ", "dim_count", "=", "len", "(", "tensors", "[", "0", "]", ".", "shape", ")", "\n", "\n", "max_shape", "=", "[", "max", "(", "[", "t", ".", "shape", "[", "d", "]", "for", "t", "in", "tensors", "]", ")", "for", "d", "in", "range", "(", "dim_count", ")", "]", "\n", "padded_tensors", "=", "[", "]", "\n", "\n", "for", "t", "in", "tensors", ":", "\n", "        ", "e", "=", "extend_tensor", "(", "t", ",", "max_shape", ",", "fill", "=", "padding", ")", "\n", "padded_tensors", ".", "append", "(", "e", ")", "\n", "\n", "", "stacked", "=", "torch", ".", "stack", "(", "padded_tensors", ")", "\n", "return", "stacked", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart.extend_tensor": [[38, 54], ["torch.zeros().to", "extended_tensor.fill_.fill_", "len", "torch.zeros", "len", "len", "len"], "function", ["None"], ["", "def", "extend_tensor", "(", "tensor", ",", "extended_shape", ",", "fill", "=", "0", ")", ":", "\n", "    ", "tensor_shape", "=", "tensor", ".", "shape", "\n", "\n", "extended_tensor", "=", "torch", ".", "zeros", "(", "extended_shape", ",", "dtype", "=", "tensor", ".", "dtype", ")", ".", "to", "(", "tensor", ".", "device", ")", "\n", "extended_tensor", "=", "extended_tensor", ".", "fill_", "(", "fill", ")", "\n", "\n", "if", "len", "(", "tensor_shape", ")", "==", "1", ":", "\n", "        ", "extended_tensor", "[", ":", "tensor_shape", "[", "0", "]", "]", "=", "tensor", "\n", "", "elif", "len", "(", "tensor_shape", ")", "==", "2", ":", "\n", "        ", "extended_tensor", "[", ":", "tensor_shape", "[", "0", "]", ",", ":", "tensor_shape", "[", "1", "]", "]", "=", "tensor", "\n", "", "elif", "len", "(", "tensor_shape", ")", "==", "3", ":", "\n", "        ", "extended_tensor", "[", ":", "tensor_shape", "[", "0", "]", ",", ":", "tensor_shape", "[", "1", "]", ",", ":", "tensor_shape", "[", "2", "]", "]", "=", "tensor", "\n", "", "elif", "len", "(", "tensor_shape", ")", "==", "4", ":", "\n", "        ", "extended_tensor", "[", ":", "tensor_shape", "[", "0", "]", ",", ":", "tensor_shape", "[", "1", "]", ",", ":", "tensor_shape", "[", "2", "]", ",", ":", "tensor_shape", "[", "3", "]", "]", "=", "tensor", "\n", "\n", "", "return", "extended_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.models.spart._adjust_rel": [[470, 480], ["None"], "function", ["None"], ["", "", "def", "_adjust_rel", "(", "rel", ":", "Tuple", ")", ":", "\n", "    ", "adjusted_rel", "=", "rel", "\n", "\n", "#TODO symmertic relastions", "\n", "# if rel[-1].symmetric:", "\n", "#     head, tail = rel[:2]", "\n", "#     if tail[0] < head[0]:", "\n", "#         adjusted_rel = tail, head, rel[-1]", "\n", "\n", "return", "adjusted_rel", "\n", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.setUp": [[33, 38], ["os.makedirs", "os.makedirs"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "collated_dir", "=", "\"tmp/collated\"", "\n", "self", ".", "uncollated_dir", "=", "\"tmp/uncollated\"", "\n", "os", ".", "makedirs", "(", "self", ".", "collated_dir", ",", "exist_ok", "=", "True", ")", "\n", "os", ".", "makedirs", "(", "self", ".", "uncollated_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.tearDown": [[39, 41], ["shutil.rmtree"], "methods", ["None"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "\"tmp\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.is_same": [[42, 56], ["sorted", "sorted", "x1.keys", "x2.keys"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "is_same", "(", "x1", ",", "x2", ")", ":", "\n", "        ", "\"Compare the fields in two dicts loaded from json.\"", "\n", "# Check if keys are same.", "\n", "if", "sorted", "(", "x1", ".", "keys", "(", ")", ")", "!=", "sorted", "(", "x2", ".", "keys", "(", ")", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "# Loop over all fields. If not same, return False.", "\n", "", "for", "key", "in", "x1", ":", "\n", "            ", "if", "x1", "[", "key", "]", "!=", "x2", "[", "key", "]", ":", "\n", "                ", "return", "False", "\n", "\n", "# If we get to the end, they're the same.", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.files_same": [[57, 81], ["collate_test.load_jsonl", "collate_test.load_jsonl", "zip", "len", "len", "collate_test.TestCollate.is_same"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.collate_test.load_jsonl", "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.load_jsonl", "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.is_same"], ["", "def", "files_same", "(", "self", ",", "f1", ",", "f2", ")", ":", "\n", "        ", "\"Check that contests of two files are the same.\"", "\n", "data1", "=", "load_jsonl", "(", "f1", ")", "\n", "data2", "=", "load_jsonl", "(", "f2", ")", "\n", "\n", "# Ignore these in the comparison; `dataset` gets added, while `sentence_start` and", "\n", "# `clusters` get removed.", "\n", "fields_to_ignore", "=", "[", "\"dataset\"", ",", "\"sentence_start\"", ",", "\"clusters\"", "]", "\n", "for", "data", "in", "[", "data1", ",", "data2", "]", ":", "\n", "            ", "for", "entry", "in", "data", ":", "\n", "# Since the input data doesn't have a `dataset` field, we don't want to compare on", "\n", "# this.", "\n", "                ", "for", "field_to_ignore", "in", "fields_to_ignore", ":", "\n", "                    ", "if", "field_to_ignore", "in", "entry", ":", "\n", "                        ", "del", "entry", "[", "field_to_ignore", "]", "\n", "\n", "", "", "", "", "if", "len", "(", "data1", ")", "!=", "len", "(", "data2", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "for", "entry1", ",", "entry2", "in", "zip", "(", "data1", ",", "data2", ")", ":", "\n", "            ", "if", "not", "self", ".", "is_same", "(", "entry1", ",", "entry2", ")", ":", "\n", "                ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.check_collate": [[82, 102], ["collate.get_args", "collate.CollateRunner", "uncollate.get_args", "uncollate.UnCollateRunner", "collate.CollateRunner.run", "uncollate.UnCollateRunner.run", "collate_test.TestCollate.files_same", "vars", "vars"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.files_same"], ["", "def", "check_collate", "(", "self", ",", "dirname", ")", ":", "\n", "        ", "input_dir", "=", "f\"fixtures/collate/{dirname}\"", "\n", "\n", "# Make the collator.", "\n", "collator_args", "=", "collate", ".", "get_args", "(", "[", "input_dir", ",", "self", ".", "collated_dir", ",", "\"--file_extension=json\"", ",", "\n", "f\"--dataset={dirname}\"", "]", ")", "\n", "collator_runner", "=", "collate", ".", "CollateRunner", "(", "**", "vars", "(", "collator_args", ")", ")", "\n", "\n", "# Make the uncollator.", "\n", "uncollator_args", "=", "uncollate", ".", "get_args", "(", "\n", "[", "self", ".", "collated_dir", ",", "self", ".", "uncollated_dir", ",", "f\"--order_like_directory={input_dir}\"", ",", "\n", "\"--file_extension=json\"", "]", ")", "\n", "uncollator_runner", "=", "uncollate", ".", "UnCollateRunner", "(", "**", "vars", "(", "uncollator_args", ")", ")", "\n", "\n", "# Run both.", "\n", "collator_runner", ".", "run", "(", ")", "\n", "uncollator_runner", ".", "run", "(", ")", "\n", "\n", "for", "name", "in", "[", "\"train\"", ",", "\"dev\"", ",", "\"test\"", "]", ":", "\n", "            ", "assert", "self", ".", "files_same", "(", "f\"{input_dir}/{name}.json\"", ",", "f\"{self.uncollated_dir}/{name}.json\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.test_collate": [[103, 107], ["collate_test.TestCollate.check_collate"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.collate_test.TestCollate.check_collate"], ["", "", "def", "test_collate", "(", "self", ")", ":", "\n", "        ", "\"Make sure that our Document class can read and write data without changing it.\"", "\n", "for", "dirname", "in", "[", "\"ace-event\"", ",", "\"scierc\"", "]", ":", "\n", "            ", "self", ".", "check_collate", "(", "dirname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.collate_test.load_jsonl": [[26, 29], ["open", "json.loads"], "function", ["None"], ["def", "load_jsonl", "(", "fname", ")", ":", "\n", "    ", "with", "open", "(", "fname", ")", "as", "f", ":", "\n", "        ", "return", "[", "json", ".", "loads", "(", "x", ")", "for", "x", "in", "f", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.setUp": [[14, 20], ["dygie.data.DyGIEReader", "dygie_test.TestDygieReader.reader.read"], "methods", ["None"], ["self", ".", "config_file", "=", "\"tests/fixtures/dygie_test_full.jsonnet\"", "\n", "self", ".", "data_file", "=", "\"tests/fixtures/scierc_article.json\"", "\n", "self", ".", "set_up_model", "(", "self", ".", "config_file", ",", "self", ".", "data_file", ")", "\n", "\n", "", "def", "test_dygie_model_can_train_save_and_load", "(", "self", ")", ":", "\n", "        ", "self", ".", "ensure_model_can_train_save_and_load", "(", "self", ".", "param_file", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.tearDown": [[21, 23], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.test_tokens_correct_scierc": [[24, 31], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.test_ner_correct_scierc": [[32, 45], ["zip"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.test_relation_correct_scierc": [[46, 63], ["len", "len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.test_coref_correct_scierc": [[64, 88], ["zip", "zip"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.dygie_test.TestDygieReader.test_vocab_size_correct_scierc": [[89, 98], ["allennlp.data.vocabulary.Vocabulary.from_instances", "allennlp.data.vocabulary.Vocabulary.from_instances.get_vocab_size", "allennlp.data.vocabulary.Vocabulary.from_instances.get_vocab_size", "allennlp.data.vocabulary.Vocabulary.from_instances.get_vocab_size"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.setUp": [[14, 17], ["os.makedirs"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "tmpdir", "=", "\"tmp\"", "\n", "os", ".", "makedirs", "(", "self", ".", "tmpdir", ",", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.tearDown": [[18, 20], ["shutil.rmtree"], "methods", ["None"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "self", ".", "tmpdir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.is_same": [[21, 35], ["x1.keys", "x2.keys"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "is_same", "(", "x1", ",", "x2", ")", ":", "\n", "        ", "\"Compare the fields in two dicts loaded from json.\"", "\n", "# Check if keys are same.", "\n", "if", "x1", ".", "keys", "(", ")", "!=", "x2", ".", "keys", "(", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "# Loop over all fields. If not same, return False.", "\n", "", "for", "key", "in", "x1", ":", "\n", "            ", "if", "x1", "[", "key", "]", "!=", "x2", "[", "key", "]", ":", "\n", "                ", "return", "False", "\n", "\n", "# If we get to the end, they're the same.", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.check_document": [[36, 52], ["dygie.data.Document.from_json", "dygie.data.Document.from_json.to_json", "document_test.TestDocument.is_same", "open", "json.load", "open", "json.dump", "open", "json.load"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.from_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.is_same"], ["", "def", "check_document", "(", "self", ",", "document_name", ")", ":", "\n", "# Load the original file.", "\n", "        ", "with", "open", "(", "f\"fixtures/{document_name}.json\"", ")", "as", "f", ":", "\n", "            ", "js", "=", "json", ".", "load", "(", "f", ")", "\n", "", "doc", "=", "Document", ".", "from_json", "(", "js", ")", "\n", "\n", "# Dump to file.", "\n", "tmpfile", "=", "f\"{self.tmpdir}/{document_name}.json\"", "\n", "dumped", "=", "doc", ".", "to_json", "(", ")", "\n", "with", "open", "(", "tmpfile", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "dumped", ",", "f", ")", "\n", "\n", "# Reload and compare.", "\n", "", "with", "open", "(", "tmpfile", ")", "as", "f", ":", "\n", "            ", "reloaded", "=", "json", ".", "load", "(", "f", ")", "\n", "", "assert", "self", ".", "is_same", "(", "js", ",", "reloaded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.test_document": [[53, 57], ["document_test.TestDocument.check_document"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.data.document_test.TestDocument.check_document"], ["", "def", "test_document", "(", "self", ")", ":", "\n", "        ", "\"Make sure that our Document class can read and write data without changing it.\"", "\n", "for", "document_name", "in", "[", "\"ace_event_article\"", ",", "\"scierc_article\"", ",", "\"ace_event_coref_article\"", "]", ":", "\n", "            ", "self", ".", "check_document", "(", "document_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.__init__": [[65, 67], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "documents", ")", ":", "\n", "        ", "self", ".", "documents", "=", "documents", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.__getitem__": [[68, 70], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "documents", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.__len__": [[71, 73], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "documents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.__repr__": [[74, 76], ["document.Dataset.__len__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.__len__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"Dataset with {self.__len__()} documents.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.from_jsonl": [[77, 86], ["cls", "open", "document.Document.from_json", "documents.append", "json.loads"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.from_json"], ["", "@", "classmethod", "\n", "def", "from_jsonl", "(", "cls", ",", "fname", ")", ":", "\n", "        ", "documents", "=", "[", "]", "\n", "with", "open", "(", "fname", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "doc", "=", "Document", ".", "from_json", "(", "json", ".", "loads", "(", "line", ")", ")", "\n", "documents", ".", "append", "(", "doc", ")", "\n", "\n", "", "", "return", "cls", "(", "documents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Dataset.to_jsonl": [[87, 92], ["doc.to_json", "open", "print", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json"], ["", "def", "to_jsonl", "(", "self", ",", "fname", ")", ":", "\n", "        ", "to_write", "=", "[", "doc", ".", "to_json", "(", ")", "for", "doc", "in", "self", "]", "\n", "with", "open", "(", "fname", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "for", "entry", "in", "to_write", ":", "\n", "                ", "print", "(", "json", ".", "dumps", "(", "entry", ")", ",", "file", "=", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.__init__": [[95, 105], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "doc_key", ",", "dataset", ",", "sentences", ",", "\n", "clusters", "=", "None", ",", "predicted_clusters", "=", "None", ",", "event_clusters", "=", "None", ",", "predicted_event_clusters", "=", "None", ",", "weight", "=", "None", ")", ":", "\n", "        ", "self", ".", "doc_key", "=", "doc_key", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "sentences", "=", "sentences", "\n", "self", ".", "clusters", "=", "clusters", "\n", "self", ".", "predicted_clusters", "=", "predicted_clusters", "\n", "self", ".", "event_clusters", "=", "event_clusters", "\n", "self", ".", "predicted_event_clusters", "=", "predicted_event_clusters", "\n", "self", ".", "weight", "=", "weight", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.from_json": [[106, 159], ["cls._check_fields", "js.get", "dygie.models.shared.fields_to_batches", "numpy.cumsum", "numpy.roll", "sentence_starts.tolist.tolist.tolist", "document.update_sentences_with_clusters", "document.update_sentences_with_event_clusters", "js.get", "cls", "len", "document.Sentence", "enumerate", "document.Cluster", "document.Cluster", "document.Cluster", "document.Cluster", "zip", "enumerate", "enumerate", "enumerate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document._check_fields", "home.repos.pwc.inspect_result.mslars_mare.models.shared.fields_to_batches", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.update_sentences_with_clusters", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.update_sentences_with_event_clusters"], ["", "@", "classmethod", "\n", "def", "from_json", "(", "cls", ",", "js", ")", ":", "\n", "        ", "\"Read in from json-loaded dict.\"", "\n", "cls", ".", "_check_fields", "(", "js", ")", "\n", "doc_key", "=", "js", "[", "\"doc_key\"", "]", "\n", "dataset", "=", "js", ".", "get", "(", "\"dataset\"", ")", "\n", "entries", "=", "fields_to_batches", "(", "js", ",", "[", "\"doc_key\"", ",", "\"dataset\"", ",", "\"clusters\"", ",", "\"predicted_clusters\"", ",", "\n", "\"weight\"", ",", "\"event_clusters\"", ",", "\"predicted_event_clusters\"", "]", ")", "\n", "sentence_lengths", "=", "[", "len", "(", "entry", "[", "\"sentences\"", "]", ")", "for", "entry", "in", "entries", "]", "\n", "sentence_starts", "=", "np", ".", "cumsum", "(", "sentence_lengths", ")", "\n", "sentence_starts", "=", "np", ".", "roll", "(", "sentence_starts", ",", "1", ")", "\n", "sentence_starts", "[", "0", "]", "=", "0", "\n", "sentence_starts", "=", "sentence_starts", ".", "tolist", "(", ")", "\n", "sentences", "=", "[", "Sentence", "(", "entry", ",", "sentence_start", ",", "sentence_ix", ")", "\n", "for", "sentence_ix", ",", "(", "entry", ",", "sentence_start", ")", "\n", "in", "enumerate", "(", "zip", "(", "entries", ",", "sentence_starts", ")", ")", "]", "\n", "# Store cofereference annotations.", "\n", "if", "\"clusters\"", "in", "js", ":", "\n", "            ", "clusters", "=", "[", "Cluster", "(", "entry", ",", "i", ",", "sentences", ",", "sentence_starts", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "js", "[", "\"clusters\"", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "clusters", "=", "None", "\n", "# TODO(dwadden) Need to treat predicted clusters differently and update sentences", "\n", "# appropriately.", "\n", "\n", "", "if", "\"predicted_clusters\"", "in", "js", ":", "\n", "            ", "predicted_clusters", "=", "[", "Cluster", "(", "entry", ",", "i", ",", "sentences", ",", "sentence_starts", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "js", "[", "\"predicted_clusters\"", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "predicted_clusters", "=", "None", "\n", "\n", "# adapt from entity clusters", "\n", "", "if", "\"event_clusters\"", "in", "js", ":", "\n", "            ", "event_clusters", "=", "[", "Cluster", "(", "entry", ",", "i", ",", "sentences", ",", "sentence_starts", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "js", "[", "\"event_clusters\"", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "event_clusters", "=", "None", "\n", "# TODO(dwadden) Need to treat predicted clusters differently and update sentences", "\n", "# appropriately.", "\n", "", "if", "\"predicted_event_clusters\"", "in", "js", ":", "\n", "            ", "predicted_event_clusters", "=", "[", "Cluster", "(", "entry", ",", "i", ",", "sentences", ",", "sentence_starts", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "js", "[", "\"predicted_event_clusters\"", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "predicted_event_clusters", "=", "None", "\n", "\n", "# Update the sentences with coreference cluster labels.", "\n", "", "sentences", "=", "update_sentences_with_clusters", "(", "sentences", ",", "clusters", ")", "\n", "sentences", "=", "update_sentences_with_event_clusters", "(", "sentences", ",", "event_clusters", ")", "\n", "# Get the loss weight for this document.", "\n", "weight", "=", "js", ".", "get", "(", "\"weight\"", ",", "None", ")", "\n", "\n", "return", "cls", "(", "doc_key", ",", "dataset", ",", "sentences", ",", "clusters", ",", "predicted_clusters", ",", "event_clusters", ",", "\n", "predicted_event_clusters", ",", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document._check_fields": [[160, 174], ["re.compile", "js.keys", "ValueError", "re.compile.match", "unexpected.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_check_fields", "(", "js", ")", ":", "\n", "        ", "\"Make sure we only have allowed fields.\"", "\n", "allowed_field_regex", "=", "(", "\"doc_key|dataset|sentences|weight|.*ner$|\"", "\n", "\".*relations$|.*clusters$|.*events$|^_.*\"", ")", "\n", "allowed_field_regex", "=", "re", ".", "compile", "(", "allowed_field_regex", ")", "\n", "unexpected", "=", "[", "]", "\n", "for", "field", "in", "js", ".", "keys", "(", ")", ":", "\n", "            ", "if", "not", "allowed_field_regex", ".", "match", "(", "field", ")", ":", "\n", "                ", "unexpected", ".", "append", "(", "field", ")", "\n", "\n", "", "", "if", "unexpected", ":", "\n", "            ", "msg", "=", "f\"The following unexpected fields should be prefixed with an underscore: {', '.join(unexpected)}.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.to_json": [[175, 195], ["dygie.models.shared.batches_to_fields", "res.update", "sent.to_json", "cluster.to_json", "cluster.to_json", "cluster.to_json", "cluster.to_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.shared.batches_to_fields", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json"], ["", "", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "\"Write to json dict.\"", "\n", "res", "=", "{", "\"doc_key\"", ":", "self", ".", "doc_key", ",", "\n", "\"dataset\"", ":", "self", ".", "dataset", "}", "\n", "sents_json", "=", "[", "sent", ".", "to_json", "(", ")", "for", "sent", "in", "self", "]", "\n", "fields_json", "=", "batches_to_fields", "(", "sents_json", ")", "\n", "res", ".", "update", "(", "fields_json", ")", "\n", "if", "self", ".", "clusters", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"clusters\"", "]", "=", "[", "cluster", ".", "to_json", "(", ")", "for", "cluster", "in", "self", ".", "clusters", "]", "\n", "", "if", "self", ".", "predicted_clusters", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"predicted_clusters\"", "]", "=", "[", "cluster", ".", "to_json", "(", ")", "for", "cluster", "in", "self", ".", "predicted_clusters", "]", "\n", "", "if", "self", ".", "event_clusters", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"event_clusters\"", "]", "=", "[", "cluster", ".", "to_json", "(", ")", "for", "cluster", "in", "self", ".", "event_clusters", "]", "\n", "", "if", "self", ".", "predicted_event_clusters", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"predicted_event_clusters\"", "]", "=", "[", "cluster", ".", "to_json", "(", ")", "for", "cluster", "in", "self", ".", "predicted_event_clusters", "]", "\n", "\n", "", "if", "self", ".", "weight", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"weight\"", "]", "=", "self", ".", "weight", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split": [[197, 252], ["copy.deepcopy", "sentence_groups.append", "NotImplementedError", "NotImplementedError", "document.Document.__class__", "len", "ValueError", "current_group.append", "len", "sentence_groups.append", "len", "range", "zip", "len", "len"], "methods", ["None"], ["", "def", "split", "(", "self", ",", "max_tokens_per_doc", ")", ":", "\n", "        ", "\"\"\"\n        Greedily split a long document into smaller documents, each shorter than\n        `max_tokens_per_doc`. Each split document will get the same weight as its parent.\n        \"\"\"", "\n", "# TODO(dwadden) Implement splitting when there's coref annotations. This is more difficult", "\n", "# because coreference clusters have to be split across documents.", "\n", "if", "self", ".", "clusters", "is", "not", "None", "or", "self", ".", "predicted_clusters", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Splitting documents with coreference annotations not implemented.\"", ")", "\n", "", "if", "self", ".", "event_clusters", "is", "not", "None", "or", "self", ".", "predicted_event_clusters", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Splitting documents with event coreference annotations not implemented.\"", ")", "\n", "\n", "# If the document is already short enough, return it as a list with a single item.", "\n", "", "if", "self", ".", "n_tokens", "<=", "max_tokens_per_doc", ":", "\n", "            ", "return", "[", "self", "]", "\n", "\n", "", "sentences", "=", "copy", ".", "deepcopy", "(", "self", ".", "sentences", ")", "\n", "\n", "sentence_groups", "=", "[", "]", "\n", "current_group", "=", "[", "]", "\n", "group_length", "=", "0", "\n", "sentence_tok_offset", "=", "0", "\n", "sentence_ix_offset", "=", "0", "\n", "for", "sentence", "in", "sentences", ":", "\n", "# Can't deal with single sentences longer than the limit.", "\n", "            ", "if", "len", "(", "sentence", ")", ">", "max_tokens_per_doc", ":", "\n", "                ", "msg", "=", "f\"Sentence \\\"{''.join(sentence.text)}\\\" has more than {max_tokens_per_doc} tokens. Please split this sentence.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "\n", "", "if", "group_length", "+", "len", "(", "sentence", ")", "<=", "max_tokens_per_doc", ":", "\n", "# If we're not at the limit, add it to the current sentence group.", "\n", "                ", "sentence", ".", "sentence_start", "-=", "sentence_tok_offset", "\n", "sentence", ".", "sentence_ix", "-=", "sentence_ix_offset", "\n", "current_group", ".", "append", "(", "sentence", ")", "\n", "group_length", "+=", "len", "(", "sentence", ")", "\n", "", "else", ":", "\n", "# Otherwise, start a new sentence group and adjust sentence offsets.", "\n", "                ", "sentence_groups", ".", "append", "(", "current_group", ")", "\n", "sentence_tok_offset", "=", "sentence", ".", "sentence_start", "\n", "sentence_ix_offset", "=", "sentence", ".", "sentence_ix", "\n", "sentence", ".", "sentence_start", "-=", "sentence_tok_offset", "\n", "sentence", ".", "sentence_ix", "-=", "sentence_ix_offset", "\n", "current_group", "=", "[", "sentence", "]", "\n", "group_length", "=", "len", "(", "sentence", ")", "\n", "\n", "# Add the final sentence group.", "\n", "", "", "sentence_groups", ".", "append", "(", "current_group", ")", "\n", "\n", "# Create a separate document for each sentence group.", "\n", "doc_keys", "=", "[", "f\"{self.doc_key}_SPLIT_{i}\"", "for", "i", "in", "range", "(", "len", "(", "sentence_groups", ")", ")", "]", "\n", "res", "=", "[", "self", ".", "__class__", "(", "doc_key", ",", "self", ".", "dataset", ",", "sentence_group", ",", "\n", "self", ".", "clusters", ",", "self", ".", "predicted_clusters", ",", "self", ".", "weight", ")", "\n", "for", "doc_key", ",", "sentence_group", "in", "zip", "(", "doc_keys", ",", "sentence_groups", ")", "]", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.__repr__": [[253, 255], ["enumerate", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"\\n\"", ".", "join", "(", "[", "str", "(", "i", ")", "+", "\": \"", "+", "\" \"", ".", "join", "(", "sent", ".", "text", ")", "for", "i", ",", "sent", "in", "enumerate", "(", "self", ".", "sentences", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.__getitem__": [[256, 258], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "ix", ")", ":", "\n", "        ", "return", "self", ".", "sentences", "[", "ix", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.__len__": [[259, 261], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "sentences", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.print_plaintext": [[262, 265], ["print"], "methods", ["None"], ["", "def", "print_plaintext", "(", "self", ")", ":", "\n", "        ", "for", "sent", "in", "self", ":", "\n", "            ", "print", "(", "\" \"", ".", "join", "(", "sent", ".", "text", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.n_tokens": [[282, 285], ["sum", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_tokens", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "[", "len", "(", "sent", ")", "for", "sent", "in", "self", ".", "sentences", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.find_cluster": [[270, 281], ["None"], "methods", ["None"], ["", "def", "find_cluster", "(", "self", ",", "entity", ")", ":", "\n", "        ", "\"\"\"\n        Search through coreference clusters and return the one containing the query entity, if it's\n        part of a cluster. If we don't find a match, return None.\n        \"\"\"", "\n", "for", "clust", "in", "self", ".", "clusters", ":", "\n", "            ", "for", "entry", "in", "clust", ":", "\n", "                ", "if", "entry", ".", "span", "==", "entity", ".", "span", ":", "\n", "                    ", "return", "clust", "\n", "\n", "", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Sentence.__init__": [[288, 343], ["document.Events", "document.PredictedEvents", "entry.items", "re.match", "document.NER", "document.PredictedNER", "document.Relation", "document.PredictedRelation"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "entry", ",", "sentence_start", ",", "sentence_ix", ")", ":", "\n", "        ", "self", ".", "sentence_start", "=", "sentence_start", "\n", "self", ".", "sentence_ix", "=", "sentence_ix", "\n", "self", ".", "text", "=", "entry", "[", "\"sentences\"", "]", "\n", "\n", "# Metadata fields are prefixed with a `_`.", "\n", "self", ".", "metadata", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "entry", ".", "items", "(", ")", "if", "re", ".", "match", "(", "\"^_\"", ",", "k", ")", "}", "\n", "\n", "# Store events.", "\n", "if", "\"ner\"", "in", "entry", ":", "\n", "            ", "self", ".", "ner", "=", "[", "NER", "(", "this_ner", ",", "self", ")", "\n", "for", "this_ner", "in", "entry", "[", "\"ner\"", "]", "]", "\n", "self", ".", "ner_dict", "=", "{", "entry", ".", "span", ".", "span_sent", ":", "entry", ".", "label", "for", "entry", "in", "self", ".", "ner", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "ner", "=", "None", "\n", "self", ".", "ner_dict", "=", "None", "\n", "\n", "# Predicted ner.", "\n", "", "if", "\"predicted_ner\"", "in", "entry", ":", "\n", "            ", "self", ".", "predicted_ner", "=", "[", "PredictedNER", "(", "this_ner", ",", "self", ")", "\n", "for", "this_ner", "in", "entry", "[", "\"predicted_ner\"", "]", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "predicted_ner", "=", "None", "\n", "\n", "# Store relations.", "\n", "", "if", "\"relations\"", "in", "entry", ":", "\n", "            ", "self", ".", "relations", "=", "[", "Relation", "(", "this_relation", ",", "self", ")", "for", "\n", "this_relation", "in", "entry", "[", "\"relations\"", "]", "]", "\n", "relation_dict", "=", "{", "}", "\n", "for", "rel", "in", "self", ".", "relations", ":", "\n", "                ", "key", "=", "(", "rel", ".", "pair", "[", "0", "]", ".", "span_sent", ",", "rel", ".", "pair", "[", "1", "]", ".", "span_sent", ")", "\n", "relation_dict", "[", "key", "]", "=", "rel", ".", "label", "\n", "", "self", ".", "relation_dict", "=", "relation_dict", "\n", "", "else", ":", "\n", "            ", "self", ".", "relations", "=", "None", "\n", "self", ".", "relation_dict", "=", "None", "\n", "\n", "# Predicted relations.", "\n", "", "if", "\"predicted_relations\"", "in", "entry", ":", "\n", "            ", "self", ".", "predicted_relations", "=", "[", "PredictedRelation", "(", "this_relation", ",", "self", ")", "for", "\n", "this_relation", "in", "entry", "[", "\"predicted_relations\"", "]", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "predicted_relations", "=", "None", "\n", "\n", "# Store events.", "\n", "", "if", "\"events\"", "in", "entry", ":", "\n", "            ", "self", ".", "events", "=", "Events", "(", "entry", "[", "\"events\"", "]", ",", "self", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "events", "=", "None", "\n", "\n", "# Predicted events.", "\n", "", "if", "\"predicted_events\"", "in", "entry", ":", "\n", "            ", "self", ".", "predicted_events", "=", "PredictedEvents", "(", "entry", "[", "\"predicted_events\"", "]", ",", "self", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predicted_events", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Sentence.to_json": [[344, 363], ["document.Sentence.metadata.items", "document.Sentence.events.to_json", "document.Sentence.predicted_events.to_json", "entry.to_json", "entry.to_json", "entry.to_json", "entry.to_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json"], ["", "", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "res", "=", "{", "\"sentences\"", ":", "self", ".", "text", "}", "\n", "if", "self", ".", "ner", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"ner\"", "]", "=", "[", "entry", ".", "to_json", "(", ")", "for", "entry", "in", "self", ".", "ner", "]", "\n", "", "if", "self", ".", "predicted_ner", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"predicted_ner\"", "]", "=", "[", "entry", ".", "to_json", "(", ")", "for", "entry", "in", "self", ".", "predicted_ner", "]", "\n", "", "if", "self", ".", "relations", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"relations\"", "]", "=", "[", "entry", ".", "to_json", "(", ")", "for", "entry", "in", "self", ".", "relations", "]", "\n", "", "if", "self", ".", "predicted_relations", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"predicted_relations\"", "]", "=", "[", "entry", ".", "to_json", "(", ")", "for", "entry", "in", "self", ".", "predicted_relations", "]", "\n", "", "if", "self", ".", "events", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"events\"", "]", "=", "self", ".", "events", ".", "to_json", "(", ")", "\n", "", "if", "self", ".", "predicted_events", "is", "not", "None", ":", "\n", "            ", "res", "[", "\"predicted_events\"", "]", "=", "self", ".", "predicted_events", ".", "to_json", "(", ")", "\n", "\n", "", "for", "k", ",", "v", "in", "self", ".", "metadata", ".", "items", "(", ")", ":", "\n", "            ", "res", "[", "k", "]", "=", "v", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Sentence.__repr__": [[364, 374], ["enumerate", "len", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "the_text", "=", "\" \"", ".", "join", "(", "self", ".", "text", ")", "\n", "the_lengths", "=", "[", "len", "(", "x", ")", "for", "x", "in", "self", ".", "text", "]", "\n", "tok_ixs", "=", "\"\"", "\n", "for", "i", ",", "offset", "in", "enumerate", "(", "the_lengths", ")", ":", "\n", "            ", "true_offset", "=", "offset", "if", "i", "<", "10", "else", "offset", "-", "1", "\n", "tok_ixs", "+=", "str", "(", "i", ")", "\n", "tok_ixs", "+=", "\" \"", "*", "true_offset", "\n", "\n", "", "return", "the_text", "+", "\"\\n\"", "+", "tok_ixs", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Sentence.__len__": [[375, 377], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.__init__": [[380, 388], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "start", ",", "end", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "# The `start` and `end` are relative to the document. We convert them to be relative to the", "\n", "# sentence.", "\n", "        ", "self", ".", "sentence", "=", "sentence", "\n", "# Need to store the sentence text to make span objects hashable.", "\n", "self", ".", "sentence_text", "=", "\" \"", ".", "join", "(", "sentence", ".", "text", ")", "\n", "self", ".", "start_sent", "=", "start", "if", "sentence_offsets", "else", "start", "-", "sentence", ".", "sentence_start", "\n", "self", ".", "end_sent", "=", "end", "if", "sentence_offsets", "else", "end", "-", "sentence", ".", "sentence_start", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.start_doc": [[389, 392], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "start_doc", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "start_sent", "+", "self", ".", "sentence", ".", "sentence_start", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.end_doc": [[393, 396], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "end_doc", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "end_sent", "+", "self", ".", "sentence", ".", "sentence_start", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.span_doc": [[397, 400], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "span_doc", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "start_doc", ",", "self", ".", "end_doc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.span_sent": [[401, 404], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "span_sent", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "start_sent", ",", "self", ".", "end_sent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.text": [[405, 408], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "text", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sentence", ".", "text", "[", "self", ".", "start_sent", ":", "self", ".", "end_sent", "+", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.__repr__": [[409, 411], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "(", "self", ".", "start_sent", ",", "self", ".", "end_sent", ",", "self", ".", "text", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.__eq__": [[412, 416], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "self", ".", "span_doc", "==", "other", ".", "span_doc", "and", "\n", "self", ".", "span_sent", "==", "other", ".", "span_sent", "and", "\n", "self", ".", "sentence", "==", "other", ".", "sentence", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Span.__hash__": [[417, 420], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "tup", "=", "self", ".", "span_sent", "+", "(", "self", ".", "sentence_text", ",", ")", "\n", "return", "hash", "(", "tup", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Token.__init__": [[423, 426], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ix", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "self", ".", "sentence", "=", "sentence", "\n", "self", ".", "ix_sent", "=", "ix", "if", "sentence_offsets", "else", "ix", "-", "sentence", ".", "sentence_start", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Token.ix_doc": [[427, 430], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "ix_doc", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ix_sent", "+", "self", ".", "sentence", ".", "sentence_start", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Token.text": [[431, 434], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "text", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sentence", ".", "text", "[", "self", ".", "ix_sent", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Token.__repr__": [[435, 437], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "(", "self", ".", "ix_sent", ",", "self", ".", "text", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Trigger.__init__": [[440, 447], ["document.Span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "trig", ",", "sentence", ",", "sentence_offsets", ")", ":", "\n", "# token = Token(trig[0], sentence, sentence_offsets)", "\n", "        ", "label", "=", "trig", "[", "2", "]", "\n", "span", "=", "Span", "(", "trig", "[", "0", "]", ",", "trig", "[", "1", "]", ",", "sentence", ",", "sentence_offsets", ")", "\n", "# self.token = token", "\n", "self", ".", "label", "=", "label", "\n", "self", ".", "span", "=", "span", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Trigger.__repr__": [[448, 450], ["document.Trigger.span.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.span.__repr__()}: {self.label}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Trigger.__hash__": [[451, 453], ["document.Trigger.span.__hash__", "hash"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", ".", "__hash__", "(", ")", "+", "hash", "(", "self", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Trigger.__eq__": [[454, 457], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "self", ".", "span", "==", "other", ".", "span", "and", "\n", "self", ".", "label", "==", "other", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Trigger.to_json": [[458, 460], ["list"], "methods", ["None"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "span", ".", "span_doc", ")", "+", "[", "self", ".", "label", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedTrigger.__init__": [[463, 467], ["document.Trigger.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "trig", ",", "sentence", ",", "sentence_offsets", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "trig", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "raw_score", "=", "trig", "[", "3", "]", "\n", "self", ".", "softmax_score", "=", "trig", "[", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedTrigger.__repr__": [[468, 470], ["document.Trigger.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "+", "f\" with confidence {self.softmax_score:0.4f}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedTrigger.to_json": [[471, 473], ["document.Trigger.to_json", "document.format_float", "document.format_float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "to_json", "(", ")", "+", "[", "format_float", "(", "self", ".", "raw_score", ")", ",", "format_float", "(", "self", ".", "softmax_score", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Argument.__init__": [[476, 480], ["document.Span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "arg", ",", "event_type", ",", "sentence", ",", "sentence_offsets", ")", ":", "\n", "        ", "self", ".", "span", "=", "Span", "(", "arg", "[", "0", "]", ",", "arg", "[", "1", "]", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "role", "=", "arg", "[", "2", "]", "\n", "self", ".", "event_type", "=", "event_type", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Argument.__repr__": [[481, 483], ["document.Argument.span.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", ".", "__repr__", "(", ")", "[", ":", "-", "1", "]", "+", "\", \"", "+", "self", ".", "event_type", "+", "\", \"", "+", "self", ".", "role", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Argument.__eq__": [[484, 488], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "self", ".", "span", "==", "other", ".", "span", "and", "\n", "self", ".", "role", "==", "other", ".", "role", "and", "\n", "self", ".", "event_type", "==", "other", ".", "event_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Argument.__hash__": [[489, 491], ["document.Argument.span.__hash__", "hash"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", ".", "__hash__", "(", ")", "+", "hash", "(", "(", "self", ".", "role", ",", "self", ".", "event_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Argument.to_json": [[492, 494], ["list"], "methods", ["None"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "span", ".", "span_doc", ")", "+", "[", "self", ".", "role", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedArgument.__init__": [[497, 501], ["document.Argument.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "arg", ",", "event_type", ",", "sentence", ",", "sentence_offsets", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "arg", ",", "event_type", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "raw_score", "=", "arg", "[", "3", "]", "\n", "self", ".", "softmax_score", "=", "arg", "[", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedArgument.__repr__": [[502, 504], ["document.Argument.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "+", "f\" with confidence {self.softmax_score:0.4f}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedArgument.to_json": [[505, 507], ["document.Argument.to_json", "document.format_float", "document.format_float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "to_json", "(", ")", "+", "[", "format_float", "(", "self", ".", "raw_score", ")", ",", "format_float", "(", "self", ".", "softmax_score", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.NER.__init__": [[510, 513], ["document.Span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ner", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "self", ".", "span", "=", "Span", "(", "ner", "[", "0", "]", ",", "ner", "[", "1", "]", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "label", "=", "ner", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.NER.__repr__": [[514, 516], ["document.NER.span.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.span.__repr__()}: {self.label}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.NER.__eq__": [[517, 520], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "self", ".", "span", "==", "other", ".", "span", "and", "\n", "self", ".", "label", "==", "other", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.NER.to_json": [[521, 523], ["list"], "methods", ["None"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "span", ".", "span_doc", ")", "+", "[", "self", ".", "label", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedNER.__init__": [[526, 531], ["document.NER.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "ner", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "\"The input should be a list: [span_start, span_end, label, raw_score, softmax_score].\"", "\n", "super", "(", ")", ".", "__init__", "(", "ner", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "raw_score", "=", "ner", "[", "3", "]", "\n", "self", ".", "softmax_score", "=", "ner", "[", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedNER.__repr__": [[532, 534], ["document.NER.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "+", "f\" with confidence {self.softmax_score:0.4f}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedNER.to_json": [[535, 537], ["document.NER.to_json", "document.format_float", "document.format_float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "to_json", "(", ")", "+", "[", "format_float", "(", "self", ".", "raw_score", ")", ",", "format_float", "(", "self", ".", "softmax_score", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Relation.__init__": [[540, 548], ["document.Span", "document.Span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "relation", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "start1", ",", "end1", "=", "relation", "[", "0", "]", ",", "relation", "[", "1", "]", "\n", "start2", ",", "end2", "=", "relation", "[", "2", "]", ",", "relation", "[", "3", "]", "\n", "label", "=", "relation", "[", "4", "]", "\n", "span1", "=", "Span", "(", "start1", ",", "end1", ",", "sentence", ",", "sentence_offsets", ")", "\n", "span2", "=", "Span", "(", "start2", ",", "end2", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "pair", "=", "(", "span1", ",", "span2", ")", "\n", "self", ".", "label", "=", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Relation.__repr__": [[549, 551], ["document.Relation.pair[].__repr__", "document.Relation.pair[].__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.pair[0].__repr__()}, {self.pair[1].__repr__()}: {self.label}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Relation.__eq__": [[552, 554], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "self", ".", "pair", "==", "other", ".", "pair", ")", "and", "(", "self", ".", "label", "==", "other", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Relation.to_json": [[555, 557], ["list", "list"], "methods", ["None"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "pair", "[", "0", "]", ".", "span_doc", ")", "+", "list", "(", "self", ".", "pair", "[", "1", "]", ".", "span_doc", ")", "+", "[", "self", ".", "label", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedRelation.__init__": [[560, 565], ["document.Relation.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "relation", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "\"Input format: [start_1, end_1, start_2, end_2, label, raw_score, softmax_score].\"", "\n", "super", "(", ")", ".", "__init__", "(", "relation", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "raw_score", "=", "relation", "[", "5", "]", "\n", "self", ".", "softmax_score", "=", "relation", "[", "6", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedRelation.__repr__": [[566, 568], ["document.Relation.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "+", "f\" with confidence {self.softmax_score:0.4f}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.PredictedRelation.to_json": [[569, 571], ["document.Relation.to_json", "document.format_float", "document.format_float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "to_json", "(", ")", "+", "[", "format_float", "(", "self", ".", "raw_score", ")", ",", "format_float", "(", "self", ".", "softmax_score", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventBase.__init__": [[577, 586], ["document.EventBase.trigger_constructor", "document.EventBase.argument_constructor", "document.EventBase.arguments.append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "event", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "trig", "=", "event", "[", "0", "]", "\n", "args", "=", "event", "[", "1", ":", "]", "\n", "self", ".", "trigger", "=", "self", ".", "trigger_constructor", "(", "trig", ",", "sentence", ",", "sentence_offsets", ")", "\n", "\n", "self", ".", "arguments", "=", "[", "]", "\n", "for", "arg", "in", "args", ":", "\n", "            ", "this_arg", "=", "self", ".", "argument_constructor", "(", "arg", ",", "self", ".", "trigger", ".", "label", ",", "sentence", ",", "sentence_offsets", ")", "\n", "self", ".", "arguments", ".", "append", "(", "this_arg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventBase.to_json": [[587, 592], ["document.EventBase.trigger.to_json", "arg.to_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json"], ["", "", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "trig_json", "=", "self", ".", "trigger", ".", "to_json", "(", ")", "\n", "arg_json", "=", "[", "arg", ".", "to_json", "(", ")", "for", "arg", "in", "self", ".", "arguments", "]", "\n", "res", "=", "[", "trig_json", "]", "+", "arg_json", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventBase.__repr__": [[593, 600], ["document.EventBase.trigger.__repr__", "arg.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "res", "=", "\"<\"", "\n", "res", "+=", "self", ".", "trigger", ".", "__repr__", "(", ")", "+", "\":\\n\"", "\n", "for", "arg", "in", "self", ".", "arguments", ":", "\n", "            ", "res", "+=", "6", "*", "\" \"", "+", "arg", ".", "__repr__", "(", ")", "+", "\";\\n\"", "\n", "", "res", "=", "res", "[", ":", "-", "2", "]", "+", "\">\"", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.__init__": [[614, 634], ["set", "set", "document.EventsBase.event_constructor"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "events_json", ",", "sentence", ",", "sentence_offsets", "=", "False", ")", ":", "\n", "        ", "self", ".", "event_list", "=", "[", "self", ".", "event_constructor", "(", "this_event", ",", "sentence", ",", "sentence_offsets", ")", "\n", "for", "this_event", "in", "events_json", "]", "\n", "self", ".", "triggers", "=", "set", "(", "[", "event", ".", "trigger", "for", "event", "in", "self", ".", "event_list", "]", ")", "\n", "self", ".", "arguments", "=", "set", "(", "[", "arg", "for", "event", "in", "self", ".", "event_list", "for", "arg", "in", "event", ".", "arguments", "]", ")", "\n", "\n", "# Store trigger and argument dictionaries.", "\n", "trigger_dict", "=", "{", "}", "\n", "argument_dict", "=", "{", "}", "\n", "for", "event", "in", "self", ".", "event_list", ":", "\n", "            ", "trigger_key", "=", "event", ".", "trigger", ".", "span", ".", "span_sent", "# integer index", "\n", "trigger_val", "=", "event", ".", "trigger", ".", "label", "# trigger label", "\n", "trigger_dict", "[", "trigger_key", "]", "=", "trigger_val", "\n", "for", "argument", "in", "event", ".", "arguments", ":", "\n", "                ", "arg_key", "=", "(", "trigger_key", ",", "argument", ".", "span", ".", "span_sent", ")", "# (trigger_ix, (arg_start, arg_end))", "\n", "arg_value", "=", "argument", ".", "role", "# argument label", "\n", "argument_dict", "[", "arg_key", "]", "=", "arg_value", "\n", "\n", "", "", "self", ".", "trigger_dict", "=", "trigger_dict", "\n", "self", ".", "argument_dict", "=", "argument_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.to_json": [[635, 637], ["event.to_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "[", "event", ".", "to_json", "(", ")", "for", "event", "in", "self", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.__len__": [[638, 640], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "event_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.__getitem__": [[641, 643], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "event_list", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.__repr__": [[644, 646], ["event.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"\\n\\n\"", ".", "join", "(", "[", "event", ".", "__repr__", "(", ")", "for", "event", "in", "self", ".", "event_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.span_matches": [[647, 650], ["set"], "methods", ["None"], ["", "def", "span_matches", "(", "self", ",", "argument", ")", ":", "\n", "        ", "return", "set", "(", "[", "candidate", "for", "candidate", "in", "self", ".", "arguments", "\n", "if", "candidate", ".", "span", ".", "span_sent", "==", "argument", ".", "span", ".", "span_sent", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.event_type_matches": [[651, 654], ["set", "document.EventsBase.span_matches"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.span_matches"], ["", "def", "event_type_matches", "(", "self", ",", "argument", ")", ":", "\n", "        ", "return", "set", "(", "[", "candidate", "for", "candidate", "in", "self", ".", "span_matches", "(", "argument", ")", "\n", "if", "candidate", ".", "event_type", "==", "argument", ".", "event_type", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.matches_except_event_type": [[655, 660], ["set", "document.EventsBase.span_matches"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.span_matches"], ["", "def", "matches_except_event_type", "(", "self", ",", "argument", ")", ":", "\n", "        ", "matched", "=", "[", "candidate", "for", "candidate", "in", "self", ".", "span_matches", "(", "argument", ")", "\n", "if", "candidate", ".", "event_type", "!=", "argument", ".", "event_type", "\n", "and", "candidate", ".", "role", "==", "argument", ".", "role", "]", "\n", "return", "set", "(", "matched", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.EventsBase.exact_match": [[661, 666], ["None"], "methods", ["None"], ["", "def", "exact_match", "(", "self", ",", "argument", ")", ":", "\n", "        ", "for", "candidate", "in", "self", ".", "arguments", ":", "\n", "            ", "if", "candidate", "==", "argument", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.__init__": [[677, 702], ["sum", "isinstance", "TypeError", "print", "len", "document.get_sentence_of_span", "document.Span", "document.ClusterMember", "members.append", "members_crossing_sentences.append"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.get_sentence_of_span"], ["    ", "def", "__init__", "(", "self", ",", "cluster", ",", "cluster_id", ",", "sentences", ",", "sentence_starts", ")", ":", "\n", "# Make sure the cluster ID is an int.", "\n", "        ", "if", "not", "isinstance", "(", "cluster_id", ",", "int", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Coreference cluster ID's must be ints.\"", ")", "\n", "\n", "", "n_tokens", "=", "sum", "(", "[", "len", "(", "x", ")", "for", "x", "in", "sentences", "]", ")", "\n", "\n", "members", "=", "[", "]", "\n", "members_crossing_sentences", "=", "[", "]", "\n", "\n", "for", "entry", "in", "cluster", ":", "\n", "            ", "try", ":", "\n", "                ", "sentence_ix", "=", "get_sentence_of_span", "(", "entry", ",", "sentence_starts", ",", "n_tokens", ")", "\n", "sentence", "=", "sentences", "[", "sentence_ix", "]", "\n", "span", "=", "Span", "(", "entry", "[", "0", "]", ",", "entry", "[", "1", "]", ",", "sentence", ")", "\n", "to_append", "=", "ClusterMember", "(", "span", ",", "sentence", ",", "cluster_id", ")", "\n", "members", ".", "append", "(", "to_append", ")", "\n", "", "except", "SpanCrossesSentencesError", ":", "\n", "                ", "members_crossing_sentences", ".", "append", "(", "entry", ")", "\n", "\n", "", "", "if", "members_crossing_sentences", ":", "\n", "            ", "print", "(", "\"Found a coreference cluster member that crosses sentence boundaries; skipping.\"", ")", "\n", "\n", "", "self", ".", "members", "=", "members", "\n", "self", ".", "cluster_id", "=", "cluster_id", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.to_json": [[703, 705], ["list"], "methods", ["None"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "[", "list", "(", "member", ".", "span", ".", "span_doc", ")", "for", "member", "in", "self", ".", "members", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.__repr__": [[706, 708], ["document.Cluster.members.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.cluster_id}: \"", "+", "self", ".", "members", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.__getitem__": [[709, 711], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "ix", ")", ":", "\n", "        ", "return", "self", ".", "members", "[", "ix", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Cluster.__len__": [[712, 714], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "members", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.ClusterMember.__init__": [[717, 721], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "span", ",", "sentence", ",", "cluster_id", ")", ":", "\n", "        ", "self", ".", "span", "=", "span", "\n", "self", ".", "sentence", "=", "sentence", "\n", "self", ".", "cluster_id", "=", "cluster_id", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.ClusterMember.__repr__": [[722, 724], ["document.ClusterMember.span.__repr__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"<{self.sentence.sentence_ix}> \"", "+", "self", ".", "span", ".", "__repr__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.format_float": [[10, 12], ["round"], "function", ["None"], ["def", "format_float", "(", "x", ")", ":", "\n", "    ", "return", "round", "(", "x", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.get_sentence_of_span": [[18, 30], ["in_between.index", "sum", "zip"], "function", ["home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index"], ["", "def", "get_sentence_of_span", "(", "span", ",", "sentence_starts", ",", "doc_tokens", ")", ":", "\n", "    ", "\"\"\"\n    Return the index of the sentence that the span is part of.\n    \"\"\"", "\n", "# Inclusive sentence ends", "\n", "sentence_ends", "=", "[", "x", "-", "1", "for", "x", "in", "sentence_starts", "[", "1", ":", "]", "]", "+", "[", "doc_tokens", "-", "1", "]", "\n", "in_between", "=", "[", "span", "[", "0", "]", ">=", "start", "and", "span", "[", "1", "]", "<=", "end", "\n", "for", "start", ",", "end", "in", "zip", "(", "sentence_starts", ",", "sentence_ends", ")", "]", "\n", "if", "sum", "(", "in_between", ")", "!=", "1", ":", "\n", "        ", "raise", "SpanCrossesSentencesError", "\n", "", "the_sentence", "=", "in_between", ".", "index", "(", "True", ")", "\n", "return", "the_sentence", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.update_sentences_with_clusters": [[32, 46], ["None"], "function", ["None"], ["", "def", "update_sentences_with_clusters", "(", "sentences", ",", "clusters", ")", ":", "\n", "    ", "\"Add cluster dictionary to each sentence, if there are coreference clusters.\"", "\n", "for", "sent", "in", "sentences", ":", "\n", "        ", "sent", ".", "cluster_dict", "=", "{", "}", "if", "clusters", "is", "not", "None", "else", "None", "\n", "\n", "", "if", "clusters", "is", "None", ":", "\n", "        ", "return", "sentences", "\n", "\n", "", "for", "clust", "in", "clusters", ":", "\n", "        ", "for", "member", "in", "clust", ".", "members", ":", "\n", "            ", "sent", "=", "member", ".", "sentence", "\n", "sent", ".", "cluster_dict", "[", "member", ".", "span", ".", "span_sent", "]", "=", "member", ".", "cluster_id", "\n", "\n", "", "", "return", "sentences", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.update_sentences_with_event_clusters": [[48, 62], ["None"], "function", ["None"], ["", "def", "update_sentences_with_event_clusters", "(", "sentences", ",", "event_clusters", ")", ":", "\n", "    ", "\"Add event cluster dictionary to each sentence, if there are event coreference clusters.\"", "\n", "for", "sent", "in", "sentences", ":", "\n", "        ", "sent", ".", "event_cluster_dict", "=", "{", "}", "if", "event_clusters", "is", "not", "None", "else", "None", "\n", "\n", "", "if", "event_clusters", "is", "None", ":", "\n", "        ", "return", "sentences", "\n", "\n", "", "for", "event_clust", "in", "event_clusters", ":", "\n", "        ", "for", "member", "in", "event_clust", ".", "members", ":", "\n", "            ", "sent", "=", "member", ".", "sentence", "\n", "sent", ".", "event_cluster_dict", "[", "member", ".", "span", ".", "span_sent", "]", "=", "member", ".", "cluster_id", "\n", "\n", "", "", "return", "sentences", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader.__init__": [[34, 43], ["allennlp.data.dataset_readers.dataset_reader.DatasetReader.__init__", "allennlp.data.token_indexers.SingleIdTokenIndexer"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["        ", "instance", "=", "self", ".", "_words_list_to_instance", "(", "tokenized_document", ")", "\n", "return", "self", ".", "predict_instance", "(", "instance", ")", "\n", "\n", "", "@", "overrides", "\n", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "return", "self", ".", "_dataset_reader", ".", "text_to_instance", "(", "json_dict", ")", "\n", "\n", "", "@", "overrides", "\n", "def", "dump_line", "(", "self", ",", "outputs", ")", ":", "\n", "# Need to override to tell Python how to deal with Numpy ints.", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._read": [[44, 57], ["allennlp.common.file_utils.cached_path", "open", "f.readlines", "json.loads", "dygie.DyGIEReader.text_to_instance"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance"], ["        ", "return", "json", ".", "dumps", "(", "outputs", ",", "default", "=", "int", ")", "+", "\"\\n\"", "\n", "\n", "# TODO(dwadden) Can this be implemented in `forward_on_instance`  instead?", "\n", "", "@", "overrides", "\n", "def", "predict_instance", "(", "self", ",", "instance", ")", ":", "\n", "        ", "\"\"\"\n        An instance is an entire document, represented as a list of sentences.\n        \"\"\"", "\n", "model", "=", "self", ".", "_model", "\n", "cuda_device", "=", "model", ".", "_get_prediction_device", "(", ")", "\n", "\n", "# Try to predict this batch.", "\n", "try", ":", "\n", "            ", "dataset", "=", "Batch", "(", "[", "instance", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._too_long": [[58, 62], ["None"], "methods", ["None"], ["dataset", ".", "index_instances", "(", "model", ".", "vocab", ")", "\n", "model_input", "=", "util", ".", "move_to_device", "(", "dataset", ".", "as_tensor_dict", "(", ")", ",", "cuda_device", ")", "\n", "prediction", "=", "model", ".", "make_output_human_readable", "(", "model", "(", "**", "model_input", ")", ")", ".", "to_json", "(", ")", "\n", "# If we run out of GPU memory, warn user and indicate that this document failed.", "\n", "# This way, prediction doesn't grind to a halt every time we run out of GPU.", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_ner": [[63, 73], ["sent.ner_dict.items", "len", "dygie.DyGIEReader._too_long", "span_tuples.index"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index"], ["", "except", "RuntimeError", "as", "err", ":", "\n", "# doc_key, dataset, sentences, message", "\n", "            ", "metadata", "=", "instance", "[", "\"metadata\"", "]", ".", "metadata", "\n", "doc_key", "=", "metadata", ".", "doc_key", "\n", "msg", "=", "(", "f\"Encountered a RunTimeError on document {doc_key}. Skipping this example.\"", "\n", "f\" Error message:\\n{err.args[0]}.\"", ")", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "prediction", "=", "metadata", ".", "to_json", "(", ")", "\n", "prediction", "[", "\"_FAILED_PREDICTION\"", "]", "=", "True", "\n", "\n", "", "return", "prediction", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_coref": [[74, 83], ["sent.cluster_dict.items", "len", "dygie.DyGIEReader._too_long", "span_tuples.index"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index"], ["", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_relations": [[84, 100], ["sent.relation_dict.items", "span_tuples.index", "span_tuples.index", "relation_indices.append", "relations.append", "dygie.DyGIEReader._too_long", "dygie.DyGIEReader._too_long"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_events": [[101, 125], ["sent.events.trigger_dict.items", "sent.events.argument_dict.items", "len", "dygie.DyGIEReader._too_long", "trigger_span_tuples.index", "dygie.DyGIEReader._too_long", "trigger_span_tuples.index", "dygie.DyGIEReader._too_long", "span_tuples.index", "argument_indices.append", "arguments.append"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_sentence": [[126, 183], ["allennlp.data.fields.TextField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "dygie.DyGIEReader._normalize_word", "trigger_spans.append", "spans.append", "dygie.DyGIEReader._process_ner", "allennlp.data.fields.ListField", "dygie.DyGIEReader._process_coref", "allennlp.data.fields.ListField", "dygie.DyGIEReader._process_relations", "allennlp.data.fields.AdjacencyField", "dygie.DyGIEReader._process_events", "allennlp.data.fields.ListField", "dygie.data.fields.adjacency_field_assym.AdjacencyFieldAssym", "allennlp.data.tokenizers.Token", "allennlp.data.fields.SpanField", "allennlp.data.fields.SpanField", "allennlp.data.fields.LabelField", "allennlp.data.fields.LabelField", "allennlp.data.fields.LabelField"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._normalize_word", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_ner", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_coref", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_relations", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_events"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_sentence_fields": [[184, 203], ["set", "sentence_fields[].keys", "dygie.DyGIEReader._process_sentence", "sentence_fields[].keys", "allennlp.data.fields.ListField", "set", "dygie.DyGIEDataException", "entry.keys"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_sentence"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader.text_to_instance": [[204, 222], ["dygie.data.dataset_readers.document.Document.from_json", "dygie.DyGIEReader._process_sentence_fields", "allennlp.data.fields.MetadataField", "allennlp.data.instance.Instance", "len", "min", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.from_json", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._process_sentence_fields"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._instances_from_cache_file": [[223, 228], ["open", "pickle.load"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._instances_to_cache_file": [[229, 233], ["open", "pickle.dump"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.dygie.DyGIEReader._normalize_word": [[234, 240], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.SpartReader.__init__": [[55, 67], ["allennlp.data.dataset_readers.dataset_reader.DatasetReader.__init__", "allennlp.data.token_indexers.SingleIdTokenIndexer"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "max_span_width", ":", "int", ",", "\n", "max_relation_negative_samples", ":", "int", ",", "\n", "token_indexers", ":", "Dict", "[", "str", ",", "TokenIndexer", "]", "=", "None", ",", "\n", "training", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "_max_span_width", "=", "max_span_width", "\n", "self", ".", "_max_relation_negative_samples", "=", "max_relation_negative_samples", "\n", "self", ".", "_token_indexers", "=", "token_indexers", "or", "{", "\"tokens\"", ":", "SingleIdTokenIndexer", "(", ")", "}", "\n", "# we cannot", "\n", "self", ".", "_training", "=", "training", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.SpartReader._read": [[68, 86], ["allennlp.common.file_utils.cached_path", "open", "f.readlines", "json.loads", "spart_reader.SpartReader.text_to_instance", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance"], ["", "@", "overrides", "\n", "def", "_read", "(", "self", ",", "file_path", ":", "str", ")", ":", "\n", "\n", "# if `file_path` is a URL, redirect to the cache", "\n", "        ", "file_path", "=", "cached_path", "(", "file_path", ")", "\n", "\n", "with", "open", "(", "file_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "for", "line", "in", "lines", ":", "\n", "# Loop over the documents.", "\n", "            ", "doc_text", "=", "json", ".", "loads", "(", "line", ")", "\n", "\n", "if", "len", "(", "doc_text", "[", "\"tokens\"", "]", ")", "<=", "2", ":", "\n", "                ", "continue", "\n", "\n", "", "instance", "=", "self", ".", "text_to_instance", "(", "doc_text", ")", "\n", "yield", "instance", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.SpartReader.text_to_instance": [[87, 210], ["spart.util.util.extract_entities", "spart.util.util.extract_relations_from_smart_sample", "allennlp.data.fields.TextField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "enumerate", "random.sample", "allennlp.data.fields.ArrayField", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.MetadataField", "allennlp.data.Instance", "allennlp.data.Token", "len", "spans.append", "span_masks.append", "spart_reader.SpartReader._too_long", "span_tuples.index", "len", "random.sample", "enumerate", "list", "min", "numpy.ones", "numpy.zeros", "allennlp.data.fields.SpanField", "spart_reader.create_mask", "allennlp.data.fields.ArrayField", "allennlp.data.fields.LabelField", "sorted", "pos_span_masks.append", "min", "zip", "len", "len", "allennlp.data.fields.ArrayField", "allennlp.data.fields.ArrayField", "allennlp.data.fields.MultiLabelField", "numpy.array", "spart_reader.create_rel_mask", "len", "spart_reader.SpartReader._too_long", "spart_reader.SpartReader._too_long", "span_tuples.index", "span_tuples.index", "neg_span_masks.append", "numpy.array", "numpy.array", "span_tuples.index", "span_tuples.index", "spart_reader.SpartReader._too_long", "spart_reader.create_rel_mask"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_entities", "home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_mask", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_rel_mask", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_rel_mask"], ["", "", "@", "overrides", "\n", "def", "text_to_instance", "(", "self", ",", "sample", ":", "Dict", "[", "str", ",", "Any", "]", ",", "training", ":", "bool", "=", "True", ")", ":", "\n", "        ", "text", "=", "sample", "[", "\"text\"", "]", "\n", "words", "=", "[", "text", "[", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "tokens", "=", "[", "Token", "(", "w", ")", "for", "w", "in", "words", "]", "\n", "entities", "=", "extract_entities", "(", "sample", ")", "\n", "\n", "relations", "=", "extract_relations_from_smart_sample", "(", "sample", ",", "include_trigger", "=", "True", ")", "\n", "\n", "sequence", "=", "TextField", "(", "tokens", ",", "self", ".", "_token_indexers", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", "}", "\n", "words", "=", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "\n", "spans", "=", "[", "]", "\n", "span_masks", "=", "[", "]", "\n", "\n", "context_size", "=", "len", "(", "words", ")", "+", "1", "\n", "for", "start", ",", "end", "in", "enumerate_spans", "(", "words", ",", "\n", "max_span_width", "=", "self", ".", "_max_span_width", ")", ":", "# TODO beim training wird eigentlich keine vollst\u00e4ndige candidate liste genommen", "\n", "            ", "assert", "start", ">=", "0", "\n", "assert", "end", ">=", "0", "\n", "spans", ".", "append", "(", "SpanField", "(", "start", ",", "end", ",", "sequence", ")", ")", "\n", "span_masks", ".", "append", "(", "create_mask", "(", "start", ",", "end", ",", "context_size", ")", ")", "\n", "\n", "", "instance_fields", "[", "\"span_masks\"", "]", "=", "ListField", "(", "\n", "[", "ArrayField", "(", "np", ".", "array", "(", "si", ",", "dtype", "=", "np", ".", "int", ")", ",", "dtype", "=", "np", ".", "int", ")", "for", "si", "in", "span_masks", "]", ")", "\n", "\n", "span_field", "=", "ListField", "(", "spans", ")", "\n", "\n", "span_tuples", "=", "[", "(", "span", ".", "span_start", ",", "span", ".", "span_end", ")", "for", "span", "in", "spans", "]", "\n", "instance_fields", "[", "\"spans\"", "]", "=", "span_field", "# TODO was ist mit dem negative sampling?", "\n", "\n", "ner_labels", "=", "[", "\"O\"", "for", "i", "in", "span_tuples", "]", "\n", "\n", "ner_list", "=", "[", "(", "(", "e", ".", "start", ",", "e", ".", "end", ")", ",", "e", ".", "role", ")", "for", "e", "in", "entities", "]", "\n", "\n", "for", "span", ",", "label", "in", "ner_list", ":", "\n", "            ", "if", "self", ".", "_too_long", "(", "span", ")", ":", "\n", "                ", "continue", "\n", "", "ix", "=", "span_tuples", ".", "index", "(", "span", ")", "\n", "ner_labels", "[", "ix", "]", "=", "label", "\n", "\n", "# TODO Evaluate if this should be a MultiLabel instead of Label", "\n", "", "instance_fields", "[", "\"ner_labels\"", "]", "=", "ListField", "(", "\n", "[", "LabelField", "(", "entry", ",", "label_namespace", "=", "\"ner_labels\"", ")", "for", "entry", "in", "ner_labels", "]", ")", "\n", "\n", "pos_span_pairs", "=", "[", "]", "\n", "pos_span_labels", "=", "[", "]", "\n", "pos_span_masks", "=", "[", "]", "\n", "\n", "for", "rel", "in", "relations", ":", "\n", "            ", "mand_arg_roles", "=", "relation_args_names", "[", "rel", ".", "label", "]", "\n", "try", ":", "\n", "# TODO handle special case Merger", "\n", "                ", "s1", ",", "s2", "=", "sorted", "(", "[", "s", "for", "s", "in", "rel", ".", "spans", "if", "s", ".", "role", "in", "mand_arg_roles", "]", ",", "key", "=", "lambda", "x", ":", "x", ".", "role", ")", "\n", "pos_span_pairs", "+=", "[", "(", "span_tuples", ".", "index", "(", "s1", ".", "span", ")", ",", "span_tuples", ".", "index", "(", "s2", ".", "span", ")", ")", "]", "\n", "pos_span_labels", "+=", "[", "[", "rel", ".", "label", "]", "]", "\n", "pos_span_masks", ".", "append", "(", "create_rel_mask", "(", "(", "s1", ".", "start", ",", "s1", ".", "end", ")", ",", "(", "s2", ".", "start", ",", "s2", ".", "end", ")", ",", "context_size", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "pass", "\n", "", "except", "Exception", ":", "\n", "                ", "i", "=", "10", "\n", "\n", "", "", "neg_span_pairs", "=", "[", "]", "\n", "neg_span_labels", "=", "[", "]", "\n", "neg_span_masks", "=", "[", "]", "\n", "if", "len", "(", "ner_list", ")", "<", "2", ":", "\n", "            ", "ner_cands", "=", "random", ".", "sample", "(", "span_tuples", ",", "min", "(", "len", "(", "span_tuples", ")", ",", "7", ")", ")", "\n", "\n", "ner_cands", "=", "[", "nc", "for", "nc", "in", "ner_cands", "if", "not", "self", ".", "_too_long", "(", "nc", ")", "]", "\n", "\n", "ner_list", "+=", "[", "(", "s", ",", "\"\"", ")", "for", "s", "in", "ner_cands", "]", "\n", "\n", "", "for", "i1", ",", "s1", "in", "enumerate", "(", "ner_list", ")", ":", "\n", "            ", "for", "i2", ",", "s2", "in", "enumerate", "(", "ner_list", ")", ":", "\n", "# rev = (s2, s1)", "\n", "# rev_symmetric = rev in pos_rel_spans and pos_rel_types[pos_rel_spans.index(rev)].symmetric", "\n", "                ", "if", "self", ".", "_too_long", "(", "s1", "[", "0", "]", ")", "or", "self", ".", "_too_long", "(", "s2", "[", "0", "]", ")", ":", "\n", "                    ", "continue", "\n", "# candidate", "\n", "", "cand", "=", "(", "span_tuples", ".", "index", "(", "s1", "[", "0", "]", ")", ",", "span_tuples", ".", "index", "(", "s2", "[", "0", "]", ")", ")", "\n", "\n", "# do not add as negative relation sample:", "\n", "# neg. relations from an entity to itself", "\n", "# entity pairs that are related according to gt", "\n", "# entity pairs whose reverse exists as a symmetric relation in gt", "\n", "# if s1 != s2 and (s1, s2) not in pos_span_pairs and not rev_symmetric:", "\n", "if", "cand", "[", "0", "]", "!=", "cand", "[", "1", "]", "and", "cand", "not", "in", "pos_span_pairs", ":", "\n", "                    ", "neg_span_pairs", "+=", "[", "cand", "]", "\n", "neg_span_labels", "+=", "[", "[", "]", "]", "\n", "neg_span_masks", ".", "append", "(", "create_rel_mask", "(", "s1", "[", "0", "]", ",", "s2", "[", "0", "]", ",", "context_size", ")", ")", "\n", "\n", "", "", "", "negative_samples", "=", "random", ".", "sample", "(", "\n", "list", "(", "zip", "(", "neg_span_pairs", ",", "neg_span_labels", ",", "neg_span_masks", ")", ")", ",", "\n", "min", "(", "len", "(", "neg_span_labels", ")", ",", "self", ".", "_max_relation_negative_samples", ")", "\n", ")", "\n", "neg_span_pairs", "=", "[", "ns", "[", "0", "]", "for", "ns", "in", "negative_samples", "]", "\n", "neg_span_labels", "=", "[", "ns", "[", "1", "]", "for", "ns", "in", "negative_samples", "]", "\n", "neg_span_masks", "=", "[", "ns", "[", "2", "]", "for", "ns", "in", "negative_samples", "]", "\n", "\n", "relation_spans", "=", "pos_span_pairs", "+", "neg_span_pairs", "\n", "relation_labels", "=", "pos_span_labels", "+", "neg_span_labels", "\n", "relation_masks", "=", "pos_span_masks", "+", "neg_span_masks", "\n", "\n", "if", "relation_spans", ":", "\n", "            ", "rels_sample_masks", "=", "np", ".", "ones", "(", "len", "(", "relation_spans", ")", ")", "\n", "", "else", ":", "\n", "            ", "rels_sample_masks", "=", "np", ".", "zeros", "(", "1", ")", "\n", "\n", "", "instance_fields", "[", "\"rels_sample_masks\"", "]", "=", "ArrayField", "(", "rels_sample_masks", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "instance_fields", "[", "\"relation_masks\"", "]", "=", "ListField", "(", "\n", "[", "ArrayField", "(", "np", ".", "array", "(", "si", ",", "dtype", "=", "np", ".", "int", ")", ",", "dtype", "=", "np", ".", "int", ")", "for", "si", "in", "relation_masks", "]", ")", "\n", "\n", "instance_fields", "[", "\"rel_span_indices\"", "]", "=", "ListField", "(", "\n", "[", "ArrayField", "(", "np", ".", "array", "(", "si", ",", "dtype", "=", "np", ".", "int", ")", ",", "dtype", "=", "np", ".", "int", ")", "for", "si", "in", "relation_spans", "]", ")", "\n", "\n", "instance_fields", "[", "\"rel_labels\"", "]", "=", "ListField", "(", "\n", "[", "MultiLabelField", "(", "rel_label", ",", "label_namespace", "=", "\"rel_labels\"", ")", "for", "rel_label", "in", "relation_labels", "]", ")", "\n", "\n", "metadata", "=", "{", "\"words\"", ":", "words", ",", "\"relations\"", ":", "relations", "}", "\n", "instance_fields", "[", "\"metadata\"", "]", "=", "MetadataField", "(", "metadata", ")", "\n", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.SpartReader._too_long": [[211, 213], ["None"], "methods", ["None"], ["", "def", "_too_long", "(", "self", ",", "span", ")", ":", "\n", "        ", "return", "span", "[", "1", "]", "-", "span", "[", "0", "]", "+", "1", ">", "self", ".", "_max_span_width", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_mask": [[39, 44], ["numpy.zeros"], "function", ["None"], ["def", "create_mask", "(", "start", ",", "end", ",", "context", ")", ":", "\n", "    ", "mask", "=", "np", ".", "zeros", "(", "context", ")", "\n", "mask", "[", "start", ":", "(", "end", "+", "1", ")", "]", "=", "1", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_rel_mask": [[46, 51], ["spart_reader.create_mask"], "function", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.spart_reader.create_mask"], ["", "def", "create_rel_mask", "(", "s1", ",", "s2", ",", "context_size", ")", ":", "\n", "    ", "start", "=", "s1", "[", "1", "]", "if", "s1", "[", "1", "]", "<", "s2", "[", "0", "]", "else", "s2", "[", "1", "]", "\n", "end", "=", "s2", "[", "0", "]", "if", "s1", "[", "1", "]", "<", "s2", "[", "0", "]", "else", "s1", "[", "0", "]", "\n", "mask", "=", "create_mask", "(", "start", ",", "end", ",", "context_size", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.__init__": [[43, 71], ["adjacency_field_assym.AdjacencyFieldAssym._maybe_warn_for_namespace", "row_field.sequence_length", "col_field.sequence_length", "len", "len", "allennlp.common.checks.ConfigurationError", "all", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError", "set", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym._maybe_warn_for_namespace"], ["def", "__init__", "(", "self", ",", "\n", "indices", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "row_field", ":", "SequenceField", ",", "\n", "col_field", ":", "SequenceField", ",", "\n", "labels", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "label_namespace", ":", "str", "=", "'labels'", ",", "\n", "padding_value", ":", "int", "=", "-", "1", ")", "->", "None", ":", "\n", "        ", "self", ".", "indices", "=", "indices", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "row_field", "=", "row_field", "\n", "self", ".", "col_field", "=", "col_field", "\n", "self", ".", "_label_namespace", "=", "label_namespace", "\n", "self", ".", "_padding_value", "=", "padding_value", "\n", "self", ".", "_indexed_labels", ":", "List", "[", "int", "]", "=", "None", "\n", "\n", "self", ".", "_maybe_warn_for_namespace", "(", "label_namespace", ")", "\n", "row_length", "=", "row_field", ".", "sequence_length", "(", ")", "\n", "col_length", "=", "col_field", ".", "sequence_length", "(", ")", "\n", "\n", "if", "len", "(", "set", "(", "indices", ")", ")", "!=", "len", "(", "indices", ")", ":", "\n", "            ", "raise", "ConfigurationError", "(", "f\"Indices must be unique, but found {indices}\"", ")", "\n", "\n", "", "if", "not", "all", "(", "[", "0", "<=", "index", "[", "1", "]", "<", "col_length", "and", "0", "<=", "index", "[", "0", "]", "<", "row_length", "for", "index", "in", "indices", "]", ")", ":", "\n", "            ", "raise", "ConfigurationError", "(", "f\"Label indices and sequence length \"", "\n", "f\"are incompatible: {indices} and {row_length} or {col_length}\"", ")", "\n", "\n", "", "if", "labels", "is", "not", "None", "and", "len", "(", "indices", ")", "!=", "len", "(", "labels", ")", ":", "\n", "            ", "raise", "ConfigurationError", "(", "f\"Labelled indices were passed, but their lengths do not match: \"", "\n", "f\" {labels}, {indices}\"", ")", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym._maybe_warn_for_namespace": [[73, 82], ["adjacency_field_assym.AdjacencyFieldAssym._label_namespace.endswith", "adjacency_field_assym.AdjacencyFieldAssym._label_namespace.endswith", "logger.warning", "adjacency_field_assym.AdjacencyFieldAssym._already_warned_namespaces.add"], "methods", ["None"], ["", "", "def", "_maybe_warn_for_namespace", "(", "self", ",", "label_namespace", ":", "str", ")", "->", "None", ":", "\n", "        ", "if", "not", "(", "self", ".", "_label_namespace", ".", "endswith", "(", "\"labels\"", ")", "or", "self", ".", "_label_namespace", ".", "endswith", "(", "\"tags\"", ")", ")", ":", "\n", "            ", "if", "label_namespace", "not", "in", "self", ".", "_already_warned_namespaces", ":", "\n", "                ", "logger", ".", "warning", "(", "\"Your label namespace was '%s'. We recommend you use a namespace \"", "\n", "\"ending with 'labels' or 'tags', so we don't add UNK and PAD tokens by \"", "\n", "\"default to your vocabulary.  See documentation for \"", "\n", "\"`non_padded_namespaces` parameter in Vocabulary.\"", ",", "\n", "self", ".", "_label_namespace", ")", "\n", "self", ".", "_already_warned_namespaces", ".", "add", "(", "label_namespace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.count_vocab_items": [[83, 88], ["None"], "methods", ["None"], ["", "", "", "@", "overrides", "\n", "def", "count_vocab_items", "(", "self", ",", "counter", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "int", "]", "]", ")", ":", "\n", "        ", "if", "self", ".", "_indexed_labels", "is", "None", "and", "self", ".", "labels", "is", "not", "None", ":", "\n", "            ", "for", "label", "in", "self", ".", "labels", ":", "\n", "                ", "counter", "[", "self", ".", "_label_namespace", "]", "[", "label", "]", "+=", "1", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index": [[89, 94], ["vocab.get_token_index"], "methods", ["None"], ["", "", "", "@", "overrides", "\n", "def", "index", "(", "self", ",", "vocab", ":", "Vocabulary", ")", ":", "\n", "        ", "if", "self", ".", "_indexed_labels", "is", "None", "and", "self", ".", "labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "_indexed_labels", "=", "[", "vocab", ".", "get_token_index", "(", "label", ",", "self", ".", "_label_namespace", ")", "\n", "for", "label", "in", "self", ".", "labels", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.get_padding_lengths": [[95, 99], ["adjacency_field_assym.AdjacencyFieldAssym.row_field.sequence_length", "adjacency_field_assym.AdjacencyFieldAssym.col_field.sequence_length"], "methods", ["None"], ["", "", "@", "overrides", "\n", "def", "get_padding_lengths", "(", "self", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "        ", "return", "{", "'num_rows'", ":", "self", ".", "row_field", ".", "sequence_length", "(", ")", ",", "\n", "'num_cols'", ":", "self", ".", "col_field", ".", "sequence_length", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.as_tensor": [[100, 110], ["zip", "torch.ones", "range", "len"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "as_tensor", "(", "self", ",", "padding_lengths", ":", "Dict", "[", "str", ",", "int", "]", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "desired_num_rows", "=", "padding_lengths", "[", "'num_rows'", "]", "\n", "desired_num_cols", "=", "padding_lengths", "[", "'num_cols'", "]", "\n", "tensor", "=", "torch", ".", "ones", "(", "desired_num_rows", ",", "desired_num_cols", ")", "*", "self", ".", "_padding_value", "\n", "labels", "=", "self", ".", "_indexed_labels", "or", "[", "1", "for", "_", "in", "range", "(", "len", "(", "self", ".", "indices", ")", ")", "]", "\n", "\n", "for", "index", ",", "label", "in", "zip", "(", "self", ".", "indices", ",", "labels", ")", ":", "\n", "            ", "tensor", "[", "index", "]", "=", "label", "\n", "", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.empty_field": [[111, 121], ["adjacency_field_assym.AdjacencyFieldAssym", "adjacency_field_assym.AdjacencyFieldAssym.row_field.empty_field", "adjacency_field_assym.AdjacencyFieldAssym.col_field.empty_field"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.empty_field", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.empty_field"], ["", "@", "overrides", "\n", "def", "empty_field", "(", "self", ")", "->", "'AdjacencyFieldAssym'", ":", "\n", "# pylint: disable=protected-access", "\n", "# The empty_list here is needed for mypy", "\n", "        ", "empty_list", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "=", "[", "]", "\n", "adjacency_field", "=", "AdjacencyFieldAssym", "(", "empty_list", ",", "\n", "self", ".", "row_field", ".", "empty_field", "(", ")", ",", "\n", "self", ".", "col_field", ".", "empty_field", "(", ")", ",", "\n", "padding_value", "=", "self", ".", "_padding_value", ")", "\n", "return", "adjacency_field", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.__str__": [[122, 130], ["adjacency_field_assym.AdjacencyFieldAssym.row_field.sequence_length", "adjacency_field_assym.AdjacencyFieldAssym.col_field.sequence_length", "textwrap.wrap", "textwrap.wrap", "repr", "repr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "row_length", "=", "self", ".", "row_field", ".", "sequence_length", "(", ")", "\n", "col_length", "=", "self", ".", "col_field", ".", "sequence_length", "(", ")", "\n", "formatted_labels", "=", "\"\"", ".", "join", "(", "[", "\"\\t\\t\"", "+", "labels", "+", "\"\\n\"", "\n", "for", "labels", "in", "textwrap", ".", "wrap", "(", "repr", "(", "self", ".", "labels", ")", ",", "100", ")", "]", ")", "\n", "formatted_indices", "=", "\"\"", ".", "join", "(", "[", "\"\\t\\t\"", "+", "index", "+", "\"\\n\"", "\n", "for", "index", "in", "textwrap", ".", "wrap", "(", "repr", "(", "self", ".", "indices", ")", ",", "100", ")", "]", ")", "\n", "return", "f\"AdjacencyFieldAssym of row length {row_length} and col length {col_length}\\n\"", "f\"\\t\\twith indices:\\n {formatted_indices}\\n\""]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictor._json_to_instance": [[14, 23], ["allennlp.data.fields.TextField", "allennlp.data.Instance", "allennlp.data.Token", "allennlp.data.fields.MetadataField"], "methods", ["None"], ["    ", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "tokens", "=", "[", "Token", "(", "t", ")", "for", "t", "in", "json_dict", "[", "\"tokens\"", "]", "]", "\n", "# Attribut (_dataset_reader._token_indexers ) wird durch unseren DataReader hinzugef\u00fcgt!", "\n", "# Nicht allgemein g\u00fcltig...", "\n", "token_indexers", "=", "self", ".", "_dataset_reader", ".", "_token_indexers", "\n", "sequence", "=", "TextField", "(", "tokens", ",", "token_indexers", "=", "token_indexers", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", ",", "\n", "\"metadata\"", ":", "MetadataField", "(", "{", "\"words\"", ":", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "}", ")", "}", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictor.transform_relations_to_format": [[24, 38], ["result[].append", "ents.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "transform_relations_to_format", "(", "relations", ")", "->", "JsonDict", ":", "\n", "        ", "result", "=", "{", "\"relations\"", ":", "[", "]", "}", "\n", "for", "rel", "in", "relations", ":", "\n", "            ", "rel_name", "=", "rel", ".", "label", "\n", "ents", "=", "[", "]", "\n", "for", "span", "in", "rel", ".", "spans", ":", "\n", "                ", "start", "=", "span", ".", "span", "[", "0", "]", "\n", "end", "=", "span", ".", "span", "[", "1", "]", "\n", "role", "=", "span", ".", "role", "\n", "ents", ".", "append", "(", "{", "\"name\"", ":", "role", ",", "\"start\"", ":", "start", ",", "\"end\"", ":", "end", "}", ")", "\n", "", "result", "[", "\"relations\"", "]", ".", "append", "(", "{", "\"name\"", ":", "rel_name", ",", "\"ents\"", ":", "ents", "}", ")", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictor._post_processing_prediction": [[39, 42], ["mare.label.extraction.transform_tags_to_relation", "seq_lab_elmo_pred.SequenceLabElmoPredictor.transform_relations_to_format"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.transform_relations_to_format"], ["", "def", "_post_processing_prediction", "(", "self", ",", "prediction", ")", ":", "\n", "        ", "relations", "=", "transform_tags_to_relation", "(", "prediction", "[", "\"tags\"", "]", ",", "max_inner_range", "=", "11", ",", "has_mode", "=", "False", ",", "include_trigger", "=", "True", ")", "\n", "return", "self", ".", "transform_relations_to_format", "(", "relations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictor.predict_json": [[43, 46], ["super().predict_json", "seq_lab_elmo_pred.SequenceLabElmoPredictor._post_processing_prediction"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], ["", "def", "predict_json", "(", "self", ",", "inputs", ":", "JsonDict", ")", "->", "JsonDict", ":", "\n", "        ", "output_dict", "=", "super", "(", ")", ".", "predict_json", "(", "inputs", ")", "\n", "return", "self", ".", "_post_processing_prediction", "(", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictor.predict_batch_json": [[48, 51], ["super().predict_batch_json", "seq_lab_elmo_pred.SequenceLabElmoPredictor._post_processing_prediction"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], ["", "def", "predict_batch_json", "(", "self", ",", "inputs", ":", "List", "[", "JsonDict", "]", ")", "->", "List", "[", "JsonDict", "]", ":", "\n", "        ", "output", "=", "super", "(", ")", ".", "predict_batch_json", "(", "inputs", ")", "\n", "return", "[", "self", ".", "_post_processing_prediction", "(", "entry", ")", "for", "entry", "in", "output", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred.SequenceLabElmoPredictorSentence._json_to_instance": [[55, 63], ["spacy.load", "spacy.load.", "seq_lab_elmo_pred.SequenceLabElmoPredictor._json_to_instance"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._json_to_instance"], ["    ", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "raw_text", "=", "json_dict", "[", "\"text\"", "]", "\n", "\n", "nlp", "=", "spacy", ".", "load", "(", "\"de_core_news_sm\"", ")", "\n", "doc", "=", "nlp", "(", "raw_text", ")", "\n", "\n", "tokens", "=", "{", "\"tokens\"", ":", "[", "t", ".", "text", "for", "t", "in", "doc", "]", "}", "\n", "return", "super", "(", ")", ".", "_json_to_instance", "(", "tokens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.span_based_precidtor.SpanBasedPredictor._json_to_instance": [[12, 30], ["allennlp.data.fields.TextField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "allennlp.data.Instance", "allennlp.data.Token", "spans.append", "allennlp.data.fields.MetadataField", "allennlp.data.fields.SpanField"], "methods", ["None"], ["    ", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "tokens", "=", "[", "Token", "(", "t", ")", "for", "t", "in", "json_dict", "[", "\"tokens\"", "]", "]", "\n", "# Attribut (_dataset_reader._token_indexers ) wird durch unseren DataReader hinzugef\u00fcgt!", "\n", "# Nicht allgemein g\u00fcltig...", "\n", "token_indexers", "=", "self", ".", "_dataset_reader", ".", "_token_indexers", "\n", "sequence", "=", "TextField", "(", "tokens", ",", "token_indexers", "=", "token_indexers", ")", "\n", "\n", "spans", "=", "[", "]", "\n", "for", "start", ",", "end", "in", "enumerate_spans", "(", "tokens", ",", "max_span_width", "=", "10", ")", ":", "\n", "            ", "spans", ".", "append", "(", "SpanField", "(", "start", ",", "end", ",", "sequence", ")", ")", "\n", "\n", "", "span_field", "=", "ListField", "(", "spans", ")", "\n", "span_tuples", "=", "[", "(", "span", ".", "span_start", ",", "span", ".", "span_end", ")", "for", "span", "in", "spans", "]", "\n", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", ",", "\n", "\"metadata\"", ":", "MetadataField", "(", "{", "\"words\"", ":", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "}", ")", ",", "\n", "\"spans\"", ":", "span_field", "}", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.span_based_precidtor.SpanBasedPredictor.predict_json": [[31, 34], ["super().predict_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json"], ["", "def", "predict_json", "(", "self", ",", "inputs", ":", "JsonDict", ")", "->", "JsonDict", ":", "\n", "        ", "output_dict", "=", "super", "(", ")", ".", "predict_json", "(", "inputs", ")", "\n", "return", "output_dict", "[", "\"relations\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.span_based_precidtor.SpanBasedPredictor.predict_batch_json": [[36, 39], ["super().predict_batch_json"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json"], ["", "def", "predict_batch_json", "(", "self", ",", "inputs", ":", "List", "[", "JsonDict", "]", ")", "->", "List", "[", "JsonDict", "]", ":", "\n", "        ", "output", "=", "super", "(", ")", ".", "predict_batch_json", "(", "inputs", ")", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_reader.SmartReader.__init__": [[21, 39], ["allennlp.data.DatasetReader.__init__", "set", "allennlp.data.token_indexers.SingleIdTokenIndexer"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "token_indexers", ":", "Dict", "[", "str", ",", "TokenIndexer", "]", "=", "None", ",", "\n", "tag_label", ":", "str", "=", "\"relation\"", ",", "\n", "feature_labels", ":", "Sequence", "[", "str", "]", "=", "(", ")", ",", "\n", "coding_scheme", ":", "str", "=", "\"BIO\"", ",", "\n", "label_namespace", ":", "str", "=", "\"labels\"", ",", "\n", "include_mode", ":", "bool", "=", "False", ",", "\n", "include_trigger", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ",", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "_token_indexers", "=", "token_indexers", "or", "{", "\"tokens\"", ":", "SingleIdTokenIndexer", "(", ")", "}", "\n", "self", ".", "tag_label", "=", "tag_label", "\n", "self", ".", "feature_labels", "=", "set", "(", "feature_labels", ")", "\n", "self", ".", "coding_scheme", "=", "coding_scheme", "\n", "self", ".", "label_namespace", "=", "label_namespace", "\n", "self", ".", "_original_coding_scheme", "=", "\"BIO\"", "\n", "self", ".", "_include_mode", "=", "include_mode", "\n", "self", ".", "include_trigger", "=", "include_trigger", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_reader.SmartReader._read": [[40, 68], ["allennlp.common.file_utils.cached_path", "open", "logger.info", "srsly.json_loads", "mare.label.extraction.extract_entities", "mare.label.extraction.combine_spans_to_entity_tags", "mare.label.extraction.extract_relations_from_smart_sample", "mare.label.extraction.combined_relation_tags", "smart_file.readlines", "allennlp.data.Token", "len", "len", "smart_reader.SmartReader.text_to_instance"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_entities", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combine_spans_to_entity_tags", "home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance"], ["", "def", "_read", "(", "self", ",", "file_path", ":", "str", ")", "->", "Iterable", "[", "Instance", "]", ":", "\n", "\n", "        ", "file_path", "=", "cached_path", "(", "file_path", ")", "\n", "\n", "with", "open", "(", "file_path", ",", "\"r\"", ")", "as", "smart_file", ":", "\n", "            ", "logger", ".", "info", "(", "\"Reading instances from lines in file at: %s\"", ",", "file_path", ")", "\n", "\n", "dataset", "=", "(", "srsly", ".", "json_loads", "(", "line", ")", "for", "line", "in", "smart_file", ".", "readlines", "(", ")", ")", "\n", "\n", "for", "sample", "in", "dataset", ":", "\n", "                ", "text", "=", "sample", "[", "\"text\"", "]", "\n", "words", "=", "[", "text", "[", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "tokens", "=", "[", "Token", "(", "w", ")", "for", "w", "in", "words", "]", "\n", "\n", "entities", "=", "extract_entities", "(", "sample", ")", "\n", "entity_tags", "=", "combine_spans_to_entity_tags", "(", "entities", ",", "len", "(", "words", ")", ")", "\n", "\n", "relations", "=", "extract_relations_from_smart_sample", "(", "sample", ",", "only_mandatory", "=", "False", ",", "\n", "include_trigger", "=", "self", ".", "include_trigger", ")", "\n", "relation_tags", "=", "combined_relation_tags", "(", "relations", ",", "len", "(", "words", ")", ",", "include_mode", "=", "self", ".", "_include_mode", ",", ")", "\n", "\n", "idx", "=", "sample", "[", "\"id\"", "]", "\n", "yield", "self", ".", "text_to_instance", "(", "tokens", ",", "\n", "relation_tags", "=", "relation_tags", ",", "\n", "relations", "=", "relations", ",", "\n", "entity_tags", "=", "entity_tags", ",", "\n", "entities", "=", "entities", ",", "\n", "idx", "=", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_reader.SmartReader.text_to_instance": [[69, 102], ["allennlp.data.fields.TextField", "allennlp.data.fields.MetadataField", "allennlp.data.Instance", "allennlp.data.fields.SequenceLabelField", "allennlp.data.fields.SequenceLabelField", "allennlp.data.fields.SequenceLabelField", "allennlp.data.fields.SequenceLabelField"], "methods", ["None"], ["", "", "", "def", "text_to_instance", "(", "self", ",", "\n", "tokens", ":", "List", "[", "Token", "]", ",", "\n", "relation_tags", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "relations", ":", "List", "[", "Dict", "]", "=", "None", ",", "\n", "entity_tags", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "entities", ":", "List", "=", "None", ",", "\n", "idx", ":", "str", "=", "None", ")", "->", "Instance", ":", "\n", "\n", "        ", "sequence", "=", "TextField", "(", "tokens", ",", "self", ".", "_token_indexers", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", "}", "\n", "\n", "metadata", "=", "{", "\"words\"", ":", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", ",", "\n", "\"id\"", ":", "idx", "}", "\n", "\n", "if", "relation_tags", "is", "not", "None", ":", "\n", "            ", "instance_fields", "[", "\"relation_tags\"", "]", "=", "SequenceLabelField", "(", "relation_tags", ",", "sequence", ",", "\"relation_tags\"", ")", "\n", "", "if", "entity_tags", "is", "not", "None", ":", "\n", "            ", "instance_fields", "[", "\"entity_tags\"", "]", "=", "SequenceLabelField", "(", "relation_tags", ",", "sequence", ",", "\"entity_tags\"", ")", "\n", "", "if", "relations", "is", "not", "None", ":", "\n", "            ", "metadata", "[", "\"relations\"", "]", "=", "relations", "\n", "", "if", "entities", "is", "not", "None", ":", "\n", "            ", "metadata", "[", "\"entities\"", "]", "=", "entities", "\n", "\n", "", "instance_fields", "[", "\"metadata\"", "]", "=", "MetadataField", "(", "metadata", ")", "\n", "\n", "if", "self", ".", "tag_label", "==", "\"ner\"", ":", "\n", "            ", "if", "entity_tags", "is", "not", "None", ":", "\n", "                ", "instance_fields", "[", "\"tags\"", "]", "=", "SequenceLabelField", "(", "entity_tags", ",", "sequence", ",", "self", ".", "label_namespace", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "relation_tags", "is", "not", "None", ":", "\n", "                ", "instance_fields", "[", "\"tags\"", "]", "=", "SequenceLabelField", "(", "relation_tags", ",", "sequence", ",", "self", ".", "label_namespace", ")", "\n", "\n", "", "", "return", "Instance", "(", "instance_fields", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_metric.NERMetrics.__init__": [[17, 22], ["ner_metric.NERMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["def", "__init__", "(", "self", ",", "number_of_classes", ":", "int", ",", "none_label", ":", "int", "=", "0", ",", "threshold", ":", "float", "=", "0.65", ")", ":", "\n", "        ", "self", ".", "number_of_classes", "=", "number_of_classes", "\n", "self", ".", "none_label", "=", "none_label", "\n", "self", ".", "_threshold", "=", "threshold", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_metric.NERMetrics.__call__": [[23, 45], ["predictions.cpu.cpu.cpu", "gold_labels.cpu.cpu.cpu", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.cpu().unsqueeze", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.cpu", "torch.logical_and", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.bool", "torch.logical_and", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.bool", "torch.logical_and", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.bool", "torch.logical_and", "mask.cpu().unsqueeze().repeat.cpu().unsqueeze().repeat.bool"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "__call__", "(", "self", ",", "\n", "predictions", ":", "torch", ".", "Tensor", ",", "\n", "gold_labels", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "predictions", "=", "predictions", ".", "cpu", "(", ")", "\n", "gold_labels", "=", "gold_labels", ".", "cpu", "(", ")", "\n", "# mask = mask.cpu()", "\n", "# for i in range(self.number_of_classes):", "\n", "#     if i == self.none_label:", "\n", "#         continue", "\n", "# self._true_positives += ((predictions[:, :, i] > 0.65)*(gold_labels==i)*mask.bool()).sum().item()", "\n", "# self._false_positives += ((predictions[:, :, i] > 0.65)*(gold_labels!=i)*mask.bool()).sum().item()", "\n", "# self._true_negatives += ((predictions[:, :, i] <= 0.65)*(gold_labels!=i)*mask.bool()).sum().item()", "\n", "# self._false_negatives += ((predictions[:, :, i] <= 0.65)*(gold_labels==i)*mask.bool()).sum().item()", "\n", "\n", "mask", "=", "mask", ".", "cpu", "(", ")", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "predictions", ".", "shape", "[", "2", "]", ")", "\n", "\n", "self", ".", "_true_positives", "+=", "(", "torch", ".", "logical_and", "(", "predictions", ">", "self", ".", "_threshold", ",", "gold_labels", "==", "1", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_false_positives", "+=", "(", "torch", ".", "logical_and", "(", "predictions", ">", "self", ".", "_threshold", ",", "gold_labels", "!=", "1", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_true_negatives", "+=", "(", "torch", ".", "logical_and", "(", "predictions", "<=", "self", ".", "_threshold", ",", "gold_labels", "!=", "1", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_false_negatives", "+=", "(", "torch", ".", "logical_and", "(", "predictions", "<=", "self", ".", "_threshold", ",", "gold_labels", "==", "1", ")", "*", "mask", ".", "bool", "(", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_metric.NERMetrics.get_metric": [[46, 66], ["mare.f1.compute_f1", "ner_metric.NERMetrics.reset"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns\n        -------\n        A tuple of the following metrics based on the accumulated count statistics:\n        precision : float\n        recall : float\n        f1-measure : float\n        \"\"\"", "\n", "predicted", "=", "self", ".", "_true_positives", "+", "self", ".", "_false_positives", "\n", "gold", "=", "self", ".", "_true_positives", "+", "self", ".", "_false_negatives", "\n", "matched", "=", "self", ".", "_true_positives", "\n", "precision", ",", "recall", ",", "f1_measure", "=", "compute_f1", "(", "predicted", ",", "gold", ",", "matched", ")", "\n", "\n", "# Reset counts if at end of epoch.", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "return", "precision", ",", "recall", ",", "f1_measure", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_metric.NERMetrics.reset": [[67, 73], ["None"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_true_positives", "=", "0", "\n", "self", ".", "_false_positives", "=", "0", "\n", "self", ".", "_true_negatives", "=", "0", "\n", "self", ".", "_false_negatives", "=", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.__init__": [[74, 191], ["allennlp.nn.InitializerApplicator", "allennlp.models.model.Model.__init__", "ner_model.SequenceTagger.vocab.get_vocab_size", "mare.utils.compounding", "allennlp.modules.TimeDistributed", "allennlp.modules.ConditionalRandomField", "allennlp.common.checks.check_dimensions_match", "initializer", "torch.nn.Dropout", "feedforward.get_output_dim", "ner_model.SequenceTagger.encoder.get_output_dim", "torch.nn.modules.linear.Linear", "SelfAttentionGRU", "PositionalEncoding", "ner_model.SequenceTagger.vocab.get_index_to_token_vocabulary", "allennlp.modules.conditional_random_field.allowed_transitions", "allennlp.training.metrics.CategoricalAccuracy", "allennlp.training.metrics.CategoricalAccuracy", "allennlp.training.metrics.SpanBasedF1Measure", "mare.metric.RelationMetric", "text_field_embedder.get_output_dim", "encoder.get_input_dim", "allennlp.common.checks.check_dimensions_match", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError", "encoder.get_output_dim", "feedforward.get_input_dim", "encoder.get_output_dim", "encoder.get_output_dim", "ner_model.SequenceTagger.vocab.get_token_index", "encoder.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__", "home.repos.pwc.inspect_result.mslars_mare.mare.utils.compounding"], ["def", "__init__", "(", "\n", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "text_field_embedder", ":", "TextFieldEmbedder", ",", "\n", "encoder", ":", "Seq2SeqEncoder", ",", "\n", "use_attention", ":", "bool", "=", "False", ",", "\n", "use_positional_encoding", ":", "bool", "=", "False", ",", "\n", "label_namespace", ":", "str", "=", "\"labels\"", ",", "\n", "feedforward", ":", "Optional", "[", "FeedForward", "]", "=", "None", ",", "\n", "label_encoding", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "include_start_end_transitions", ":", "bool", "=", "True", ",", "\n", "has_mode", ":", "bool", "=", "False", ",", "\n", "constrain_crf_decoding", ":", "bool", "=", "None", ",", "\n", "calculate_span_f1", ":", "bool", "=", "None", ",", "\n", "calculate_relation_f1", ":", "bool", "=", "False", ",", "\n", "dropout", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "verbose_metrics", ":", "bool", "=", "False", ",", "\n", "initializer", ":", "InitializerApplicator", "=", "InitializerApplicator", "(", ")", ",", "\n", "top_k", ":", "int", "=", "1", ",", "\n", "max_relation_width", ":", "int", "=", "11", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "vocab", ",", "**", "kwargs", ")", "\n", "self", ".", "label_namespace", "=", "label_namespace", "\n", "self", ".", "text_field_embedder", "=", "text_field_embedder", "\n", "self", ".", "num_tags", "=", "self", ".", "vocab", ".", "get_vocab_size", "(", "label_namespace", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "top_k", "=", "top_k", "\n", "self", ".", "_verbose_metrics", "=", "verbose_metrics", "\n", "self", ".", "use_attention", "=", "use_attention", "\n", "self", ".", "use_positional_encoding", "=", "use_positional_encoding", "\n", "self", ".", "_sample_probability", "=", "compounding", "(", "0.1", ",", "1.0", ",", "0.99", ")", "\n", "\n", "self", ".", "has_mode", "=", "has_mode", "\n", "if", "dropout", ":", "\n", "            ", "self", ".", "dropout", "=", "torch", ".", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "dropout", "=", "None", "\n", "", "self", ".", "_feedforward", "=", "feedforward", "\n", "\n", "if", "feedforward", "is", "not", "None", ":", "\n", "            ", "output_dim", "=", "feedforward", ".", "get_output_dim", "(", ")", "\n", "", "else", ":", "\n", "            ", "output_dim", "=", "self", ".", "encoder", ".", "get_output_dim", "(", ")", "\n", "", "self", ".", "tag_projection_layer", "=", "TimeDistributed", "(", "Linear", "(", "output_dim", ",", "self", ".", "num_tags", ")", ")", "\n", "\n", "if", "self", ".", "use_attention", ":", "\n", "            ", "self", ".", "_attention", "=", "SelfAttentionGRU", "(", "\n", "output_dim", ",", "\n", "embedding_size", "=", "encoder", ".", "get_output_dim", "(", ")", ",", "\n", "rnn_hidden_size", "=", "encoder", ".", "get_output_dim", "(", ")", ",", "\n", "bos_index", "=", "self", ".", "vocab", ".", "get_token_index", "(", "\"O\"", ",", "label_namespace", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "use_positional_encoding", ":", "\n", "            ", "self", ".", "positional_encoding", "=", "PositionalEncoding", "(", "d_model", "=", "encoder", ".", "get_output_dim", "(", ")", ",", "dropout", "=", "dropout", ")", "\n", "\n", "# if  constrain_crf_decoding and calculate_span_f1 are not", "\n", "# provided, (i.e., they're None), set them to True", "\n", "# if label_encoding is provided and False if it isn't.", "\n", "", "if", "constrain_crf_decoding", "is", "None", ":", "\n", "            ", "constrain_crf_decoding", "=", "label_encoding", "is", "not", "None", "\n", "", "if", "calculate_span_f1", "is", "None", ":", "\n", "            ", "calculate_span_f1", "=", "label_encoding", "is", "not", "None", "\n", "\n", "", "self", ".", "label_encoding", "=", "label_encoding", "\n", "if", "constrain_crf_decoding", ":", "\n", "            ", "if", "not", "label_encoding", ":", "\n", "                ", "raise", "ConfigurationError", "(", "\n", "\"constrain_crf_decoding is True, but no label_encoding was specified.\"", "\n", ")", "\n", "", "labels", "=", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "label_namespace", ")", "\n", "constraints", "=", "allowed_transitions", "(", "label_encoding", ",", "labels", ")", "\n", "", "else", ":", "\n", "            ", "constraints", "=", "None", "\n", "\n", "", "self", ".", "include_start_end_transitions", "=", "include_start_end_transitions", "\n", "self", ".", "crf", "=", "ConditionalRandomField", "(", "\n", "self", ".", "num_tags", ",", "constraints", ",", "include_start_end_transitions", "=", "include_start_end_transitions", "\n", ")", "\n", "\n", "self", ".", "metrics", "=", "{", "\n", "\"accuracy\"", ":", "CategoricalAccuracy", "(", ")", ",", "\n", "\"accuracy3\"", ":", "CategoricalAccuracy", "(", "top_k", "=", "3", ")", ",", "\n", "}", "\n", "self", ".", "calculate_span_f1", "=", "calculate_span_f1", "\n", "if", "calculate_span_f1", ":", "\n", "            ", "if", "not", "label_encoding", ":", "\n", "                ", "raise", "ConfigurationError", "(", "\n", "\"calculate_span_f1 is True, but no label_encoding was specified.\"", "\n", ")", "\n", "", "self", ".", "_f1_metric", "=", "SpanBasedF1Measure", "(", "\n", "vocab", ",", "tag_namespace", "=", "label_namespace", ",", "label_encoding", "=", "label_encoding", "\n", ")", "\n", "\n", "", "self", ".", "calculate_relation_f1", "=", "calculate_relation_f1", "\n", "if", "calculate_relation_f1", ":", "\n", "            ", "self", ".", "_relation_f1_metric", "=", "RelationMetric", "(", "\n", "vocab", ",", "tag_namespace", "=", "label_namespace", ",", "label_encoding", "=", "label_encoding", ",", "has_mode", "=", "has_mode", ",", "max_relation_width", "=", "max_relation_width", "\n", ")", "\n", "\n", "", "check_dimensions_match", "(", "\n", "text_field_embedder", ".", "get_output_dim", "(", ")", ",", "\n", "encoder", ".", "get_input_dim", "(", ")", ",", "\n", "\"text field embedding dim\"", ",", "\n", "\"encoder input dim\"", ",", "\n", ")", "\n", "if", "feedforward", "is", "not", "None", ":", "\n", "            ", "check_dimensions_match", "(", "\n", "encoder", ".", "get_output_dim", "(", ")", ",", "\n", "feedforward", ".", "get_input_dim", "(", ")", ",", "\n", "\"encoder output dim\"", ",", "\n", "\"feedforward input dim\"", ",", "\n", ")", "\n", "\n", "", "self", ".", "j", "=", "0", "\n", "initializer", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.get_predicted_spans": [[192, 206], ["enumerate", "isinstance", "enumerate", "tags.tolist.tolist.tolist", "isinstance", "x.detach", "ner_model.SequenceTagger.vocab.get_index_to_token_vocabulary"], "methods", ["None"], ["", "def", "get_predicted_spans", "(", "self", ",", "predicted_tags", ",", "logits", ")", ":", "\n", "        ", "class_probabilities", "=", "logits", "*", "0.0", "\n", "for", "i", ",", "instance_tags", "in", "enumerate", "(", "predicted_tags", ")", ":", "\n", "            ", "for", "j", ",", "tag_id", "in", "enumerate", "(", "instance_tags", ")", ":", "\n", "                ", "class_probabilities", "[", "i", ",", "j", ",", "tag_id", "]", "=", "1", "\n", "\n", "", "", "tags", "=", "(", "x", ".", "detach", "(", ")", "if", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", "else", "x", "for", "x", "in", "predicted_tags", ")", "\n", "\n", "if", "isinstance", "(", "tags", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "tags", "=", "tags", ".", "tolist", "(", ")", "\n", "\n", "", "bio_tags", "=", "[", "[", "self", ".", "vocab", ".", "get_index_to_token_vocabulary", "(", "self", ".", "label_namespace", ")", "[", "t", "]", "for", "t", "in", "batch", "]", "for", "batch", "in", "tags", "]", "\n", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.forward": [[207, 310], ["ner_model.SequenceTagger.text_field_embedder", "allennlp.get_text_field_mask", "ner_model.SequenceTagger.encoder", "allennlp.get_final_encoder_states", "ner_model.SequenceTagger.tag_projection_layer", "ner_model.SequenceTagger.crf.viterbi_tags", "typing.cast", "ner_model.SequenceTagger.dropout", "ner_model.SequenceTagger.dropout", "ner_model.SequenceTagger._feedforward", "ner_model.SequenceTagger.positional_encoding", "ner_model.SequenceTagger._attention", "ner_model.SequenceTagger.crf", "enumerate", "ner_model.SequenceTagger.vocab.get_token_index", "enumerate", "ner_model.SequenceTagger._f1_metric", "ner_model.SequenceTagger._relation_f1_metric"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_text_field_mask", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_final_encoder_states"], ["", "@", "overrides", "\n", "def", "forward", "(", "\n", "self", ",", "# type: ignore", "\n", "tokens", ":", "TextFieldTensors", ",", "\n", "tags", ":", "torch", ".", "LongTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "ignore_loss_on_o_tags", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "# to allow for a more general dataset reader that passes args we don't need", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "\n", "        ", "\"\"\"\n        # Parameters\n        tokens : `TextFieldTensors`, required\n            The output of `TextField.as_array()`, which should typically be passed directly to a\n            `TextFieldEmbedder`. This output is a dictionary mapping keys to `TokenIndexer`\n            tensors.  At its most basic, using a `SingleIdTokenIndexer` this is : `{\"tokens\":\n            Tensor(batch_size, num_tokens)}`. This dictionary will have the same keys as were used\n            for the `TokenIndexers` when you created the `TextField` representing your\n            sequence.  The dictionary is designed to be passed directly to a `TextFieldEmbedder`,\n            which knows how to combine different word representations into a single vector per\n            token in your input.\n        tags : `torch.LongTensor`, optional (default = `None`)\n            A torch tensor representing the sequence of integer gold class labels of shape\n            `(batch_size, num_tokens)`.\n        metadata : `List[Dict[str, Any]]`, optional, (default = `None`)\n            metadata containg the original words in the sentence to be tagged under a 'words' key.\n        ignore_loss_on_o_tags : `bool`, optional (default = `False`)\n            If True, we compute the loss only for actual spans in `tags`, and not on `O` tokens.\n            This is useful for computing gradients of the loss on a _single span_, for\n            interpretation / attacking.\n        # Returns\n        An output dictionary consisting of:\n        logits : `torch.FloatTensor`\n            The logits that are the output of the `tag_projection_layer`\n        mask : `torch.BoolTensor`\n            The text field mask for the input tokens\n        tags : `List[List[int]]`\n            The predicted tags using the Viterbi algorithm.\n        loss : `torch.FloatTensor`, optional\n            A scalar loss to be optimised. Only computed if gold label `tags` are provided.\n        \"\"\"", "\n", "self", ".", "dropout", ".", "training", "=", "self", ".", "training", "\n", "embedded_text_input", "=", "self", ".", "text_field_embedder", "(", "tokens", ")", "\n", "mask", "=", "util", ".", "get_text_field_mask", "(", "tokens", ")", "\n", "\n", "if", "self", ".", "dropout", ":", "\n", "            ", "embedded_text_input", "=", "self", ".", "dropout", "(", "embedded_text_input", ")", "\n", "\n", "", "encoded_text", "=", "self", ".", "encoder", "(", "embedded_text_input", ",", "mask", ")", "\n", "\n", "if", "self", ".", "dropout", ":", "\n", "            ", "encoded_text", "=", "self", ".", "dropout", "(", "encoded_text", ")", "\n", "\n", "", "if", "self", ".", "_feedforward", "is", "not", "None", ":", "\n", "            ", "encoded_text", "=", "self", ".", "_feedforward", "(", "encoded_text", ")", "\n", "\n", "", "h_n", "=", "util", ".", "get_final_encoder_states", "(", "encoded_text", ",", "mask", ",", "True", ")", "\n", "\n", "if", "self", ".", "use_positional_encoding", ":", "\n", "            ", "encoded_text", "=", "self", ".", "positional_encoding", "(", "encoded_text", ")", "\n", "\n", "", "if", "self", ".", "use_attention", ":", "\n", "            ", "encoded_text", "=", "self", ".", "_attention", "(", "encoded_text", ",", "h_n", ",", "encoded_text", ")", "\n", "\n", "", "logits", "=", "self", ".", "tag_projection_layer", "(", "encoded_text", ")", "\n", "best_paths", "=", "self", ".", "crf", ".", "viterbi_tags", "(", "logits", ",", "mask", ",", "top_k", "=", "self", ".", "top_k", ")", "\n", "\n", "# Just get the top tags and ignore the scores.", "\n", "predicted_tags", "=", "cast", "(", "List", "[", "List", "[", "int", "]", "]", ",", "[", "x", "[", "0", "]", "[", "0", "]", "for", "x", "in", "best_paths", "]", ")", "\n", "\n", "output", "=", "{", "\"logits\"", ":", "logits", ",", "\"mask\"", ":", "mask", ",", "\"tags\"", ":", "predicted_tags", "}", "\n", "\n", "if", "self", ".", "top_k", ">", "1", ":", "\n", "            ", "output", "[", "\"top_k_tags\"", "]", "=", "best_paths", "\n", "\n", "", "if", "tags", "is", "not", "None", ":", "\n", "            ", "if", "ignore_loss_on_o_tags", ":", "\n", "                ", "o_tag_index", "=", "self", ".", "vocab", ".", "get_token_index", "(", "\"O\"", ",", "namespace", "=", "self", ".", "label_namespace", ")", "\n", "crf_mask", "=", "mask", "&", "(", "tags", "!=", "o_tag_index", ")", "\n", "", "else", ":", "\n", "                ", "crf_mask", "=", "mask", "\n", "# Add negative log-likelihood as loss", "\n", "", "log_likelihood", "=", "self", ".", "crf", "(", "logits", ",", "tags", ",", "crf_mask", ")", "\n", "\n", "output", "[", "\"loss\"", "]", "=", "-", "log_likelihood", "\n", "\n", "# Represent viterbi tags as \"class probabilities\" that we can", "\n", "# feed into the metrics", "\n", "class_probabilities", "=", "logits", "*", "0.0", "\n", "for", "i", ",", "instance_tags", "in", "enumerate", "(", "predicted_tags", ")", ":", "\n", "                ", "for", "j", ",", "tag_id", "in", "enumerate", "(", "instance_tags", ")", ":", "\n", "                    ", "class_probabilities", "[", "i", ",", "j", ",", "tag_id", "]", "=", "1", "\n", "\n", "# for metric in self.metrics.values():", "\n", "#     metric(class_probabilities, tags, mask)", "\n", "", "", "if", "self", ".", "calculate_span_f1", ":", "\n", "                ", "self", ".", "_f1_metric", "(", "class_probabilities", ",", "tags", ",", "mask", ")", "\n", "", "if", "self", ".", "calculate_relation_f1", ":", "\n", "                ", "self", ".", "_relation_f1_metric", "(", "predicted_tags", ",", "mask", ",", "[", "m", "[", "\"relations\"", "]", "for", "m", "in", "metadata", "]", ")", "\n", "\n", "", "", "if", "metadata", "is", "not", "None", ":", "\n", "            ", "output", "[", "\"words\"", "]", "=", "[", "x", "[", "\"words\"", "]", "for", "x", "in", "metadata", "]", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.make_output_human_readable": [[311, 338], ["ner_model.SequenceTagger.make_output_human_readable.decode_tags"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "make_output_human_readable", "(", "\n", "self", ",", "output_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Converts the tag ids to the actual tags.\n        `output_dict[\"tags\"]` is a list of lists of tag_ids,\n        so we use an ugly nested list comprehension.\n        \"\"\"", "\n", "\n", "def", "decode_tags", "(", "tags", ")", ":", "\n", "            ", "return", "[", "\n", "self", ".", "vocab", ".", "get_token_from_index", "(", "tag", ",", "namespace", "=", "self", ".", "label_namespace", ")", "for", "tag", "in", "tags", "\n", "]", "\n", "\n", "", "def", "decode_top_k_tags", "(", "top_k_tags", ")", ":", "\n", "            ", "return", "[", "\n", "{", "\"tags\"", ":", "decode_tags", "(", "scored_path", "[", "0", "]", ")", ",", "\"score\"", ":", "scored_path", "[", "1", "]", "}", "\n", "for", "scored_path", "in", "top_k_tags", "\n", "]", "\n", "\n", "", "output_dict", "[", "\"tags\"", "]", "=", "[", "decode_tags", "(", "t", ")", "for", "t", "in", "output_dict", "[", "\"tags\"", "]", "]", "\n", "\n", "if", "\"top_k_tags\"", "in", "output_dict", ":", "\n", "            ", "output_dict", "[", "\"top_k_tags\"", "]", "=", "[", "decode_top_k_tags", "(", "t", ")", "for", "t", "in", "output_dict", "[", "\"top_k_tags\"", "]", "]", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_model.SequenceTagger.get_metrics": [[339, 360], ["metric.get_metric", "ner_model.SequenceTagger._f1_metric.get_metric", "ner_model.SequenceTagger._relation_f1_metric.get_metric", "ner_model.SequenceTagger.metrics.items", "metrics_to_return.update", "metrics_to_return.update", "metrics_to_return.update", "metrics_to_return.update", "ner_model.SequenceTagger.items", "ner_model.SequenceTagger.items"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "metrics_to_return", "=", "{", "\n", "metric_name", ":", "metric", ".", "get_metric", "(", "reset", ")", "for", "metric_name", ",", "metric", "in", "self", ".", "metrics", ".", "items", "(", ")", "\n", "}", "\n", "\n", "if", "self", ".", "calculate_span_f1", ":", "\n", "            ", "f1_dict", "=", "self", ".", "_f1_metric", ".", "get_metric", "(", "reset", "=", "reset", ")", "\n", "if", "self", ".", "_verbose_metrics", ":", "\n", "                ", "metrics_to_return", ".", "update", "(", "f1_dict", ")", "\n", "", "else", ":", "\n", "                ", "metrics_to_return", ".", "update", "(", "{", "x", ":", "y", "for", "x", ",", "y", "in", "f1_dict", ".", "items", "(", ")", "if", "\"overall\"", "in", "x", "}", ")", "\n", "\n", "", "", "if", "self", ".", "calculate_relation_f1", ":", "\n", "            ", "f1_dict", "=", "self", ".", "_relation_f1_metric", ".", "get_metric", "(", "reset", "=", "reset", ")", "\n", "if", "self", ".", "_verbose_metrics", ":", "\n", "                ", "metrics_to_return", ".", "update", "(", "f1_dict", ")", "\n", "", "else", ":", "\n", "                ", "metrics_to_return", ".", "update", "(", "{", "x", ":", "y", "for", "x", ",", "y", "in", "f1_dict", ".", "items", "(", ")", "if", "\"overall\"", "in", "x", "}", ")", "\n", "\n", "", "", "return", "metrics_to_return", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.__init__": [[16, 29], ["allennlp.data.DatasetReader.__init__", "allennlp.data.token_indexers.SingleIdTokenIndexer"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "max_span_width", ":", "int", ",", "\n", "token_indexers", ":", "Dict", "[", "str", ",", "TokenIndexer", "]", "=", "None", ",", "\n", "label_namespace", ":", "str", "=", "\"ner_labels\"", ",", "\n", "tag_label", ":", "str", "=", "\"ner\"", ",", "\n", "include_trigger", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "_max_span_width", "=", "max_span_width", "\n", "self", ".", "_token_indexers", "=", "token_indexers", "or", "{", "\"tokens\"", ":", "SingleIdTokenIndexer", "(", ")", "}", "\n", "self", ".", "label_namespace", "=", "label_namespace", "\n", "self", ".", "tag_label", "=", "tag_label", "\n", "self", ".", "include_trigger", "=", "include_trigger", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._read": [[30, 52], ["allennlp.common.file_utils.cached_path", "open", "srsly.json_loads", "smart_file.readlines", "allennlp.data.Token", "mare.label.extraction.extract_entities", "smart_span_reader.SpanBasedSmartReader.text_to_instance", "mare.label.extraction.extract_relations_from_smart_sample"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_entities", "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance", "home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample"], ["", "@", "overrides", "\n", "def", "_read", "(", "self", ",", "file_path", ":", "str", ")", ":", "\n", "# if `file_path` is a URL, redirect to the cache", "\n", "        ", "file_path", "=", "cached_path", "(", "file_path", ")", "\n", "\n", "with", "open", "(", "file_path", ",", "\"r\"", ")", "as", "smart_file", ":", "\n", "            ", "dataset", "=", "(", "srsly", ".", "json_loads", "(", "line", ")", "for", "line", "in", "smart_file", ".", "readlines", "(", ")", ")", "\n", "\n", "for", "sample", "in", "dataset", ":", "\n", "                ", "text", "=", "sample", "[", "\"text\"", "]", "\n", "words", "=", "[", "text", "[", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "tokens", "=", "[", "Token", "(", "w", ")", "for", "w", "in", "words", "]", "\n", "\n", "if", "self", ".", "tag_label", "==", "\"ner\"", ":", "\n", "                    ", "entities", "=", "extract_entities", "(", "sample", ")", "\n", "", "elif", "self", ".", "tag_label", "==", "\"relation\"", ":", "\n", "                    ", "relations", "=", "extract_relations_from_smart_sample", "(", "sample", ",", "include_trigger", "=", "self", ".", "include_trigger", ")", "\n", "entities", "=", "[", "e", "for", "relation", "in", "relations", "for", "e", "in", "relation", ".", "entities", "]", "\n", "\n", "", "yield", "self", ".", "text_to_instance", "(", "tokens", ",", "\n", "entities", "=", "entities", ",", "\n", "relations", "=", "relations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader.text_to_instance": [[53, 91], ["allennlp.data.fields.TextField", "allennlp.data.dataset_readers.dataset_utils.enumerate_spans", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.MetadataField", "allennlp.data.Instance", "spans.append", "smart_span_reader.SpanBasedSmartReader._too_long", "span_tuples.index", "allennlp.data.fields.SpanField", "allennlp.data.fields.MultiLabelField"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long", "home.repos.pwc.inspect_result.mslars_mare.fields.adjacency_field_assym.AdjacencyFieldAssym.index"], ["", "", "", "def", "text_to_instance", "(", "self", ",", "\n", "tokens", ":", "List", "[", "Token", "]", ",", "\n", "entities", ":", "List", "=", "None", ",", "\n", "relations", ":", "List", "=", "None", ")", "->", "Instance", ":", "\n", "        ", "sequence", "=", "TextField", "(", "tokens", ",", "self", ".", "_token_indexers", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", "}", "\n", "words", "=", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "\n", "spans", "=", "[", "]", "\n", "for", "start", ",", "end", "in", "enumerate_spans", "(", "words", ",", "max_span_width", "=", "self", ".", "_max_span_width", ")", ":", "\n", "            ", "assert", "start", ">=", "0", "\n", "assert", "end", ">=", "0", "\n", "spans", ".", "append", "(", "SpanField", "(", "start", ",", "end", ",", "sequence", ")", ")", "\n", "\n", "\n", "", "span_field", "=", "ListField", "(", "spans", ")", "\n", "span_tuples", "=", "[", "(", "span", ".", "span_start", ",", "span", ".", "span_end", ")", "for", "span", "in", "spans", "]", "\n", "instance_fields", "[", "\"spans\"", "]", "=", "span_field", "\n", "\n", "ner_labels", "=", "[", "[", "]", "for", "i", "in", "span_tuples", "]", "\n", "\n", "ner_list", "=", "[", "(", "(", "e", ".", "start", ",", "e", ".", "end", ")", ",", "e", ".", "role", ")", "for", "e", "in", "entities", "]", "\n", "\n", "for", "span", ",", "label", "in", "ner_list", ":", "\n", "            ", "if", "self", ".", "_too_long", "(", "span", ")", ":", "\n", "                ", "continue", "\n", "", "ix", "=", "span_tuples", ".", "index", "(", "span", ")", "\n", "# if \"\" in ner_labels[ix]:", "\n", "#     ner_labels[ix].remove(\"\")", "\n", "\n", "ner_labels", "[", "ix", "]", "+=", "[", "label", "]", "\n", "\n", "", "instance_fields", "[", "\"ner_labels\"", "]", "=", "ListField", "(", "\n", "[", "MultiLabelField", "(", "entry", ",", "label_namespace", "=", "self", ".", "label_namespace", ")", "for", "entry", "in", "ner_labels", "]", ")", "\n", "\n", "metadata", "=", "{", "\"words\"", ":", "words", ",", "\"relations\"", ":", "relations", "}", "\n", "instance_fields", "[", "\"metadata\"", "]", "=", "MetadataField", "(", "metadata", ")", "\n", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.smart_span_reader.SpanBasedSmartReader._too_long": [[92, 94], ["None"], "methods", ["None"], ["", "def", "_too_long", "(", "self", ",", "span", ")", ":", "\n", "        ", "return", "span", "[", "1", "]", "-", "span", "[", "0", "]", "+", "1", ">", "self", ".", "_max_span_width", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.__init__": [[39, 87], ["allennlp.nn.InitializerApplicator", "allennlp.models.model.Model.__init__", "vocab.get_token_to_index_vocabulary", "ner_span_based.NERTagger.vocab.get_vocab_size", "torch.nn.ModuleDict", "torch.nn.Sequential", "mare.metric.RelationMetric", "mare.ner_metric.NERMetrics", "mare.metric.SpanRelationMetric", "torch.nn.BCEWithLogitsLoss", "initializer", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "torch.nn.Linear", "feedforward.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "text_field_embedder", ":", "TextFieldEmbedder", ",", "\n", "span_extractor", ":", "SpanExtractor", ",", "\n", "feedforward", ":", "FeedForward", ",", "\n", "ner_threshold", ":", "float", "=", "0.65", ",", "\n", "max_inner_range", ":", "float", "=", "18", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "label_namespace", ":", "str", "=", "\"ner_labels\"", ",", "\n", "regularizer", ":", "Optional", "[", "RegularizerApplicator", "]", "=", "None", ",", "\n", "initializer", ":", "InitializerApplicator", "=", "InitializerApplicator", "(", ")", ")", "->", "None", ":", "\n", "        ", "super", "(", "NERTagger", ",", "self", ")", ".", "__init__", "(", "vocab", ",", "regularizer", ")", "\n", "\n", "self", ".", "_include_trigger", "=", "False", "\n", "for", "label", "in", "vocab", ".", "get_token_to_index_vocabulary", "(", "label_namespace", ")", ":", "\n", "            ", "if", "\"trigger\"", "in", "label", ":", "\n", "                ", "self", ".", "_include_trigger", "=", "True", "\n", "\n", "", "", "self", ".", "label_namespace", "=", "label_namespace", "\n", "self", ".", "_n_labels", "=", "self", ".", "vocab", ".", "get_vocab_size", "(", "label_namespace", ")", "\n", "\n", "# null_label = vocab.get_token_index(\"\", label_namespace)", "\n", "# assert null_label == 0", "\n", "\n", "self", ".", "_ner_threshold", "=", "ner_threshold", "\n", "self", ".", "_max_inner_range", "=", "max_inner_range", "\n", "self", ".", "_ner_scorer", "=", "torch", ".", "nn", ".", "ModuleDict", "(", ")", "\n", "\n", "self", ".", "_text_field_embedder", "=", "text_field_embedder", "\n", "\n", "self", ".", "_span_extractor", "=", "span_extractor", "\n", "\n", "self", ".", "_ner_scorer", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "TimeDistributed", "(", "feedforward", ")", ",", "\n", "TimeDistributed", "(", "torch", ".", "nn", ".", "Linear", "(", "\n", "feedforward", ".", "get_output_dim", "(", ")", ",", "\n", "self", ".", "_n_labels", ")", ")", ")", "\n", "\n", "self", ".", "_relation_f1_metric", "=", "RelationMetric", "(", "\n", "vocab", ",", "tag_namespace", "=", "label_namespace", ",", "\n", ")", "\n", "\n", "self", ".", "_ner_metric", "=", "NERMetrics", "(", "self", ".", "_n_labels", ")", "\n", "self", ".", "_relation_metric", "=", "SpanRelationMetric", "(", ")", "\n", "\n", "self", ".", "_loss", "=", "torch", ".", "nn", ".", "BCEWithLogitsLoss", "(", "reduction", "=", "\"sum\"", ")", "\n", "\n", "initializer", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.forward": [[88, 141], ["allennlp.nn.util.get_text_field_mask", "span_mask.unsqueeze.sum().long", "ner_span_based.NERTagger._text_field_embedder", "ner_span_based.NERTagger._span_extractor", "ner_span_based.NERTagger._ner_scorer", "span_mask.unsqueeze", "allennlp.nn.util.replace_masked_values", "torch.sigmoid", "ner_span_based.NERTagger.extract_relations", "span_mask.unsqueeze.bool", "ner_span_based.NERTagger._ner_metric", "ner_span_based.NERTagger._relation_metric", "ner_span_based.NERTagger._loss", "span_mask.unsqueeze.sum", "ner_labels.float"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_text_field_mask", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values", "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.extract_relations"], ["", "@", "overrides", "\n", "def", "forward", "(", "self", ",", "# type: ignore", "\n", "tokens", ":", "TextFieldTensors", ",", "\n", "spans", ":", "torch", ".", "IntTensor", ",", "\n", "ner_labels", ":", "torch", ".", "IntTensor", "=", "None", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "\n", "        ", "mask", "=", "util", ".", "get_text_field_mask", "(", "tokens", ")", "\n", "span_mask", "=", "(", "spans", "[", ":", ",", ":", ",", "0", "]", ">=", "0", ")", "\n", "sentence_lengths", "=", "mask", ".", "sum", "(", "dim", "=", "1", ")", ".", "long", "(", ")", "\n", "\n", "embedded_text_input", "=", "self", ".", "_text_field_embedder", "(", "tokens", ")", "\n", "span_embeddings", "=", "self", ".", "_span_extractor", "(", "embedded_text_input", ",", "spans", ",", "span_mask", ")", "\n", "\n", "# cls_h = embedded_text_input[:, 0, :].unsqueeze(1).repeat(1, span_embeddings.shape[1], 1)", "\n", "\n", "# span_vectors = torch.cat((span_embeddings, cls_h), dim=2)", "\n", "\n", "span_vectors", "=", "span_embeddings", "\n", "\n", "# 32, 90, 1000", "\n", "ner_scores", "=", "self", ".", "_ner_scorer", "(", "span_vectors", ")", "\n", "# Give large negative scores to masked-out elements.", "\n", "mask", "=", "span_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "ner_scores", "=", "util", ".", "replace_masked_values", "(", "ner_scores", ",", "mask", ".", "bool", "(", ")", ",", "-", "1e20", ")", "\n", "# The dummy_scores are the score for the null label.", "\n", "# dummy_dims = [ner_scores.size(0), ner_scores.size(1), 1]", "\n", "# dummy_scores = ner_scores.new_zeros(*dummy_dims)", "\n", "# ner_scores_logits = torch.cat((dummy_scores, ner_scores), -1)", "\n", "\n", "ner_scores_probs", "=", "torch", ".", "sigmoid", "(", "ner_scores", ")", "\n", "\n", "# predictions = self.predict(ner_scores.detach().cpu(),", "\n", "#                            spans.detach().cpu(),", "\n", "#                            span_mask.detach().cpu(),", "\n", "#                            metadata)", "\n", "#", "\n", "# output_dict = {\"predictions\": predictions}", "\n", "\n", "relations", "=", "self", ".", "extract_relations", "(", "spans", ",", "ner_scores_probs", ")", "\n", "\n", "output_dict", "=", "{", "\"relations\"", ":", "relations", "}", "\n", "\n", "if", "ner_labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "_ner_metric", "(", "ner_scores_probs", ",", "ner_labels", ",", "span_mask", ")", "\n", "\n", "self", ".", "_relation_metric", "(", "relations", ",", "[", "m", "[", "\"relations\"", "]", "for", "m", "in", "metadata", "]", ")", "\n", "\n", "loss", "=", "self", ".", "_loss", "(", "ner_scores", ",", "ner_labels", ".", "float", "(", ")", ")", "\n", "\n", "output_dict", "[", "\"loss\"", "]", "=", "loss", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.extract_relations": [[142, 166], ["range", "torch.nonzero", "[].squeeze().argmax().tolist", "[].squeeze().tolist", "zip", "len", "ner_span_based.NERTagger.vocab.get_token_from_index", "mare.label.extraction.transform_spans_to_relation", "[].squeeze().argmax", "[].squeeze", "[].squeeze"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_spans_to_relation"], ["", "def", "extract_relations", "(", "self", ",", "spans", ",", "predicted_ner", ")", ":", "\n", "        ", "num_batches", "=", "spans", ".", "shape", "[", "0", "]", "\n", "result", "=", "[", "]", "\n", "for", "batch", "in", "range", "(", "num_batches", ")", ":", "\n", "            ", "span_containing_ent", "=", "(", "predicted_ner", "[", "batch", "]", ">", "self", ".", "_ner_threshold", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "entity_span_idx", "=", "torch", ".", "nonzero", "(", "span_containing_ent", ")", "\n", "if", "len", "(", "entity_span_idx", ")", "==", "0", ":", "\n", "                ", "result", "+=", "[", "[", "]", "]", "\n", "continue", "\n", "", "entity_labels", "=", "predicted_ner", "[", "batch", "]", "[", "entity_span_idx", "]", ".", "squeeze", "(", "1", ")", ".", "argmax", "(", "axis", "=", "1", ")", ".", "tolist", "(", ")", "\n", "entity_spans", "=", "spans", "[", "batch", "]", "[", "entity_span_idx", "]", ".", "squeeze", "(", "1", ")", ".", "tolist", "(", ")", "\n", "\n", "batch_spans", "=", "[", "]", "\n", "\n", "for", "span_tuple", ",", "label_idx", "in", "zip", "(", "entity_spans", ",", "entity_labels", ")", ":", "\n", "                ", "label", "=", "self", ".", "vocab", ".", "get_token_from_index", "(", "label_idx", ",", "namespace", "=", "self", ".", "label_namespace", ")", "\n", "\n", "batch_spans", "+=", "[", "(", "label", ",", "(", "span_tuple", "[", "0", "]", ",", "span_tuple", "[", "1", "]", ")", ")", "]", "\n", "\n", "", "result", "+=", "[", "\n", "transform_spans_to_relation", "(", "batch_spans", ",", "max_inner_range", "=", "self", ".", "_max_inner_range", ",", "allow_overlaps", "=", "True", ",", "\n", "include_trigger", "=", "self", ".", "_include_trigger", ")", "]", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.ner_span_based.NERTagger.get_metrics": [[195, 214], ["ner_span_based.NERTagger._ner_metric.get_metric", "res.update", "ner_span_based.NERTagger._relation_metric.get_metric", "res.update"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric"], ["", "@", "overrides", "\n", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "\"Loop over the metrics for all namespaces, and return as dict.\"", "\n", "res", "=", "{", "}", "\n", "precision", ",", "recall", ",", "f1", "=", "self", ".", "_ner_metric", ".", "get_metric", "(", "reset", ")", "\n", "prefix", "=", "\"span_ner_\"", "\n", "to_update", "=", "{", "f\"{prefix}_precision\"", ":", "precision", ",", "\n", "f\"{prefix}_recall\"", ":", "recall", ",", "\n", "f\"{prefix}_f1\"", ":", "f1", "}", "\n", "res", ".", "update", "(", "to_update", ")", "\n", "\n", "precision", ",", "recall", ",", "f1", "=", "self", ".", "_relation_metric", ".", "get_metric", "(", "reset", ")", "\n", "prefix", "=", "\"relation\"", "\n", "to_update", "=", "{", "f\"{prefix}_precision\"", ":", "precision", ",", "\n", "f\"{prefix}_recall\"", ":", "recall", ",", "\n", "f\"{prefix}_f1\"", ":", "f1", "}", "\n", "res", ".", "update", "(", "to_update", ")", "\n", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.SpanRelationMetric.__init__": [[22, 33], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "ignore_classes", ":", "List", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "self", ".", "_ignore_classes", ":", "List", "[", "str", "]", "=", "ignore_classes", "or", "[", "]", "\n", "\n", "# These will hold per label span counts.", "\n", "self", ".", "_true_positives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_positives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_negatives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.SpanRelationMetric.__call__": [[34, 54], ["enumerate", "set", "set.remove"], "methods", ["None"], ["", "def", "__call__", "(", "\n", "self", ",", "\n", "predicted_batches", ",", "\n", "gold_batches", "\n", ")", ":", "\n", "\n", "        ", "for", "i", ",", "predicted_relations", "in", "enumerate", "(", "predicted_batches", ")", ":", "\n", "\n", "            ", "gold_relations", "=", "set", "(", "gold_batches", "[", "i", "]", ")", "\n", "\n", "for", "p_rel", "in", "predicted_relations", ":", "\n", "                ", "if", "p_rel", "in", "gold_relations", ":", "\n", "                    ", "self", ".", "_true_positives", "[", "p_rel", ".", "label", "]", "+=", "1", "\n", "gold_relations", ".", "remove", "(", "p_rel", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "_false_positives", "[", "p_rel", ".", "label", "]", "+=", "1", "\n", "\n", "", "", "for", "g_rel", "in", "gold_relations", ":", "\n", "                ", "self", ".", "_false_negatives", "[", "g_rel", ".", "label", "]", "+=", "1", "\n", "", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.SpanRelationMetric.get_metric": [[55, 99], ["allennlp.common.util.is_distributed", "set", "all_tags.update", "all_tags.update", "all_tags.update", "metric.SpanRelationMetric._compute_metrics", "RuntimeError", "metric.SpanRelationMetric._true_positives.keys", "metric.SpanRelationMetric._false_positives.keys", "metric.SpanRelationMetric._false_negatives.keys", "sum", "sum", "sum", "metric.SpanRelationMetric.reset", "metric.SpanRelationMetric._true_positives.values", "metric.SpanRelationMetric._false_positives.values", "metric.SpanRelationMetric._false_negatives.values"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric._compute_metrics", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "", "def", "get_metric", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        # Returns\n        `Dict[str, float]`\n            A Dict per label containing following the span based metrics:\n            - precision : `float`\n            - recall : `float`\n            - f1-measure : `float`\n            Additionally, an `overall` key is included, which provides the precision,\n            recall and f1-measure for all spans.\n        \"\"\"", "\n", "if", "is_distributed", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"Distributed aggregation for SpanBasedF1Measure is currently not supported.\"", "\n", ")", "\n", "", "all_tags", ":", "Set", "[", "str", "]", "=", "set", "(", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_true_positives", ".", "keys", "(", ")", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_false_positives", ".", "keys", "(", ")", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_false_negatives", ".", "keys", "(", ")", ")", "\n", "all_metrics", "=", "{", "}", "\n", "# for tag in all_tags:", "\n", "#     precision, recall, f1_measure = self._compute_metrics(", "\n", "#         self._true_positives[tag], self._false_positives[tag], self._false_negatives[tag]", "\n", "#     )", "\n", "#     precision_key = \"precision\" + \"-\" + tag", "\n", "#     recall_key = \"recall\" + \"-\" + tag", "\n", "#     f1_key = \"FR-\" + \"-\" + tag", "\n", "#     all_metrics[precision_key] = precision", "\n", "#     all_metrics[recall_key] = recall", "\n", "#     all_metrics[f1_key] = f1_measure", "\n", "\n", "# Compute the precision, recall and f1 for all spans jointly.", "\n", "precision", ",", "recall", ",", "f1_measure", "=", "self", ".", "_compute_metrics", "(", "\n", "sum", "(", "self", ".", "_true_positives", ".", "values", "(", ")", ")", ",", "\n", "sum", "(", "self", ".", "_false_positives", ".", "values", "(", ")", ")", ",", "\n", "sum", "(", "self", ".", "_false_negatives", ".", "values", "(", ")", ")", ",", "\n", ")", "\n", "\n", "all_metrics", "[", "\"PR-overall\"", "]", "=", "precision", "\n", "all_metrics", "[", "\"RR-overall\"", "]", "=", "recall", "\n", "all_metrics", "[", "\"FR-overall\"", "]", "=", "f1_measure", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "", "return", "precision", ",", "recall", ",", "f1_measure", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.SpanRelationMetric._compute_metrics": [[100, 106], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_metrics", "(", "true_positives", ":", "int", ",", "false_positives", ":", "int", ",", "false_negatives", ":", "int", ")", ":", "\n", "        ", "precision", "=", "true_positives", "/", "(", "true_positives", "+", "false_positives", "+", "1e-13", ")", "\n", "recall", "=", "true_positives", "/", "(", "true_positives", "+", "false_negatives", "+", "1e-13", ")", "\n", "f1_measure", "=", "2.0", "*", "(", "precision", "*", "recall", ")", "/", "(", "precision", "+", "recall", "+", "1e-13", ")", "\n", "return", "precision", ",", "recall", ",", "f1_measure", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.SpanRelationMetric.reset": [[107, 111], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_true_positives", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_positives", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_negatives", "=", "defaultdict", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric.__init__": [[127, 191], ["vocabulary.get_index_to_token_vocabulary", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "vocabulary", ":", "Vocabulary", ",", "\n", "tag_namespace", ":", "str", "=", "\"tags\"", ",", "\n", "ignore_classes", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "label_encoding", ":", "Optional", "[", "str", "]", "=", "\"BIO\"", ",", "\n", "has_mode", ":", "bool", "=", "False", ",", "\n", "tags_to_spans_function", ":", "Optional", "[", "TAGS_TO_SPANS_FUNCTION_TYPE", "]", "=", "None", ",", "\n", "max_relation_width", ":", "int", "=", "11", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        # Parameters\n        vocabulary : `Vocabulary`, required.\n            A vocabulary containing the tag namespace.\n        tag_namespace : `str`, required.\n            This metric assumes that a BIO format is used in which the\n            labels are of the format: [\"B-LABEL\", \"I-LABEL\"].\n        ignore_classes : `List[str]`, optional.\n            Span labels which will be ignored when computing span metrics.\n            A \"span label\" is the part that comes after the BIO label, so it\n            would be \"ARG1\" for the tag \"B-ARG1\". For example by passing:\n             `ignore_classes=[\"V\"]`\n            the following sequence would not consider the \"V\" span at index (2, 3)\n            when computing the precision, recall and F1 metrics.\n            [\"O\", \"O\", \"B-V\", \"I-V\", \"B-ARG1\", \"I-ARG1\"]\n            This is helpful for instance, to avoid computing metrics for \"V\"\n            spans in a BIO tagging scheme which are typically not included.\n        label_encoding : `str`, optional (default = `\"BIO\"`)\n            The encoding used to specify label span endpoints in the sequence.\n            Valid options are \"BIO\", \"IOB1\", \"BIOUL\" or \"BMES\".\n        tags_to_spans_function : `Callable`, optional (default = `None`)\n            If `label_encoding` is `None`, `tags_to_spans_function` will be\n            used to generate spans.\n        \"\"\"", "\n", "if", "label_encoding", "and", "tags_to_spans_function", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\n", "\"Both label_encoding and tags_to_spans_function are provided. \"", "\n", "'Set \"label_encoding=None\" explicitly to enable tags_to_spans_function.'", "\n", ")", "\n", "", "if", "label_encoding", ":", "\n", "            ", "if", "label_encoding", "not", "in", "[", "\"BIO\"", ",", "\"IOB1\"", ",", "\"BIOUL\"", ",", "\"BMES\"", "]", ":", "\n", "                ", "raise", "ConfigurationError", "(", "\n", "\"Unknown label encoding - expected 'BIO', 'IOB1', 'BIOUL', 'BMES'.\"", "\n", ")", "\n", "", "", "elif", "tags_to_spans_function", "is", "None", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\n", "\"At least one of the (label_encoding, tags_to_spans_function) should be provided.\"", "\n", ")", "\n", "\n", "", "self", ".", "_label_encoding", "=", "label_encoding", "\n", "self", ".", "_tags_to_spans_function", "=", "tags_to_spans_function", "\n", "self", ".", "_label_vocabulary", "=", "vocabulary", ".", "get_index_to_token_vocabulary", "(", "tag_namespace", ")", "\n", "self", ".", "_ignore_classes", ":", "List", "[", "str", "]", "=", "ignore_classes", "or", "[", "]", "\n", "\n", "# These will hold per label span counts.", "\n", "self", ".", "_true_positives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_positives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_negatives", ":", "Dict", "[", "str", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "\n", "self", ".", "vocab", "=", "vocabulary", "\n", "\n", "self", ".", "has_mode", "=", "has_mode", "\n", "\n", "self", ".", "max_relation_width", "=", "max_relation_width", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric.__call__": [[192, 248], ["metric.RelationMetric.detach_tensors", "isinstance", "enumerate", "torch.ones_like().bool", "tags.tolist.tolist.tolist", "mare.label.extraction.transform_tags_to_relation", "set", "torch.ones_like", "set.remove"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation"], ["", "def", "__call__", "(", "\n", "self", ",", "\n", "tags", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "Optional", "[", "torch", ".", "BoolTensor", "]", "=", "None", ",", "\n", "correct_rels", ":", "Optional", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        # Parameters\n        predictions : `torch.Tensor`, required.\n            A tensor of predictions of shape (batch_size, sequence_length, num_classes).\n        gold_labels : `torch.Tensor`, required.\n            A tensor of integer class label of shape (batch_size, sequence_length). It must be the same\n            shape as the `predictions` tensor without the `num_classes` dimension.\n        mask : `torch.BoolTensor`, optional (default = `None`).\n            A masking tensor the same size as `gold_labels`.\n        prediction_map : `torch.Tensor`, optional (default = `None`).\n            A tensor of size (batch_size, num_classes) which provides a mapping from the index of predictions\n            to the indices of the label vocabulary. If provided, the output label at each timestep will be\n            `vocabulary.get_index_to_token_vocabulary(prediction_map[batch, argmax(predictions[batch, t]))`,\n            rather than simply `vocabulary.get_index_to_token_vocabulary(argmax(predictions[batch, t]))`.\n            This is useful in cases where each Instance in the dataset is associated with a different possible\n            subset of labels from a large label-space (IE FrameNet, where each frame has a different set of\n            possible roles associated with it).\n        \"\"\"", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "ones_like", "(", "tags", ")", ".", "bool", "(", ")", "\n", "\n", "", "prediction_map", "=", "None", "\n", "\n", "tags", ",", "mask", "=", "self", ".", "detach_tensors", "(", "\n", "tags", ",", "mask", "\n", ")", "\n", "if", "isinstance", "(", "tags", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "tags", "=", "tags", ".", "tolist", "(", ")", "\n", "\n", "", "bio_tags", "=", "[", "[", "self", ".", "_label_vocabulary", "[", "t", "]", "for", "t", "in", "batch", "]", "for", "batch", "in", "tags", "]", "\n", "\n", "# Iterate over timesteps in batch.", "\n", "# batch_size = gold_labels.size(0)", "\n", "# TODO Weiche Entit\u00e4tsgrenzen erlauben (Wie auch im original Paper)", "\n", "# zip bio tags and correct rels", "\n", "for", "i", ",", "predicted_tags", "in", "enumerate", "(", "bio_tags", ")", ":", "\n", "            ", "predicted_relations", "=", "transform_tags_to_relation", "(", "predicted_tags", ",", "max_inner_range", "=", "self", ".", "max_relation_width", ",", "has_mode", "=", "self", ".", "has_mode", ")", "\n", "\n", "gold_relations", "=", "set", "(", "correct_rels", "[", "i", "]", ")", "\n", "\n", "for", "p_rel", "in", "predicted_relations", ":", "\n", "                ", "if", "p_rel", "in", "gold_relations", ":", "\n", "                    ", "self", ".", "_true_positives", "[", "p_rel", ".", "label", "]", "+=", "1", "\n", "gold_relations", ".", "remove", "(", "p_rel", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "_false_positives", "[", "p_rel", ".", "label", "]", "+=", "1", "\n", "\n", "", "", "for", "g_rel", "in", "gold_relations", ":", "\n", "                ", "self", ".", "_false_negatives", "[", "g_rel", ".", "label", "]", "+=", "1", "\n", "", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric._handle_continued_spans": [[249, 282], ["set", "list", "min", "max", "span_set.difference_update", "span_set.add", "label.startswith"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_handle_continued_spans", "(", "spans", ":", "List", "[", "TypedStringSpan", "]", ")", "->", "List", "[", "TypedStringSpan", "]", ":", "\n", "        ", "\"\"\"\n        The official CONLL 2012 evaluation script for SRL treats continued spans (i.e spans which\n        have a `C-` prepended to another valid tag) as part of the span that they are continuing.\n        This is basically a massive hack to allow SRL models which produce a linear sequence of\n        predictions to do something close to structured prediction. However, this means that to\n        compute the metric, these continuation spans need to be merged into the span to which\n        they refer. The way this is done is to simply consider the span for the continued argument\n        to start at the start index of the first occurrence of the span and end at the end index\n        of the last occurrence of the span. Handling this is important, because predicting continued\n        spans is difficult and typically will effect overall average F1 score by ~ 2 points.\n        # Parameters\n        spans : `List[TypedStringSpan]`, required.\n            A list of (label, (start, end)) spans.\n        # Returns\n        A `List[TypedStringSpan]` with continued arguments replaced with a single span.\n        \"\"\"", "\n", "span_set", ":", "Set", "[", "TypedStringSpan", "]", "=", "set", "(", "spans", ")", "\n", "continued_labels", ":", "List", "[", "str", "]", "=", "[", "\n", "label", "[", "2", ":", "]", "for", "(", "label", ",", "span", ")", "in", "span_set", "if", "label", ".", "startswith", "(", "\"C-\"", ")", "\n", "]", "\n", "for", "label", "in", "continued_labels", ":", "\n", "            ", "continued_spans", "=", "{", "span", "for", "span", "in", "span_set", "if", "label", "in", "span", "[", "0", "]", "}", "\n", "\n", "span_start", "=", "min", "(", "span", "[", "1", "]", "[", "0", "]", "for", "span", "in", "continued_spans", ")", "\n", "span_end", "=", "max", "(", "span", "[", "1", "]", "[", "1", "]", "for", "span", "in", "continued_spans", ")", "\n", "replacement_span", ":", "TypedStringSpan", "=", "(", "label", ",", "(", "span_start", ",", "span_end", ")", ")", "\n", "\n", "span_set", ".", "difference_update", "(", "continued_spans", ")", "\n", "span_set", ".", "add", "(", "replacement_span", ")", "\n", "\n", "", "return", "list", "(", "span_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric.get_metric": [[283, 327], ["allennlp.common.util.is_distributed", "set", "all_tags.update", "all_tags.update", "all_tags.update", "metric.RelationMetric._compute_metrics", "RuntimeError", "metric.RelationMetric._true_positives.keys", "metric.RelationMetric._false_positives.keys", "metric.RelationMetric._false_negatives.keys", "metric.RelationMetric._compute_metrics", "sum", "sum", "sum", "metric.RelationMetric.reset", "metric.RelationMetric._true_positives.values", "metric.RelationMetric._false_positives.values", "metric.RelationMetric._false_negatives.values"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric._compute_metrics", "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric._compute_metrics", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset"], ["", "def", "get_metric", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        # Returns\n        `Dict[str, float]`\n            A Dict per label containing following the span based metrics:\n            - precision : `float`\n            - recall : `float`\n            - f1-measure : `float`\n            Additionally, an `overall` key is included, which provides the precision,\n            recall and f1-measure for all spans.\n        \"\"\"", "\n", "if", "is_distributed", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"Distributed aggregation for SpanBasedF1Measure is currently not supported.\"", "\n", ")", "\n", "", "all_tags", ":", "Set", "[", "str", "]", "=", "set", "(", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_true_positives", ".", "keys", "(", ")", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_false_positives", ".", "keys", "(", ")", ")", "\n", "all_tags", ".", "update", "(", "self", ".", "_false_negatives", ".", "keys", "(", ")", ")", "\n", "all_metrics", "=", "{", "}", "\n", "for", "tag", "in", "all_tags", ":", "\n", "            ", "precision", ",", "recall", ",", "f1_measure", "=", "self", ".", "_compute_metrics", "(", "\n", "self", ".", "_true_positives", "[", "tag", "]", ",", "self", ".", "_false_positives", "[", "tag", "]", ",", "self", ".", "_false_negatives", "[", "tag", "]", "\n", ")", "\n", "precision_key", "=", "\"precision\"", "+", "\"-\"", "+", "tag", "\n", "recall_key", "=", "\"recall\"", "+", "\"-\"", "+", "tag", "\n", "f1_key", "=", "\"FR-\"", "+", "\"-\"", "+", "tag", "\n", "all_metrics", "[", "precision_key", "]", "=", "precision", "\n", "all_metrics", "[", "recall_key", "]", "=", "recall", "\n", "all_metrics", "[", "f1_key", "]", "=", "f1_measure", "\n", "\n", "# Compute the precision, recall and f1 for all spans jointly.", "\n", "", "precision", ",", "recall", ",", "f1_measure", "=", "self", ".", "_compute_metrics", "(", "\n", "sum", "(", "self", ".", "_true_positives", ".", "values", "(", ")", ")", ",", "\n", "sum", "(", "self", ".", "_false_positives", ".", "values", "(", ")", ")", ",", "\n", "sum", "(", "self", ".", "_false_negatives", ".", "values", "(", ")", ")", ",", "\n", ")", "\n", "\n", "all_metrics", "[", "\"PR-overall\"", "]", "=", "precision", "\n", "all_metrics", "[", "\"RR-overall\"", "]", "=", "recall", "\n", "all_metrics", "[", "\"FR-overall\"", "]", "=", "f1_measure", "\n", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "", "return", "all_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric._compute_metrics": [[328, 334], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_metrics", "(", "true_positives", ":", "int", ",", "false_positives", ":", "int", ",", "false_negatives", ":", "int", ")", ":", "\n", "        ", "precision", "=", "true_positives", "/", "(", "true_positives", "+", "false_positives", "+", "1e-13", ")", "\n", "recall", "=", "true_positives", "/", "(", "true_positives", "+", "false_negatives", "+", "1e-13", ")", "\n", "f1_measure", "=", "2.0", "*", "(", "precision", "*", "recall", ")", "/", "(", "precision", "+", "recall", "+", "1e-13", ")", "\n", "return", "precision", ",", "recall", ",", "f1_measure", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.metric.RelationMetric.reset": [[335, 339], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_true_positives", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_positives", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "_false_negatives", "=", "defaultdict", "(", "int", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div": [[6, 11], ["None"], "function", ["None"], ["def", "safe_div", "(", "num", ",", "denom", ")", ":", "\n", "    ", "if", "denom", ">", "0", ":", "\n", "        ", "return", "num", "/", "denom", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.f1.compute_f1": [[13, 18], ["f1.safe_div", "f1.safe_div", "f1.safe_div"], "function", ["home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div", "home.repos.pwc.inspect_result.mslars_mare.mare.f1.safe_div"], ["", "", "def", "compute_f1", "(", "predicted", ",", "gold", ",", "matched", ")", ":", "\n", "    ", "precision", "=", "safe_div", "(", "matched", ",", "predicted", ")", "\n", "recall", "=", "safe_div", "(", "matched", ",", "gold", ")", "\n", "f1", "=", "safe_div", "(", "2", "*", "precision", "*", "recall", ",", "precision", "+", "recall", ")", "\n", "return", "precision", ",", "recall", ",", "f1", "\n", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._json_to_instance": [[14, 23], ["allennlp.data.fields.TextField", "allennlp.data.Instance", "allennlp.data.Token", "allennlp.data.fields.MetadataField"], "methods", ["None"], ["    ", "def", "_json_to_instance", "(", "self", ",", "json_dict", ":", "JsonDict", ")", "->", "Instance", ":", "\n", "        ", "tokens", "=", "[", "Token", "(", "t", ")", "for", "t", "in", "json_dict", "[", "\"tokens\"", "]", "]", "\n", "# Attribut (_dataset_reader._token_indexers ) wird durch unseren DataReader hinzugef\u00fcgt!", "\n", "# Nicht allgemein g\u00fcltig...", "\n", "token_indexers", "=", "self", ".", "_dataset_reader", ".", "_token_indexers", "\n", "sequence", "=", "TextField", "(", "tokens", ",", "token_indexers", "=", "token_indexers", ")", "\n", "instance_fields", ":", "Dict", "[", "str", ",", "Field", "]", "=", "{", "\"tokens\"", ":", "sequence", ",", "\n", "\"metadata\"", ":", "MetadataField", "(", "{", "\"words\"", ":", "[", "x", ".", "text", "for", "x", "in", "tokens", "]", "}", ")", "}", "\n", "return", "Instance", "(", "instance_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.transform_relations_to_format": [[24, 38], ["result[].append", "ents.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "transform_relations_to_format", "(", "relations", ")", "->", "JsonDict", ":", "\n", "        ", "result", "=", "{", "\"relations\"", ":", "[", "]", "}", "\n", "for", "rel", "in", "relations", ":", "\n", "            ", "rel_name", "=", "rel", ".", "label", "\n", "ents", "=", "[", "]", "\n", "for", "span", "in", "rel", ".", "spans", ":", "\n", "                ", "start", "=", "span", ".", "span", "[", "0", "]", "\n", "end", "=", "span", ".", "span", "[", "1", "]", "\n", "role", "=", "span", ".", "role", "\n", "ents", ".", "append", "(", "{", "\"name\"", ":", "role", ",", "\"start\"", ":", "start", ",", "\"end\"", ":", "end", "}", ")", "\n", "", "result", "[", "\"relations\"", "]", ".", "append", "(", "{", "\"name\"", ":", "rel_name", ",", "\"ents\"", ":", "ents", "}", ")", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction": [[39, 42], ["mare.label.extraction.transform_tags_to_relation", "seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.transform_relations_to_format"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.transform_relations_to_format"], ["", "def", "_post_processing_prediction", "(", "self", ",", "prediction", ")", ":", "\n", "        ", "relations", "=", "transform_tags_to_relation", "(", "prediction", "[", "\"tags\"", "]", ",", "max_inner_range", "=", "11", ",", "has_mode", "=", "False", ",", "include_trigger", "=", "False", ")", "\n", "return", "self", ".", "transform_relations_to_format", "(", "relations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json": [[43, 46], ["super().predict_json", "seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_json", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], ["", "def", "predict_json", "(", "self", ",", "inputs", ":", "JsonDict", ")", "->", "JsonDict", ":", "\n", "        ", "output_dict", "=", "super", "(", ")", ".", "predict_json", "(", "inputs", ")", "\n", "return", "self", ".", "_post_processing_prediction", "(", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor.predict_batch_json": [[48, 51], ["super().predict_batch_json", "seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json", "home.repos.pwc.inspect_result.mslars_mare.mare.seq_lab_elmo_pred_no_trig.SequenceLabElmoPredictor._post_processing_prediction"], ["", "def", "predict_batch_json", "(", "self", ",", "inputs", ":", "List", "[", "JsonDict", "]", ")", "->", "List", "[", "JsonDict", "]", ":", "\n", "        ", "output", "=", "super", "(", ")", ".", "predict_batch_json", "(", "inputs", ")", "\n", "return", "[", "self", ".", "_post_processing_prediction", "(", "entry", ")", "for", "entry", "in", "output", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.compounding": [[6, 14], ["float", "max", "min", "utils.compounding.clip"], "function", ["None"], ["def", "compounding", "(", "start", ",", "stop", ",", "compound", ")", ":", "\n", "    ", "def", "clip", "(", "value", ")", ":", "\n", "        ", "return", "max", "(", "value", ",", "stop", ")", "if", "(", "start", ">", "stop", ")", "else", "min", "(", "value", ",", "stop", ")", "\n", "\n", "", "curr", "=", "float", "(", "start", ")", "\n", "while", "True", ":", "\n", "        ", "yield", "clip", "(", "curr", ")", "\n", "curr", "/=", "compound", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.get_one_h_logits": [[16, 25], ["range", "range", "len"], "function", ["None"], ["", "", "def", "get_one_h_logits", "(", "logits", ",", "tags", ")", ":", "\n", "    ", "one_h_logits", "=", "0.0", "*", "logits", "\n", "\n", "for", "batch", "in", "range", "(", "logits", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "token_idx", "in", "range", "(", "logits", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "label_idx", "=", "tags", "[", "batch", "]", "[", "token_idx", "]", "if", "len", "(", "tags", "[", "batch", "]", ")", ">", "token_idx", "else", "1", "\n", "one_h_logits", "[", "batch", "]", "[", "token_idx", "]", "[", "label_idx", "]", "=", "1.0", "\n", "\n", "", "", "return", "one_h_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.get_span_indizes": [[27, 29], ["sorted", "allennlp.data.dataset_readers.dataset_utils.bio_tags_to_spans"], "function", ["None"], ["", "def", "get_span_indizes", "(", "tags", ")", ":", "\n", "    ", "return", "[", "sorted", "(", "[", "s", "[", "1", "]", "for", "s", "in", "bio_tags_to_spans", "(", "ts", ")", "]", ")", "for", "ts", "in", "tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.get_span_tensor": [[31, 41], ["max", "torch.tensor", "len", "torch.arange().expand", "torch.tensor().unsqueeze", "torch.tensor.to", "mask.to", "allennlp.common.util.pad_sequence_to_length", "len", "torch.arange", "torch.tensor"], "function", ["None"], ["", "def", "get_span_tensor", "(", "spans", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "    ", "lens", "=", "[", "len", "(", "s", ")", "for", "s", "in", "spans", "]", "\n", "num_max_spans", "=", "max", "(", "lens", ")", "\n", "\n", "spans", "=", "torch", ".", "tensor", "(", "[", "pad_sequence_to_length", "(", "ts", ",", "num_max_spans", ",", "lambda", ":", "(", "0", ",", "0", ")", ")", "for", "ts", "in", "spans", "]", ")", "\n", "\n", "mask", "=", "torch", ".", "arange", "(", "num_max_spans", ")", ".", "expand", "(", "len", "(", "lens", ")", ",", "num_max_spans", ")", "<", "torch", ".", "tensor", "(", "lens", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "return", "spans", ".", "to", "(", "device", ")", ",", "mask", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.apply_attention": [[43, 56], ["sequence.size", "sequence.size", "range", "sequence.size", "attention", "torch.bmm().squeeze", "torch.bmm", "attention.view"], "function", ["None"], ["", "def", "apply_attention", "(", "sequence", ",", "attention", ",", "mask", ")", ":", "\n", "# Apply span wise attention", "\n", "    ", "batch_size", "=", "sequence", ".", "size", "(", "0", ")", "\n", "attended", "=", "sequence", "*", "0.0", "\n", "\n", "if", "sequence", ".", "size", "(", "2", ")", ">", "0", ":", "\n", "        ", "for", "i", "in", "range", "(", "sequence", ".", "size", "(", "1", ")", ")", ":", "\n", "# (batch_size, max_num_spans)", "\n", "            ", "attention_scores", "=", "attention", "(", "sequence", "[", ":", ",", "i", ",", ":", "]", ",", "sequence", ",", "mask", ")", "\n", "\n", "attended", "[", ":", ",", "i", ",", ":", "]", "=", "torch", ".", "bmm", "(", "attention_scores", ".", "view", "(", "batch_size", ",", "1", ",", "-", "1", ")", ",", "sequence", ")", ".", "squeeze", "(", ")", "\n", "\n", "", "", "return", "attended", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.combine_sequence_with_spans": [[58, 67], ["enumerate", "torch.cat", "enumerate", "attended_spans[].repeat().view", "attended_spans[].repeat"], "function", ["None"], ["", "def", "combine_sequence_with_spans", "(", "encoded", ",", "attended_spans", ",", "spans", ")", ":", "\n", "    ", "combined", "=", "0.0", "*", "encoded", "\n", "for", "batch", ",", "spans", "in", "enumerate", "(", "spans", ")", ":", "\n", "        ", "for", "span_index", ",", "span", "in", "enumerate", "(", "spans", ")", ":", "\n", "            ", "s", "=", "span", "[", "0", "]", "\n", "e", "=", "span", "[", "1", "]", "+", "1", "\n", "combined", "[", "batch", ",", "s", ":", "e", ",", ":", "]", "=", "attended_spans", "[", "batch", ",", "span_index", ",", ":", "]", ".", "repeat", "(", "e", "-", "s", ")", ".", "view", "(", "e", "-", "s", ",", "-", "1", ")", "\n", "\n", "", "", "return", "torch", ".", "cat", "(", "(", "encoded", ",", "combined", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.mare.utils.remove_line_split": [[69, 76], ["word.strip", "removed.strip", "word[].replace"], "function", ["None"], ["", "def", "remove_line_split", "(", "word", ":", "str", ",", "transformer_res", ")", ":", "\n", "\n", "    ", "if", "'\u00ad'", "in", "word", "[", "1", ":", "-", "1", "]", ":", "\n", "        ", "removed", "=", "f\"{word[0]}{word[1:-1].replace('\u00ad', '')}{word[-1]}\"", "\n", "if", "removed", "==", "transformer_res", ":", "\n", "            ", "return", "removed", ".", "strip", "(", ")", "\n", "", "", "return", "word", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities_of_rel": [[25, 27], ["evaluation_strategies.sort_entities"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities"], ["def", "sort_entities_of_rel", "(", "relation", ")", ":", "\n", "    ", "return", "{", "\"name\"", ":", "relation", "[", "\"name\"", "]", ",", "\"ents\"", ":", "sort_entities", "(", "relation", "[", "\"ents\"", "]", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities": [[29, 31], ["sorted"], "function", ["None"], ["", "def", "sort_entities", "(", "ents", ")", ":", "\n", "    ", "return", "sorted", "(", "ents", ",", "key", "=", "lambda", "x", ":", "x", "[", "\"start\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_relations": [[33, 35], ["sorted"], "function", ["None"], ["", "def", "sort_relations", "(", "rels", ")", ":", "\n", "    ", "return", "sorted", "(", "rels", ",", "key", "=", "lambda", "x", ":", "x", "[", "\"name\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments": [[37, 42], ["evaluation_strategies.sort_entities"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities"], ["", "def", "reduce_to_mandatory_arguments", "(", "relation", ")", ":", "\n", "    ", "return", "{", "\"name\"", ":", "relation", "[", "\"name\"", "]", ",", "\n", "\"ents\"", ":", "sort_entities", "(", "\n", "[", "ele", "for", "ele", "in", "relation", "[", "\"ents\"", "]", "if", "\n", "ele", "[", "\"name\"", "]", "in", "relation_mandatory_args", "[", "relation", "[", "\"name\"", "]", "]", "]", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_relations_to_mandatory_arguments": [[44, 50], ["evaluation_strategies.reduce_to_mandatory_arguments", "rels_reduced.append"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments"], ["", "def", "reduce_relations_to_mandatory_arguments", "(", "relations", ")", ":", "\n", "    ", "rels_reduced", "=", "[", "]", "\n", "for", "rel", "in", "relations", ":", "\n", "        ", "rel_reduced", "=", "reduce_to_mandatory_arguments", "(", "rel", ")", "\n", "rels_reduced", ".", "append", "(", "rel_reduced", ")", "\n", "", "return", "rels_reduced", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict": [[52, 54], ["copy.deepcopy"], "function", ["None"], ["", "def", "copy_dict", "(", "source", ")", ":", "\n", "    ", "return", "copy", ".", "deepcopy", "(", "source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.named_entity_recognition": [[56, 80], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "pred_ner.append", "gold_ner.append", "pred_ner.append", "gold_ner.append", "gold_ents.remove", "pred_ner.append", "gold_ner.append"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict"], ["", "def", "named_entity_recognition", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "pred_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "gold_ner", "=", "[", "]", "\n", "pred_ner", "=", "[", "]", "\n", "\n", "gold_ents", "=", "[", "ent", "for", "rel", "in", "gold_copy", "[", "\"relations\"", "]", "for", "ent", "in", "rel", "[", "\"ents\"", "]", "]", "\n", "pred_ents", "=", "[", "ent", "for", "rel", "in", "pred_copy", "[", "\"relations\"", "]", "for", "ent", "in", "rel", "[", "\"ents\"", "]", "]", "\n", "\n", "for", "pred_ent", "in", "pred_ents", ":", "\n", "        ", "if", "pred_ent", "in", "gold_ents", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ents", ".", "remove", "(", "pred_ent", ")", "\n", "", "else", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_ent", "in", "gold_ents", ":", "\n", "        ", "pred_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_ner", ".", "append", "(", "gold_ent", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "pred_ner", ",", "gold_ner", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.named_entity_recognition_v2": [[82, 113], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.named_entity_recognition_v2.extract_ents"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict"], ["", "def", "named_entity_recognition_v2", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "pred_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "gold_ner", "=", "[", "]", "\n", "pred_ner", "=", "[", "]", "\n", "\n", "def", "extract_ents", "(", "relations", ")", ":", "\n", "        ", "ents", "=", "[", "]", "\n", "for", "rel", "in", "relations", ":", "\n", "            ", "for", "ent", "in", "rel", "[", "\"ents\"", "]", ":", "\n", "                ", "ent", "[", "\"name\"", "]", "=", "f\"{rel['name']}-{ent['name']}\"", "\n", "ents", ".", "append", "(", "ent", ")", "\n", "", "", "return", "ents", "\n", "", "gold_ents", "=", "extract_ents", "(", "gold_copy", "[", "\"relations\"", "]", ")", "\n", "pred_ents", "=", "extract_ents", "(", "pred_copy", "[", "\"relations\"", "]", ")", "\n", "\n", "for", "pred_ent", "in", "pred_ents", ":", "\n", "        ", "if", "pred_ent", "in", "gold_ents", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ents", ".", "remove", "(", "pred_ent", ")", "\n", "", "else", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_ent", "in", "gold_ents", ":", "\n", "        ", "pred_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_ner", ".", "append", "(", "gold_ent", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "pred_ner", ",", "gold_ner", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.named_entity_recognition_v2_no_trigger": [[115, 148], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.named_entity_recognition_v2.extract_ents"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict"], ["", "def", "named_entity_recognition_v2_no_trigger", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "pred_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "gold_ner", "=", "[", "]", "\n", "pred_ner", "=", "[", "]", "\n", "\n", "def", "extract_ents", "(", "relations", ")", ":", "\n", "        ", "ents", "=", "[", "]", "\n", "for", "rel", "in", "relations", ":", "\n", "            ", "for", "ent", "in", "rel", "[", "\"ents\"", "]", ":", "\n", "                ", "if", "ent", "[", "\"name\"", "]", ".", "lower", "(", ")", "!=", "\"trigger\"", ":", "\n", "                    ", "ent", "[", "\"name\"", "]", "=", "f\"{rel['name']}-{ent['name']}\"", "\n", "ents", ".", "append", "(", "ent", ")", "\n", "", "", "", "return", "ents", "\n", "\n", "", "gold_ents", "=", "extract_ents", "(", "gold_copy", "[", "\"relations\"", "]", ")", "\n", "pred_ents", "=", "extract_ents", "(", "pred_copy", "[", "\"relations\"", "]", ")", "\n", "\n", "for", "pred_ent", "in", "pred_ents", ":", "\n", "        ", "if", "pred_ent", "in", "gold_ents", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ents", ".", "remove", "(", "pred_ent", ")", "\n", "", "else", ":", "\n", "            ", "pred_ner", ".", "append", "(", "pred_ent", "[", "\"name\"", "]", ")", "\n", "gold_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_ent", "in", "gold_ents", ":", "\n", "        ", "pred_ner", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_ner", ".", "append", "(", "gold_ent", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "pred_ner", ",", "gold_ner", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.only_relation_classification": [[150, 174], ["prediction_relations.append", "gold_relations.append", "prediction_relations.append", "gold_relations.append", "gold_rel_names.remove", "prediction_relations.append", "gold_relations.append"], "function", ["None"], ["", "def", "only_relation_classification", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "\"\"\"\n    Returns prediction_rel, gold_rel\n    \"\"\"", "\n", "gold_rel_names", "=", "[", "rel", "[", "\"name\"", "]", "for", "rel", "in", "gold", "[", "\"relations\"", "]", "]", "\n", "prediction_rel_names", "=", "[", "rel", "[", "\"name\"", "]", "for", "rel", "in", "prediction", "[", "\"relations\"", "]", "]", "\n", "\n", "prediction_relations", "=", "[", "]", "\n", "gold_relations", "=", "[", "]", "\n", "\n", "for", "pred", "in", "prediction_rel_names", ":", "\n", "        ", "if", "pred", "in", "gold_rel_names", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred", ")", "\n", "gold_relations", ".", "append", "(", "pred", ")", "\n", "gold_rel_names", ".", "remove", "(", "pred", ")", "\n", "", "else", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred", ")", "\n", "gold_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_rel", "in", "gold_rel_names", ":", "\n", "        ", "prediction_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_relations", ".", "append", "(", "gold_rel", ")", "\n", "\n", "", "return", "prediction_relations", ",", "gold_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.respect_only_mandatory_args": [[176, 204], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.reduce_to_mandatory_arguments", "gold_rels_reduced.append", "evaluation_strategies.reduce_to_mandatory_arguments", "prediction_relations.append", "gold_relations.append", "prediction_relations.append", "gold_relations.append", "gold_rels_reduced.remove", "prediction_relations.append", "gold_relations.append"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments"], ["", "def", "respect_only_mandatory_args", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "prediction_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "prediction_relations", "=", "[", "]", "\n", "gold_relations", "=", "[", "]", "\n", "\n", "gold_rels_reduced", "=", "[", "]", "\n", "for", "gold_rel", "in", "gold_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "gold_rel_reduced", "=", "reduce_to_mandatory_arguments", "(", "gold_rel", ")", "\n", "gold_rels_reduced", ".", "append", "(", "gold_rel_reduced", ")", "\n", "\n", "", "for", "pred", "in", "prediction_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "pred_reduced", "=", "reduce_to_mandatory_arguments", "(", "pred", ")", "\n", "\n", "if", "pred_reduced", "in", "gold_rels_reduced", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_rels_reduced", ".", "remove", "(", "pred_reduced", ")", "\n", "", "else", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_rel", "in", "gold_rels_reduced", ":", "\n", "        ", "prediction_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_relations", ".", "append", "(", "gold_rel", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "prediction_relations", ",", "gold_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.filter_role": [[206, 218], ["ent[].lower", "new_ents.append"], "function", ["None"], ["", "def", "filter_role", "(", "rel", ",", "role", "=", "\"trigger\"", ")", ":", "\n", "    ", "new_rel", "=", "{", "\"name\"", ":", "rel", "[", "\"name\"", "]", "}", "\n", "new_ents", "=", "[", "]", "\n", "for", "ent", "in", "rel", "[", "\"ents\"", "]", ":", "\n", "        ", "if", "ent", "[", "\"name\"", "]", ".", "lower", "(", ")", "!=", "role", ":", "\n", "            ", "new_ent", "=", "{", "\"name\"", ":", "ent", "[", "\"name\"", "]", ",", "\n", "\"start\"", ":", "ent", "[", "\"start\"", "]", ",", "\n", "\"end\"", ":", "ent", "[", "\"end\"", "]", "\n", "}", "\n", "new_ents", ".", "append", "(", "new_ent", ")", "\n", "", "", "new_rel", "[", "\"ents\"", "]", "=", "new_ents", "\n", "return", "new_rel", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.respect_only_mandatory_args_no_trigger": [[220, 248], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.filter_role", "gold_rels_reduced.append", "evaluation_strategies.filter_role", "prediction_relations.append", "gold_relations.append", "evaluation_strategies.reduce_to_mandatory_arguments", "evaluation_strategies.reduce_to_mandatory_arguments", "prediction_relations.append", "gold_relations.append", "gold_rels_reduced.remove", "prediction_relations.append", "gold_relations.append"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.filter_role", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.filter_role", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments"], ["", "def", "respect_only_mandatory_args_no_trigger", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "prediction_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "prediction_relations", "=", "[", "]", "\n", "gold_relations", "=", "[", "]", "\n", "\n", "gold_rels_reduced", "=", "[", "]", "\n", "for", "gold_rel", "in", "gold_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "gold_rel_reduced", "=", "filter_role", "(", "reduce_to_mandatory_arguments", "(", "gold_rel", ")", ")", "\n", "gold_rels_reduced", ".", "append", "(", "gold_rel_reduced", ")", "\n", "\n", "", "for", "pred", "in", "prediction_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "pred_reduced", "=", "filter_role", "(", "reduce_to_mandatory_arguments", "(", "pred", ")", ")", "\n", "\n", "if", "pred_reduced", "in", "gold_rels_reduced", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_rels_reduced", ".", "remove", "(", "pred_reduced", ")", "\n", "", "else", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_rel", "in", "gold_rels_reduced", ":", "\n", "        ", "prediction_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_relations", ".", "append", "(", "gold_rel", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "prediction_relations", ",", "gold_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.spert_only_two_mandatory_args": [[250, 284], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.reduce_to_mandatory_arguments", "gold_rels_tmp.append", "sum", "evaluation_strategies.reduce_to_mandatory_arguments", "prediction_relations.append", "gold_relations.append", "prediction_relations.append", "gold_relations.append", "gold_rels_reduced.remove", "prediction_relations.append", "gold_relations.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.reduce_to_mandatory_arguments"], ["", "def", "spert_only_two_mandatory_args", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "prediction_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "prediction_relations", "=", "[", "]", "\n", "gold_relations", "=", "[", "]", "\n", "\n", "gold_rels_tmp", "=", "[", "]", "\n", "for", "gold_rel", "in", "gold_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "gold_rel_reduced", "=", "reduce_to_mandatory_arguments", "(", "gold_rel", ")", "\n", "gold_rels_tmp", ".", "append", "(", "gold_rel_reduced", ")", "\n", "\n", "", "if", "sum", "(", "[", "len", "(", "rel", "[", "\"ents\"", "]", ")", "!=", "2", "for", "rel", "in", "gold_rels_tmp", "]", ")", ">", "0", ":", "\n", "        ", "return", "[", "]", ",", "[", "]", "\n", "\n", "", "gold_rels_reduced", "=", "[", "rel", "for", "rel", "in", "gold_rels_tmp", "if", "len", "(", "rel", "[", "\"ents\"", "]", ")", "==", "2", "]", "\n", "#gold_rels_reduced = gold_rels_tmp", "\n", "\n", "for", "pred", "in", "prediction_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "pred_reduced", "=", "reduce_to_mandatory_arguments", "(", "pred", ")", "\n", "\n", "if", "pred_reduced", "in", "gold_rels_reduced", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_rels_reduced", ".", "remove", "(", "pred_reduced", ")", "\n", "", "else", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_reduced", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_rel", "in", "gold_rels_reduced", ":", "\n", "        ", "prediction_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_relations", ".", "append", "(", "gold_rel", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "prediction_relations", ",", "gold_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.spert_only_two_mandatory_args_v2": [[286, 317], ["set", "evaluation_strategies.spert_only_two_mandatory_args_v2.to_tuples"], "function", ["None"], ["", "def", "spert_only_two_mandatory_args_v2", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "union", "=", "set", "(", ")", "\n", "\n", "def", "to_tuples", "(", "rels", ")", ":", "\n", "        ", "result", "=", "[", "]", "\n", "for", "rel", "in", "rels", ":", "\n", "            ", "rel", "=", "reduce_to_mandatory_arguments", "(", "rel", ")", "\n", "#attrs = tuple([tuple(ent.values()) for ent in sort_entities(rel[\"ents\"])])", "\n", "attrs", "=", "tuple", "(", "[", "tuple", "(", "ent", ".", "values", "(", ")", ")", "for", "ent", "in", "rel", "[", "\"ents\"", "]", "]", ")", "\n", "result", "+=", "[", "(", "rel", "[", "\"name\"", "]", ",", "attrs", ")", "]", "\n", "", "return", "result", "\n", "", "gold_tuples", "=", "to_tuples", "(", "copy_dict", "(", "gold", "[", "\"relations\"", "]", ")", ")", "\n", "pred_tuples", "=", "to_tuples", "(", "copy_dict", "(", "prediction", "[", "\"relations\"", "]", ")", ")", "\n", "union", ".", "update", "(", "gold_tuples", ")", "\n", "union", ".", "update", "(", "pred_tuples", ")", "\n", "\n", "gt_flat", "=", "[", "]", "\n", "pred_flat", "=", "[", "]", "\n", "\n", "for", "s", "in", "union", ":", "\n", "        ", "if", "s", "in", "gold_tuples", ":", "\n", "            ", "gt_flat", ".", "append", "(", "s", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "gt_flat", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "if", "s", "in", "pred_tuples", ":", "\n", "            ", "pred_flat", ".", "append", "(", "s", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "pred_flat", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "return", "pred_flat", ",", "gt_flat", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.all_args_mandatory": [[319, 347], ["evaluation_strategies.copy_dict", "evaluation_strategies.copy_dict", "evaluation_strategies.sort_entities_of_rel", "gold_rels_sorted.append", "evaluation_strategies.sort_entities_of_rel", "prediction_relations.append", "gold_relations.append", "prediction_relations.append", "gold_relations.append", "gold_rels_sorted.remove", "prediction_relations.append", "gold_relations.append"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.copy_dict", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities_of_rel", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_strategies.sort_entities_of_rel"], ["", "def", "all_args_mandatory", "(", "gold", ",", "prediction", ")", ":", "\n", "    ", "gold_copy", "=", "copy_dict", "(", "gold", ")", "\n", "prediction_copy", "=", "copy_dict", "(", "prediction", ")", "\n", "\n", "prediction_relations", "=", "[", "]", "\n", "gold_relations", "=", "[", "]", "\n", "\n", "gold_rels_sorted", "=", "[", "]", "\n", "for", "gold_rel", "in", "gold_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "gold_rel_sorted", "=", "sort_entities_of_rel", "(", "gold_rel", ")", "\n", "gold_rels_sorted", ".", "append", "(", "gold_rel_sorted", ")", "\n", "\n", "", "for", "pred", "in", "prediction_copy", "[", "\"relations\"", "]", ":", "\n", "        ", "pred_sorted", "=", "sort_entities_of_rel", "(", "pred", ")", "\n", "\n", "if", "pred_sorted", "in", "gold_rels_sorted", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_sorted", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "pred_sorted", "[", "\"name\"", "]", ")", "\n", "gold_rels_sorted", ".", "remove", "(", "pred_sorted", ")", "\n", "", "else", ":", "\n", "            ", "prediction_relations", ".", "append", "(", "pred_sorted", "[", "\"name\"", "]", ")", "\n", "gold_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "\n", "", "", "for", "gold_rel", "in", "gold_rels_sorted", ":", "\n", "        ", "prediction_relations", ".", "append", "(", "NO_MATCH", ")", "\n", "gold_relations", ".", "append", "(", "gold_rel", "[", "\"name\"", "]", ")", "\n", "\n", "", "return", "prediction_relations", ",", "gold_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.prediction_relation_mapper.map_dygie": [[29, 57], ["len"], "function", ["None"], ["def", "map_dygie", "(", "predictions", ")", ":", "\n", "\n", "    ", "res", "=", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "        ", "relations", "=", "[", "]", "\n", "for", "sent", "in", "prediction", "[", "\"predicted_events\"", "]", ":", "\n", "            ", "relation", "=", "None", "\n", "for", "event", "in", "sent", ":", "\n", "                ", "assert", "len", "(", "event", ")", ">", "0", "\n", "relation", "=", "{", "\n", "\"name\"", ":", "event", "[", "0", "]", "[", "2", "]", ",", "\n", "\"ents\"", ":", "[", "\n", "{", "\"name\"", ":", "\"trigger\"", ",", "\n", "\"start\"", ":", "event", "[", "0", "]", "[", "0", "]", ",", "\n", "\"end\"", ":", "event", "[", "0", "]", "[", "1", "]", "}", "\n", "]", "\n", "}", "\n", "for", "argument", "in", "event", "[", "1", ":", "]", ":", "\n", "                    ", "relation", "[", "\"ents\"", "]", "+=", "[", "{", "\n", "\"name\"", ":", "argument", "[", "2", "]", ",", "\n", "\"start\"", ":", "argument", "[", "0", "]", ",", "\n", "\"end\"", ":", "argument", "[", "1", "]", "\n", "}", "]", "\n", "", "", "if", "relation", ":", "\n", "                ", "relations", "+=", "[", "relation", "]", "\n", "", "", "res", "+=", "[", "{", "\"relations\"", ":", "relations", "}", "]", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.prediction_relation_mapper.filter_current_gold": [[59, 65], ["len"], "function", ["None"], ["", "def", "filter_current_gold", "(", "current_gold", ")", ":", "\n", "    ", "for", "relation", "in", "current_gold", "[", "\"relations\"", "]", ":", "\n", "        ", "trigger_ents", "=", "[", "r", "for", "r", "in", "relation", "[", "'ents'", "]", "if", "r", "[", "\"name\"", "]", "==", "\"trigger\"", "]", "\n", "if", "len", "(", "trigger_ents", ")", "!=", "1", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.extract_stats.main": [[5, 25], ["click.command", "click.argument", "srsly.read_json", "print", "print", "print", "print", "attr.endswith"], "function", ["None"], ["@", "click", ".", "command", "(", ")", "\n", "@", "click", ".", "argument", "(", "'file_path'", ")", "\n", "def", "main", "(", "file_path", ":", "str", ")", ":", "\n", "\n", "    ", "data", "=", "srsly", ".", "read_json", "(", "file_path", ")", "\n", "\n", "strat", ":", "str", "\n", "for", "strat", "in", "data", "[", "\"strategies\"", "]", ":", "\n", "\n", "        ", "print", "(", ")", "\n", "\n", "print", "(", "f\"EVALUATION RESULTS FOR {strat}\"", ")", "\n", "\n", "print", "(", ")", "\n", "\n", "for", "attr", "in", "data", "[", "\"strategies\"", "]", "[", "strat", "]", ":", "\n", "            ", "if", "attr", ".", "endswith", "(", "\"labels\"", ")", "or", "\"micro\"", "not", "in", "attr", ":", "\n", "                ", "continue", "\n", "\n", "", "print", "(", "f\"{attr}: {data['strategies'][strat][attr]}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.timeit_decorator.timeit": [[3, 16], ["print", "time.time", "method", "time.time", "kw.get", "int", "print", "method.__name__.upper"], "function", ["None"], ["def", "timeit", "(", "method", ")", ":", "\n", "    ", "def", "timed", "(", "*", "args", ",", "**", "kw", ")", ":", "\n", "        ", "print", "(", "\"Starting {}\"", ".", "format", "(", "method", ".", "__name__", ")", ")", "\n", "ts", "=", "time", "(", ")", "\n", "result", "=", "method", "(", "*", "args", ",", "**", "kw", ")", "\n", "te", "=", "time", "(", ")", "\n", "if", "'log_time'", "in", "kw", ":", "\n", "            ", "name", "=", "kw", ".", "get", "(", "'log_name'", ",", "method", ".", "__name__", ".", "upper", "(", ")", ")", "\n", "kw", "[", "'log_time'", "]", "[", "name", "]", "=", "int", "(", "(", "te", "-", "ts", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"{}  {:2.2f} sec.\"", ".", "format", "(", "method", ".", "__name__", ",", "(", "te", "-", "ts", ")", ")", ")", "\n", "", "return", "result", "\n", "", "return", "timed", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.MockModel.predict_batch_json": [[47, 49], ["NotImplemented"], "methods", ["None"], ["    ", "def", "predict_batch_json", "(", "self", ",", "batch", ")", ":", "\n", "        ", "raise", "NotImplemented", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.__init__": [[53, 60], ["allennlp.models.load_archive", "allennlp.models.load_archive.model.eval", "dygie.predictors.dygie.predictors.dygie.predictors.DyGIEPredictor.from_archive", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model_path", ":", "Union", "[", "str", ",", "Path", "]", ")", ":", "\n", "        ", "archive", "=", "load_archive", "(", "model_path", ")", "\n", "archive", ".", "model", ".", "eval", "(", ")", "\n", "\n", "self", ".", "_predictor", "=", "dygie", ".", "predictors", ".", "DyGIEPredictor", ".", "from_archive", "(", "archive", ")", "\n", "self", ".", "_model", "=", "archive", ".", "model", "\n", "print", "(", "self", ".", "_predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json": [[61, 106], ["mock_model.DygieppMockModel._predictor.predict"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.models.ner.NERTagger.predict"], ["", "def", "predict_batch_json", "(", "self", ",", "batch", ")", ":", "\n", "\n", "        ", "result", "=", "[", "]", "\n", "\n", "for", "elem", "in", "batch", ":", "\n", "\n", "            ", "tokens", "=", "elem", "[", "\"tokens\"", "]", "\n", "\n", "instance", "=", "{", "\n", "\"doc_key\"", ":", "\"xyz\"", ",", "\n", "\"dataset\"", ":", "\"smart_data\"", ",", "\n", "\"sentences\"", ":", "[", "elem", "[", "\"tokens\"", "]", "]", "\n", "}", "\n", "\n", "relations", "=", "[", "]", "\n", "\n", "prediction", "=", "self", ".", "_predictor", ".", "predict", "(", "instance", ")", "\n", "\n", "for", "pred_event", "in", "prediction", "[", "\"predicted_events\"", "]", "[", "0", "]", ":", "\n", "                ", "pred_trigger", "=", "pred_event", "[", "0", "]", "\n", "relation", "=", "{", "\"name\"", ":", "pred_trigger", "[", "2", "]", ",", "\"ents\"", ":", "[", "]", "}", "\n", "\n", "# add Trigger to relation", "\n", "trigger_type", "=", "get_trigger_type_for_relation", "[", "pred_trigger", "[", "2", "]", "]", "\n", "\n", "relation", "[", "\"ents\"", "]", "+=", "[", "{", "\n", "\"start\"", ":", "pred_trigger", "[", "0", "]", ",", "\n", "\"end\"", ":", "pred_trigger", "[", "1", "]", ",", "\n", "\"name\"", ":", "trigger_type", ",", "\n", "#\"tokens\": tokens[pred_trigger[0]: pred_trigger[1]+1]", "\n", "}", "]", "\n", "\n", "for", "pred_argument", "in", "pred_event", "[", "1", ":", "]", ":", "\n", "                    ", "ent", "=", "{", "}", "\n", "ent", "[", "\"start\"", "]", "=", "pred_argument", "[", "0", "]", "\n", "ent", "[", "\"end\"", "]", "=", "pred_argument", "[", "1", "]", "\n", "ent", "[", "\"name\"", "]", "=", "pred_argument", "[", "2", "]", "\n", "#ent[\"tokens\"] = tokens[pred_argument[0]: pred_argument[1]+1]", "\n", "relation", "[", "\"ents\"", "]", "+=", "[", "ent", "]", "\n", "\n", "", "relations", "+=", "[", "relation", "]", "\n", "\n", "", "result", "+=", "[", "{", "\"relations\"", ":", "relations", "}", "]", "\n", "\n", "", "return", "result", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.__init__": [[97, 102], ["evaluation_runner.jsonl_df"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.jsonl_df"], ["def", "__init__", "(", "self", ",", "model", ",", "evaluation_path", ",", "dir", "=", "\"\"", ")", ":", "\n", "        ", "self", ".", "_store", "=", "{", "}", "\n", "self", ".", "_dir", "=", "dir", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "df", "=", "jsonl_df", "(", "evaluation_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._prepare_store": [[103, 111], ["None"], "methods", ["None"], ["", "def", "_prepare_store", "(", "self", ",", "run_names", ")", ":", "\n", "        ", "self", ".", "_store", "[", "self", ".", "GOLD_DATA", "]", "=", "[", "]", "\n", "self", ".", "_store", "[", "self", ".", "PRED_DATA", "]", "=", "[", "]", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "=", "{", "}", "\n", "for", "name", "in", "run_names", ":", "\n", "            ", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "name", "]", "=", "{", "\n", "self", ".", "GOLD_LABEL", ":", "[", "]", ",", "\n", "self", ".", "PRED_LABEL", ":", "[", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.evaluate": [[113, 140], ["evaluation_runner.EvaluationRunner._prepare_store", "tqdm.tqdm.tqdm", "run_strategies.keys", "evaluation_runner.EvaluationRunner._prepare_row", "evaluation_runner.extract_gold", "batch.append", "gold_for_batch.append", "len", "evaluation_runner.EvaluationRunner._predict_and_evaluate_on_batch", "tqdm.tqdm.tqdm.update", "len", "len", "evaluation_runner.EvaluationRunner._predict_and_evaluate_on_batch", "tqdm.tqdm.tqdm.update", "len"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._prepare_store", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._prepare_row", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.extract_gold", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._predict_and_evaluate_on_batch", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._predict_and_evaluate_on_batch"], ["", "", "def", "evaluate", "(", "self", ",", "**", "run_strategies", ")", ":", "\n", "        ", "self", ".", "_prepare_store", "(", "run_strategies", ".", "keys", "(", ")", ")", "\n", "\n", "batch_size", "=", "1", "\n", "\n", "batch", "=", "[", "]", "\n", "gold_for_batch", "=", "[", "]", "\n", "\n", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "self", ".", "df", ")", ")", "\n", "for", "row", "in", "self", ".", "df", ":", "\n", "            ", "tokens", "=", "EvaluationRunner", ".", "_prepare_row", "(", "row", ")", "\n", "to_predict", "=", "{", "\"tokens\"", ":", "tokens", "}", "\n", "\n", "gold", "=", "extract_gold", "(", "row", ")", "\n", "\n", "batch", ".", "append", "(", "to_predict", ")", "\n", "gold_for_batch", ".", "append", "(", "gold", ")", "\n", "\n", "if", "len", "(", "batch", ")", "==", "batch_size", ":", "\n", "                ", "self", ".", "_predict_and_evaluate_on_batch", "(", "batch", ",", "gold_for_batch", ",", "run_strategies", ")", "\n", "batch", "=", "[", "]", "\n", "gold_for_batch", "=", "[", "]", "\n", "pbar", ".", "update", "(", "batch_size", ")", "\n", "\n", "", "", "if", "len", "(", "batch", ")", ">", "0", ":", "\n", "            ", "self", ".", "_predict_and_evaluate_on_batch", "(", "batch", ",", "gold_for_batch", ",", "run_strategies", ")", "\n", "pbar", ".", "update", "(", "len", "(", "batch", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._predict_and_evaluate_on_batch": [[141, 146], ["evaluation_runner.EvaluationRunner.model.predict_batch_json", "enumerate", "zip", "evaluation_runner.EvaluationRunner._evaluate_on_single"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.mock_model.DygieppMockModel.predict_batch_json", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._evaluate_on_single"], ["", "", "def", "_predict_and_evaluate_on_batch", "(", "self", ",", "batch", ",", "gold_for_batch", ",", "run_strategies", ")", ":", "\n", "\n", "        ", "predictions", "=", "self", ".", "model", ".", "predict_batch_json", "(", "batch", ")", "\n", "for", "idx", ",", "(", "current_pred", ",", "current_gold", ")", "in", "enumerate", "(", "zip", "(", "predictions", ",", "gold_for_batch", ")", ")", ":", "\n", "            ", "self", ".", "_evaluate_on_single", "(", "current_gold", ",", "current_pred", ",", "run_strategies", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._evaluate_on_single": [[147, 152], ["evaluation_runner.EvaluationRunner._store[].append", "evaluation_runner.EvaluationRunner._store[].append", "run_strategies.items", "evaluation_runner.EvaluationRunner._perform_strategy"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._perform_strategy"], ["", "", "def", "_evaluate_on_single", "(", "self", ",", "current_gold", ",", "current_pred", ",", "run_strategies", ")", ":", "\n", "        ", "self", ".", "_store", "[", "self", ".", "GOLD_DATA", "]", ".", "append", "(", "current_gold", ")", "\n", "self", ".", "_store", "[", "self", ".", "PRED_DATA", "]", ".", "append", "(", "current_pred", ")", "\n", "for", "run_name", ",", "strategy", "in", "run_strategies", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_perform_strategy", "(", "current_gold", ",", "current_pred", ",", "run_name", ",", "strategy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._prepare_row": [[153, 158], ["None"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_prepare_row", "(", "row", ")", ":", "\n", "        ", "text", "=", "row", "[", "\"text\"", "]", "\n", "tokens", "=", "[", "text", "[", "token", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "token", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "token", "in", "row", "[", "\"tokens\"", "]", "]", "\n", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._perform_strategy": [[159, 163], ["strategy", "[].extend", "[].extend"], "methods", ["None"], ["", "def", "_perform_strategy", "(", "self", ",", "gold", ",", "prediction", ",", "run_name", ",", "strategy", ")", ":", "\n", "        ", "prediction_rel", ",", "gold_rel", "=", "strategy", "(", "gold", ",", "prediction", ")", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "self", ".", "GOLD_LABEL", "]", ".", "extend", "(", "gold_rel", ")", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "self", ".", "PRED_LABEL", "]", ".", "extend", "(", "prediction_rel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.extract_labels": [[164, 173], ["set", "set.update", "list", "set.remove"], "methods", ["None"], ["", "def", "extract_labels", "(", "self", ",", "gold", ",", "pred", ",", "exclude", "=", "[", "\"NO_MATCH\"", "]", ")", ":", "\n", "        ", "labels", "=", "set", "(", "gold", ")", "\n", "labels", ".", "update", "(", "pred", ")", "\n", "for", "ex", "in", "exclude", ":", "\n", "            ", "try", ":", "\n", "                ", "labels", ".", "remove", "(", "ex", ")", "\n", "", "except", ":", "\n", "                ", "pass", "# If no entry exists, then everything is fine", "\n", "", "", "return", "list", "(", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._f1_score": [[174, 178], ["evaluation_runner.EvaluationRunner.extract_labels", "sklearn.metrics.f1_score", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.extract_labels", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations"], ["", "def", "_f1_score", "(", "self", ",", "run_name", ",", "average", "=", "'weighted'", ")", ":", "\n", "        ", "labels", "=", "self", ".", "extract_labels", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ")", "\n", "return", "f1_score", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ",", "average", "=", "average", ",", "\n", "labels", "=", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._precision_score": [[179, 183], ["evaluation_runner.EvaluationRunner.extract_labels", "sklearn.metrics.precision_score", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.extract_labels", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations"], ["", "def", "_precision_score", "(", "self", ",", "run_name", ",", "average", "=", "'weighted'", ")", ":", "\n", "        ", "labels", "=", "self", ".", "extract_labels", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ")", "\n", "return", "precision_score", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ",", "average", "=", "average", ",", "\n", "labels", "=", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._recall_score": [[184, 188], ["evaluation_runner.EvaluationRunner.extract_labels", "sklearn.metrics.recall_score", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.extract_labels", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations"], ["", "def", "_recall_score", "(", "self", ",", "run_name", ",", "average", "=", "'weighted'", ")", ":", "\n", "        ", "labels", "=", "self", ".", "extract_labels", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ")", "\n", "return", "recall_score", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "self", ".", "pred_relations", "(", "run_name", ")", ",", "average", "=", "average", ",", "\n", "labels", "=", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._confusion_matrix": [[189, 192], ["pandas.crosstab", "pandas.Series", "pandas.Series", "evaluation_runner.EvaluationRunner.gold_relations", "evaluation_runner.EvaluationRunner.pred_relations"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations"], ["", "def", "_confusion_matrix", "(", "self", ",", "run_name", ")", ":", "\n", "        ", "return", "pd", ".", "crosstab", "(", "pd", ".", "Series", "(", "self", ".", "gold_relations", "(", "run_name", ")", ",", "name", "=", "\"Actual\"", ")", ",", "\n", "pd", ".", "Series", "(", "self", ".", "pred_relations", "(", "run_name", ")", ",", "name", "=", "\"Pred\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.gold_relations": [[193, 195], ["None"], "methods", ["None"], ["", "def", "gold_relations", "(", "self", ",", "run_name", ")", ":", "\n", "        ", "return", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "self", ".", "GOLD_LABEL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.pred_relations": [[196, 198], ["None"], "methods", ["None"], ["", "def", "pred_relations", "(", "self", ",", "run_name", ")", ":", "\n", "        ", "return", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "self", ".", "PRED_LABEL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.save_report": [[199, 221], ["print", "evaluation_runner.EvaluationRunner._confusion_matrix", "evaluation_runner.EvaluationRunner._save_confusion_matrix", "open", "json.dump", "evaluation_runner.EvaluationRunner._precision_score", "evaluation_runner.EvaluationRunner._recall_score", "evaluation_runner.EvaluationRunner._f1_score"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._confusion_matrix", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._save_confusion_matrix", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._precision_score", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._recall_score", "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._f1_score"], ["", "def", "save_report", "(", "self", ")", ":", "\n", "        ", "print", "(", "\"Calculating metrics\"", ")", "\n", "for", "run_name", "in", "self", ".", "_store", "[", "self", ".", "STRATS", "]", ":", "\n", "            ", "for", "average", "in", "[", "\"micro\"", ",", "\"macro\"", ",", "\"weighted\"", "]", ":", "\n", "                ", "precision", "=", "self", ".", "_precision_score", "(", "run_name", ",", "average", "=", "average", ")", "\n", "recall", "=", "self", ".", "_recall_score", "(", "run_name", ",", "average", "=", "average", ")", "\n", "f1", "=", "self", ".", "_f1_score", "(", "run_name", ",", "average", "=", "average", ")", "\n", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "\"precision_\"", "+", "average", "]", "=", "precision", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "\"recall_\"", "+", "average", "]", "=", "recall", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "\"f1_\"", "+", "average", "]", "=", "f1", "\n", "\n", "", "conf_mat", "=", "self", ".", "_confusion_matrix", "(", "run_name", ")", "\n", "self", ".", "_save_confusion_matrix", "(", "conf_mat", ",", "run_name", ")", "\n", "self", ".", "_store", "[", "self", ".", "STRATS", "]", "[", "run_name", "]", "[", "\"confusion_matrix\"", "]", "=", "\"see \"", "+", "run_name", "+", "\".png\"", "\n", "\n", "", "file_name", "=", "\"\"", "\n", "if", "self", ".", "_dir", "!=", "\"\"", ":", "\n", "            ", "file_name", "+=", "self", ".", "_dir", "+", "\"/\"", "\n", "", "file_name", "+=", "\"store\"", "+", "self", ".", "_file_suffix", "\n", "with", "open", "(", "file_name", ",", "\"w\"", ")", "as", "outfile", ":", "\n", "            ", "json", ".", "dump", "(", "self", ".", "_store", ",", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner.load_report": [[222, 226], ["open", "json.load"], "methods", ["None"], ["", "", "def", "load_report", "(", "self", ",", "file", ")", ":", "\n", "        ", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "infile", ":", "\n", "            ", "data", "=", "json", ".", "load", "(", "infile", ")", "\n", "self", ".", "_store", "=", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.EvaluationRunner._save_confusion_matrix": [[227, 235], ["seaborn.heatmap", "matplotlib.savefig", "matplotlib.clf"], "methods", ["None"], ["", "", "def", "_save_confusion_matrix", "(", "self", ",", "df_confusion", ",", "to_file", ")", ":", "\n", "        ", "file_name", "=", "\"\"", "\n", "if", "self", ".", "_dir", "!=", "\"\"", ":", "\n", "            ", "file_name", "+=", "self", ".", "_dir", "+", "\"/\"", "\n", "", "file_name", "+=", "to_file", "+", "\".png\"", "\n", "sn", ".", "heatmap", "(", "df_confusion", ",", "annot", "=", "True", ")", "\n", "plt", ".", "savefig", "(", "file_name", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.jsonl_df": [[40, 43], ["allennlp.common.file_utils.cached_path", "list", "srsly.read_jsonl"], "function", ["None"], ["def", "jsonl_df", "(", "filepath", ")", ":", "\n", "    ", "cacched_file_path", "=", "cached_path", "(", "filepath", ")", "\n", "return", "list", "(", "srsly", ".", "read_jsonl", "(", "cacched_file_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.transform_entities_char_spans_to_token_spans": [[45, 72], ["enumerate", "print", "print"], "function", ["None"], ["", "def", "transform_entities_char_spans_to_token_spans", "(", "rel", ",", "tokens", ")", ":", "\n", "    ", "token_spans", "=", "[", "]", "\n", "for", "arg", "in", "rel", "[", "\"args\"", "]", ":", "\n", "        ", "start", "=", "arg", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "[", "\"start\"", "]", "\n", "end", "=", "arg", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "[", "\"end\"", "]", "\n", "\n", "token_start_index", "=", "-", "1", "\n", "token_end_index", "=", "-", "1", "\n", "for", "idx", ",", "t", "in", "enumerate", "(", "tokens", ")", ":", "\n", "            ", "t_start", "=", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", "\n", "t_end", "=", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "\n", "if", "t_start", "==", "start", ":", "\n", "                ", "token_start_index", "=", "idx", "\n", "", "if", "t_end", "==", "end", ":", "\n", "                ", "token_end_index", "=", "idx", "\n", "\n", "", "", "if", "token_start_index", "==", "-", "1", ":", "\n", "            ", "print", "(", "\"Start nicht gefunden\"", ")", "\n", "", "if", "token_end_index", "==", "-", "1", ":", "\n", "            ", "print", "(", "\"Ende nicht gefunden\"", ")", "\n", "\n", "", "token_spans", "+=", "[", "{", "\n", "\"name\"", ":", "arg", "[", "\"role\"", "]", ",", "\n", "\"start\"", ":", "token_start_index", ",", "\n", "\"end\"", ":", "token_end_index", "\n", "}", "]", "\n", "", "return", "token_spans", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.extract_gold": [[74, 87], ["evaluation_runner.transform_entities_char_spans_to_token_spans"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.transform_entities_char_spans_to_token_spans"], ["", "def", "extract_gold", "(", "row", ")", ":", "\n", "    ", "gold", "=", "{", "\"tokens\"", ":", "[", "row", "[", "\"text\"", "]", "[", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ":", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", "]", "for", "t", "in", "row", "[", "\"tokens\"", "]", "]", ",", "\n", "\"relations\"", ":", "[", "]", "}", "\n", "for", "rel", "in", "row", "[", "\"relationMentions\"", "]", ":", "\n", "        ", "rel_name", "=", "rel", "[", "\"name\"", "]", "\n", "ents", "=", "transform_entities_char_spans_to_token_spans", "(", "rel", ",", "row", "[", "\"tokens\"", "]", ")", "\n", "\n", "gold", "[", "\"relations\"", "]", "+=", "[", "{", "\n", "\"name\"", ":", "rel_name", ",", "\n", "\"ents\"", ":", "ents", "\n", "}", "]", "\n", "\n", "", "return", "gold", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.smart_data_evaluate": [[237, 286], ["click.command", "click.option", "click.option", "click.option", "click.option", "click.option", "click.option", "click.option", "evaluation_runner.prepare_dir", "allennlp.import_module_and_submodules", "evaluation_runner.smart_data_evaluate.eval_model"], "function", ["home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.prepare_dir"], ["", "", "@", "click", ".", "command", "(", ")", "\n", "@", "click", ".", "option", "(", "\"--model-path\"", ",", "help", "=", "\"Path to model.tar.gz\"", ",", "required", "=", "True", ")", "\n", "@", "click", ".", "option", "(", "\"--predictor\"", ",", "help", "=", "\"Fully qualified name of the predictor class\"", ",", "required", "=", "False", ",", ")", "\n", "@", "click", ".", "option", "(", "\"--test-data\"", ",", "help", "=", "\"Path to test data in avro format\"", ",", "required", "=", "True", ")", "\n", "@", "click", ".", "option", "(", "\"--include-package\"", ",", "\"--inc\"", ",", "help", "=", "\"Like AllenNLP's inlcude-package\"", ",", "required", "=", "True", ")", "\n", "@", "click", ".", "option", "(", "\"--output-dir\"", ",", "help", "=", "\"Output directory\"", ",", "required", "=", "True", ")", "\n", "@", "click", ".", "option", "(", "\"--overwrite-dir\"", ",", "\"-f\"", ",", "is_flag", "=", "True", ",", "default", "=", "False", ")", "\n", "@", "click", ".", "option", "(", "\"--use_mock_predictor\"", ",", "\"-ump\"", ",", "is_flag", "=", "True", ",", "default", "=", "False", ")", "\n", "def", "smart_data_evaluate", "(", "model_path", ",", "predictor", ",", "test_data", ",", "include_package", ",", "output_dir", ",", "overwrite_dir", ",", "\n", "use_mock_predictor", ")", ":", "\n", "    ", "prepare_dir", "(", "output_dir", ",", "overwrite_dir", ")", "\n", "common_util", ".", "import_module_and_submodules", "(", "include_package", ")", "\n", "if", "\"mock\"", "in", "predictor", ".", "lower", "(", ")", ":", "\n", "        ", "use_mock_predictor", "=", "True", "\n", "", "if", "use_mock_predictor", ":", "\n", "        ", "splitted", "=", "predictor", ".", "split", "(", "\".\"", ")", "\n", "mod", "=", "__import__", "(", "\".\"", ".", "join", "(", "splitted", "[", ":", "-", "1", "]", ")", ",", "fromlist", "=", "[", "splitted", "[", "-", "1", "]", "]", ")", "\n", "klass", "=", "getattr", "(", "mod", ",", "splitted", "[", "-", "1", "]", ")", "\n", "current_predictor_class", "=", "klass", "\n", "", "else", ":", "\n", "        ", "current_predictor_class", "=", "Predictor", ".", "by_name", "(", "predictor", ")", "\n", "\n", "", "@", "timeit", "\n", "def", "load_model", "(", "path", ")", ":", "\n", "        ", "archive", "=", "load_archive", "(", "path", ")", "\n", "archive", ".", "model", ".", "eval", "(", ")", "\n", "return", "current_predictor_class", ".", "from_archive", "(", "archive", ")", "\n", "\n", "", "@", "timeit", "\n", "def", "eval_model", "(", "predictor", ",", "test_data_path", ")", ":", "\n", "        ", "evaluate_runner", "=", "EvaluationRunner", "(", "predictor", ",", "test_data_path", ",", "output_dir", ")", "\n", "evaluate_runner", ".", "evaluate", "(", "\n", "MRE", "=", "respect_only_mandatory_args", ",", "\n", "Cl", "=", "only_relation_classification", ",", "\n", "CRE", "=", "all_args_mandatory", ",", "\n", "AR", "=", "named_entity_recognition_v2", ",", "\n", "BRE", "=", "spert_only_two_mandatory_args", ",", "\n", "MRE_no_trigger", "=", "respect_only_mandatory_args_no_trigger", ",", "\n", "AR_no_trigger", "=", "named_entity_recognition_v2_no_trigger", "\n", ")", "\n", "evaluate_runner", ".", "save_report", "(", ")", "\n", "\n", "", "if", "not", "use_mock_predictor", ":", "\n", "        ", "predictor", "=", "load_model", "(", "model_path", ")", "\n", "\n", "", "else", ":", "\n", "        ", "predictor", "=", "current_predictor_class", "(", "model_path", ")", "\n", "\n", "", "eval_model", "(", "predictor", ",", "test_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.evaluation.evaluation_runner.prepare_dir": [[288, 295], ["os.path.isdir", "os.mkdir", "Exception", "shutil.rmtree"], "function", ["None"], ["", "def", "prepare_dir", "(", "output_dir", ",", "overwrite_dir", ")", ":", "\n", "    ", "folder_exists", "=", "os", ".", "path", ".", "isdir", "(", "output_dir", ")", "\n", "if", "folder_exists", "and", "not", "overwrite_dir", ":", "\n", "        ", "raise", "Exception", "(", "f\"Folder \\\"{output_dir}\\\" already exists\"", ")", "\n", "", "if", "folder_exists", "and", "overwrite_dir", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "output_dir", ")", "\n", "", "os", ".", "mkdir", "(", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.dataset": [[11, 30], ["allennlp.common.file_utils.cached_path", "open", "srsly.json_loads", "file.readlines"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "dataset", "(", ")", ":", "\n", "    ", "smart_training_data_path", "=", "\"https://fh-aachen.sciebo.de/s/MjcrDC3gDjwU7Vd/download\"", "\n", "smart_validation_data_path", "=", "\"https://fh-aachen.sciebo.de/s/3GpXCZLhjwm2SJU/download\"", "\n", "smart_test_data_path", "=", "\"https://fh-aachen.sciebo.de/s/9ghU4Qi1azUMFPW/download\"", "\n", "\n", "data_paths", "=", "[", "smart_training_data_path", ",", "smart_validation_data_path", ",", "smart_test_data_path", "]", "\n", "\n", "dataset", "=", "[", "]", "\n", "\n", "for", "file_path", "in", "data_paths", ":", "\n", "\n", "        ", "file_path", "=", "cached_path", "(", "file_path", ")", "\n", "\n", "with", "open", "(", "file_path", ",", "\"r\"", ")", "as", "file", ":", "\n", "\n", "            ", "dataset", "+=", "[", "srsly", ".", "json_loads", "(", "line", ")", "for", "line", "in", "file", ".", "readlines", "(", ")", "]", "\n", "\n", "", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.sort_gold": [[32, 40], ["min", "max"], "function", ["None"], ["", "def", "sort_gold", "(", "x", ")", ":", "\n", "\n", "    ", "start", "=", "min", "(", "\n", "[", "a", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "[", "\"start\"", "]", "for", "a", "in", "x", "[", "\"args\"", "]", "if", "a", "[", "\"role\"", "]", "in", "relation_mandatory_args", "[", "x", "[", "\"name\"", "]", "]", "]", ")", "\n", "end", "=", "max", "(", "\n", "[", "a", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "[", "\"end\"", "]", "for", "a", "in", "x", "[", "\"args\"", "]", "if", "a", "[", "\"role\"", "]", "in", "relation_mandatory_args", "[", "x", "[", "\"name\"", "]", "]", "]", ")", "\n", "\n", "return", "start", ",", "end", ",", "x", "[", "\"name\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_overlapping_entities": [[42, 99], ["mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["None"], ["", "def", "test_overlapping_entities", "(", ")", ":", "\n", "\n", "# Testcase 1: Reduce nested (complete included)", "\n", "\n", "    ", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "2", ",", "\"a\"", ")", ",", "Span", "(", "1", ",", "3", ",", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "reduced_relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "3", ",", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "assert", "relation", "==", "reduced_relation", ",", "f\"Overlapping spans in relation not reduced!\"", "\n", "\n", "# Testcase 2: Reduce nested (overlapping borders)", "\n", "\n", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "5", ",", "\"a\"", ")", ",", "Span", "(", "4", ",", "8", ",", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "reduced_relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "5", ",", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "assert", "relation", "==", "reduced_relation", ",", "f\"Overlapping spans in relation not reduced!\"", "\n", "\n", "# Testcase 3: one span with two roles", "\n", "\n", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "2", ",", "\"a\"", ")", ",", "Span", "(", "2", ",", "2", ",", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "reduced_relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "2", ",", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "assert", "relation", "==", "reduced_relation", ",", "f\"Overlapping spans in relation not reduced!\"", "\n", "\n", "#Testcase 4: Some complex sample", "\n", "\n", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "2", ",", "\"a\"", ")", ",", "Span", "(", "2", ",", "2", ",", "\"b\"", ")", ",", "Span", "(", "5", ",", "7", ",", "\"c\"", ")", ",", "Span", "(", "6", ",", "8", ",", "\"d\"", ")", ",", "Span", "(", "9", ",", "11", ",", "\"e\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "reduced_relation", "=", "Relation", "(", "\n", "[", "Span", "(", "2", ",", "2", ",", "\"a\"", ")", ",", "Span", "(", "5", ",", "7", ",", "\"c\"", ")", ",", "Span", "(", "9", ",", "11", ",", "\"e\"", ")", "]", ",", "\n", "label", "=", "\"Hallo\"", "\n", ")", "\n", "\n", "assert", "relation", "==", "reduced_relation", ",", "f\"Overlapping spans in relation not reduced!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_extract_relations_from_smart_sample": [[101, 117], ["mare.label.extraction.extract_relations_from_smart_sample", "sorted", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample"], ["", "def", "test_extract_relations_from_smart_sample", "(", "dataset", ")", ":", "\n", "\n", "    ", "for", "sample", "in", "dataset", ":", "\n", "\n", "        ", "extracted_relations", "=", "extract_relations_from_smart_sample", "(", "sample", ",", "only_mandatory", "=", "True", ")", "\n", "\n", "gold_relations", "=", "sample", "[", "\"relationMentions\"", "]", "\n", "\n", "if", "len", "(", "extracted_relations", ")", "!=", "len", "(", "gold_relations", ")", ":", "\n", "            ", "assert", "False", ",", "f\"Wrong number of Relations found in sample with id: {sample['id']}\"", "\n", "\n", "", "gold_relations", "=", "sorted", "(", "gold_relations", ",", "key", "=", "sort_gold", ")", "\n", "\n", "for", "er", ",", "gr", "in", "zip", "(", "extracted_relations", ",", "gold_relations", ")", ":", "\n", "\n", "            ", "assert", "gr", "[", "\"name\"", "]", "==", "er", ".", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_relation_entities": [[119, 136], ["mare.label.extraction.Relation", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "list", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["None"], ["", "", "", "def", "test_relation_entities", "(", ")", ":", "\n", "\n", "    ", "spans", "=", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "3", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "9", ",", "9", ",", "role", "=", "\"a\"", ")", "]", "\n", "\n", "relation", "=", "Relation", "(", "list", "(", "spans", ")", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "entities", "=", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"B-a\"", ")", ",", "\n", "Span", "(", "3", ",", "6", ",", "role", "=", "\"B-a\"", ")", ",", "\n", "Span", "(", "9", ",", "9", ",", "role", "=", "\"B-a\"", ")", "]", "\n", "\n", "\n", "assert", "relation", ".", "spans", "==", "spans", "\n", "assert", "relation", ".", "entities", "==", "entities", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_relation_tags": [[138, 203], ["mare.label.extraction.Relation", "mare.label.extraction.Relation.get_bio_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation.get_bio_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation.get_bio_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation.get_bio_tags", "pytest.raises", "mare.label.extraction.Relation", "mare.label.extraction.Relation.get_bio_tags", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags", "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags"], ["", "def", "test_relation_tags", "(", ")", ":", "\n", "\n", "# Testcase 1: single argument", "\n", "\n", "    ", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "tags", "=", "relation", ".", "get_bio_tags", "(", "4", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-B-a\"", ",", "\"O\"", ",", "\"O\"", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"relation {relation} converted to sequence {tags} instead of {gold}\"", "\n", "\n", "# Testcase 2: multiple argument", "\n", "\n", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "3", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "9", ",", "9", ",", "role", "=", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "tags", "=", "relation", ".", "get_bio_tags", "(", "12", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-B-a\"", ",", "\"O\"", ",", "\"B-B-a\"", ",", "\"I-B-a\"", ",", "\"I-B-a\"", ",", "\"I-B-a\"", ",", "\"O\"", ",", "\"O\"", ",", "\"B-B-a\"", ",", "\"O\"", ",", "\"O\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"relation {relation} converted to sequence {tags} instead of {gold}\"", "\n", "\n", "# Testcase 3: invalid arguments", "\n", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "3", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "9", ",", "9", ",", "role", "=", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "tags", "=", "relation", ".", "get_bio_tags", "(", "12", ")", "\n", "\n", "# Testcase 4: wrong length", "\n", "\n", "", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "3", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "9", ",", "9", ",", "role", "=", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "n", "=", "8", "\n", "tags", "=", "relation", ".", "get_bio_tags", "(", "n", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-B-a\"", ",", "\"O\"", ",", "\"B-B-a\"", ",", "\"I-B-a\"", ",", "\"I-B-a\"", ",", "\"I-B-a\"", ",", "\"O\"", ",", "]", "\n", "assert", "tags", "==", "gold", ",", "f\"relation {relation} converted to sequence {tags} instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 5: Test mode inclusion", "\n", "\n", "relation", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "1", ",", "role", "=", "\"a\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "tags", "=", "relation", ".", "get_bio_tags", "(", "4", ",", "mode", "=", "\"X\"", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-B-a\"", ",", "\"O\"", ",", "\"O\"", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"relation {relation} converted to sequence {tags} instead of {gold}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_combined_relation_tags": [[205, 346], ["mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags"], ["", "def", "test_combined_relation_tags", "(", ")", ":", "\n", "\n", "# Testcase 1: non overlapping", "\n", "\n", "    ", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "8", ",", "9", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "n", "=", "11", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_1", ",", "relation_2", "]", ",", "n", ",", "include_mode", "=", "True", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-A-a\"", ",", "\"I-X-A-a\"", ",", "\"O\"", ",", "\"B-X-A-b\"", ",", "\"O\"", ",", "\"B-X-B-a\"", ",", "\"O\"", ",", "\"B-X-B-b\"", ",", "\"I-X-B-b\"", ",", "\"O\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 2: overlapping and conflicting Relations, korrekt ordering", "\n", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "3", ",", "5", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "8", ",", "9", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "n", "=", "11", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_1", ",", "relation_2", "]", ",", "n", ",", "include_mode", "=", "True", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-A-a\"", ",", "\"I-X-A-a\"", ",", "\"B-X-B-a\"", ",", "\"B-X-A-b\"", ",", "\"I-X-B-a\"", ",", "\"B-X-B-a\"", ",", "\"O\"", ",", "\"B-X-B-b\"", ",", "\"I-X-B-b\"", ",", "\"O\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 3: overlapping and conflicting Relations, wrong ordering", "\n", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "3", ",", "5", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "8", ",", "9", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "n", "=", "11", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_2", ",", "relation_1", "]", ",", "n", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-A-a\"", ",", "\"I-A-a\"", ",", "\"B-B-a\"", ",", "\"B-A-b\"", ",", "\"I-B-a\"", ",", "\"B-B-a\"", ",", "\"O\"", ",", "\"B-B-b\"", ",", "\"I-B-b\"", ",", "\"O\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 4: Define fist relation type as dominant", "\n", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "relation_3", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"b\"", ")", ",", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "\n", "n", "=", "7", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_1", ",", "relation_2", ",", "relation_3", "]", ",", "n", ",", "include_mode", "=", "True", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-A-a\"", ",", "\"I-X-A-a\"", ",", "\"O\"", ",", "\"B-X-A-b\"", ",", "\"O\"", ",", "\"B-Y-A-b\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 5: Define fist relation type as dominant", "\n", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "\n", "relation_3", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"b\"", ")", ",", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "n", "=", "7", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_1", ",", "relation_2", ",", "relation_3", "]", ",", "n", ",", "include_mode", "=", "True", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-B-a\"", ",", "\"I-X-B-a\"", ",", "\"O\"", ",", "\"B-X-B-b\"", ",", "\"O\"", ",", "\"B-Y-B-b\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n", "\n", "# Testcase 5: Test_multiple alternating mode-relations", "\n", "\n", "relation_1", "=", "Relation", "(", "\n", "[", "Span", "(", "1", ",", "2", ",", "role", "=", "\"a\"", ")", ",", "\n", "Span", "(", "4", ",", "4", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "relation_2", "=", "Relation", "(", "\n", "[", "Span", "(", "6", ",", "6", ",", "role", "=", "\"a\"", ")", ",", "Span", "(", "7", ",", "7", ",", "role", "=", "\"b\"", ")", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "relation_3", "=", "Relation", "(", "\n", "[", "Span", "(", "9", ",", "10", ",", "role", "=", "\"b\"", ")", ",", "]", ",", "\n", "label", "=", "\"B\"", "\n", ")", "\n", "\n", "relation_4", "=", "Relation", "(", "\n", "[", "Span", "(", "5", ",", "5", ",", "role", "=", "\"d\"", ")", ",", "Span", "(", "8", ",", "8", ",", "role", "=", "\"e\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "\n", "relation_5", "=", "Relation", "(", "\n", "[", "Span", "(", "13", ",", "14", ",", "role", "=", "\"d\"", ")", ",", "Span", "(", "16", ",", "16", ",", "role", "=", "\"e\"", ")", "]", ",", "\n", "label", "=", "\"A\"", "\n", ")", "\n", "\n", "n", "=", "17", "\n", "tags", "=", "combined_relation_tags", "(", "[", "relation_1", ",", "relation_2", ",", "relation_3", ",", "relation_4", ",", "relation_5", "]", ",", "n", ",", "include_mode", "=", "True", ")", "\n", "gold", "=", "[", "\"O\"", ",", "\"B-X-B-a\"", ",", "\"I-X-B-a\"", ",", "\"O\"", ",", "\"B-X-B-b\"", ",", "\"B-X-A-d\"", ",", "\"B-Y-B-a\"", ",", "\"B-Y-B-b\"", ",", "\"B-X-A-e\"", ",", "\"B-X-B-b\"", ",", "\"I-X-B-b\"", ",", "\"O\"", ",", "\"O\"", ",", "\"B-Y-A-d\"", ",", "\"I-Y-A-d\"", ",", "\"O\"", ",", "\"B-Y-A-e\"", ",", "]", "\n", "\n", "assert", "tags", "==", "gold", ",", "f\"Combination of relations: {relation_1, relation_2} converted to sequence {tags} \"", "f\"instead of {gold} for n = {n}\"", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_split_relation_spans": [[349, 399], ["mare.label.extraction.split_relation_spans", "mare.label.extraction.split_relation_spans", "mare.label.extraction.split_relation_spans", "mare.label.extraction.split_relation_spans", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.split_relation_spans", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.split_relation_spans", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.split_relation_spans", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.split_relation_spans"], ["", "def", "test_split_relation_spans", "(", ")", ":", "\n", "\n", "# Testcase 1: Simple Split", "\n", "\n", "    ", "relation_spans", "=", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"a\"", ")", ",", "Span", "(", "5", ",", "1", ",", "\"b\"", ")", ",", "]", "\n", "\n", "splitted_relation_spans", "=", "split_relation_spans", "(", "relation_spans", ")", "\n", "gold_splitted", "=", "[", "\n", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", "]", ",", "\n", "[", "Span", "(", "4", ",", "4", ",", "\"a\"", ")", ",", "Span", "(", "5", ",", "1", ",", "\"b\"", ")", "]", "\n", "]", "\n", "\n", "assert", "splitted_relation_spans", "==", "gold_splitted", "\n", "\n", "# Testcase 2: No Split", "\n", "\n", "relation_spans", "=", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", ",", "]", "\n", "\n", "splitted_relation_spans", "=", "split_relation_spans", "(", "relation_spans", ")", "\n", "gold_splitted", "=", "[", "\n", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", "]", ",", "\n", "]", "\n", "\n", "assert", "splitted_relation_spans", "==", "gold_splitted", "\n", "\n", "# Testcase 3: No Split but some repitition", "\n", "\n", "relation_spans", "=", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", ",", "Span", "(", "6", ",", "6", ",", "\"a\"", ")", ",", "Span", "(", "7", ",", "7", ",", "\"b\"", ")", ",", "]", "\n", "\n", "splitted_relation_spans", "=", "split_relation_spans", "(", "relation_spans", ")", "\n", "gold_splitted", "=", "[", "\n", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", ",", "Span", "(", "6", ",", "6", ",", "\"a\"", ")", ",", "Span", "(", "7", ",", "7", ",", "\"b\"", ")", ",", "]", ",", "\n", "]", "\n", "\n", "assert", "splitted_relation_spans", "==", "gold_splitted", "\n", "\n", "# Testcase 4: Split complicated", "\n", "\n", "relation_spans", "=", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", ",", "\n", "Span", "(", "6", ",", "6", ",", "\"a\"", ")", ",", "Span", "(", "7", ",", "7", ",", "\"c\"", ")", ",", "Span", "(", "9", ",", "9", ",", "\"b\"", ")", ",", "\n", "Span", "(", "13", ",", "13", ",", "\"c\"", ")", ",", "Span", "(", "15", ",", "15", ",", "\"b\"", ")", ",", "Span", "(", "17", ",", "17", ",", "\"a\"", ")", ",", "]", "\n", "\n", "splitted_relation_spans", "=", "split_relation_spans", "(", "relation_spans", ")", "\n", "gold_splitted", "=", "[", "\n", "[", "Span", "(", "1", ",", "1", ",", "\"a\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"b\"", ")", ",", "Span", "(", "4", ",", "4", ",", "\"c\"", ")", "]", ",", "\n", "[", "Span", "(", "6", ",", "6", ",", "\"a\"", ")", ",", "Span", "(", "7", ",", "7", ",", "\"c\"", ")", ",", "Span", "(", "9", ",", "9", ",", "\"b\"", ")", "]", ",", "\n", "[", "Span", "(", "13", ",", "13", ",", "\"c\"", ")", ",", "Span", "(", "15", ",", "15", ",", "\"b\"", ")", ",", "Span", "(", "17", ",", "17", ",", "\"a\"", ")", ",", "]", ",", "\n", "]", "\n", "\n", "assert", "splitted_relation_spans", "==", "gold_splitted", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_transform_label_to_relation": [[401, 446], ["mare.label.extraction.transform_tags_to_relation", "mare.label.extraction.transform_tags_to_relation", "mare.label.extraction.transform_tags_to_relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Relation", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span", "mare.label.extraction.Span"], "function", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation"], ["", "def", "test_transform_label_to_relation", "(", ")", ":", "\n", "\n", "# Testcase 1: Multiple Relation instances", "\n", "\n", "    ", "tags", "=", "[", "\"O\"", ",", "\"B-X-Ol-per\"", ",", "\"O\"", ",", "\"B-X-Ol-org\"", ",", "\"O\"", ",", "\"B-Y-Ol-per\"", ",", "\"I-Y-Ol-per\"", ",", "\"O\"", ",", "\"B-Y-Ol-org\"", ",", "\"O\"", ",", "]", "\n", "\n", "relations", "=", "transform_tags_to_relation", "(", "tags", ",", "has_mode", "=", "True", ")", "\n", "\n", "gold", "=", "[", "\n", "Relation", "(", "[", "Span", "(", "1", ",", "1", ",", "\"per\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"org\"", ")", "]", ",", "label", "=", "\"Ol\"", ")", ",", "\n", "Relation", "(", "[", "Span", "(", "5", ",", "6", ",", "\"per\"", ")", ",", "Span", "(", "8", ",", "8", ",", "\"org\"", ")", "]", ",", "label", "=", "\"Ol\"", ")", ",", "\n", "]", "\n", "\n", "assert", "relations", "==", "gold", ",", "f\"Tags Sequence {tags}\"", "\n", "\n", "# Testcase 2: Shared Argument", "\n", "\n", "tags", "=", "[", "\"O\"", ",", "\"B-X-Accident-location\"", ",", "\"O\"", ",", "\"B-X-Accident-trigger\"", ",", "\"O\"", ",", "\"B-X-TrafficJam-trigger\"", ",", "\"O\"", "]", "\n", "\n", "relations", "=", "transform_tags_to_relation", "(", "tags", ",", "has_mode", "=", "True", ")", "\n", "\n", "gold", "=", "[", "\n", "Relation", "(", "[", "Span", "(", "1", ",", "1", ",", "\"location\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"trigger\"", ")", "]", ",", "label", "=", "\"Accident\"", ")", ",", "\n", "Relation", "(", "[", "Span", "(", "1", ",", "1", ",", "\"location\"", ")", ",", "Span", "(", "5", ",", "5", ",", "\"trigger\"", ")", "]", ",", "label", "=", "\"TrafficJam\"", ")", ",", "\n", "]", "\n", "\n", "assert", "relations", "==", "gold", ",", "f\"Tags Sequence {tags}\"", "\n", "\n", "# Testcase 3: We expect Relations to have an inner-distance from at most 18", "\n", "\n", "tags", "=", "[", "\"O\"", ",", "\"B-X-Accident-location\"", ",", "\"O\"", ",", "\"B-X-Accident-trigger\"", ",", "\"O\"", ",", "\n", "\"O\"", ",", "\"B-Y-Accident-location\"", ",", "\"O\"", ",", "\"B-Y-Accident-trigger\"", ",", "\"O\"", ",", "\n", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\n", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\"O\"", ",", "\n", "\"O\"", ",", "\"B-X-Accident-location\"", ",", "\"O\"", ",", "\"B-X-Accident-trigger\"", ",", "\"O\"", ",", "]", "\n", "\n", "relations", "=", "transform_tags_to_relation", "(", "tags", ",", "has_mode", "=", "True", ",", "max_inner_range", "=", "15", ")", "\n", "\n", "gold", "=", "[", "\n", "Relation", "(", "[", "Span", "(", "1", ",", "1", ",", "\"location\"", ")", ",", "Span", "(", "3", ",", "3", ",", "\"trigger\"", ")", "]", ",", "label", "=", "\"Accident\"", ")", ",", "\n", "Relation", "(", "[", "Span", "(", "6", ",", "6", ",", "\"location\"", ")", ",", "Span", "(", "8", ",", "8", ",", "\"trigger\"", ")", "]", ",", "label", "=", "\"Accident\"", ")", ",", "\n", "Relation", "(", "[", "Span", "(", "31", ",", "31", ",", "\"location\"", ")", ",", "Span", "(", "33", ",", "33", ",", "\"trigger\"", ")", "]", ",", "label", "=", "\"Accident\"", ")", "\n", "]", "\n", "\n", "assert", "relations", "==", "gold", ",", "f\"Tags Sequence {tags}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_re_transform_relations_keep_first": [[448, 504], ["print", "print", "len", "mare.label.extraction.extract_relations_from_smart_sample", "sorted", "mare.label.extraction.combined_relation_tags", "mare.label.extraction.transform_tags_to_relation", "set", "set", "len", "len", "len", "bool", "set.intersection", "set.difference", "set.difference", "len"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation"], ["", "def", "test_re_transform_relations_keep_first", "(", "dataset", ")", ":", "\n", "\n", "    ", "number_of_samples_with_relations", "=", "0", "\n", "number_of_correct_samples", "=", "0", "\n", "\n", "tp", "=", "0", "\n", "fp", "=", "0", "\n", "fn", "=", "0", "\n", "\n", "for", "sample", "in", "dataset", ":", "\n", "\n", "        ", "n", "=", "len", "(", "sample", "[", "\"tokens\"", "]", ")", "\n", "\n", "gold_relations", "=", "extract_relations_from_smart_sample", "(", "sample", ",", "only_mandatory", "=", "False", ")", "\n", "gold_relations", "=", "sorted", "(", "gold_relations", ",", "key", "=", "lambda", "x", ":", "(", "x", ".", "start", ",", "x", ".", "end", ",", "x", ".", "label", ")", ")", "\n", "tags", "=", "combined_relation_tags", "(", "gold_relations", ",", "n", ",", "include_mode", "=", "False", ")", "\n", "\n", "transformed_relations", "=", "transform_tags_to_relation", "(", "tags", ",", "max_inner_range", "=", "10", ",", "has_mode", "=", "False", ")", "\n", "\n", "if", "not", "gold_relations", ":", "\n", "            ", "assert", "not", "bool", "(", "transformed_relations", ")", ",", "f\"Should not have found any relation for\"", "f\"\\n{gold_relations}\"", "f\"\\nbut found:\"", "f\"\\n{transformed_relations}\"", "\n", "number_of_correct_samples", "+=", "1", "\n", "", "else", ":", "\n", "\n", "# assert gold_relations[0].label == transformed_relations[0].label, f\"Transformation of \\n{gold_relations}\" \\", "\n", "#                                                                   f\"\\n{tags}\" \\", "\n", "#                                                                   f\"\\n{transformed_relations}\" \\", "\n", "#                                                                   f\"\\n first relation has not same label.\"", "\n", "\n", "            ", "number_of_samples_with_relations", "+=", "1", "\n", "\n", "gold_set", "=", "set", "(", "gold_relations", ")", "\n", "transformed_set", "=", "set", "(", "transformed_relations", ")", "\n", "\n", "if", "gold_set", "==", "transformed_set", ":", "\n", "                ", "number_of_correct_samples", "+=", "1", "\n", "\n", "# if gold_set != transformed_set:", "\n", "#     print(\"hallo\")", "\n", "\n", "", "tp", "+=", "len", "(", "gold_set", ".", "intersection", "(", "transformed_set", ")", ")", "\n", "fn", "+=", "len", "(", "gold_set", ".", "difference", "(", "transformed_set", ")", ")", "\n", "fp", "+=", "len", "(", "transformed_set", ".", "difference", "(", "gold_set", ")", ")", "\n", "\n", "\n", "", "", "p", "=", "tp", "/", "(", "tp", "+", "fp", ")", "if", "(", "tp", "+", "fp", ")", ">", "0", "else", "0", "\n", "r", "=", "tp", "/", "(", "tp", "+", "fn", ")", "if", "(", "tp", "+", "fn", ")", ">", "0", "else", "0", "\n", "f", "=", "2", "*", "(", "p", "*", "r", ")", "/", "(", "p", "+", "r", ")", "if", "(", "p", "+", "r", ")", ">", "0", "else", "0", "\n", "\n", "print", "(", "f\"f: {f} p: {p} r: {r} of first relations correct!\"", ")", "\n", "print", "(", "f\"Amount of correct samples {number_of_correct_samples / len(dataset)}\"", ")", "\n", "\n", "assert", "f", ">", "0.85", ",", "\"F Score to low\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.test_extraction.test_ner_extraction": [[506, 518], ["len", "mare.label.extraction.extract_entities", "mare.label.extraction.combine_spans_to_entity_tags", "mare.label.extraction.transform_tag_to_entity", "len", "len"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.extract_entities", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combine_spans_to_entity_tags", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tag_to_entity"], ["", "def", "test_ner_extraction", "(", "dataset", ")", ":", "\n", "    ", "for", "sample", "in", "dataset", ":", "\n", "\n", "        ", "concept_mentions", "=", "sample", "[", "\"conceptMentions\"", "]", "\n", "n", "=", "len", "(", "sample", "[", "\"tokens\"", "]", ")", "\n", "gold_entities", "=", "extract_entities", "(", "sample", ")", "\n", "\n", "assert", "len", "(", "concept_mentions", ")", "==", "len", "(", "gold_entities", ")", ",", "f\"Found unequal number of entities in {sample}\"", "\n", "\n", "ent_tags", "=", "combine_spans_to_entity_tags", "(", "gold_entities", ",", "n", ")", "\n", "\n", "transformed_entities", "=", "transform_tag_to_entity", "(", "ent_tags", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.__init__": [[13, 17], ["int", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pos1", ",", "pos2", ",", "role", ":", "str", "=", "None", ",", "text", ":", "str", "=", "None", ")", ":", "\n", "        ", "self", ".", "span", "=", "(", "int", "(", "pos1", ")", ",", "int", "(", "pos2", ")", ")", "\n", "self", ".", "role", "=", "role", "\n", "self", ".", "text", "=", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.start": [[18, 21], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "start", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.end": [[22, 25], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "end", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.to_josn": [[26, 31], ["None"], "methods", ["None"], ["", "def", "to_josn", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"start\"", ":", "self", ".", "span", "[", "0", "]", ",", "\n", "\"end\"", ":", "self", ".", "span", "[", "1", "]", ",", "\n", "\"name\"", ":", "self", ".", "role", "if", "self", ".", "role", "else", "\"\"", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.__repr__": [[33, 35], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"[{repr(self.span)}, {self.role if self.role is not None else ''}]\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.__eq__": [[36, 38], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "role", "==", "other", ".", "role", "and", "self", ".", "span", "==", "other", ".", "span", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Span.__hash__": [[39, 41], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "(", "self", ".", "span", ",", "self", ".", "role", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.__init__": [[44, 69], ["AttributeError", "itertools.combinations", "len", "spans.remove", "spans.remove", "spans.remove", "spans.remove", "spans.remove", "spans.remove"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "spans", ":", "List", "[", "Span", "]", ",", "label", ":", "str", "=", "None", ",", "allow_overlaps", "=", "False", ")", ":", "\n", "\n", "        ", "if", "not", "len", "(", "spans", ")", ">=", "1", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Tried to create Relation with no spans\"", ")", "\n", "\n", "# TODO ist das gut so? Review", "\n", "", "if", "not", "allow_overlaps", ":", "\n", "            ", "for", "s1", ",", "s2", "in", "itertools", ".", "combinations", "(", "spans", ",", "2", ")", ":", "\n", "                ", "if", "s2", ".", "start", "<=", "s1", ".", "start", "<=", "s2", ".", "end", "or", "s2", ".", "start", "<=", "s1", ".", "end", "<=", "s2", ".", "end", ":", "\n", "# Found conflicting spans!", "\n", "                    ", "if", "s1", ".", "start", "<", "s2", ".", "start", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "elif", "s2", ".", "start", "<", "s1", ".", "start", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "", "elif", "s1", ".", "end", "<", "s2", ".", "end", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "elif", "s2", ".", "end", "<", "s1", ".", "end", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "", "elif", "s1", ".", "role", "<", "s2", ".", "role", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "else", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "\n", "", "", "", "", "self", ".", "spans", "=", "spans", "\n", "self", ".", "label", "=", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.start": [[70, 73], ["min"], "methods", ["None"], ["", "@", "property", "\n", "def", "start", "(", "self", ")", ":", "\n", "        ", "return", "min", "(", "(", "s", ".", "start", "for", "s", "in", "self", ".", "spans", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.end": [[74, 77], ["max"], "methods", ["None"], ["", "@", "property", "\n", "def", "end", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "(", "s", ".", "end", "for", "s", "in", "self", ".", "spans", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.get_bio_tags": [[78, 101], ["max", "RuntimeError"], "methods", ["None"], ["", "def", "get_bio_tags", "(", "self", ",", "n", ":", "int", ",", "mode", ":", "str", "=", "None", ")", "->", "Iterable", "[", "str", "]", ":", "\n", "\n", "        ", "if", "not", "mode", ":", "\n", "            ", "mode", "=", "\"\"", "\n", "\n", "", "n_m", "=", "max", "(", "n", ",", "self", ".", "end", "+", "1", ")", "\n", "\n", "tags", "=", "[", "\"O\"", "]", "*", "n_m", "\n", "\n", "for", "span", "in", "self", ".", "spans", ":", "\n", "\n", "            ", "if", "tags", "[", "span", ".", "start", ":", "span", ".", "end", "+", "1", "]", "!=", "[", "\"O\"", "]", "*", "(", "1", "+", "span", ".", "end", "-", "span", ".", "start", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "f\"Nested argument types for relation {self}, \"", "\n", "f\"cannot build well-defined tag sequence.\"", ")", "\n", "\n", "", "tag_post", "=", "f\"{self.label}-{span.role}\"", "\n", "if", "mode", "!=", "\"\"", ":", "\n", "                ", "tag_post", "=", "f\"{mode}-{tag_post}\"", "\n", "", "tags", "[", "span", ".", "start", "]", "=", "f\"B-{tag_post}\"", "if", "mode", "==", "\"\"", "else", "f\"B-{tag_post}\"", "\n", "if", "span", ".", "end", ">", "span", ".", "start", ":", "\n", "                ", "tags", "[", "span", ".", "start", "+", "1", ":", "span", ".", "end", "+", "1", "]", "=", "[", "f\"I-{tag_post}\"", "]", "*", "(", "span", ".", "end", "-", "span", ".", "start", ")", "\n", "\n", "", "", "return", "tags", "[", ":", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.entities": [[102, 110], ["copy.deepcopy", "zip"], "methods", ["None"], ["", "@", "property", "\n", "def", "entities", "(", "self", ")", ":", "\n", "        ", "entities", "=", "copy", ".", "deepcopy", "(", "self", ".", "spans", ")", "\n", "\n", "for", "ent", ",", "span", "in", "zip", "(", "entities", ",", "self", ".", "spans", ")", ":", "\n", "            ", "ent", ".", "role", "=", "f\"{self.label}-{span.role}\"", "\n", "\n", "", "return", "entities", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.to_json": [[111, 115], ["s.to_josn"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Span.to_josn"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"name\"", ":", "self", ".", "label", ",", "\n", "\"ents\"", ":", "[", "s", ".", "to_josn", "(", ")", "for", "s", "in", "self", ".", "spans", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.__repr__": [[118, 120], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{{({repr(self.spans)}, {self.label if self.label is not None else ''})}}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.__eq__": [[121, 123], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "{", "s", "for", "s", "in", "self", ".", "spans", "}", "==", "{", "s", "for", "s", "in", "other", ".", "spans", "}", "and", "self", ".", "label", "==", "other", ".", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.Relation.__hash__": [[124, 126], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.get_token_index_from_char_index": [[128, 143], ["sorted", "AttributeError", "enumerate", "enumerate", "enumerate", "enumerate"], "function", ["None"], ["", "", "def", "get_token_index_from_char_index", "(", "start", ",", "end", ",", "token_borders", ",", "fuzzy", "=", "False", ")", ":", "\n", "\n", "    ", "token_borders", "=", "sorted", "(", "token_borders", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "\n", "if", "fuzzy", ":", "\n", "        ", "token_start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", ">=", "start", "]", "\n", "token_end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", ">=", "end", "]", "\n", "", "else", ":", "\n", "        ", "token_start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", "==", "start", "]", "\n", "token_end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", "==", "end", "]", "\n", "\n", "", "try", ":", "\n", "        ", "return", "token_start", "[", "0", "]", ",", "token_end", "[", "0", "]", "\n", "", "except", "IndexError", ":", "\n", "        ", "raise", "AttributeError", "(", "f\"Tokenborders {token_borders} are not valid \"", "\n", "f\"for char indizies {start, end} with fuzzy={fuzzy}\"", ")", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.extract_relations_from_smart_sample": [[146, 176], ["sorted", "extraction.get_token_index_from_char_index", "extraction.Span", "extraction.Relation"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.get_token_index_from_char_index"], ["", "", "def", "extract_relations_from_smart_sample", "(", "sample", ",", "only_mandatory", "=", "False", ",", "include_trigger", "=", "True", ")", ":", "\n", "    ", "token_borders", "=", "[", "(", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ",", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", ")", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "\n", "relations", "=", "[", "]", "\n", "\n", "for", "relation", "in", "sample", "[", "\"relationMentions\"", "]", ":", "\n", "\n", "        ", "relation_name", "=", "relation", "[", "\"name\"", "]", "\n", "spans", "=", "[", "]", "\n", "\n", "for", "argument", "in", "relation", "[", "\"args\"", "]", ":", "\n", "\n", "            ", "if", "only_mandatory", "and", "argument", "[", "\"role\"", "]", "not", "in", "relation_mandatory_args", "[", "relation_name", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "not", "include_trigger", "and", "argument", "[", "\"role\"", "]", "==", "\"trigger\"", ":", "\n", "                ", "continue", "\n", "\n", "", "argument_role", "=", "argument", "[", "\"role\"", "]", "\n", "entity", "=", "argument", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "\n", "start", ",", "end", "=", "get_token_index_from_char_index", "(", "entity", "[", "\"start\"", "]", ",", "entity", "[", "\"end\"", "]", ",", "token_borders", ")", "\n", "\n", "spans", "+=", "[", "Span", "(", "start", ",", "end", ",", "role", "=", "argument_role", ")", "]", "\n", "\n", "", "if", "spans", ":", "\n", "            ", "relations", "+=", "[", "Relation", "(", "spans", ",", "label", "=", "relation_name", ")", "]", "\n", "\n", "", "", "relations", "=", "sorted", "(", "relations", ",", "key", "=", "lambda", "r", ":", "(", "r", ".", "start", ",", "r", ".", "end", ",", "r", ".", "label", ")", ")", "\n", "\n", "return", "relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combined_relation_tags": [[178, 212], ["sorted", "sorted", "enumerate", "relation.get_bio_tags", "extraction.combined_relation_tags.get_tag_type"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags"], ["", "def", "combined_relation_tags", "(", "relations", ":", "Iterable", "[", "Relation", "]", ",", "n", ":", "int", ",", "include_mode", "=", "False", ")", "->", "List", "[", "str", "]", ":", "\n", "\n", "    ", "relations", "=", "sorted", "(", "relations", ",", "key", "=", "lambda", "r", ":", "(", "r", ".", "start", ",", "r", ".", "end", ",", "r", ".", "label", ")", ")", "\n", "\n", "rel_types_mode", "=", "{", "l", ":", "True", "for", "l", "in", "{", "r", ".", "label", "for", "r", "in", "relations", "}", "}", "\n", "\n", "tags", "=", "[", "\"O\"", "]", "*", "n", "\n", "dominant_type", "=", "\"O\"", "\n", "if", "relations", ":", "\n", "        ", "dominant_type", "=", "relations", "[", "0", "]", ".", "label", "\n", "\n", "", "relations", "=", "sorted", "(", "relations", ",", "key", "=", "lambda", "r", ":", "0", "if", "r", ".", "label", "==", "dominant_type", "else", "1", ")", "\n", "\n", "def", "get_tag_type", "(", "t", ":", "str", ")", "->", "str", ":", "\n", "        ", "if", "t", "==", "\"O\"", ":", "\n", "            ", "return", "\"O\"", "\n", "", "rel_text", "=", "t", "[", "2", ":", "]", "\n", "type", "=", "rel_text", "[", ":", "rel_text", ".", "find", "(", "\"-\"", ")", "]", "\n", "return", "type", "\n", "\n", "", "for", "relation", "in", "relations", ":", "\n", "        ", "pre", "=", "rel_types_mode", "[", "relation", ".", "label", "]", "\n", "rel_types_mode", "[", "relation", ".", "label", "]", "=", "not", "rel_types_mode", "[", "relation", ".", "label", "]", "\n", "if", "include_mode", ":", "\n", "            ", "sub_tags", "=", "relation", ".", "get_bio_tags", "(", "n", ",", "mode", "=", "\"X\"", ")", "if", "pre", "else", "relation", ".", "get_bio_tags", "(", "n", ",", "mode", "=", "\"Y\"", ")", "\n", "", "else", ":", "\n", "            ", "sub_tags", "=", "relation", ".", "get_bio_tags", "(", "n", ")", "\n", "", "for", "i", ",", "tag", "in", "enumerate", "(", "sub_tags", ")", ":", "\n", "            ", "typ", "=", "get_tag_type", "(", "tag", ")", "\n", "if", "tags", "[", "i", "]", "==", "\"O\"", "or", "(", "typ", "==", "dominant_type", "and", "get_tag_type", "(", "tags", "[", "i", "]", ")", "!=", "dominant_type", ")", ":", "\n", "                ", "if", "tag", "!=", "\"O\"", ":", "\n", "                    ", "tags", "[", "i", "]", "=", "tag", "\n", "\n", "", "", "", "", "return", "tags", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.split_relation_spans": [[214, 257], ["set", "len", "len", "range", "set.add", "set"], "function", ["None"], ["", "def", "split_relation_spans", "(", "relation_spans", ":", "List", "[", "Span", "]", ")", "->", "List", "[", "List", "[", "Span", "]", "]", ":", "\n", "    ", "\"\"\"\n    We try to find specific pattern in the relation roles that indicate multiple relation instead of one.\n\n    1) E.g. person, organization, person, organization\n        Here we have a \"recurring structure\" => two relations (person, organization), (person, organization)\n\n    :param relation_spans:\n    :return:\n    \"\"\"", "\n", "\n", "relation_roles", "=", "[", "s", ".", "role", "for", "s", "in", "relation_spans", "]", "\n", "relations_string", "=", "\"\"", ".", "join", "(", "[", "f\"[{r}]\"", "for", "r", "in", "relation_roles", "]", ")", "\n", "\n", "prototypical_relation_roles", "=", "set", "(", ")", "\n", "\n", "for", "role", "in", "relation_roles", ":", "\n", "        ", "if", "not", "role", "in", "prototypical_relation_roles", ":", "\n", "            ", "prototypical_relation_roles", ".", "add", "(", "role", ")", "\n", "continue", "\n", "\n", "# Here we found a possible reoccuring pattern", "\n", "", "pattern_size", "=", "len", "(", "prototypical_relation_roles", ")", "\n", "n", "=", "len", "(", "relation_roles", ")", "\n", "if", "n", "%", "pattern_size", "!=", "0", ":", "\n", "# pattern does not match", "\n", "            ", "break", "\n", "\n", "", "number_of_relations", "=", "n", "//", "pattern_size", "\n", "potential_split", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "number_of_relations", ")", ":", "\n", "            ", "start", "=", "i", "*", "pattern_size", "\n", "end", "=", "start", "+", "pattern_size", "\n", "potential_split", "+=", "[", "relation_spans", "[", "start", ":", "end", "]", "]", "\n", "\n", "", "for", "split", "in", "potential_split", ":", "\n", "            ", "split_roles", "=", "[", "s", ".", "role", "for", "s", "in", "split", "]", "\n", "if", "set", "(", "split_roles", ")", "!=", "prototypical_relation_roles", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "potential_split", "\n", "\n", "", "return", "[", "relation_spans", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.xybio_tags_to_spans": [[259, 315], ["set", "enumerate", "list", "spans.add", "allennlp.data.dataset_readers.dataset_utils.span_utils.InvalidTagSequence", "len", "spans.add", "spans.add", "spans.add"], "function", ["None"], ["", "def", "xybio_tags_to_spans", "(", "\n", "tag_sequence", ":", "List", "[", "str", "]", ",", "classes_to_ignore", ":", "List", "[", "str", "]", "=", "None", "\n", ")", "->", "List", "[", "TypedStringSpan", "]", ":", "\n", "    ", "classes_to_ignore", "=", "classes_to_ignore", "or", "[", "]", "\n", "spans", ":", "Set", "[", "Tuple", "[", "str", ",", "Tuple", "[", "int", ",", "int", "]", "]", "]", "=", "set", "(", ")", "\n", "span_start", "=", "0", "\n", "span_end", "=", "0", "\n", "active_conll_tag", "=", "None", "\n", "active_pos_mode", "=", "None", "\n", "for", "index", ",", "string_tag", "in", "enumerate", "(", "tag_sequence", ")", ":", "\n", "# Actual BIO tag.", "\n", "\n", "        ", "bio_tag", "=", "string_tag", "[", "0", "]", "\n", "if", "bio_tag", "not", "in", "[", "\"B\"", ",", "\"I\"", ",", "\"O\"", "]", ":", "\n", "            ", "raise", "InvalidTagSequence", "(", "tag_sequence", ")", "\n", "", "conll_tag", "=", "string_tag", "[", "4", ":", "]", "\n", "mode", "=", "string_tag", "[", "2", "]", "if", "len", "(", "string_tag", ")", ">", "2", "else", "\"O\"", "\n", "if", "bio_tag", "==", "\"O\"", "or", "conll_tag", "in", "classes_to_ignore", ":", "\n", "# The span has ended.", "\n", "            ", "if", "active_conll_tag", "is", "not", "None", ":", "\n", "                ", "spans", ".", "add", "(", "(", "active_conll_tag", ",", "(", "span_start", ",", "span_end", ")", ",", "active_pos_mode", ")", ")", "\n", "", "active_conll_tag", "=", "None", "\n", "active_pos_mode", "=", "None", "\n", "# We don't care about tags we are", "\n", "# told to ignore, so we do nothing.", "\n", "continue", "\n", "", "elif", "bio_tag", "==", "\"B\"", ":", "\n", "# We are entering a new span; reset indices", "\n", "# and active tag to new span.", "\n", "            ", "if", "active_conll_tag", "is", "not", "None", ":", "\n", "                ", "spans", ".", "add", "(", "(", "active_conll_tag", ",", "(", "span_start", ",", "span_end", ")", ",", "active_pos_mode", ")", ")", "\n", "", "active_conll_tag", "=", "conll_tag", "\n", "active_pos_mode", "=", "mode", "\n", "span_start", "=", "index", "\n", "span_end", "=", "index", "\n", "", "elif", "bio_tag", "==", "\"I\"", "and", "conll_tag", "==", "active_conll_tag", ":", "\n", "# We're inside a span.", "\n", "            ", "span_end", "+=", "1", "\n", "", "else", ":", "\n", "# This is the case the bio label is an \"I\", but either:", "\n", "# 1) the span hasn't started - i.e. an ill formed span.", "\n", "# 2) The span is an I tag for a different conll annotation.", "\n", "# We'll process the previous span if it exists, but also", "\n", "# include this span. This is important, because otherwise,", "\n", "# a model may get a perfect F1 score whilst still including", "\n", "# false positive ill-formed spans.", "\n", "            ", "if", "active_conll_tag", "is", "not", "None", ":", "\n", "                ", "spans", ".", "add", "(", "(", "active_conll_tag", ",", "(", "span_start", ",", "span_end", ")", ",", "active_pos_mode", ")", ")", "\n", "", "active_conll_tag", "=", "conll_tag", "\n", "active_pos_mode", "=", "mode", "\n", "span_start", "=", "index", "\n", "span_end", "=", "index", "\n", "# Last token might have been a part of a valid span.", "\n", "", "", "if", "active_conll_tag", "is", "not", "None", ":", "\n", "        ", "spans", ".", "add", "(", "(", "active_conll_tag", ",", "(", "span_start", ",", "span_end", ")", ",", "active_pos_mode", ")", ")", "\n", "", "return", "list", "(", "spans", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_spans_to_relation": [[317, 380], ["sorted", "a[].find", "range", "extraction.Span", "extraction.Span", "a[].startswith", "len", "list", "extraction.Relation", "a[].startswith", "abs", "mandatory_args.get", "mandatory_args[].difference", "len", "mare.defs.replacable_args.get", "extraction.Relation", "sorted", "set", "set", "extraction.Span", "a[].find", "a[].find", "abs", "abs"], "function", ["None"], ["", "def", "transform_spans_to_relation", "(", "spans", ":", "List", "[", "Span", "]", ",", "max_inner_range", "=", "1000", ",", "has_mode", "=", "False", ",", "allow_overlaps", "=", "False", ",", "include_trigger", "=", "True", ")", ":", "\n", "    ", "if", "include_trigger", ":", "\n", "        ", "mandatory_args", "=", "relation_mandatory_args", "\n", "", "else", ":", "\n", "        ", "mandatory_args", "=", "relation_mandatory_args_without_trigger", "\n", "\n", "", "relation_label", "=", "{", "a", "[", "0", "]", "[", ":", "a", "[", "0", "]", ".", "find", "(", "\"-\"", ")", "]", "for", "a", "in", "spans", "}", "\n", "\n", "relations", "=", "[", "]", "\n", "\n", "for", "label", "in", "relation_label", ":", "\n", "\n", "        ", "modes", "=", "[", "\"\"", "]", "\n", "if", "has_mode", ":", "\n", "            ", "modes", "=", "[", "\"X\"", ",", "\"Y\"", "]", "\n", "\n", "", "for", "mode", "in", "modes", ":", "\n", "            ", "if", "mode", "!=", "\"\"", ":", "\n", "                ", "relation_spans", "=", "[", "Span", "(", "*", "a", "[", "1", "]", ",", "role", "=", "a", "[", "0", "]", "[", "a", "[", "0", "]", ".", "find", "(", "\"-\"", ")", "+", "1", ":", "]", ")", "for", "a", "in", "spans", "if", "\n", "a", "[", "0", "]", ".", "startswith", "(", "label", ")", "and", "a", "[", "2", "]", "==", "mode", "]", "\n", "", "else", ":", "\n", "                ", "relation_spans", "=", "[", "Span", "(", "*", "a", "[", "1", "]", ",", "role", "=", "a", "[", "0", "]", "[", "a", "[", "0", "]", ".", "find", "(", "\"-\"", ")", "+", "1", ":", "]", ")", "for", "a", "in", "spans", "if", "\n", "a", "[", "0", "]", ".", "startswith", "(", "label", ")", "]", "\n", "", "if", "relation_spans", ":", "\n", "                ", "final_spans", "=", "[", "]", "\n", "start", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "relation_spans", ")", "-", "1", ")", ":", "\n", "                    ", "curr_span_end", "=", "relation_spans", "[", "i", "]", ".", "end", "\n", "next_span_start", "=", "relation_spans", "[", "i", "+", "1", "]", ".", "start", "\n", "curr_spans", "=", "relation_spans", "[", "start", ":", "i", "+", "1", "]", "\n", "curr_arg_types", "=", "{", "s", ".", "role", "for", "s", "in", "curr_spans", "}", "\n", "if", "abs", "(", "curr_span_end", "-", "next_span_start", ")", ">", "max_inner_range", "and", "mandatory_args", ".", "get", "(", "label", ",", "\n", "set", "(", "\n", "\"UNLIKELY_LABEL_BAMMM\"", ")", ")", "<=", "curr_arg_types", ":", "\n", "                        ", "final_spans", "+=", "[", "curr_spans", "]", "\n", "start", "=", "i", "+", "1", "\n", "\n", "", "", "final_spans", "+=", "[", "relation_spans", "[", "start", ":", "]", "]", "\n", "\n", "for", "relation_spans", "in", "final_spans", ":", "\n", "\n", "# Check if we have all mand. arguments", "\n", "                    ", "arg_types", "=", "{", "t", ".", "role", "for", "t", "in", "relation_spans", "}", "\n", "# Check if we have found all mand. args", "\n", "if", "label", "in", "mandatory_args", "and", "not", "mandatory_args", "[", "label", "]", "<", "arg_types", ":", "\n", "                        ", "missing_type", "=", "list", "(", "mandatory_args", "[", "label", "]", ".", "difference", "(", "arg_types", ")", ")", "\n", "\n", "if", "len", "(", "missing_type", ")", "==", "1", ":", "\n", "                            ", "missing_type", "=", "missing_type", "[", "0", "]", "\n", "possible_types", "=", "replacable_args", ".", "get", "(", "f\"{label}-{missing_type}\"", ",", "set", "(", ")", ")", "\n", "help_relation", "=", "Relation", "(", "relation_spans", ",", "allow_overlaps", "=", "allow_overlaps", ")", "\n", "potential_args", "=", "[", "s", "for", "s", "in", "spans", "if", "s", "[", "0", "]", "in", "possible_types", "]", "\n", "potential_args", "=", "sorted", "(", "potential_args", ",", "\n", "key", "=", "lambda", "s", ":", "abs", "(", "s", "[", "1", "]", "[", "0", "]", "-", "help_relation", ".", "start", ")", "+", "abs", "(", "\n", "s", "[", "1", "]", "[", "1", "]", "-", "help_relation", ".", "end", ")", ")", "\n", "\n", "if", "potential_args", ":", "\n", "                                ", "new_span", "=", "Span", "(", "potential_args", "[", "0", "]", "[", "1", "]", "[", "0", "]", ",", "potential_args", "[", "0", "]", "[", "1", "]", "[", "1", "]", ",", "role", "=", "missing_type", ")", "\n", "relation_spans", "+=", "[", "new_span", "]", "\n", "\n", "", "", "", "relations", "+=", "[", "Relation", "(", "relation_spans", ",", "label", "=", "label", ",", "allow_overlaps", "=", "allow_overlaps", ")", "]", "\n", "\n", "", "", "", "", "return", "sorted", "(", "relations", ",", "key", "=", "lambda", "x", ":", "(", "x", ".", "start", ",", "x", ".", "end", ",", "x", ".", "label", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tags_to_relation": [[382, 389], ["extraction.transform_spans_to_relation", "sorted", "sorted", "extraction.xybio_tags_to_spans", "allennlp.data.dataset_readers.dataset_utils.bio_tags_to_spans"], "function", ["home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_spans_to_relation", "home.repos.pwc.inspect_result.mslars_mare.label.extraction.xybio_tags_to_spans"], ["", "def", "transform_tags_to_relation", "(", "tags", ":", "List", "[", "str", "]", ",", "max_inner_range", "=", "1000", ",", "has_mode", "=", "False", ",", "include_trigger", "=", "True", ")", ":", "\n", "    ", "if", "has_mode", ":", "\n", "        ", "spans", "=", "sorted", "(", "xybio_tags_to_spans", "(", "tags", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "spans", "=", "sorted", "(", "bio_tags_to_spans", "(", "tags", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "\n", "", "return", "transform_spans_to_relation", "(", "spans", ",", "max_inner_range", ",", "has_mode", ",", "include_trigger", "=", "include_trigger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.extract_entities": [[391, 406], ["enumerate", "enumerate", "len", "len", "extraction.Span"], "function", ["None"], ["", "def", "extract_entities", "(", "sample", ")", ":", "\n", "    ", "token_borders", "=", "[", "(", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ",", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", ")", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "\n", "entities", "=", "[", "]", "\n", "for", "concept_mention", "in", "sample", "[", "\"conceptMentions\"", "]", ":", "\n", "        ", "start", "=", "concept_mention", "[", "\"span\"", "]", "[", "\"start\"", "]", "\n", "end", "=", "concept_mention", "[", "\"span\"", "]", "[", "\"end\"", "]", "\n", "\n", "start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", "==", "start", "]", "\n", "end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", "==", "end", "]", "\n", "\n", "if", "len", "(", "start", ")", ">", "0", "and", "len", "(", "end", ")", ">", "0", ":", "\n", "            ", "entities", "+=", "[", "Span", "(", "start", "[", "0", "]", ",", "end", "[", "0", "]", ",", "role", "=", "concept_mention", "[", "\"type\"", "]", ")", "]", "\n", "\n", "", "", "return", "entities", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.combine_spans_to_entity_tags": [[408, 419], ["None"], "function", ["None"], ["", "def", "combine_spans_to_entity_tags", "(", "spans", ":", "Span", ",", "n", ":", "int", ")", ":", "\n", "\n", "        ", "ent_labels", "=", "[", "\"O\"", "]", "*", "n", "\n", "\n", "if", "spans", "is", "not", "None", ":", "\n", "            ", "for", "ent", "in", "spans", ":", "\n", "                ", "ent_labels", "[", "ent", ".", "start", "]", "=", "f\"B-{ent.role}\"", "\n", "if", "ent", ".", "end", ">", "ent", ".", "start", ":", "\n", "                    ", "ent_labels", "[", "ent", ".", "start", "+", "1", ":", "ent", ".", "end", "+", "1", "]", "=", "[", "f\"I-{ent.role}\"", "]", "*", "(", "ent", ".", "end", "-", "ent", ".", "start", ")", "\n", "\n", "", "", "", "return", "ent_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.label.extraction.transform_tag_to_entity": [[421, 426], ["sorted", "extraction.Span", "allennlp.data.dataset_readers.dataset_utils.bio_tags_to_spans"], "function", ["None"], ["", "def", "transform_tag_to_entity", "(", "tags", ":", "List", "[", "str", "]", ")", ":", "\n", "\n", "    ", "spans", "=", "[", "Span", "(", "s", "[", "1", "]", "[", "0", "]", ",", "s", "[", "1", "]", "[", "1", "]", ",", "role", "=", "s", "[", "0", "]", ")", "for", "s", "in", "bio_tags_to_spans", "(", "tags", ")", "]", "\n", "\n", "return", "sorted", "(", "spans", ",", "key", "=", "lambda", "x", ":", "x", ".", "start", ")", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.__init__": [[24, 28], ["int", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pos1", ",", "pos2", ",", "role", ":", "str", "=", "None", ",", "text", ":", "str", "=", "None", ")", ":", "\n", "        ", "self", ".", "span", "=", "(", "int", "(", "pos1", ")", ",", "int", "(", "pos2", ")", ")", "\n", "self", ".", "role", "=", "role", "\n", "self", ".", "text", "=", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.start": [[29, 32], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "start", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.end": [[33, 36], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "end", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "span", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.to_josn": [[37, 42], ["None"], "methods", ["None"], ["", "def", "to_josn", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"start\"", ":", "self", ".", "span", "[", "0", "]", ",", "\n", "\"end\"", ":", "self", ".", "span", "[", "1", "]", ",", "\n", "\"name\"", ":", "self", ".", "role", "if", "self", ".", "role", "else", "\"\"", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.__repr__": [[44, 46], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"[{repr(self.span)}, {self.role if self.role is not None else ''}]\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.__eq__": [[47, 49], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "role", "==", "other", ".", "role", "and", "self", ".", "span", "==", "other", ".", "span", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Span.__hash__": [[50, 52], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "(", "self", ".", "span", ",", "self", ".", "role", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__init__": [[55, 80], ["AttributeError", "itertools.combinations", "len", "spans.remove", "spans.remove", "spans.remove", "spans.remove", "spans.remove", "spans.remove"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "spans", ":", "List", "[", "Span", "]", ",", "label", ":", "str", "=", "None", ",", "allow_overlaps", "=", "False", ")", ":", "\n", "\n", "        ", "if", "not", "len", "(", "spans", ")", ">=", "1", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Tried to create Relation with no spans\"", ")", "\n", "\n", "# TODO ist das gut so? Review", "\n", "", "if", "not", "allow_overlaps", ":", "\n", "            ", "for", "s1", ",", "s2", "in", "itertools", ".", "combinations", "(", "spans", ",", "2", ")", ":", "\n", "                ", "if", "s2", ".", "start", "<=", "s1", ".", "start", "<=", "s2", ".", "end", "or", "s2", ".", "start", "<=", "s1", ".", "end", "<=", "s2", ".", "end", ":", "\n", "# Found conflicting spans!", "\n", "                    ", "if", "s1", ".", "start", "<", "s2", ".", "start", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "elif", "s2", ".", "start", "<", "s1", ".", "start", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "", "elif", "s1", ".", "end", "<", "s2", ".", "end", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "elif", "s2", ".", "end", "<", "s1", ".", "end", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "", "elif", "s1", ".", "role", "<", "s2", ".", "role", ":", "\n", "                        ", "spans", ".", "remove", "(", "s2", ")", "\n", "", "else", ":", "\n", "                        ", "spans", ".", "remove", "(", "s1", ")", "\n", "\n", "", "", "", "", "self", ".", "spans", "=", "spans", "\n", "self", ".", "label", "=", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.start": [[81, 84], ["min"], "methods", ["None"], ["", "@", "property", "\n", "def", "start", "(", "self", ")", ":", "\n", "        ", "return", "min", "(", "(", "s", ".", "start", "for", "s", "in", "self", ".", "spans", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.end": [[85, 88], ["max"], "methods", ["None"], ["", "@", "property", "\n", "def", "end", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "(", "s", ".", "end", "for", "s", "in", "self", ".", "spans", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.get_bio_tags": [[89, 112], ["max", "RuntimeError"], "methods", ["None"], ["", "def", "get_bio_tags", "(", "self", ",", "n", ":", "int", ",", "mode", ":", "str", "=", "None", ")", "->", "Iterable", "[", "str", "]", ":", "\n", "\n", "        ", "if", "not", "mode", ":", "\n", "            ", "mode", "=", "\"\"", "\n", "\n", "", "n_m", "=", "max", "(", "n", ",", "self", ".", "end", "+", "1", ")", "\n", "\n", "tags", "=", "[", "\"O\"", "]", "*", "n_m", "\n", "\n", "for", "span", "in", "self", ".", "spans", ":", "\n", "\n", "            ", "if", "tags", "[", "span", ".", "start", ":", "span", ".", "end", "+", "1", "]", "!=", "[", "\"O\"", "]", "*", "(", "1", "+", "span", ".", "end", "-", "span", ".", "start", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "f\"Nested argument types for relation {self}, \"", "\n", "f\"cannot build well-defined tag sequence.\"", ")", "\n", "\n", "", "tag_post", "=", "f\"{self.label}-{span.role}\"", "\n", "if", "mode", "!=", "\"\"", ":", "\n", "                ", "tag_post", "=", "f\"{mode}-{tag_post}\"", "\n", "", "tags", "[", "span", ".", "start", "]", "=", "f\"B-{tag_post}\"", "if", "mode", "==", "\"\"", "else", "f\"B-{tag_post}\"", "\n", "if", "span", ".", "end", ">", "span", ".", "start", ":", "\n", "                ", "tags", "[", "span", ".", "start", "+", "1", ":", "span", ".", "end", "+", "1", "]", "=", "[", "f\"I-{tag_post}\"", "]", "*", "(", "span", ".", "end", "-", "span", ".", "start", ")", "\n", "\n", "", "", "return", "tags", "[", ":", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.entities": [[113, 121], ["copy.deepcopy", "zip"], "methods", ["None"], ["", "@", "property", "\n", "def", "entities", "(", "self", ")", ":", "\n", "        ", "entities", "=", "copy", ".", "deepcopy", "(", "self", ".", "spans", ")", "\n", "\n", "for", "ent", ",", "span", "in", "zip", "(", "entities", ",", "self", ".", "spans", ")", ":", "\n", "            ", "ent", ".", "role", "=", "f\"{self.label}-{span.role}\"", "\n", "\n", "", "return", "entities", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.to_json": [[122, 126], ["s.to_josn"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.util.util.Span.to_josn"], ["", "def", "to_json", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"name\"", ":", "self", ".", "label", ",", "\n", "\"ents\"", ":", "[", "s", ".", "to_josn", "(", ")", "for", "s", "in", "self", ".", "spans", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__repr__": [[128, 130], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{{({repr(self.spans)}, {self.label if self.label is not None else ''})}}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__eq__": [[131, 133], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "{", "s", "for", "s", "in", "self", ".", "spans", "}", "==", "{", "s", "for", "s", "in", "other", ".", "spans", "}", "and", "self", ".", "label", "==", "other", ".", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.Relation.__hash__": [[134, 136], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.extract_relations_from_smart_sample": [[138, 168], ["sorted", "util.get_token_index_from_char_index", "util.Span", "util.Relation"], "function", ["home.repos.pwc.inspect_result.mslars_mare.util.util.get_token_index_from_char_index"], ["", "", "def", "extract_relations_from_smart_sample", "(", "sample", ",", "only_mandatory", "=", "False", ",", "include_trigger", "=", "True", ")", ":", "\n", "    ", "token_borders", "=", "[", "(", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ",", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", ")", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "\n", "relations", "=", "[", "]", "\n", "\n", "for", "relation", "in", "sample", "[", "\"relationMentions\"", "]", ":", "\n", "\n", "        ", "relation_name", "=", "relation", "[", "\"name\"", "]", "\n", "spans", "=", "[", "]", "\n", "\n", "for", "argument", "in", "relation", "[", "\"args\"", "]", ":", "\n", "\n", "            ", "if", "only_mandatory", "and", "argument", "[", "\"role\"", "]", "not", "in", "relation_mandatory_args", "[", "relation_name", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "not", "include_trigger", "and", "argument", "[", "\"role\"", "]", "==", "\"trigger\"", ":", "\n", "                ", "continue", "\n", "\n", "", "argument_role", "=", "argument", "[", "\"role\"", "]", "\n", "entity", "=", "argument", "[", "\"conceptMention\"", "]", "[", "\"span\"", "]", "\n", "start", ",", "end", "=", "get_token_index_from_char_index", "(", "entity", "[", "\"start\"", "]", ",", "entity", "[", "\"end\"", "]", ",", "token_borders", ")", "\n", "\n", "spans", "+=", "[", "Span", "(", "start", ",", "end", ",", "role", "=", "argument_role", ")", "]", "\n", "\n", "", "if", "spans", ":", "\n", "            ", "relations", "+=", "[", "Relation", "(", "spans", ",", "label", "=", "relation_name", ")", "]", "\n", "\n", "", "", "relations", "=", "sorted", "(", "relations", ",", "key", "=", "lambda", "r", ":", "(", "r", ".", "start", ",", "r", ".", "end", ",", "r", ".", "label", ")", ")", "\n", "\n", "return", "relations", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.get_token_index_from_char_index": [[170, 184], ["sorted", "AttributeError", "enumerate", "enumerate", "enumerate", "enumerate"], "function", ["None"], ["", "def", "get_token_index_from_char_index", "(", "start", ",", "end", ",", "token_borders", ",", "fuzzy", "=", "False", ")", ":", "\n", "    ", "token_borders", "=", "sorted", "(", "token_borders", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "\n", "if", "fuzzy", ":", "\n", "        ", "token_start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", ">=", "start", "]", "\n", "token_end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", ">=", "end", "]", "\n", "", "else", ":", "\n", "        ", "token_start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", "==", "start", "]", "\n", "token_end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", "==", "end", "]", "\n", "\n", "", "try", ":", "\n", "        ", "return", "token_start", "[", "0", "]", ",", "token_end", "[", "0", "]", "\n", "", "except", "IndexError", ":", "\n", "        ", "raise", "AttributeError", "(", "f\"Tokenborders {token_borders} are not valid \"", "\n", "f\"for char indizies {start, end} with fuzzy={fuzzy}\"", ")", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.util.util.extract_entities": [[186, 201], ["enumerate", "enumerate", "len", "len", "util.Span"], "function", ["None"], ["", "", "def", "extract_entities", "(", "sample", ")", ":", "\n", "    ", "token_borders", "=", "[", "(", "t", "[", "\"span\"", "]", "[", "\"start\"", "]", ",", "t", "[", "\"span\"", "]", "[", "\"end\"", "]", ")", "for", "t", "in", "sample", "[", "\"tokens\"", "]", "]", "\n", "\n", "entities", "=", "[", "]", "\n", "for", "concept_mention", "in", "sample", "[", "\"conceptMentions\"", "]", ":", "\n", "        ", "start", "=", "concept_mention", "[", "\"span\"", "]", "[", "\"start\"", "]", "\n", "end", "=", "concept_mention", "[", "\"span\"", "]", "[", "\"end\"", "]", "\n", "\n", "start", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "0", "]", "==", "start", "]", "\n", "end", "=", "[", "i", "[", "0", "]", "for", "i", "in", "enumerate", "(", "token_borders", ")", "if", "i", "[", "1", "]", "[", "1", "]", "==", "end", "]", "\n", "\n", "if", "len", "(", "start", ")", ">", "0", "and", "len", "(", "end", ")", ">", "0", ":", "\n", "            ", "entities", "+=", "[", "Span", "(", "start", "[", "0", "]", ",", "end", "[", "0", "]", ",", "role", "=", "concept_mention", "[", "\"type\"", "]", ")", "]", "\n", "\n", "", "", "return", "entities", "\n", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device": [[24, 53], ["allennlp.common.util.int_to_device", "isinstance", "isinstance", "obj.to", "obj.items", "isinstance", "nn_util.move_to_device", "enumerate", "nn_util.move_to_device", "isinstance", "hasattr", "obj.__class__", "isinstance", "tuple", "nn_util.move_to_device", "nn_util.move_to_device"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.move_to_device"], ["def", "move_to_device", "(", "obj", ",", "device", ":", "Union", "[", "torch", ".", "device", ",", "int", "]", ")", ":", "\n", "    ", "\"\"\"\n    Given a structure (possibly) containing Tensors,\n    move all the Tensors to the specified device (or do nothing, if they are already on\n    the target device).\n    \"\"\"", "\n", "device", "=", "int_to_device", "(", "device", ")", "\n", "\n", "if", "isinstance", "(", "obj", ",", "torch", ".", "Tensor", ")", ":", "\n", "# You may be wondering why we don't just always call `obj.to(device)` since that would", "\n", "# be a no-op anyway if `obj` is already on `device`. Well that works fine except", "\n", "# when PyTorch is not compiled with CUDA support, in which case even calling", "\n", "# `obj.to(torch.device(\"cpu\"))` would result in an error.", "\n", "        ", "return", "obj", "if", "obj", ".", "device", "==", "device", "else", "obj", ".", "to", "(", "device", "=", "device", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "        ", "for", "key", ",", "value", "in", "obj", ".", "items", "(", ")", ":", "\n", "            ", "obj", "[", "key", "]", "=", "move_to_device", "(", "value", ",", "device", ")", "\n", "", "return", "obj", "\n", "", "elif", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "        ", "for", "i", ",", "item", "in", "enumerate", "(", "obj", ")", ":", "\n", "            ", "obj", "[", "i", "]", "=", "move_to_device", "(", "item", ",", "device", ")", "\n", "", "return", "obj", "\n", "", "elif", "isinstance", "(", "obj", ",", "tuple", ")", "and", "hasattr", "(", "obj", ",", "\"_fields\"", ")", ":", "\n", "# This is the best way to detect a NamedTuple, it turns out.", "\n", "        ", "return", "obj", ".", "__class__", "(", "*", "(", "move_to_device", "(", "item", ",", "device", ")", "for", "item", "in", "obj", ")", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "move_to_device", "(", "item", ",", "device", ")", "for", "item", "in", "obj", ")", "\n", "", "else", ":", "\n", "        ", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.clamp_tensor": [[55, 68], ["tensor.coalesce", "tensor.coalesce._values().clamp_", "tensor.clamp", "tensor.coalesce._values"], "function", ["None"], ["", "", "def", "clamp_tensor", "(", "tensor", ",", "minimum", ",", "maximum", ")", ":", "\n", "    ", "\"\"\"\n    Supports sparse and dense tensors.\n    Returns a tensor with values clamped between the provided minimum and maximum,\n    without modifying the original tensor.\n    \"\"\"", "\n", "if", "tensor", ".", "is_sparse", ":", "\n", "        ", "coalesced_tensor", "=", "tensor", ".", "coalesce", "(", ")", "\n", "\n", "coalesced_tensor", ".", "_values", "(", ")", ".", "clamp_", "(", "minimum", ",", "maximum", ")", "\n", "return", "coalesced_tensor", "\n", "", "else", ":", "\n", "        ", "return", "tensor", ".", "clamp", "(", "minimum", ",", "maximum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batch_tensor_dicts": [[70, 96], ["collections.defaultdict", "key_to_tensors.items", "tensor_dict.items", "torch.stack", "torch.stack", "key_to_tensors[].append", "all", "batched_tensor.squeeze.squeeze", "tensor.size"], "function", ["None"], ["", "", "def", "batch_tensor_dicts", "(", "\n", "tensor_dicts", ":", "List", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ",", "remove_trailing_dimension", ":", "bool", "=", "False", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Takes a list of tensor dictionaries, where each dictionary is assumed to have matching keys,\n    and returns a single dictionary with all tensors with the same key batched together.\n\n    # Parameters\n\n    tensor_dicts : `List[Dict[str, torch.Tensor]]`\n        The list of tensor dictionaries to batch.\n    remove_trailing_dimension : `bool`\n        If `True`, we will check for a trailing dimension of size 1 on the tensors that are being\n        batched, and remove it if we find it.\n    \"\"\"", "\n", "key_to_tensors", ":", "Dict", "[", "str", ",", "List", "[", "torch", ".", "Tensor", "]", "]", "=", "defaultdict", "(", "list", ")", "\n", "for", "tensor_dict", "in", "tensor_dicts", ":", "\n", "        ", "for", "key", ",", "tensor", "in", "tensor_dict", ".", "items", "(", ")", ":", "\n", "            ", "key_to_tensors", "[", "key", "]", ".", "append", "(", "tensor", ")", "\n", "", "", "batched_tensors", "=", "{", "}", "\n", "for", "key", ",", "tensor_list", "in", "key_to_tensors", ".", "items", "(", ")", ":", "\n", "        ", "batched_tensor", "=", "torch", ".", "stack", "(", "tensor_list", ")", "\n", "if", "remove_trailing_dimension", "and", "all", "(", "tensor", ".", "size", "(", "-", "1", ")", "==", "1", "for", "tensor", "in", "tensor_list", ")", ":", "\n", "            ", "batched_tensor", "=", "batched_tensor", ".", "squeeze", "(", "-", "1", ")", "\n", "", "batched_tensors", "[", "key", "]", "=", "batched_tensor", "\n", "", "return", "batched_tensors", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_lengths_from_binary_sequence_mask": [[98, 116], ["mask.sum"], "function", ["None"], ["", "def", "get_lengths_from_binary_sequence_mask", "(", "mask", ":", "torch", ".", "BoolTensor", ")", "->", "torch", ".", "LongTensor", ":", "\n", "    ", "\"\"\"\n    Compute sequence lengths for each batch element in a tensor using a\n    binary mask.\n\n    # Parameters\n\n    mask : `torch.BoolTensor`, required.\n        A 2D binary mask of shape (batch_size, sequence_length) to\n        calculate the per-batch sequence lengths from.\n\n    # Returns\n\n    `torch.LongTensor`\n        A torch.LongTensor of shape (batch_size,) representing the lengths\n        of the sequences in the batch.\n    \"\"\"", "\n", "return", "mask", ".", "sum", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_mask_from_sequence_lengths": [[118, 135], ["sequence_lengths.new_ones", "sequence_lengths.new_ones.cumsum", "sequence_lengths.size", "sequence_lengths.unsqueeze"], "function", ["None"], ["", "def", "get_mask_from_sequence_lengths", "(", "\n", "sequence_lengths", ":", "torch", ".", "Tensor", ",", "max_length", ":", "int", "\n", ")", "->", "torch", ".", "BoolTensor", ":", "\n", "    ", "\"\"\"\n    Given a variable of shape `(batch_size,)` that represents the sequence lengths of each batch\n    element, this function returns a `(batch_size, max_length)` mask variable.  For example, if\n    our input was `[2, 2, 3]`, with a `max_length` of 4, we'd return\n    `[[1, 1, 0, 0], [1, 1, 0, 0], [1, 1, 1, 0]]`.\n\n    We require `max_length` here instead of just computing it from the input `sequence_lengths`\n    because it lets us avoid finding the max, then copying that value from the GPU to the CPU so\n    that we can use it to construct a new tensor.\n    \"\"\"", "\n", "# (batch_size, max_length)", "\n", "ones", "=", "sequence_lengths", ".", "new_ones", "(", "sequence_lengths", ".", "size", "(", "0", ")", ",", "max_length", ")", "\n", "range_tensor", "=", "ones", ".", "cumsum", "(", "dim", "=", "1", ")", "\n", "return", "sequence_lengths", ".", "unsqueeze", "(", "1", ")", ">=", "range_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.sort_batch_by_length": [[137, 175], ["sequence_lengths.sort", "tensor.index_select", "torch.arange", "torch.arange", "permutation_index.sort", "torch.arange.index_select", "allennlp.common.checks.ConfigurationError", "len", "isinstance", "isinstance"], "function", ["None"], ["", "def", "sort_batch_by_length", "(", "tensor", ":", "torch", ".", "Tensor", ",", "sequence_lengths", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"\n    Sort a batch first tensor by some specified lengths.\n\n    # Parameters\n\n    tensor : `torch.FloatTensor`, required.\n        A batch first Pytorch tensor.\n    sequence_lengths : `torch.LongTensor`, required.\n        A tensor representing the lengths of some dimension of the tensor which\n        we want to sort by.\n\n    # Returns\n\n    sorted_tensor : `torch.FloatTensor`\n        The original tensor sorted along the batch dimension with respect to sequence_lengths.\n    sorted_sequence_lengths : `torch.LongTensor`\n        The original sequence_lengths sorted by decreasing size.\n    restoration_indices : `torch.LongTensor`\n        Indices into the sorted_tensor such that\n        `sorted_tensor.index_select(0, restoration_indices) == original_tensor`\n    permutation_index : `torch.LongTensor`\n        The indices used to sort the tensor. This is useful if you want to sort many\n        tensors using the same ordering.\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "or", "not", "isinstance", "(", "sequence_lengths", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\"Both the tensor and sequence lengths must be torch.Tensors.\"", ")", "\n", "\n", "", "sorted_sequence_lengths", ",", "permutation_index", "=", "sequence_lengths", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "sorted_tensor", "=", "tensor", ".", "index_select", "(", "0", ",", "permutation_index", ")", "\n", "\n", "index_range", "=", "torch", ".", "arange", "(", "0", ",", "len", "(", "sequence_lengths", ")", ",", "device", "=", "sequence_lengths", ".", "device", ")", "\n", "# This is the equivalent of zipping with index, sorting by the original", "\n", "# sequence lengths and returning the now sorted indices.", "\n", "_", ",", "reverse_mapping", "=", "permutation_index", ".", "sort", "(", "0", ",", "descending", "=", "False", ")", "\n", "restoration_indices", "=", "index_range", ".", "index_select", "(", "0", ",", "reverse_mapping", ")", "\n", "return", "sorted_tensor", ",", "sorted_sequence_lengths", ",", "restoration_indices", ",", "permutation_index", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_final_encoder_states": [[177, 208], ["encoder_outputs.size", "last_word_indices.view().expand", "encoder_outputs.gather", "torch.cat.squeeze", "mask.sum", "torch.cat", "torch.cat", "last_word_indices.view"], "function", ["None"], ["", "def", "get_final_encoder_states", "(", "\n", "encoder_outputs", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "bidirectional", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given the output from a `Seq2SeqEncoder`, with shape `(batch_size, sequence_length,\n    encoding_dim)`, this method returns the final hidden state for each element of the batch,\n    giving a tensor of shape `(batch_size, encoding_dim)`.  This is not as simple as\n    `encoder_outputs[:, -1]`, because the sequences could have different lengths.  We use the\n    mask (which has shape `(batch_size, sequence_length)`) to find the final state for each batch\n    instance.\n\n    Additionally, if `bidirectional` is `True`, we will split the final dimension of the\n    `encoder_outputs` into two and assume that the first half is for the forward direction of the\n    encoder and the second half is for the backward direction.  We will concatenate the last state\n    for each encoder dimension, giving `encoder_outputs[:, -1, :encoding_dim/2]` concatenated with\n    `encoder_outputs[:, 0, encoding_dim/2:]`.\n    \"\"\"", "\n", "# These are the indices of the last words in the sequences (i.e. length sans padding - 1).  We", "\n", "# are assuming sequences are right padded.", "\n", "# Shape: (batch_size,)", "\n", "last_word_indices", "=", "mask", ".", "sum", "(", "1", ")", "-", "1", "\n", "batch_size", ",", "_", ",", "encoder_output_dim", "=", "encoder_outputs", ".", "size", "(", ")", "\n", "expanded_indices", "=", "last_word_indices", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "1", ",", "encoder_output_dim", ")", "\n", "# Shape: (batch_size, 1, encoder_output_dim)", "\n", "final_encoder_output", "=", "encoder_outputs", ".", "gather", "(", "1", ",", "expanded_indices", ")", "\n", "final_encoder_output", "=", "final_encoder_output", ".", "squeeze", "(", "1", ")", "# (batch_size, encoder_output_dim)", "\n", "if", "bidirectional", ":", "\n", "        ", "final_forward_output", "=", "final_encoder_output", "[", ":", ",", ":", "(", "encoder_output_dim", "//", "2", ")", "]", "\n", "final_backward_output", "=", "encoder_outputs", "[", ":", ",", "0", ",", "(", "encoder_output_dim", "//", "2", ")", ":", "]", "\n", "final_encoder_output", "=", "torch", ".", "cat", "(", "[", "final_forward_output", ",", "final_backward_output", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "return", "final_encoder_output", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_dropout_mask": [[210, 237], ["binary_mask.float().div", "binary_mask.float", "torch.rand", "torch.rand", "tensor_for_masking.size"], "function", ["None"], ["", "def", "get_dropout_mask", "(", "dropout_probability", ":", "float", ",", "tensor_for_masking", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"\n    Computes and returns an element-wise dropout mask for a given tensor, where\n    each element in the mask is dropped out with probability dropout_probability.\n    Note that the mask is NOT applied to the tensor - the tensor is passed to retain\n    the correct CUDA tensor type for the mask.\n\n    # Parameters\n\n    dropout_probability : `float`, required.\n        Probability of dropping a dimension of the input.\n    tensor_for_masking : `torch.Tensor`, required.\n\n\n    # Returns\n\n    `torch.FloatTensor`\n        A torch.FloatTensor consisting of the binary mask scaled by 1/ (1 - dropout_probability).\n        This scaling ensures expected values and variances of the output of applying this mask\n        and the original tensor are the same.\n    \"\"\"", "\n", "binary_mask", "=", "(", "torch", ".", "rand", "(", "tensor_for_masking", ".", "size", "(", ")", ")", ">", "dropout_probability", ")", ".", "to", "(", "\n", "tensor_for_masking", ".", "device", "\n", ")", "\n", "# Scale mask by 1/keep_prob to preserve output statistics.", "\n", "dropout_mask", "=", "binary_mask", ".", "float", "(", ")", ".", "div", "(", "1.0", "-", "dropout_probability", ")", "\n", "return", "dropout_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_softmax": [[239, 280], ["torch.nn.functional.softmax", "torch.nn.functional.softmax", "mask.unsqueeze.dim", "vector.dim", "mask.unsqueeze.unsqueeze", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "vector.masked_fill", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "nn_util.min_value_of_dtype", "torch.nn.functional.softmax.sum", "nn_util.tiny_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.min_value_of_dtype", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype"], ["", "def", "masked_softmax", "(", "\n", "vector", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "torch", ".", "BoolTensor", ",", "\n", "dim", ":", "int", "=", "-", "1", ",", "\n", "memory_efficient", ":", "bool", "=", "False", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    `torch.nn.functional.softmax(vector)` does not work if some elements of `vector` should be\n    masked.  This performs a softmax on just the non-masked portions of `vector`.  Passing\n    `None` in for the mask is also acceptable; you'll just get a regular softmax.\n\n    `vector` can have an arbitrary number of dimensions; the only requirement is that `mask` is\n    broadcastable to `vector's` shape.  If `mask` has fewer dimensions than `vector`, we will\n    unsqueeze on dimension 1 until they match.  If you need a different unsqueezing of your mask,\n    do it yourself before passing the mask into this function.\n\n    If `memory_efficient` is set to true, we will simply use a very large negative number for those\n    masked positions so that the probabilities of those positions would be approximately 0.\n    This is not accurate in math, but works for most cases and consumes less memory.\n\n    In the case that the input vector is completely masked and `memory_efficient` is false, this function\n    returns an array of `0.0`. This behavior may cause `NaN` if this is used as the last layer of\n    a model that uses categorical cross-entropy loss. Instead, if `memory_efficient` is true, this function\n    will treat every element as equal, and do softmax over equal numbers.\n    \"\"\"", "\n", "if", "mask", "is", "None", ":", "\n", "        ", "result", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "vector", ",", "dim", "=", "dim", ")", "\n", "", "else", ":", "\n", "        ", "while", "mask", ".", "dim", "(", ")", "<", "vector", ".", "dim", "(", ")", ":", "\n", "            ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "\n", "", "if", "not", "memory_efficient", ":", "\n", "# To limit numerical errors from large vector elements outside the mask, we zero these out.", "\n", "            ", "result", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "vector", "*", "mask", ",", "dim", "=", "dim", ")", "\n", "result", "=", "result", "*", "mask", "\n", "result", "=", "result", "/", "(", "\n", "result", ".", "sum", "(", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", "+", "tiny_value_of_dtype", "(", "result", ".", "dtype", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "masked_vector", "=", "vector", ".", "masked_fill", "(", "~", "mask", ",", "min_value_of_dtype", "(", "vector", ".", "dtype", ")", ")", "\n", "result", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "masked_vector", ",", "dim", "=", "dim", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_log_softmax": [[282, 311], ["torch.nn.functional.log_softmax", "torch.nn.functional.log_softmax", "mask.unsqueeze.dim", "vector.dim", "mask.unsqueeze.unsqueeze", "nn_util.tiny_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype"], ["", "def", "masked_log_softmax", "(", "vector", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "dim", ":", "int", "=", "-", "1", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    `torch.nn.functional.log_softmax(vector)` does not work if some elements of `vector` should be\n    masked.  This performs a log_softmax on just the non-masked portions of `vector`.  Passing\n    `None` in for the mask is also acceptable; you'll just get a regular log_softmax.\n\n    `vector` can have an arbitrary number of dimensions; the only requirement is that `mask` is\n    broadcastable to `vector's` shape.  If `mask` has fewer dimensions than `vector`, we will\n    unsqueeze on dimension 1 until they match.  If you need a different unsqueezing of your mask,\n    do it yourself before passing the mask into this function.\n\n    In the case that the input vector is completely masked, the return value of this function is\n    arbitrary, but not `nan`.  You should be masking the result of whatever computation comes out\n    of this in that case, anyway, so the specific values returned shouldn't matter.  Also, the way\n    that we deal with this case relies on having single-precision floats; mixing half-precision\n    floats with fully-masked vectors will likely give you `nans`.\n\n    If your logits are all extremely negative (i.e., the max value in your logit vector is -50 or\n    lower), the way we handle masking here could mess you up.  But if you've got logit values that\n    extreme, you've got bigger problems than this.\n    \"\"\"", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "while", "mask", ".", "dim", "(", ")", "<", "vector", ".", "dim", "(", ")", ":", "\n", "            ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "\n", "# vector + mask.log() is an easy way to zero out masked elements in logspace, but it", "\n", "# results in nans when the whole vector is masked.  We need a very small value instead of a", "\n", "# zero in the mask for these cases.", "\n", "", "vector", "=", "vector", "+", "(", "mask", "+", "tiny_value_of_dtype", "(", "vector", ".", "dtype", ")", ")", ".", "log", "(", ")", "\n", "", "return", "torch", ".", "nn", ".", "functional", ".", "log_softmax", "(", "vector", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_max": [[313, 341], ["vector.masked_fill", "vector.masked_fill.max", "nn_util.min_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.min_value_of_dtype"], ["", "def", "masked_max", "(", "\n", "vector", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "torch", ".", "BoolTensor", ",", "\n", "dim", ":", "int", ",", "\n", "keepdim", ":", "bool", "=", "False", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    To calculate max along certain dimensions on masked values\n\n    # Parameters\n\n    vector : `torch.Tensor`\n        The vector to calculate max, assume unmasked parts are already zeros\n    mask : `torch.BoolTensor`\n        The mask of the vector. It must be broadcastable with vector.\n    dim : `int`\n        The dimension to calculate max\n    keepdim : `bool`\n        Whether to keep dimension\n\n    # Returns\n\n    `torch.Tensor`\n        A `torch.Tensor` of including the maximum values.\n    \"\"\"", "\n", "replaced_vector", "=", "vector", ".", "masked_fill", "(", "~", "mask", ",", "min_value_of_dtype", "(", "vector", ".", "dtype", ")", ")", "\n", "max_value", ",", "_", "=", "replaced_vector", ".", "max", "(", "dim", "=", "dim", ",", "keepdim", "=", "keepdim", ")", "\n", "return", "max_value", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_mean": [[343, 370], ["vector.masked_fill", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.float().clamp", "torch.sum.float", "nn_util.tiny_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype"], ["", "def", "masked_mean", "(", "\n", "vector", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "dim", ":", "int", ",", "keepdim", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    To calculate mean along certain dimensions on masked values\n\n    # Parameters\n\n    vector : `torch.Tensor`\n        The vector to calculate mean.\n    mask : `torch.BoolTensor`\n        The mask of the vector. It must be broadcastable with vector.\n    dim : `int`\n        The dimension to calculate mean\n    keepdim : `bool`\n        Whether to keep dimension\n\n    # Returns\n\n    `torch.Tensor`\n        A `torch.Tensor` of including the mean values.\n    \"\"\"", "\n", "replaced_vector", "=", "vector", ".", "masked_fill", "(", "~", "mask", ",", "0.0", ")", "\n", "\n", "value_sum", "=", "torch", ".", "sum", "(", "replaced_vector", ",", "dim", "=", "dim", ",", "keepdim", "=", "keepdim", ")", "\n", "value_count", "=", "torch", ".", "sum", "(", "mask", ",", "dim", "=", "dim", ",", "keepdim", "=", "keepdim", ")", "\n", "return", "value_sum", "/", "value_count", ".", "float", "(", ")", ".", "clamp", "(", "min", "=", "tiny_value_of_dtype", "(", "torch", ".", "float", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_flip": [[372, 399], ["padded_sequence.size", "torch.flip", "torch.flip", "torch.nn.utils.rnn.pad_sequence", "torch.nn.utils.rnn.pad_sequence", "padded_sequence.size", "len", "len", "padded_sequence.size", "enumerate"], "function", ["None"], ["", "def", "masked_flip", "(", "padded_sequence", ":", "torch", ".", "Tensor", ",", "sequence_lengths", ":", "List", "[", "int", "]", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Flips a padded tensor along the time dimension without affecting masked entries.\n\n    # Parameters\n\n    padded_sequence : `torch.Tensor`\n        The tensor to flip along the time dimension.\n        Assumed to be of dimensions (batch size, num timesteps, ...)\n    sequence_lengths : `torch.Tensor`\n        A list containing the lengths of each unpadded sequence in the batch.\n\n    # Returns\n\n    `torch.Tensor`\n        A `torch.Tensor` of the same shape as padded_sequence.\n    \"\"\"", "\n", "assert", "padded_sequence", ".", "size", "(", "0", ")", "==", "len", "(", "\n", "sequence_lengths", "\n", ")", ",", "f\"sequence_lengths length ${len(sequence_lengths)} does not match batch size ${padded_sequence.size(0)}\"", "\n", "num_timesteps", "=", "padded_sequence", ".", "size", "(", "1", ")", "\n", "flipped_padded_sequence", "=", "torch", ".", "flip", "(", "padded_sequence", ",", "[", "1", "]", ")", "\n", "sequences", "=", "[", "\n", "flipped_padded_sequence", "[", "i", ",", "num_timesteps", "-", "length", ":", "]", "\n", "for", "i", ",", "length", "in", "enumerate", "(", "sequence_lengths", ")", "\n", "]", "\n", "return", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pad_sequence", "(", "sequences", ",", "batch_first", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.viterbi_decode": [[401, 578], ["list", "range", "path_scores[].view", "min", "torch.topk", "torch.topk", "range", "torch.cat.size", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.size", "torch.zeros", "torch.zeros", "path_scores.append", "path_scores.append", "summed_potentials.view.view", "min", "torch.topk", "torch.topk", "path_indices.append", "reversed", "viterbi_path.reverse", "viterbi_paths.append", "ValueError", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "len", "allennlp.common.checks.ConfigurationError", "torch.ones", "torch.ones", "torch.zeros.unsqueeze", "tag_sequence[].unsqueeze", "path_scores[].unsqueeze", "torch.zeros", "torch.zeros", "path_scores.append", "path_scores.append", "paths.squeeze", "path_scores[].view.size", "viterbi_path.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "summed_potentials.view.size", "logger.warning", "torch.zeros.unsqueeze", "int", "backward_timestep.view"], "function", ["None"], ["", "def", "viterbi_decode", "(", "\n", "tag_sequence", ":", "torch", ".", "Tensor", ",", "\n", "transition_matrix", ":", "torch", ".", "Tensor", ",", "\n", "tag_observations", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "allowed_start_transitions", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", "allowed_end_transitions", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", "top_k", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Perform Viterbi decoding in log space over a sequence given a transition matrix\n    specifying pairwise (transition) potentials between tags and a matrix of shape\n    (sequence_length, num_tags) specifying unary potentials for possible tags per\n    timestep.\n\n    # Parameters\n\n    tag_sequence : `torch.Tensor`, required.\n        A tensor of shape (sequence_length, num_tags) representing scores for\n        a set of tags over a given sequence.\n    transition_matrix : `torch.Tensor`, required.\n        A tensor of shape (num_tags, num_tags) representing the binary potentials\n        for transitioning between a given pair of tags.\n    tag_observations : `Optional[List[int]]`, optional, (default = `None`)\n        A list of length `sequence_length` containing the class ids of observed\n        elements in the sequence, with unobserved elements being set to -1. Note that\n        it is possible to provide evidence which results in degenerate labelings if\n        the sequences of tags you provide as evidence cannot transition between each\n        other, or those transitions are extremely unlikely. In this situation we log a\n        warning, but the responsibility for providing self-consistent evidence ultimately\n        lies with the user.\n    allowed_start_transitions : `torch.Tensor`, optional, (default = `None`)\n        An optional tensor of shape (num_tags,) describing which tags the START token\n        may transition *to*. If provided, additional transition constraints will be used for\n        determining the start element of the sequence.\n    allowed_end_transitions : `torch.Tensor`, optional, (default = `None`)\n        An optional tensor of shape (num_tags,) describing which tags may transition *to* the\n        end tag. If provided, additional transition constraints will be used for determining\n        the end element of the sequence.\n    top_k : `int`, optional, (default = `None`)\n        Optional integer specifying how many of the top paths to return. For top_k>=1, returns\n        a tuple of two lists: top_k_paths, top_k_scores, For top_k==None, returns a flattened\n        tuple with just the top path and its score (not in lists, for backwards compatibility).\n\n    # Returns\n\n    viterbi_path : `List[int]`\n        The tag indices of the maximum likelihood tag sequence.\n    viterbi_score : `torch.Tensor`\n        The score of the viterbi path.\n    \"\"\"", "\n", "if", "top_k", "is", "None", ":", "\n", "        ", "top_k", "=", "1", "\n", "flatten_output", "=", "True", "\n", "", "elif", "top_k", ">=", "1", ":", "\n", "        ", "flatten_output", "=", "False", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"top_k must be either None or an integer >=1. Instead received {top_k}\"", ")", "\n", "\n", "", "sequence_length", ",", "num_tags", "=", "list", "(", "tag_sequence", ".", "size", "(", ")", ")", "\n", "\n", "has_start_end_restrictions", "=", "(", "\n", "allowed_end_transitions", "is", "not", "None", "or", "allowed_start_transitions", "is", "not", "None", "\n", ")", "\n", "\n", "if", "has_start_end_restrictions", ":", "\n", "\n", "        ", "if", "allowed_end_transitions", "is", "None", ":", "\n", "            ", "allowed_end_transitions", "=", "torch", ".", "zeros", "(", "num_tags", ")", "\n", "", "if", "allowed_start_transitions", "is", "None", ":", "\n", "            ", "allowed_start_transitions", "=", "torch", ".", "zeros", "(", "num_tags", ")", "\n", "\n", "", "num_tags", "=", "num_tags", "+", "2", "\n", "new_transition_matrix", "=", "torch", ".", "zeros", "(", "num_tags", ",", "num_tags", ")", "\n", "new_transition_matrix", "[", ":", "-", "2", ",", ":", "-", "2", "]", "=", "transition_matrix", "\n", "\n", "# Start and end transitions are fully defined, but cannot transition between each other.", "\n", "\n", "allowed_start_transitions", "=", "torch", ".", "cat", "(", "\n", "[", "allowed_start_transitions", ",", "torch", ".", "tensor", "(", "[", "-", "math", ".", "inf", ",", "-", "math", ".", "inf", "]", ")", "]", "\n", ")", "\n", "allowed_end_transitions", "=", "torch", ".", "cat", "(", "\n", "[", "allowed_end_transitions", ",", "torch", ".", "tensor", "(", "[", "-", "math", ".", "inf", ",", "-", "math", ".", "inf", "]", ")", "]", "\n", ")", "\n", "\n", "# First define how we may transition FROM the start and end tags.", "\n", "new_transition_matrix", "[", "-", "2", ",", ":", "]", "=", "allowed_start_transitions", "\n", "# We cannot transition from the end tag to any tag.", "\n", "new_transition_matrix", "[", "-", "1", ",", ":", "]", "=", "-", "math", ".", "inf", "\n", "\n", "new_transition_matrix", "[", ":", ",", "-", "1", "]", "=", "allowed_end_transitions", "\n", "# We cannot transition to the start tag from any tag.", "\n", "new_transition_matrix", "[", ":", ",", "-", "2", "]", "=", "-", "math", ".", "inf", "\n", "\n", "transition_matrix", "=", "new_transition_matrix", "\n", "\n", "", "if", "tag_observations", ":", "\n", "        ", "if", "len", "(", "tag_observations", ")", "!=", "sequence_length", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\n", "\"Observations were provided, but they were not the same length \"", "\n", "\"as the sequence. Found sequence of length: {} and evidence: {}\"", ".", "format", "(", "\n", "sequence_length", ",", "tag_observations", "\n", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "        ", "tag_observations", "=", "[", "-", "1", "for", "_", "in", "range", "(", "sequence_length", ")", "]", "\n", "\n", "", "if", "has_start_end_restrictions", ":", "\n", "        ", "tag_observations", "=", "[", "num_tags", "-", "2", "]", "+", "tag_observations", "+", "[", "num_tags", "-", "1", "]", "\n", "zero_sentinel", "=", "torch", ".", "zeros", "(", "1", ",", "num_tags", ")", "\n", "extra_tags_sentinel", "=", "torch", ".", "ones", "(", "sequence_length", ",", "2", ")", "*", "-", "math", ".", "inf", "\n", "tag_sequence", "=", "torch", ".", "cat", "(", "[", "tag_sequence", ",", "extra_tags_sentinel", "]", ",", "-", "1", ")", "\n", "tag_sequence", "=", "torch", ".", "cat", "(", "[", "zero_sentinel", ",", "tag_sequence", ",", "zero_sentinel", "]", ",", "0", ")", "\n", "sequence_length", "=", "tag_sequence", ".", "size", "(", "0", ")", "\n", "\n", "", "path_scores", "=", "[", "]", "\n", "path_indices", "=", "[", "]", "\n", "\n", "if", "tag_observations", "[", "0", "]", "!=", "-", "1", ":", "\n", "        ", "one_hot", "=", "torch", ".", "zeros", "(", "num_tags", ")", "\n", "one_hot", "[", "tag_observations", "[", "0", "]", "]", "=", "100000.0", "\n", "path_scores", ".", "append", "(", "one_hot", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "else", ":", "\n", "        ", "path_scores", ".", "append", "(", "tag_sequence", "[", "0", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# Evaluate the scores for all possible paths.", "\n", "", "for", "timestep", "in", "range", "(", "1", ",", "sequence_length", ")", ":", "\n", "# Add pairwise potentials to current scores.", "\n", "        ", "summed_potentials", "=", "path_scores", "[", "timestep", "-", "1", "]", ".", "unsqueeze", "(", "2", ")", "+", "transition_matrix", "\n", "summed_potentials", "=", "summed_potentials", ".", "view", "(", "-", "1", ",", "num_tags", ")", "\n", "\n", "# Best pairwise potential path score from the previous timestep.", "\n", "max_k", "=", "min", "(", "summed_potentials", ".", "size", "(", ")", "[", "0", "]", ",", "top_k", ")", "\n", "scores", ",", "paths", "=", "torch", ".", "topk", "(", "summed_potentials", ",", "k", "=", "max_k", ",", "dim", "=", "0", ")", "\n", "\n", "# If we have an observation for this timestep, use it", "\n", "# instead of the distribution over tags.", "\n", "observation", "=", "tag_observations", "[", "timestep", "]", "\n", "# Warn the user if they have passed", "\n", "# invalid/extremely unlikely evidence.", "\n", "if", "tag_observations", "[", "timestep", "-", "1", "]", "!=", "-", "1", "and", "observation", "!=", "-", "1", ":", "\n", "            ", "if", "transition_matrix", "[", "tag_observations", "[", "timestep", "-", "1", "]", ",", "observation", "]", "<", "-", "10000", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "\"The pairwise potential between tags you have passed as \"", "\n", "\"observations is extremely unlikely. Double check your evidence \"", "\n", "\"or transition potentials!\"", "\n", ")", "\n", "", "", "if", "observation", "!=", "-", "1", ":", "\n", "            ", "one_hot", "=", "torch", ".", "zeros", "(", "num_tags", ")", "\n", "one_hot", "[", "observation", "]", "=", "100000.0", "\n", "path_scores", ".", "append", "(", "one_hot", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "else", ":", "\n", "            ", "path_scores", ".", "append", "(", "tag_sequence", "[", "timestep", ",", ":", "]", "+", "scores", ")", "\n", "", "path_indices", ".", "append", "(", "paths", ".", "squeeze", "(", ")", ")", "\n", "\n", "# Construct the most likely sequence backwards.", "\n", "", "path_scores_v", "=", "path_scores", "[", "-", "1", "]", ".", "view", "(", "-", "1", ")", "\n", "max_k", "=", "min", "(", "path_scores_v", ".", "size", "(", ")", "[", "0", "]", ",", "top_k", ")", "\n", "viterbi_scores", ",", "best_paths", "=", "torch", ".", "topk", "(", "path_scores_v", ",", "k", "=", "max_k", ",", "dim", "=", "0", ")", "\n", "viterbi_paths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "max_k", ")", ":", "\n", "        ", "viterbi_path", "=", "[", "best_paths", "[", "i", "]", "]", "\n", "for", "backward_timestep", "in", "reversed", "(", "path_indices", ")", ":", "\n", "            ", "viterbi_path", ".", "append", "(", "int", "(", "backward_timestep", ".", "view", "(", "-", "1", ")", "[", "viterbi_path", "[", "-", "1", "]", "]", ")", ")", "\n", "# Reverse the backward path.", "\n", "", "viterbi_path", ".", "reverse", "(", ")", "\n", "\n", "if", "has_start_end_restrictions", ":", "\n", "            ", "viterbi_path", "=", "viterbi_path", "[", "1", ":", "-", "1", "]", "\n", "\n", "# Viterbi paths uses (num_tags * n_permutations) nodes; therefore, we need to modulo.", "\n", "", "viterbi_path", "=", "[", "j", "%", "num_tags", "for", "j", "in", "viterbi_path", "]", "\n", "viterbi_paths", ".", "append", "(", "viterbi_path", ")", "\n", "\n", "", "if", "flatten_output", ":", "\n", "        ", "return", "viterbi_paths", "[", "0", "]", ",", "viterbi_scores", "[", "0", "]", "\n", "\n", "", "return", "viterbi_paths", ",", "viterbi_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_text_field_mask": [[580, 634], ["text_field_tensors.items", "tensor_dims.sort", "len", "masks.append", "len", "ValueError", "tensor.dim", "text_field_tensors.values", "indexer_output.values", "ValueError", "indexer_tensors[].bool"], "function", ["None"], ["", "def", "get_text_field_mask", "(", "\n", "text_field_tensors", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ",", "\n", "num_wrapping_dims", ":", "int", "=", "0", ",", "\n", "padding_id", ":", "int", "=", "0", ",", "\n", ")", "->", "torch", ".", "BoolTensor", ":", "\n", "    ", "\"\"\"\n    Takes the dictionary of tensors produced by a `TextField` and returns a mask\n    with 0 where the tokens are padding, and 1 otherwise. `padding_id` specifies the id of padding tokens.\n    We also handle `TextFields` wrapped by an arbitrary number of `ListFields`, where the number of wrapping\n    `ListFields` is given by `num_wrapping_dims`.\n\n    If `num_wrapping_dims == 0`, the returned mask has shape `(batch_size, num_tokens)`.\n    If `num_wrapping_dims > 0` then the returned mask has `num_wrapping_dims` extra\n    dimensions, so the shape will be `(batch_size, ..., num_tokens)`.\n\n    There could be several entries in the tensor dictionary with different shapes (e.g., one for\n    word ids, one for character ids).  In order to get a token mask, we use the tensor in\n    the dictionary with the lowest number of dimensions.  After subtracting `num_wrapping_dims`,\n    if this tensor has two dimensions we assume it has shape `(batch_size, ..., num_tokens)`,\n    and use it for the mask.  If instead it has three dimensions, we assume it has shape\n    `(batch_size, ..., num_tokens, num_features)`, and sum over the last dimension to produce\n    the mask.  Most frequently this will be a character id tensor, but it could also be a\n    featurized representation of each token, etc.\n\n    If the input `text_field_tensors` contains the \"mask\" key, this is returned instead of inferring the mask.\n    \"\"\"", "\n", "masks", "=", "[", "]", "\n", "for", "indexer_name", ",", "indexer_tensors", "in", "text_field_tensors", ".", "items", "(", ")", ":", "\n", "        ", "if", "\"mask\"", "in", "indexer_tensors", ":", "\n", "            ", "masks", ".", "append", "(", "indexer_tensors", "[", "\"mask\"", "]", ".", "bool", "(", ")", ")", "\n", "", "", "if", "len", "(", "masks", ")", "==", "1", ":", "\n", "        ", "return", "masks", "[", "0", "]", "\n", "", "elif", "len", "(", "masks", ")", ">", "1", ":", "\n", "# TODO(mattg): My guess is this will basically never happen, so I'm not writing logic to", "\n", "# handle it.  Should be straightforward to handle, though.  If you see this error in", "\n", "# practice, open an issue on github.", "\n", "        ", "raise", "ValueError", "(", "\"found two mask outputs; not sure which to use!\"", ")", "\n", "\n", "", "tensor_dims", "=", "[", "\n", "(", "tensor", ".", "dim", "(", ")", ",", "tensor", ")", "\n", "for", "indexer_output", "in", "text_field_tensors", ".", "values", "(", ")", "\n", "for", "tensor", "in", "indexer_output", ".", "values", "(", ")", "\n", "]", "\n", "tensor_dims", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "\n", "smallest_dim", "=", "tensor_dims", "[", "0", "]", "[", "0", "]", "-", "num_wrapping_dims", "\n", "if", "smallest_dim", "==", "2", ":", "\n", "        ", "token_tensor", "=", "tensor_dims", "[", "0", "]", "[", "1", "]", "\n", "return", "token_tensor", "!=", "padding_id", "\n", "", "elif", "smallest_dim", "==", "3", ":", "\n", "        ", "character_tensor", "=", "tensor_dims", "[", "0", "]", "[", "1", "]", "\n", "return", "(", "character_tensor", "!=", "padding_id", ")", ".", "any", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected a tensor with dimension 2 or 3, found {}\"", ".", "format", "(", "smallest_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_token_ids_from_text_field_tensors": [[636, 652], ["text_field_tensors.items", "NotImplementedError", "indexer_tensors.items"], "function", ["None"], ["", "", "def", "get_token_ids_from_text_field_tensors", "(", "\n", "text_field_tensors", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Our `TextFieldTensors` are complex output structures, because they try to handle a lot of\n    potential variation. Sometimes, you just want to grab the token ids from this data structure,\n    and that's not trivial without hard-coding assumptions about your data processing, which defeats\n    the entire purpose of that generality. This method tries to let you get the token ids out of the\n    data structure in your model without hard-coding any assumptions.\n    \"\"\"", "\n", "for", "indexer_name", ",", "indexer_tensors", "in", "text_field_tensors", ".", "items", "(", ")", ":", "\n", "        ", "for", "argument_name", ",", "tensor", "in", "indexer_tensors", ".", "items", "(", ")", ":", "\n", "            ", "if", "argument_name", "in", "[", "\"tokens\"", ",", "\"token_ids\"", ",", "\"input_ids\"", "]", ":", "\n", "                ", "return", "tensor", "\n", "", "", "", "raise", "NotImplementedError", "(", "\n", "\"Our heuristic for guessing the right token ids failed. Please open an issue on \"", "\n", "\"github with more detail on how you got this error, so we can implement more robust \"", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.weighted_sum": [[657, 694], ["intermediate.sum", "attention.unsqueeze().bmm().squeeze", "attention.bmm", "attention.dim", "list", "range", "matrix.unsqueeze.expand", "attention.unsqueeze().expand_as", "attention.dim", "matrix.unsqueeze.dim", "attention.dim", "matrix.unsqueeze.dim", "matrix.unsqueeze.dim", "matrix.unsqueeze.size", "matrix.unsqueeze.unsqueeze", "list.insert", "attention.unsqueeze().bmm", "attention.size", "attention.unsqueeze", "attention.dim", "matrix.unsqueeze.dim", "attention.unsqueeze"], "function", ["None"], ["", "def", "weighted_sum", "(", "matrix", ":", "torch", ".", "Tensor", ",", "attention", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Takes a matrix of vectors and a set of weights over the rows in the matrix (which we call an\n    \"attention\" vector), and returns a weighted sum of the rows in the matrix.  This is the typical\n    computation performed after an attention mechanism.\n\n    Note that while we call this a \"matrix\" of vectors and an attention \"vector\", we also handle\n    higher-order tensors.  We always sum over the second-to-last dimension of the \"matrix\", and we\n    assume that all dimensions in the \"matrix\" prior to the last dimension are matched in the\n    \"vector\".  Non-matched dimensions in the \"vector\" must be `directly after the batch dimension`.\n\n    For example, say I have a \"matrix\" with dimensions `(batch_size, num_queries, num_words,\n    embedding_dim)`.  The attention \"vector\" then must have at least those dimensions, and could\n    have more. Both:\n\n        - `(batch_size, num_queries, num_words)` (distribution over words for each query)\n        - `(batch_size, num_documents, num_queries, num_words)` (distribution over words in a\n          query for each document)\n\n    are valid input \"vectors\", producing tensors of shape:\n    `(batch_size, num_queries, embedding_dim)` and\n    `(batch_size, num_documents, num_queries, embedding_dim)` respectively.\n    \"\"\"", "\n", "# We'll special-case a few settings here, where there are efficient (but poorly-named)", "\n", "# operations in pytorch that already do the computation we need.", "\n", "if", "attention", ".", "dim", "(", ")", "==", "2", "and", "matrix", ".", "dim", "(", ")", "==", "3", ":", "\n", "        ", "return", "attention", ".", "unsqueeze", "(", "1", ")", ".", "bmm", "(", "matrix", ")", ".", "squeeze", "(", "1", ")", "\n", "", "if", "attention", ".", "dim", "(", ")", "==", "3", "and", "matrix", ".", "dim", "(", ")", "==", "3", ":", "\n", "        ", "return", "attention", ".", "bmm", "(", "matrix", ")", "\n", "", "if", "matrix", ".", "dim", "(", ")", "-", "1", "<", "attention", ".", "dim", "(", ")", ":", "\n", "        ", "expanded_size", "=", "list", "(", "matrix", ".", "size", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "attention", ".", "dim", "(", ")", "-", "matrix", ".", "dim", "(", ")", "+", "1", ")", ":", "\n", "            ", "matrix", "=", "matrix", ".", "unsqueeze", "(", "1", ")", "\n", "expanded_size", ".", "insert", "(", "i", "+", "1", ",", "attention", ".", "size", "(", "i", "+", "1", ")", ")", "\n", "", "matrix", "=", "matrix", ".", "expand", "(", "*", "expanded_size", ")", "\n", "", "intermediate", "=", "attention", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "matrix", ")", "*", "matrix", "\n", "return", "intermediate", ".", "sum", "(", "dim", "=", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.sequence_cross_entropy_with_logits": [[696, 851], ["weights.to.to", "tuple", "weights.to.sum", "logits.view", "torch.nn.functional.log_softmax", "torch.nn.functional.log_softmax", "targets.view().long", "negative_log_likelihood_flat.sum.view", "ValueError", "range", "logits.size", "torch.nn.functional.log_softmax.exp", "torch.gather", "torch.gather", "focal_factor.view.view", "isinstance", "torch.gather().view", "torch.gather().view", "logits.size", "torch.zeros_like().scatter_", "torch.zeros_like().scatter_", "negative_log_likelihood_flat.sum.sum", "len", "targets.view", "torch.tensor", "torch.tensor", "isinstance", "torch.gather", "torch.gather", "targets.size", "negative_log_likelihood_flat.view.sum", "nn_util.tiny_value_of_dtype", "per_batch_loss.sum", "targets.size", "torch.tensor", "torch.tensor", "TypeError", "torch.gather", "torch.gather", "targets.size", "torch.zeros_like", "torch.zeros_like", "nn_util.tiny_value_of_dtype", "negative_log_likelihood_flat.view.sum", "negative_log_likelihood_flat.view.sum", "float", "torch.cat.size", "torch.cat.view", "torch.cat", "torch.cat", "weights.sum.sum", "nn_util.tiny_value_of_dtype", "nn_util.tiny_value_of_dtype", "float", "type", "targets.view().long.view"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype"], ["", "def", "sequence_cross_entropy_with_logits", "(", "\n", "logits", ":", "torch", ".", "FloatTensor", ",", "\n", "targets", ":", "torch", ".", "LongTensor", ",", "\n", "weights", ":", "Union", "[", "torch", ".", "FloatTensor", ",", "torch", ".", "BoolTensor", "]", ",", "\n", "average", ":", "str", "=", "\"batch\"", ",", "\n", "label_smoothing", ":", "float", "=", "None", ",", "\n", "gamma", ":", "float", "=", "None", ",", "\n", "alpha", ":", "Union", "[", "float", ",", "List", "[", "float", "]", ",", "torch", ".", "FloatTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "    ", "\"\"\"\n    Computes the cross entropy loss of a sequence, weighted with respect to\n    some user provided weights. Note that the weighting here is not the same as\n    in the `torch.nn.CrossEntropyLoss()` criterion, which is weighting\n    classes; here we are weighting the loss contribution from particular elements\n    in the sequence. This allows loss computations for models which use padding.\n\n    # Parameters\n\n    logits : `torch.FloatTensor`, required.\n        A `torch.FloatTensor` of size (batch_size, sequence_length, num_classes)\n        which contains the unnormalized probability for each class.\n    targets : `torch.LongTensor`, required.\n        A `torch.LongTensor` of size (batch, sequence_length) which contains the\n        index of the true class for each corresponding step.\n    weights : `Union[torch.FloatTensor, torch.BoolTensor]`, required.\n        A `torch.FloatTensor` of size (batch, sequence_length)\n    average: `str`, optional (default = `\"batch\"`)\n        If \"batch\", average the loss across the batches. If \"token\", average\n        the loss across each item in the input. If `None`, return a vector\n        of losses per batch element.\n    label_smoothing : `float`, optional (default = `None`)\n        Whether or not to apply label smoothing to the cross-entropy loss.\n        For example, with a label smoothing value of 0.2, a 4 class classification\n        target would look like `[0.05, 0.05, 0.85, 0.05]` if the 3rd class was\n        the correct label.\n    gamma : `float`, optional (default = `None`)\n        Focal loss[*] focusing parameter `gamma` to reduces the relative loss for\n        well-classified examples and put more focus on hard. The greater value\n        `gamma` is, the more focus on hard examples.\n    alpha : `Union[float, List[float]]`, optional (default = `None`)\n        Focal loss[*] weighting factor `alpha` to balance between classes. Can be\n        used independently with `gamma`. If a single `float` is provided, it\n        is assumed binary case using `alpha` and `1 - alpha` for positive and\n        negative respectively. If a list of `float` is provided, with the same\n        length as the number of classes, the weights will match the classes.\n        [*] T. Lin, P. Goyal, R. Girshick, K. He and P. Doll\u00e1r, \"Focal Loss for\n        Dense Object Detection,\" 2017 IEEE International Conference on Computer\n        Vision (ICCV), Venice, 2017, pp. 2999-3007.\n\n    # Returns\n\n    `torch.FloatTensor`\n        A torch.FloatTensor representing the cross entropy loss.\n        If `average==\"batch\"` or `average==\"token\"`, the returned loss is a scalar.\n        If `average is None`, the returned loss is a vector of shape (batch_size,).\n\n    \"\"\"", "\n", "if", "average", "not", "in", "{", "None", ",", "\"token\"", ",", "\"batch\"", "}", ":", "\n", "        ", "raise", "ValueError", "(", "\"Got average f{average}, expected one of None, 'token', or 'batch'\"", ")", "\n", "\n", "# make sure weights are float", "\n", "", "weights", "=", "weights", ".", "to", "(", "logits", ".", "dtype", ")", "\n", "# sum all dim except batch", "\n", "non_batch_dims", "=", "tuple", "(", "range", "(", "1", ",", "len", "(", "weights", ".", "shape", ")", ")", ")", "\n", "# shape : (batch_size,)", "\n", "weights_batch_sum", "=", "weights", ".", "sum", "(", "dim", "=", "non_batch_dims", ")", "\n", "# shape : (batch * sequence_length, num_classes)", "\n", "logits_flat", "=", "logits", ".", "view", "(", "-", "1", ",", "logits", ".", "size", "(", "-", "1", ")", ")", "\n", "# shape : (batch * sequence_length, num_classes)", "\n", "log_probs_flat", "=", "torch", ".", "nn", ".", "functional", ".", "log_softmax", "(", "logits_flat", ",", "dim", "=", "-", "1", ")", "\n", "# shape : (batch * max_len, 1)", "\n", "targets_flat", "=", "targets", ".", "view", "(", "-", "1", ",", "1", ")", ".", "long", "(", ")", "\n", "# focal loss coefficient", "\n", "if", "gamma", ":", "\n", "# shape : (batch * sequence_length, num_classes)", "\n", "        ", "probs_flat", "=", "log_probs_flat", ".", "exp", "(", ")", "\n", "# shape : (batch * sequence_length,)", "\n", "probs_flat", "=", "torch", ".", "gather", "(", "probs_flat", ",", "dim", "=", "1", ",", "index", "=", "targets_flat", ")", "\n", "# shape : (batch * sequence_length,)", "\n", "focal_factor", "=", "(", "1.0", "-", "probs_flat", ")", "**", "gamma", "\n", "# shape : (batch, sequence_length)", "\n", "focal_factor", "=", "focal_factor", ".", "view", "(", "*", "targets", ".", "size", "(", ")", ")", "\n", "weights", "=", "weights", "*", "focal_factor", "\n", "\n", "", "if", "alpha", "is", "not", "None", ":", "\n", "# shape : () / (num_classes,)", "\n", "        ", "if", "isinstance", "(", "alpha", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "\n", "# shape : (2,)", "\n", "            ", "alpha_factor", "=", "torch", ".", "tensor", "(", "\n", "[", "1.0", "-", "float", "(", "alpha", ")", ",", "float", "(", "alpha", ")", "]", ",", "dtype", "=", "weights", ".", "dtype", ",", "device", "=", "weights", ".", "device", "\n", ")", "\n", "\n", "", "elif", "isinstance", "(", "alpha", ",", "(", "list", ",", "numpy", ".", "ndarray", ",", "torch", ".", "Tensor", ")", ")", ":", "\n", "\n", "# shape : (c,)", "\n", "            ", "alpha_factor", "=", "torch", ".", "tensor", "(", "alpha", ",", "dtype", "=", "weights", ".", "dtype", ",", "device", "=", "weights", ".", "device", ")", "\n", "\n", "if", "not", "alpha_factor", ".", "size", "(", ")", ":", "\n", "# shape : (1,)", "\n", "                ", "alpha_factor", "=", "alpha_factor", ".", "view", "(", "1", ")", "\n", "# shape : (2,)", "\n", "alpha_factor", "=", "torch", ".", "cat", "(", "[", "1", "-", "alpha_factor", ",", "alpha_factor", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "(", "\"alpha must be float, list of float, or torch.FloatTensor, {} provided.\"", ")", ".", "format", "(", "\n", "type", "(", "alpha", ")", "\n", ")", "\n", ")", "\n", "# shape : (batch, max_len)", "\n", "", "alpha_factor", "=", "torch", ".", "gather", "(", "alpha_factor", ",", "dim", "=", "0", ",", "index", "=", "targets_flat", ".", "view", "(", "-", "1", ")", ")", ".", "view", "(", "\n", "*", "targets", ".", "size", "(", ")", "\n", ")", "\n", "weights", "=", "weights", "*", "alpha_factor", "\n", "\n", "", "if", "label_smoothing", "is", "not", "None", "and", "label_smoothing", ">", "0.0", ":", "\n", "        ", "num_classes", "=", "logits", ".", "size", "(", "-", "1", ")", "\n", "smoothing_value", "=", "label_smoothing", "/", "num_classes", "\n", "# Fill all the correct indices with 1 - smoothing value.", "\n", "one_hot_targets", "=", "torch", ".", "zeros_like", "(", "log_probs_flat", ")", ".", "scatter_", "(", "\n", "-", "1", ",", "targets_flat", ",", "1.0", "-", "label_smoothing", "\n", ")", "\n", "smoothed_targets", "=", "one_hot_targets", "+", "smoothing_value", "\n", "negative_log_likelihood_flat", "=", "-", "log_probs_flat", "*", "smoothed_targets", "\n", "negative_log_likelihood_flat", "=", "negative_log_likelihood_flat", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "", "else", ":", "\n", "# Contribution to the negative log likelihood only comes from the exact indices", "\n", "# of the targets, as the target distributions are one-hot. Here we use torch.gather", "\n", "# to extract the indices of the num_classes dimension which contribute to the loss.", "\n", "# shape : (batch * sequence_length, 1)", "\n", "        ", "negative_log_likelihood_flat", "=", "-", "torch", ".", "gather", "(", "log_probs_flat", ",", "dim", "=", "1", ",", "index", "=", "targets_flat", ")", "\n", "# shape : (batch, sequence_length)", "\n", "", "negative_log_likelihood", "=", "negative_log_likelihood_flat", ".", "view", "(", "*", "targets", ".", "size", "(", ")", ")", "\n", "# shape : (batch, sequence_length)", "\n", "negative_log_likelihood", "=", "negative_log_likelihood", "*", "weights", "\n", "\n", "if", "average", "==", "\"batch\"", ":", "\n", "# shape : (batch_size,)", "\n", "        ", "per_batch_loss", "=", "negative_log_likelihood", ".", "sum", "(", "non_batch_dims", ")", "/", "(", "\n", "weights_batch_sum", "+", "tiny_value_of_dtype", "(", "negative_log_likelihood", ".", "dtype", ")", "\n", ")", "\n", "num_non_empty_sequences", "=", "(", "weights_batch_sum", ">", "0", ")", ".", "sum", "(", ")", "+", "tiny_value_of_dtype", "(", "\n", "negative_log_likelihood", ".", "dtype", "\n", ")", "\n", "return", "per_batch_loss", ".", "sum", "(", ")", "/", "num_non_empty_sequences", "\n", "", "elif", "average", "==", "\"token\"", ":", "\n", "        ", "return", "negative_log_likelihood", ".", "sum", "(", ")", "/", "(", "\n", "weights_batch_sum", ".", "sum", "(", ")", "+", "tiny_value_of_dtype", "(", "negative_log_likelihood", ".", "dtype", ")", "\n", ")", "\n", "", "else", ":", "\n", "# shape : (batch_size,)", "\n", "        ", "per_batch_loss", "=", "negative_log_likelihood", ".", "sum", "(", "non_batch_dims", ")", "/", "(", "\n", "weights_batch_sum", "+", "tiny_value_of_dtype", "(", "negative_log_likelihood", ".", "dtype", ")", "\n", ")", "\n", "return", "per_batch_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values": [[853, 870], ["tensor.masked_fill", "tensor.dim", "mask.dim", "allennlp.common.checks.ConfigurationError", "tensor.dim", "mask.dim"], "function", ["None"], ["", "", "def", "replace_masked_values", "(", "\n", "tensor", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "replace_with", ":", "float", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Replaces all masked values in `tensor` with `replace_with`.  `mask` must be broadcastable\n    to the same shape as `tensor`. We require that `tensor.dim() == mask.dim()`, as otherwise we\n    won't know which dimensions of the mask to unsqueeze.\n\n    This just does `tensor.masked_fill()`, except the pytorch method fills in things with a mask\n    value of 1, where we want the opposite.  You can do this in your own code with\n    `tensor.masked_fill(~mask, replace_with)`.\n    \"\"\"", "\n", "if", "tensor", ".", "dim", "(", ")", "!=", "mask", ".", "dim", "(", ")", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\n", "\"tensor.dim() (%d) != mask.dim() (%d)\"", "%", "(", "tensor", ".", "dim", "(", ")", ",", "mask", ".", "dim", "(", ")", ")", "\n", ")", "\n", "", "return", "tensor", ".", "masked_fill", "(", "~", "mask", ",", "replace_with", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tensors_equal": [[872, 909], ["isinstance", "all", "isinstance", "all", "isinstance", "isinstance", "len", "len", "nn_util.tensors_equal", "isinstance", "tensor1.keys", "tensor2.keys", "zip", "nn_util.tensors_equal", "isinstance", "tensor1.size", "tensor2.size", "print", "type", "type"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tensors_equal", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tensors_equal"], ["", "def", "tensors_equal", "(", "tensor1", ":", "torch", ".", "Tensor", ",", "tensor2", ":", "torch", ".", "Tensor", ",", "tolerance", ":", "float", "=", "1e-12", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    A check for tensor equality (by value).  We make sure that the tensors have the same shape,\n    then check all of the entries in the tensor for equality.  We additionally allow the input\n    tensors to be lists or dictionaries, where we then do the above check on every position in the\n    list / item in the dictionary.  If we find objects that aren't tensors as we're doing that, we\n    just defer to their equality check.\n\n    This is kind of a catch-all method that's designed to make implementing `__eq__` methods\n    easier, in a way that's really only intended to be useful for tests.\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "tensor1", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "tensor2", ",", "(", "list", ",", "tuple", ")", ")", "or", "len", "(", "tensor1", ")", "!=", "len", "(", "tensor2", ")", ":", "\n", "            ", "return", "False", "\n", "", "return", "all", "(", "tensors_equal", "(", "t1", ",", "t2", ",", "tolerance", ")", "for", "t1", ",", "t2", "in", "zip", "(", "tensor1", ",", "tensor2", ")", ")", "\n", "", "elif", "isinstance", "(", "tensor1", ",", "dict", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "tensor2", ",", "dict", ")", ":", "\n", "            ", "return", "False", "\n", "", "if", "tensor1", ".", "keys", "(", ")", "!=", "tensor2", ".", "keys", "(", ")", ":", "\n", "            ", "return", "False", "\n", "", "return", "all", "(", "tensors_equal", "(", "tensor1", "[", "key", "]", ",", "tensor2", "[", "key", "]", ",", "tolerance", ")", "for", "key", "in", "tensor1", ")", "\n", "", "elif", "isinstance", "(", "tensor1", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "tensor2", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "False", "\n", "", "if", "tensor1", ".", "size", "(", ")", "!=", "tensor2", ".", "size", "(", ")", ":", "\n", "            ", "return", "False", "\n", "# Special case for bools since they don't support subtraction", "\n", "", "if", "tensor1", ".", "dtype", "==", "torch", ".", "bool", "or", "tensor2", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "            ", "return", "(", "tensor1", "==", "tensor2", ")", ".", "all", "(", ")", "\n", "", "return", "(", "(", "tensor1", "-", "tensor2", ")", ".", "abs", "(", ")", ".", "float", "(", ")", "<", "tolerance", ")", ".", "all", "(", ")", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "tensor1", "==", "tensor2", "\n", "", "except", "RuntimeError", ":", "\n", "            ", "print", "(", "type", "(", "tensor1", ")", ",", "type", "(", "tensor2", ")", ")", "\n", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.device_mapping": [[911, 925], ["storage.cuda"], "function", ["None"], ["", "", "", "def", "device_mapping", "(", "cuda_device", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    In order to `torch.load()` a GPU-trained model onto a CPU (or specific GPU),\n    you have to supply a `map_location` function. Call this with\n    the desired `cuda_device` to get the function that `torch.load()` needs.\n    \"\"\"", "\n", "\n", "def", "inner_device_mapping", "(", "storage", ":", "torch", ".", "Storage", ",", "location", ")", "->", "torch", ".", "Storage", ":", "\n", "        ", "if", "cuda_device", ">=", "0", ":", "\n", "            ", "return", "storage", ".", "cuda", "(", "cuda_device", ")", "\n", "", "else", ":", "\n", "            ", "return", "storage", "\n", "\n", "", "", "return", "inner_device_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.combine_tensors": [[927, 956], ["combination.replace().replace.replace().replace", "torch.cat", "torch.cat", "len", "allennlp.common.checks.ConfigurationError", "nn_util._get_combination", "combination.replace().replace.replace", "combination.replace().replace.split"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split"], ["", "def", "combine_tensors", "(", "combination", ":", "str", ",", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Combines a list of tensors using element-wise operations and concatenation, specified by a\n    `combination` string.  The string refers to (1-indexed) positions in the input tensor list,\n    and looks like `\"1,2,1+2,3-1\"`.\n\n    We allow the following kinds of combinations : `x`, `x*y`, `x+y`, `x-y`, and `x/y`,\n    where `x` and `y` are positive integers less than or equal to `len(tensors)`.  Each of\n    the binary operations is performed elementwise.  You can give as many combinations as you want\n    in the `combination` string.  For example, for the input string `\"1,2,1*2\"`, the result\n    would be `[1;2;1*2]`, as you would expect, where `[;]` is concatenation along the last\n    dimension.\n\n    If you have a fixed, known way to combine tensors that you use in a model, you should probably\n    just use something like `torch.cat([x_tensor, y_tensor, x_tensor * y_tensor])`.  This\n    function adds some complexity that is only necessary if you want the specific combination used\n    to be `configurable`.\n\n    If you want to do any element-wise operations, the tensors involved in each element-wise\n    operation must have the same shape.\n\n    This function also accepts `x` and `y` in place of `1` and `2` in the combination\n    string.\n    \"\"\"", "\n", "if", "len", "(", "tensors", ")", ">", "9", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\"Double-digit tensor lists not currently supported\"", ")", "\n", "", "combination", "=", "combination", ".", "replace", "(", "\"x\"", ",", "\"1\"", ")", ".", "replace", "(", "\"y\"", ",", "\"2\"", ")", "\n", "to_concatenate", "=", "[", "_get_combination", "(", "piece", ",", "tensors", ")", "for", "piece", "in", "combination", ".", "split", "(", "\",\"", ")", "]", "\n", "return", "torch", ".", "cat", "(", "to_concatenate", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._rindex": [[958, 978], ["range", "ValueError", "len"], "function", ["None"], ["", "def", "_rindex", "(", "sequence", ":", "Sequence", "[", "T", "]", ",", "obj", ":", "T", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Return zero-based index in the sequence of the last item whose value is equal to obj.  Raises a\n    ValueError if there is no such item.\n\n    # Parameters\n\n    sequence : `Sequence[T]`\n    obj : `T`\n\n    # Returns\n\n    `int`\n        zero-based index associated to the position of the last item equal to obj\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "sequence", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "if", "sequence", "[", "i", "]", "==", "obj", ":", "\n", "            ", "return", "i", "\n", "\n", "", "", "raise", "ValueError", "(", "f\"Unable to find {obj} in sequence {sequence}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination": [[980, 1000], ["combination.isdigit", "nn_util._get_combination", "nn_util._get_combination", "int", "len", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination"], ["", "def", "_get_combination", "(", "combination", ":", "str", ",", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "if", "combination", ".", "isdigit", "(", ")", ":", "\n", "        ", "index", "=", "int", "(", "combination", ")", "-", "1", "\n", "return", "tensors", "[", "index", "]", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "combination", ")", "!=", "3", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"Invalid combination: \"", "+", "combination", ")", "\n", "", "first_tensor", "=", "_get_combination", "(", "combination", "[", "0", "]", ",", "tensors", ")", "\n", "second_tensor", "=", "_get_combination", "(", "combination", "[", "2", "]", ",", "tensors", ")", "\n", "operation", "=", "combination", "[", "1", "]", "\n", "if", "operation", "==", "\"*\"", ":", "\n", "            ", "return", "first_tensor", "*", "second_tensor", "\n", "", "elif", "operation", "==", "\"/\"", ":", "\n", "            ", "return", "first_tensor", "/", "second_tensor", "\n", "", "elif", "operation", "==", "\"+\"", ":", "\n", "            ", "return", "first_tensor", "+", "second_tensor", "\n", "", "elif", "operation", "==", "\"-\"", ":", "\n", "            ", "return", "first_tensor", "-", "second_tensor", "\n", "", "else", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"Invalid operation: \"", "+", "operation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.combine_tensors_and_multiply": [[1002, 1040], ["combination.replace().replace.replace().replace", "combination.replace().replace.split", "zip", "len", "allennlp.common.checks.ConfigurationError", "tensor.size", "nn_util._get_combination_dim", "to_sum.append", "combination.replace().replace.replace", "nn_util._get_combination_and_multiply"], "function", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_dim", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_and_multiply"], ["", "", "", "def", "combine_tensors_and_multiply", "(", "\n", "combination", ":", "str", ",", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "weights", ":", "torch", ".", "nn", ".", "Parameter", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Like [`combine_tensors`](./util.md#combine_tensors), but does a weighted (linear)\n    multiplication while combining. This is a separate function from `combine_tensors`\n    because we try to avoid instantiating large intermediate tensors during the combination,\n    which is possible because we know that we're going to be multiplying by a weight vector in the end.\n\n    # Parameters\n\n    combination : `str`\n        Same as in `combine_tensors`\n    tensors : `List[torch.Tensor]`\n        A list of tensors to combine, where the integers in the `combination` are (1-indexed)\n        positions in this list of tensors.  These tensors are all expected to have either three or\n        four dimensions, with the final dimension being an embedding.  If there are four\n        dimensions, one of them must have length 1.\n    weights : `torch.nn.Parameter`\n        A vector of weights to use for the combinations.  This should have shape (combined_dim,),\n        as calculated by `get_combined_dim`.\n    \"\"\"", "\n", "if", "len", "(", "tensors", ")", ">", "9", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\"Double-digit tensor lists not currently supported\"", ")", "\n", "", "combination", "=", "combination", ".", "replace", "(", "\"x\"", ",", "\"1\"", ")", ".", "replace", "(", "\"y\"", ",", "\"2\"", ")", "\n", "pieces", "=", "combination", ".", "split", "(", "\",\"", ")", "\n", "tensor_dims", "=", "[", "tensor", ".", "size", "(", "-", "1", ")", "for", "tensor", "in", "tensors", "]", "\n", "combination_dims", "=", "[", "_get_combination_dim", "(", "piece", ",", "tensor_dims", ")", "for", "piece", "in", "pieces", "]", "\n", "dims_so_far", "=", "0", "\n", "to_sum", "=", "[", "]", "\n", "for", "piece", ",", "combination_dim", "in", "zip", "(", "pieces", ",", "combination_dims", ")", ":", "\n", "        ", "weight", "=", "weights", "[", "dims_so_far", ":", "(", "dims_so_far", "+", "combination_dim", ")", "]", "\n", "dims_so_far", "+=", "combination_dim", "\n", "to_sum", ".", "append", "(", "_get_combination_and_multiply", "(", "piece", ",", "tensors", ",", "weight", ")", ")", "\n", "", "result", "=", "to_sum", "[", "0", "]", "\n", "for", "result_piece", "in", "to_sum", "[", "1", ":", "]", ":", "\n", "        ", "result", "=", "result", "+", "result_piece", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_and_multiply": [[1042, 1090], ["combination.isdigit", "torch.matmul", "torch.matmul", "nn_util._get_combination", "nn_util._get_combination", "int", "len", "allennlp.common.checks.ConfigurationError", "torch.matmul", "torch.matmul", "ValueError", "max", "first_tensor.squeeze.dim", "nn_util._rindex", "first_tensor.squeeze.squeeze", "second_tensor.squeeze.dim", "nn_util._rindex", "second_tensor.squeeze.squeeze", "second_tensor.squeeze.transpose", "result.squeeze.dim", "result.squeeze.squeeze", "torch.matmul", "torch.matmul", "first_tensor.squeeze.dim", "second_tensor.squeeze.dim", "first_tensor.squeeze.dim", "second_tensor.squeeze.dim", "first_tensor.squeeze.size", "second_tensor.squeeze.size", "ValueError", "max", "first_tensor.squeeze.dim", "nn_util._rindex", "first_tensor.squeeze.squeeze", "second_tensor.squeeze.dim", "nn_util._rindex", "second_tensor.squeeze.squeeze", "second_tensor.squeeze.pow().transpose", "result.squeeze.dim", "result.squeeze.squeeze", "first_tensor.squeeze.dim", "second_tensor.squeeze.dim", "first_tensor.squeeze.dim", "second_tensor.squeeze.dim", "first_tensor.squeeze.size", "second_tensor.squeeze.size", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "allennlp.common.checks.ConfigurationError", "second_tensor.squeeze.pow", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._rindex", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._rindex", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._rindex", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._rindex"], ["", "def", "_get_combination_and_multiply", "(", "\n", "combination", ":", "str", ",", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "weight", ":", "torch", ".", "nn", ".", "Parameter", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "if", "combination", ".", "isdigit", "(", ")", ":", "\n", "        ", "index", "=", "int", "(", "combination", ")", "-", "1", "\n", "return", "torch", ".", "matmul", "(", "tensors", "[", "index", "]", ",", "weight", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "combination", ")", "!=", "3", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"Invalid combination: \"", "+", "combination", ")", "\n", "", "first_tensor", "=", "_get_combination", "(", "combination", "[", "0", "]", ",", "tensors", ")", "\n", "second_tensor", "=", "_get_combination", "(", "combination", "[", "2", "]", ",", "tensors", ")", "\n", "operation", "=", "combination", "[", "1", "]", "\n", "if", "operation", "==", "\"*\"", ":", "\n", "            ", "if", "first_tensor", ".", "dim", "(", ")", ">", "4", "or", "second_tensor", ".", "dim", "(", ")", ">", "4", ":", "\n", "                ", "raise", "ValueError", "(", "\"Tensors with dim > 4 not currently supported\"", ")", "\n", "", "desired_dim", "=", "max", "(", "first_tensor", ".", "dim", "(", ")", ",", "second_tensor", ".", "dim", "(", ")", ")", "-", "1", "\n", "if", "first_tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "                ", "expanded_dim", "=", "_rindex", "(", "first_tensor", ".", "size", "(", ")", ",", "1", ")", "\n", "first_tensor", "=", "first_tensor", ".", "squeeze", "(", "expanded_dim", ")", "\n", "", "if", "second_tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "                ", "expanded_dim", "=", "_rindex", "(", "second_tensor", ".", "size", "(", ")", ",", "1", ")", "\n", "second_tensor", "=", "second_tensor", ".", "squeeze", "(", "expanded_dim", ")", "\n", "", "intermediate", "=", "first_tensor", "*", "weight", "\n", "result", "=", "torch", ".", "matmul", "(", "intermediate", ",", "second_tensor", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "if", "result", ".", "dim", "(", ")", "==", "desired_dim", "+", "1", ":", "\n", "                ", "result", "=", "result", ".", "squeeze", "(", "-", "1", ")", "\n", "", "return", "result", "\n", "", "elif", "operation", "==", "\"/\"", ":", "\n", "            ", "if", "first_tensor", ".", "dim", "(", ")", ">", "4", "or", "second_tensor", ".", "dim", "(", ")", ">", "4", ":", "\n", "                ", "raise", "ValueError", "(", "\"Tensors with dim > 4 not currently supported\"", ")", "\n", "", "desired_dim", "=", "max", "(", "first_tensor", ".", "dim", "(", ")", ",", "second_tensor", ".", "dim", "(", ")", ")", "-", "1", "\n", "if", "first_tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "                ", "expanded_dim", "=", "_rindex", "(", "first_tensor", ".", "size", "(", ")", ",", "1", ")", "\n", "first_tensor", "=", "first_tensor", ".", "squeeze", "(", "expanded_dim", ")", "\n", "", "if", "second_tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "                ", "expanded_dim", "=", "_rindex", "(", "second_tensor", ".", "size", "(", ")", ",", "1", ")", "\n", "second_tensor", "=", "second_tensor", ".", "squeeze", "(", "expanded_dim", ")", "\n", "", "intermediate", "=", "first_tensor", "*", "weight", "\n", "result", "=", "torch", ".", "matmul", "(", "intermediate", ",", "second_tensor", ".", "pow", "(", "-", "1", ")", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "if", "result", ".", "dim", "(", ")", "==", "desired_dim", "+", "1", ":", "\n", "                ", "result", "=", "result", ".", "squeeze", "(", "-", "1", ")", "\n", "", "return", "result", "\n", "", "elif", "operation", "==", "\"+\"", ":", "\n", "            ", "return", "torch", ".", "matmul", "(", "first_tensor", ",", "weight", ")", "+", "torch", ".", "matmul", "(", "second_tensor", ",", "weight", ")", "\n", "", "elif", "operation", "==", "\"-\"", ":", "\n", "            ", "return", "torch", ".", "matmul", "(", "first_tensor", ",", "weight", ")", "-", "torch", ".", "matmul", "(", "second_tensor", ",", "weight", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"Invalid operation: \"", "+", "operation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_combined_dim": [[1092, 1112], ["combination.replace().replace.replace().replace", "sum", "len", "allennlp.common.checks.ConfigurationError", "combination.replace().replace.replace", "nn_util._get_combination_dim", "combination.replace().replace.split"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_dim", "home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split"], ["", "", "", "def", "get_combined_dim", "(", "combination", ":", "str", ",", "tensor_dims", ":", "List", "[", "int", "]", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    For use with [`combine_tensors`](./util.md#combine_tensors).\n    This function computes the resultant dimension when calling `combine_tensors(combination, tensors)`,\n    when the tensor dimension is known.  This is necessary for knowing the sizes of weight matrices\n    when building models that use `combine_tensors`.\n\n    # Parameters\n\n    combination : `str`\n        A comma-separated list of combination pieces, like `\"1,2,1*2\"`, specified identically to\n        `combination` in `combine_tensors`.\n    tensor_dims : `List[int]`\n        A list of tensor dimensions, where each dimension is from the `last axis` of the tensors\n        that will be input to `combine_tensors`.\n    \"\"\"", "\n", "if", "len", "(", "tensor_dims", ")", ">", "9", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\"Double-digit tensor lists not currently supported\"", ")", "\n", "", "combination", "=", "combination", ".", "replace", "(", "\"x\"", ",", "\"1\"", ")", ".", "replace", "(", "\"y\"", ",", "\"2\"", ")", "\n", "return", "sum", "(", "_get_combination_dim", "(", "piece", ",", "tensor_dims", ")", "for", "piece", "in", "combination", ".", "split", "(", "\",\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_dim": [[1114, 1127], ["combination.isdigit", "nn_util._get_combination_dim", "nn_util._get_combination_dim", "int", "len", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_dim", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util._get_combination_dim"], ["", "def", "_get_combination_dim", "(", "combination", ":", "str", ",", "tensor_dims", ":", "List", "[", "int", "]", ")", "->", "int", ":", "\n", "    ", "if", "combination", ".", "isdigit", "(", ")", ":", "\n", "        ", "index", "=", "int", "(", "combination", ")", "-", "1", "\n", "return", "tensor_dims", "[", "index", "]", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "combination", ")", "!=", "3", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"Invalid combination: \"", "+", "combination", ")", "\n", "", "first_tensor_dim", "=", "_get_combination_dim", "(", "combination", "[", "0", "]", ",", "tensor_dims", ")", "\n", "second_tensor_dim", "=", "_get_combination_dim", "(", "combination", "[", "2", "]", ",", "tensor_dims", ")", "\n", "operation", "=", "combination", "[", "1", "]", "\n", "if", "first_tensor_dim", "!=", "second_tensor_dim", ":", "\n", "            ", "raise", "ConfigurationError", "(", "'Tensor dims must match for operation \"{}\"'", ".", "format", "(", "operation", ")", ")", "\n", "", "return", "first_tensor_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.logsumexp": [[1129, 1150], ["tensor.max", "stable_vec.exp().sum().log", "max_score.unsqueeze", "stable_vec.exp().sum", "stable_vec.exp"], "function", ["None"], ["", "", "def", "logsumexp", "(", "tensor", ":", "torch", ".", "Tensor", ",", "dim", ":", "int", "=", "-", "1", ",", "keepdim", ":", "bool", "=", "False", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    A numerically stable computation of logsumexp. This is mathematically equivalent to\n    `tensor.exp().sum(dim, keep=keepdim).log()`.  This function is typically used for summing log\n    probabilities.\n\n    # Parameters\n\n    tensor : `torch.FloatTensor`, required.\n        A tensor of arbitrary size.\n    dim : `int`, optional (default = `-1`)\n        The dimension of the tensor to apply the logsumexp to.\n    keepdim: `bool`, optional (default = `False`)\n        Whether to retain a dimension of size one at the dimension we reduce over.\n    \"\"\"", "\n", "max_score", ",", "_", "=", "tensor", ".", "max", "(", "dim", ",", "keepdim", "=", "keepdim", ")", "\n", "if", "keepdim", ":", "\n", "        ", "stable_vec", "=", "tensor", "-", "max_score", "\n", "", "else", ":", "\n", "        ", "stable_vec", "=", "tensor", "-", "max_score", ".", "unsqueeze", "(", "dim", ")", "\n", "", "return", "max_score", "+", "(", "stable_vec", ".", "exp", "(", ")", ".", "sum", "(", "dim", ",", "keepdim", "=", "keepdim", ")", ")", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of": [[1152, 1160], ["tensor.get_device"], "function", ["None"], ["", "def", "get_device_of", "(", "tensor", ":", "torch", ".", "Tensor", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns the device of the tensor.\n    \"\"\"", "\n", "if", "not", "tensor", ".", "is_cuda", ":", "\n", "        ", "return", "-", "1", "\n", "", "else", ":", "\n", "        ", "return", "tensor", ".", "get_device", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices": [[1162, 1207], ["range", "offset_indices.view.view", "allennlp.common.checks.ConfigurationError", "nn_util.get_range_vector", "offsets.unsqueeze.unsqueeze", "torch.max", "torch.max", "torch.min", "torch.min", "indices.size", "nn_util.get_device_of", "len", "indices.size"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of"], ["", "", "def", "flatten_and_batch_shift_indices", "(", "indices", ":", "torch", ".", "Tensor", ",", "sequence_length", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    This is a subroutine for [`batched_index_select`](./util.md#batched_index_select).\n    The given `indices` of size `(batch_size, d_1, ..., d_n)` indexes into dimension 2 of a\n    target tensor, which has size `(batch_size, sequence_length, embedding_size)`. This\n    function returns a vector that correctly indexes into the flattened target. The sequence\n    length of the target must be provided to compute the appropriate offsets.\n\n    ```python\n        indices = torch.ones([2,3], dtype=torch.long)\n        # Sequence length of the target tensor.\n        sequence_length = 10\n        shifted_indices = flatten_and_batch_shift_indices(indices, sequence_length)\n        # Indices into the second element in the batch are correctly shifted\n        # to take into account that the target tensor will be flattened before\n        # the indices are applied.\n        assert shifted_indices == [1, 1, 1, 11, 11, 11]\n    ```\n\n    # Parameters\n\n    indices : `torch.LongTensor`, required.\n    sequence_length : `int`, required.\n        The length of the sequence the indices index into.\n        This must be the second dimension of the tensor.\n\n    # Returns\n\n    offset_indices : `torch.LongTensor`\n    \"\"\"", "\n", "# Shape: (batch_size)", "\n", "if", "torch", ".", "max", "(", "indices", ")", ">=", "sequence_length", "or", "torch", ".", "min", "(", "indices", ")", "<", "0", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\n", "f\"All elements in indices should be in range (0, {sequence_length - 1})\"", "\n", ")", "\n", "", "offsets", "=", "get_range_vector", "(", "indices", ".", "size", "(", "0", ")", ",", "get_device_of", "(", "indices", ")", ")", "*", "sequence_length", "\n", "for", "_", "in", "range", "(", "len", "(", "indices", ".", "size", "(", ")", ")", "-", "1", ")", ":", "\n", "        ", "offsets", "=", "offsets", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# Shape: (batch_size, d_1, ..., d_n)", "\n", "", "offset_indices", "=", "indices", "+", "offsets", "\n", "\n", "# Shape: (batch_size * d_1 * ... * d_n)", "\n", "offset_indices", "=", "offset_indices", ".", "view", "(", "-", "1", ")", "\n", "return", "offset_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select": [[1209, 1265], ["target.view", "target.view.index_select", "flattened_target.index_select.view", "nn_util.flatten_and_batch_shift_indices", "target.size", "list", "target.size", "indices.size", "target.size"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices"], ["", "def", "batched_index_select", "(", "\n", "target", ":", "torch", ".", "Tensor", ",", "\n", "indices", ":", "torch", ".", "LongTensor", ",", "\n", "flattened_indices", ":", "Optional", "[", "torch", ".", "LongTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    The given `indices` of size `(batch_size, d_1, ..., d_n)` indexes into the sequence\n    dimension (dimension 2) of the target, which has size `(batch_size, sequence_length,\n    embedding_size)`.\n\n    This function returns selected values in the target with respect to the provided indices, which\n    have size `(batch_size, d_1, ..., d_n, embedding_size)`. This can use the optionally\n    precomputed `flattened_indices` with size `(batch_size * d_1 * ... * d_n)` if given.\n\n    An example use case of this function is looking up the start and end indices of spans in a\n    sequence tensor. This is used in the\n    [CoreferenceResolver](https://docs.allennlp.org/models/main/models/coref/models/coref/)\n    model to select contextual word representations corresponding to the start and end indices of\n    mentions.\n\n    The key reason this can't be done with basic torch functions is that we want to be able to use look-up\n    tensors with an arbitrary number of dimensions (for example, in the coref model, we don't know\n    a-priori how many spans we are looking up).\n\n    # Parameters\n\n    target : `torch.Tensor`, required.\n        A 3 dimensional tensor of shape (batch_size, sequence_length, embedding_size).\n        This is the tensor to be indexed.\n    indices : `torch.LongTensor`\n        A tensor of shape (batch_size, ...), where each element is an index into the\n        `sequence_length` dimension of the `target` tensor.\n    flattened_indices : `Optional[torch.Tensor]`, optional (default = `None`)\n        An optional tensor representing the result of calling `flatten_and_batch_shift_indices`\n        on `indices`. This is helpful in the case that the indices can be flattened once and\n        cached for many batch lookups.\n\n    # Returns\n\n    selected_targets : `torch.Tensor`\n        A tensor with shape [indices.size(), target.size(-1)] representing the embedded indices\n        extracted from the batch flattened target tensor.\n    \"\"\"", "\n", "if", "flattened_indices", "is", "None", ":", "\n", "# Shape: (batch_size * d_1 * ... * d_n)", "\n", "        ", "flattened_indices", "=", "flatten_and_batch_shift_indices", "(", "indices", ",", "target", ".", "size", "(", "1", ")", ")", "\n", "\n", "# Shape: (batch_size * sequence_length, embedding_size)", "\n", "", "flattened_target", "=", "target", ".", "view", "(", "-", "1", ",", "target", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "# Shape: (batch_size * d_1 * ... * d_n, embedding_size)", "\n", "flattened_selected", "=", "flattened_target", ".", "index_select", "(", "0", ",", "flattened_indices", ")", "\n", "selected_shape", "=", "list", "(", "indices", ".", "size", "(", ")", ")", "+", "[", "target", ".", "size", "(", "-", "1", ")", "]", "\n", "# Shape: (batch_size, d_1, ..., d_n, embedding_size)", "\n", "selected_targets", "=", "flattened_selected", ".", "view", "(", "*", "selected_shape", ")", "\n", "return", "selected_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_index_fill": [[1267, 1308], ["mask.view.bool", "target.size", "nn_util.flatten_and_batch_shift_indices", "mask.view.view", "target.view", "flattened_indices[].unsqueeze", "flattened_target.scatter.scatter", "flattened_target.scatter.reshape", "target.size"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices"], ["", "def", "masked_index_fill", "(", "\n", "target", ":", "torch", ".", "Tensor", ",", "indices", ":", "torch", ".", "LongTensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "fill_value", ":", "int", "=", "1", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    The given `indices` in `target` will be will be filled with `fill_value` given a `mask`.\n\n\n    # Parameters\n\n    target : `torch.Tensor`, required.\n        A 2 dimensional tensor of shape (batch_size, sequence_length).\n        This is the tensor to be filled.\n    indices : `torch.LongTensor`, required\n        A 2 dimensional tensor of shape (batch_size, num_indices),\n        These are the indices that will be filled in the original tensor.\n    mask : `torch.Tensor`, required.\n        A 2 dimensional tensor of shape (batch_size, num_indices), mask.sum() == `nonzero_indices`.\n    fill_value : `int`, optional (default = `1`)\n        The value we fill the tensor with.\n\n    # Returns\n\n    filled_target : `torch.Tensor`\n        A tensor with shape (batch_size, sequence_length) where 'indices' are filled with `fill_value`\n    \"\"\"", "\n", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "prev_shape", "=", "target", ".", "size", "(", ")", "\n", "# Shape: (batch_size * num_indices)", "\n", "flattened_indices", "=", "flatten_and_batch_shift_indices", "(", "indices", "*", "mask", ",", "target", ".", "size", "(", "1", ")", ")", "\n", "# Shape: (batch_size * num_indices, 1)", "\n", "mask", "=", "mask", ".", "view", "(", "-", "1", ")", "\n", "# Shape: (batch_size * sequence_length, 1)", "\n", "flattened_target", "=", "target", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "# Shape: (nonzero_indices, 1)", "\n", "unmasked_indices", "=", "flattened_indices", "[", "mask", "]", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "flattened_target", "=", "flattened_target", ".", "scatter", "(", "0", ",", "unmasked_indices", ",", "fill_value", ")", "\n", "\n", "filled_target", "=", "flattened_target", ".", "reshape", "(", "prev_shape", ")", "\n", "\n", "return", "filled_target", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_index_replace": [[1310, 1354], ["target.clone.clone", "mask.view.bool", "target.clone.size", "nn_util.flatten_and_batch_shift_indices", "target.clone.view", "mask.view.view", "target.view.reshape", "target.clone.size", "target.clone.size", "replace.view", "replace.size"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.clone", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flatten_and_batch_shift_indices"], ["", "def", "masked_index_replace", "(", "\n", "target", ":", "torch", ".", "Tensor", ",", "\n", "indices", ":", "torch", ".", "LongTensor", ",", "\n", "mask", ":", "torch", ".", "BoolTensor", ",", "\n", "replace", ":", "torch", ".", "Tensor", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    The given `indices` in `target` will be will be replaced with corresponding index\n    from the `replace` tensor given a `mask`.\n\n\n    # Parameters\n\n    target : `torch.Tensor`, required.\n        A 3 dimensional tensor of shape (batch_size, sequence_length, embedding_dim).\n        This is the tensor to be replaced into.\n    indices : `torch.LongTensor`, required\n        A 2 dimensional tensor of shape (batch_size, num_indices),\n        These are the indices that will be replaced in the original tensor.\n    mask : `torch.Tensor`, required.\n        A 2 dimensional tensor of shape (batch_size, num_indices), mask.sum() == `nonzero_indices`.\n    replace : `torch.Tensor`, required.\n        A 3 dimensional tensor of shape (batch_size, num_indices, embedding_dim),\n        The tensor to perform scatter from.\n\n    # Returns\n\n    replaced_target : `torch.Tensor`\n        A tensor with shape (batch_size, sequence_length, embedding_dim) where 'indices'\n        are replaced with the corrosponding vector from `replace`\n    \"\"\"", "\n", "target", "=", "target", ".", "clone", "(", ")", "\n", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "prev_shape", "=", "target", ".", "size", "(", ")", "\n", "# Shape: (batch_size * num_indices)", "\n", "flattened_indices", "=", "flatten_and_batch_shift_indices", "(", "indices", "*", "mask", ",", "target", ".", "size", "(", "1", ")", ")", "\n", "# Shape: (batch_size * sequence_length, embedding_size)", "\n", "flattened_target", "=", "target", ".", "view", "(", "-", "1", ",", "target", ".", "size", "(", "-", "1", ")", ")", "\n", "# Shape: (nonzero_indices, 1)", "\n", "mask", "=", "mask", ".", "view", "(", "-", "1", ")", "\n", "flattened_target", "[", "flattened_indices", "[", "mask", "]", "]", "=", "replace", ".", "view", "(", "-", "1", ",", "replace", ".", "size", "(", "-", "1", ")", ")", "[", "mask", "]", "\n", "# Shape: (batch_size, sequence_length, embedding_dim)", "\n", "replaced_target", "=", "flattened_target", ".", "reshape", "(", "prev_shape", ")", "\n", "return", "replaced_target", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_span_select": [[1356, 1420], ["spans.split", "get_range_vector().view", "nn_util.batched_index_select", "span_widths.max().item", "nn_util.get_range_vector", "span_widths.max", "nn_util.get_device_of", "target.size"], "function", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.batched_index_select", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of"], ["", "def", "batched_span_select", "(", "target", ":", "torch", ".", "Tensor", ",", "spans", ":", "torch", ".", "LongTensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    The given `spans` of size `(batch_size, num_spans, 2)` indexes into the sequence\n    dimension (dimension 2) of the target, which has size `(batch_size, sequence_length,\n    embedding_size)`.\n\n    This function returns segmented spans in the target with respect to the provided span indices.\n\n    # Parameters\n\n    target : `torch.Tensor`, required.\n        A 3 dimensional tensor of shape (batch_size, sequence_length, embedding_size).\n        This is the tensor to be indexed.\n    indices : `torch.LongTensor`\n        A 3 dimensional tensor of shape (batch_size, num_spans, 2) representing start and end\n        indices (both inclusive) into the `sequence_length` dimension of the `target` tensor.\n\n    # Returns\n\n    span_embeddings : `torch.Tensor`\n        A tensor with shape (batch_size, num_spans, max_batch_span_width, embedding_size]\n        representing the embedded spans extracted from the batch flattened target tensor.\n    span_mask: `torch.BoolTensor`\n        A tensor with shape (batch_size, num_spans, max_batch_span_width) representing the mask on\n        the returned span embeddings.\n    \"\"\"", "\n", "# both of shape (batch_size, num_spans, 1)", "\n", "span_starts", ",", "span_ends", "=", "spans", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# shape (batch_size, num_spans, 1)", "\n", "# These span widths are off by 1, because the span ends are `inclusive`.", "\n", "span_widths", "=", "span_ends", "-", "span_starts", "\n", "\n", "# We need to know the maximum span width so we can", "\n", "# generate indices to extract the spans from the sequence tensor.", "\n", "# These indices will then get masked below, such that if the length", "\n", "# of a given span is smaller than the max, the rest of the values", "\n", "# are masked.", "\n", "max_batch_span_width", "=", "span_widths", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", "\n", "\n", "# Shape: (1, 1, max_batch_span_width)", "\n", "max_span_range_indices", "=", "get_range_vector", "(", "max_batch_span_width", ",", "get_device_of", "(", "target", ")", ")", ".", "view", "(", "\n", "1", ",", "1", ",", "-", "1", "\n", ")", "\n", "# Shape: (batch_size, num_spans, max_batch_span_width)", "\n", "# This is a broadcasted comparison - for each span we are considering,", "\n", "# we are creating a range vector of size max_span_width, but masking values", "\n", "# which are greater than the actual length of the span.", "\n", "#", "\n", "# We're using <= here (and for the mask below) because the span ends are", "\n", "# inclusive, so we want to include indices which are equal to span_widths rather", "\n", "# than using it as a non-inclusive upper bound.", "\n", "span_mask", "=", "max_span_range_indices", "<=", "span_widths", "\n", "raw_span_indices", "=", "span_starts", "+", "max_span_range_indices", "\n", "# We also don't want to include span indices which greater than the sequence_length,", "\n", "# which happens because some spans near the end of the sequence", "\n", "# have a start index + max_batch_span_width > sequence_length, so we add this to the mask here.", "\n", "span_mask", "=", "span_mask", "&", "(", "raw_span_indices", "<", "target", ".", "size", "(", "1", ")", ")", "&", "(", "0", "<=", "raw_span_indices", ")", "\n", "span_indices", "=", "raw_span_indices", "*", "span_mask", "\n", "\n", "# Shape: (batch_size, num_spans, max_batch_span_width, embedding_dim)", "\n", "span_embeddings", "=", "batched_index_select", "(", "target", ",", "span_indices", ")", "\n", "\n", "return", "span_embeddings", ",", "span_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.flattened_index_select": [[1422, 1453], ["target.index_select", "target.index_select.view", "indices.dim", "allennlp.common.checks.ConfigurationError", "indices.view", "target.size", "indices.size", "indices.size", "indices.size"], "function", ["None"], ["", "def", "flattened_index_select", "(", "target", ":", "torch", ".", "Tensor", ",", "indices", ":", "torch", ".", "LongTensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    The given `indices` of size `(set_size, subset_size)` specifies subsets of the `target`\n    that each of the set_size rows should select. The `target` has size\n    `(batch_size, sequence_length, embedding_size)`, and the resulting selected tensor has size\n    `(batch_size, set_size, subset_size, embedding_size)`.\n\n    # Parameters\n\n    target : `torch.Tensor`, required.\n        A Tensor of shape (batch_size, sequence_length, embedding_size).\n    indices : `torch.LongTensor`, required.\n        A LongTensor of shape (set_size, subset_size). All indices must be < sequence_length\n        as this tensor is an index into the sequence_length dimension of the target.\n\n    # Returns\n\n    selected : `torch.Tensor`, required.\n        A Tensor of shape (batch_size, set_size, subset_size, embedding_size).\n    \"\"\"", "\n", "if", "indices", ".", "dim", "(", ")", "!=", "2", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\n", "\"Indices passed to flattened_index_select had shape {} but \"", "\n", "\"only 2 dimensional inputs are supported.\"", ".", "format", "(", "indices", ".", "size", "(", ")", ")", "\n", ")", "\n", "# Shape: (batch_size, set_size * subset_size, embedding_size)", "\n", "", "flattened_selected", "=", "target", ".", "index_select", "(", "1", ",", "indices", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "# Shape: (batch_size, set_size, subset_size, embedding_size)", "\n", "selected", "=", "flattened_selected", ".", "view", "(", "target", ".", "size", "(", "0", ")", ",", "indices", ".", "size", "(", "0", ")", ",", "indices", ".", "size", "(", "1", ")", ",", "-", "1", ")", "\n", "return", "selected", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector": [[1455, 1464], ["torch.arange", "torch.arange", "torch.cuda.LongTensor().fill_().cumsum", "torch.cuda.LongTensor().fill_().cumsum", "torch.cuda.LongTensor().fill_", "torch.cuda.LongTensor().fill_", "torch.cuda.LongTensor", "torch.cuda.LongTensor"], "function", ["None"], ["", "def", "get_range_vector", "(", "size", ":", "int", ",", "device", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Returns a range vector with the desired size, starting at 0. The CUDA implementation\n    is meant to avoid copy data from CPU to GPU.\n    \"\"\"", "\n", "if", "device", ">", "-", "1", ":", "\n", "        ", "return", "torch", ".", "cuda", ".", "LongTensor", "(", "size", ",", "device", "=", "device", ")", ".", "fill_", "(", "1", ")", ".", "cumsum", "(", "0", ")", "-", "1", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "arange", "(", "0", ",", "size", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.bucket_values": [[1466, 1507], ["combined_index.clamp", "distances.float().log", "math.log", "distances.float"], "function", ["None"], ["", "", "def", "bucket_values", "(", "\n", "distances", ":", "torch", ".", "Tensor", ",", "num_identity_buckets", ":", "int", "=", "4", ",", "num_total_buckets", ":", "int", "=", "10", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Places the given values (designed for distances) into `num_total_buckets`semi-logscale\n    buckets, with `num_identity_buckets` of these capturing single values.\n\n    The default settings will bucket values into the following buckets:\n    [0, 1, 2, 3, 4, 5-7, 8-15, 16-31, 32-63, 64+].\n\n    # Parameters\n\n    distances : `torch.Tensor`, required.\n        A Tensor of any size, to be bucketed.\n    num_identity_buckets: `int`, optional (default = `4`).\n        The number of identity buckets (those only holding a single value).\n    num_total_buckets : `int`, (default = `10`)\n        The total number of buckets to bucket values into.\n\n    # Returns\n\n    `torch.Tensor`\n        A tensor of the same shape as the input, containing the indices of the buckets\n        the values were placed in.\n    \"\"\"", "\n", "# Chunk the values into semi-logscale buckets using .floor().", "\n", "# This is a semi-logscale bucketing because we divide by log(2) after taking the log.", "\n", "# We do this to make the buckets more granular in the initial range, where we expect", "\n", "# most values to fall. We then add (num_identity_buckets - 1) because we want these indices", "\n", "# to start _after_ the fixed number of buckets which we specified would only hold single values.", "\n", "logspace_index", "=", "(", "distances", ".", "float", "(", ")", ".", "log", "(", ")", "/", "math", ".", "log", "(", "2", ")", ")", ".", "floor", "(", ")", ".", "long", "(", ")", "+", "(", "\n", "num_identity_buckets", "-", "1", "\n", ")", "\n", "# create a mask for values which will go into single number buckets (i.e not a range).", "\n", "use_identity_mask", "=", "(", "distances", "<=", "num_identity_buckets", ")", ".", "long", "(", ")", "\n", "use_buckets_mask", "=", "1", "+", "(", "-", "1", "*", "use_identity_mask", ")", "\n", "# Use the original values if they are less than num_identity_buckets, otherwise", "\n", "# use the logspace indices.", "\n", "combined_index", "=", "use_identity_mask", "*", "distances", "+", "use_buckets_mask", "*", "logspace_index", "\n", "# Clamp to put anything > num_total_buckets into the final bucket.", "\n", "return", "combined_index", ".", "clamp", "(", "0", ",", "num_total_buckets", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.add_sentence_boundary_token_ids": [[1509, 1566], ["mask.sum().detach().cpu().numpy", "list", "list", "tensor.new_zeros", "len", "enumerate", "mask.sum().detach().cpu", "len", "sentence_begin_token.detach().to.detach().to", "sentence_end_token.detach().to.detach().to", "enumerate", "ValueError", "mask.sum().detach", "sentence_begin_token.detach().to.detach", "sentence_end_token.detach().to.detach", "mask.sum"], "function", ["None"], ["", "def", "add_sentence_boundary_token_ids", "(", "\n", "tensor", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", ",", "sentence_begin_token", ":", "Any", ",", "sentence_end_token", ":", "Any", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "BoolTensor", "]", ":", "\n", "    ", "\"\"\"\n    Add begin/end of sentence tokens to the batch of sentences.\n    Given a batch of sentences with size `(batch_size, timesteps)` or\n    `(batch_size, timesteps, dim)` this returns a tensor of shape\n    `(batch_size, timesteps + 2)` or `(batch_size, timesteps + 2, dim)` respectively.\n\n    Returns both the new tensor and updated mask.\n\n    # Parameters\n\n    tensor : `torch.Tensor`\n        A tensor of shape `(batch_size, timesteps)` or `(batch_size, timesteps, dim)`\n    mask : `torch.BoolTensor`\n         A tensor of shape `(batch_size, timesteps)`\n    sentence_begin_token: `Any`\n        Can be anything that can be broadcast in torch for assignment.\n        For 2D input, a scalar with the `<S>` id. For 3D input, a tensor with length dim.\n    sentence_end_token: `Any`\n        Can be anything that can be broadcast in torch for assignment.\n        For 2D input, a scalar with the `</S>` id. For 3D input, a tensor with length dim.\n\n    # Returns\n\n    tensor_with_boundary_tokens : `torch.Tensor`\n        The tensor with the appended and prepended boundary tokens. If the input was 2D,\n        it has shape (batch_size, timesteps + 2) and if the input was 3D, it has shape\n        (batch_size, timesteps + 2, dim).\n    new_mask : `torch.BoolTensor`\n        The new mask for the tensor, taking into account the appended tokens\n        marking the beginning and end of the sentence.\n    \"\"\"", "\n", "sequence_lengths", "=", "mask", ".", "sum", "(", "dim", "=", "1", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "tensor_shape", "=", "list", "(", "tensor", ".", "data", ".", "shape", ")", "\n", "new_shape", "=", "list", "(", "tensor_shape", ")", "\n", "new_shape", "[", "1", "]", "=", "tensor_shape", "[", "1", "]", "+", "2", "\n", "tensor_with_boundary_tokens", "=", "tensor", ".", "new_zeros", "(", "*", "new_shape", ",", "device", "=", "tensor", ".", "device", ")", "\n", "if", "len", "(", "tensor_shape", ")", "==", "2", ":", "\n", "        ", "tensor_with_boundary_tokens", "[", ":", ",", "1", ":", "-", "1", "]", "=", "tensor", "\n", "tensor_with_boundary_tokens", "[", ":", ",", "0", "]", "=", "sentence_begin_token", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "sequence_lengths", ")", ":", "\n", "            ", "tensor_with_boundary_tokens", "[", "i", ",", "j", "+", "1", "]", "=", "sentence_end_token", "\n", "", "new_mask", "=", "tensor_with_boundary_tokens", "!=", "0", "\n", "", "elif", "len", "(", "tensor_shape", ")", "==", "3", ":", "\n", "        ", "tensor_with_boundary_tokens", "[", ":", ",", "1", ":", "-", "1", ",", ":", "]", "=", "tensor", "\n", "sentence_begin_token", "=", "sentence_begin_token", ".", "detach", "(", ")", ".", "to", "(", "tensor", ".", "device", ")", "\n", "sentence_end_token", "=", "sentence_end_token", ".", "detach", "(", ")", ".", "to", "(", "tensor", ".", "device", ")", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "sequence_lengths", ")", ":", "\n", "            ", "tensor_with_boundary_tokens", "[", "i", ",", "0", ",", ":", "]", "=", "sentence_begin_token", "\n", "tensor_with_boundary_tokens", "[", "i", ",", "j", "+", "1", ",", ":", "]", "=", "sentence_end_token", "\n", "", "new_mask", "=", "(", "tensor_with_boundary_tokens", ">", "0", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ">", "0", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"add_sentence_boundary_token_ids only accepts 2D and 3D input\"", ")", "\n", "\n", "", "return", "tensor_with_boundary_tokens", ",", "new_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.remove_sentence_boundaries": [[1568, 1609], ["mask.sum().detach().cpu().numpy", "list", "list", "tensor.new_zeros", "tensor.new_zeros", "enumerate", "mask.sum().detach().cpu", "mask.sum().detach", "mask.sum"], "function", ["None"], ["", "def", "remove_sentence_boundaries", "(", "\n", "tensor", ":", "torch", ".", "Tensor", ",", "mask", ":", "torch", ".", "BoolTensor", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Remove begin/end of sentence embeddings from the batch of sentences.\n    Given a batch of sentences with size `(batch_size, timesteps, dim)`\n    this returns a tensor of shape `(batch_size, timesteps - 2, dim)` after removing\n    the beginning and end sentence markers.  The sentences are assumed to be padded on the right,\n    with the beginning of each sentence assumed to occur at index 0 (i.e., `mask[:, 0]` is assumed\n    to be 1).\n\n    Returns both the new tensor and updated mask.\n\n    This function is the inverse of `add_sentence_boundary_token_ids`.\n\n    # Parameters\n\n    tensor : `torch.Tensor`\n        A tensor of shape `(batch_size, timesteps, dim)`\n    mask : `torch.BoolTensor`\n         A tensor of shape `(batch_size, timesteps)`\n\n    # Returns\n\n    tensor_without_boundary_tokens : `torch.Tensor`\n        The tensor after removing the boundary tokens of shape `(batch_size, timesteps - 2, dim)`\n    new_mask : `torch.BoolTensor`\n        The new mask for the tensor of shape `(batch_size, timesteps - 2)`.\n    \"\"\"", "\n", "sequence_lengths", "=", "mask", ".", "sum", "(", "dim", "=", "1", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "tensor_shape", "=", "list", "(", "tensor", ".", "data", ".", "shape", ")", "\n", "new_shape", "=", "list", "(", "tensor_shape", ")", "\n", "new_shape", "[", "1", "]", "=", "tensor_shape", "[", "1", "]", "-", "2", "\n", "tensor_without_boundary_tokens", "=", "tensor", ".", "new_zeros", "(", "*", "new_shape", ")", "\n", "new_mask", "=", "tensor", ".", "new_zeros", "(", "(", "new_shape", "[", "0", "]", ",", "new_shape", "[", "1", "]", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "sequence_lengths", ")", ":", "\n", "        ", "if", "j", ">", "2", ":", "\n", "            ", "tensor_without_boundary_tokens", "[", "i", ",", ":", "(", "j", "-", "2", ")", ",", ":", "]", "=", "tensor", "[", "i", ",", "1", ":", "(", "j", "-", "1", ")", ",", ":", "]", "\n", "new_mask", "[", "i", ",", ":", "(", "j", "-", "2", ")", "]", "=", "True", "\n", "\n", "", "", "return", "tensor_without_boundary_tokens", ",", "new_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.add_positional_features": [[1611, 1667], ["tensor.size", "get_range_vector().data.float", "get_range_vector().data.float", "torch.cat", "torch.cat", "math.log", "float", "torch.exp", "torch.exp", "get_range_vector().data.float.unsqueeze", "inverse_timescales.unsqueeze", "torch.cat", "torch.cat", "torch.cat.unsqueeze", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "nn_util.get_range_vector", "nn_util.get_range_vector", "float", "float", "torch.cat.new_zeros", "nn_util.get_device_of", "nn_util.get_device_of"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_range_vector", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_device_of"], ["", "def", "add_positional_features", "(", "\n", "tensor", ":", "torch", ".", "Tensor", ",", "min_timescale", ":", "float", "=", "1.0", ",", "max_timescale", ":", "float", "=", "1.0e4", "\n", ")", ":", "\n", "\n", "    ", "\"\"\"\n    Implements the frequency-based positional encoding described\n    in [Attention is All you Need][0].\n\n    Adds sinusoids of different frequencies to a `Tensor`. A sinusoid of a\n    different frequency and phase is added to each dimension of the input `Tensor`.\n    This allows the attention heads to use absolute and relative positions.\n\n    The number of timescales is equal to hidden_dim / 2 within the range\n    (min_timescale, max_timescale). For each timescale, the two sinusoidal\n    signals sin(timestep / timescale) and cos(timestep / timescale) are\n    generated and concatenated along the hidden_dim dimension.\n\n    [0]: https://www.semanticscholar.org/paper/Attention-Is-All-You-Need-Vaswani-Shazeer/0737da0767d77606169cbf4187b83e1ab62f6077\n\n    # Parameters\n\n    tensor : `torch.Tensor`\n        a Tensor with shape (batch_size, timesteps, hidden_dim).\n    min_timescale : `float`, optional (default = `1.0`)\n        The smallest timescale to use.\n    max_timescale : `float`, optional (default = `1.0e4`)\n        The largest timescale to use.\n\n    # Returns\n\n    `torch.Tensor`\n        The input tensor augmented with the sinusoidal frequencies.\n    \"\"\"", "# noqa", "\n", "_", ",", "timesteps", ",", "hidden_dim", "=", "tensor", ".", "size", "(", ")", "\n", "\n", "timestep_range", "=", "get_range_vector", "(", "timesteps", ",", "get_device_of", "(", "tensor", ")", ")", ".", "data", ".", "float", "(", ")", "\n", "# We're generating both cos and sin frequencies,", "\n", "# so half for each.", "\n", "num_timescales", "=", "hidden_dim", "//", "2", "\n", "timescale_range", "=", "get_range_vector", "(", "num_timescales", ",", "get_device_of", "(", "tensor", ")", ")", ".", "data", ".", "float", "(", ")", "\n", "\n", "log_timescale_increments", "=", "math", ".", "log", "(", "float", "(", "max_timescale", ")", "/", "float", "(", "min_timescale", ")", ")", "/", "float", "(", "\n", "num_timescales", "-", "1", "\n", ")", "\n", "inverse_timescales", "=", "min_timescale", "*", "torch", ".", "exp", "(", "timescale_range", "*", "-", "log_timescale_increments", ")", "\n", "\n", "# Broadcasted multiplication - shape (timesteps, num_timescales)", "\n", "scaled_time", "=", "timestep_range", ".", "unsqueeze", "(", "1", ")", "*", "inverse_timescales", ".", "unsqueeze", "(", "0", ")", "\n", "# shape (timesteps, 2 * num_timescales)", "\n", "sinusoids", "=", "torch", ".", "cat", "(", "[", "torch", ".", "sin", "(", "scaled_time", ")", ",", "torch", ".", "cos", "(", "scaled_time", ")", "]", ",", "1", ")", "\n", "if", "hidden_dim", "%", "2", "!=", "0", ":", "\n", "# if the number of dimensions is odd, the cos and sin", "\n", "# timescales had size (hidden_dim - 1) / 2, so we need", "\n", "# to add a row of zeros to make up the difference.", "\n", "        ", "sinusoids", "=", "torch", ".", "cat", "(", "[", "sinusoids", ",", "sinusoids", ".", "new_zeros", "(", "timesteps", ",", "1", ")", "]", ",", "1", ")", "\n", "", "return", "tensor", "+", "sinusoids", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.clone": [[1669, 1672], ["torch.nn.ModuleList", "torch.nn.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["", "def", "clone", "(", "module", ":", "torch", ".", "nn", ".", "Module", ",", "num_copies", ":", "int", ")", "->", "torch", ".", "nn", ".", "ModuleList", ":", "\n", "    ", "\"\"\"Produce N identical layers.\"\"\"", "\n", "return", "torch", ".", "nn", ".", "ModuleList", "(", "copy", ".", "deepcopy", "(", "module", ")", "for", "_", "in", "range", "(", "num_copies", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.combine_initial_dims": [[1674, 1685], ["tensor.dim", "tensor.view", "tensor.size"], "function", ["None"], ["", "def", "combine_initial_dims", "(", "tensor", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given a (possibly higher order) tensor of ids with shape\n    (d1, ..., dn, sequence_length)\n    Return a view that's (d1 * ... * dn, sequence_length).\n    If original tensor is 1-d or 2-d, return it as is.\n    \"\"\"", "\n", "if", "tensor", ".", "dim", "(", ")", "<=", "2", ":", "\n", "        ", "return", "tensor", "\n", "", "else", ":", "\n", "        ", "return", "tensor", ".", "view", "(", "-", "1", ",", "tensor", ".", "size", "(", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.uncombine_initial_dims": [[1687, 1702], ["len", "tensor.view", "list", "tensor.size"], "function", ["None"], ["", "", "def", "uncombine_initial_dims", "(", "tensor", ":", "torch", ".", "Tensor", ",", "original_size", ":", "torch", ".", "Size", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given a tensor of embeddings with shape\n    (d1 * ... * dn, sequence_length, embedding_dim)\n    and the original shape\n    (d1, ..., dn, sequence_length),\n    return the reshaped tensor of embeddings with shape\n    (d1, ..., dn, sequence_length, embedding_dim).\n    If original size is 1-d or 2-d, return it as is.\n    \"\"\"", "\n", "if", "len", "(", "original_size", ")", "<=", "2", ":", "\n", "        ", "return", "tensor", "\n", "", "else", ":", "\n", "        ", "view_args", "=", "list", "(", "original_size", ")", "+", "[", "tensor", ".", "size", "(", "-", "1", ")", "]", "\n", "return", "tensor", ".", "view", "(", "*", "view_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.inspect_parameters": [[1704, 1736], ["sorted", "module.named_parameters", "name.split", "print", "json.dumps"], "function", ["home.repos.pwc.inspect_result.mslars_mare.dataset_readers.document.Document.split"], ["", "", "def", "inspect_parameters", "(", "module", ":", "torch", ".", "nn", ".", "Module", ",", "quiet", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Inspects the model/module parameters and their tunability. The output is structured\n    in a nested dict so that parameters in same sub-modules are grouped together.\n    This can be helpful to setup module path based regex, for example in initializer.\n    It prints it by default (optional) and returns the inspection dict. Eg. output::\n\n        {\n            \"_text_field_embedder\": {\n                \"token_embedder_tokens\": {\n                    \"_projection\": {\n                        \"bias\": \"tunable\",\n                        \"weight\": \"tunable\"\n                    },\n                    \"weight\": \"frozen\"\n                }\n            }\n        }\n\n    \"\"\"", "\n", "results", ":", "Dict", "[", "str", ",", "Any", "]", "=", "{", "}", "\n", "for", "name", ",", "param", "in", "sorted", "(", "module", ".", "named_parameters", "(", ")", ")", ":", "\n", "        ", "keys", "=", "name", ".", "split", "(", "\".\"", ")", "\n", "write_to", "=", "results", "\n", "for", "key", "in", "keys", "[", ":", "-", "1", "]", ":", "\n", "            ", "if", "key", "not", "in", "write_to", ":", "\n", "                ", "write_to", "[", "key", "]", "=", "{", "}", "\n", "", "write_to", "=", "write_to", "[", "key", "]", "\n", "", "write_to", "[", "keys", "[", "-", "1", "]", "]", "=", "\"tunable\"", "if", "param", ".", "requires_grad", "else", "\"frozen\"", "\n", "", "if", "not", "quiet", ":", "\n", "        ", "print", "(", "json", ".", "dumps", "(", "results", ",", "indent", "=", "4", ")", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.find_text_field_embedder": [[1738, 1750], ["model.modules", "ValueError", "isinstance"], "function", ["None"], ["", "def", "find_text_field_embedder", "(", "model", ":", "torch", ".", "nn", ".", "Module", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"\n    Takes a `Model` and returns the `Module` that is a `TextFieldEmbedder`.  We return just the\n    first one, as it's very rare to have more than one.  If there isn't a `TextFieldEmbedder` in the\n    given `Model`, we raise a `ValueError`.\n    \"\"\"", "\n", "from", "allennlp", ".", "modules", ".", "text_field_embedders", ".", "text_field_embedder", "import", "TextFieldEmbedder", "\n", "\n", "for", "module", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "TextFieldEmbedder", ")", ":", "\n", "            ", "return", "module", "\n", "", "", "raise", "ValueError", "(", "\"Couldn't find TextFieldEmbedder!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.find_embedding_layer": [[1752, 1799], ["model.modules", "model.modules", "RuntimeError", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "len", "isinstance", "list", "module._token_embedders.values"], "function", ["None"], ["", "def", "find_embedding_layer", "(", "model", ":", "torch", ".", "nn", ".", "Module", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"\n    Takes a model (typically an AllenNLP `Model`, but this works for any `torch.nn.Module`) and\n    makes a best guess about which module is the embedding layer.  For typical AllenNLP models,\n    this often is the `TextFieldEmbedder`, but if you're using a pre-trained contextualizer, we\n    really want layer 0 of that contextualizer, not the output.  So there are a bunch of hacks in\n    here for specific pre-trained contextualizers.\n    \"\"\"", "\n", "# We'll look for a few special cases in a first pass, then fall back to just finding a", "\n", "# TextFieldEmbedder in a second pass if we didn't find a special case.", "\n", "from", "transformers", ".", "models", ".", "gpt2", ".", "modeling_gpt2", "import", "GPT2Model", "\n", "from", "transformers", ".", "models", ".", "bert", ".", "modeling_bert", "import", "BertEmbeddings", "\n", "from", "transformers", ".", "models", ".", "albert", ".", "modeling_albert", "import", "AlbertEmbeddings", "\n", "from", "transformers", ".", "models", ".", "roberta", ".", "modeling_roberta", "import", "RobertaEmbeddings", "\n", "from", "allennlp", ".", "modules", ".", "text_field_embedders", ".", "text_field_embedder", "import", "TextFieldEmbedder", "\n", "from", "allennlp", ".", "modules", ".", "text_field_embedders", ".", "basic_text_field_embedder", "import", "(", "\n", "BasicTextFieldEmbedder", ",", "\n", ")", "\n", "from", "allennlp", ".", "modules", ".", "token_embedders", ".", "embedding", "import", "Embedding", "\n", "\n", "for", "module", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "BertEmbeddings", ")", ":", "\n", "            ", "return", "module", ".", "word_embeddings", "\n", "", "if", "isinstance", "(", "module", ",", "RobertaEmbeddings", ")", ":", "\n", "            ", "return", "module", ".", "word_embeddings", "\n", "", "if", "isinstance", "(", "module", ",", "AlbertEmbeddings", ")", ":", "\n", "            ", "return", "module", ".", "word_embeddings", "\n", "", "if", "isinstance", "(", "module", ",", "GPT2Model", ")", ":", "\n", "            ", "return", "module", ".", "wte", "\n", "\n", "", "", "for", "module", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "TextFieldEmbedder", ")", ":", "\n", "\n", "            ", "if", "isinstance", "(", "module", ",", "BasicTextFieldEmbedder", ")", ":", "\n", "# We'll have a check for single Embedding cases, because we can be more efficient", "\n", "# in cases like this.  If this check fails, then for something like hotflip we need", "\n", "# to actually run the text field embedder and construct a vector for each token.", "\n", "                ", "if", "len", "(", "module", ".", "_token_embedders", ")", "==", "1", ":", "\n", "                    ", "embedder", "=", "list", "(", "module", ".", "_token_embedders", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "if", "isinstance", "(", "embedder", ",", "Embedding", ")", ":", "\n", "                        ", "if", "embedder", ".", "_projection", "is", "None", ":", "\n", "# If there's a projection inside the Embedding, then we need to return", "\n", "# the whole TextFieldEmbedder, because there's more computation that", "\n", "# needs to be done than just multiply by an embedding matrix.", "\n", "                            ", "return", "embedder", "\n", "", "", "", "", "return", "module", "\n", "", "", "raise", "RuntimeError", "(", "\"No embedding module found!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_token_offsets_from_text_field_inputs": [[1801, 1826], ["enumerate", "text_field_input.values", "isinstance", "input_value.items", "isinstance"], "function", ["None"], ["", "def", "get_token_offsets_from_text_field_inputs", "(", "\n", "text_field_inputs", ":", "List", "[", "Any", "]", ",", "\n", ")", "->", "Optional", "[", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Given a list of inputs to a TextFieldEmbedder, tries to find token offsets from those inputs, if\n    there are any.  You will have token offsets if you are using a mismatched token embedder; if\n    you're not, the return value from this function should be None.  This function is intended to be\n    called from a `forward_hook` attached to a `TextFieldEmbedder`, so the inputs are formatted just\n    as a list.\n\n    It's possible in theory that you could have multiple offsets as inputs to a single call to a\n    `TextFieldEmbedder`, but that's an extremely rare use case (I can't really imagine anyone\n    wanting to do that).  In that case, we'll only return the first one.  If you need different\n    behavior for your model, open an issue on github describing what you're doing.\n    \"\"\"", "\n", "for", "input_index", ",", "text_field_input", "in", "enumerate", "(", "text_field_inputs", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "text_field_input", ",", "dict", ")", ":", "\n", "            ", "continue", "\n", "", "for", "input_value", "in", "text_field_input", ".", "values", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "input_value", ",", "dict", ")", ":", "\n", "                ", "continue", "\n", "", "for", "embedder_arg_name", ",", "embedder_arg_value", "in", "input_value", ".", "items", "(", ")", ":", "\n", "                ", "if", "embedder_arg_name", "==", "\"offsets\"", ":", "\n", "                    ", "return", "embedder_arg_value", "\n", "", "", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.extend_layer": [[1828, 1856], ["isinstance", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.zeros_", "torch.nn.init.zeros_", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "any", "allennlp.common.checks.ConfigurationError", "torch.FloatTensor", "torch.FloatTensor", "isinstance", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.FloatTensor", "torch.FloatTensor", "isinstance", "torch.FloatTensor.to", "torch.FloatTensor.to"], "function", ["None"], ["", "def", "extend_layer", "(", "layer", ":", "torch", ".", "nn", ".", "Module", ",", "new_dim", ":", "int", ")", "->", "None", ":", "\n", "    ", "valid_layers", "=", "[", "torch", ".", "nn", ".", "Linear", ",", "torch", ".", "nn", ".", "Bilinear", "]", "\n", "if", "not", "any", "(", "[", "isinstance", "(", "layer", ",", "i", ")", "for", "i", "in", "valid_layers", "]", ")", ":", "\n", "        ", "raise", "ConfigurationError", "(", "\"Inappropriate layer type\"", ")", "\n", "\n", "", "extend_dim", "=", "new_dim", "-", "layer", ".", "out_features", "\n", "if", "not", "extend_dim", ":", "\n", "        ", "return", "layer", "\n", "\n", "", "if", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "Linear", ")", ":", "\n", "        ", "new_weight", "=", "torch", ".", "FloatTensor", "(", "extend_dim", ",", "layer", ".", "in_features", ")", "\n", "", "elif", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "Bilinear", ")", ":", "\n", "        ", "new_weight", "=", "torch", ".", "FloatTensor", "(", "extend_dim", ",", "layer", ".", "in1_features", ",", "layer", ".", "in2_features", ")", "\n", "\n", "", "new_bias", "=", "torch", ".", "FloatTensor", "(", "extend_dim", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "new_weight", ")", "\n", "torch", ".", "nn", ".", "init", ".", "zeros_", "(", "new_bias", ")", "\n", "\n", "device", "=", "layer", ".", "weight", ".", "device", "\n", "layer", ".", "weight", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "cat", "(", "[", "layer", ".", "weight", ".", "data", ",", "new_weight", ".", "to", "(", "device", ")", "]", ",", "dim", "=", "0", ")", ",", "\n", "requires_grad", "=", "layer", ".", "weight", ".", "requires_grad", ",", "\n", ")", "\n", "layer", ".", "bias", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "cat", "(", "[", "layer", ".", "bias", ".", "data", ",", "new_bias", ".", "to", "(", "device", ")", "]", ",", "dim", "=", "0", ")", ",", "\n", "requires_grad", "=", "layer", ".", "bias", ".", "requires_grad", ",", "\n", ")", "\n", "layer", ".", "out_features", "=", "new_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.masked_topk": [[1858, 1973], ["list", "list.pop", "list", "list.insert", "list", "list.pop", "isinstance", "replace_masked_values.size", "replace_masked_values.permute().reshape", "mask.permute().reshape.permute().reshape", "k.reshape.reshape", "nn_util.replace_masked_values", "replace_masked_values.topk", "get_mask_from_sequence_lengths().bool", "torch.where.max", "torch.where", "torch.where", "torch.where.sort", "mask.permute().reshape.gather", "replace_masked_values.gather", "replace_masked_values.size", "mask.permute().reshape.size", "ValueError", "ValueError", "replace_masked_values.dim", "isinstance", "k.reshape.max", "range", "range", "replace_masked_values.size", "nn_util.min_value_of_dtype", "input_.gather.reshape().permute", "top_mask.reshape().permute", "torch.where.reshape().permute", "replace_masked_values.dim", "replace_masked_values.dim", "replace_masked_values.dim", "torch.ones", "torch.ones", "list", "ValueError", "replace_masked_values.permute", "mask.permute().reshape.permute", "nn_util.get_mask_from_sequence_lengths", "replace_masked_values.dim", "replace_masked_values.dim", "k.reshape.size", "input_.gather.reshape", "top_mask.reshape", "torch.where.reshape"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.replace_masked_values", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.min_value_of_dtype", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.get_mask_from_sequence_lengths"], ["", "def", "masked_topk", "(", "\n", "input_", ":", "torch", ".", "FloatTensor", ",", "\n", "mask", ":", "torch", ".", "BoolTensor", ",", "\n", "k", ":", "Union", "[", "int", ",", "torch", ".", "LongTensor", "]", ",", "\n", "dim", ":", "int", "=", "-", "1", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "LongTensor", ",", "torch", ".", "LongTensor", ",", "torch", ".", "FloatTensor", "]", ":", "\n", "    ", "\"\"\"\n    Extracts the top-k items along a certain dimension. This is similar to `torch.topk` except:\n    (1) we allow of a `mask` that makes the function not consider certain elements;\n    (2) the returned top input, mask, and indices are sorted in their original order in the input;\n    (3) May use the same k for all dimensions, or different k for each.\n\n    # Parameters\n\n    input_ : `torch.FloatTensor`, required.\n        A tensor containing the items that we want to prune.\n    mask : `torch.BoolTensor`, required.\n        A tensor with the same shape as `input_` that makes the function not consider masked out\n        (i.e. False) elements.\n    k : `Union[int, torch.LongTensor]`, required.\n        If a tensor of shape as `input_` except without dimension `dim`, specifies the number of\n        items to keep for each dimension.\n        If an int, keep the same number of items for all dimensions.\n\n    # Returns\n\n    top_input : `torch.FloatTensor`\n        The values of the top-k scoring items.\n        Has the same shape as `input_` except dimension `dim` has value `k` when it's an `int`\n        or `k.max()` when it's a tensor.\n    top_mask : `torch.BoolTensor`\n        The corresponding mask for `top_input`.\n        Has the shape as `top_input`.\n    top_indices : `torch.IntTensor`\n        The indices of the top-k scoring items into the original `input_`\n        tensor. This is returned because it can be useful to retain pointers to\n        the original items, if each item is being scored by multiple distinct\n        scorers, for instance.\n        Has the shape as `top_input`.\n    \"\"\"", "\n", "if", "input_", ".", "size", "(", ")", "!=", "mask", ".", "size", "(", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"`input_` and `mask` must have the same shape.\"", ")", "\n", "", "if", "not", "-", "input_", ".", "dim", "(", ")", "<=", "dim", "<", "input_", ".", "dim", "(", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"`dim` must be in `[-input_.dim(), input_.dim())`\"", ")", "\n", "", "dim", "=", "(", "dim", "+", "input_", ".", "dim", "(", ")", ")", "%", "input_", ".", "dim", "(", ")", "\n", "\n", "max_k", "=", "k", "if", "isinstance", "(", "k", ",", "int", ")", "else", "k", ".", "max", "(", ")", "\n", "\n", "# We put the dim in question to the last dimension by permutation, and squash all leading dims.", "\n", "\n", "# [0, 1, ..., dim - 1, dim + 1, ..., input.dim() - 1, dim]", "\n", "permutation", "=", "list", "(", "range", "(", "input_", ".", "dim", "(", ")", ")", ")", "\n", "permutation", ".", "pop", "(", "dim", ")", "\n", "permutation", "+=", "[", "dim", "]", "\n", "\n", "# [0, 1, ..., dim - 1, -1, dim, ..., input.dim() - 2]; for restoration", "\n", "reverse_permutation", "=", "list", "(", "range", "(", "input_", ".", "dim", "(", ")", "-", "1", ")", ")", "\n", "reverse_permutation", ".", "insert", "(", "dim", ",", "-", "1", ")", "\n", "\n", "other_dims_size", "=", "list", "(", "input_", ".", "size", "(", ")", ")", "\n", "other_dims_size", ".", "pop", "(", "dim", ")", "\n", "permuted_size", "=", "other_dims_size", "+", "[", "max_k", "]", "# for restoration", "\n", "\n", "# If an int was given for number of items to keep, construct tensor by repeating the value.", "\n", "if", "isinstance", "(", "k", ",", "int", ")", ":", "\n", "# Put the tensor on same device as the mask.", "\n", "        ", "k", "=", "k", "*", "torch", ".", "ones", "(", "*", "other_dims_size", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "mask", ".", "device", ")", "\n", "", "else", ":", "\n", "        ", "if", "list", "(", "k", ".", "size", "(", ")", ")", "!=", "other_dims_size", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`k` must have the same shape as `input_` with dimension `dim` removed.\"", "\n", ")", "\n", "\n", "", "", "num_items", "=", "input_", ".", "size", "(", "dim", ")", "\n", "# (batch_size, num_items)  -- \"batch_size\" refers to all other dimensions stacked together", "\n", "input_", "=", "input_", ".", "permute", "(", "*", "permutation", ")", ".", "reshape", "(", "-", "1", ",", "num_items", ")", "\n", "mask", "=", "mask", ".", "permute", "(", "*", "permutation", ")", ".", "reshape", "(", "-", "1", ",", "num_items", ")", "\n", "k", "=", "k", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# Make sure that we don't select any masked items by setting their scores to be very", "\n", "# negative.", "\n", "input_", "=", "replace_masked_values", "(", "input_", ",", "mask", ",", "min_value_of_dtype", "(", "input_", ".", "dtype", ")", ")", "\n", "\n", "# Shape: (batch_size, max_k)", "\n", "_", ",", "top_indices", "=", "input_", ".", "topk", "(", "max_k", ",", "1", ")", "\n", "\n", "# Mask based on number of items to keep for each sentence.", "\n", "# Shape: (batch_size, max_k)", "\n", "top_indices_mask", "=", "get_mask_from_sequence_lengths", "(", "k", ",", "max_k", ")", ".", "bool", "(", ")", "\n", "\n", "# Fill all masked indices with largest \"top\" index for that sentence, so that all masked", "\n", "# indices will be sorted to the end.", "\n", "# Shape: (batch_size, 1)", "\n", "fill_value", ",", "_", "=", "top_indices", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "# Shape: (batch_size, max_num_items_to_keep)", "\n", "top_indices", "=", "torch", ".", "where", "(", "top_indices_mask", ",", "top_indices", ",", "fill_value", ")", "\n", "\n", "# Now we order the selected indices in increasing order with", "\n", "# respect to their indices (and hence, with respect to the", "\n", "# order they originally appeared in the `embeddings` tensor).", "\n", "top_indices", ",", "_", "=", "top_indices", ".", "sort", "(", "1", ")", "\n", "\n", "# Combine the masks on spans that are out-of-bounds, and the mask on spans that are outside", "\n", "# the top k for each sentence.", "\n", "# Shape: (batch_size, max_k)", "\n", "sequence_mask", "=", "mask", ".", "gather", "(", "1", ",", "top_indices", ")", "\n", "top_mask", "=", "top_indices_mask", "&", "sequence_mask", "\n", "\n", "# Shape: (batch_size, max_k)", "\n", "top_input", "=", "input_", ".", "gather", "(", "1", ",", "top_indices", ")", "\n", "\n", "return", "(", "\n", "top_input", ".", "reshape", "(", "*", "permuted_size", ")", ".", "permute", "(", "*", "reverse_permutation", ")", ",", "\n", "top_mask", ".", "reshape", "(", "*", "permuted_size", ")", ".", "permute", "(", "*", "reverse_permutation", ")", ",", "\n", "top_indices", ".", "reshape", "(", "*", "permuted_size", ")", ".", "permute", "(", "*", "reverse_permutation", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.info_value_of_dtype": [[1976, 1986], ["TypeError", "torch.finfo", "torch.finfo", "torch.iinfo", "torch.iinfo"], "function", ["None"], ["", "def", "info_value_of_dtype", "(", "dtype", ":", "torch", ".", "dtype", ")", ":", "\n", "    ", "\"\"\"\n    Returns the `finfo` or `iinfo` object of a given PyTorch data type. Does not allow torch.bool.\n    \"\"\"", "\n", "if", "dtype", "==", "torch", ".", "bool", ":", "\n", "        ", "raise", "TypeError", "(", "\"Does not support torch.bool\"", ")", "\n", "", "elif", "dtype", ".", "is_floating_point", ":", "\n", "        ", "return", "torch", ".", "finfo", "(", "dtype", ")", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "iinfo", "(", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.min_value_of_dtype": [[1988, 1993], ["nn_util.info_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.info_value_of_dtype"], ["", "", "def", "min_value_of_dtype", "(", "dtype", ":", "torch", ".", "dtype", ")", ":", "\n", "    ", "\"\"\"\n    Returns the minimum value of a given PyTorch data type. Does not allow torch.bool.\n    \"\"\"", "\n", "return", "info_value_of_dtype", "(", "dtype", ")", ".", "min", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.max_value_of_dtype": [[1995, 2000], ["nn_util.info_value_of_dtype"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.info_value_of_dtype"], ["", "def", "max_value_of_dtype", "(", "dtype", ":", "torch", ".", "dtype", ")", ":", "\n", "    ", "\"\"\"\n    Returns the maximum value of a given PyTorch data type. Does not allow torch.bool.\n    \"\"\"", "\n", "return", "info_value_of_dtype", "(", "dtype", ")", ".", "max", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.tiny_value_of_dtype": [[2002, 2017], ["TypeError", "TypeError", "str", "torch.float", "torch.float"], "function", ["None"], ["", "def", "tiny_value_of_dtype", "(", "dtype", ":", "torch", ".", "dtype", ")", ":", "\n", "    ", "\"\"\"\n    Returns a moderately tiny value for a given PyTorch data type that is used to avoid numerical\n    issues such as division by zero.\n    This is different from `info_value_of_dtype(dtype).tiny` because it causes some NaN bugs.\n    Only supports floating point dtypes.\n    \"\"\"", "\n", "if", "not", "dtype", ".", "is_floating_point", ":", "\n", "        ", "raise", "TypeError", "(", "\"Only supports floating point dtypes.\"", ")", "\n", "", "if", "dtype", "==", "torch", ".", "float", "or", "dtype", "==", "torch", ".", "double", ":", "\n", "        ", "return", "1e-13", "\n", "", "elif", "dtype", "==", "torch", ".", "half", ":", "\n", "        ", "return", "1e-4", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\"Does not support dtype \"", "+", "str", "(", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce": [[2022, 2053], ["allennlp.common.util.int_to_device", "torch.tensor", "torch.tensor", "torch.all_reduce", "isinstance", "torch.tensor.item", "allennlp.common.util.is_distributed", "torch.cuda.current_device", "torch.cuda.current_device", "torch.get_backend", "torch.dist.ReduceOp.SUM"], "function", ["None"], ["def", "dist_reduce", "(", "value", ":", "_V", ",", "reduce_op", ",", "**", "kwargs", ")", "->", "_V", ":", "\n", "    ", "\"\"\"\n    Reduces the given `value` across all distributed worker nodes according the given\n    reduction operation.\n\n    If called outside of a distributed context, it will just return `value`.\n\n    # Parameters\n\n    value : `_V`\n        The value to reduce across distributed nodes.\n    reduce_op : `torch.distributed.ReduceOp`\n        The [reduction operation](https://pytorch.org/docs/stable/distributed.html#torch.distributed.ReduceOp)\n        to use.\n    **kwargs : `Any`\n        Additional arguments used to construct the tensor that will wrap `value`.\n\n    # Returns\n\n    `_V`\n        The final value.\n    \"\"\"", "\n", "if", "not", "is_distributed", "(", ")", ":", "\n", "        ", "return", "value", "\n", "", "device", "=", "int_to_device", "(", "-", "1", "if", "dist", ".", "get_backend", "(", ")", "!=", "\"nccl\"", "else", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "value_tensor", "=", "torch", ".", "tensor", "(", "value", ",", "device", "=", "device", ",", "**", "kwargs", ")", "\n", "dist", ".", "all_reduce", "(", "value_tensor", ",", "op", "=", "reduce_op", ")", "\n", "\n", "if", "isinstance", "(", "value", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "value_tensor", "\n", "", "return", "value_tensor", ".", "item", "(", ")", "# type: ignore[return-value]", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum": [[2055, 2069], ["nn_util.dist_reduce", "allennlp.common.util.is_distributed"], "function", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce"], ["", "def", "dist_reduce_sum", "(", "value", ":", "_V", ",", "**", "kwargs", ")", "->", "_V", ":", "\n", "    ", "\"\"\"\n    Sums the given `value` across distributed worker nodes.\n    This is equivalent to calling `dist_reduce(v, dist.ReduceOp.SUM)`.\n    \"\"\"", "\n", "# NOTE: Why have this check here even though the same check is in `dist_reduce()`?", "\n", "# Because we want to be able to call this function even when torch's distributed framework", "\n", "# is not available...", "\n", "# If torch's distributed framework is not available on the system, then `torch.distributed`", "\n", "# (imported here as `dist`) will just be an empty module. So calling `dist.ReduceOp.SUM` would", "\n", "# result in an `AttributeError`.", "\n", "if", "not", "is_distributed", "(", ")", ":", "\n", "        ", "return", "value", "\n", "", "return", "dist_reduce", "(", "value", ",", "dist", ".", "ReduceOp", ".", "SUM", ",", "**", "kwargs", ")", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_multi.FBetaMultiLabelMeasure.__init__": [[67, 76], ["allennlp.training.metrics.FBetaMeasure.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "beta", ":", "float", "=", "1.0", ",", "\n", "average", ":", "str", "=", "None", ",", "\n", "labels", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "threshold", ":", "float", "=", "0.5", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "beta", ",", "average", ",", "labels", ")", "\n", "self", ".", "_threshold", "=", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_multi.FBetaMultiLabelMeasure.__call__": [[77, 152], ["fbeta_multi.FBetaMultiLabelMeasure.detach_tensors", "predictions.size", "gold_labels.float.float.float", "torch.arange().unsqueeze().repeat", "torch.ones_like.expand_as().sum().to", "spart.metrics.nn_util.dist_reduce_sum", "spart.metrics.nn_util.dist_reduce_sum", "spart.metrics.nn_util.dist_reduce_sum", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones_like", "gold_labels.float.float.size", "torch.zeros", "torch.bincount().float", "torch.bincount().float", "torch.zeros", "torch.bincount().float", "torch.zeros", "torch.arange().unsqueeze", "torch.ones_like.expand_as().sum", "predictions.sum", "torch.bincount", "torch.bincount", "gold_labels.float.float.bool", "torch.bincount", "torch.arange", "true_positives_bins.long", "threshold_predictions.bool", "torch.ones_like.expand_as"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum"], ["", "@", "overrides", "\n", "def", "__call__", "(", "\n", "self", ",", "\n", "predictions", ":", "torch", ".", "Tensor", ",", "\n", "gold_labels", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "Optional", "[", "torch", ".", "BoolTensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        # Parameters\n\n        predictions : `torch.Tensor`, required.\n            A tensor of predictions of shape (batch_size, ..., num_classes).\n        gold_labels : `torch.Tensor`, required.\n            A tensor of boolean labels of shape (batch_size, ..., num_classes). It must be the same\n            shape as the `predictions`.\n        mask : `torch.BoolTensor`, optional (default = `None`).\n            A masking tensor the same size as `gold_labels`.\n        \"\"\"", "\n", "predictions", ",", "gold_labels", ",", "mask", "=", "self", ".", "detach_tensors", "(", "predictions", ",", "gold_labels", ",", "mask", ")", "\n", "\n", "# Calculate true_positive_sum, true_negative_sum, pred_sum, true_sum", "\n", "num_classes", "=", "predictions", ".", "size", "(", "-", "1", ")", "\n", "\n", "# It means we call this metric at the first time", "\n", "# when `self._true_positive_sum` is None.", "\n", "if", "self", ".", "_true_positive_sum", "is", "None", ":", "\n", "            ", "self", ".", "_true_positive_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_true_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_pred_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_total_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "ones_like", "(", "gold_labels", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "", "gold_labels", "=", "gold_labels", ".", "float", "(", ")", "\n", "\n", "# If the prediction tensor is all zeros, the record is not classified to any of the labels.", "\n", "pred_mask", "=", "(", "predictions", ".", "sum", "(", "dim", "=", "-", "1", ")", "!=", "0", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "threshold_predictions", "=", "(", "predictions", ">=", "self", ".", "_threshold", ")", ".", "float", "(", ")", "\n", "\n", "class_indices", "=", "(", "\n", "torch", ".", "arange", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", ".", "unsqueeze", "(", "0", ")", "\n", ".", "repeat", "(", "gold_labels", ".", "size", "(", "0", ")", ",", "1", ")", "\n", ")", "\n", "true_positives", "=", "(", "gold_labels", "*", "threshold_predictions", ")", ".", "bool", "(", ")", "&", "mask", "&", "pred_mask", "\n", "true_positives_bins", "=", "class_indices", "[", "true_positives", "]", "\n", "\n", "# Watch it:", "\n", "# The total numbers of true positives under all _predicted_ classes are zeros.", "\n", "if", "true_positives_bins", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "true_positive_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "true_positive_sum", "=", "torch", ".", "bincount", "(", "\n", "true_positives_bins", ".", "long", "(", ")", ",", "minlength", "=", "num_classes", "\n", ")", ".", "float", "(", ")", "\n", "\n", "", "pred_bins", "=", "class_indices", "[", "threshold_predictions", ".", "bool", "(", ")", "&", "mask", "&", "pred_mask", "]", "\n", "# Watch it:", "\n", "# When the `mask` is all 0, we will get an _empty_ tensor.", "\n", "if", "pred_bins", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "pred_sum", "=", "torch", ".", "bincount", "(", "pred_bins", ",", "minlength", "=", "num_classes", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "pred_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "gold_labels_bins", "=", "class_indices", "[", "gold_labels", ".", "bool", "(", ")", "&", "mask", "]", "\n", "if", "gold_labels_bins", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "true_sum", "=", "torch", ".", "bincount", "(", "gold_labels_bins", ",", "minlength", "=", "num_classes", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "true_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "self", ".", "_total_sum", "+=", "mask", ".", "expand_as", "(", "gold_labels", ")", ".", "sum", "(", ")", ".", "to", "(", "torch", ".", "float", ")", "\n", "\n", "self", ".", "_true_positive_sum", "+=", "dist_reduce_sum", "(", "true_positive_sum", ")", "\n", "self", ".", "_pred_sum", "+=", "dist_reduce_sum", "(", "pred_sum", ")", "\n", "self", ".", "_true_sum", "+=", "dist_reduce_sum", "(", "true_sum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_multi.FBetaMultiLabelMeasure._true_negative_sum": [[153, 165], ["fbeta_multi.FBetaMultiLabelMeasure._true_positive_sum.size"], "methods", ["None"], ["", "@", "property", "\n", "def", "_true_negative_sum", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_total_sum", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "true_negative_sum", "=", "(", "\n", "self", ".", "_total_sum", "[", "0", "]", "/", "self", ".", "_true_positive_sum", ".", "size", "(", "0", ")", "\n", "-", "self", ".", "_pred_sum", "\n", "-", "self", ".", "_true_sum", "\n", "+", "self", ".", "_true_positive_sum", "\n", ")", "\n", "return", "true_negative_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_multi.F1MultiLabelMeasure.__init__": [[168, 172], ["fbeta_multi.FBetaMultiLabelMeasure.__init__"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "average", ":", "str", "=", "None", ",", "labels", ":", "List", "[", "int", "]", "=", "None", ",", "threshold", ":", "float", "=", "0.5", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "1.0", ",", "average", ",", "labels", ",", "threshold", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__init__": [[77, 104], ["allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError", "allennlp.common.checks.ConfigurationError", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "beta", ":", "float", "=", "1.0", ",", "average", ":", "str", "=", "None", ",", "labels", ":", "List", "[", "int", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "average_options", "=", "{", "None", ",", "\"micro\"", ",", "\"macro\"", ",", "\"weighted\"", "}", "\n", "if", "average", "not", "in", "average_options", ":", "\n", "            ", "raise", "ConfigurationError", "(", "f\"`average` has to be one of {average_options}.\"", ")", "\n", "", "if", "beta", "<=", "0", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"`beta` should be >0 in the F-beta score.\"", ")", "\n", "", "if", "labels", "is", "not", "None", "and", "len", "(", "labels", ")", "==", "0", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\"`labels` cannot be an empty list.\"", ")", "\n", "", "self", ".", "_beta", "=", "beta", "\n", "self", ".", "_average", "=", "average", "\n", "self", ".", "_labels", "=", "labels", "\n", "\n", "# statistics", "\n", "# the total number of true positive instances under each class", "\n", "# Shape: (num_classes, )", "\n", "self", ".", "_true_positive_sum", ":", "Union", "[", "None", ",", "torch", ".", "Tensor", "]", "=", "None", "\n", "# the total number of instances", "\n", "# Shape: (num_classes, )", "\n", "self", ".", "_total_sum", ":", "Union", "[", "None", ",", "torch", ".", "Tensor", "]", "=", "None", "\n", "# the total number of instances under each _predicted_ class,", "\n", "# including true positives and false positives", "\n", "# Shape: (num_classes, )", "\n", "self", ".", "_pred_sum", ":", "Union", "[", "None", ",", "torch", ".", "Tensor", "]", "=", "None", "\n", "# the total number of instances under each _true_ class,", "\n", "# including true positives and false negatives", "\n", "# Shape: (num_classes, )", "\n", "self", ".", "_true_sum", ":", "Union", "[", "None", ",", "torch", ".", "Tensor", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.__call__": [[105, 180], ["fbeta_measure.FBetaMeasure.detach_tensors", "predictions.size", "gold_labels.float.float.float", "[].float", "argmax_predictions[].long", "gold_labels[].long", "torch.ones_like().bool.sum().to", "spart.metrics.nn_util.dist_reduce_sum", "spart.metrics.nn_util.dist_reduce_sum", "spart.metrics.nn_util.dist_reduce_sum", "allennlp.common.checks.ConfigurationError", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones_like().bool", "predictions.sum", "torch.zeros", "torch.bincount().float", "torch.bincount().float", "torch.zeros", "torch.bincount().float", "torch.zeros", "torch.ones_like().bool.sum", "torch.ones_like", "predictions.max", "torch.bincount", "torch.bincount", "torch.bincount", "true_positives_bins.long"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum", "home.repos.pwc.inspect_result.mslars_mare.metrics.nn_util.dist_reduce_sum"], ["", "@", "overrides", "\n", "def", "__call__", "(", "\n", "self", ",", "\n", "predictions", ":", "torch", ".", "Tensor", ",", "\n", "gold_labels", ":", "torch", ".", "Tensor", ",", "\n", "mask", ":", "Optional", "[", "torch", ".", "BoolTensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        # Parameters\n\n        predictions : `torch.Tensor`, required.\n            A tensor of predictions of shape (batch_size, ..., num_classes).\n        gold_labels : `torch.Tensor`, required.\n            A tensor of integer class label of shape (batch_size, ...). It must be the same\n            shape as the `predictions` tensor without the `num_classes` dimension.\n        mask : `torch.BoolTensor`, optional (default = `None`).\n            A masking tensor the same size as `gold_labels`.\n        \"\"\"", "\n", "predictions", ",", "gold_labels", ",", "mask", "=", "self", ".", "detach_tensors", "(", "predictions", ",", "gold_labels", ",", "mask", ")", "\n", "\n", "# Calculate true_positive_sum, true_negative_sum, pred_sum, true_sum", "\n", "num_classes", "=", "predictions", ".", "size", "(", "-", "1", ")", "\n", "if", "(", "gold_labels", ">=", "num_classes", ")", ".", "any", "(", ")", ":", "\n", "            ", "raise", "ConfigurationError", "(", "\n", "\"A gold label passed to FBetaMeasure contains \"", "\n", "f\"an id >= {num_classes}, the number of classes.\"", "\n", ")", "\n", "\n", "# It means we call this metric at the first time", "\n", "# when `self._true_positive_sum` is None.", "\n", "", "if", "self", ".", "_true_positive_sum", "is", "None", ":", "\n", "            ", "self", ".", "_true_positive_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_true_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_pred_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "self", ".", "_total_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "ones_like", "(", "gold_labels", ")", ".", "bool", "(", ")", "\n", "", "gold_labels", "=", "gold_labels", ".", "float", "(", ")", "\n", "\n", "# If the prediction tensor is all zeros, the record is not classified to any of the labels.", "\n", "pred_mask", "=", "predictions", ".", "sum", "(", "dim", "=", "-", "1", ")", "!=", "0", "\n", "argmax_predictions", "=", "predictions", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "1", "]", ".", "float", "(", ")", "\n", "\n", "true_positives", "=", "(", "gold_labels", "==", "argmax_predictions", ")", "&", "mask", "&", "pred_mask", "\n", "true_positives_bins", "=", "gold_labels", "[", "true_positives", "]", "\n", "\n", "# Watch it:", "\n", "# The total numbers of true positives under all _predicted_ classes are zeros.", "\n", "if", "true_positives_bins", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "true_positive_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "true_positive_sum", "=", "torch", ".", "bincount", "(", "\n", "true_positives_bins", ".", "long", "(", ")", ",", "minlength", "=", "num_classes", "\n", ")", ".", "float", "(", ")", "\n", "\n", "", "pred_bins", "=", "argmax_predictions", "[", "mask", "&", "pred_mask", "]", ".", "long", "(", ")", "\n", "# Watch it:", "\n", "# When the `mask` is all 0, we will get an _empty_ tensor.", "\n", "if", "pred_bins", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "pred_sum", "=", "torch", ".", "bincount", "(", "pred_bins", ",", "minlength", "=", "num_classes", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "pred_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "gold_labels_bins", "=", "gold_labels", "[", "mask", "]", ".", "long", "(", ")", "\n", "if", "gold_labels", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "true_sum", "=", "torch", ".", "bincount", "(", "gold_labels_bins", ",", "minlength", "=", "num_classes", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "true_sum", "=", "torch", ".", "zeros", "(", "num_classes", ",", "device", "=", "predictions", ".", "device", ")", "\n", "\n", "", "self", ".", "_total_sum", "+=", "mask", ".", "sum", "(", ")", ".", "to", "(", "torch", ".", "float", ")", "\n", "\n", "self", ".", "_true_positive_sum", "+=", "dist_reduce_sum", "(", "true_positive_sum", ")", "\n", "self", ".", "_pred_sum", "+=", "dist_reduce_sum", "(", "pred_sum", ")", "\n", "self", ".", "_true_sum", "+=", "dist_reduce_sum", "(", "true_sum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.get_metric": [[181, 241], ["fbeta_measure.nan_safe_tensor_divide", "fbeta_measure.nan_safe_tensor_divide", "RuntimeError", "tp_sum.sum.sum.sum", "pred_sum.sum.sum.sum", "true_sum.sum.sum.sum", "nan_safe_tensor_divide.mean", "nan_safe_tensor_divide.mean", "nan_safe_tensor_divide.mean", "fbeta_measure.FBetaMeasure.reset", "true_sum.sum.sum.sum", "fbeta_measure.nan_safe_tensor_divide", "fbeta_measure.nan_safe_tensor_divide", "fbeta_measure.nan_safe_tensor_divide", "nan_safe_tensor_divide.tolist", "nan_safe_tensor_divide.tolist", "nan_safe_tensor_divide.tolist", "nan_safe_tensor_divide.item", "nan_safe_tensor_divide.item", "nan_safe_tensor_divide.item"], "methods", ["home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide", "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide"], ["", "@", "overrides", "\n", "def", "get_metric", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        # Returns\n\n        precisions : `List[float]`\n        recalls : `List[float]`\n        f1-measures : `List[float]`\n\n        !!! Note\n            If `self.average` is not `None`, you will get `float` instead of `List[float]`.\n        \"\"\"", "\n", "if", "self", ".", "_true_positive_sum", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"You never call this metric before.\"", ")", "\n", "\n", "", "else", ":", "\n", "            ", "tp_sum", "=", "self", ".", "_true_positive_sum", "\n", "pred_sum", "=", "self", ".", "_pred_sum", "\n", "true_sum", "=", "self", ".", "_true_sum", "\n", "\n", "", "if", "self", ".", "_labels", "is", "not", "None", ":", "\n", "# Retain only selected labels and order them", "\n", "            ", "tp_sum", "=", "tp_sum", "[", "self", ".", "_labels", "]", "\n", "pred_sum", "=", "pred_sum", "[", "self", ".", "_labels", "]", "# type: ignore", "\n", "true_sum", "=", "true_sum", "[", "self", ".", "_labels", "]", "# type: ignore", "\n", "\n", "", "if", "self", ".", "_average", "==", "\"micro\"", ":", "\n", "            ", "tp_sum", "=", "tp_sum", ".", "sum", "(", ")", "\n", "pred_sum", "=", "pred_sum", ".", "sum", "(", ")", "# type: ignore", "\n", "true_sum", "=", "true_sum", ".", "sum", "(", ")", "# type: ignore", "\n", "\n", "", "beta2", "=", "self", ".", "_beta", "**", "2", "\n", "# Finally, we have all our sufficient statistics.", "\n", "precision", "=", "nan_safe_tensor_divide", "(", "tp_sum", ",", "pred_sum", ")", "\n", "recall", "=", "nan_safe_tensor_divide", "(", "tp_sum", ",", "true_sum", ")", "\n", "fscore", "=", "(", "1", "+", "beta2", ")", "*", "precision", "*", "recall", "/", "(", "beta2", "*", "precision", "+", "recall", ")", "\n", "fscore", "[", "tp_sum", "==", "0", "]", "=", "0.0", "\n", "\n", "if", "self", ".", "_average", "==", "\"macro\"", ":", "\n", "            ", "precision", "=", "precision", ".", "mean", "(", ")", "\n", "recall", "=", "recall", ".", "mean", "(", ")", "\n", "fscore", "=", "fscore", ".", "mean", "(", ")", "\n", "", "elif", "self", ".", "_average", "==", "\"weighted\"", ":", "\n", "            ", "weights", "=", "true_sum", "\n", "weights_sum", "=", "true_sum", ".", "sum", "(", ")", "# type: ignore", "\n", "precision", "=", "nan_safe_tensor_divide", "(", "(", "weights", "*", "precision", ")", ".", "sum", "(", ")", ",", "weights_sum", ")", "\n", "recall", "=", "nan_safe_tensor_divide", "(", "(", "weights", "*", "recall", ")", ".", "sum", "(", ")", ",", "weights_sum", ")", "\n", "fscore", "=", "nan_safe_tensor_divide", "(", "(", "weights", "*", "fscore", ")", ".", "sum", "(", ")", ",", "weights_sum", ")", "\n", "\n", "", "if", "reset", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "if", "self", ".", "_average", "is", "None", ":", "\n", "            ", "return", "{", "\n", "\"precision\"", ":", "precision", ".", "tolist", "(", ")", ",", "\n", "\"recall\"", ":", "recall", ".", "tolist", "(", ")", ",", "\n", "\"fscore\"", ":", "fscore", ".", "tolist", "(", ")", ",", "\n", "}", "\n", "", "else", ":", "\n", "            ", "return", "{", "\"precision\"", ":", "precision", ".", "item", "(", ")", ",", "\"recall\"", ":", "recall", ".", "item", "(", ")", ",", "\"fscore\"", ":", "fscore", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure.reset": [[242, 248], ["None"], "methods", ["None"], ["", "", "@", "overrides", "\n", "def", "reset", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_true_positive_sum", "=", "None", "\n", "self", ".", "_pred_sum", "=", "None", "\n", "self", ".", "_true_sum", "=", "None", "\n", "self", ".", "_total_sum", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.FBetaMeasure._true_negative_sum": [[249, 258], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "_true_negative_sum", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_total_sum", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "true_negative_sum", "=", "(", "\n", "self", ".", "_total_sum", "-", "self", ".", "_pred_sum", "-", "self", ".", "_true_sum", "+", "self", ".", "_true_positive_sum", "\n", ")", "\n", "return", "true_negative_sum", "", "", "", "", ""]], "home.repos.pwc.inspect_result.mslars_mare.metrics.fbeta_measure.nan_safe_tensor_divide": [[10, 22], ["mask.any"], "function", ["None"], ["def", "nan_safe_tensor_divide", "(", "numerator", ",", "denominator", ")", ":", "\n", "    ", "\"\"\"Performs division and handles divide-by-zero.\n    On zero-division, sets the corresponding result elements to zero.\n    \"\"\"", "\n", "result", "=", "numerator", "/", "denominator", "\n", "mask", "=", "denominator", "==", "0.0", "\n", "if", "not", "mask", ".", "any", "(", ")", ":", "\n", "        ", "return", "result", "\n", "\n", "# remove nan", "\n", "", "result", "[", "mask", "]", "=", "0.0", "\n", "return", "result", "\n", "\n"]]}