{"home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.GCNLayer.__init__": [[42, 46], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_feats", ",", "out_feats", ")", ":", "\n", "        ", "super", "(", "GCNLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# define a fully connected layer to store W", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_feats", ",", "out_feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.GCNLayer.forward": [[47, 55], ["g.local_scope", "g.update_all", "simple_gcn.GCNLayer.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "g", ",", "feature", ")", ":", "\n", "# perform one-pass of updates on graph", "\n", "# return the updated embeddings of all nodes", "\n", "        ", "with", "g", ".", "local_scope", "(", ")", ":", "\n", "            ", "g", ".", "ndata", "[", "'h'", "]", "=", "feature", "\n", "g", ".", "update_all", "(", "gcn_msg", ",", "gcn_reduce", ")", "\n", "h", "=", "g", ".", "ndata", "[", "'h'", "]", "\n", "return", "self", ".", "linear", "(", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.__init__": [[60, 64], ["torch.Module.__init__", "simple_gcn.GCNLayer", "simple_gcn.GCNLayer"], "methods", ["home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "insz", ",", "outsz", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layer1", "=", "GCNLayer", "(", "insz", ",", "128", ")", "\n", "self", ".", "layer2", "=", "GCNLayer", "(", "128", ",", "outsz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.forward": [[65, 72], ["torch.relu", "torch.relu", "torch.relu", "simple_gcn.Net.layer2", "simple_gcn.Net.layer1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "g", ",", "features", ")", ":", "\n", "# input features are being used to learn some vector per node", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "layer1", "(", "g", ",", "features", ")", ")", "\n", "# learnt vector is refined by non-linear activation and used", "\n", "# to learn next a vector on next layer", "\n", "x", "=", "self", ".", "layer2", "(", "g", ",", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.get_embeddings": [[73, 76], ["simple_gcn.Net.layer1"], "methods", ["None"], ["", "def", "get_embeddings", "(", "self", ",", "g", ",", "features", ")", ":", "\n", "        ", "x", "=", "self", ".", "layer1", "(", "g", ",", "features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.gcn_msg": [[31, 34], ["None"], "function", ["None"], ["def", "gcn_msg", "(", "edges", ")", ":", "\n", "# just pass source node's embedding to destination node", "\n", "    ", "return", "{", "'m'", ":", "edges", ".", "src", "[", "'h'", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.gcn_reduce": [[36, 39], ["torch.sum", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "gcn_reduce", "(", "nodes", ")", ":", "\n", "# sum the embedding of all neighbor nodes", "\n", "    ", "return", "{", "'h'", ":", "torch", ".", "sum", "(", "nodes", ".", "mailbox", "[", "'m'", "]", ",", "dim", "=", "1", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.evaluate": [[78, 93], ["model.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.max", "torch.max", "torch.max", "sklearn.metrics.f1_score"], "function", ["None"], ["", "", "def", "evaluate", "(", "model", ",", "g", ",", "features", ",", "labels", ",", "mask", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "# disable gradient computation", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# compute embeddings", "\n", "        ", "logits", "=", "model", "(", "g", ",", "features", ")", "\n", "logits", "=", "logits", "[", "mask", "]", "\n", "labels", "=", "labels", "[", "mask", "]", "\n", "# predict class 1 for node x if logits[x][1] > logits[x][0]", "\n", "_", ",", "indices", "=", "torch", ".", "max", "(", "logits", ",", "dim", "=", "1", ")", "\n", "ans", "=", "metrics", ".", "f1_score", "(", "labels", ",", "indices", ",", "average", "=", "'micro'", ")", "\n", "# correct = torch.sum(indices == labels)", "\n", "# # accuracy computation", "\n", "# return correct.item() * 1.0 / len(labels)", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.evaluate_lp": [[94, 100], ["model.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.get_embeddings", "node_embedding_attack.utils.evaluate_embedding_link_prediction"], "function", ["home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.Net.get_embeddings", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.evaluate_embedding_link_prediction"], ["", "", "def", "evaluate_lp", "(", "model", ",", "g", ",", "features", ",", "node_pairs", ",", "adj_matrix", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "embeddings", "=", "model", ".", "get_embeddings", "(", "g", ",", "features", ")", "\n", "roc", ",", "auc", "=", "evaluate_embedding_link_prediction", "(", "adj_matrix", ",", "node_pairs", ",", "embeddings", ")", "\n", "return", "auc", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.load_karate_club": [[101, 128], ["networkx.karate_club_graph", "dgl.DGLGraph.nodes", "numpy.eye", "numpy.zeros", "numpy.ones", "dgl.DGLGraph", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "len", "len", "dgl.DGLGraph.node.data", "torch.LongTensor.append", "torch.LongTensor.append", "dgl.DGLGraph.nodes"], "function", ["None"], ["", "", "def", "load_karate_club", "(", ")", ":", "\n", "# generate training and testing masks", "\n", "# alongisde loading dataset", "\n", "    ", "g", "=", "nx", ".", "karate_club_graph", "(", ")", "\n", "labels", "=", "[", "]", "\n", "for", "i", "in", "g", ".", "nodes", "(", ")", ":", "\n", "        ", "n", "=", "g", ".", "node", ".", "data", "(", ")", "[", "i", "]", "\n", "if", "n", "[", "'club'", "]", "==", "'Officer'", ":", "\n", "            ", "labels", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "labels", ".", "append", "(", "0", ")", "\n", "\n", "# one-hot encoded node id", "\n", "", "", "feats", "=", "np", ".", "eye", "(", "len", "(", "g", ".", "nodes", "(", ")", ")", ")", "\n", "train_mask", "=", "np", ".", "zeros", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "# only first and last node for training", "\n", "train_mask", "[", "[", "0", ",", "train_mask", ".", "shape", "[", "0", "]", "-", "1", "]", "]", "=", "1", "\n", "# all nodes for testing", "\n", "test_mask", "=", "np", ".", "ones", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "\n", "# convert everything to pytorch variables", "\n", "g", "=", "dgl", ".", "DGLGraph", "(", "g", ")", "\n", "feats", "=", "torch", ".", "FloatTensor", "(", "feats", ")", "\n", "train_mask", "=", "torch", ".", "BoolTensor", "(", "train_mask", ")", "\n", "test_mask", "=", "torch", ".", "BoolTensor", "(", "test_mask", ")", "\n", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "return", "g", ",", "feats", ",", "labels", ",", "train_mask", ",", "test_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.load_npz": [[130, 152], ["node_embedding_attack.utils.load_dataset", "node_embedding_attack.utils.standardize", "dgl.DGLGraph", "numpy.eye", "numpy.zeros", "numpy.random.choice", "numpy.ones", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "len", "numpy.arange", "len", "numpy.nonzero", "dgl.DGLGraph.nodes", "len", "int", "len"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.load_dataset", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.standardize"], ["", "def", "load_npz", "(", "fileloc", ",", "attack", "=", "None", ",", "ctype", "=", "'addition'", ")", ":", "\n", "    ", "G", "=", "load_dataset", "(", "fileloc", ")", "\n", "adj_matrix", ",", "labels", "=", "standardize", "(", "G", "[", "'adj_matrix'", "]", ",", "G", "[", "'labels'", "]", ")", "\n", "adj_matrix", "[", "np", ".", "nonzero", "(", "adj_matrix", ")", "]", "=", "1", "\n", "\n", "g", "=", "dgl", ".", "DGLGraph", "(", "adj_matrix", ")", "\n", "labels", "=", "labels", "\n", "feats", "=", "np", ".", "eye", "(", "len", "(", "g", ".", "nodes", "(", ")", ")", ")", "\n", "train_mask", "=", "np", ".", "zeros", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "\n", "sindices", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "len", "(", "train_mask", ")", ",", "1", ")", ",", "\n", "size", "=", "int", "(", "0.1", "*", "len", "(", "train_mask", ")", ")", ",", "replace", "=", "False", ")", "\n", "\n", "train_mask", "[", "sindices", "]", "=", "1", "\n", "\n", "test_mask", "=", "np", ".", "ones", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "\n", "feats", "=", "torch", ".", "FloatTensor", "(", "feats", ")", "\n", "train_mask", "=", "torch", ".", "BoolTensor", "(", "train_mask", ")", "\n", "test_mask", "=", "torch", ".", "BoolTensor", "(", "test_mask", ")", "\n", "labels", "=", "torch", ".", "LongTensor", "(", "labels", ")", "\n", "return", "adj_matrix", ",", "feats", ",", "labels", ",", "train_mask", ",", "test_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.get_candidates": [[154, 164], ["node_embedding_attack.utils.generate_candidates_addition", "node_embedding_attack.utils.generate_candidates_removal", "node_embedding_attack.utils.generate_candidates_addition", "node_embedding_attack.utils.generate_candidates_removal", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_addition", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_addition", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal"], ["", "def", "get_candidates", "(", "adj_matrix", ",", "ctype", "=", "'addition'", ",", "numcds", "=", "5000", ")", ":", "\n", "    ", "if", "ctype", "==", "'addition'", ":", "\n", "        ", "candidates", "=", "generate_candidates_addition", "(", "adj_matrix", "=", "adj_matrix", ",", "n_candidates", "=", "numcds", ")", "\n", "", "elif", "ctype", "==", "'removal'", ":", "\n", "        ", "candidates", "=", "generate_candidates_removal", "(", "adj_matrix", "=", "adj_matrix", ")", "\n", "", "elif", "ctype", "==", "'combined'", ":", "\n", "        ", "candidates1", "=", "generate_candidates_addition", "(", "adj_matrix", "=", "adj_matrix", ",", "n_candidates", "=", "numcds", ")", "\n", "candidates2", "=", "generate_candidates_removal", "(", "adj_matrix", "=", "adj_matrix", ")", "\n", "candidates", "=", "np", ".", "concatenate", "(", "[", "candidates1", ",", "candidates2", "]", ")", "\n", "", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_gcn.get_attacked_graph": [[166, 179], ["node_embedding_attack.utils.flip_candidates", "node_embedding_attack.perturbation_attack.baseline_random_top_flips", "node_embedding_attack.perturbation_attack.baseline_degree_top_flips", "node_embedding_attack.perturbation_attack.perturbation_top_flips", "node_embedding_attack.perturbation_attack.perturbation_top_flips"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.flip_candidates", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_random_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_degree_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.perturbation_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.perturbation_top_flips"], ["", "def", "get_attacked_graph", "(", "adj_matrix", ",", "candidates", ",", "attack", "=", "None", ",", "nflips", "=", "None", ",", "dim", "=", "None", ",", "window_size", "=", "None", ",", "L", "=", "None", ")", ":", "\n", "    ", "if", "attack", "is", "not", "None", ":", "\n", "        ", "if", "attack", "==", "'rnd'", ":", "\n", "            ", "flips", "=", "baseline_random_top_flips", "(", "candidates", ",", "n_flips", ",", "0", ")", "\n", "", "elif", "attack", "==", "'deg'", ":", "\n", "            ", "flips", "=", "baseline_degree_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "True", ")", "\n", "", "elif", "attack", "==", "'our'", ":", "\n", "            ", "flips", "=", "perturbation_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "L", ")", "\n", "", "elif", "attack", "==", "'ori'", ":", "\n", "            ", "flips", "=", "perturbation_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "mode", "=", "'unsup'", ")", "\n", "", "adj_matrix_flipped", "=", "flip_candidates", "(", "adj_matrix", ",", "flips", ")", "\n", "return", "adj_matrix_flipped", "\n", "", "return", "adj_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_all.load_npz": [[23, 39], ["node_embedding_attack.utils.load_dataset", "node_embedding_attack.utils.standardize", "networkx.Graph", "numpy.eye", "numpy.zeros", "numpy.random.choice", "numpy.ones", "len", "len", "numpy.arange", "len", "nx.Graph.nodes", "len", "int", "len"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.load_dataset", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.standardize"], ["def", "load_npz", "(", "fileloc", ",", "attack", "=", "None", ",", "ctype", "=", "'addition'", ")", ":", "\n", "    ", "G", "=", "load_dataset", "(", "fileloc", ")", "\n", "adj_matrix", ",", "labels", "=", "standardize", "(", "G", "[", "'adj_matrix'", "]", ",", "G", "[", "'labels'", "]", ")", "\n", "\n", "g", "=", "nx", ".", "Graph", "(", "adj_matrix", ")", "\n", "labels", "=", "labels", "\n", "feats", "=", "np", ".", "eye", "(", "len", "(", "g", ".", "nodes", "(", ")", ")", ")", "\n", "train_mask", "=", "np", ".", "zeros", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "\n", "sindices", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "len", "(", "train_mask", ")", ",", "1", ")", ",", "\n", "size", "=", "int", "(", "0.1", "*", "len", "(", "train_mask", ")", ")", ",", "replace", "=", "False", ")", "\n", "\n", "train_mask", "[", "sindices", "]", "=", "1", "\n", "\n", "test_mask", "=", "np", ".", "ones", "(", "len", "(", "g", ".", "nodes", ")", ")", "\n", "return", "adj_matrix", ",", "feats", ",", "labels", ",", "train_mask", ",", "test_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_all.get_candidates": [[41, 53], ["node_embedding_attack.utils.generate_candidates_addition", "node_embedding_attack.utils.generate_candidates_removal", "node_embedding_attack.utils.generate_candidates_addition", "node_embedding_attack.utils.generate_candidates_removal", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_addition", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_addition", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal"], ["", "def", "get_candidates", "(", "adj_matrix", ",", "ctype", "=", "'addition'", ",", "numcds", "=", "5000", ")", ":", "\n", "    ", "if", "ctype", "==", "'addition'", ":", "\n", "        ", "candidates", "=", "generate_candidates_addition", "(", "\n", "adj_matrix", "=", "adj_matrix", ",", "n_candidates", "=", "numcds", ")", "\n", "", "elif", "ctype", "==", "'removal'", ":", "\n", "        ", "candidates", "=", "generate_candidates_removal", "(", "adj_matrix", "=", "adj_matrix", ")", "\n", "", "elif", "ctype", "==", "'combined'", ":", "\n", "        ", "candidates1", "=", "generate_candidates_addition", "(", "\n", "adj_matrix", "=", "adj_matrix", ",", "n_candidates", "=", "numcds", ")", "\n", "candidates2", "=", "generate_candidates_removal", "(", "adj_matrix", "=", "adj_matrix", ")", "\n", "candidates", "=", "np", ".", "concatenate", "(", "[", "candidates1", ",", "candidates2", "]", ")", "\n", "", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_all.get_attacked_graph": [[55, 71], ["node_embedding_attack.utils.flip_candidates", "node_embedding_attack.perturbation_attack.baseline_random_top_flips", "node_embedding_attack.perturbation_attack.baseline_degree_top_flips", "node_embedding_attack.perturbation_attack.perturbation_top_flips", "node_embedding_attack.perturbation_attack.perturbation_top_flips"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.flip_candidates", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_random_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_degree_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.perturbation_top_flips", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.perturbation_top_flips"], ["", "def", "get_attacked_graph", "(", "adj_matrix", ",", "candidates", ",", "attack", "=", "None", ",", "nflips", "=", "None", ",", "dim", "=", "None", ",", "window_size", "=", "None", ",", "L", "=", "None", ")", ":", "\n", "    ", "if", "attack", "is", "not", "None", ":", "\n", "        ", "if", "attack", "==", "'rnd'", ":", "\n", "            ", "flips", "=", "baseline_random_top_flips", "(", "candidates", ",", "n_flips", ",", "0", ")", "\n", "", "elif", "attack", "==", "'deg'", ":", "\n", "            ", "flips", "=", "baseline_degree_top_flips", "(", "\n", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "True", ")", "\n", "", "elif", "attack", "==", "'our'", ":", "\n", "            ", "flips", "=", "perturbation_top_flips", "(", "\n", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "L", ")", "\n", "", "elif", "attack", "==", "'ori'", ":", "\n", "            ", "flips", "=", "perturbation_top_flips", "(", "\n", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "mode", "=", "'unsup'", ")", "\n", "", "adj_matrix_flipped", "=", "flip_candidates", "(", "adj_matrix", ",", "flips", ")", "\n", "return", "adj_matrix_flipped", "\n", "", "return", "adj_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.code.simple_all.get_embedding": [[73, 87], ["node_embedding_attack.embedding.deepwalk_svd", "node_embedding_attack.embedding.deepwalk_skipgram", "node_embedding_attack.embedding.node2vec_snap", "node_embedding_attack.embedding.line_cversion"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.deepwalk_svd", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.deepwalk_skipgram", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.node2vec_snap", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.line_cversion"], ["", "def", "get_embedding", "(", "method", ",", "adj_matrix", ",", "dim", "=", "None", ",", "window_size", "=", "None", ",", ")", ":", "\n", "    ", "if", "method", "==", "'deepwalk_svd'", ":", "\n", "        ", "embs", ",", "_", ",", "_", ",", "_", "=", "deepwalk_svd", "(", "adj_matrix", ",", "window_size", ",", "dim", ")", "\n", "return", "embs", "\n", "", "elif", "method", "==", "'deepwalk_skipgram'", ":", "\n", "        ", "embs", "=", "deepwalk_skipgram", "(", "adj_matrix", ",", "embedding_dim", "=", "dim", ",", "window_size", "=", "window_size", ")", "\n", "return", "embs", "\n", "", "elif", "method", "==", "'node2vec'", ":", "\n", "        ", "embs", "=", "node2vec_snap", "(", "adj_matrix", ",", "embedding_dim", "=", "dim", ",", "window_size", "=", "window_size", ")", "\n", "return", "embs", "\n", "", "elif", "method", "==", "'line'", ":", "\n", "        ", "embs", "=", "line_cversion", "(", "adj_matrix", ",", "embedding_dim", "=", "dim", ")", "\n", "return", "embs", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.node2vec_snap": [[16, 61], ["networkx.from_scipy_sparse_matrix", "datetime.datetime.now().isoformat", "networkx.write_edgelist", "subprocess.call", "gensim.models.KeyedVectors.load_word2vec_format", "nx.from_scipy_sparse_matrix.to_undirected", "datetime.datetime.now", "numpy.fromiter().argsort", "numpy.fromiter", "map"], "function", ["None"], ["def", "node2vec_snap", "(", "adj_matrix", ",", "embedding_dim", "=", "64", ",", "walk_length", "=", "80", ",", "walks_per_node", "=", "10", ",", "\n", "workers", "=", "8", ",", "window_size", "=", "10", ",", "p", "=", "4", ",", "q", "=", "1", ",", "e", "=", "1", ")", ":", "\n", "    ", "\"\"\"Compute node2vec embeddings if node2vec binary is installed.\n\n    Parameters\n    ----------\n    adj_matrix : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    embedding_dim : int, optional\n        Dimension of the embedding\n    walks_per_node : int, optional\n        Number of walks sampled from each node\n    walk_length : int, optional\n        Length of each random walk\n    workers : int, optional\n        Number of threads (see gensim.models.Word2Vec process)\n    window_size : int, optional\n        Window size (see gensim.models.Word2Vec)\n\n    Returns\n    -------\n    E : np.ndarray, shape [num_nodes, embedding_dim]\n        Embedding matrix\n    \"\"\"", "\n", "graph", "=", "nx", ".", "from_scipy_sparse_matrix", "(", "adj_matrix", ")", "\n", "ctme", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "isoformat", "(", ")", "\n", "fname", "=", "'/tmp/n2vectemp_{}.txt'", ".", "format", "(", "ctme", ")", "\n", "outname", "=", "'/tmp/n2vectemp_{}.emb'", ".", "format", "(", "ctme", ")", "\n", "nx", ".", "write_edgelist", "(", "graph", ".", "to_undirected", "(", ")", ",", "fname", ",", "data", "=", "[", "'weight'", "]", ")", "\n", "errcode", "=", "subprocess", ".", "call", "(", "\n", "'/usr/bin/env node2vec -i:{} -o:{} -d:{} -l:{} -r:{} -k:{} -p:{} -q:{} -e:{}'", ".", "format", "(", "\n", "fname", ",", "\n", "outname", ",", "\n", "embedding_dim", ",", "\n", "walk_length", ",", "\n", "walks_per_node", ",", "\n", "window_size", ",", "\n", "p", ",", "\n", "q", ",", "\n", "e", "\n", ")", ".", "split", "(", "' '", ")", "\n", ")", "\n", "model", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "outname", ",", "binary", "=", "False", ")", "\n", "embedding", "=", "model", ".", "vectors", "[", "np", ".", "fromiter", "(", "map", "(", "int", ",", "model", ".", "index2word", ")", ",", "np", ".", "int32", ")", ".", "argsort", "(", ")", "]", "\n", "return", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.line_cversion": [[63, 118], ["networkx.from_scipy_sparse_matrix", "datetime.datetime.now().isoformat", "networkx.write_edgelist", "subprocess.call", "gensim.models.KeyedVectors.load_word2vec_format", "nx.from_scipy_sparse_matrix.to_undirected", "pstring.split", "datetime.datetime.now", "numpy.fromiter().argsort", "numpy.fromiter", "map"], "function", ["None"], ["", "def", "line_cversion", "(", "adj_matrix", ",", "embedding_dim", "=", "32", ",", "order", "=", "1", ",", "negative", "=", "5", ",", "\n", "workers", "=", "8", ",", "samples", "=", "1", ",", "rho", "=", "0.025", ")", ":", "\n", "    ", "\"\"\"Compute node2vec embeddings if node2vec binary is installed.\n\n    Parameters\n    ----------\n    adj_matrix : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    embedding_dim : int, optional\n        Dimension of the embedding\n    order : int, optional\n        Line order to be used\n    negative : int, optional\n        Number of samples for negative sampling\n    workers : int, optional\n        Number of threads (see gensim.models.Word2Vec process)\n    samples : int, optional\n        Number of samples in millions\n    rho : float, optional\n        Starting Learning parameter\n\n    Returns\n    -------\n    E : np.ndarray, shape [num_nodes, embedding_dim]\n        Embedding matrix\n    \"\"\"", "\n", "graph", "=", "nx", ".", "from_scipy_sparse_matrix", "(", "adj_matrix", ")", "\n", "ctme", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "isoformat", "(", ")", "\n", "fname", "=", "'/tmp/linetemp_{}.txt'", ".", "format", "(", "ctme", ")", "\n", "outname", "=", "'/tmp/linetemp_{}.emb'", ".", "format", "(", "ctme", ")", "\n", "nx", ".", "write_edgelist", "(", "graph", ".", "to_undirected", "(", ")", ",", "fname", ",", "data", "=", "[", "'weight'", "]", ")", "\n", "os", ".", "environ", "[", "\"LD_LIBRARY_PATH\"", "]", "=", "\"/home/viresh/bin/lib/\"", "\n", "pstring", "=", "\"/usr/bin/env line -train {} -output {} -binary 1 -size {} -order {} -negative {} -threads {} -samples {} -rho {}\"", ".", "format", "(", "\n", "fname", ",", "\n", "outname", ",", "\n", "embedding_dim", ",", "\n", "order", ",", "\n", "negative", ",", "\n", "workers", ",", "\n", "samples", ",", "\n", "rho", "\n", ")", "\n", "#     print(pstring)", "\n", "#     try:", "\n", "#         output = subprocess.check_output(pstring.split(\" \"), stderr=subprocess.STDOUT).decode()", "\n", "#         success = True", "\n", "#     except subprocess.CalledProcessError as e:", "\n", "#         output = e.output.decode()", "\n", "#         success = False", "\n", "#     print(output)", "\n", "errcode", "=", "subprocess", ".", "call", "(", "pstring", ".", "split", "(", "' '", ")", ")", "\n", "#     print(\"Error Code\", errcode)", "\n", "model", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "outname", ",", "binary", "=", "True", ")", "\n", "embedding", "=", "model", ".", "vectors", "[", "np", ".", "fromiter", "(", "map", "(", "int", ",", "model", ".", "index2word", ")", ",", "np", ".", "int32", ")", ".", "argsort", "(", ")", "]", "\n", "return", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.deepwalk_skipgram": [[120, 153], ["embedding.sample_random_walks", "gensim.models.Word2Vec", "list", "map", "numpy.fromiter().argsort", "numpy.fromiter", "map"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.sample_random_walks"], ["", "def", "deepwalk_skipgram", "(", "adj_matrix", ",", "embedding_dim", "=", "64", ",", "walk_length", "=", "80", ",", "walks_per_node", "=", "10", ",", "\n", "workers", "=", "8", ",", "window_size", "=", "10", ",", "num_neg_samples", "=", "1", ")", ":", "\n", "    ", "\"\"\"Compute DeepWalk embeddings for the given graph using the skip-gram formulation.\n\n    Parameters\n    ----------\n    adj_matrix : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    embedding_dim : int, optional\n        Dimension of the embedding\n    walks_per_node : int, optional\n        Number of walks sampled from each node\n    walk_length : int, optional\n        Length of each random walk\n    workers : int, optional\n        Number of threads (see gensim.models.Word2Vec process)\n    window_size : int, optional\n        Window size (see gensim.models.Word2Vec)\n    num_neg_samples : int, optional\n        Number of negative samples (see gensim.models.Word2Vec)\n\n    Returns\n    -------\n    E : np.ndarray, shape [num_nodes, embedding_dim]\n        Embedding matrix\n\n    \"\"\"", "\n", "walks", "=", "sample_random_walks", "(", "adj_matrix", ",", "walk_length", ",", "walks_per_node", ")", "\n", "walks", "=", "[", "list", "(", "map", "(", "str", ",", "walk", ")", ")", "for", "walk", "in", "walks", "]", "\n", "model", "=", "Word2Vec", "(", "walks", ",", "size", "=", "embedding_dim", ",", "window", "=", "window_size", ",", "min_count", "=", "0", ",", "sg", "=", "1", ",", "workers", "=", "workers", ",", "\n", "iter", "=", "1", ",", "negative", "=", "num_neg_samples", ",", "hs", "=", "0", ",", "compute_loss", "=", "True", ")", "\n", "embedding", "=", "model", ".", "wv", ".", "syn0", "[", "np", ".", "fromiter", "(", "map", "(", "int", ",", "model", ".", "wv", ".", "index2word", ")", ",", "np", ".", "int32", ")", ".", "argsort", "(", ")", "]", "\n", "return", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.deepwalk_svd": [[155, 193], ["embedding.sum_of_powers_of_transition_matrix", "scipy.diags", "adj_matrix.sum", "M.copy", "numpy.log", "log_M.toarray.multiply", "embedding.svd_embedding", "numpy.linalg.norm", "adj_matrix.sum", "log_M.toarray.toarray", "sum_of_powers_of_transition_matrix.dot", "Fu.dot"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.sum_of_powers_of_transition_matrix", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.svd_embedding"], ["", "def", "deepwalk_svd", "(", "adj_matrix", ",", "window_size", ",", "embedding_dim", ",", "num_neg_samples", "=", "1", ",", "sparse", "=", "True", ")", ":", "\n", "    ", "\"\"\"Compute DeepWalk embeddings for the given graph using the matrix factorization formulation.\n\n    :param adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param window_size: int\n        Size of the window\n    :param embedding_dim: int\n        Size of the embedding\n    :param num_neg_samples: int\n        Number of negative samples\n    :param sparse: bool\n        Whether to perform sparse operations\n    :return: np.ndarray, shape [num_nodes, embedding_dim]\n        Embedding matrix.\n    \"\"\"", "\n", "sum_powers_transition", "=", "sum_of_powers_of_transition_matrix", "(", "adj_matrix", ",", "window_size", ")", "\n", "\n", "deg", "=", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg", "[", "deg", "==", "0", "]", "=", "1", "\n", "deg_matrix", "=", "sp", ".", "diags", "(", "1", "/", "deg", ")", "\n", "\n", "volume", "=", "adj_matrix", ".", "sum", "(", ")", "\n", "\n", "M", "=", "sum_powers_transition", ".", "dot", "(", "deg_matrix", ")", "*", "volume", "/", "(", "num_neg_samples", "*", "window_size", ")", "\n", "\n", "log_M", "=", "M", ".", "copy", "(", ")", "\n", "log_M", "[", "M", ">", "1", "]", "=", "np", ".", "log", "(", "log_M", "[", "M", ">", "1", "]", ")", "\n", "log_M", "=", "log_M", ".", "multiply", "(", "M", ">", "1", ")", "\n", "\n", "if", "not", "sparse", ":", "\n", "        ", "log_M", "=", "log_M", ".", "toarray", "(", ")", "\n", "\n", "", "Fu", ",", "Fv", "=", "svd_embedding", "(", "log_M", ",", "embedding_dim", ",", "sparse", ")", "\n", "\n", "loss", "=", "np", ".", "linalg", ".", "norm", "(", "Fu", ".", "dot", "(", "Fv", ".", "T", ")", "-", "log_M", ",", "ord", "=", "'fro'", ")", "\n", "\n", "return", "Fu", ",", "Fv", ",", "loss", ",", "log_M", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.sample_random_walks": [[195, 224], ["scipy.csr_matrix", "_random_walk().reshape", "numpy.random.randint", "embedding._random_walk"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding._random_walk"], ["", "def", "sample_random_walks", "(", "adj_matrix", ",", "walk_length", ",", "walks_per_node", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Sample random walks of fixed length from each node in the graph in parallel.\n\n    Parameters\n    ----------\n    adj_matrix : sp.csr_matrix, shape [n_nodes, n_nodes]\n        Sparse adjacency matrix\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    seed : int or None\n        Random seed\n\n    Returns\n    -------\n    walks : np.ndarray, shape [num_walks * num_nodes, walk_length]\n        The sampled random walks\n\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "100000", ")", "\n", "", "adj_matrix", "=", "sp", ".", "csr_matrix", "(", "adj_matrix", ")", "\n", "random_walks", "=", "_random_walk", "(", "adj_matrix", ".", "indptr", ",", "\n", "adj_matrix", ".", "indices", ",", "\n", "walk_length", ",", "\n", "walks_per_node", ",", "\n", "seed", ")", ".", "reshape", "(", "[", "-", "1", ",", "walk_length", "]", ")", "\n", "return", "random_walks", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding._random_walk": [[226, 259], ["numba.jit", "numpy.random.seed", "range", "numpy.array", "len", "range", "range", "walks.append", "numpy.random.choice"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "_random_walk", "(", "indptr", ",", "indices", ",", "walk_length", ",", "walks_per_node", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Sample r random walks of length l per node in parallel from the graph.\n\n    Parameters\n    ----------\n    indptr : array-like\n        Pointer for the edges of each node\n    indices : array-like\n        Edges for each node\n    walk_length : int\n        Random walk length\n    walks_per_node : int\n        Number of random walks per node\n    seed : int\n        Random seed\n\n    Returns\n    -------\n    walks : array-like, shape [r*N*l]\n        The sampled random walks\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "N", "=", "len", "(", "indptr", ")", "-", "1", "\n", "walks", "=", "[", "]", "\n", "\n", "for", "ir", "in", "range", "(", "walks_per_node", ")", ":", "\n", "        ", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "for", "il", "in", "range", "(", "walk_length", ")", ":", "\n", "                ", "walks", ".", "append", "(", "n", ")", "\n", "n", "=", "np", ".", "random", ".", "choice", "(", "indices", "[", "indptr", "[", "n", "]", ":", "indptr", "[", "n", "+", "1", "]", "]", ")", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "walks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.svd_embedding": [[261, 283], ["numpy.diag", "scipy.linalg.svds", "numpy.linalg.svd", "U.dot", "numpy.sqrt", "numpy.sqrt().dot", "numpy.sqrt"], "function", ["None"], ["", "def", "svd_embedding", "(", "x", ",", "embedding_dim", ",", "sparse", "=", "False", ")", ":", "\n", "    ", "\"\"\"Computes an embedding by selection the top (embedding_dim) largest singular-values/vectors.\n\n    :param x: sp.csr_matrix or np.ndarray\n        The matrix that we want to embed\n    :param embedding_dim: int\n        Dimension of the embedding\n    :param sparse: bool\n        Whether to perform sparse operations\n    :return: np.ndarray, shape [?, embedding_dim], np.ndarray, shape [?, embedding_dim]\n        Embedding matrices.\n    \"\"\"", "\n", "if", "sparse", ":", "\n", "        ", "U", ",", "s", ",", "V", "=", "sp", ".", "linalg", ".", "svds", "(", "x", ",", "embedding_dim", ")", "\n", "", "else", ":", "\n", "        ", "U", ",", "s", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "x", ")", "\n", "\n", "", "S", "=", "np", ".", "diag", "(", "s", ")", "\n", "Fu", "=", "U", ".", "dot", "(", "np", ".", "sqrt", "(", "S", ")", ")", "[", ":", ",", ":", "embedding_dim", "]", "\n", "Fv", "=", "np", ".", "sqrt", "(", "S", ")", ".", "dot", "(", "V", ")", "[", ":", "embedding_dim", ",", ":", "]", ".", "T", "\n", "\n", "return", "Fu", ",", "Fv", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.embedding.sum_of_powers_of_transition_matrix": [[285, 307], ["scipy.diags().dot", "range", "adj_matrix.sum", "last.dot.dot", "scipy.diags"], "function", ["None"], ["", "def", "sum_of_powers_of_transition_matrix", "(", "adj_matrix", ",", "pow", ")", ":", "\n", "    ", "\"\"\"Computes \\sum_{r=1}^{pow) (D^{-1}A)^r.\n\n    :param adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param pow: int\n        Power exponent\n    :return: sp.csr_matrix\n        Sum of powers of the transition matrix of a graph.\n\n    \"\"\"", "\n", "deg", "=", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg", "[", "deg", "==", "0", "]", "=", "1", "\n", "transition_matrix", "=", "sp", ".", "diags", "(", "1", "/", "deg", ")", ".", "dot", "(", "adj_matrix", ")", "\n", "\n", "sum_of_powers", "=", "transition_matrix", "\n", "last", "=", "transition_matrix", "\n", "for", "i", "in", "range", "(", "1", ",", "pow", ")", ":", "\n", "        ", "last", "=", "last", ".", "dot", "(", "transition_matrix", ")", "\n", "sum_of_powers", "+=", "last", "\n", "\n", "", "return", "sum_of_powers", "\n", "", ""]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.flip_candidates": [[17, 34], ["adj_matrix.copy().tolil", "adj_matrix_flipped.tocsr.tocsr", "adj_matrix_flipped.tocsr.eliminate_zeros", "adj_matrix.copy"], "function", ["None"], ["def", "flip_candidates", "(", "adj_matrix", ",", "candidates", ")", ":", "\n", "    ", "\"\"\"Flip the edges in the candidate set to non-edges and vise-versa.\n\n    :param adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :return: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph with the flipped edges/non-edges.\n    \"\"\"", "\n", "adj_matrix_flipped", "=", "adj_matrix", ".", "copy", "(", ")", ".", "tolil", "(", ")", "\n", "adj_matrix_flipped", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", "=", "1", "-", "adj_matrix", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", "\n", "adj_matrix_flipped", "[", "candidates", "[", ":", ",", "1", "]", ",", "candidates", "[", ":", ",", "0", "]", "]", "=", "1", "-", "adj_matrix", "[", "candidates", "[", ":", ",", "1", "]", ",", "candidates", "[", ":", ",", "0", "]", "]", "\n", "adj_matrix_flipped", "=", "adj_matrix_flipped", ".", "tocsr", "(", ")", "\n", "adj_matrix_flipped", ".", "eliminate_zeros", "(", ")", "\n", "\n", "return", "adj_matrix_flipped", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.sum_of_powers": [[36, 53], ["numba.jit", "numpy.zeros", "enumerate", "np.zeros.sum", "range", "numpy.power"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "sum_of_powers", "(", "x", ",", "power", ")", ":", "\n", "    ", "\"\"\"For each x_i, computes \\sum_{r=1}^{pow) x_i^r (elementwise sum of powers).\n\n    :param x: shape [?]\n        Any vector\n    :param pow: int\n        The largest power to consider\n    :return: shape [?]\n        Vector where each element is the sum of powers from 1 to pow.\n    \"\"\"", "\n", "n", "=", "x", ".", "shape", "[", "0", "]", "\n", "sum_powers", "=", "np", ".", "zeros", "(", "(", "power", ",", "n", ")", ")", "\n", "for", "i", ",", "i_power", "in", "enumerate", "(", "range", "(", "1", ",", "power", "+", "1", ")", ")", ":", "\n", "        ", "sum_powers", "[", "i", "]", "=", "np", ".", "power", "(", "x", ",", "i_power", ")", "\n", "\n", "", "return", "sum_powers", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal_minimum_spanning_tree": [[55, 70], ["scipy.csgraph.minimum_spanning_tree", "mst.maximum.maximum", "numpy.column_stack", "scipy.triu().nonzero", "scipy.triu"], "function", ["None"], ["", "def", "generate_candidates_removal_minimum_spanning_tree", "(", "adj_matrix", ")", ":", "\n", "    ", "\"\"\"Generates candidate edge flips for removal (edge -> non-edge),\n     disallowing edges that lie on the minimum spanning tree.\n\n    adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :return: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    \"\"\"", "\n", "mst", "=", "sp", ".", "csgraph", ".", "minimum_spanning_tree", "(", "adj_matrix", ")", "\n", "mst", "=", "mst", ".", "maximum", "(", "mst", ".", "T", ")", "\n", "adj_matrix_sample", "=", "adj_matrix", "-", "mst", "\n", "candidates", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj_matrix_sample", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_removal": [[72, 101], ["numpy.random.seed", "numpy.column_stack", "utils.edges_to_sparse", "adj_hidden.maximum.maximum", "numpy.column_stack", "numpy.where", "scipy.triu().nonzero", "numpy.arange", "numpy.fromiter", "numpy.logical_not", "map", "scipy.triu", "adj_matrix.sum", "numpy.in1d", "numpy.in1d", "adj_matrix.tolil"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edges_to_sparse"], ["", "def", "generate_candidates_removal", "(", "adj_matrix", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Generates candidate edge flips for removal (edge -> non-edge),\n     disallowing one random edge per node to prevent singleton nodes.\n\n    adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param seed: int\n        Random seed\n    :return: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    \"\"\"", "\n", "n_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "deg", "=", "np", ".", "where", "(", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "==", "1", ")", "[", "0", "]", "\n", "\n", "hiddeen", "=", "np", ".", "column_stack", "(", "\n", "(", "np", ".", "arange", "(", "n_nodes", ")", ",", "np", ".", "fromiter", "(", "map", "(", "np", ".", "random", ".", "choice", ",", "adj_matrix", ".", "tolil", "(", ")", ".", "rows", ")", ",", "dtype", "=", "np", ".", "int", ")", ")", ")", "\n", "\n", "adj_hidden", "=", "edges_to_sparse", "(", "hiddeen", ",", "adj_matrix", ".", "shape", "[", "0", "]", ")", "\n", "adj_hidden", "=", "adj_hidden", ".", "maximum", "(", "adj_hidden", ".", "T", ")", "\n", "\n", "adj_keep", "=", "adj_matrix", "-", "adj_hidden", "\n", "\n", "candidates", "=", "np", ".", "column_stack", "(", "(", "sp", ".", "triu", "(", "adj_keep", ")", ".", "nonzero", "(", ")", ")", ")", "\n", "\n", "candidates", "=", "candidates", "[", "np", ".", "logical_not", "(", "np", ".", "in1d", "(", "candidates", "[", ":", ",", "0", "]", ",", "deg", ")", "|", "np", ".", "in1d", "(", "candidates", "[", ":", ",", "1", "]", ",", "deg", ")", ")", "]", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.generate_candidates_addition": [[103, 127], ["numpy.random.seed", "numpy.random.randint", "numpy.array", "list", "len", "set", "map"], "function", ["None"], ["", "def", "generate_candidates_addition", "(", "adj_matrix", ",", "n_candidates", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Generates candidate edge flips for addition (non-edge -> edge).\n\n    adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param n_candidates: int\n        Number of candidates to generate.\n    :param seed: int\n        Random seed\n    :return: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "num_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "\n", "candidates", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "num_nodes", ",", "[", "n_candidates", "*", "5", ",", "2", "]", ")", "\n", "candidates", "=", "candidates", "[", "candidates", "[", ":", ",", "0", "]", "<", "candidates", "[", ":", ",", "1", "]", "]", "\n", "candidates", "=", "candidates", "[", "adj_matrix", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "==", "0", "]", "\n", "candidates", "=", "np", ".", "array", "(", "list", "(", "set", "(", "map", "(", "tuple", ",", "candidates", ")", ")", ")", ")", "\n", "candidates", "=", "candidates", "[", ":", "n_candidates", "]", "\n", "\n", "assert", "len", "(", "candidates", ")", "==", "n_candidates", "\n", "\n", "return", "candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edges_to_sparse": [[129, 145], ["scipy.coo_matrix().tocsr", "numpy.ones", "scipy.coo_matrix"], "function", ["None"], ["", "def", "edges_to_sparse", "(", "edges", ",", "num_nodes", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"Create a sparse adjacency matrix from an array of edge indices and (optionally) values.\n\n    :param edges: array-like, shape [num_edges, 2]\n        Array with each row storing indices of an edge as (u, v).\n    :param num_nodes: int\n        Number of nodes in the resulting graph.\n    :param weights: array_like, shape [num_edges], optional, default None\n        Weights of the edges. If None, all edges weights are set to 1.\n    :return: sp.csr_matrix\n        Adjacency matrix in CSR format.\n    \"\"\"", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "np", ".", "ones", "(", "edges", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "return", "sp", ".", "coo_matrix", "(", "(", "weights", ",", "(", "edges", "[", ":", ",", "0", "]", ",", "edges", "[", ":", ",", "1", "]", ")", ")", ",", "shape", "=", "(", "num_nodes", ",", "num_nodes", ")", ")", ".", "tocsr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.evaluate_embedding_link_prediction": [[147, 175], ["sklearn.metrics.average_precision_score", "sklearn.preprocessing.normalize", "sklearn.metrics.roc_auc_score", "print"], "function", ["None"], ["", "def", "evaluate_embedding_link_prediction", "(", "adj_matrix", ",", "node_pairs", ",", "embedding_matrix", ",", "norm", "=", "True", ")", ":", "\n", "    ", "\"\"\"Evaluate the node embeddings on the link prediction task.\n\n    :param adj_matrix: sp.csr_matrix, shape [n_nodes, n_nodes]\n        Adjacency matrix of the graph\n    :param node_pairs:\n    :param embedding_matrix: np.ndarray, shape [n_nodes, embedding_dim]\n        Embedding matrix\n    :param norm: bool\n        Whether to normalize the embeddings\n    :return: float, float\n        Average precision (AP) score and area under ROC curve (AUC) score\n    \"\"\"", "\n", "if", "norm", ":", "\n", "        ", "embedding_matrix", "=", "normalize", "(", "embedding_matrix", ")", "\n", "\n", "", "true", "=", "adj_matrix", "[", "node_pairs", "[", ":", ",", "0", "]", ",", "node_pairs", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "scores", "=", "(", "embedding_matrix", "[", "node_pairs", "[", ":", ",", "0", "]", "]", "*", "embedding_matrix", "[", "node_pairs", "[", ":", ",", "1", "]", "]", ")", ".", "sum", "(", "1", ")", "\n", "# print(np.unique(true, return_counts=True))", "\n", "try", ":", "\n", "        ", "auc_score", "=", "roc_auc_score", "(", "true", ",", "scores", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "auc_score", "=", "0.00", "\n", "print", "(", "'ROC error'", ")", "\n", "\n", "", "ap_score", "=", "average_precision_score", "(", "true", ",", "scores", ")", "\n", "\n", "return", "auc_score", ",", "ap_score", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.evaluate_embedding_node_classification": [[177, 220], ["range", "numpy.array", "sklearn.preprocessing.normalize", "sklearn.model_selection.StratifiedShuffleSplit", "next", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "sklearn.linear_model.LogisticRegression.predict", "sklearn.metrics.f1_score", "sklearn.metrics.f1_score", "np.array.append", "np.array.mean", "np.array.std", "sklearn.model_selection.StratifiedShuffleSplit.split"], "function", ["None"], ["", "def", "evaluate_embedding_node_classification", "(", "embedding_matrix", ",", "labels", ",", "train_ratio", "=", "0.1", ",", "norm", "=", "True", ",", "seed", "=", "0", ",", "n_repeats", "=", "10", ")", ":", "\n", "    ", "\"\"\"Evaluate the node embeddings on the node classification task..\n\n    :param embedding_matrix: np.ndarray, shape [n_nodes, embedding_dim]\n        Embedding matrix\n    :param labels: np.ndarray, shape [n_nodes]\n        The ground truth labels\n    :param train_ratio: float\n        The fraction of labels to use for training\n    :param norm: bool\n        Whether to normalize the embeddings\n    :param seed: int\n        Random seed\n    :param n_repeats: int\n        Number of times to repeat the experiment\n    :return: [float, float], [float, float]\n        The mean and standard deviation of the f1_scores\n    \"\"\"", "\n", "if", "norm", ":", "\n", "        ", "embedding_matrix", "=", "normalize", "(", "embedding_matrix", ")", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "it_seed", "in", "range", "(", "n_repeats", ")", ":", "\n", "        ", "sss", "=", "StratifiedShuffleSplit", "(", "n_splits", "=", "1", ",", "test_size", "=", "1", "-", "train_ratio", ",", "random_state", "=", "seed", "+", "it_seed", ")", "\n", "split_train", ",", "split_test", "=", "next", "(", "sss", ".", "split", "(", "embedding_matrix", ",", "labels", ")", ")", "\n", "\n", "features_train", "=", "embedding_matrix", "[", "split_train", "]", "\n", "features_test", "=", "embedding_matrix", "[", "split_test", "]", "\n", "labels_train", "=", "labels", "[", "split_train", "]", "\n", "labels_test", "=", "labels", "[", "split_test", "]", "\n", "\n", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "1000", ",", "multi_class", "=", "'auto'", ")", "\n", "lr", ".", "fit", "(", "features_train", ",", "labels_train", ")", "\n", "\n", "lr_z_predict", "=", "lr", ".", "predict", "(", "features_test", ")", "\n", "f1_micro", "=", "f1_score", "(", "labels_test", ",", "lr_z_predict", ",", "average", "=", "'micro'", ")", "\n", "f1_macro", "=", "f1_score", "(", "labels_test", ",", "lr_z_predict", ",", "average", "=", "'macro'", ")", "\n", "\n", "results", ".", "append", "(", "[", "f1_micro", ",", "f1_macro", "]", ")", "\n", "\n", "", "results", "=", "np", ".", "array", "(", "results", ")", "\n", "\n", "return", "results", ".", "mean", "(", "0", ")", ",", "results", ".", "std", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.predict_L": [[222, 260], ["sklearn.model_selection.StratifiedShuffleSplit", "next", "numpy.zeros", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "sklearn.linear_model.LogisticRegression.predict", "sklearn.preprocessing.normalize", "sklearn.model_selection.StratifiedShuffleSplit.split"], "function", ["None"], ["", "def", "predict_L", "(", "embedding_matrix", ",", "labels", ",", "train_ratio", "=", "0.1", ",", "norm", "=", "True", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Evaluate the node embeddings on the node classification task..\n\n    :param embedding_matrix: np.ndarray, shape [n_nodes, embedding_dim]\n        Embedding matrix\n    :param labels: np.ndarray, shape [n_nodes]\n        The ground truth labels\n    :param train_ratio: float\n        The fraction of labels to use for training\n    :param norm: bool\n        Whether to normalize the embeddings\n    :param seed: int\n        Random seed\n    :return: [float, float], [float, float]\n        The mean and standard deviation of the f1_scores\n    \"\"\"", "\n", "if", "norm", ":", "\n", "        ", "embedding_matrix", "=", "normalize", "(", "embedding_matrix", ")", "\n", "\n", "", "sss", "=", "StratifiedShuffleSplit", "(", "n_splits", "=", "1", ",", "test_size", "=", "1", "-", "train_ratio", ",", "random_state", "=", "seed", ")", "\n", "split_train", ",", "split_test", "=", "next", "(", "sss", ".", "split", "(", "embedding_matrix", ",", "labels", ")", ")", "\n", "\n", "predictions", "=", "np", ".", "zeros", "(", "labels", ".", "shape", ")", "\n", "\n", "features_train", "=", "embedding_matrix", "[", "split_train", "]", "\n", "features_test", "=", "embedding_matrix", "[", "split_test", "]", "\n", "labels_train", "=", "labels", "[", "split_train", "]", "\n", "labels_test", "=", "labels", "[", "split_test", "]", "\n", "\n", "\n", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "1000", ",", "multi_class", "=", "'auto'", ")", "\n", "lr", ".", "fit", "(", "features_train", ",", "labels_train", ")", "\n", "\n", "lr_z_predict", "=", "lr", ".", "predict", "(", "features_test", ")", "\n", "predictions", "[", "split_train", "]", "=", "labels", "[", "split_train", "]", "\n", "predictions", "[", "split_test", "]", "=", "lr_z_predict", "\n", "\n", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.construct_line_graph": [[262, 286], ["numpy.column_stack", "scipy.eye().tocsr", "scipy.triu().nonzero", "E2.dot", "scipy.eye", "E2.dot", "scipy.eye", "scipy.triu", "E1.dot", "E1.dot"], "function", ["None"], ["", "def", "construct_line_graph", "(", "adj_matrix", ")", ":", "\n", "    ", "\"\"\"Construct a line graph from an undirected original graph.\n\n    Parameters\n    ----------\n    adj_matrix : sp.spmatrix [n_samples ,n_samples]\n        Symmetric binary adjacency matrix.\n\n    Returns\n    -------\n    L : sp.spmatrix, shape [A.nnz/2, A.nnz/2]\n        Symmetric binary adjacency matrix of the line graph.\n    \"\"\"", "\n", "N", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "edges", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj_matrix", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "e1", ",", "e2", "=", "edges", "[", ":", ",", "0", "]", ",", "edges", "[", ":", ",", "1", "]", "\n", "\n", "I", "=", "sp", ".", "eye", "(", "N", ")", ".", "tocsr", "(", ")", "\n", "E1", "=", "I", "[", "e1", "]", "\n", "E2", "=", "I", "[", "e2", "]", "\n", "\n", "L", "=", "E1", ".", "dot", "(", "E1", ".", "T", ")", "+", "E1", ".", "dot", "(", "E2", ".", "T", ")", "+", "E2", ".", "dot", "(", "E1", ".", "T", ")", "+", "E2", ".", "dot", "(", "E2", ".", "T", ")", "\n", "\n", "return", "L", "-", "2", "*", "sp", ".", "eye", "(", "L", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.load_dataset": [[288, 331], ["file_name.endswith", "numpy.load", "dict", "scipy.csr_matrix", "dict.get", "dict.get", "dict.get", "dict.get", "idx_to_node.tolist.tolist", "idx_to_attr.tolist.tolist", "idx_to_class.tolist.tolist"], "function", ["None"], ["", "def", "load_dataset", "(", "file_name", ")", ":", "\n", "    ", "\"\"\"\"Load a graph from a Numpy binary file.\n\n    :param file_name: str\n        Name of the file to load.\n\n    :return: dict\n        Dictionary that contains:\n            * 'A' : The adjacency matrix in sparse matrix format\n            * 'X' : The attribute matrix in sparse matrix format\n            * 'z' : The ground truth class labels\n            * Further dictionaries mapping node, class and attribute IDs\n    \"\"\"", "\n", "if", "not", "file_name", ".", "endswith", "(", "'.npz'", ")", ":", "\n", "        ", "file_name", "+=", "'.npz'", "\n", "", "with", "np", ".", "load", "(", "file_name", ",", "allow_pickle", "=", "True", ")", "as", "loader", ":", "\n", "        ", "loader", "=", "dict", "(", "loader", ")", "\n", "adj_matrix", "=", "sp", ".", "csr_matrix", "(", "(", "loader", "[", "'adj_data'", "]", ",", "loader", "[", "'adj_indices'", "]", ",", "\n", "loader", "[", "'adj_indptr'", "]", ")", ",", "shape", "=", "loader", "[", "'adj_shape'", "]", ")", "\n", "\n", "labels", "=", "loader", ".", "get", "(", "'labels'", ")", "\n", "\n", "graph", "=", "{", "\n", "'adj_matrix'", ":", "adj_matrix", ",", "\n", "'labels'", ":", "labels", "\n", "}", "\n", "\n", "idx_to_node", "=", "loader", ".", "get", "(", "'idx_to_node'", ")", "\n", "if", "idx_to_node", ":", "\n", "            ", "idx_to_node", "=", "idx_to_node", ".", "tolist", "(", ")", "\n", "graph", "[", "'idx_to_node'", "]", "=", "idx_to_node", "\n", "\n", "", "idx_to_attr", "=", "loader", ".", "get", "(", "'idx_to_attr'", ")", "\n", "if", "idx_to_attr", ":", "\n", "            ", "idx_to_attr", "=", "idx_to_attr", ".", "tolist", "(", ")", "\n", "graph", "[", "'idx_to_attr'", "]", "=", "idx_to_attr", "\n", "\n", "", "idx_to_class", "=", "loader", ".", "get", "(", "'idx_to_class'", ")", "\n", "if", "idx_to_class", ":", "\n", "            ", "idx_to_class", "=", "idx_to_class", ".", "tolist", "(", ")", "\n", "graph", "[", "'idx_to_class'", "]", "=", "idx_to_class", "\n", "\n", "", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.train_val_test_split_adjacency": [[333, 519], ["numpy.random.seed", "int", "numpy.arange", "numpy.random.permutation", "numpy.column_stack", "int", "int", "adj_matrix.maximum.max", "adj_matrix.maximum.min", "adj_matrix.maximum.diagonal().sum", "numpy.any", "scipy.tril().tocsr", "adj_matrix.maximum.eliminate_zeros", "edges_to_sparse.eliminate_zeros", "adj_sample.nonzero", "numpy.row_stack", "len", "numpy.array", "symmetrize", "symmetrize", "symmetrize", "symmetrize", "symmetrize", "adj_matrix.maximum.maximum", "set", "warnings.warn", "scipy.csgraph.minimum_spanning_tree", "adj_matrix.maximum.eliminate_zeros", "utils.edges_to_sparse", "numpy.random.randint", "numpy.random.randint", "numpy.row_stack", "len", "numpy.random.randint", "numpy.row_stack", "map", "set.intersection", "set", "set.intersection", "set", "set.intersection", "set", "set.intersection", "set", "len", "len", "adj_matrix.maximum.diagonal", "scipy.tril", "adj_matrix.maximum.sum", "utils.edge_cover", "numpy.column_stack", "numpy.any", "numpy.all", "numpy.column_stack", "symmetrize.append", "len", "len", "set", "set", "set", "set", "set", "len", "set", "len", "scipy.csgraph.connected_components", "ValueError", "ValueError", "numpy.column_stack", "numpy.row_stack", "len", "edges_to_sparse.nonzero", "int", "int", "numpy.unique", "numpy.column_stack", "utils.edges_to_sparse", "map", "map", "map", "map", "map", "map", "scipy.csgraph.connected_components", "adj_matrix.maximum.sum", "adj_matrix.maximum.sum", "numpy.row_stack", "numpy.unique", "numpy.row_stack", "map", "numpy.row_stack", "np.row_stack.flatten", "map", "adj_matrix[].tolil", "adj_matrix[].T.tolil"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edges_to_sparse", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edge_cover", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edges_to_sparse"], ["", "", "def", "train_val_test_split_adjacency", "(", "adj_matrix", ",", "p_val", "=", "0.10", ",", "p_test", "=", "0.05", ",", "seed", "=", "0", ",", "neg_mul", "=", "1", ",", "\n", "every_node", "=", "True", ",", "connected", "=", "False", ",", "undirected", "=", "False", ",", "\n", "use_edge_cover", "=", "True", ",", "set_ops", "=", "True", ",", "asserts", "=", "False", ")", ":", "\n", "    ", "\"\"\"Split the edges of the adjacency matrix into train, validation and test edges\n    and randomly samples equal amount of validation and test non-edges.\n\n    :param adj_matrix: scipy.sparse.spmatrix\n        Sparse unweighted adjacency matrix\n    :param p_val: float\n        Percentage of validation edges. Default p_val=0.10\n    :param p_test: float\n        Percentage of test edges. Default p_test=0.05\n    :param seed: int\n        Seed for numpy.random. Default seed=0\n    :param neg_mul: int\n        What multiplicity of negative samples (non-edges) to have in the test/validation set\n        w.r.t the number of edges, i.e. len(non-edges) = L * len(edges). Default neg_mul=1\n    :param every_node: bool\n        Make sure each node appears at least once in the train set. Default every_node=True\n    :param connected: bool\n        Make sure the training graph is still connected after the split\n    :param undirected: bool\n        Whether to make the split undirected, that is if (i, j) is in val/test set then (j, i) is there as well.\n        Default undirected=False\n    :param use_edge_cover: bool\n        Whether to use (approximate) edge_cover to find the minimum set of edges that cover every node.\n        Only active when every_node=True. Default use_edge_cover=True\n    :param set_ops: bool\n        Whether to use set operations to construction the test zeros. Default setwise_zeros=True\n        Otherwise use a while loop.\n    :param asserts: bool\n        Unit test like checks. Default asserts=False\n    :return:\n        train_ones: array-like, shape [n_train, 2]\n            Indices of the train edges\n        val_ones: array-like, shape [n_val, 2]\n            Indices of the validation edges\n        val_zeros: array-like, shape [n_val, 2]\n            Indices of the validation non-edges\n        test_ones: array-like, shape [n_test, 2]\n            Indices of the test edges\n        test_zeros: array-like, shape [n_test, 2]\n            Indices of the test non-edges\n    \"\"\"", "\n", "assert", "p_val", "+", "p_test", ">", "0", "\n", "assert", "adj_matrix", ".", "max", "(", ")", "==", "1", "# no weights", "\n", "assert", "adj_matrix", ".", "min", "(", ")", "==", "0", "# no negative edges", "\n", "assert", "adj_matrix", ".", "diagonal", "(", ")", ".", "sum", "(", ")", "==", "0", "# no self-loops", "\n", "assert", "not", "np", ".", "any", "(", "adj_matrix", ".", "sum", "(", "0", ")", ".", "A1", "+", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "==", "0", ")", "# no dangling nodes", "\n", "\n", "is_undirected", "=", "(", "adj_matrix", "!=", "adj_matrix", ".", "T", ")", ".", "nnz", "==", "0", "\n", "\n", "if", "undirected", ":", "\n", "        ", "assert", "is_undirected", "# make sure is directed", "\n", "adj_matrix", "=", "sp", ".", "tril", "(", "adj_matrix", ")", ".", "tocsr", "(", ")", "# consider only upper triangular", "\n", "adj_matrix", ".", "eliminate_zeros", "(", ")", "\n", "", "else", ":", "\n", "        ", "if", "is_undirected", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Graph appears to be undirected. Did you forgot to set undirected=True?'", ")", "\n", "\n", "", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "n_edges", "=", "adj_matrix", ".", "nnz", "\n", "n_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "s_train", "=", "int", "(", "n_edges", "*", "(", "1", "-", "p_val", "-", "p_test", ")", ")", "\n", "\n", "idx", "=", "np", ".", "arange", "(", "n_nodes", ")", "\n", "\n", "# hold some edges so each node appears at least once", "\n", "if", "every_node", ":", "\n", "        ", "if", "connected", ":", "\n", "            ", "assert", "sp", ".", "csgraph", ".", "connected_components", "(", "adj_matrix", ")", "[", "0", "]", "==", "1", "# make sure original graph is connected", "\n", "adj_hold", "=", "sp", ".", "csgraph", ".", "minimum_spanning_tree", "(", "adj_matrix", ")", "\n", "", "else", ":", "\n", "            ", "adj_matrix", ".", "eliminate_zeros", "(", ")", "# makes sure A.tolil().rows contains only indices of non-zero elements", "\n", "d", "=", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "\n", "\n", "if", "use_edge_cover", ":", "\n", "                ", "hold_edges", "=", "edge_cover", "(", "adj_matrix", ")", "\n", "\n", "# make sure the training percentage is not smaller than len(edge_cover)/E when every_node is set to True", "\n", "min_size", "=", "hold_edges", ".", "shape", "[", "0", "]", "\n", "if", "min_size", ">", "s_train", ":", "\n", "                    ", "raise", "ValueError", "(", "'Training percentage too low to guarantee every node. Min train size needed {:.2f}'", "\n", ".", "format", "(", "min_size", "/", "n_edges", ")", ")", "\n", "", "", "else", ":", "\n", "# make sure the training percentage is not smaller than N/E when every_node is set to True", "\n", "                ", "if", "n_nodes", ">", "s_train", ":", "\n", "                    ", "raise", "ValueError", "(", "'Training percentage too low to guarantee every node. Min train size needed {:.2f}'", "\n", ".", "format", "(", "n_nodes", "/", "n_edges", ")", ")", "\n", "\n", "", "hold_edges_d1", "=", "np", ".", "column_stack", "(", "\n", "(", "idx", "[", "d", ">", "0", "]", ",", "np", ".", "row_stack", "(", "map", "(", "np", ".", "random", ".", "choice", ",", "adj_matrix", "[", "d", ">", "0", "]", ".", "tolil", "(", ")", ".", "rows", ")", ")", ")", ")", "\n", "\n", "if", "np", ".", "any", "(", "d", "==", "0", ")", ":", "\n", "                    ", "hold_edges_d0", "=", "np", ".", "column_stack", "(", "\n", "(", "np", ".", "row_stack", "(", "map", "(", "np", ".", "random", ".", "choice", ",", "adj_matrix", "[", ":", ",", "d", "==", "0", "]", ".", "T", ".", "tolil", "(", ")", ".", "rows", ")", ")", ",", "\n", "idx", "[", "d", "==", "0", "]", ")", ")", "\n", "hold_edges", "=", "np", ".", "row_stack", "(", "(", "hold_edges_d0", ",", "hold_edges_d1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "hold_edges", "=", "hold_edges_d1", "\n", "\n", "", "", "if", "asserts", ":", "\n", "                ", "assert", "np", ".", "all", "(", "adj_matrix", "[", "hold_edges", "[", ":", ",", "0", "]", ",", "hold_edges", "[", ":", ",", "1", "]", "]", ")", "\n", "assert", "len", "(", "np", ".", "unique", "(", "hold_edges", ".", "flatten", "(", ")", ")", ")", "==", "n_nodes", "\n", "\n", "", "adj_hold", "=", "edges_to_sparse", "(", "hold_edges", ",", "n_nodes", ")", "\n", "\n", "", "adj_hold", "[", "adj_hold", ">", "1", "]", "=", "1", "\n", "adj_hold", ".", "eliminate_zeros", "(", ")", "\n", "adj_sample", "=", "adj_matrix", "-", "adj_hold", "\n", "\n", "s_train", "=", "s_train", "-", "adj_hold", ".", "nnz", "\n", "", "else", ":", "\n", "        ", "adj_sample", "=", "adj_matrix", "\n", "\n", "", "idx_ones", "=", "np", ".", "random", ".", "permutation", "(", "adj_sample", ".", "nnz", ")", "\n", "ones", "=", "np", ".", "column_stack", "(", "adj_sample", ".", "nonzero", "(", ")", ")", "\n", "train_ones", "=", "ones", "[", "idx_ones", "[", ":", "s_train", "]", "]", "\n", "test_ones", "=", "ones", "[", "idx_ones", "[", "s_train", ":", "]", "]", "\n", "\n", "# return back the held edges", "\n", "if", "every_node", ":", "\n", "        ", "train_ones", "=", "np", ".", "row_stack", "(", "(", "train_ones", ",", "np", ".", "column_stack", "(", "adj_hold", ".", "nonzero", "(", ")", ")", ")", ")", "\n", "\n", "", "n_test", "=", "len", "(", "test_ones", ")", "*", "neg_mul", "\n", "if", "set_ops", ":", "\n", "# generate slightly more completely random non-edge indices than needed and discard any that hit an edge", "\n", "# much faster compared a while loop", "\n", "# in the future: estimate the multiplicity (currently fixed 1.3/2.3) based on A_obs.nnz", "\n", "        ", "if", "undirected", ":", "\n", "            ", "random_sample", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n_nodes", ",", "[", "int", "(", "2.3", "*", "n_test", ")", ",", "2", "]", ")", "\n", "random_sample", "=", "random_sample", "[", "random_sample", "[", ":", ",", "0", "]", ">", "random_sample", "[", ":", ",", "1", "]", "]", "\n", "", "else", ":", "\n", "            ", "random_sample", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n_nodes", ",", "[", "int", "(", "1.3", "*", "n_test", ")", ",", "2", "]", ")", "\n", "random_sample", "=", "random_sample", "[", "random_sample", "[", ":", ",", "0", "]", "!=", "random_sample", "[", ":", ",", "1", "]", "]", "\n", "\n", "# discard ones", "\n", "", "random_sample", "=", "random_sample", "[", "adj_matrix", "[", "random_sample", "[", ":", ",", "0", "]", ",", "random_sample", "[", ":", ",", "1", "]", "]", ".", "A1", "==", "0", "]", "\n", "# discard duplicates", "\n", "random_sample", "=", "random_sample", "[", "np", ".", "unique", "(", "random_sample", "[", ":", ",", "0", "]", "*", "n_nodes", "+", "random_sample", "[", ":", ",", "1", "]", ",", "return_index", "=", "True", ")", "[", "1", "]", "]", "\n", "# only take as much as needed", "\n", "test_zeros", "=", "np", ".", "row_stack", "(", "random_sample", ")", "[", ":", "n_test", "]", "\n", "assert", "test_zeros", ".", "shape", "[", "0", "]", "==", "n_test", "\n", "", "else", ":", "\n", "        ", "test_zeros", "=", "[", "]", "\n", "while", "len", "(", "test_zeros", ")", "<", "n_test", ":", "\n", "            ", "i", ",", "j", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n_nodes", ",", "2", ")", "\n", "if", "adj_matrix", "[", "i", ",", "j", "]", "==", "0", "and", "(", "not", "undirected", "or", "i", ">", "j", ")", "and", "(", "i", ",", "j", ")", "not", "in", "test_zeros", ":", "\n", "                ", "test_zeros", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "", "", "test_zeros", "=", "np", ".", "array", "(", "test_zeros", ")", "\n", "\n", "# split the test set into validation and test set", "\n", "", "s_val_ones", "=", "int", "(", "len", "(", "test_ones", ")", "*", "p_val", "/", "(", "p_val", "+", "p_test", ")", ")", "\n", "s_val_zeros", "=", "int", "(", "len", "(", "test_zeros", ")", "*", "p_val", "/", "(", "p_val", "+", "p_test", ")", ")", "\n", "\n", "val_ones", "=", "test_ones", "[", ":", "s_val_ones", "]", "\n", "test_ones", "=", "test_ones", "[", "s_val_ones", ":", "]", "\n", "\n", "val_zeros", "=", "test_zeros", "[", ":", "s_val_zeros", "]", "\n", "test_zeros", "=", "test_zeros", "[", "s_val_zeros", ":", "]", "\n", "\n", "if", "undirected", ":", "\n", "# put (j, i) edges for every (i, j) edge in the respective sets and form back original A", "\n", "        ", "symmetrize", "=", "lambda", "x", ":", "np", ".", "row_stack", "(", "(", "x", ",", "np", ".", "column_stack", "(", "(", "x", "[", ":", ",", "1", "]", ",", "x", "[", ":", ",", "0", "]", ")", ")", ")", ")", "\n", "train_ones", "=", "symmetrize", "(", "train_ones", ")", "\n", "val_ones", "=", "symmetrize", "(", "val_ones", ")", "\n", "val_zeros", "=", "symmetrize", "(", "val_zeros", ")", "\n", "test_ones", "=", "symmetrize", "(", "test_ones", ")", "\n", "test_zeros", "=", "symmetrize", "(", "test_zeros", ")", "\n", "adj_matrix", "=", "adj_matrix", ".", "maximum", "(", "adj_matrix", ".", "T", ")", "\n", "\n", "", "if", "asserts", ":", "\n", "        ", "set_of_train_ones", "=", "set", "(", "map", "(", "tuple", ",", "train_ones", ")", ")", "\n", "assert", "train_ones", ".", "shape", "[", "0", "]", "+", "test_ones", ".", "shape", "[", "0", "]", "+", "val_ones", ".", "shape", "[", "0", "]", "==", "adj_matrix", ".", "nnz", "\n", "assert", "(", "edges_to_sparse", "(", "np", ".", "row_stack", "(", "(", "train_ones", ",", "test_ones", ",", "val_ones", ")", ")", ",", "n_nodes", ")", "!=", "adj_matrix", ")", ".", "nnz", "==", "0", "\n", "assert", "set_of_train_ones", ".", "intersection", "(", "set", "(", "map", "(", "tuple", ",", "test_ones", ")", ")", ")", "==", "set", "(", ")", "\n", "assert", "set_of_train_ones", ".", "intersection", "(", "set", "(", "map", "(", "tuple", ",", "val_ones", ")", ")", ")", "==", "set", "(", ")", "\n", "assert", "set_of_train_ones", ".", "intersection", "(", "set", "(", "map", "(", "tuple", ",", "test_zeros", ")", ")", ")", "==", "set", "(", ")", "\n", "assert", "set_of_train_ones", ".", "intersection", "(", "set", "(", "map", "(", "tuple", ",", "val_zeros", ")", ")", ")", "==", "set", "(", ")", "\n", "assert", "len", "(", "set", "(", "map", "(", "tuple", ",", "test_zeros", ")", ")", ")", "==", "len", "(", "test_ones", ")", "*", "neg_mul", "\n", "assert", "len", "(", "set", "(", "map", "(", "tuple", ",", "val_zeros", ")", ")", ")", "==", "len", "(", "val_ones", ")", "*", "neg_mul", "\n", "assert", "not", "connected", "or", "sp", ".", "csgraph", ".", "connected_components", "(", "adj_hold", ")", "[", "0", "]", "==", "1", "\n", "assert", "not", "every_node", "or", "(", "(", "adj_hold", "-", "adj_matrix", ")", ">", "0", ")", ".", "sum", "(", ")", "==", "0", "\n", "\n", "", "return", "train_ones", ",", "val_ones", ",", "val_zeros", ",", "test_ones", ",", "test_zeros", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.edge_cover": [[521, 578], ["np.row_stack.append", "np.row_stack.append", "numpy.row_stack", "set", "set", "numpy.column_stack", "numpy.setdiff1d", "numpy.row_stack", "adj_matrix.sum", "adj_matrix.sum", "numpy.where", "numpy.where", "numpy.column_stack", "numpy.column_stack", "map", "np.row_stack.flatten", "adj_matrix.nonzero", "numpy.arange", "list", "list", "len", "np.row_stack.append", "len", "np.row_stack.append", "adj_matrix[].sum", "len", "len", "len", "len", "d_in[].argsort", "set.add", "set.add", "set.add", "len", "numpy.column_stack", "numpy.column_stack", "set", "numpy.unique", "map", "adj_matrix[].argmax", "adj_matrix[].argmax", "adj_matrix[].argmax", "adj_matrix[].argmax"], "function", ["None"], ["", "def", "edge_cover", "(", "adj_matrix", ")", ":", "\n", "    ", "\"\"\"Approximately compute minimum edge cover.\n\n    Edge cover of a graph is a set of edges such that every vertex of the graph is incident\n    to at least one edge of the set. Minimum edge cover is an  edge cover of minimum size.\n\n    :param adj_matrix: sp.spmatrix\n        Sparse adjacency matrix\n    :return: array-like, shape [?, 2]\n        The edges the form the edge cover\n    \"\"\"", "\n", "n_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "d_in", "=", "adj_matrix", ".", "sum", "(", "0", ")", ".", "A1", "\n", "d_out", "=", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "\n", "\n", "# make sure to include singleton nodes (nodes with one incoming or one outgoing edge)", "\n", "one_in", "=", "np", ".", "where", "(", "(", "d_in", "==", "1", ")", "&", "(", "d_out", "==", "0", ")", ")", "[", "0", "]", "\n", "one_out", "=", "np", ".", "where", "(", "(", "d_in", "==", "0", ")", "&", "(", "d_out", "==", "1", ")", ")", "[", "0", "]", "\n", "\n", "edges", "=", "[", "]", "\n", "edges", ".", "append", "(", "np", ".", "column_stack", "(", "(", "adj_matrix", "[", ":", ",", "one_in", "]", ".", "argmax", "(", "0", ")", ".", "A1", ",", "one_in", ")", ")", ")", "\n", "edges", ".", "append", "(", "np", ".", "column_stack", "(", "(", "one_out", ",", "adj_matrix", "[", "one_out", "]", ".", "argmax", "(", "1", ")", ".", "A1", ")", ")", ")", "\n", "edges", "=", "np", ".", "row_stack", "(", "edges", ")", "\n", "\n", "edge_cover_set", "=", "set", "(", "map", "(", "tuple", ",", "edges", ")", ")", "\n", "nodes", "=", "set", "(", "edges", ".", "flatten", "(", ")", ")", "\n", "\n", "# greedly add other edges such that both end-point are not yet in the edge_cover_set", "\n", "cands", "=", "np", ".", "column_stack", "(", "adj_matrix", ".", "nonzero", "(", ")", ")", "\n", "for", "u", ",", "v", "in", "cands", "[", "d_in", "[", "cands", "[", ":", ",", "1", "]", "]", ".", "argsort", "(", ")", "]", ":", "\n", "        ", "if", "u", "not", "in", "nodes", "and", "v", "not", "in", "nodes", "and", "u", "!=", "v", ":", "\n", "            ", "edge_cover_set", ".", "add", "(", "(", "u", ",", "v", ")", ")", "\n", "nodes", ".", "add", "(", "u", ")", "\n", "nodes", ".", "add", "(", "v", ")", "\n", "", "if", "len", "(", "nodes", ")", "==", "n_nodes", ":", "\n", "            ", "break", "\n", "\n", "# add a single edge for the rest of the nodes not covered so far", "\n", "", "", "not_covered", "=", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "n_nodes", ")", ",", "list", "(", "nodes", ")", ")", "\n", "edges", "=", "[", "list", "(", "edge_cover_set", ")", "]", "\n", "not_covered_out", "=", "not_covered", "[", "d_out", "[", "not_covered", "]", ">", "0", "]", "\n", "\n", "if", "len", "(", "not_covered_out", ")", ">", "0", ":", "\n", "        ", "edges", ".", "append", "(", "np", ".", "column_stack", "(", "(", "not_covered_out", ",", "adj_matrix", "[", "not_covered_out", "]", ".", "argmax", "(", "1", ")", ".", "A1", ")", ")", ")", "\n", "\n", "", "not_covered_in", "=", "not_covered", "[", "d_out", "[", "not_covered", "]", "==", "0", "]", "\n", "if", "len", "(", "not_covered_in", ")", ">", "0", ":", "\n", "        ", "edges", ".", "append", "(", "np", ".", "column_stack", "(", "(", "adj_matrix", "[", ":", ",", "not_covered_in", "]", ".", "argmax", "(", "0", ")", ".", "A1", ",", "not_covered_in", ")", ")", ")", "\n", "\n", "", "edges", "=", "np", ".", "row_stack", "(", "edges", ")", "\n", "\n", "# make sure that we've indeed computed an edge_cover", "\n", "assert", "adj_matrix", "[", "edges", "[", ":", ",", "0", "]", ",", "edges", "[", ":", ",", "1", "]", "]", ".", "sum", "(", ")", "==", "len", "(", "edges", ")", "\n", "assert", "len", "(", "set", "(", "map", "(", "tuple", ",", "edges", ")", ")", ")", "==", "len", "(", "edges", ")", "\n", "assert", "len", "(", "np", ".", "unique", "(", "edges", ")", ")", "==", "n_nodes", "\n", "\n", "return", "edges", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.standardize": [[580, 607], ["adj_matrix.maximum.maximum", "scipy.csgraph.connected_components", "numpy.unique", "c_counts.argmax"], "function", ["None"], ["", "def", "standardize", "(", "adj_matrix", ",", "labels", ")", ":", "\n", "    ", "\"\"\"\n    Make the graph undirected and select only the nodes\n     belonging to the largest connected component.\n\n    :param adj_matrix: sp.spmatrix\n        Sparse adjacency matrix\n    :param labels: array-like, shape [n]\n\n    :return:\n        standardized_adj_matrix: sp.spmatrix\n            Standardized sparse adjacency matrix.\n        standardized_labels: array-like, shape [?]\n            Labels for the selected nodes.\n    \"\"\"", "\n", "# make the graph undirected", "\n", "adj_matrix", "=", "adj_matrix", ".", "maximum", "(", "adj_matrix", ".", "T", ")", "\n", "\n", "# select the largest connected component", "\n", "_", ",", "components", "=", "sp", ".", "csgraph", ".", "connected_components", "(", "adj_matrix", ")", "\n", "c_ids", ",", "c_counts", "=", "np", ".", "unique", "(", "components", ",", "return_counts", "=", "True", ")", "\n", "id_max_component", "=", "c_ids", "[", "c_counts", ".", "argmax", "(", ")", "]", "\n", "select", "=", "components", "==", "id_max_component", "\n", "standardized_adj_matrix", "=", "adj_matrix", "[", "select", "]", "[", ":", ",", "select", "]", "\n", "standardized_labels", "=", "labels", "[", "select", "]", "\n", "\n", "return", "standardized_adj_matrix", ",", "standardized_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.perturbation_top_flips": [[18, 55], ["numpy.diag", "scipy.eigh", "perturbation_attack.estimate_loss_with_delta_eigenvals", "perturbation_attack.estimate_loss_with_supervision_type2", "adj_matrix.toarray", "adj_matrix.sum", "estimate_loss_with_delta_eigenvals.argsort", "estimate_loss_with_delta_eigenvals.argsort"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_delta_eigenvals", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_supervision_type2"], ["def", "perturbation_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "L", "=", "None", ",", "mode", "=", "'supervised'", ")", ":", "\n", "    ", "\"\"\"Selects the top (n_flips) number of flips using our perturbation attack.\n\n    :param mode: str\n        Swtiches b/w sota and otherwise\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param n_flips: int\n        Number of flips to select\n    :param dim: int\n        Dimensionality of the embeddings.\n    :param window_size: int\n        Co-occurence window size.\n    :param L: np.ndarray, shape[?, ?]\n        Binary label matrix of given graph.\n    :return: np.ndarray, shape [?, 2]\n        The top edge flips from the candidate set\n    \"\"\"", "\n", "n_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "# vector indicating whether we are adding an edge (+1) or removing an edge (-1)", "\n", "delta_w", "=", "1", "-", "2", "*", "adj_matrix", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "if", "mode", "!=", "'supervised'", ":", "\n", "# generalized eigenvalues/eigenvectors", "\n", "        ", "deg_matrix", "=", "np", ".", "diag", "(", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", ")", "\n", "vals_org", ",", "vecs_org", "=", "spl", ".", "eigh", "(", "adj_matrix", ".", "toarray", "(", ")", ",", "deg_matrix", ")", "\n", "loss_for_candidates", "=", "estimate_loss_with_delta_eigenvals", "(", "candidates", ",", "delta_w", ",", "vals_org", ",", "vecs_org", ",", "n_nodes", ",", "dim", ",", "window_size", ")", "\n", "top_flips", "=", "candidates", "[", "loss_for_candidates", ".", "argsort", "(", ")", "[", "-", "n_flips", ":", "]", "]", "\n", "", "else", ":", "\n", "        ", "loss_for_candidates1", "=", "estimate_loss_with_supervision_type2", "(", "candidates", ",", "delta_w", ",", "adj_matrix", ",", "L", ",", "n_nodes", ")", "\n", "\n", "loss_for_candidates", "=", "loss_for_candidates1", "\n", "top_flips", "=", "candidates", "[", "loss_for_candidates", ".", "argsort", "(", ")", "[", "-", "n_flips", ":", "]", "]", "\n", "\n", "", "return", "top_flips", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_supervision": [[57, 93], ["numpy.zeros", "A.copy().todense", "numpy.matmul", "numpy.ones", "enumerate", "len", "numpy.sum", "numpy.sum", "numpy.linalg.norm", "A.copy", "numpy.multiply"], "function", ["None"], ["", "def", "estimate_loss_with_supervision", "(", "candidates", ",", "flip_indicator", ",", "A", ",", "L", ",", "n_nodes", ")", ":", "\n", "    ", "\"\"\"\n    Compute community loss for every candidate flip\n\n    :param candidates: np.ndarray, shape[?, 2]\n        Candidate set for edge flips\n    :param flip_indicator: np.ndarray, shape[?]\n        Vector indicating whether we add an edge or remove an edge\n    :param A: np.ndarray, shape[?, ?]\n        Adjacency matrix of given graph\n    :param n_nodes: int\n        Number of nodes\n    :return: np.ndarray, shape[?]\n        Loss values for each candidate\n    \"\"\"", "\n", "\n", "assert", "L", "is", "not", "None", ",", "\"Label Matrix cannot be empty for this loss!\"", "\n", "loss_val", "=", "np", ".", "zeros", "(", "len", "(", "candidates", ")", ")", "\n", "temp_A", "=", "A", ".", "copy", "(", ")", ".", "todense", "(", ")", "\n", "midval", "=", "np", ".", "matmul", "(", "temp_A", ",", "L", ")", "\n", "del", "temp_A", "\n", "idealvec", "=", "np", ".", "ones", "(", "n_nodes", ")", "\n", "for", "idx", ",", "(", "i", ",", "j", ")", "in", "enumerate", "(", "candidates", ")", ":", "\n", "        ", "midval", "[", "i", "]", "=", "midval", "[", "i", "]", "+", "flip_indicator", "[", "idx", "]", "*", "L", "[", "j", "]", "\n", "midval", "[", "j", "]", "=", "midval", "[", "j", "]", "+", "flip_indicator", "[", "idx", "]", "*", "L", "[", "i", "]", "\n", "# temp_A[i, j] = temp_A[i, j] + flip_indicator[idx]", "\n", "# temp_A[j, i] = temp_A[j, i] + flip_indicator[idx]", "\n", "numerator", "=", "np", ".", "sum", "(", "np", ".", "multiply", "(", "midval", ",", "L", ")", ",", "axis", "=", "1", ")", "\n", "denominator", "=", "np", ".", "sum", "(", "midval", ",", "axis", "=", "1", ")", "\n", "muvec", "=", "numerator", "/", "denominator", "\n", "loss_val", "[", "idx", "]", "=", "np", ".", "linalg", ".", "norm", "(", "idealvec", "-", "muvec", ")", "\n", "# temp_A[j, i] = temp_A[j, i] - flip_indicator[idx]", "\n", "# temp_A[i, j] = temp_A[i, j] - flip_indicator[idx]", "\n", "midval", "[", "i", "]", "=", "midval", "[", "i", "]", "-", "flip_indicator", "[", "idx", "]", "*", "L", "[", "j", "]", "\n", "midval", "[", "j", "]", "=", "midval", "[", "j", "]", "-", "flip_indicator", "[", "idx", "]", "*", "L", "[", "i", "]", "\n", "", "return", "loss_val", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_supervision_type2": [[95, 134], ["numpy.zeros", "A.copy().todense", "numpy.matmul", "numpy.sum", "numpy.sum", "numpy.linalg.norm", "numpy.ones", "enumerate", "len", "numpy.multiply", "numpy.sum", "numpy.sum", "A.copy", "numpy.multiply", "numpy.linalg.norm"], "function", ["None"], ["", "def", "estimate_loss_with_supervision_type2", "(", "candidates", ",", "flip_indicator", ",", "A", ",", "L", ",", "n_nodes", ")", ":", "\n", "    ", "\"\"\"\n    Compute community loss for every candidate flip\n\n    :param candidates: np.ndarray, shape[?, 2]\n        Candidate set for edge flips\n    :param flip_indicator: np.ndarray, shape[?]\n        Vector indicating whether we add an edge or remove an edge\n    :param A: np.ndarray, shape[?, ?]\n        Adjacency matrix of given graph\n    :param n_nodes: int\n        Number of nodes\n    :return: np.ndarray, shape[?]\n        Loss values for each candidate\n    \"\"\"", "\n", "\n", "assert", "L", "is", "not", "None", ",", "\"Label Matrix cannot be empty for this loss!\"", "\n", "loss_val", "=", "np", ".", "zeros", "(", "len", "(", "candidates", ")", ")", "\n", "temp_A", "=", "A", ".", "copy", "(", ")", ".", "todense", "(", ")", "\n", "midval", "=", "np", ".", "matmul", "(", "temp_A", ",", "L", ")", "\n", "del", "temp_A", "\n", "numerator", "=", "np", ".", "sum", "(", "np", ".", "multiply", "(", "midval", ",", "L", ")", ",", "axis", "=", "1", ")", "\n", "denominator", "=", "np", ".", "sum", "(", "midval", ",", "axis", "=", "1", ")", "\n", "nmu", "=", "np", ".", "linalg", ".", "norm", "(", "numerator", "/", "denominator", ")", "\n", "idealvec", "=", "np", ".", "ones", "(", "n_nodes", ")", "\n", "for", "idx", ",", "(", "i", ",", "j", ")", "in", "enumerate", "(", "candidates", ")", ":", "\n", "        ", "midval", "[", "i", "]", "=", "midval", "[", "i", "]", "+", "flip_indicator", "[", "idx", "]", "*", "L", "[", "j", "]", "\n", "midval", "[", "j", "]", "=", "midval", "[", "j", "]", "+", "flip_indicator", "[", "idx", "]", "*", "L", "[", "i", "]", "\n", "# temp_A[i, j] = temp_A[i, j] + flip_indicator[idx]", "\n", "# temp_A[j, i] = temp_A[j, i] + flip_indicator[idx]", "\n", "numerator", "=", "np", ".", "sum", "(", "np", ".", "multiply", "(", "midval", ",", "L", ")", ",", "axis", "=", "1", ")", "\n", "denominator", "=", "np", ".", "sum", "(", "midval", ",", "axis", "=", "1", ")", "\n", "muvec", "=", "numerator", "/", "denominator", "\n", "loss_val", "[", "idx", "]", "=", "(", "nmu", "-", "np", ".", "linalg", ".", "norm", "(", "muvec", ")", ")", "\n", "# temp_A[j, i] = temp_A[j, i] - flip_indicator[idx]", "\n", "# temp_A[i, j] = temp_A[i, j] - flip_indicator[idx]", "\n", "midval", "[", "i", "]", "=", "midval", "[", "i", "]", "-", "flip_indicator", "[", "idx", "]", "*", "L", "[", "j", "]", "\n", "midval", "[", "j", "]", "=", "midval", "[", "j", "]", "-", "flip_indicator", "[", "idx", "]", "*", "L", "[", "i", "]", "\n", "", "return", "loss_val", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_delta_eigenvals": [[136, 170], ["numba.jit", "numpy.zeros", "range", "len", "len", "sum_of_powers", "numpy.sqrt", "numpy.sum", "numpy.sort"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.sum_of_powers"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "estimate_loss_with_delta_eigenvals", "(", "candidates", ",", "flip_indicator", ",", "vals_org", ",", "vecs_org", ",", "n_nodes", ",", "dim", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"Computes the estimated loss using the change in the eigenvalues for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips,\n    :param flip_indicator: np.ndarray, shape [?]\n        Vector indicating whether we are adding an edge (+1) or removing an edge (-1)\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :param n_nodes: int\n        Number of nodes\n    :param dim: int\n        Embedding dimension\n    :param window_size: int\n        Size of the window\n    :return: np.ndarray, shape [?]\n        Estimated loss for each candidate flip\n    \"\"\"", "\n", "\n", "loss_est", "=", "np", ".", "zeros", "(", "len", "(", "candidates", ")", ")", "\n", "for", "x", "in", "range", "(", "len", "(", "candidates", ")", ")", ":", "\n", "        ", "i", ",", "j", "=", "candidates", "[", "x", "]", "\n", "vals_est", "=", "vals_org", "+", "flip_indicator", "[", "x", "]", "*", "(", "\n", "2", "*", "vecs_org", "[", "i", "]", "*", "vecs_org", "[", "j", "]", "-", "vals_org", "*", "(", "vecs_org", "[", "i", "]", "**", "2", "+", "vecs_org", "[", "j", "]", "**", "2", ")", ")", "\n", "\n", "vals_sum_powers", "=", "sum_of_powers", "(", "vals_est", ",", "window_size", ")", "\n", "\n", "loss_ij", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "sort", "(", "vals_sum_powers", "**", "2", ")", "[", ":", "n_nodes", "-", "dim", "]", ")", ")", "\n", "loss_est", "[", "x", "]", "=", "loss_ij", "\n", "\n", "", "return", "loss_est", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_delta_eigenvecs": [[172, 210], ["numba.jit", "len", "numpy.zeros", "range", "range", "numpy.dot"], "function", ["None"], ["", "@", "numba", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "estimate_delta_eigenvecs", "(", "candidates", ",", "flip_indicator", ",", "degrees", ",", "vals_org", ",", "vecs_org", ",", "delta_eigvals", ",", "pinvs", ")", ":", "\n", "    ", "\"\"\"Computes the estimated change in the eigenvectors for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips,\n    :param flip_indicator: np.ndarray, shape [?]\n        Vector indicating whether we are adding an edge (+1) or removing an edge (-1)\n    :param degrees: np.ndarray, shape [n]\n        Vector of node degrees.\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :param delta_eigvals: np.ndarray, shape [?, n]\n        Estimated change in the eigenvalues for all candidate edge flips\n    :param pinvs: np.ndarray, shape [k, n, n]\n        Precomputed pseudo-inverse matrices for every dimension\n    :return: np.ndarray, shape [?, n, k]\n        Estimated change in the eigenvectors for all candidate edge flips\n    \"\"\"", "\n", "n_nodes", ",", "dim", "=", "vecs_org", ".", "shape", "\n", "n_candidates", "=", "len", "(", "candidates", ")", "\n", "delta_eigvecs", "=", "np", ".", "zeros", "(", "(", "n_candidates", ",", "dim", ",", "n_nodes", ")", ")", "\n", "\n", "for", "k", "in", "range", "(", "dim", ")", ":", "\n", "        ", "cur_eigvecs", "=", "vecs_org", "[", ":", ",", "k", "]", "\n", "cur_eigvals", "=", "vals_org", "[", "k", "]", "\n", "for", "c", "in", "range", "(", "n_candidates", ")", ":", "\n", "            ", "degree_eigvec", "=", "(", "-", "delta_eigvals", "[", "c", ",", "k", "]", "*", "degrees", ")", "*", "cur_eigvecs", "\n", "i", ",", "j", "=", "candidates", "[", "c", "]", "\n", "\n", "degree_eigvec", "[", "i", "]", "+=", "cur_eigvecs", "[", "j", "]", "-", "cur_eigvals", "*", "cur_eigvecs", "[", "i", "]", "\n", "degree_eigvec", "[", "j", "]", "+=", "cur_eigvecs", "[", "i", "]", "-", "cur_eigvals", "*", "cur_eigvecs", "[", "j", "]", "\n", "\n", "delta_eigvecs", "[", "c", ",", "k", "]", "=", "np", ".", "dot", "(", "pinvs", "[", "k", "]", ",", "flip_indicator", "[", "c", "]", "*", "degree_eigvec", ")", "\n", "\n", "", "", "return", "delta_eigvecs", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_delta_eigvals": [[212, 234], ["None"], "function", ["None"], ["", "def", "estimate_delta_eigvals", "(", "candidates", ",", "adj_matrix", ",", "vals_org", ",", "vecs_org", ")", ":", "\n", "    ", "\"\"\"Computes the estimated change in the eigenvalues for every candidate edge flip.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param vecs_org: np.ndarray, shape [n, n]\n        The generalized eigenvectors of the clean graph\n    :return: np.ndarray, shape [?, n]\n        Estimated change in the eigenvalues for all candidate edge flips\n    \"\"\"", "\n", "# vector indicating whether we are adding an edge (+1) or removing an edge (-1)", "\n", "delta_w", "=", "1", "-", "2", "*", "adj_matrix", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "delta_eigvals", "=", "delta_w", "[", ":", ",", "None", "]", "*", "(", "2", "*", "vecs_org", "[", "candidates", "[", ":", ",", "0", "]", "]", "*", "vecs_org", "[", "candidates", "[", ":", ",", "1", "]", "]", "\n", "-", "vals_org", "*", "(", "\n", "vecs_org", "[", "candidates", "[", ":", ",", "0", "]", "]", "**", "2", "+", "vecs_org", "[", "candidates", "[", ":", ",", "1", "]", "]", "**", "2", ")", ")", "\n", "\n", "return", "delta_eigvals", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.get_pinvs": [[236, 266], ["scipy.diags", "range", "numpy.stack", "range", "print", "last.dot.dot", "adj_matrix.sum", "pinvs.append", "print", "pinvs.append", "numpy.linalg.pinv", "scipy.pinv"], "function", ["None"], ["", "@", "mem", ".", "cache", "\n", "def", "get_pinvs", "(", "adj_matrix", ",", "vals_org", ",", "dim", ")", ":", "\n", "    ", "\"\"\" Precomputes the pseudo-inverse matrices for every dimension.\n\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param vals_org: np.ndarray, shape [n]\n        The generalized eigenvalues of the clean graph\n    :param dim: int\n        Embedding dimension\n    :return:  np.ndarray, shape [k, n, n]\n        Pseudo-inverse matrices for every dimension\n    \"\"\"", "\n", "deg_matrix", "=", "sp", ".", "diags", "(", "adj_matrix", ".", "sum", "(", "0", ")", ".", "A1", ")", "\n", "pinvs", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "dim", ")", ":", "\n", "        ", "print", "(", "k", ")", "\n", "try", ":", "\n", "            ", "pinvs", ".", "append", "(", "-", "np", ".", "linalg", ".", "pinv", "(", "(", "adj_matrix", "-", "vals_org", "[", "k", "]", "*", "deg_matrix", ")", ".", "toarray", "(", ")", ")", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "print", "(", "'error'", ")", "\n", "pinvs", ".", "append", "(", "-", "spl", ".", "pinv", "(", "(", "adj_matrix", "-", "vals_org", "[", "k", "]", "*", "deg_matrix", ")", ".", "toarray", "(", ")", ")", ")", "\n", "\n", "", "", "return", "np", ".", "stack", "(", "pinvs", ")", "\n", "\n", "sum_of_powers", "=", "transition_matrix", "\n", "last", "=", "transition_matrix", "\n", "for", "i", "in", "range", "(", "1", ",", "pow", ")", ":", "\n", "        ", "last", "=", "last", ".", "dot", "(", "transition_matrix", ")", "\n", "sum_of_powers", "+=", "last", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_perturbation_gradient": [[268, 303], ["perturbation_attack._get_gradient_estimator", "tensorflow.ConfigProto", "tensorflow.Session", "tf.Session.run", "scipy.csr_matrix", "scipy.linalg.eigsh", "tf.Session.run", "adj_matrix.toarray", "adj_matrix.toarray"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack._get_gradient_estimator"], ["", "", "def", "estimate_loss_with_perturbation_gradient", "(", "candidates", ",", "adj_matrix", ",", "n_nodes", ",", "window_size", ",", "dim", ",", "num_neg_samples", ")", ":", "\n", "    ", "\"\"\"Computes the estimated loss using the gradient defined with eigenvalue perturbation.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param n_nodes: int\n        Number of nodes in the graph\n    :param window_size: int\n        Size of the window\n    :param dim: int\n        Size of the embedding\n    :param num_neg_samples: int\n        Number of negative samples\n    :return:\n    \"\"\"", "\n", "adj_matrix_tf", ",", "logM_tf", ",", "eigenvecs_tf", ",", "loss", ",", "adj_matrix_grad_tf", "=", "_get_gradient_estimator", "(", "\n", "n_nodes", ",", "window_size", ",", "dim", ",", "num_neg_samples", ")", "\n", "config", "=", "tf", ".", "ConfigProto", "(", ")", "\n", "config", ".", "gpu_options", ".", "allow_growth", "=", "True", "\n", "sess", "=", "tf", ".", "Session", "(", "config", "=", "config", ")", "\n", "\n", "logM", "=", "sess", ".", "run", "(", "logM_tf", ",", "{", "adj_matrix_tf", ":", "adj_matrix", ".", "toarray", "(", ")", "}", ")", "\n", "logM", "=", "sp", ".", "csr_matrix", "(", "logM", ")", "\n", "eigenvals", ",", "eigenvecs", "=", "sp", ".", "linalg", ".", "eigsh", "(", "logM", ",", "dim", ")", "\n", "\n", "adj_matrix_grad", "=", "sess", ".", "run", "(", "adj_matrix_grad_tf", ",", "{", "adj_matrix_grad_tf", ":", "adj_matrix", ".", "toarray", "(", ")", ",", "eigenvecs_tf", ":", "eigenvecs", "}", ")", "[", "\n", "0", "]", "\n", "sig_est_grad", "=", "adj_matrix_grad", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", "+", "adj_matrix_grad", "[", "\n", "candidates", "[", ":", ",", "1", "]", ",", "candidates", "[", ":", ",", "0", "]", "]", "\n", "ignore", "=", "sig_est_grad", "<", "0", "\n", "sig_est_grad", "[", "ignore", "]", "=", "-", "1", "\n", "\n", "return", "sig_est_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack._get_gradient_estimator": [[305, 344], ["tensorflow.placeholder", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "range", "tensorflow.log", "tensorflow.square", "tensorflow.placeholder", "tensorflow.reduce_sum", "tensorflow.sqrt", "tensorflow.gradients", "tensorflow.matmul", "tensorflow.maximum", "tensorflow.norm", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.square"], "function", ["None"], ["", "def", "_get_gradient_estimator", "(", "n_nodes", ",", "window_size", ",", "dim", ",", "num_neg_samples", ")", ":", "\n", "    ", "\"\"\"Define a tensorflow computation graph used to estimate the loss using the perturbation gradient.\n\n    :param n_nodes: int\n        Number of nodes in the graph\n    :param window_size: int\n        Size of the window\n    :param dim: int\n        Size of the embedding\n    :param num_neg_samples: int\n        Number of negative samples\n    :return: (tf.placeholder, ...)\n        Tensorflow placeholders used to estimate the loss.\n    \"\"\"", "\n", "adj_matrix", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "shape", "=", "[", "n_nodes", ",", "n_nodes", "]", ")", "\n", "\n", "deg", "=", "tf", ".", "reduce_sum", "(", "adj_matrix", ",", "1", ")", "\n", "volume", "=", "tf", ".", "reduce_sum", "(", "adj_matrix", ")", "\n", "\n", "transition_matrix", "=", "adj_matrix", "/", "deg", "[", ":", ",", "None", "]", "\n", "\n", "sum_of_powers", "=", "transition_matrix", "\n", "last", "=", "transition_matrix", "\n", "for", "i", "in", "range", "(", "1", ",", "window_size", ")", ":", "\n", "        ", "last", "=", "tf", ".", "matmul", "(", "last", ",", "transition_matrix", ")", "\n", "sum_of_powers", "+=", "last", "\n", "\n", "", "M", "=", "sum_of_powers", "/", "deg", "*", "volume", "/", "(", "num_neg_samples", "*", "window_size", ")", "\n", "logM", "=", "tf", ".", "log", "(", "tf", ".", "maximum", "(", "M", ",", "1.0", ")", ")", "\n", "\n", "norm_logM", "=", "tf", ".", "square", "(", "tf", ".", "norm", "(", "logM", ",", "ord", "=", "2", ")", ")", "\n", "\n", "eigenvecs", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "shape", "=", "[", "n_nodes", ",", "dim", "]", ")", "\n", "eigen_vals", "=", "tf", ".", "reduce_sum", "(", "eigenvecs", "*", "tf", ".", "matmul", "(", "logM", ",", "eigenvecs", ")", ",", "0", ")", "\n", "loss", "=", "tf", ".", "sqrt", "(", "norm_logM", "-", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "eigen_vals", ")", ")", ")", "\n", "\n", "adj_matrix_grad", "=", "tf", ".", "gradients", "(", "loss", ",", "adj_matrix", ")", "\n", "\n", "return", "adj_matrix", ",", "logM", ",", "eigenvecs", ",", "loss", ",", "adj_matrix_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_random_top_flips": [[346, 360], ["numpy.random.seed", "numpy.random.permutation", "len"], "function", ["None"], ["", "def", "baseline_random_top_flips", "(", "candidates", ",", "n_flips", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Selects (n_flips) number of flips at random.\n\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param n_flips: int\n        Number of flips to select\n    :param seed: int\n        Random seed\n    :return: np.ndarray, shape [?, 2]\n        The top edge flips from the candidate set\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "return", "candidates", "[", "np", ".", "random", ".", "permutation", "(", "len", "(", "candidates", ")", ")", "[", ":", "n_flips", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_eigencentrality_top_flips": [[362, 384], ["numpy.column_stack", "construct_line_graph", "networkx.eigenvector_centrality_numpy", "numpy.array", "np.array.argsort", "scipy.triu().nonzero", "networkx.Graph", "tuple", "np.array.items", "scipy.triu", "tuple"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.construct_line_graph"], ["", "def", "baseline_eigencentrality_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ")", ":", "\n", "    ", "\"\"\"Selects the top (n_flips) number of flips using eigencentrality score of the edges.\n    Applicable only when removing edges.\n\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param n_flips: int\n        Number of flips to select\n    :return: np.ndarray, shape [?, 2]\n        The top edge flips from the candidate set\n    \"\"\"", "\n", "edges", "=", "np", ".", "column_stack", "(", "sp", ".", "triu", "(", "adj_matrix", ",", "1", ")", ".", "nonzero", "(", ")", ")", "\n", "line_graph", "=", "construct_line_graph", "(", "adj_matrix", ")", "\n", "eigcentrality_scores", "=", "nx", ".", "eigenvector_centrality_numpy", "(", "nx", ".", "Graph", "(", "line_graph", ")", ")", "\n", "eigcentrality_scores", "=", "{", "tuple", "(", "edges", "[", "k", "]", ")", ":", "eigcentrality_scores", "[", "k", "]", "for", "k", ",", "v", "in", "eigcentrality_scores", ".", "items", "(", ")", "}", "\n", "eigcentrality_scores", "=", "np", ".", "array", "(", "[", "eigcentrality_scores", "[", "tuple", "(", "cnd", ")", "]", "for", "cnd", "in", "candidates", "]", ")", "\n", "\n", "scores_argsrt", "=", "eigcentrality_scores", ".", "argsort", "(", ")", "\n", "\n", "return", "candidates", "[", "scores_argsrt", "[", "-", "n_flips", ":", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.baseline_degree_top_flips": [[386, 406], ["scipy.csr_matrix", "sp.csr_matrix.sum", "sp.csr_matrix.toarray"], "function", ["None"], ["", "def", "baseline_degree_top_flips", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "complement", ")", ":", "\n", "    ", "\"\"\"Selects the top (n_flips) number of flips using degree centrality score of the edges.\n\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param n_flips: int\n        Number of flips to select\n    :param complement: bool\n        Whether to look at the complement graph\n    :return: np.ndarray, shape [?, 2]\n        The top edge flips from the candidate set\n    \"\"\"", "\n", "if", "complement", ":", "\n", "        ", "adj_matrix", "=", "sp", ".", "csr_matrix", "(", "1", "-", "adj_matrix", ".", "toarray", "(", ")", ")", "\n", "", "deg", "=", "adj_matrix", ".", "sum", "(", "1", ")", ".", "A1", "\n", "deg_argsort", "=", "(", "deg", "[", "candidates", "[", ":", ",", "0", "]", "]", "+", "deg", "[", "candidates", "[", ":", ",", "1", "]", "]", ")", ".", "argsort", "(", ")", "\n", "\n", "return", "candidates", "[", "deg_argsort", "[", "-", "n_flips", ":", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.add_by_remove": [[408, 451], ["numpy.random.seed", "flip_candidates", "scipy.eigh", "perturbation_attack.estimate_loss_with_delta_eigenvals", "estimate_loss_with_delta_eigenvals.argsort", "numpy.random.permutation", "len", "flip_candidates.toarray", "numpy.diag", "len", "len", "flip_candidates.sum"], "function", ["home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.utils.flip_candidates", "home.repos.pwc.inspect_result.virresh_viking.node_embedding_attack.perturbation_attack.estimate_loss_with_delta_eigenvals"], ["", "def", "add_by_remove", "(", "adj_matrix", ",", "candidates", ",", "n_flips", ",", "dim", ",", "window_size", ",", "c_rnd", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n\n    :param adj_matrix: sp.spmatrix\n        The graph represented as a sparse scipy matrix\n    :param candidates: np.ndarray, shape [?, 2]\n        Candidate set of edge flips\n    :param n_flips: int\n        Number of flips to select\n    :param dim: int\n         Embedding dimension\n     :param window_size: int\n        Size of the window\n    :param c_rnd: int\n        Multiplicative constant for the number of other candidates to randomly select.\n    :param seed: int\n        Random seed\n    :return: np.ndarray, shape [?, 2]\n        The top edge flips from the candidate set\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "n_nodes", "=", "adj_matrix", ".", "shape", "[", "0", "]", "\n", "\n", "rnd_perm", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "candidates", ")", ")", "[", ":", "c_rnd", "*", "n_flips", "]", "\n", "candidates_add", "=", "candidates", "[", "rnd_perm", "]", "\n", "assert", "len", "(", "candidates_add", ")", "==", "c_rnd", "*", "n_flips", "\n", "\n", "adj_matrix_add", "=", "flip_candidates", "(", "adj_matrix", ",", "candidates_add", ")", "\n", "\n", "vals_org_add", ",", "vecs_org_add", "=", "spl", ".", "eigh", "(", "adj_matrix_add", ".", "toarray", "(", ")", ",", "np", ".", "diag", "(", "adj_matrix_add", ".", "sum", "(", "1", ")", ".", "A1", ")", ")", "\n", "flip_indicator", "=", "1", "-", "2", "*", "adj_matrix_add", "[", "candidates", "[", ":", ",", "0", "]", ",", "candidates", "[", ":", ",", "1", "]", "]", ".", "A1", "\n", "\n", "loss_est", "=", "estimate_loss_with_delta_eigenvals", "(", "candidates_add", ",", "flip_indicator", ",", "\n", "vals_org_add", ",", "vecs_org_add", ",", "n_nodes", ",", "dim", ",", "window_size", ")", "\n", "\n", "loss_argsort", "=", "loss_est", ".", "argsort", "(", ")", "\n", "\n", "top_candidates", "=", "candidates_add", "[", "loss_argsort", "[", ":", "n_flips", "]", "]", "\n", "\n", "assert", "len", "(", "top_candidates", ")", "==", "n_flips", "\n", "\n", "return", "top_candidates", "\n", "", ""]]}