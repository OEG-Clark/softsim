{"home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train": [[21, 223], ["set_random_seeds", "DataLoader", "tensorboardX.SummaryWriter", "Agent.policy.train", "os.path.isfile", "random.sample", "range", "AgentSupervised", "Agent", "load_module", "os.path.join", "print", "torch.load", "torch.load", "DataLoader", "Agent.policy.load_state_dict", "range", "evaluate", "tensorboardX.SummaryWriter.add_scalar", "tensorboardX.SummaryWriter.add_scalar", "train_history.append", "val_history.append", "torch.save", "torch.save", "print", "ValueError", "os.path.join", "AgentSupervised", "Agent", "get_starts", "State", "rec_errs[].data.sum", "torch.save", "torch.save", "Agent.policy.state_dict", "Agent.optimizer.state_dict", "os.path.join", "DataLoader.next_batch_train", "Agent.gather_trajectory", "Agent.update_policy", "Agent.policy.state_dict", "Agent.optimizer.state_dict", "os.path.join", "torch.save", "torch.save", "max", "range", "abs", "DataLoader.next_batch_train", "Agent.train_agent_hybrid", "os.path.join", "decoded_images[].size", "torchvision.make_grid", "tensorboardX.SummaryWriter.add_image", "DataLoader.next_batch_train", "DataLoader.next_batch_train", "Agent.train_agent_hybrid_inv", "Agent.train_agent"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.set_random_seeds", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.load_module", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.evaluate", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_starts", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train"], ["def", "train", "(", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Training function - trains an agent for a fixed number of epochs\n    \"\"\"", "\n", "# Set number of actions", "\n", "opts", ".", "A", "=", "opts", ".", "delta_M", "*", "opts", ".", "delta_N", "\n", "# Set random seeds", "\n", "set_random_seeds", "(", "opts", ".", "seed", ")", "\n", "\n", "if", "opts", ".", "expert_rewards", "and", "opts", ".", "expert_trajectories", ":", "\n", "        ", "from", "DataLoader", "import", "DataLoaderExpertBoth", "as", "DataLoader", "\n", "", "elif", "opts", ".", "expert_rewards", ":", "\n", "        ", "from", "DataLoader", "import", "DataLoaderExpert", "as", "DataLoader", "\n", "", "elif", "opts", ".", "expert_trajectories", "or", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "        ", "from", "DataLoader", "import", "DataLoaderExpertPolicy", "as", "DataLoader", "\n", "", "else", ":", "\n", "        ", "from", "DataLoader", "import", "DataLoaderSimple", "as", "DataLoader", "\n", "\n", "", "if", "opts", ".", "dataset", "==", "0", ":", "\n", "        ", "opts", ".", "num_channels", "=", "3", "\n", "if", "opts", ".", "mean_subtract", ":", "\n", "# R, G, B means and stds", "\n", "            ", "opts", ".", "mean", "=", "[", "119.16", ",", "107.68", ",", "95.12", "]", "\n", "opts", ".", "std", "=", "[", "61.88", ",", "61.72", ",", "67.24", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "opts", ".", "std", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "", "", "elif", "opts", ".", "dataset", "==", "1", ":", "\n", "        ", "opts", ".", "num_channels", "=", "1", "\n", "if", "opts", ".", "mean_subtract", ":", "\n", "# R, G, B means and stds", "\n", "            ", "opts", ".", "mean", "=", "[", "193.0162338615919", "]", "\n", "opts", ".", "std", "=", "[", "37.716024486312811", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", "]", "\n", "opts", ".", "std", "=", "[", "1", "]", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Dataset %d does not exist!'", "%", "(", "opts", ".", "dataset", ")", ")", "\n", "\n", "", "if", "opts", ".", "expert_trajectories", ":", "\n", "        ", "opts", ".", "T_sup", "=", "opts", ".", "T", "-", "1", "\n", "", "loader", "=", "DataLoader", "(", "opts", ")", "\n", "if", "opts", ".", "expert_trajectories", ":", "\n", "        ", "agent", "=", "AgentSupervised", "(", "opts", ")", "\n", "", "else", ":", "\n", "        ", "agent", "=", "Agent", "(", "opts", ")", "\n", "# Create tensorboard writer", "\n", "", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "opts", ".", "save_path", ")", "\n", "# Set networks to train", "\n", "agent", ".", "policy", ".", "train", "(", ")", "\n", "# Initiate statistics storage variables", "\n", "if", "opts", ".", "load_model", "==", "''", ":", "\n", "        ", "best_val_error", "=", "100000", "\n", "train_history", "=", "[", "]", "\n", "val_history", "=", "[", "]", "\n", "epoch_start", "=", "0", "\n", "", "else", ":", "\n", "       ", "best_val_error", ",", "train_history", ",", "val_history", ",", "epoch_start", "=", "load_module", "(", "agent", ",", "opts", ")", "\n", "\n", "# To handle job eviction and restarts", "\n", "", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "opts", ".", "save_path", ",", "'model_latest.net'", ")", ")", ":", "\n", "        ", "print", "(", "'====> Resuming training from previous checkpoint'", ")", "\n", "# undo most of the loading done before", "\n", "loaded_model", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "opts", ".", "save_path", ",", "'model_latest.net'", ")", ")", "\n", "opts", "=", "loaded_model", "[", "'opts'", "]", "\n", "epoch_start", "=", "loaded_model", "[", "'epoch'", "]", "+", "1", "\n", "\n", "loader", "=", "DataLoader", "(", "opts", ")", "\n", "if", "opts", ".", "expert_trajectories", ":", "\n", "            ", "agent", "=", "AgentSupervised", "(", "opts", ")", "\n", "agent", ".", "T_sup", "=", "loaded_model", "[", "'T_sup'", "]", "\n", "", "else", ":", "\n", "            ", "agent", "=", "Agent", "(", "opts", ")", "\n", "\n", "", "agent", ".", "policy", ".", "load_state_dict", "(", "loaded_model", "[", "'state_dict'", "]", ")", "\n", "train_history", "=", "loaded_model", "[", "'train_history'", "]", "\n", "val_history", "=", "loaded_model", "[", "'val_history'", "]", "\n", "#agent.optimizer.load_state_dict(loaded_model['optimizer'])", "\n", "best_val_error", "=", "loaded_model", "[", "'best_val_error'", "]", "\n", "\n", "# Some random selection of images to display", "\n", "", "rng_choices", "=", "random", ".", "sample", "(", "range", "(", "400", "//", "opts", ".", "batch_size", ")", ",", "2", ")", "\n", "# Start training", "\n", "for", "epoch", "in", "range", "(", "epoch_start", ",", "opts", ".", "epochs", ")", ":", "\n", "# Initialize epoch specific variables", "\n", "        ", "depleted", "=", "False", "\n", "train_err", "=", "0", "\n", "train_count", "=", "0", "\n", "iter_count", "=", "0", "\n", "\n", "while", "not", "depleted", ":", "\n", "# pano - BxNxMxCx32x32", "\n", "            ", "if", "opts", ".", "expert_rewards", "and", "opts", ".", "expert_trajectories", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "", "elif", "opts", ".", "expert_rewards", ":", "\n", "                ", "pano", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "pano_maps", "=", "None", "\n", "", "elif", "opts", ".", "expert_trajectories", "or", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "", "else", ":", "\n", "                ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "\n", "# Note: This batch size is the current batch size, not the global batch size. This varies", "\n", "# when you reach the boundary of the dataset.", "\n", "", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "start_idx", "=", "get_starts", "(", "opts", ".", "N", ",", "opts", ".", "M", ",", "batch_size", ",", "opts", ".", "start_view", ")", "\n", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ")", "\n", "if", "opts", ".", "expert_trajectories", ":", "\n", "                ", "if", "opts", ".", "hybrid_train", ":", "\n", "                    ", "rec_errs", "=", "agent", ".", "train_agent_hybrid", "(", "state", ",", "pano_maps", ",", "opts", ")", "\n", "", "elif", "opts", ".", "hybrid_inv_train", ":", "\n", "                    ", "rec_errs", "=", "agent", ".", "train_agent_hybrid_inv", "(", "state", ",", "pano_maps", ",", "opts", ")", "\n", "", "else", ":", "\n", "                    ", "rec_errs", "=", "agent", ".", "train_agent", "(", "state", ",", "pano_maps", ",", "opts", ")", "\n", "", "", "else", ":", "\n", "# Forward pass", "\n", "                ", "log_probs", ",", "rec_errs", ",", "rewards", ",", "entropies", ",", "decoded", ",", "values", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "None", ",", "pano_maps", "=", "pano_maps", ",", "opts", "=", "opts", ")", "\n", "# Backward pass", "\n", "agent", ".", "update_policy", "(", "rewards", ",", "log_probs", ",", "rec_errs", ",", "entropies", ",", "values", ",", "visited_idxes", ",", "decoded_all", ")", "\n", "\n", "# Accumulate statistics", "\n", "", "train_err", "+=", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "sum", "(", ")", "\n", "train_count", "+=", "batch_size", "\n", "iter_count", "+=", "1", "\n", "\n", "", "train_err", "/=", "train_count", "\n", "\n", "# Evaluate the agent after every epoch", "\n", "val_err", ",", "_", ",", "_", ",", "decoded_images", "=", "evaluate", "(", "loader", ",", "agent", ",", "'val'", ",", "opts", ")", "\n", "\n", "# Write out statistics to tensorboard", "\n", "writer", ".", "add_scalar", "(", "'data/train_error'", ",", "train_err", ",", "epoch", "+", "1", ")", "\n", "writer", ".", "add_scalar", "(", "'data/val_error'", ",", "val_err", ",", "epoch", "+", "1", ")", "\n", "\n", "# Write out models and other statistics to torch format file", "\n", "train_history", ".", "append", "(", "[", "epoch", ",", "train_err", "]", ")", "\n", "val_history", ".", "append", "(", "[", "epoch", ",", "val_err", "]", ")", "\n", "if", "best_val_error", ">", "val_err", ":", "\n", "            ", "best_val_error", "=", "val_err", "\n", "save_state", "=", "{", "\n", "'epoch'", ":", "epoch", ",", "\n", "'state_dict'", ":", "agent", ".", "policy", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "agent", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'opts'", ":", "opts", ",", "\n", "'best_val_error'", ":", "best_val_error", ",", "\n", "'train_history'", ":", "train_history", ",", "\n", "'val_history'", ":", "val_history", "\n", "}", "\n", "if", "opts", ".", "expert_trajectories", ":", "\n", "                ", "save_state", "[", "'T_sup'", "]", "=", "agent", ".", "T_sup", "\n", "\n", "", "torch", ".", "save", "(", "save_state", ",", "os", ".", "path", ".", "join", "(", "opts", ".", "save_path", ",", "'model_best.net'", ")", ")", "\n", "\n", "", "save_state", "=", "{", "\n", "'epoch'", ":", "epoch", ",", "\n", "'state_dict'", ":", "agent", ".", "policy", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "agent", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'opts'", ":", "opts", ",", "\n", "'best_val_error'", ":", "best_val_error", ",", "\n", "'train_history'", ":", "train_history", ",", "\n", "'val_history'", ":", "val_history", "\n", "}", "\n", "if", "opts", ".", "expert_trajectories", ":", "\n", "            ", "save_state", "[", "'T_sup'", "]", "=", "agent", ".", "T_sup", "\n", "", "torch", ".", "save", "(", "save_state", ",", "os", ".", "path", ".", "join", "(", "opts", ".", "save_path", ",", "'model_latest.net'", ")", ")", "\n", "\n", "print", "(", "'Epoch %d : Train loss: %9.6f    Val loss: %9.6f'", "%", "(", "epoch", "+", "1", ",", "train_err", ",", "val_err", ")", ")", "\n", "\n", "# Reduce supervision gradually", "\n", "if", "opts", ".", "expert_trajectories", "and", "(", "opts", ".", "hybrid_train", "or", "opts", ".", "hybrid_inv_train", ")", ":", "\n", "            ", "if", "(", "epoch", "+", "1", ")", "%", "opts", ".", "hybrid_schedule", "==", "0", "and", "agent", ".", "T_sup", ">", "0", ":", "\n", "                ", "agent", ".", "T_sup", "-=", "1", "\n", "# Save the model after the first schedule is over", "\n", "", "if", "epoch", "+", "1", "==", "opts", ".", "hybrid_schedule", ":", "\n", "                ", "torch", ".", "save", "(", "save_state", ",", "os", ".", "path", ".", "join", "(", "opts", ".", "save_path", ",", "'model_after_one_schedule.net'", ")", ")", "\n", "\n", "# Decay exploration factor", "\n", "", "", "if", "agent", ".", "policy", ".", "explorationFactor", ">", "0", ":", "\n", "            ", "agent", ".", "policy", ".", "explorationFactor", "=", "max", "(", "agent", ".", "policy", ".", "explorationFactor", "*", "opts", ".", "explorationDecay", ",", "0.0001", ")", "-", "0.0001", "\n", "\n", "# Decay expert reward gradually", "\n", "", "if", "opts", ".", "expert_rewards", "and", "(", "epoch", "+", "1", ")", "%", "opts", ".", "expert_rewards_scale_decay", "==", "0", ":", "\n", "            ", "agent", ".", "reward_scale_expert", "/=", "opts", ".", "expert_rewards_scale", "\n", "\n", "# Display three randomly selected batches of panoramas every 10 epochs", "\n", "", "if", "(", "epoch", "+", "1", ")", "%", "10", "==", "0", "or", "epoch", "==", "0", ":", "\n", "            ", "for", "choice", "in", "rng_choices", ":", "\n", "                ", "for", "pano_count", "in", "range", "(", "decoded_images", "[", "choice", "]", ".", "size", "(", "0", ")", ")", ":", "\n", "                    ", "x", "=", "vutils", ".", "make_grid", "(", "decoded_images", "[", "choice", "]", "[", "pano_count", "]", ",", "padding", "=", "5", ",", "normalize", "=", "True", ",", "scale_each", "=", "True", ",", "nrow", "=", "opts", ".", "T", "//", "2", "+", "1", ")", "\n", "writer", ".", "add_image", "(", "'Validation batch # : %d  image # : %d'", "%", "(", "choice", ",", "pano_count", ")", ",", "x", ",", "0", ")", "# Converting this to 0 to save disk space, should be epoch ideally", "\n", "\n", "# Early stopping criterion", "\n", "", "", "", "if", "epoch", "==", "0", ":", "\n", "            ", "best_val_error_in_past", "=", "best_val_error", "\n", "", "if", "(", "epoch", "+", "1", ")", "%", "opts", ".", "check_stop", "==", "0", ":", "\n", "            ", "if", "abs", "(", "best_val_error", "-", "best_val_error_in_past", ")", "<=", "1e-8", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "best_val_error_in_past", "=", "best_val_error", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.str2bool": [[23, 25], ["v.lower"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "return", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.get_rewards_one_view": [[26, 91], ["agent.policy.eval", "range", "range", "np.zeros", "np.zeros", "range", "true_images.append", "scores_images.append", "scores_matrices.append", "loader.next_batch_train", "loader.next_batch_val", "loader.next_batch_test", "np.max", "np.min", "State", "agent.gather_trajectory", "rec_errs[].data.cpu", "range", "range"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test"], ["", "def", "get_rewards_one_view", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    One View reward function - evaluates the MSE error for each view of the panorama and\n    returns scores for each view.\n    Outputs:\n        true_images    : list of BxNxMxCx32x32 arrays (each element of list corresponds to one batch)\n        score_images   : list of BxNxMxCx32x32 arrays, each Cx32x32 image is a constant \n                         image containing score corresponding to each location in NxM panorama\n        score_matrices : list of BxNxM arrays, contains scores corresponding to each\n                         location in NxM panorama\n    \"\"\"", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "true_images", "=", "[", "]", "\n", "scores_images", "=", "[", "]", "\n", "scores_matrices", "=", "[", "]", "\n", "\n", "while", "not", "depleted", ":", "\n", "        ", "if", "split", "==", "'train'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "", "if", "split", "==", "'val'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "", "if", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "\n", "", "curr_err", "=", "0", "\n", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Compute the performance with the initial state ", "\n", "# starting at fixed grid locations", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "# Scores images are stored as BxNxMx3x32x32 images with all values in an image proportional to", "\n", "# the assigned score. ", "\n", "scores_image", "=", "np", ".", "zeros", "(", "pano", ".", "shape", ")", "\n", "# Scores matrices are stored as BxNxM matrices with one value corresponding to one view. ", "\n", "scores_matrix", "=", "np", ".", "zeros", "(", "pano", ".", "shape", "[", "0", ":", "3", "]", ")", "\n", "\n", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "state", "=", "State", "(", "pano", ",", "None", ",", "start_idx", ",", "opts", ")", "\n", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "opts", ".", "memorize_views", "}", ")", "\n", "# For some random initial state, print the decoded images at all time steps", "\n", "rec_errs", "=", "rec_errs", "[", "0", "]", ".", "data", ".", "cpu", "(", ")", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "reward", "=", "1", "/", "(", "rec_errs", "[", "k", "]", "*", "1000", ")", "\n", "scores_image", "[", "k", ",", "i", ",", "j", "]", "=", "reward", "\n", "scores_matrix", "[", "k", ",", "i", ",", "j", "]", "=", "reward", "\n", "\n", "# Rescale scores for each image in batch", "\n", "", "", "", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "max_v", "=", "np", ".", "max", "(", "scores_image", "[", "i", "]", ")", "\n", "min_v", "=", "np", ".", "min", "(", "scores_image", "[", "i", "]", ")", "\n", "scores_image", "[", "i", "]", "-=", "min_v", "\n", "scores_image", "[", "i", "]", "/=", "(", "max_v", "-", "min_v", "+", "1e-8", ")", "\n", "scores_image", "[", "i", "]", "*=", "255", "\n", "scores_matrix", "[", "i", "]", "-=", "min_v", "\n", "scores_matrix", "[", "i", "]", "/=", "(", "max_v", "-", "min_v", "+", "1e-8", ")", "\n", "scores_matrix", "[", "i", "]", "*=", "255", "\n", "\n", "", "true_images", ".", "append", "(", "pano", ")", "\n", "scores_images", ".", "append", "(", "scores_image", ")", "\n", "scores_matrices", ".", "append", "(", "scores_matrix", ")", "\n", "\n", "", "return", "true_images", ",", "scores_images", ",", "scores_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.get_rewards_uniform": [[92, 148], ["agent.policy.eval", "range", "range", "np.zeros", "np.zeros", "np.random.randint", "np.random.randint", "range", "true_images.append", "scores_images.append", "scores_matrices.append", "loader.next_batch_train", "loader.next_batch_val", "loader.next_batch_test", "range", "np.minimum", "np.minimum", "range", "range", "max", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test"], ["", "def", "get_rewards_uniform", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    This is a baseline mechanism where rewards are spread uniformly randomly throughout the\n    different views.\n    Outputs:\n        true_images    : list of BxNxMxCx32x32 arrays (each element of list corresponds to one batch)\n        score_images   : list of BxNxMxCx32x32 arrays, each Cx32x32 image is a constant \n                         image containing score corresponding to each location in NxM panorama\n        score_matrices : list of BxNxM arrays, contains scores corresponding to each\n                         location in NxM panorama\n    \"\"\"", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "true_images", "=", "[", "]", "\n", "scores_images", "=", "[", "]", "\n", "scores_matrices", "=", "[", "]", "\n", "\n", "while", "not", "depleted", ":", "\n", "        ", "if", "split", "==", "'train'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "", "if", "split", "==", "'val'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "", "if", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "\n", "", "curr_err", "=", "0", "\n", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Compute the performance with the initial state ", "\n", "# starting at fixed grid locations", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "# Scores images are stored as BxNxMx3x32x32 images with all values in an image proportional to", "\n", "# the assigned score. ", "\n", "scores_image", "=", "np", ".", "zeros", "(", "pano", ".", "shape", ")", "\n", "# Scores matrices are stored as BxNxM matrices with one value corresponding to one view. ", "\n", "scores_matrix", "=", "np", ".", "zeros", "(", "pano", ".", "shape", "[", "0", ":", "3", "]", ")", "\n", "\n", "# Randomly sample nms_iters reward locations", "\n", "random_azimuths", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "opts", ".", "M", ",", "(", "batch_size", ",", "opts", ".", "nms_iters", ")", ")", "\n", "random_elevations", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "opts", ".", "N", ",", "(", "batch_size", ",", "opts", ".", "nms_iters", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "opts", ".", "nms_iters", ")", ":", "\n", "                 ", "for", "k1", "in", "[", "value_1", "%", "opts", ".", "N", "for", "value_1", "in", "range", "(", "random_elevations", "[", "i", ",", "j", "]", "-", "opts", ".", "nms_nbd", ",", "random_elevations", "[", "i", ",", "j", "]", "+", "opts", ".", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                    ", "for", "k2", "in", "[", "value_2", "%", "opts", ".", "M", "for", "value_2", "in", "range", "(", "random_azimuths", "[", "i", ",", "j", "]", "-", "opts", ".", "nms_nbd", ",", "random_azimuths", "[", "i", ",", "j", "]", "+", "opts", ".", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "curr_value", "=", "1.0", "/", "(", "4.0", "**", "(", "max", "(", "abs", "(", "random_azimuths", "[", "i", ",", "j", "]", "-", "k2", ")", ",", "abs", "(", "random_elevations", "[", "i", ",", "j", "]", "-", "k1", ")", ")", ")", ")", "\n", "scores_image", "[", "i", ",", "k1", ",", "k2", "]", "+=", "curr_value", "\n", "scores_matrix", "[", "i", ",", "k1", ",", "k2", "]", "+=", "curr_value", "\n", "\n", "", "", "", "", "scores_image", "=", "np", ".", "minimum", "(", "scores_image", ",", "1", ")", "*", "255.0", "\n", "scores_matrix", "=", "np", ".", "minimum", "(", "scores_matrix", ",", "1", ")", "*", "255.0", "\n", "true_images", ".", "append", "(", "pano", ")", "\n", "scores_images", ".", "append", "(", "scores_image", ")", "\n", "scores_matrices", ".", "append", "(", "scores_matrix", ")", "\n", "\n", "", "return", "true_images", ",", "scores_images", ",", "scores_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.greedy_nms_image": [[149, 191], ["np.zeros_like", "range", "np.copy", "range", "range", "range", "range", "range", "min", "range", "float", "max", "abs", "abs"], "function", ["None"], ["", "def", "greedy_nms_image", "(", "score_image", ",", "nms_iters", ",", "nms_nbd", ",", "score_type", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Takes in a BxNxMx3x32x32 numpy array and performs NMS on\n    each NxMx3x32x32 panorama score image. \n    Note: Each 3x32x32 consists of just one pixel value corresponding\n    to the score assigned to that view of the panorama\n    score_type: 0 - only nms , 1 - nms + smoothing, 2 = none\n    \"\"\"", "\n", "if", "score_type", "==", "2", "or", "score_type", "==", "3", ":", "\n", "        ", "final_score_image", "=", "score_image", "\n", "", "else", ":", "\n", "        ", "shape", "=", "score_image", ".", "shape", "\n", "final_score_image", "=", "np", ".", "zeros_like", "(", "score_image", ")", "\n", "N", "=", "shape", "[", "1", "]", "\n", "M", "=", "shape", "[", "2", "]", "\n", "for", "i", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "            ", "pano", "=", "np", ".", "copy", "(", "score_image", "[", "i", "]", ")", "\n", "iter_count", "=", "0", "\n", "while", "iter_count", "<", "nms_iters", ":", "\n", "                ", "max_val", "=", "0", "\n", "max_idx", "=", "(", "0", ",", "0", ")", "\n", "for", "j", "in", "range", "(", "N", ")", ":", "\n", "                    ", "for", "k", "in", "range", "(", "M", ")", ":", "\n", "                        ", "if", "max_val", "<=", "pano", "[", "j", ",", "k", ",", "0", ",", "0", ",", "0", "]", ":", "\n", "                            ", "max_val", "=", "pano", "[", "j", ",", "k", ",", "0", ",", "0", ",", "0", "]", "\n", "max_idx", "=", "(", "j", ",", "k", ")", "\n", "", "", "", "if", "score_type", "==", "0", ":", "\n", "                    ", "final_score_image", "[", "i", ",", "max_idx", "[", "0", "]", ",", "max_idx", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "=", "max_val", "\n", "", "elif", "score_type", "==", "1", ":", "\n", "# Adds +1 to the actual maxima location and 0.25 to the adjacent locations", "\n", "                    ", "for", "j", "in", "[", "value_j", "%", "N", "for", "value_j", "in", "range", "(", "max_idx", "[", "0", "]", "-", "nms_nbd", ",", "max_idx", "[", "0", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "for", "k", "in", "[", "value_k", "%", "M", "for", "value_k", "in", "range", "(", "max_idx", "[", "1", "]", "-", "1", ",", "max_idx", "[", "1", "]", "+", "1", "+", "1", ")", "]", ":", "\n", "                            ", "final_score_image", "[", "i", ",", "j", ",", "k", "]", "+=", "min", "(", "max_val", "/", "(", "float", "(", "4", "**", "(", "max", "(", "abs", "(", "max_idx", "[", "0", "]", "-", "j", ")", ",", "abs", "(", "max_idx", "[", "1", "]", "-", "k", ")", ")", ")", ")", ")", ",", "max_val", ")", "\n", "\n", "# Eliminate the maxima and neighbours for next iteration", "\n", "", "", "", "for", "j", "in", "[", "value_j", "%", "N", "for", "value_j", "in", "range", "(", "max_idx", "[", "0", "]", "-", "nms_nbd", ",", "max_idx", "[", "0", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                    ", "for", "k", "in", "[", "value_k", "%", "M", "for", "value_k", "in", "range", "(", "max_idx", "[", "1", "]", "-", "nms_nbd", ",", "max_idx", "[", "1", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "pano", "[", "j", ",", "k", ",", ":", ",", ":", ",", ":", "]", "=", "0", "\n", "\n", "", "", "iter_count", "+=", "1", "\n", "\n", "", "", "", "return", "final_score_image", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.greedy_nms_matrix": [[192, 232], ["np.zeros_like", "range", "np.copy", "range", "range", "range", "range", "range", "min", "range", "float", "max", "abs", "abs"], "function", ["None"], ["", "def", "greedy_nms_matrix", "(", "score_matrix", ",", "nms_iters", ",", "nms_nbd", ",", "score_type", ")", ":", "\n", "    ", "\"\"\"\n    Takes in a BxNxM numpy array and performs NMS on\n    each NxM matrix.\n    Output: BxNxM numpy array \n    \"\"\"", "\n", "if", "score_type", "==", "2", "or", "score_type", "==", "3", ":", "\n", "        ", "final_score_matrix", "=", "score_matrix", "\n", "", "else", ":", "\n", "        ", "shape", "=", "score_matrix", ".", "shape", "\n", "final_score_matrix", "=", "np", ".", "zeros_like", "(", "score_matrix", ")", "\n", "N", "=", "shape", "[", "1", "]", "\n", "M", "=", "shape", "[", "2", "]", "\n", "for", "i", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "            ", "matrix_copy", "=", "np", ".", "copy", "(", "score_matrix", "[", "i", "]", ")", "\n", "iter_count", "=", "0", "\n", "while", "iter_count", "<", "nms_iters", ":", "\n", "                ", "max_val", "=", "0", "\n", "max_idx", "=", "(", "0", ",", "0", ")", "\n", "for", "j", "in", "range", "(", "N", ")", ":", "\n", "                    ", "for", "k", "in", "range", "(", "M", ")", ":", "\n", "                        ", "if", "max_val", "<=", "matrix_copy", "[", "j", ",", "k", "]", ":", "\n", "                            ", "max_val", "=", "matrix_copy", "[", "j", ",", "k", "]", "\n", "max_idx", "=", "(", "j", ",", "k", ")", "\n", "", "", "", "if", "score_type", "==", "0", ":", "\n", "                    ", "final_score_matrix", "[", "i", ",", "max_idx", "[", "0", "]", ",", "max_idx", "[", "1", "]", "]", "=", "max_val", "\n", "", "elif", "score_type", "==", "1", ":", "\n", "# Adds +1 to the actual maxima location and 0.25 to the adjacent locations", "\n", "                    ", "for", "j", "in", "[", "value_j", "%", "N", "for", "value_j", "in", "range", "(", "max_idx", "[", "0", "]", "-", "nms_nbd", ",", "max_idx", "[", "0", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "for", "k", "in", "[", "value_k", "%", "M", "for", "value_k", "in", "range", "(", "max_idx", "[", "1", "]", "-", "1", ",", "max_idx", "[", "1", "]", "+", "1", "+", "1", ")", "]", ":", "\n", "                            ", "final_score_matrix", "[", "i", ",", "j", ",", "k", "]", "+=", "min", "(", "max_val", "/", "(", "float", "(", "4", "**", "(", "max", "(", "abs", "(", "max_idx", "[", "0", "]", "-", "j", ")", ",", "abs", "(", "max_idx", "[", "1", "]", "-", "k", ")", ")", ")", ")", ")", ",", "max_val", ")", "\n", "\n", "# Eliminate the maxima and neighbours for next iteration", "\n", "", "", "", "for", "j", "in", "[", "value_j", "%", "N", "for", "value_j", "in", "range", "(", "max_idx", "[", "0", "]", "-", "nms_nbd", ",", "max_idx", "[", "0", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                    ", "for", "k", "in", "[", "value_k", "%", "M", "for", "value_k", "in", "range", "(", "max_idx", "[", "1", "]", "-", "nms_nbd", ",", "max_idx", "[", "1", "]", "+", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "matrix_copy", "[", "j", ",", "k", "]", "=", "0", "\n", "\n", "", "", "iter_count", "+=", "1", "\n", "\n", "", "", "", "return", "final_score_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.main": [[233, 315], ["set_random_seeds", "tensorboardX.SummaryWriter", "DataLoader.DataLoaderSimple", "Agent", "h5py.File", "json.dump", "tensorboardX.SummaryWriter.close", "h5py.File.close", "torch.load", "torch.load", "Agent.policy.load_state_dict", "range", "np.concatenate", "np.concatenate", "h5py.File.create_dataset", "h5py.File.create_dataset", "vars", "open", "ValueError", "create_one_view_scores.get_rewards_uniform", "create_one_view_scores.get_rewards_one_view", "len", "range", "len", "create_one_view_scores.greedy_nms_matrix", "np.concatenate.append", "range", "len", "len", "len", "torch.Tensor", "torch.Tensor", "range", "np.reshape", "np.reshape", "np.reshape", "np.concatenate", "torchvision.make_grid", "tensorboardX.SummaryWriter.add_image", "create_one_view_scores.greedy_nms_image"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.set_random_seeds", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.get_rewards_uniform", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.get_rewards_one_view", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.greedy_nms_matrix", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_one_view_scores.greedy_nms_image"], ["", "def", "main", "(", "opts", ")", ":", "\n", "# Set number of actions", "\n", "    ", "opts", ".", "A", "=", "opts", ".", "delta_M", "*", "opts", ".", "delta_N", "\n", "# Set random seeds ", "\n", "set_random_seeds", "(", "opts", ".", "seed", ")", "\n", "\n", "if", "opts", ".", "dataset", "==", "0", ":", "\n", "        ", "if", "opts", ".", "mean_subtract", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "119.16", ",", "107.68", ",", "95.12", "]", "\n", "opts", ".", "std", "=", "[", "61.88", ",", "61.72", ",", "67.24", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "opts", ".", "std", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "opts", ".", "num_channels", "=", "3", "\n", "", "elif", "opts", ".", "dataset", "==", "1", ":", "\n", "        ", "if", "opts", ".", "mean_subtract", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "193.0162338615919", "]", "\n", "opts", ".", "std", "=", "[", "37.716024486312811", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", "]", "\n", "opts", ".", "std", "=", "[", "0", "]", "\n", "", "opts", ".", "num_channels", "=", "1", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Dataset %d does not exist!'", "%", "(", "opts", ".", "dataset", ")", ")", "\n", "\n", "# Create tensorboard writer", "\n", "", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "opts", ".", "save_path_vis", ")", "\n", "\n", "loader", "=", "DataLoader", "(", "opts", ")", "\n", "agent", "=", "Agent", "(", "opts", ",", "mode", "=", "'eval'", ")", "\n", "if", "opts", ".", "score_type", "!=", "3", ":", "\n", "        ", "loaded_state", "=", "torch", ".", "load", "(", "opts", ".", "load_model", ")", "\n", "agent", ".", "policy", ".", "load_state_dict", "(", "loaded_state", "[", "'state_dict'", "]", ")", "\n", "\n", "", "h5file", "=", "h5py", ".", "File", "(", "opts", ".", "save_path_h5", ",", "'w'", ")", "\n", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", "]", ":", "\n", "        ", "if", "opts", ".", "score_type", "==", "3", ":", "\n", "            ", "true_images", ",", "scores_images", ",", "scores_matrices", "=", "get_rewards_uniform", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", "\n", "", "else", ":", "\n", "            ", "true_images", ",", "scores_images", ",", "scores_matrices", "=", "get_rewards_one_view", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", "\n", "", "if", "opts", ".", "debug", ":", "\n", "            ", "num_batches", "=", "len", "(", "true_images", ")", "\n", "assert", "(", "len", "(", "scores_images", ")", "==", "num_batches", ")", "\n", "assert", "(", "len", "(", "scores_matrices", ")", "==", "num_batches", ")", "\n", "for", "i", "in", "range", "(", "num_batches", ")", ":", "\n", "                ", "batch_size", "=", "true_images", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "assert", "(", "scores_images", "[", "i", "]", ".", "shape", "==", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "opts", ".", "num_channels", ",", "32", ",", "32", ")", ")", "\n", "assert", "(", "scores_matrices", "[", "i", "]", ".", "shape", "==", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "\n", "", "", "final_scores_matrices_nms", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "true_images", ")", ")", ":", "\n", "            ", "scores_matrix", "=", "scores_matrices", "[", "i", "]", "\n", "scores_matrix_nms", "=", "greedy_nms_matrix", "(", "scores_matrix", ",", "opts", ".", "nms_iters", ",", "opts", ".", "nms_nbd", ",", "opts", ".", "score_type", ")", "\n", "if", "opts", ".", "debug", ":", "\n", "                ", "batch_size", "=", "scores_matrix", ".", "shape", "[", "0", "]", "\n", "assert", "(", "scores_matrix_nms", ".", "shape", "==", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "", "final_scores_matrices_nms", ".", "append", "(", "scores_matrix_nms", ")", "\n", "\n", "", "if", "split", "==", "'val'", ":", "\n", "            ", "images_count", "=", "0", "\n", "# Iterate through the different batches", "\n", "for", "i", "in", "range", "(", "len", "(", "true_images", ")", ")", ":", "\n", "                ", "shape", "=", "true_images", "[", "i", "]", ".", "shape", "\n", "true_images", "[", "i", "]", "=", "np", ".", "reshape", "(", "true_images", "[", "i", "]", ",", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", ",", "shape", "[", "4", "]", ",", "shape", "[", "5", "]", ")", ")", "/", "255.0", "\n", "scores_images_nms", "=", "np", ".", "reshape", "(", "greedy_nms_image", "(", "scores_images", "[", "i", "]", ",", "opts", ".", "nms_iters", ",", "opts", ".", "nms_nbd", ",", "opts", ".", "score_type", ")", ",", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", ",", "shape", "[", "4", "]", ",", "shape", "[", "5", "]", ")", ")", "/", "255.0", "\n", "scores_images_normal", "=", "np", ".", "reshape", "(", "scores_images", "[", "i", "]", ",", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", ",", "shape", "[", "4", "]", ",", "shape", "[", "5", "]", ")", ")", "/", "255.0", "\n", "concatenated", "=", "torch", ".", "Tensor", "(", "np", ".", "concatenate", "(", "[", "true_images", "[", "i", "]", ",", "scores_images_normal", ",", "scores_images_nms", "]", ",", "axis", "=", "1", ")", ")", "\n", "for", "j", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "x", "=", "vutils", ".", "make_grid", "(", "concatenated", "[", "j", "]", ",", "padding", "=", "True", ",", "normalize", "=", "False", ",", "scale_each", "=", "False", ",", "nrow", "=", "opts", ".", "M", ")", "\n", "images_count", "+=", "1", "\n", "\n", "writer", ".", "add_image", "(", "'Panorama #%5.3d'", "%", "(", "images_count", ")", ",", "x", ",", "0", ")", "\n", "\n", "", "", "", "scores_matrices", "=", "np", ".", "concatenate", "(", "scores_matrices", ",", "axis", "=", "0", ")", "\n", "final_scores_matrices_nms", "=", "np", ".", "concatenate", "(", "final_scores_matrices_nms", ",", "axis", "=", "0", ")", "\n", "h5file", ".", "create_dataset", "(", "'%s/normal'", "%", "split", ",", "data", "=", "scores_matrices", ")", "\n", "h5file", ".", "create_dataset", "(", "'%s/nms'", "%", "split", ",", "data", "=", "final_scores_matrices_nms", ")", "\n", "\n", "", "json", ".", "dump", "(", "vars", "(", "opts", ")", ",", "open", "(", "opts", ".", "save_path_json", ",", "'w'", ")", ")", "\n", "writer", ".", "close", "(", ")", "\n", "h5file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_utility_based_rewards.get_utility_maps": [[23, 107], ["agent.policy.eval", "range", "range", "np.zeros", "np.zeros", "np.max", "np.min", "np.repeat", "np.repeat", "np.repeat", "true_images.append", "utility_images.append", "utility_matrices.append", "loader.next_batch_train", "loader.next_batch_val", "loader.next_batch_test", "loader.next_batch_test_unseen", "np.max", "np.min", "np.repeat", "np.repeat", "np.repeat", "State", "agent.gather_trajectory", "np.reshape().sum", "rec_errs[].data.cpu().numpy", "np.roll", "range", "np.repeat", "range", "np.reshape", "rec_errs[].data.cpu", "decoded.data.cpu().numpy", "np.reshape().sum", "decoded.data.cpu", "np.reshape"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["def", "get_utility_maps", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    get_utility_maps - computes the MSE error for using one view of panorama P and\n    generating each view of P. This is used to generate a scoring map which defines \n    the utility (0-1) of picking a view V for reconstructing each of the views of P.  \n    Outputs:\n        true_images      : list of BxNxMxCx32x32 arrays (each element of list corresponds to one batch)\n        utility_images   : list of BxNxMxNxMxCx32x32 arrays, each MxNxCx32x32 image is a set of constant \n                           images containing utility map corresponding to each location in NxM panorama\n        utility_matrices : list of BxNxMxNxM arrays, contains utility maps corresponding to each\n                           location in NxM panorama\n    \"\"\"", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "true_images", "=", "[", "]", "\n", "utility_images", "=", "[", "]", "\n", "utility_matrices", "=", "[", "]", "\n", "\n", "while", "not", "depleted", ":", "\n", "        ", "if", "split", "==", "'train'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "", "if", "split", "==", "'val'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "", "if", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "_", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "", "if", "split", "==", "'test_unseen'", ":", "\n", "            ", "pano", ",", "_", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "\n", "", "curr_err", "=", "0", "\n", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "\n", "N", "=", "pano", ".", "shape", "[", "1", "]", "\n", "M", "=", "pano", ".", "shape", "[", "2", "]", "\n", "C", "=", "pano", ".", "shape", "[", "3", "]", "\n", "H", "=", "8", "\n", "W", "=", "8", "\n", "\n", "# Compute the performance with the initial state ", "\n", "# starting at fixed grid locations", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "# Scores images are stored as BxNxMx3x32x32 images with all values in an image proportional to", "\n", "# the assigned score. ", "\n", "utility_image", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "N", ",", "M", ",", "N", ",", "M", ",", "C", ",", "H", ",", "W", ")", ")", "\n", "# Scores matrices are stored as BxNxM matrices with one value corresponding to one view. ", "\n", "utility_matrix", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "N", ",", "M", ",", "N", ",", "M", ")", ")", "\n", "\n", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "state", "=", "State", "(", "pano", ",", "None", ",", "start_idx", ",", "opts", ")", "\n", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "decoded", ",", "_", ",", "_", ",", "_", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "opts", ".", "memorize_views", "}", ")", "\n", "\n", "rec_errs_per_view", "=", "np", ".", "reshape", "(", "(", "state", ".", "views_prepro_shifted", "-", "decoded", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "**", "2", ",", "(", "batch_size", ",", "N", ",", "M", ",", "-", "1", ")", ")", ".", "sum", "(", "axis", "=", "3", ")", "\n", "rec_errs", "=", "rec_errs", "[", "0", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "opts", ".", "debug", ":", "\n", "                    ", "assert", "(", "(", "rec_errs", "-", "np", ".", "reshape", "(", "rec_errs_per_view", ",", "(", "batch_size", ",", "-", "1", ")", ")", ".", "sum", "(", "axis", "=", "1", ")", "/", "state", ".", "total_pixels", ")", ".", "sum", "(", ")", "<=", "1e-6", ")", "\n", "# Rotate the reconstruction errors by the starting view to get original orientation", "\n", "", "rec_errs_per_view", "=", "np", ".", "roll", "(", "rec_errs_per_view", ",", "j", ",", "axis", "=", "2", ")", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "utility_matrix", "[", "k", ",", "i", ",", "j", "]", "=", "1", "/", "(", "rec_errs_per_view", "[", "k", ",", ":", ",", ":", "]", "*", "1000.0", "+", "1e-8", ")", "\n", "\n", "# Rescale utility by normalizing over the utilities of taking any view @ a particular view", "\n", "", "", "", "max_v", "=", "np", ".", "max", "(", "np", ".", "max", "(", "utility_matrix", ",", "axis", "=", "2", ")", ",", "axis", "=", "1", ")", "\n", "min_v", "=", "np", ".", "min", "(", "np", ".", "min", "(", "utility_matrix", ",", "axis", "=", "2", ")", ",", "axis", "=", "1", ")", "\n", "# expanding the max and min to span over all views", "\n", "max_v", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "max_v", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", ",", ":", "]", ",", "repeats", "=", "N", ",", "axis", "=", "1", ")", ",", "repeats", "=", "M", ",", "axis", "=", "2", ")", "\n", "min_v", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "min_v", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", ",", ":", "]", ",", "repeats", "=", "N", ",", "axis", "=", "1", ")", ",", "repeats", "=", "M", ",", "axis", "=", "2", ")", "\n", "utility_matrix", "-=", "min_v", "\n", "utility_matrix", "/=", "(", "max_v", "-", "min_v", "+", "1e-8", ")", "\n", "\n", "if", "opts", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "utility_matrix", ">=", "0", ")", ".", "all", "(", ")", ")", "\n", "\n", "", "if", "opts", ".", "threshold_maps", ":", "\n", "            ", "utility_matrix", "[", "utility_matrix", ">", "0.5", "]", "=", "1", "\n", "utility_matrix", "[", "utility_matrix", "<=", "0.5", "]", "=", "0", "\n", "\n", "", "utility_image", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "utility_matrix", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ",", "repeats", "=", "C", ",", "axis", "=", "5", ")", ",", "repeats", "=", "H", ",", "axis", "=", "6", ")", ",", "repeats", "=", "W", ",", "axis", "=", "7", ")", "\n", "true_images", ".", "append", "(", "pano", ")", "\n", "utility_images", ".", "append", "(", "utility_image", ")", "\n", "utility_matrices", ".", "append", "(", "utility_matrix", ")", "\n", "\n", "", "return", "true_images", ",", "utility_images", ",", "utility_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_utility_based_rewards.main": [[108, 207], ["set_random_seeds", "tensorboardX.SummaryWriter", "DataLoader.DataLoaderSimple", "Agent", "torch.load", "torch.load", "Agent.policy.load_state_dict", "h5py.File", "json.dump", "tensorboardX.SummaryWriter.close", "h5py.File.close", "all_splits.append", "create_utility_based_rewards.get_utility_maps", "range", "np.concatenate", "np.concatenate", "h5py.File.create_dataset", "h5py.File.create_dataset", "vars", "open", "ValueError", "len", "np.zeros", "range", "np.minimum", "np.concatenate.append", "len", "range", "range", "get_submodular_views", "len", "len", "len", "np.reshape", "range", "np.reshape", "utility_images[].transpose", "torchvision.make_grid", "tensorboardX.SummaryWriter.add_image", "get_submodular_views", "np.zeros", "np.reshape", "np.repeat", "np.concatenate", "torchvision.make_grid", "tensorboardX.SummaryWriter.add_image", "true_images[].transpose", "torch.Tensor", "torch.Tensor", "np.reshape.transpose", "np.repeat", "np.reshape", "torch.Tensor", "torch.Tensor", "range", "np.repeat", "np.repeat.transpose", "range", "max", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.set_random_seeds", "home.repos.pwc.inspect_result.srama2512_sidekicks.None.create_utility_based_rewards.get_utility_maps", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_submodular_views", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_submodular_views"], ["", "def", "main", "(", "opts", ")", ":", "\n", "# Set number of actions", "\n", "    ", "opts", ".", "A", "=", "opts", ".", "delta_M", "*", "opts", ".", "delta_N", "\n", "# Set random seeds ", "\n", "set_random_seeds", "(", "opts", ".", "seed", ")", "\n", "\n", "if", "opts", ".", "dataset", "==", "0", ":", "\n", "        ", "if", "opts", ".", "mean_subtract", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "119.16", ",", "107.68", ",", "95.12", "]", "\n", "opts", ".", "std", "=", "[", "61.88", ",", "61.72", ",", "67.24", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "opts", ".", "std", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "opts", ".", "num_channels", "=", "3", "\n", "", "elif", "opts", ".", "dataset", "==", "1", ":", "\n", "        ", "if", "opts", ".", "mean_subtract", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "193.0162338615919", "]", "\n", "opts", ".", "std", "=", "[", "37.716024486312811", "]", "\n", "", "else", ":", "\n", "            ", "opts", ".", "mean", "=", "[", "0", "]", "\n", "opts", ".", "std", "=", "[", "0", "]", "\n", "", "opts", ".", "num_channels", "=", "1", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Dataset %d does not exist!'", "%", "(", "opts", ".", "dataset", ")", ")", "\n", "\n", "# Create tensorboard writer", "\n", "", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "opts", ".", "save_path_vis", ")", "\n", "\n", "loader", "=", "DataLoader", "(", "opts", ")", "\n", "agent", "=", "Agent", "(", "opts", ",", "mode", "=", "'eval'", ")", "\n", "loaded_state", "=", "torch", ".", "load", "(", "opts", ".", "load_model", ")", "\n", "agent", ".", "policy", ".", "load_state_dict", "(", "loaded_state", "[", "'state_dict'", "]", ")", "\n", "\n", "h5file", "=", "h5py", ".", "File", "(", "opts", ".", "save_path_h5", ",", "'w'", ")", "\n", "\n", "all_splits", "=", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "if", "opts", ".", "dataset", "==", "1", ":", "\n", "        ", "all_splits", ".", "append", "(", "'test_unseen'", ")", "\n", "\n", "", "for", "split", "in", "all_splits", ":", "\n", "        ", "true_images", ",", "utility_images", ",", "utility_matrices", "=", "get_utility_maps", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", "\n", "reward_matrices", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "true_images", ")", ")", ":", "\n", "            ", "shape", "=", "true_images", "[", "i", "]", ".", "shape", "\n", "reward_matrix", "=", "np", ".", "zeros", "(", "(", "shape", "[", "0", "]", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "for", "j", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "                ", "optimal_views", ",", "utility_value", "=", "get_submodular_views", "(", "utility_matrices", "[", "i", "]", "[", "j", "]", ",", "4", ")", "\n", "for", "k", "in", "optimal_views", ":", "\n", "                    ", "for", "itera", "in", "[", "a_val", "%", "opts", ".", "N", "for", "a_val", "in", "range", "(", "k", "[", "0", "]", "-", "opts", ".", "nms_nbd", ",", "k", "[", "0", "]", "+", "opts", ".", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                        ", "for", "iterb", "in", "[", "b_val", "%", "opts", ".", "M", "for", "b_val", "in", "range", "(", "k", "[", "1", "]", "-", "opts", ".", "nms_nbd", ",", "k", "[", "1", "]", "+", "opts", ".", "nms_nbd", "+", "1", ")", "]", ":", "\n", "                            ", "reward_matrix", "[", "j", ",", "itera", ",", "iterb", "]", "+=", "255.0", "/", "4.0", "**", "(", "max", "(", "abs", "(", "k", "[", "0", "]", "-", "itera", ")", ",", "abs", "(", "k", "[", "1", "]", "-", "iterb", ")", ")", ")", "\n", "", "", "", "", "reward_matrix", "=", "np", ".", "minimum", "(", "reward_matrix", ",", "255.0", ")", "\n", "reward_matrices", ".", "append", "(", "reward_matrix", ")", "\n", "\n", "", "if", "opts", ".", "debug", ":", "\n", "            ", "num_batches", "=", "len", "(", "true_images", ")", "\n", "assert", "(", "len", "(", "utility_images", ")", "==", "num_batches", ")", "\n", "assert", "(", "len", "(", "utility_matrices", ")", "==", "num_batches", ")", "\n", "for", "i", "in", "range", "(", "num_batches", ")", ":", "\n", "                ", "batch_size", "=", "true_images", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "assert", "(", "utility_images", "[", "i", "]", ".", "shape", "==", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "opts", ".", "num_channels", ",", "8", ",", "8", ")", ")", "\n", "assert", "(", "utility_matrices", "[", "i", "]", ".", "shape", "==", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "\n", "", "", "if", "split", "==", "'val'", ":", "\n", "            ", "images_count", "=", "0", "\n", "# Iterate through the different batches", "\n", "for", "i", "in", "range", "(", "len", "(", "true_images", ")", ")", ":", "\n", "                ", "shape", "=", "true_images", "[", "i", "]", ".", "shape", "\n", "true_images", "[", "i", "]", "=", "np", ".", "reshape", "(", "true_images", "[", "i", "]", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ",", "(", "shape", "[", "0", "]", ",", "1", ",", "shape", "[", "3", "]", ",", "shape", "[", "1", "]", "*", "shape", "[", "4", "]", ",", "shape", "[", "2", "]", "*", "shape", "[", "5", "]", ")", ")", "/", "255.0", "\n", "utility_images_normal", "=", "np", ".", "reshape", "(", "utility_images", "[", "i", "]", ".", "transpose", "(", "0", ",", "1", ",", "2", ",", "5", ",", "3", ",", "6", ",", "4", ",", "7", ")", ",", "(", "shape", "[", "0", "]", ",", "opts", ".", "N", "*", "opts", ".", "M", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "8", ",", "opts", ".", "M", "*", "8", ")", ")", "\n", "for", "j", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "x", "=", "vutils", ".", "make_grid", "(", "torch", ".", "Tensor", "(", "utility_images_normal", "[", "j", "]", ")", ",", "padding", "=", "3", ",", "normalize", "=", "False", ",", "scale_each", "=", "False", ",", "nrow", "=", "opts", ".", "M", ")", "\n", "images_count", "+=", "1", "\n", "writer", ".", "add_image", "(", "'Panorama #%5.3d utility'", "%", "(", "images_count", ")", ",", "x", ",", "0", ")", "\n", "# ---- Apply submodularity based greedy algorithm to get near-optimal views ----", "\n", "optimal_views", ",", "utility_value", "=", "get_submodular_views", "(", "utility_matrices", "[", "i", "]", "[", "j", "]", ",", "4", ")", "\n", "optimal_views_images", "=", "np", ".", "zeros", "(", "(", "opts", ".", "N", ",", "opts", ".", "M", ",", "opts", ".", "num_channels", ",", "32", ",", "32", ")", ")", "\n", "# Convert the scores into images for visualization", "\n", "for", "k", "in", "optimal_views", ":", "\n", "                        ", "optimal_views_images", "[", "k", "[", "0", "]", ",", "k", "[", "1", "]", "]", "=", "1.0", "\n", "", "optimal_views_images", "=", "np", ".", "reshape", "(", "optimal_views_images", ".", "transpose", "(", "2", ",", "0", ",", "3", ",", "1", ",", "4", ")", ",", "(", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", ")", "\n", "# Get the reward image computed based on optimal_views", "\n", "reward_image", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "reward_matrices", "[", "i", "]", "[", "j", "]", "[", ":", ",", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ",", "repeats", "=", "opts", ".", "num_channels", ",", "axis", "=", "2", ")", ",", "repeats", "=", "32", ",", "axis", "=", "3", ")", ",", "repeats", "=", "32", ",", "axis", "=", "4", ")", "\n", "reward_image", "=", "np", ".", "reshape", "(", "reward_image", ".", "transpose", "(", "2", ",", "0", ",", "3", ",", "1", ",", "4", ")", ",", "(", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", ")", "/", "255.0", "\n", "\n", "# Concatenate the true image, optimal view image and reward image for display", "\n", "concatenated_images", "=", "np", ".", "concatenate", "(", "[", "true_images", "[", "i", "]", "[", "j", "]", ",", "optimal_views_images", ",", "reward_image", "]", ",", "axis", "=", "0", ")", "\n", "x", "=", "vutils", ".", "make_grid", "(", "torch", ".", "Tensor", "(", "concatenated_images", ")", ",", "padding", "=", "3", ",", "normalize", "=", "False", ",", "scale_each", "=", "False", ",", "nrow", "=", "1", ")", "\n", "writer", ".", "add_image", "(", "'Panorama #%5.3d image'", "%", "(", "images_count", ")", ",", "x", ",", "0", ")", "\n", "\n", "\n", "", "", "", "utility_matrices", "=", "np", ".", "concatenate", "(", "utility_matrices", ",", "axis", "=", "0", ")", "\n", "reward_matrices", "=", "np", ".", "concatenate", "(", "reward_matrices", ",", "axis", "=", "0", ")", "\n", "h5file", ".", "create_dataset", "(", "'%s/utility_maps'", "%", "split", ",", "data", "=", "utility_matrices", ")", "\n", "h5file", ".", "create_dataset", "(", "'%s/nms'", "%", "(", "split", ")", ",", "data", "=", "reward_matrices", ")", "\n", "\n", "", "json", ".", "dump", "(", "vars", "(", "opts", ")", ",", "open", "(", "opts", ".", "save_path_json", ",", "'w'", ")", ")", "\n", "writer", ".", "close", "(", ")", "\n", "h5file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.State.__init__": [[40, 152], ["copy.deepcopy", "range", "State.preprocess_views", "numpy.zeros_like", "range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "range", "numpy.copy", "numpy.zeros", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "State.State.masks.cuda", "State.State.masks.view", "range", "numpy.roll", "len", "len", "numpy.roll", "numpy.roll", "State.State.masks_sum.size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "numpy.roll", "numpy.roll"], "methods", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.preprocess_views"], ["def", "__init__", "(", "self", ",", "views", ",", "views_rewards", ",", "start_idx", ",", "opts", ",", "masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            N = # elevations\n            M = # azimuths\n            views: B x N x M x C x H x W array \n            views_rewards: B x N x M array\n            start_idx: Initial views for B panoramas [..., [elevation_idx, azimuth_idx], ...]\n\n            init sets up the settings, data in the state and preprocesses the views\n            settings needed:\n            Panorama navigation settings:\n            (1) M, N, A, C (2) start_idx (3) idx (4) delta (5) actOn*, known*, wrap*\n            (6) act_to_delta, delta_to_act\n            Data settings:\n            (1) batch_size (2) normalization (3) total_pixels (4) debug\n        \"\"\"", "\n", "\n", "# ---- Panorama navigation settings ----", "\n", "self", ".", "M", "=", "opts", ".", "M", "\n", "self", ".", "N", "=", "opts", ".", "N", "\n", "self", ".", "A", "=", "opts", ".", "delta_M", "*", "opts", ".", "delta_N", "\n", "self", ".", "C", "=", "opts", ".", "num_channels", "\n", "self", ".", "start_idx", "=", "start_idx", "# Stored for the purpose of computing the loss", "\n", "self", ".", "idx", "=", "copy", ".", "deepcopy", "(", "start_idx", ")", "# Current view of the state", "\n", "# Proprioception is [elevation, change in azimuth]", "\n", "# Whether elevation and azimuth are fed to act module or not", "\n", "self", ".", "actOnElev", "=", "opts", ".", "actOnElev", "\n", "self", ".", "actOnAzim", "=", "opts", ".", "actOnAzim", "\n", "# Whether azimuth, elevation are known to the sensor or not", "\n", "self", ".", "knownElev", "=", "opts", ".", "knownElev", "\n", "self", ".", "knownAzim", "=", "opts", ".", "knownAzim", "\n", "# Whether to wrap around elevation and azimuths", "\n", "self", ".", "wrap_elevation", "=", "opts", ".", "wrap_elevation", "\n", "self", ".", "wrap_azimuth", "=", "opts", ".", "wrap_azimuth", "\n", "# delta_M is the number of azimuths available to rotate to, usually odd", "\n", "# delta_N is the number of elevations available to rotate to, usually odd", "\n", "if", "masks", "is", "None", ":", "\n", "            ", "self", ".", "hasmasks", "=", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "hasmasks", "=", "True", "\n", "self", ".", "masks", "=", "Variable", "(", "torch", ".", "Tensor", "(", "masks", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "opts", ".", "iscuda", ":", "\n", "                ", "self", ".", "masks", "=", "self", ".", "masks", ".", "cuda", "(", ")", "\n", "", "self", ".", "masks_sum", "=", "torch", ".", "sum", "(", "self", ".", "masks", ".", "view", "(", "views", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "self", ".", "debug", "=", "opts", ".", "debug", "\n", "if", "self", ".", "debug", ":", "\n", "# These are necessary for the next step", "\n", "            ", "assert", "(", "opts", ".", "delta_N", "%", "2", "==", "1", ")", "\n", "assert", "(", "opts", ".", "delta_M", "%", "2", "==", "1", ")", "\n", "# Decodes actions to the corresponding changes in elevation and azimuth", "\n", "", "self", ".", "act_to_delta", "=", "{", "}", "\n", "self", ".", "delta_to_act", "=", "{", "}", "\n", "count_act", "=", "0", "\n", "for", "i", "in", "range", "(", "-", "(", "opts", ".", "delta_N", "//", "2", ")", ",", "opts", ".", "delta_N", "//", "2", "+", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "-", "(", "opts", ".", "delta_M", "//", "2", ")", ",", "opts", ".", "delta_M", "//", "2", "+", "1", ")", ":", "\n", "                ", "self", ".", "act_to_delta", "[", "count_act", "]", "=", "(", "i", ",", "j", ")", "\n", "self", ".", "delta_to_act", "[", "(", "i", ",", "j", ")", "]", "=", "count_act", "\n", "count_act", "+=", "1", "\n", "\n", "# ---- Data settings ----", "\n", "", "", "self", ".", "batch_size", "=", "views", ".", "shape", "[", "0", "]", "\n", "self", ".", "delta", "=", "[", "[", "0", ",", "0", "]", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "]", "# Starts off with no change", "\n", "# Store mean and std to preprocess the views", "\n", "self", ".", "mean", "=", "opts", ".", "mean", "\n", "self", ".", "std", "=", "opts", ".", "std", "\n", "# total_pixels is useful for computing MSE", "\n", "self", ".", "total_pixels", "=", "self", ".", "M", "*", "self", ".", "N", "*", "views", ".", "shape", "[", "3", "]", "*", "views", ".", "shape", "[", "4", "]", "*", "views", ".", "shape", "[", "5", "]", "\n", "\n", "# ---- Save panorama data to the state and preprocess ---- ", "\n", "self", ".", "views", "=", "views", "\n", "if", "views_rewards", "is", "not", "None", ":", "\n", "            ", "self", ".", "views_rewards", "=", "np", ".", "copy", "(", "views_rewards", ")", "# To create a copy", "\n", "self", ".", "has_rewards", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "views_rewards", "=", "np", ".", "zeros", "(", "(", "views", ".", "shape", "[", "0", "]", ",", "views", ".", "shape", "[", "1", "]", ",", "views", ".", "shape", "[", "2", "]", ")", ")", "\n", "self", ".", "has_rewards", "=", "False", "\n", "\n", "# Compute preprocessed views", "\n", "", "if", "self", ".", "debug", ":", "\n", "# Ensure that the 4th idx is the channel", "\n", "            ", "assert", "(", "self", ".", "views", ".", "shape", "[", "3", "]", "==", "1", "or", "self", ".", "views", ".", "shape", "[", "3", "]", "==", "3", ")", "\n", "", "self", ".", "views_prepro", "=", "preprocess_views", "(", "self", ".", "views", ",", "self", ".", "mean", ",", "self", ".", "std", ")", "\n", "# Shift each panorama in views_prepro according to corresponding start_idxes", "\n", "# Rotate the original views such that the 0th azimuth is the start azimuth (if azimuth", "\n", "# is not known to the agent) or the 0th elevation is the start elevation (if elevation ", "\n", "# is not known to the agent)", "\n", "self", ".", "views_prepro_shifted", "=", "np", ".", "zeros_like", "(", "self", ".", "views_prepro", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "if", "not", "(", "self", ".", "knownElev", "or", "self", ".", "knownAzim", ")", ":", "\n", "# Shift the azimuth and elevation", "\n", "                ", "self", ".", "views_prepro_shifted", "[", "i", "]", "=", "np", ".", "roll", "(", "np", ".", "roll", "(", "self", ".", "views_prepro", "[", "i", "]", ",", "-", "start_idx", "[", "i", "]", "[", "1", "]", ",", "axis", "=", "1", ")", ",", "-", "start_idx", "[", "i", "]", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "", "elif", "not", "self", ".", "knownAzim", ":", "\n", "# Shift the azimuths", "\n", "                ", "self", ".", "views_prepro_shifted", "[", "i", "]", "=", "np", ".", "roll", "(", "self", ".", "views_prepro", "[", "i", "]", ",", "-", "start_idx", "[", "i", "]", "[", "1", "]", ",", "axis", "=", "1", ")", "\n", "", "elif", "not", "self", ".", "knownElev", ":", "\n", "# Shift the elevations", "\n", "                ", "self", ".", "views_prepro_shifted", "[", "i", "]", "=", "np", ".", "roll", "(", "self", ".", "views_prepro", "[", "i", "]", ",", "-", "start_idx", "[", "i", "]", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# ---- Debug ----", "\n", "", "", "self", ".", "W", "=", "views", ".", "shape", "[", "5", "]", "\n", "self", ".", "H", "=", "views", ".", "shape", "[", "4", "]", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "self", ".", "views", ".", "shape", "==", "(", "self", ".", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "assert", "(", "(", "self", ".", "views_prepro", "[", "0", "]", "==", "np", ".", "roll", "(", "self", ".", "views_prepro_shifted", "[", "0", "]", ",", "start_idx", "[", "0", "]", "[", "1", "]", ",", "axis", "=", "1", ")", ")", ".", "all", "(", ")", ")", "\n", "assert", "(", "(", "self", ".", "views_prepro_shifted", "<=", "1", ")", ".", "all", "(", ")", "and", "(", "self", ".", "views_prepro_shifted", ">=", "-", "1", ")", ".", "all", "(", ")", ")", "\n", "assert", "(", "self", ".", "A", "==", "len", "(", "self", ".", "act_to_delta", ")", ")", "\n", "assert", "(", "self", ".", "A", "==", "len", "(", "self", ".", "delta_to_act", ")", ")", "\n", "for", "key", "in", "self", ".", "act_to_delta", ":", "\n", "                ", "assert", "(", "(", "key", "<", "self", ".", "A", ")", "and", "(", "key", ">=", "0", ")", ")", "\n", "", "if", "self", ".", "hasmasks", ":", "\n", "                ", "assert", "(", "self", ".", "masks_sum", ".", "size", "(", ")", "==", "torch", ".", "Size", "(", "[", "self", ".", "batch_size", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.State.get_view": [[153, 173], ["copy.deepcopy", "range", "len", "pro_out[].append", "pro_out[].append", "range", "range", "len", "len"], "methods", ["None"], ["", "", "", "def", "get_view", "(", "self", ",", "prepro", "=", "True", ")", ":", "\n", "# Returns the current view and proprioception for each panorama", "\n", "# output view: BxCx32x32", "\n", "# output proprioception: list of [delta_elev, delta_azim, elev (optional), azim (optional)]", "\n", "\n", "        ", "pro_out", "=", "copy", ".", "deepcopy", "(", "self", ".", "delta", ")", "\n", "if", "self", ".", "knownElev", "or", "self", ".", "knownAzim", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "pro_out", ")", ")", ":", "\n", "                ", "if", "self", ".", "knownElev", ":", "\n", "                    ", "pro_out", "[", "i", "]", ".", "append", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", ")", "\n", "", "if", "self", ".", "knownAzim", ":", "\n", "                    ", "pro_out", "[", "i", "]", ".", "append", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", ")", "\n", "\n", "# Using python advanced indexing to get views for all panoramas simultaneously", "\n", "", "", "", "if", "prepro", ":", "\n", "            ", "return", "self", ".", "views_prepro", "[", "range", "(", "len", "(", "self", ".", "idx", ")", ")", ",", "[", "i", "[", "0", "]", "for", "i", "in", "self", ".", "idx", "]", ",", "[", "i", "[", "1", "]", "for", "i", "in", "self", ".", "idx", "]", "]", ",", "pro_out", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "views", "[", "range", "(", "len", "(", "self", ".", "idx", ")", ")", ",", "[", "i", "[", "0", "]", "for", "i", "in", "self", ".", "idx", "]", ",", "[", "i", "[", "1", "]", "for", "i", "in", "self", ".", "idx", "]", "]", ",", "pro_out", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.State.rotate": [[174, 201], ["numpy.copy", "list", "range", "range", "len", "range", "range", "range", "max", "range", "range", "min", "max", "range", "max", "max", "range", "len", "min", "min", "min"], "methods", ["None"], ["", "", "def", "rotate", "(", "self", ",", "act", ")", ":", "\n", "# Rotates the state by delta corresponding to act. Returns the reward (intrinsic)", "\n", "# corresponding to this transition. ", "\n", "# act: tensor of integers between 0 to opts.delta_M * opts.delta_N", "\n", "# output reward: reward corresponding to visited view (optional)", "\n", "\n", "        ", "delta", "=", "[", "list", "(", "self", ".", "act_to_delta", "[", "act", "[", "i", "]", "]", ")", "for", "i", "in", "range", "(", "act", ".", "shape", "[", "0", "]", ")", "]", "\n", "self", ".", "delta", "=", "delta", "\n", "if", "self", ".", "wrap_elevation", "and", "self", ".", "wrap_azimuth", ":", "\n", "            ", "self", ".", "idx", "=", "[", "[", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "+", "delta", "[", "i", "]", "[", "0", "]", ")", "%", "self", ".", "N", ",", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "+", "delta", "[", "i", "]", "[", "1", "]", ")", "%", "self", ".", "M", "]", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "]", "\n", "", "elif", "self", ".", "wrap_elevation", ":", "\n", "            ", "self", ".", "idx", "=", "[", "[", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "+", "delta", "[", "i", "]", "[", "0", "]", ")", "%", "self", ".", "N", ",", "max", "(", "min", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "+", "delta", "[", "i", "]", "[", "1", "]", ",", "self", ".", "M", "-", "1", ")", ",", "0", ")", "]", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "]", "\n", "", "elif", "self", ".", "wrap_azimuth", ":", "\n", "            ", "self", ".", "idx", "=", "[", "[", "max", "(", "min", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "+", "delta", "[", "i", "]", "[", "0", "]", ",", "self", ".", "N", "-", "1", ")", ",", "0", ")", ",", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "+", "delta", "[", "i", "]", "[", "1", "]", ")", "%", "self", ".", "M", "]", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "idx", "=", "[", "[", "max", "(", "min", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "+", "delta", "[", "i", "]", "[", "0", "]", ",", "self", ".", "N", "-", "1", ")", ",", "0", ")", ",", "max", "(", "min", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "+", "delta", "[", "i", "]", "[", "1", "]", ",", "self", ".", "M", "-", "1", ")", ",", "0", ")", "]", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "]", "\n", "\n", "# After reaching the next state, return the reward for this transition", "\n", "# Collect rewards and then zero them out.", "\n", "", "rewards_copy", "=", "np", ".", "copy", "(", "self", ".", "views_rewards", "[", "range", "(", "len", "(", "self", ".", "idx", ")", ")", ",", "[", "i", "[", "0", "]", "for", "i", "in", "self", ".", "idx", "]", ",", "[", "i", "[", "1", "]", "for", "i", "in", "self", ".", "idx", "]", "]", ")", "\n", "if", "self", ".", "has_rewards", ":", "# To save some compute time", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "idx", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "-", "1", ",", "self", ".", "idx", "[", "i", "]", "[", "0", "]", "+", "2", ")", ":", "\n", "                    ", "for", "k", "in", "range", "(", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "-", "1", ",", "self", ".", "idx", "[", "i", "]", "[", "1", "]", "+", "2", ")", ":", "\n", "                        ", "self", ".", "views_rewards", "[", "i", ",", "j", "%", "self", ".", "N", ",", "k", "%", "self", ".", "M", "]", "=", "0", "\n", "\n", "", "", "", "", "return", "rewards_copy", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.State.rec_loss": [[202, 213], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "true_views.cuda.cuda.cuda"], "methods", ["None"], ["", "def", "rec_loss", "(", "self", ",", "rec_views", ",", "iscuda", ")", ":", "\n", "# Computes loss between self.views and rec_views with start_idx shift", "\n", "# rec_views: B x N x M x C x H x W torch Variable with preprocessed values", "\n", "# masks: B x N x M x C x H x W torch Variable ", "\n", "        ", "true_views", "=", "Variable", "(", "torch", ".", "Tensor", "(", "self", ".", "views_prepro_shifted", ")", ")", "\n", "if", "iscuda", ":", "\n", "            ", "true_views", "=", "true_views", ".", "cuda", "(", ")", "\n", "", "if", "not", "self", ".", "hasmasks", ":", "\n", "            ", "return", "(", "(", "true_views", "-", "rec_views", ")", "**", "2", ")", ".", "view", "(", "self", ".", "batch_size", ",", "-", "1", ")", ".", "sum", "(", "dim", "=", "1", ")", "/", "(", "self", ".", "total_pixels", ")", "\n", "", "else", ":", "\n", "            ", "return", "(", "self", ".", "masks", "*", "(", "true_views", "-", "rec_views", ")", "**", "2", ")", ".", "view", "(", "self", ".", "batch_size", ",", "-", "1", ")", ".", "sum", "(", "dim", "=", "1", ")", "/", "self", ".", "masks_sum", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.preprocess_views": [[13, 24], ["pano.astype", "range", "len"], "function", ["None"], ["def", "preprocess_views", "(", "pano", ",", "mean", ",", "std", ")", ":", "\n", "    ", "\"\"\"\n    This function preprocesses the input views by subtracting the mean and dividing by the standard deviation\n    pano: BxNxMxCxHxW numpy array\n    \"\"\"", "\n", "pano_float", "=", "pano", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "c", "in", "range", "(", "len", "(", "mean", ")", ")", ":", "\n", "        ", "pano_float", "[", ":", ",", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "-=", "mean", "[", "c", "]", "\n", "# Ignore this because it affects the MSE computation later", "\n", "#pano_float[:, :, :, c, :, :] /= std[c]", "\n", "", "return", "pano_float", "/", "255.0", "# Scale pixel values from [0, 255] to [0, 1] range", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.State.preprocess": [[25, 33], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "def", "preprocess", "(", "im", ",", "pro", ")", ":", "\n", "    ", "\"\"\"\n        This function converts the numpy arrays or lists to tensors and returns it.\n        Can be augmented with different operations in the future if needed (like augmentation).\n        im: BxCxHxW images \n        pro: list of list of integers [delta_elev, delta_azim, elev (optional), azim (optional)]\n    \"\"\"", "\n", "return", "torch", ".", "Tensor", "(", "im", ")", ",", "torch", ".", "Tensor", "(", "pro", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderSimple.__init__": [[13, 75], ["h5py.File", "numpy.array", "numpy.array", "numpy.array", "list", "DataLoader.DataLoaderSimple.h5_file.keys", "numpy.array", "numpy.array", "h5py.File", "numpy.array", "hasattr", "h5py.File", "numpy.array", "range", "random.shuffle", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opts", ")", ":", "\n", "        ", "\"\"\"\n        Loads the dataset and saves settings needed:\n        (1) dataset statistics (2) shuffle (3) debug statistics (4) iteration tracker  \n        Opts required: seed, h5_path, shuffle, batch_size, h5_path_unseen (optional)\n        mask_path (optional)\n        \"\"\"", "\n", "# ---- Load the dataset ----", "\n", "self", ".", "h5_file", "=", "h5py", ".", "File", "(", "opts", ".", "h5_path", ",", "'r'", ")", "\n", "self", ".", "data", "=", "{", "}", "\n", "self", ".", "data", "[", "'train'", "]", "=", "np", ".", "array", "(", "self", ".", "h5_file", "[", "'train'", "]", ")", "\n", "self", ".", "data", "[", "'val'", "]", "=", "np", ".", "array", "(", "self", ".", "h5_file", "[", "'val'", "]", ")", "\n", "self", ".", "data", "[", "'test'", "]", "=", "np", ".", "array", "(", "self", ".", "h5_file", "[", "'test'", "]", ")", "\n", "if", "'val_highres'", "in", "self", ".", "h5_file", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "data", "[", "'val_highres'", "]", "=", "np", ".", "array", "(", "self", ".", "h5_file", "[", "'val_highres'", "]", ")", "\n", "self", ".", "data", "[", "'test_highres'", "]", "=", "np", ".", "array", "(", "self", ".", "h5_file", "[", "'test_highres'", "]", ")", "\n", "\n", "# ---- Load the unseen classes ----", "\n", "", "if", "opts", ".", "h5_path_unseen", "!=", "''", ":", "\n", "            ", "h5_file_unseen", "=", "h5py", ".", "File", "(", "opts", ".", "h5_path_unseen", ",", "'r'", ")", "\n", "self", ".", "data", "[", "'test_unseen'", "]", "=", "np", ".", "array", "(", "h5_file_unseen", "[", "'test'", "]", ")", "\n", "# ---- Save settings needed for batching operations ----", "\n", "# Dataset statistics", "\n", "", "self", ".", "train_count", "=", "self", ".", "h5_file", "[", "'train'", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "val_count", "=", "self", ".", "h5_file", "[", "'val'", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "test_count", "=", "self", ".", "h5_file", "[", "'test'", "]", ".", "shape", "[", "0", "]", "\n", "if", "opts", ".", "h5_path_unseen", "!=", "''", ":", "\n", "            ", "self", ".", "test_unseen_count", "=", "self", ".", "data", "[", "'test_unseen'", "]", ".", "shape", "[", "0", "]", "\n", "", "if", "hasattr", "(", "opts", ",", "'mask_path'", ")", "and", "opts", ".", "mask_path", "!=", "''", ":", "\n", "            ", "mask_file", "=", "h5py", ".", "File", "(", "opts", ".", "mask_path", ",", "'r'", ")", "\n", "self", ".", "masks", "=", "{", "}", "\n", "self", ".", "masks", "[", "'test'", "]", "=", "np", ".", "array", "(", "mask_file", "[", "'test_mask'", "]", ")", "\n", "if", "opts", ".", "h5_path_unseen", "!=", "''", ":", "\n", "                ", "self", ".", "masks", "[", "'test_unseen'", "]", "=", "np", ".", "array", "(", "mask_file", "[", "'test_unseen_mask'", "]", ")", "\n", "", "self", ".", "hasmasks", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "hasmasks", "=", "False", "\n", "\n", "", "self", ".", "pano_shape", "=", "self", ".", "h5_file", "[", "'train'", "]", ".", "shape", "[", "1", ":", "]", "\n", "# Iteration tracker ", "\n", "self", ".", "train_idx", "=", "0", "\n", "self", ".", "val_idx", "=", "0", "\n", "self", ".", "test_idx", "=", "0", "\n", "if", "opts", ".", "h5_path_unseen", "!=", "''", ":", "\n", "            ", "self", ".", "test_unseen_idx", "=", "0", "\n", "\n", "", "self", ".", "batch_size", "=", "opts", ".", "batch_size", "\n", "# Shuffle the training data indices and access them in the shuffled order", "\n", "self", ".", "shuffle", "=", "opts", ".", "shuffle", "\n", "self", ".", "shuffled_idx", "=", "list", "(", "range", "(", "self", ".", "h5_file", "[", "'train'", "]", ".", "shape", "[", "0", "]", ")", ")", "\n", "if", "self", ".", "shuffle", ":", "\n", "            ", "random", ".", "shuffle", "(", "self", ".", "shuffled_idx", ")", "\n", "# Debug mode", "\n", "", "self", ".", "debug", "=", "opts", ".", "debug", "\n", "self", ".", "N", "=", "self", ".", "data", "[", "'train'", "]", ".", "shape", "[", "1", "]", "\n", "self", ".", "M", "=", "self", ".", "data", "[", "'train'", "]", ".", "shape", "[", "2", "]", "\n", "self", ".", "C", "=", "self", ".", "data", "[", "'train'", "]", ".", "shape", "[", "3", "]", "\n", "self", ".", "H", "=", "self", ".", "data", "[", "'train'", "]", ".", "shape", "[", "4", "]", "\n", "self", ".", "W", "=", "self", ".", "data", "[", "'train'", "]", ".", "shape", "[", "5", "]", "\n", "if", "'val_highres'", "in", "self", ".", "data", ":", "\n", "            ", "self", ".", "H_highres", "=", "self", ".", "data", "[", "'val_highres'", "]", ".", "shape", "[", "4", "]", "\n", "self", ".", "W_highres", "=", "self", ".", "data", "[", "'test_highres'", "]", ".", "shape", "[", "5", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderSimple.next_batch_train": [[76, 98], ["min", "numpy.array"], "methods", ["None"], ["", "", "def", "next_batch_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next training batch (indexed by self.shuffled_idx and starting at self.train_idx)\n        out: BxNxMxCx32x32\n        depleted: is the epoch over?\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "train_count", "-", "self", ".", "train_idx", ")", "\n", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "\n", "", "if", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "train_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "train_idx", "=", "self", ".", "train_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderSimple.next_batch_val": [[99, 128], ["min", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "next_batch_val", "(", "self", ",", "highres", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next validation batch\n        out: BxNxMxCx32x32\n        out_highres: BxNxMxCx448x448 (optional)\n        depleted: is the epoch over?\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "val_count", "-", "self", ".", "val_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "if", "highres", ":", "\n", "            ", "out_highres", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'val_highres'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "highres", ":", "\n", "                ", "assert", "(", "out_highres", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H_highres", ",", "self", ".", "W_highres", ")", ")", "\n", "\n", "", "", "if", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "val_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "val_idx", "=", "self", ".", "val_idx", "+", "batch_size", "\n", "\n", "", "if", "not", "highres", ":", "\n", "            ", "return", "out", ",", "depleted", "\n", "", "else", ":", "\n", "            ", "return", "out", ",", "out_highres", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderSimple.next_batch_test": [[129, 165], ["min", "numpy.array", "numpy.array"], "methods", ["None"], ["", "", "def", "next_batch_test", "(", "self", ",", "highres", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next testing batch\n        out: BxNxMxCx32x32\n        out_highres: BxNxMxCx448x448 (optional)\n        depleted: is the epoch over?\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "test_count", "-", "self", ".", "test_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "if", "highres", ":", "\n", "            ", "out_highres", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test_highres'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "", "if", "self", ".", "hasmasks", ":", "\n", "            ", "out_masks", "=", "self", ".", "masks", "[", "'test'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "out_masks", "=", "None", "\n", "\n", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "test_idx", "+", "batch_size", "==", "self", ".", "test_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "highres", ":", "\n", "                ", "assert", "(", "out_highres", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H_highres", ",", "self", ".", "W_highres", ")", ")", "\n", "", "if", "self", ".", "hasmasks", ":", "\n", "                ", "assert", "(", "out_masks", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "\n", "", "", "if", "self", ".", "test_idx", "+", "batch_size", "==", "self", ".", "test_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "test_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "test_idx", "=", "self", ".", "test_idx", "+", "batch_size", "\n", "\n", "", "if", "not", "highres", ":", "\n", "            ", "return", "out", ",", "out_masks", ",", "depleted", "\n", "", "else", ":", "\n", "            ", "return", "out", ",", "out_highres", ",", "out_masks", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderSimple.next_batch_test_unseen": [[166, 190], ["min", "numpy.array"], "methods", ["None"], ["", "", "def", "next_batch_test_unseen", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next unseen classes testing batch\n        out: BxNxMxCx32x32\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "test_unseen_count", "-", "self", ".", "test_unseen_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "if", "self", ".", "hasmasks", ":", "\n", "            ", "out_masks", "=", "self", ".", "masks", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "out_masks", "=", "None", "\n", "\n", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "test_unseen_idx", "+", "batch_size", "==", "self", ".", "test_unseen_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "\n", "", "if", "self", ".", "test_unseen_idx", "+", "batch_size", "==", "self", ".", "test_unseen_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "test_unseen_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "test_unseen_idx", "=", "self", ".", "test_unseen_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_masks", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpert.__init__": [[196, 211], ["DataLoader.DataLoaderSimple.__init__", "h5py.File", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.__init__"], ["def", "__init__", "(", "self", ",", "opts", ")", ":", "\n", "        ", "\"\"\"\n        Loads the dataset, rewards and saves settings needed:\n        (1) dataset statistics (2) shuffle (3) debug statistics (4) iteration tracker  \n        Opts required: seed, h5_path, shuffle, batch_size, rewards_h5_path\n        \"\"\"", "\n", "# ---- Load the dataset, save settings ----", "\n", "super", "(", "DataLoaderExpert", ",", "self", ")", ".", "__init__", "(", "opts", ")", "\n", "# ---- Load the rewards ----", "\n", "rewards_file", "=", "h5py", ".", "File", "(", "opts", ".", "rewards_h5_path", ")", "\n", "self", ".", "rewards", "=", "{", "}", "\n", "# These are KxNxM arrays containing rewards corresponding to each views of", "\n", "# all panoramas in the train and val splits", "\n", "self", ".", "rewards", "[", "'train'", "]", "=", "np", ".", "array", "(", "rewards_file", "[", "'train/nms'", "]", ")", "\n", "self", ".", "rewards", "[", "'val'", "]", "=", "np", ".", "array", "(", "rewards_file", "[", "'val/nms'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpert.next_batch_train": [[212, 236], ["min", "numpy.array"], "methods", ["None"], ["", "def", "next_batch_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next training batch (indexed by self.shuffled_idx and starting at self.train_idx)\n        out: BxNxMxCx32x32\n        out_rewards: BxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "train_count", "-", "self", ".", "train_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "out_rewards", "=", "self", ".", "rewards", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", "]", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "assert", "(", "out_rewards", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "\n", "", "if", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "train_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "train_idx", "=", "self", ".", "train_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_rewards", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpert.next_batch_val": [[237, 261], ["min"], "methods", ["None"], ["", "def", "next_batch_val", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next validation batch\n        out: BxNxMxCx32x32\n        out_rewards: BxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "val_count", "-", "self", ".", "val_idx", ")", "\n", "\n", "out", "=", "self", ".", "data", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "out_rewards", "=", "self", ".", "rewards", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", "]", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "assert", "(", "out_rewards", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "\n", "", "if", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "val_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "val_idx", "=", "self", ".", "val_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_rewards", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.__init__": [[267, 290], ["DataLoader.DataLoaderSimple.__init__", "h5py.File", "h5py.File.keys", "numpy.array", "torch.load", "ValueError"], "methods", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.__init__"], ["def", "__init__", "(", "self", ",", "opts", ")", ":", "\n", "        ", "\"\"\"\n        Loads the dataset, utility maps and saves settings needed:\n        (1) dataset statistics (2) shuffle (3) debug statistics (4) iteration tracker  \n        Opts required: seed, h5_path, shuffle, batch_size, utility_h5_path, h5_path_unseen, debug\n        \"\"\"", "\n", "# ---- Load the dataset, save the settings ----", "\n", "super", "(", "DataLoaderExpertPolicy", ",", "self", ")", ".", "__init__", "(", "opts", ")", "\n", "self", ".", "trajectories_type", "=", "opts", ".", "trajectories_type", "\n", "if", "opts", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "# ---- Load the utility maps ----", "\n", "            ", "utility_file", "=", "h5py", ".", "File", "(", "opts", ".", "utility_h5_path", ")", "\n", "self", ".", "utility_maps", "=", "{", "}", "\n", "# These are KxNxMxNxM arrays ", "\n", "for", "split", "in", "utility_file", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "utility_maps", "[", "split", "]", "=", "np", ".", "array", "(", "utility_file", "[", "split", "]", "[", "'utility_maps'", "]", ")", "\n", "\n", "", "", "elif", "opts", ".", "trajectories_type", "==", "'expert_trajectories'", ":", "\n", "# ---- Load the trajectories ----", "\n", "# {'train': #train_samples x T-1 numpy array, 'val': #val_samples x T-1 numpy array}", "\n", "            ", "self", ".", "trajectories", "=", "torch", ".", "load", "(", "opts", ".", "utility_h5_path", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Wrong trajectories_type!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_train": [[291, 325], ["min", "numpy.array", "range", "range", "len", "out_maps.keys"], "methods", ["None"], ["", "", "def", "next_batch_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next training batch (indexed by self.shuffled_idx and starting at self.train_idx)\n        out: BxNxMxCx32x32\n        out_maps: BxNxMxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "train_count", "-", "self", ".", "train_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "            ", "out_maps", "=", "self", ".", "utility_maps", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", "]", "\n", "", "else", ":", "\n", "            ", "out_maps", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "self", ".", "N", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "M", ")", ":", "\n", "                    ", "out_maps", "[", "(", "i", ",", "j", ")", "]", "=", "self", ".", "trajectories", "[", "'train'", "]", "[", "(", "i", ",", "j", ")", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", "]", "\n", "\n", "", "", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "                ", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "(", "len", "(", "out_maps", ".", "keys", "(", ")", ")", "==", "self", ".", "M", "*", "self", ".", "N", ")", "\n", "assert", "(", "out_maps", "[", "(", "0", ",", "0", ")", "]", ".", "shape", "[", "0", "]", "==", "batch_size", ")", "\n", "\n", "", "", "if", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "train_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "train_idx", "=", "self", ".", "train_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_maps", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_val": [[326, 360], ["min", "range", "range", "len", "out_maps.keys"], "methods", ["None"], ["", "def", "next_batch_val", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next validation batch\n        out: BxNxMxCx32x32\n        out_maps: BxNxMxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "val_count", "-", "self", ".", "val_idx", ")", "\n", "\n", "out", "=", "self", ".", "data", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "            ", "out_maps", "=", "self", ".", "utility_maps", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "out_maps", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "self", ".", "N", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "M", ")", ":", "\n", "                    ", "out_maps", "[", "(", "i", ",", "j", ")", "]", "=", "self", ".", "trajectories", "[", "'val'", "]", "[", "(", "i", ",", "j", ")", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", "]", "\n", "\n", "", "", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "                ", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "(", "len", "(", "out_maps", ".", "keys", "(", ")", ")", "==", "self", ".", "M", "*", "self", ".", "N", ")", "\n", "assert", "(", "out_maps", "[", "(", "0", ",", "0", ")", "]", ".", "shape", "[", "0", "]", "==", "batch_size", ")", "\n", "\n", "", "", "if", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "val_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "val_idx", "=", "self", ".", "val_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_maps", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test": [[361, 413], ["min", "numpy.array", "numpy.array", "range", "range", "len", "out_maps.keys"], "methods", ["None"], ["", "def", "next_batch_test", "(", "self", ",", "highres", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next testing batch\n        out: BxNxMxCx32x32\n        out_masks: ???\n        out_maps: BxNxMxNxM\n        out_highres: BxNxMxCx448x448 (optional)\n        depleted: is the epoch over?\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "test_count", "-", "self", ".", "test_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "if", "highres", ":", "\n", "            ", "out_highres", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test_highres'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "", "if", "self", ".", "hasmasks", ":", "\n", "            ", "out_masks", "=", "self", ".", "masks", "[", "'test'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "out_masks", "=", "None", "\n", "\n", "", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "            ", "out_maps", "=", "self", ".", "utility_maps", "[", "'test'", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "out_maps", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "self", ".", "N", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "M", ")", ":", "\n", "                    ", "out_maps", "[", "(", "i", ",", "j", ")", "]", "=", "self", ".", "trajectories", "[", "'test'", "]", "[", "(", "i", ",", "j", ")", "]", "[", "self", ".", "test_idx", ":", "(", "self", ".", "test_idx", "+", "batch_size", ")", ",", ":", "]", "\n", "\n", "", "", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "test_idx", "+", "batch_size", "==", "self", ".", "test_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "highres", ":", "\n", "                ", "assert", "(", "out_highres", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H_highres", ",", "self", ".", "W_highres", ")", ")", "\n", "", "if", "self", ".", "hasmasks", ":", "\n", "                ", "assert", "(", "out_masks", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "\n", "", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "                ", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "(", "len", "(", "out_maps", ".", "keys", "(", ")", ")", "==", "self", ".", "M", "*", "self", ".", "N", ")", "\n", "assert", "(", "out_maps", "[", "(", "0", ",", "0", ")", "]", ".", "shape", "[", "0", "]", "==", "batch_size", ")", "\n", "\n", "", "", "if", "self", ".", "test_idx", "+", "batch_size", "==", "self", ".", "test_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "test_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "test_idx", "=", "self", ".", "test_idx", "+", "batch_size", "\n", "\n", "", "if", "not", "highres", ":", "\n", "            ", "return", "out", ",", "out_masks", ",", "out_maps", ",", "depleted", "\n", "", "else", ":", "\n", "            ", "return", "out", ",", "out_highres", ",", "out_masks", ",", "out_maps", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen": [[414, 453], ["min", "numpy.array", "range", "range", "len", "out_maps.keys"], "methods", ["None"], ["", "", "def", "next_batch_test_unseen", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next unseen classes testing batch\n        out: BxNxMxCx32x32\n        out_maps: BxNxMxNxM\n        out_masks: ??? \n        depleted: is the epoch over?\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "test_unseen_count", "-", "self", ".", "test_unseen_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "if", "self", ".", "hasmasks", ":", "\n", "            ", "out_masks", "=", "self", ".", "masks", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "out_masks", "=", "None", "\n", "", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "            ", "out_maps", "=", "self", ".", "utility_maps", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "out_maps", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "self", ".", "N", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "M", ")", ":", "\n", "                    ", "out_maps", "[", "(", "i", ",", "j", ")", "]", "=", "self", ".", "trajectories", "[", "'test_unseen'", "]", "[", "self", ".", "test_unseen_idx", ":", "(", "self", ".", "test_unseen_idx", "+", "batch_size", ")", ",", ":", "]", "\n", "\n", "", "", "", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "test_unseen_idx", "+", "batch_size", "==", "self", ".", "test_unseen_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "if", "self", ".", "trajectories_type", "==", "'utility_maps'", ":", "\n", "                ", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "(", "len", "(", "out_maps", ".", "keys", "(", ")", ")", "==", "self", ".", "M", "*", "self", ".", "N", ")", "\n", "assert", "(", "out_maps", "[", "(", "0", ",", "0", ")", "]", ".", "shape", "[", "0", "]", "==", "batch_size", ")", "\n", "\n", "", "", "if", "self", ".", "test_unseen_idx", "+", "batch_size", "==", "self", ".", "test_unseen_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "test_unseen_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "test_unseen_idx", "=", "self", ".", "test_unseen_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_masks", ",", "out_maps", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.__init__": [[461, 481], ["DataLoader.DataLoaderSimple.__init__", "h5py.File", "h5py.File", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.__init__"], ["def", "__init__", "(", "self", ",", "opts", ")", ":", "\n", "        ", "\"\"\"\n        Loads the dataset, utility maps and saves settings needed:\n        (1) dataset statistics (2) shuffle (3) debug statistics (4) iteration tracker  \n        Opts required: seed, h5_path, shuffle, batch_size, utility_h5_path, rewards_h5_path, h5_path_unseen, debug\n        \"\"\"", "\n", "# ---- Load the dataset, save the settings ----", "\n", "super", "(", "DataLoaderExpertBoth", ",", "self", ")", ".", "__init__", "(", "opts", ")", "\n", "# ---- Load the utility maps and rewards ----", "\n", "utility_file", "=", "h5py", ".", "File", "(", "opts", ".", "utility_h5_path", ")", "\n", "rewards_file", "=", "h5py", ".", "File", "(", "opts", ".", "rewards_h5_path", ")", "\n", "self", ".", "rewards", "=", "{", "}", "\n", "self", ".", "utility_maps", "=", "{", "}", "\n", "# These are KxNxMxNxM arrays ", "\n", "self", ".", "utility_maps", "[", "'train'", "]", "=", "np", ".", "array", "(", "utility_file", "[", "'train/utility_maps'", "]", ")", "\n", "self", ".", "utility_maps", "[", "'val'", "]", "=", "np", ".", "array", "(", "utility_file", "[", "'val/utility_maps'", "]", ")", "\n", "# These are KxNxM arrays containing rewards corresponding to each views of ", "\n", "# all panoramas in the train and val splits", "\n", "self", ".", "rewards", "[", "'train'", "]", "=", "np", ".", "array", "(", "rewards_file", "[", "'train/nms'", "]", ")", "\n", "self", ".", "rewards", "[", "'val'", "]", "=", "np", ".", "array", "(", "rewards_file", "[", "'val/nms'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train": [[482, 509], ["min", "numpy.array"], "methods", ["None"], ["", "def", "next_batch_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next training batch (indexed by self.shuffled_idx and starting at self.train_idx)\n        out: BxNxMxCx32x32\n        out_maps: BxNxMxNxM\n        out_rewards: BxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "train_count", "-", "self", ".", "train_idx", ")", "\n", "out", "=", "np", ".", "array", "(", "self", ".", "data", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "out_maps", "=", "self", ".", "utility_maps", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", "]", "\n", "out_rewards", "=", "self", ".", "rewards", "[", "'train'", "]", "[", "self", ".", "shuffled_idx", "[", "self", ".", "train_idx", ":", "(", "self", ".", "train_idx", "+", "batch_size", ")", "]", ",", ":", ",", ":", "]", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "assert", "(", "out_rewards", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "\n", "", "if", "self", ".", "train_idx", "+", "batch_size", "==", "self", ".", "train_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "train_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "train_idx", "=", "self", ".", "train_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_maps", ",", "out_rewards", ",", "depleted", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val": [[510, 537], ["min"], "methods", ["None"], ["", "def", "next_batch_val", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the next validation batch\n        out: BxNxMxCx32x32\n        out_maps: BxNxMxNxM\n        out_rewards: BxNxM\n        \"\"\"", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "self", ".", "val_count", "-", "self", ".", "val_idx", ")", "\n", "\n", "out", "=", "self", ".", "data", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", ",", ":", ",", ":", ",", ":", ",", ":", ",", ":", "]", "\n", "out_maps", "=", "self", ".", "utility_maps", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", "]", "\n", "out_rewards", "=", "self", ".", "rewards", "[", "'val'", "]", "[", "self", ".", "val_idx", ":", "(", "self", ".", "val_idx", "+", "batch_size", ")", "]", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "assert", "(", "(", "batch_size", "==", "self", ".", "batch_size", ")", "or", "(", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ")", ")", "\n", "assert", "(", "out", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "C", ",", "self", ".", "H", ",", "self", ".", "W", ")", ")", "\n", "assert", "(", "out_maps", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "assert", "(", "out_rewards", ".", "shape", "==", "(", "batch_size", ",", "self", ".", "N", ",", "self", ".", "M", ")", ")", "\n", "\n", "", "if", "self", ".", "val_idx", "+", "batch_size", "==", "self", ".", "val_count", ":", "\n", "            ", "depleted", "=", "True", "\n", "self", ".", "val_idx", "=", "0", "\n", "", "else", ":", "\n", "            ", "depleted", "=", "False", "\n", "self", ".", "val_idx", "=", "self", ".", "val_idx", "+", "batch_size", "\n", "\n", "", "return", "out", ",", "out_maps", ",", "out_rewards", ",", "depleted", "\n", "", "", ""]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.__init__": [[889, 893], ["nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "shape", ")", ":", "\n", "# shape is a list", "\n", "        ", "super", "(", "View", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shape", "=", "shape", "\n", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.View.forward": [[893, 895], ["input.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", ".", "view", "(", "*", "self", ".", "shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.str2bool": [[16, 18], ["v.lower"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "return", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.set_random_seeds": [[19, 27], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all"], "function", ["None"], ["", "def", "set_random_seeds", "(", "seed", ")", ":", "\n", "    ", "\"\"\"\n    Sets the random seeds for numpy, python, pytorch cpu and gpu\n    \"\"\"", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.load_module": [[28, 131], ["torch.load", "torch.load", "agent.policy.load_state_dict", "agent.policy.load_state_dict", "agent.policy.sense_im.parameters", "agent.policy.sense_pro.parameters", "agent.policy.fuse.parameters", "agent.create_optimizer", "agent.policy.decode.parameters", "agent.create_optimizer", "agent.optimizer.load_state_dict", "load_state[].items", "agent.policy.sense_im.parameters", "agent.policy.sense_pro.parameters", "agent.policy.fuse.parameters", "agent.create_optimizer", "agent.optimizer.load_state_dict", "agent.policy.decode.parameters", "agent.create_optimizer"], "function", ["None"], ["", "def", "load_module", "(", "agent", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Given the agent, load a pre-trained model and other setup based on the\n    training_setting\n    \"\"\"", "\n", "# ---- Load the pre-trained model ----", "\n", "load_state", "=", "torch", ".", "load", "(", "opts", ".", "load_model", ")", "\n", "# strict=False ensures that only the modules common to loaded_dict and agent.policy's state_dict are loaded. ", "\n", "# Could potentially lead to errors being masked. Tread carefully! ", "\n", "if", "opts", ".", "actorType", "==", "'actor'", "and", "opts", ".", "act_full_obs", ":", "\n", "# Don't load the actor module, since the full obs actor architecture is different. ", "\n", "        ", "partial_state_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "load_state", "[", "'state_dict'", "]", ".", "items", "(", ")", "if", "'act'", "not", "in", "k", "}", "\n", "agent", ".", "policy", ".", "load_state_dict", "(", "partial_state_dict", ",", "strict", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "agent", ".", "policy", ".", "load_state_dict", "(", "load_state", "[", "'state_dict'", "]", ",", "strict", "=", "False", ")", "\n", "\n", "# ---- Other settings ----", "\n", "", "epoch_start", "=", "0", "\n", "best_val_error", "=", "100000", "\n", "train_history", "=", "[", "]", "\n", "val_history", "=", "[", "]", "\n", "\n", "if", "opts", ".", "training_setting", "==", "1", ":", "\n", "        ", "\"\"\"\n        Scenario: Model trained on one-view reconstruction. Needs to be \n        finetuned for multi-view reconstruction.\n        \"\"\"", "\n", "# (1) Must fix sense, fuse modules", "\n", "for", "parameter", "in", "agent", ".", "policy", ".", "sense_im", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "", "for", "parameter", "in", "agent", ".", "policy", ".", "sense_pro", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "", "for", "parameter", "in", "agent", ".", "policy", ".", "fuse", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "# (2) Fix decode module if requested", "\n", "", "if", "opts", ".", "fix_decode", ":", "\n", "            ", "for", "parameter", "in", "agent", ".", "policy", ".", "decode", ".", "parameters", "(", ")", ":", "\n", "                ", "parameter", ".", "requires_grad", "=", "False", "\n", "# (3) Re-create the optimizer with the above settings", "\n", "", "", "agent", ".", "create_optimizer", "(", "opts", ".", "lr", ",", "opts", ".", "weight_decay", ",", "opts", ".", "training_setting", ",", "opts", ".", "fix_decode", ")", "\n", "\n", "", "elif", "opts", ".", "training_setting", "==", "2", ":", "\n", "        ", "\"\"\"\n        Scenario: Model trained on one-view reconstruction. Needs to be\n        further trained on the same setting.\n        \"\"\"", "\n", "# (1) Keep a copy of the new number of epochs to run for", "\n", "epoch_total", "=", "opts", ".", "epochs", "\n", "# (2) Load the rest of the opts from saved model", "\n", "opts", "=", "load_state", "[", "'opts'", "]", "\n", "opts", ".", "epochs", "=", "epoch_total", "\n", "train_history", "=", "load_state", "[", "'train_history'", "]", "\n", "val_history", "=", "load_state", "[", "'val_history'", "]", "\n", "best_val_error", "=", "load_state", "[", "'best_val_error'", "]", "\n", "epoch_start", "=", "load_state", "[", "'epoch'", "]", "+", "1", "\n", "# (3) Create optimizer based on the new parameter settings ", "\n", "agent", ".", "create_optimizer", "(", "opts", ".", "lr", ",", "opts", ".", "weight_decay", ",", "2", ",", "opts", ".", "fix_decode", ")", "\n", "# (4) Load the optimizer state dict", "\n", "agent", ".", "optimizer", ".", "load_state_dict", "(", "load_state", "[", "'optimizer'", "]", ")", "\n", "\n", "", "elif", "opts", ".", "training_setting", "==", "3", ":", "\n", "        ", "\"\"\"\n        Scenario: Model training on multi-view reconstruction. Needs to be \n        further trained on the same setting.\n        \"\"\"", "\n", "# (1) Load opts from saved model and replace LR", "\n", "opts_copy", "=", "load_state", "[", "'opts'", "]", "\n", "opts_copy", ".", "lr", "=", "opts", ".", "lr", "\n", "train_history", "=", "load_state", "[", "'train_history'", "]", "\n", "val_history", "=", "load_state", "[", "'val_history'", "]", "\n", "best_val_error", "=", "load_state", "[", "'best_val_error'", "]", "\n", "epoch_start", "=", "load_state", "[", "'epoch'", "]", "+", "1", "\n", "opts_copy", ".", "training_setting", "=", "opts", ".", "training_setting", "\n", "opts", "=", "opts_copy", "\n", "# (2) Fix sense, fuse and decode (optionally) modules  ", "\n", "for", "parameter", "in", "agent", ".", "policy", ".", "sense_im", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "", "for", "parameter", "in", "agent", ".", "policy", ".", "sense_pro", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "", "for", "parameter", "in", "agent", ".", "policy", ".", "fuse", ".", "parameters", "(", ")", ":", "\n", "            ", "parameter", ".", "requires_grad", "=", "False", "\n", "", "if", "opts", ".", "fix_decode", ":", "\n", "            ", "for", "parameter", "in", "agent", ".", "policy", ".", "decode", ".", "parameters", "(", ")", ":", "\n", "                ", "parameter", ".", "requires_grad", "=", "False", "\n", "# (3) Re-create the optimizer with the above settings", "\n", "", "", "agent", ".", "create_optimizer", "(", "opts", ".", "lr", ",", "opts", ".", "weight_decay", ",", "3", ",", "opts", ".", "fix_decode", ")", "\n", "# (4) Load the optimizer state dict", "\n", "agent", ".", "optimizer", ".", "load_state_dict", "(", "load_state", "[", "'optimizer'", "]", ")", "\n", "\n", "", "elif", "opts", ".", "training_setting", "==", "4", ":", "\n", "        ", "\"\"\"\n        Scenario: Model trained on one-view reconstruction. Needs to be\n        further trained on some other setting.\n        \"\"\"", "\n", "# (1) Load the train history, val history and best validation errors from the saved model.", "\n", "train_history", "=", "load_state", "[", "'train_history'", "]", "\n", "val_history", "=", "load_state", "[", "'val_history'", "]", "\n", "best_val_error", "=", "load_state", "[", "'best_val_error'", "]", "\n", "epoch_start", "=", "load_state", "[", "'epoch'", "]", "+", "1", "\n", "# (2) Create the optimizer according to the new settings", "\n", "agent", ".", "create_optimizer", "(", "opts", ".", "lr", ",", "opts", ".", "weight_decay", ",", "opts", ".", "training_setting", ",", "False", ")", "\n", "\n", "", "return", "best_val_error", ",", "train_history", ",", "val_history", ",", "epoch_start", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_starts": [[132, 143], ["random.randint", "random.randint", "range", "range"], "function", ["None"], ["", "def", "get_starts", "(", "N", ",", "M", ",", "batch_size", ",", "option", ")", ":", "\n", "    ", "\"\"\"\n    Given the number of elevations(N), azimuths(M), batch size and the option (different types of starts),\n    this function returns the start indices for the batch.\n    start_idx: list of [start_elev, start_azim] for each panorama in the batch\n    \"\"\"", "\n", "if", "option", "==", "0", ":", "\n", "        ", "start_idx", "=", "[", "[", "random", ".", "randint", "(", "0", ",", "N", "-", "1", ")", ",", "random", ".", "randint", "(", "0", ",", "M", "-", "1", ")", "]", "for", "i", "in", "range", "(", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "        ", "start_idx", "=", "[", "[", "N", "//", "2", ",", "M", "//", "2", "-", "1", "]", "for", "i", "in", "range", "(", "batch_size", ")", "]", "\n", "", "return", "start_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.utility_function": [[144, 159], ["numpy.zeros", "numpy.minimum", "np.minimum.sum"], "function", ["None"], ["", "def", "utility_function", "(", "utility_matrix", ",", "selected_views", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"\n    Evaluates the quality of the selected views based on the utility_matrix\n    utility_matrix : NxMxNxM array\n    selected_views : list of (i, j) pairs indicating selected views\n    \"\"\"", "\n", "M", "=", "utility_matrix", ".", "shape", "[", "1", "]", "\n", "N", "=", "utility_matrix", ".", "shape", "[", "0", "]", "\n", "total_utility_map", "=", "np", ".", "zeros", "(", "(", "N", ",", "M", ")", ")", "\n", "\n", "for", "view", "in", "selected_views", ":", "\n", "        ", "total_utility_map", "+=", "utility_matrix", "[", "view", "[", "0", "]", ",", "view", "[", "1", "]", "]", "\n", "\n", "", "total_utility_map", "=", "np", ".", "minimum", "(", "total_utility_map", ",", "threshold", ")", "\n", "return", "total_utility_map", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.utility_function_unique": [[160, 182], ["numpy.zeros", "set", "numpy.minimum", "np.minimum.sum", "set.add"], "function", ["None"], ["", "def", "utility_function_unique", "(", "utility_matrix", ",", "selected_views", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"\n    Evaluates the quality of the selected views based on the utility_matrix.\n    This selects only uniques views for computation, to ensure that the\n    same view does get selected multiple times.\n\n    utility_matrix : NxMxNxM array\n    selected_views : list of (i, j) pairs indicating selected views\n    \"\"\"", "\n", "M", "=", "utility_matrix", ".", "shape", "[", "1", "]", "\n", "N", "=", "utility_matrix", ".", "shape", "[", "0", "]", "\n", "total_utility_map", "=", "np", ".", "zeros", "(", "(", "N", ",", "M", ")", ")", "\n", "\n", "selected_views_set", "=", "set", "(", ")", "\n", "for", "view", "in", "selected_views", ":", "\n", "        ", "selected_views_set", ".", "add", "(", "(", "view", "[", "0", "]", ",", "view", "[", "1", "]", ")", ")", "\n", "\n", "", "for", "view", "in", "selected_views_set", ":", "\n", "        ", "total_utility_map", "+=", "utility_matrix", "[", "view", "[", "0", "]", ",", "view", "[", "1", "]", "]", "\n", "\n", "", "total_utility_map", "=", "np", ".", "minimum", "(", "total_utility_map", ",", "threshold", ")", "\n", "return", "total_utility_map", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_submodular_views": [[183, 207], ["range", "range", "sel_views.append", "range", "utils.utility_function"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.utility_function"], ["", "def", "get_submodular_views", "(", "utility_matrix", ",", "num_views", ")", ":", "\n", "    ", "\"\"\"\n    Uses greedy maximization of submodular utility function to get close to optimal set of views\n    utility_matrix : NxMxNxM array\n    num_views      : number of views to select\n    \"\"\"", "\n", "M", "=", "utility_matrix", ".", "shape", "[", "1", "]", "\n", "N", "=", "utility_matrix", ".", "shape", "[", "0", "]", "\n", "sel_views", "=", "[", "]", "\n", "\n", "total_utility", "=", "0", "\n", "for", "n", "in", "range", "(", "num_views", ")", ":", "\n", "        ", "max_idx", "=", "[", "0", ",", "0", "]", "\n", "max_utility_gain", "=", "0", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "M", ")", ":", "\n", "                ", "curr_utility_gain", "=", "utility_function", "(", "utility_matrix", ",", "sel_views", "+", "[", "[", "i", ",", "j", "]", "]", ",", "1", ")", "-", "total_utility", "\n", "if", "curr_utility_gain", ">=", "max_utility_gain", ":", "\n", "                    ", "max_utility_gain", "=", "curr_utility_gain", "\n", "max_idx", "=", "[", "i", ",", "j", "]", "\n", "", "", "", "sel_views", ".", "append", "(", "max_idx", ")", "\n", "total_utility", "+=", "max_utility_gain", "\n", "\n", "", "return", "sel_views", ",", "total_utility", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_expert_trajectories": [[208, 254], ["numpy.copy", "numpy.zeros", "range", "len", "utils.utility_function_unique", "range", "selected_views[].append", "range", "max", "max", "utils.utility_function_unique", "min", "min"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.utility_function_unique", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.utility_function_unique"], ["", "def", "get_expert_trajectories", "(", "state", ",", "pano_maps_orig", ",", "selected_views", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Get greedy trajectories based on utility for each panorama in batch\n    opts must contain:\n    T, delta_M, delta_N, wrap_elevation, wrap_azimuth, N, M\n    \"\"\"", "\n", "pano_maps", "=", "np", ".", "copy", "(", "pano_maps_orig", ")", "\n", "batch_size", "=", "pano_maps", ".", "shape", "[", "0", "]", "\n", "# Note: Assuming atleast one view has been selected initially", "\n", "t_start", "=", "len", "(", "selected_views", "[", "0", "]", ")", "-", "1", "# What t to start from, if some views have already been selected", "\n", "# Access pattern: selected_views[batch_size][time_step]", "\n", "selected_actions", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "opts", ".", "T", "-", "t_start", "-", "1", ")", ",", "np", ".", "int32", ")", "# Access pattern: selected_actions[batch_size][time_step]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "curr_utility", "=", "utility_function_unique", "(", "pano_maps", "[", "i", "]", ",", "selected_views", "[", "i", "]", ",", "1", ")", "\n", "# Given the first view, select T-1 more views", "\n", "t", "=", "t_start", "\n", "while", "t", "<", "opts", ".", "T", "-", "1", ":", "\n", "            ", "curr_pos", "=", "selected_views", "[", "i", "]", "[", "t", "]", "\n", "max_gain", "=", "0", "\n", "max_delta", "=", "None", "\n", "max_pos", "=", "None", "\n", "for", "delta_ele", "in", "range", "(", "-", "(", "opts", ".", "delta_N", "//", "2", ")", ",", "opts", ".", "delta_N", "//", "2", "+", "1", ")", ":", "\n", "                ", "for", "delta_azi", "in", "range", "(", "-", "(", "opts", ".", "delta_M", "//", "2", ")", ",", "opts", ".", "delta_M", "//", "2", "+", "1", ")", ":", "\n", "                    ", "if", "opts", ".", "wrap_elevation", ":", "\n", "                        ", "new_ele", "=", "(", "curr_pos", "[", "0", "]", "+", "delta_ele", ")", "%", "opts", ".", "N", "\n", "", "else", ":", "\n", "                        ", "new_ele", "=", "max", "(", "min", "(", "curr_pos", "[", "0", "]", "+", "delta_ele", ",", "opts", ".", "N", "-", "1", ")", ",", "0", ")", "\n", "\n", "", "if", "opts", ".", "wrap_azimuth", ":", "\n", "                        ", "new_azi", "=", "(", "curr_pos", "[", "1", "]", "+", "delta_azi", ")", "%", "opts", ".", "M", "\n", "", "else", ":", "\n", "                        ", "new_azi", "=", "max", "(", "min", "(", "curr_pos", "[", "1", "]", "+", "delta_azi", ",", "opts", ".", "M", "-", "1", ")", ",", "0", ")", "\n", "\n", "", "new_pos", "=", "[", "new_ele", ",", "new_azi", "]", "\n", "curr_gain", "=", "utility_function_unique", "(", "pano_maps", "[", "i", "]", ",", "selected_views", "[", "i", "]", "+", "[", "new_pos", "]", ",", "1", ")", "-", "curr_utility", "\n", "if", "curr_gain", ">=", "max_gain", ":", "\n", "                        ", "max_gain", "=", "curr_gain", "\n", "max_delta", "=", "(", "delta_ele", ",", "delta_azi", ")", "\n", "max_pos", "=", "new_pos", "\n", "\n", "", "", "", "curr_utility", "+=", "max_gain", "\n", "selected_views", "[", "i", "]", ".", "append", "(", "max_pos", ")", "\n", "selected_actions", "[", "i", "]", "[", "t", "-", "t_start", "]", "=", "state", ".", "delta_to_act", "[", "max_delta", "]", "\n", "t", "+=", "1", "\n", "\n", "", "", "return", "selected_views", ",", "selected_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.evaluate": [[255, 431], ["agent.policy.eval", "numpy.array", "float", "float", "float", "agent.policy.train", "range", "numpy.mean", "numpy.std", "np.array.append", "math.sqrt", "loader.next_batch_val", "random.randint", "random.randint", "range", "range", "rec_errs[].data.sum", "rec_errs[].data.cpu().numpy", "float", "loader.next_batch_val", "loader.next_batch_test", "loader.next_batch_test", "State.State", "State.State", "agent.gather_trajectory", "agent.gather_trajectory", "range", "numpy.concatenate", "decoded_images.append", "loader.next_batch_val", "loader.next_batch_val", "loader.next_batch_test_unseen", "loader.next_batch_test_unseen", "range", "len", "decoded_all[].data.cpu", "decoded_all[].data.cpu.numpy", "enumerate", "range", "np.roll.transpose().reshape", "numpy.array", "true_state.transpose().reshape.transpose().reshape", "numpy.zeros_like", "range", "numpy.concatenate", "torch.Tensor", "torch.Tensor", "rec_errs[].data.cpu", "numpy.roll", "numpy.roll", "range", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.concatenate", "range", "np.roll.transpose", "true_state.transpose().reshape.transpose", "range"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["", "def", "evaluate", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Evaluation function - evaluates the agent over fixed grid locations as\n    starting points and returns the overall average reconstruction error.\n    \"\"\"", "\n", "# ---- Initial setup ----", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "overall_err", "=", "0", "\n", "overall_count", "=", "0", "\n", "err_values", "=", "[", "]", "\n", "decoded_images", "=", "[", "]", "\n", "while", "not", "depleted", ":", "\n", "# ---- Sample batch of data ----", "\n", "        ", "if", "split", "==", "'val'", ":", "\n", "            ", "if", "opts", ".", "expert_rewards", "and", "opts", ".", "expert_trajectories", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "", "elif", "opts", ".", "expert_trajectories", "or", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "", "elif", "opts", ".", "expert_rewards", ":", "\n", "                ", "pano", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_maps", "=", "None", "\n", "", "else", ":", "\n", "                ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "", "elif", "split", "==", "'test'", ":", "\n", "            ", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "", "else", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "", "pano_rewards", "=", "None", "\n", "", "elif", "split", "==", "'test_unseen'", ":", "\n", "            ", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "", "else", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "", "pano_rewards", "=", "None", "\n", "\n", "# Initial setup for evaluating over a grid of views", "\n", "", "curr_err", "=", "0", "\n", "curr_count", "=", "0", "\n", "curr_err_batch", "=", "0", "\n", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Compute the performance with the initial state", "\n", "# starting at fixed grid locations", "\n", "if", "opts", ".", "start_view", "==", "0", ":", "\n", "# Randomly sample one location from grid", "\n", "            ", "elevations", "=", "[", "random", ".", "randint", "(", "0", ",", "opts", ".", "N", "-", "1", ")", "]", "\n", "azimuths", "=", "[", "random", ".", "randint", "(", "0", ",", "opts", ".", "M", "-", "1", ")", "]", "\n", "", "elif", "opts", ".", "start_view", "==", "1", ":", "\n", "# Sample only the center location from grid", "\n", "            ", "elevations", "=", "[", "opts", ".", "N", "//", "2", "]", "\n", "azimuths", "=", "[", "opts", ".", "M", "//", "2", "-", "1", "]", "\n", "", "else", ":", "\n", "# Sample all the locations from grid", "\n", "            ", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ",", "2", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ",", "2", ")", "\n", "\n", "", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "if", "split", "==", "'test'", "or", "split", "==", "'test_unseen'", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ",", "pano_masks", ")", "\n", "", "else", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ")", "\n", "# Enable view memorization for testing by default", "\n", "", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "# Not enabling demo_sidekick training for AgentSupervised (that's not needed, doesn't make sense)", "\n", "                    ", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ",", "pano_maps", "=", "pano_maps", ",", "opts", "=", "opts", ")", "\n", "", "else", ":", "\n", "                    ", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ")", "\n", "# For some random initial state, print the decoded images at all time steps", "\n", "", "if", "curr_count", "==", "0", ":", "\n", "                    ", "curr_decoded_plus_true", "=", "None", "\n", "for", "dec_idx", "in", "range", "(", "len", "(", "decoded_all", ")", ")", ":", "\n", "                        ", "decoded", "=", "decoded_all", "[", "dec_idx", "]", ".", "data", ".", "cpu", "(", ")", "\n", "curr_decoded", "=", "decoded", ".", "numpy", "(", ")", "\n", "# Rotate it forward by the start index", "\n", "# Shifting all the images by equal amount since the start idx is same for all", "\n", "if", "not", "opts", ".", "knownAzim", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "1", "]", ",", "axis", "=", "2", ")", "\n", "", "if", "not", "opts", ".", "knownElev", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "0", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Fill in the true views here", "\n", "", "for", "jdx", ",", "jdx_v", "in", "enumerate", "(", "visited_idxes", ")", ":", "\n", "                            ", "if", "jdx", ">", "dec_idx", ":", "\n", "                                ", "break", "\n", "", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                                ", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "=", "state", ".", "views_prepro", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "", "", "curr_decoded", "=", "curr_decoded", "*", "255", "\n", "for", "c", "in", "range", "(", "opts", ".", "num_channels", ")", ":", "\n", "#curr_decoded[:, :, :, , c, :, :] *= opts.std[c]", "\n", "                            ", "curr_decoded", "[", ":", ",", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "+=", "opts", ".", "mean", "[", "c", "]", "\n", "\n", "", "if", "opts", ".", "num_channels", "==", "1", ":", "\n", "                            ", "curr_decoded_3chn", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "3", ",", "32", ",", "32", ")", ")", "\n", "for", "c", "in", "range", "(", "3", ")", ":", "\n", "                                ", "curr_decoded_3chn", "[", ":", ",", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "=", "curr_decoded", "[", ":", ",", ":", ",", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "", "curr_decoded", "=", "curr_decoded_3chn", "\n", "#for jdx, jdx_v in enumerate(visited_idxes):", "\n", "#    if jdx > dec_idx:", "\n", "#        break", "\n", "", "jdx_v", "=", "visited_idxes", "[", "dec_idx", "]", "\n", "#for idx in range(batch_size):", "\n", "# Fill in some red margin", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], :, 0:3, :] = 0", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], :, -3:, :] = 0", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], :, :, 0:3] = 0", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], :, :, -3:] = 0", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], 0, 0:3, :] = 255", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], 0, -3:, :] = 255", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], 0, :, 0:3] = 255", "\n", "#curr_decoded[idx, jdx_v[idx][0], jdx_v[idx][1], 0, :, -3:] = 255", "\n", "\n", "# Need to convert from B x N x M x C x 32 x 32 to B x 1 x C x N*32 x M*32", "\n", "# Convert from B x N x M x C x 32 x 32 to B x C x N x 32 x M x 32 and then reshape", "\n", "curr_decoded", "=", "curr_decoded", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "3", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "\n", "true_state", "=", "np", ".", "array", "(", "state", ".", "views", ")", "\n", "start_idx", "=", "state", ".", "start_idx", "\n", "if", "opts", ".", "num_channels", "==", "1", ":", "\n", "                            ", "true_state_3chn", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ",", "3", ",", "32", ",", "32", ")", ")", "\n", "for", "c", "in", "range", "(", "3", ")", ":", "\n", "                                ", "true_state_3chn", "[", ":", ",", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "=", "true_state", "[", ":", ",", ":", ",", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "", "true_state", "=", "true_state_3chn", "\n", "\n", "# Fill in red margin for starting states of each true panorama", "\n", "#for idx in range(batch_size):", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], :, 0:3, :] = 0", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], :, -3:, :] = 0", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], :, :, 0:3] = 0", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], :, :, -3:] = 0", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], 0, 0:3, :] = 255", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], 0, -3:, :] = 255", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], 0, :, 0:3] = 255", "\n", "#    true_state[idx, start_idx[idx][0], start_idx[idx][1], 0, :, -3:] = 255", "\n", "\n", "", "true_state", "=", "true_state", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "3", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "\n", "\n", "if", "curr_decoded_plus_true", "is", "None", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "curr_decoded", "\n", "", "else", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "curr_decoded", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "true_state", ",", "curr_decoded_plus_true", "]", ",", "axis", "=", "1", ")", "\n", "if", "opts", ".", "expert_rewards", ":", "\n", "                        ", "reward_image", "=", "np", ".", "zeros_like", "(", "curr_decoded", ")", "\n", "for", "iter_N", "in", "range", "(", "opts", ".", "N", ")", ":", "\n", "                            ", "for", "iter_M", "in", "range", "(", "opts", ".", "M", ")", ":", "\n", "                                ", "for", "bn", "in", "range", "(", "batch_size", ")", ":", "\n", "                                    ", "reward_image", "[", "bn", ",", ":", ",", ":", ",", "(", "iter_N", "*", "32", ")", ":", "(", "(", "iter_N", "+", "1", ")", "*", "32", ")", ",", "(", "iter_M", "*", "32", ")", ":", "(", "(", "iter_M", "+", "1", ")", "*", "32", ")", "]", "=", "pano_rewards", "[", "bn", ",", "iter_N", ",", "iter_M", "]", "/", "255.0", "\n", "", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "reward_image", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "decoded_images", ".", "append", "(", "torch", ".", "Tensor", "(", "curr_decoded_plus_true", "/", "255.0", ")", ")", "\n", "\n", "# Add error from the last step", "\n", "", "curr_err", "+=", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "sum", "(", ")", "\n", "curr_count", "+=", "1", "# Count for the views", "\n", "curr_err_batch", "+=", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "curr_err", "/=", "curr_count", "\n", "curr_err_batch", "/=", "curr_count", "\n", "for", "i", "in", "range", "(", "curr_err_batch", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "err_values", ".", "append", "(", "float", "(", "curr_err_batch", "[", "i", "]", ")", ")", "\n", "", "overall_err", "+=", "curr_err", "\n", "overall_count", "+=", "batch_size", "\n", "\n", "", "err_values", "=", "np", ".", "array", "(", "err_values", ")", "\n", "overall_mean", "=", "float", "(", "np", ".", "mean", "(", "err_values", ")", ")", "\n", "overall_std", "=", "float", "(", "np", ".", "std", "(", "err_values", ",", "ddof", "=", "1", ")", ")", "\n", "overall_std_err", "=", "float", "(", "overall_std", "/", "math", ".", "sqrt", "(", "err_values", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "agent", ".", "policy", ".", "train", "(", ")", "\n", "\n", "return", "overall_mean", ",", "overall_std", ",", "overall_std_err", ",", "decoded_images", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.evaluate_adversarial_fixed": [[432, 527], ["agent.policy.eval", "range", "numpy.concatenate", "numpy.mean", "numpy.std", "agent.policy.train", "json.load", "len", "int", "int", "State.State", "agent.gather_trajectory", "range", "numpy.concatenate", "decoded_images.append", "np.concatenate.append", "numpy.sum", "math.sqrt", "open", "loader.next_batch_test", "len", "decoded_all[].data.cpu", "decoded_all[].data.cpu.numpy", "enumerate", "State.State.views.transpose().reshape", "range", "numpy.zeros_like", "range", "numpy.concatenate", "torch.Tensor", "torch.Tensor", "rec_errs[].data.cpu().numpy", "rec_errs[].data.cpu().numpy", "loader.next_batch_test_unseen", "numpy.roll", "numpy.roll", "range", "np.roll.transpose().reshape", "numpy.concatenate", "range", "State.State.views.transpose", "range", "rec_errs[].data.cpu", "rec_errs[].data.cpu", "np.roll.transpose"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["", "def", "evaluate_adversarial_fixed", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Evaluation function - evaluates the agent over the hardest starting points for\n    a one-view model\n    \"\"\"", "\n", "# ---- Initial setup ----", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "overall_err", "=", "0", "\n", "overall_count", "=", "0", "\n", "decoded_images", "=", "[", "]", "\n", "start_views", "=", "json", ".", "load", "(", "open", "(", "opts", ".", "start_views_json", ")", ")", "[", "'%s_adversarial_views'", "%", "split", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "start_views", ")", ")", ":", "\n", "        ", "start_views", "[", "i", "]", "[", "0", "]", "=", "int", "(", "start_views", "[", "i", "]", "[", "0", "]", ")", "\n", "start_views", "[", "i", "]", "[", "1", "]", "=", "int", "(", "start_views", "[", "i", "]", "[", "1", "]", ")", "\n", "\n", "", "err_values", "=", "[", "]", "\n", "while", "not", "depleted", ":", "\n", "# ---- Sample batch of data ----", "\n", "        ", "if", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "elif", "split", "==", "'test_unseen'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "\n", "# Initial setup for evaluating over a grid of views", "\n", "", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Get the adversarial start_idx", "\n", "start_idx", "=", "start_views", "[", "overall_count", ":", "(", "overall_count", "+", "batch_size", ")", "]", "\n", "\n", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ",", "pano_masks", ")", "\n", "# Enable view memorization for testing by default", "\n", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ")", "\n", "# For some random initial state, print the decoded images at all time steps", "\n", "curr_decoded_plus_true", "=", "None", "\n", "for", "dec_idx", "in", "range", "(", "len", "(", "decoded_all", ")", ")", ":", "\n", "            ", "decoded", "=", "decoded_all", "[", "dec_idx", "]", ".", "data", ".", "cpu", "(", ")", "\n", "curr_decoded", "=", "decoded", ".", "numpy", "(", ")", "\n", "# Rotate it forward by the start index", "\n", "# Shifting all the images by equal amount since the start idx is same for all", "\n", "if", "not", "opts", ".", "knownAzim", ":", "\n", "                ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "1", "]", ",", "axis", "=", "2", ")", "\n", "", "if", "not", "opts", ".", "knownElev", ":", "\n", "                ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "0", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Fill in the true views here", "\n", "", "for", "jdx", ",", "jdx_v", "in", "enumerate", "(", "visited_idxes", ")", ":", "\n", "                ", "if", "jdx", ">", "dec_idx", ":", "\n", "                    ", "break", "\n", "", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "=", "state", ".", "views_prepro", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "# Fill in some black margin", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "0", ":", "3", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "-", "3", ":", "-", "1", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "0", ":", "3", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "-", "3", ":", "-", "1", "]", "=", "0", "\n", "\n", "# Need to convert from B x N x M x C x 32 x 32 to B x 1 x C x N*32 x M*32", "\n", "# Convert from B x N x M x C x 32 x 32 to B x C x N x 32 x M x 32 and then reshape", "\n", "", "", "curr_decoded", "=", "curr_decoded", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "*", "255.0", "\n", "true_state", "=", "state", ".", "views", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "\n", "for", "c", "in", "range", "(", "opts", ".", "num_channels", ")", ":", "\n", "#curr_decoded[:, :, c, :, :] *= opts.std[c]", "\n", "                ", "curr_decoded", "[", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "+=", "opts", ".", "mean", "[", "c", "]", "\n", "\n", "", "if", "curr_decoded_plus_true", "is", "None", ":", "\n", "                ", "curr_decoded_plus_true", "=", "curr_decoded", "\n", "", "else", ":", "\n", "                ", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "curr_decoded", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "true_state", "]", ",", "axis", "=", "1", ")", "\n", "if", "opts", ".", "expert_rewards", ":", "\n", "            ", "reward_image", "=", "np", ".", "zeros_like", "(", "curr_decoded", ")", "\n", "for", "iter_N", "in", "range", "(", "opts", ".", "N", ")", ":", "\n", "                ", "for", "iter_M", "in", "range", "(", "opts", ".", "M", ")", ":", "\n", "                    ", "for", "bn", "in", "range", "(", "batch_size", ")", ":", "\n", "                        ", "reward_image", "[", "bn", ",", ":", ",", ":", ",", "(", "iter_N", "*", "32", ")", ":", "(", "(", "iter_N", "+", "1", ")", "*", "32", ")", ",", "(", "iter_M", "*", "32", ")", ":", "(", "(", "iter_M", "+", "1", ")", "*", "32", ")", "]", "=", "pano_rewards", "[", "bn", ",", "iter_N", ",", "iter_M", "]", "/", "255.0", "\n", "", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "reward_image", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "decoded_images", ".", "append", "(", "torch", ".", "Tensor", "(", "curr_decoded_plus_true", "/", "255.0", ")", ")", "\n", "\n", "err_values", ".", "append", "(", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "overall_err", "+=", "np", ".", "sum", "(", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "overall_count", "+=", "batch_size", "\n", "\n", "", "err_values", "=", "np", ".", "concatenate", "(", "err_values", ",", "axis", "=", "0", ")", "\n", "overall_mean", "=", "np", ".", "mean", "(", "err_values", ")", "\n", "overall_std", "=", "np", ".", "std", "(", "err_values", ",", "ddof", "=", "1", ")", "\n", "overall_std_err", "=", "overall_std", "/", "math", ".", "sqrt", "(", "err_values", ".", "shape", "[", "0", "]", ")", "\n", "agent", ".", "policy", ".", "train", "(", ")", "\n", "\n", "return", "overall_mean", ",", "overall_std", ",", "overall_std_err", ",", "decoded_images", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.evaluate_adversarial": [[528, 652], ["agent.policy.eval", "numpy.concatenate", "numpy.mean", "numpy.std", "agent.policy.train", "range", "range", "numpy.zeros", "errs_across_grid.reshape.reshape", "numpy.sum", "np.concatenate.append", "math.sqrt", "numpy.max", "numpy.max", "loader.next_batch_val", "rec_errs[].data.cpu().numpy", "loader.next_batch_val", "loader.next_batch_val", "loader.next_batch_test", "loader.next_batch_test", "State.State", "State.State", "agent.gather_trajectory", "agent.gather_trajectory", "range", "numpy.concatenate", "decoded_images.append", "loader.next_batch_test_unseen", "loader.next_batch_test_unseen", "range", "len", "decoded_all[].data.cpu", "decoded_all[].data.cpu.numpy", "enumerate", "State.State.views.transpose().reshape", "range", "numpy.zeros_like", "range", "numpy.concatenate", "torch.Tensor", "torch.Tensor", "rec_errs[].data.cpu", "numpy.roll", "numpy.roll", "range", "np.roll.transpose().reshape", "numpy.concatenate", "range", "State.State.views.transpose", "range", "np.roll.transpose"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["", "def", "evaluate_adversarial", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Evaluation function - evaluates the agent over all grid locations as\n    starting points and returns the average of worst reconstruction error over different\n    locations for the panoramas (average(max error over locations)).\n    \"\"\"", "\n", "# ---- Initial setup ----", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "overall_err", "=", "0", "\n", "overall_count", "=", "0", "\n", "decoded_images", "=", "[", "]", "\n", "err_values", "=", "[", "]", "\n", "while", "not", "depleted", ":", "\n", "# ---- Sample batch of data ----", "\n", "        ", "if", "split", "==", "'val'", ":", "\n", "            ", "if", "opts", ".", "expert_trajectories", "or", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "", "elif", "opts", ".", "expert_rewards", ":", "\n", "                ", "pano", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_maps", "=", "None", "\n", "", "else", ":", "\n", "                ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "", "elif", "split", "==", "'test'", ":", "\n", "            ", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "", "else", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "", "pano_rewards", "=", "None", "\n", "", "elif", "split", "==", "'test_unseen'", ":", "\n", "            ", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "", "else", ":", "\n", "                ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "", "pano_rewards", "=", "None", "\n", "\n", "# Initial setup for evaluating over a grid of views", "\n", "", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Compute the performance with the initial state", "\n", "# starting at fixed grid locations", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "\n", "errs_across_grid", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "\n", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "if", "split", "==", "'test'", "or", "split", "==", "'test_unseen'", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ",", "pano_masks", ")", "\n", "", "else", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ")", "\n", "# Enable view memorization for testing by default", "\n", "", "if", "opts", ".", "actorType", "==", "'demo_sidekick'", ":", "# Not enabling demo_sidekick training for AgentSupervised (that's not needed, doesn't make sense)", "\n", "                    ", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ",", "pano_maps", "=", "pano_maps", ",", "opts", "=", "opts", ")", "\n", "", "else", ":", "\n", "                    ", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ")", "\n", "# For some random initial state, print the decoded images at all time steps", "\n", "", "if", "i", "==", "0", "and", "j", "==", "0", ":", "\n", "                    ", "curr_decoded_plus_true", "=", "None", "\n", "for", "dec_idx", "in", "range", "(", "len", "(", "decoded_all", ")", ")", ":", "\n", "                        ", "decoded", "=", "decoded_all", "[", "dec_idx", "]", ".", "data", ".", "cpu", "(", ")", "\n", "curr_decoded", "=", "decoded", ".", "numpy", "(", ")", "\n", "# Rotate it forward by the start index", "\n", "# Shifting all the images by equal amount since the start idx is same for all", "\n", "if", "not", "opts", ".", "knownAzim", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "1", "]", ",", "axis", "=", "2", ")", "\n", "", "if", "not", "opts", ".", "knownElev", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "0", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Fill in the true views here", "\n", "", "for", "jdx", ",", "jdx_v", "in", "enumerate", "(", "visited_idxes", ")", ":", "\n", "                            ", "if", "jdx", ">", "dec_idx", ":", "\n", "                                ", "break", "\n", "", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                                ", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "=", "state", ".", "views_prepro", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "# Fill in some black margin", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "0", ":", "3", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "-", "3", ":", "-", "1", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "0", ":", "3", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "-", "3", ":", "-", "1", "]", "=", "0", "\n", "\n", "# Need to convert from B x N x M x C x 32 x 32 to B x 1 x C x N*32 x M*32", "\n", "# Convert from B x N x M x C x 32 x 32 to B x C x N x 32 x M x 32 and then reshape", "\n", "", "", "curr_decoded", "=", "curr_decoded", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "*", "255.0", "\n", "true_state", "=", "state", ".", "views", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "\n", "for", "c", "in", "range", "(", "opts", ".", "num_channels", ")", ":", "\n", "#curr_decoded[:, :, c, :, :] *= opts.std[c]", "\n", "                            ", "curr_decoded", "[", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "+=", "opts", ".", "mean", "[", "c", "]", "\n", "\n", "", "if", "curr_decoded_plus_true", "is", "None", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "curr_decoded", "\n", "", "else", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "curr_decoded", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "true_state", "]", ",", "axis", "=", "1", ")", "\n", "if", "opts", ".", "expert_rewards", ":", "\n", "                        ", "reward_image", "=", "np", ".", "zeros_like", "(", "curr_decoded", ")", "\n", "for", "iter_N", "in", "range", "(", "opts", ".", "N", ")", ":", "\n", "                            ", "for", "iter_M", "in", "range", "(", "opts", ".", "M", ")", ":", "\n", "                                ", "for", "bn", "in", "range", "(", "batch_size", ")", ":", "\n", "                                    ", "reward_image", "[", "bn", ",", ":", ",", ":", ",", "(", "iter_N", "*", "32", ")", ":", "(", "(", "iter_N", "+", "1", ")", "*", "32", ")", ",", "(", "iter_M", "*", "32", ")", ":", "(", "(", "iter_M", "+", "1", ")", "*", "32", ")", "]", "=", "pano_rewards", "[", "bn", ",", "iter_N", ",", "iter_M", "]", "/", "255.0", "\n", "", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "reward_image", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "decoded_images", ".", "append", "(", "torch", ".", "Tensor", "(", "curr_decoded_plus_true", "/", "255.0", ")", ")", "\n", "# endif", "\n", "", "errs_across_grid", "[", ":", ",", "i", ",", "j", "]", "=", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "errs_across_grid", "=", "errs_across_grid", ".", "reshape", "(", "batch_size", ",", "-", "1", ")", "\n", "overall_err", "+=", "np", ".", "sum", "(", "np", ".", "max", "(", "errs_across_grid", ",", "axis", "=", "1", ")", ")", "\n", "overall_count", "+=", "batch_size", "\n", "err_values", ".", "append", "(", "np", ".", "max", "(", "errs_across_grid", ",", "axis", "=", "1", ")", ")", "\n", "\n", "", "err_values", "=", "np", ".", "concatenate", "(", "err_values", ",", "axis", "=", "0", ")", "\n", "overall_mean", "=", "np", ".", "mean", "(", "err_values", ")", "\n", "overall_std", "=", "np", ".", "std", "(", "err_values", ",", "ddof", "=", "1", ")", "\n", "overall_std_err", "=", "overall_std", "/", "math", ".", "sqrt", "(", "err_values", ".", "shape", "[", "0", "]", ")", "\n", "\n", "agent", ".", "policy", ".", "train", "(", ")", "\n", "\n", "return", "overall_mean", ",", "overall_std", ",", "overall_std_err", ",", "decoded_images", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.get_all_trajectories": [[653, 708], ["agent.policy.eval", "range", "range", "agent.policy.train", "loader.next_batch_train", "loader.next_batch_val", "torch.cat", "torch.cat", "loader.next_batch_test", "agent.gather_trajectory", "trajectories[].append", "loader.next_batch_test_unseen", "State.State", "State.State", "range"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.None.main.train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_train", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["", "def", "get_all_trajectories", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Gathers trajectories from all starting positions and returns them.\n    \"\"\"", "\n", "# ---- Initial setup ----", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "trajectories", "=", "{", "}", "\n", "# Sample all the locations from grid", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "for", "i", "in", "elevations", ":", "\n", "        ", "for", "j", "in", "azimuths", ":", "\n", "            ", "trajectories", "[", "(", "i", ",", "j", ")", "]", "=", "[", "]", "\n", "\n", "", "", "while", "not", "depleted", ":", "\n", "# ---- Sample batch of data ----", "\n", "        ", "if", "split", "==", "'train'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_train", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "if", "split", "==", "'val'", ":", "\n", "            ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "elif", "split", "==", "'test_unseen'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "\n", "", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Gather agent trajectories from each starting location", "\n", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "if", "split", "==", "'test'", "or", "split", "==", "'test_unseen'", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ",", "pano_masks", ")", "\n", "", "else", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ")", "\n", "# Enable view memorization for testing by default", "\n", "", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "actions_taken", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ")", "\n", "# actions_taken: B x T torch Tensor", "\n", "trajectories", "[", "(", "i", ",", "j", ")", "]", ".", "append", "(", "actions_taken", ")", "\n", "\n", "", "", "", "for", "i", "in", "elevations", ":", "\n", "        ", "for", "j", "in", "azimuths", ":", "\n", "            ", "trajectories", "[", "(", "i", ",", "j", ")", "]", "=", "torch", ".", "cat", "(", "trajectories", "[", "(", "i", ",", "j", ")", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "agent", ".", "policy", ".", "train", "(", ")", "\n", "\n", "return", "trajectories", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.select_adversarial_views": [[709, 825], ["agent.policy.eval", "numpy.concatenate", "numpy.zeros", "range", "np.zeros.tolist", "range", "range", "numpy.zeros", "errs_across_grid.reshape.reshape", "np.concatenate.append", "math.floor", "numpy.argmax", "loader.next_batch_val", "loader.next_batch_test", "agent.gather_trajectory", "rec_errs[].data.cpu().numpy", "loader.next_batch_val", "loader.next_batch_val", "loader.next_batch_test_unseen", "State.State", "State.State", "range", "numpy.concatenate", "decoded_images.append", "range", "len", "decoded_all[].data.cpu", "decoded_all[].data.cpu.numpy", "enumerate", "State.State.views.transpose().reshape", "range", "numpy.zeros_like", "range", "numpy.concatenate", "torch.Tensor", "torch.Tensor", "rec_errs[].data.cpu", "numpy.roll", "numpy.roll", "range", "np.roll.transpose().reshape", "numpy.concatenate", "range", "State.State.views.transpose", "range", "np.roll.transpose"], "function", ["home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertBoth.next_batch_val", "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.DataLoader.DataLoaderExpertPolicy.next_batch_test_unseen"], ["", "def", "select_adversarial_views", "(", "loader", ",", "agent", ",", "split", ",", "opts", ")", ":", "\n", "    ", "\"\"\"\n    Adversarial selection function - evaluates the agent over all grid locations as\n    starting points and returns the indices of the worst reconstruction error over different\n    locations for the panoramas.\n    \"\"\"", "\n", "# ---- Initial setup ----", "\n", "depleted", "=", "False", "\n", "agent", ".", "policy", ".", "eval", "(", ")", "\n", "decoded_images", "=", "[", "]", "\n", "adversarial_views", "=", "[", "]", "\n", "while", "not", "depleted", ":", "\n", "# ---- Sample batch of data ----", "\n", "        ", "if", "split", "==", "'val'", ":", "\n", "            ", "if", "opts", ".", "expert_trajectories", ":", "\n", "                ", "pano", ",", "pano_maps", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "", "elif", "opts", ".", "expert_rewards", ":", "\n", "                ", "pano", ",", "pano_rewards", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_maps", "=", "None", "\n", "", "else", ":", "\n", "                ", "pano", ",", "depleted", "=", "loader", ".", "next_batch_val", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "", "elif", "split", "==", "'test'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "", "elif", "split", "==", "'test_unseen'", ":", "\n", "            ", "pano", ",", "pano_masks", ",", "depleted", "=", "loader", ".", "next_batch_test_unseen", "(", ")", "\n", "pano_rewards", "=", "None", "\n", "pano_maps", "=", "None", "\n", "\n", "# Initial setup for evaluating over a grid of views", "\n", "", "batch_size", "=", "pano", ".", "shape", "[", "0", "]", "\n", "# Compute the performance with the initial state", "\n", "# starting at fixed grid locations", "\n", "elevations", "=", "range", "(", "0", ",", "opts", ".", "N", ")", "\n", "azimuths", "=", "range", "(", "0", ",", "opts", ".", "M", ")", "\n", "\n", "errs_across_grid", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "opts", ".", "N", ",", "opts", ".", "M", ")", ")", "\n", "\n", "for", "i", "in", "elevations", ":", "\n", "            ", "for", "j", "in", "azimuths", ":", "\n", "                ", "start_idx", "=", "[", "[", "i", ",", "j", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "if", "split", "==", "'test'", "or", "split", "==", "'test_unseen'", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ",", "pano_masks", ")", "\n", "", "else", ":", "\n", "                    ", "state", "=", "State", "(", "pano", ",", "pano_rewards", ",", "start_idx", ",", "opts", ")", "\n", "# Enable view memorization for testing by default", "\n", "", "_", ",", "rec_errs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "visited_idxes", ",", "decoded_all", ",", "_", "=", "agent", ".", "gather_trajectory", "(", "state", ",", "eval_opts", "=", "{", "'greedy'", ":", "opts", ".", "greedy", ",", "'memorize_views'", ":", "True", "}", ")", "\n", "# For some random initial state, print the decoded images at all time steps", "\n", "if", "i", "==", "0", "and", "j", "==", "0", ":", "\n", "                    ", "curr_decoded_plus_true", "=", "None", "\n", "for", "dec_idx", "in", "range", "(", "len", "(", "decoded_all", ")", ")", ":", "\n", "                        ", "decoded", "=", "decoded_all", "[", "dec_idx", "]", ".", "data", ".", "cpu", "(", ")", "\n", "curr_decoded", "=", "decoded", ".", "numpy", "(", ")", "\n", "# Rotate it forward by the start index", "\n", "# Shifting all the images by equal amount since the start idx is same for all", "\n", "if", "not", "opts", ".", "knownAzim", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "1", "]", ",", "axis", "=", "2", ")", "\n", "", "if", "not", "opts", ".", "knownElev", ":", "\n", "                            ", "curr_decoded", "=", "np", ".", "roll", "(", "curr_decoded", ",", "start_idx", "[", "0", "]", "[", "0", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Fill in the true views here", "\n", "", "for", "jdx", ",", "jdx_v", "in", "enumerate", "(", "visited_idxes", ")", ":", "\n", "                            ", "if", "jdx", ">", "dec_idx", ":", "\n", "                                ", "break", "\n", "", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                                ", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "=", "state", ".", "views_prepro", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "# Fill in some black margin", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "0", ":", "3", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", "-", "3", ":", "-", "1", ",", ":", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "0", ":", "3", "]", "=", "0", "\n", "curr_decoded", "[", "idx", ",", "jdx_v", "[", "idx", "]", "[", "0", "]", ",", "jdx_v", "[", "idx", "]", "[", "1", "]", ",", ":", ",", ":", ",", "-", "3", ":", "-", "1", "]", "=", "0", "\n", "\n", "# Need to convert from B x N x M x C x 32 x 32 to B x 1 x C x N*32 x M*32", "\n", "# Convert from B x N x M x C x 32 x 32 to B x C x N x 32 x M x 32 and then reshape", "\n", "", "", "curr_decoded", "=", "curr_decoded", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "*", "255.0", "\n", "true_state", "=", "state", ".", "views", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "4", ",", "2", ",", "5", ")", ")", ".", "reshape", "(", "batch_size", ",", "1", ",", "opts", ".", "num_channels", ",", "opts", ".", "N", "*", "32", ",", "opts", ".", "M", "*", "32", ")", "\n", "for", "c", "in", "range", "(", "opts", ".", "num_channels", ")", ":", "\n", "#curr_decoded[:, :, c, :, :] *= opts.std[c]", "\n", "                            ", "curr_decoded", "[", ":", ",", ":", ",", "c", ",", ":", ",", ":", "]", "+=", "opts", ".", "mean", "[", "c", "]", "\n", "\n", "", "if", "curr_decoded_plus_true", "is", "None", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "curr_decoded", "\n", "", "else", ":", "\n", "                            ", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "curr_decoded", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "true_state", "]", ",", "axis", "=", "1", ")", "\n", "if", "opts", ".", "expert_rewards", ":", "\n", "                        ", "reward_image", "=", "np", ".", "zeros_like", "(", "curr_decoded", ")", "\n", "for", "iter_N", "in", "range", "(", "opts", ".", "N", ")", ":", "\n", "                            ", "for", "iter_M", "in", "range", "(", "opts", ".", "M", ")", ":", "\n", "                                ", "for", "bn", "in", "range", "(", "batch_size", ")", ":", "\n", "                                    ", "reward_image", "[", "bn", ",", ":", ",", ":", ",", "(", "iter_N", "*", "32", ")", ":", "(", "(", "iter_N", "+", "1", ")", "*", "32", ")", ",", "(", "iter_M", "*", "32", ")", ":", "(", "(", "iter_M", "+", "1", ")", "*", "32", ")", "]", "=", "pano_rewards", "[", "bn", ",", "iter_N", ",", "iter_M", "]", "/", "255.0", "\n", "", "", "", "curr_decoded_plus_true", "=", "np", ".", "concatenate", "(", "[", "curr_decoded_plus_true", ",", "reward_image", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "decoded_images", ".", "append", "(", "torch", ".", "Tensor", "(", "curr_decoded_plus_true", "/", "255.0", ")", ")", "\n", "# endif", "\n", "", "errs_across_grid", "[", ":", ",", "i", ",", "j", "]", "=", "rec_errs", "[", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "errs_across_grid", "=", "errs_across_grid", ".", "reshape", "(", "batch_size", ",", "-", "1", ")", "\n", "adversarial_views", ".", "append", "(", "np", ".", "argmax", "(", "errs_across_grid", ",", "axis", "=", "1", ")", ")", "\n", "\n", "# The indices are encoded in the row major format. Need to convert to (n, m) format.", "\n", "", "adversarial_views", "=", "np", ".", "concatenate", "(", "adversarial_views", ",", "axis", "=", "0", ")", "\n", "adversarial_views_n_m", "=", "np", ".", "zeros", "(", "(", "adversarial_views", ".", "shape", "[", "0", "]", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "adversarial_views", ".", "shape", "[", "0", "]", ")", ":", "\n", "# adversarial_views[i] = n*M + m", "\n", "        ", "m", "=", "adversarial_views", "[", "i", "]", "%", "opts", ".", "M", "\n", "n", "=", "math", ".", "floor", "(", "adversarial_views", "[", "i", "]", "/", "opts", ".", "M", ")", "\n", "assert", "(", "n", "*", "opts", ".", "M", "+", "m", "==", "adversarial_views", "[", "i", "]", ")", "\n", "adversarial_views_n_m", "[", "i", "]", "[", "0", "]", "=", "n", "\n", "adversarial_views_n_m", "[", "i", "]", "[", "1", "]", "=", "m", "\n", "", "return", "adversarial_views_n_m", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.iunf": [[826, 841], ["str", "range", "type", "nn.init.uniform", "nn.init.uniform", "nn.init.uniform", "nn.init.uniform", "hasattr", "hasattr", "getattr", "getattr", "getattr", "getattr", "nn.init.uniform", "nn.init.uniform", "str", "str", "type", "type"], "function", ["None"], ["", "def", "iunf", "(", "input_layer", ",", "initunf", "=", "0.1", ")", ":", "\n", "# If the layer is an LSTM", "\n", "    ", "if", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.rnn.LSTM'>\"", ":", "\n", "        ", "for", "i", "in", "range", "(", "input_layer", ".", "num_layers", ")", ":", "\n", "            ", "nn", ".", "init", ".", "uniform", "(", "getattr", "(", "input_layer", ",", "'weight_ih_l%d'", "%", "(", "i", ")", ")", ",", "-", "initunf", ",", "initunf", ")", "\n", "nn", ".", "init", ".", "uniform", "(", "getattr", "(", "input_layer", ",", "'weight_hh_l%d'", "%", "(", "i", ")", ")", ",", "-", "initunf", ",", "initunf", ")", "\n", "nn", ".", "init", ".", "uniform", "(", "getattr", "(", "input_layer", ",", "'bias_ih_l%d'", "%", "(", "i", ")", ")", ",", "-", "initunf", ",", "initunf", ")", "\n", "nn", ".", "init", ".", "uniform", "(", "getattr", "(", "input_layer", ",", "'bias_hh_l%d'", "%", "(", "i", ")", ")", ",", "-", "initunf", ",", "initunf", ")", "\n", "# For all other layers except batch norm", "\n", "", "", "elif", "not", "(", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm2d'>\"", "or", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm1d'>\"", ")", ":", "\n", "        ", "if", "hasattr", "(", "input_layer", ",", "'weight'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "uniform", "(", "input_layer", ".", "weight", ",", "-", "initunf", ",", "initunf", ")", ";", "\n", "", "if", "hasattr", "(", "input_layer", ",", "'bias'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "uniform", "(", "input_layer", ".", "bias", ",", "-", "initunf", ",", "initunf", ")", ";", "\n", "", "", "return", "input_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.ixvr": [[842, 857], ["str", "range", "type", "nn.init.xavier_normal", "nn.init.xavier_normal", "nn.init.constant", "nn.init.constant", "hasattr", "hasattr", "getattr", "getattr", "getattr", "getattr", "nn.init.xavier_normal", "nn.init.constant", "str", "str", "type", "type"], "function", ["None"], ["", "def", "ixvr", "(", "input_layer", ",", "bias_val", "=", "0.01", ")", ":", "\n", "# If the layer is an LSTM", "\n", "    ", "if", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.rnn.LSTM'>\"", ":", "\n", "        ", "for", "i", "in", "range", "(", "input_layer", ".", "num_layers", ")", ":", "\n", "            ", "nn", ".", "init", ".", "xavier_normal", "(", "getattr", "(", "input_layer", ",", "'weight_ih_l%d'", "%", "(", "i", ")", ")", ")", "\n", "nn", ".", "init", ".", "xavier_normal", "(", "getattr", "(", "input_layer", ",", "'weight_hh_l%d'", "%", "(", "i", ")", ")", ")", "\n", "nn", ".", "init", ".", "constant", "(", "getattr", "(", "input_layer", ",", "'bias_ih_l%d'", "%", "(", "i", ")", ")", ",", "bias_val", ")", "\n", "nn", ".", "init", ".", "constant", "(", "getattr", "(", "input_layer", ",", "'bias_hh_l%d'", "%", "(", "i", ")", ")", ",", "bias_val", ")", "\n", "# For all other layers except batch norm", "\n", "", "", "elif", "not", "(", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm2d'>\"", "or", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm1d'>\"", ")", ":", "\n", "        ", "if", "hasattr", "(", "input_layer", ",", "'weight'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "xavier_normal", "(", "input_layer", ".", "weight", ")", ";", "\n", "", "if", "hasattr", "(", "input_layer", ",", "'bias'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "constant", "(", "input_layer", ".", "bias", ",", "bias_val", ")", ";", "\n", "", "", "return", "input_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.inrml": [[858, 873], ["str", "range", "type", "nn.init.normal", "nn.init.normal", "nn.init.constant", "nn.init.constant", "hasattr", "hasattr", "getattr", "getattr", "getattr", "getattr", "nn.init.normal", "nn.init.constant", "str", "str", "type", "type"], "function", ["None"], ["", "def", "inrml", "(", "input_layer", ",", "mean", "=", "0", ",", "std", "=", "0.001", ")", ":", "\n", "# If the layer is an LSTM", "\n", "    ", "if", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.rnn.LSTM'>\"", ":", "\n", "        ", "for", "i", "in", "range", "(", "input_layer", ".", "num_layers", ")", ":", "\n", "            ", "nn", ".", "init", ".", "normal", "(", "getattr", "(", "input_layer", ",", "'weight_ih_l%d'", "%", "(", "i", ")", ")", ",", "mean", ",", "std", ")", "\n", "nn", ".", "init", ".", "normal", "(", "getattr", "(", "input_layer", ",", "'weight_hh_l%d'", "%", "(", "i", ")", ")", ",", "mean", ",", "std", ")", "\n", "nn", ".", "init", ".", "constant", "(", "getattr", "(", "input_layer", ",", "'bias_ih_l%d'", "%", "(", "i", ")", ")", ",", "0.01", ")", "\n", "nn", ".", "init", ".", "constant", "(", "getattr", "(", "input_layer", ",", "'bias_hh_l%d'", "%", "(", "i", ")", ")", ",", "0.01", ")", "\n", "# For all other layers except batch norm", "\n", "", "", "elif", "not", "(", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm2d'>\"", "or", "str", "(", "type", "(", "input_layer", ")", ")", "==", "\"<class 'torch.nn.modules.batchnorm.BatchNorm1d'>\"", ")", ":", "\n", "        ", "if", "hasattr", "(", "input_layer", ",", "'weight'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "normal", "(", "input_layer", ".", "weight", ",", "mean", ",", "std", ")", ";", "\n", "", "if", "hasattr", "(", "input_layer", ",", "'bias'", ")", ":", "\n", "            ", "nn", ".", "init", ".", "constant", "(", "input_layer", ".", "bias", ",", "0.01", ")", ";", "\n", "", "", "return", "input_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.srama2512_sidekicks.misc.utils.initialize_sequential": [[874, 887], ["range", "nn.Sequential", "len", "var_list.append", "init_method"], "function", ["None"], ["", "def", "initialize_sequential", "(", "var_sequential", ",", "init_method", ")", ":", "\n", "    ", "\"\"\"\n    Given a sequential module (var_sequential) and an initialization method \n    (init_method), this initializes var_sequential using init_method\n    \n    Note: The layers returned are different from the one inputted. \n    Not sure if this affects anything.\n    \"\"\"", "\n", "var_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "var_sequential", ")", ")", ":", "\n", "        ", "var_list", ".", "append", "(", "init_method", "(", "var_sequential", "[", "i", "]", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "var_list", ")", "\n", "\n"]]}