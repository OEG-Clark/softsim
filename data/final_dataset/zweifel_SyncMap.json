{"home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.__init__": [[10, 39], ["networkx.DiGraph", "DynamicGraphWalkTest.GraphWalkTest.G.number_of_nodes", "networkx.adj_matrix", "DynamicGraphWalkTest.GraphWalkTest.A.todense", "numpy.array", "range", "numpy.random.randint", "networkx.nx_agraph.read_dot", "DynamicGraphWalkTest.GraphWalkTest.A[].sum", "print", "print", "exit"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ",", "filename", "=", "\"graph.dot\"", ")", ":", "\n", "\t\t", "'''\n\t\tUnfinished\n\t\t'''", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "0", "\n", "\n", "self", ".", "G", "=", "nx", ".", "DiGraph", "(", "nx", ".", "nx_agraph", ".", "read_dot", "(", "filename", ")", ")", "\n", "\n", "self", ".", "output_size", "=", "self", ".", "G", ".", "number_of_nodes", "(", ")", "\n", "\n", "self", ".", "A", "=", "nx", ".", "adj_matrix", "(", "self", ".", "G", ")", "\n", "self", ".", "A", "=", "self", ".", "A", ".", "todense", "(", ")", "\n", "self", ".", "A", "=", "np", ".", "array", "(", "self", ".", "A", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "output_size", ")", ":", "\n", "\t\t\t", "accum", "=", "self", ".", "A", "[", "i", "]", ".", "sum", "(", ")", "\n", "if", "accum", "!=", "0", ":", "\n", "\t\t\t\t", "self", ".", "A", "[", "i", "]", "=", "self", ".", "A", "[", "i", "]", "/", "accum", "\n", "", "else", ":", "\n", "\t\t\t\t", "print", "(", "\"ERROR: Node \"", ",", "i", ",", "\" without connections from found\"", ")", "\n", "exit", "(", ")", "\n", "", "print", "(", "self", ".", "A", "[", "i", "]", ")", "\n", "\n", "\n", "#random start\t", "\n", "", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "output_size", ")", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "self", ".", "previous_previous_output_class", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.getOutputSize": [[44, 46], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.updateTimeDelay": [[47, 56], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "self", ".", "previous_previous_output_class", "=", "self", ".", "previous_output_class", "\n", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.getInput": [[58, 95], ["DynamicGraphWalkTest.GraphWalkTest.updateTimeDelay", "numpy.random.choice", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\n", "#print(self.G)", "\n", "#print(A.shape)", "\n", "#transition= self.A[self.output_class]", "\n", "#print(len(transition))", "\n", "#print(transition.shape)", "\n", "#print(transition)", "\n", "\n", "\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "output_size", ",", "1", ",", "p", "=", "self", ".", "A", "[", "self", ".", "output_class", "]", ")", "[", "0", "]", "\n", "#print(choice)", "\n", "#print(A[0])", "\n", "#print(A[1])", "\n", "#print(A[2])", "\n", "\n", "", "noise_intensity", "=", "0", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "\n", "#\t\tnoise_intensity=0", "\n", "\n", "#\t\tif  self.previous_output_class is None or np.array_equal(self.previous_output_class, self.output_class):", "\n", "#\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity", "\n", "#\t\telse:", "\n", "#\t\t\tif  self.previous_previous_output_class is None or np.array_equal(self.previous_previous_output_class, self.previous_output_class):", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay))", "\n", "#\t\t\telse:", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay)) + self.previous_previous_output_class*np.exp(-0.1*(self.time_counter+2.0*self.time_delay))", "\n", "#\t", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.getSequence": [[110, 128], ["numpy.empty", "numpy.empty", "range", "DynamicGraphWalkTest.GraphWalkTest.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "sequence_size", ")", ":", "\n", "\n", "#print(self.data.shape[0])", "\n", "#print(input_sequence.shape)", "\n", "#exit()", "\n", "\t\t", "self", ".", "input_sequence", "=", "np", ".", "empty", "(", "(", "sequence_size", ",", "self", ".", "output_size", ")", ")", "\n", "self", ".", "input_class", "=", "np", ".", "empty", "(", "sequence_size", ")", "\n", "\n", "for", "i", "in", "range", "(", "sequence_size", ")", ":", "\n", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "self", ".", "input_class", "[", "i", "]", "=", "self", ".", "output_class", "\n", "self", ".", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "", "return", "self", ".", "input_sequence", ",", "self", ".", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.plotGraph": [[129, 142], ["networkx.draw_networkx", "matplotlib.show", "matplotlib.savefig"], "methods", ["None"], ["", "def", "plotGraph", "(", "self", ",", "save", "=", "True", ")", ":", "\n", "\n", "\t\t", "options", "=", "{", "\n", "'node_size'", ":", "100", ",", "\n", "'arrowstyle'", ":", "'-|>'", ",", "\n", "'arrowsize'", ":", "12", ",", "\n", "}", "\n", "nx", ".", "draw_networkx", "(", "self", ".", "G", ",", "arrows", "=", "True", ",", "**", "options", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"graph_plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.plot": [[143, 159], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.DynamicGraphWalkTest.GraphWalkTest.plotSuperposed": [[160, 180], ["numpy.asarray", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.__init__": [[15, 24], ["numpy.random.rand"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "input_size", ",", "dimensions", ",", "adaptation_rate", ")", ":", "\n", "\n", "\t\t", "self", ".", "organized", "=", "False", "\n", "self", ".", "space_size", "=", "10", "\n", "self", ".", "dimensions", "=", "dimensions", "\n", "self", ".", "input_size", "=", "input_size", "\n", "#syncmap= np.zeros((input_size,dimensions))", "\n", "self", ".", "syncmap", "=", "np", ".", "random", ".", "rand", "(", "input_size", ",", "dimensions", ")", "\n", "self", ".", "adaptation_rate", "=", "adaptation_rate", "\n", "#self.syncmap= np.random.rand(dimensions, input_size)", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.inputGeneral": [[26, 76], ["range", "vplus.sum", "vminus.sum", "scipy.spatial.distance.cdist", "scipy.spatial.distance.cdist", "numpy.transpose", "numpy.transpose", "SyncMap.SyncMap.syncmap.max", "numpy.dot", "numpy.dot"], "methods", ["None"], ["", "def", "inputGeneral", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "plus", "=", "x", ">", "0.1", "\n", "minus", "=", "~", "plus", "\n", "\n", "sequence_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "#print(sequence_size, \"asfasdfasdfasd\")", "\n", "for", "i", "in", "range", "(", "sequence_size", ")", ":", "\n", "\n", "\t\t\t", "vplus", "=", "plus", "[", "i", ",", ":", "]", "\n", "vminus", "=", "minus", "[", "i", ",", ":", "]", "\n", "plus_mass", "=", "vplus", ".", "sum", "(", ")", "\n", "minus_mass", "=", "vminus", ".", "sum", "(", ")", "\n", "\n", "#print(plus_mass)", "\n", "#print(minus_mass)", "\n", "\n", "if", "plus_mass", "<=", "1", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "if", "minus_mass", "<=", "1", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "#print(\"vplus\")", "\n", "#print(vplus)", "\n", "\n", "", "center_plus", "=", "np", ".", "dot", "(", "vplus", ",", "self", ".", "syncmap", ")", "/", "plus_mass", "\n", "center_minus", "=", "np", ".", "dot", "(", "vminus", ",", "self", ".", "syncmap", ")", "/", "minus_mass", "\n", "\n", "#print(self.syncmap.shape)", "\n", "#exit()", "\n", "dist_plus", "=", "distance", ".", "cdist", "(", "center_plus", "[", "None", ",", ":", "]", ",", "self", ".", "syncmap", ",", "'euclidean'", ")", "\n", "dist_minus", "=", "distance", ".", "cdist", "(", "center_minus", "[", "None", ",", ":", "]", ",", "self", ".", "syncmap", ",", "'euclidean'", ")", "\n", "dist_plus", "=", "np", ".", "transpose", "(", "dist_plus", ")", "\n", "dist_minus", "=", "np", ".", "transpose", "(", "dist_minus", ")", "\n", "\n", "#update_plus= vplus[:,np.newaxis]*((center_plus - self.syncmap)/dist_plus + (self.syncmap - center_minus)/dist_minus)", "\n", "#update_minus= vminus[:,np.newaxis]*((center_minus -self.syncmap)/dist_minus + (self.syncmap - center_plus)/dist_plus)", "\n", "update_plus", "=", "vplus", "[", ":", ",", "np", ".", "newaxis", "]", "*", "(", "(", "center_plus", "-", "self", ".", "syncmap", ")", "/", "dist_plus", ")", "# + (self.syncmap - center_minus)/dist_minus)", "\n", "update_minus", "=", "vminus", "[", ":", ",", "np", ".", "newaxis", "]", "*", "(", "(", "center_minus", "-", "self", ".", "syncmap", ")", "/", "dist_minus", ")", "# + (self.syncmap - center_plus)/dist_plus)", "\n", "\n", "\n", "#self.syncmap+= self.adaptation_rate*update", "\n", "\n", "#self.syncmap= self.space_size*self.syncmap/maximum", "\n", "\n", "update", "=", "update_plus", "-", "update_minus", "\n", "self", ".", "syncmap", "+=", "self", ".", "adaptation_rate", "*", "update", "\n", "\n", "maximum", "=", "self", ".", "syncmap", ".", "max", "(", ")", "\n", "self", ".", "syncmap", "=", "self", ".", "space_size", "*", "self", ".", "syncmap", "/", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.input": [[78, 163], ["SyncMap.SyncMap.inputGeneral", "print", "range", "vplus.sum", "vminus.sum", "SyncMap.SyncMap.syncmap.max", "numpy.dot", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.inputGeneral"], ["", "", "def", "input", "(", "self", ",", "x", ")", ":", "\n", "\n", "\t\t", "self", ".", "inputGeneral", "(", "x", ")", "\n", "\n", "return", "\n", "\n", "print", "(", "x", ".", "shape", ")", "\n", "plus", "=", "x", ">", "0.1", "\n", "minus", "=", "~", "plus", "\n", "#\t\tprint(plus)", "\n", "#\t\tprint(minus)", "\n", "\n", "#\t\tprint(plus.shape)", "\n", "#\t\tprint(type(plus))", "\n", "\n", "#\t\tprint(x.shape)", "\n", "#\t\tprint(\"in\",x[1,:])", "\n", "#\t\tprint(\"map\",self.syncmap)", "\n", "\n", "\n", "sequence_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "sequence_size", ")", ":", "\n", "\t\t\t", "vplus", "=", "plus", "[", "i", ",", ":", "]", "\n", "vminus", "=", "minus", "[", "i", ",", ":", "]", "\n", "plus_mass", "=", "vplus", ".", "sum", "(", ")", "\n", "minus_mass", "=", "vminus", ".", "sum", "(", ")", "\n", "#print(self.syncmap)", "\n", "#print(\"plus\",vplus)", "\n", "if", "plus_mass", "<=", "1", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "if", "minus_mass", "<=", "1", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "#if plus_mass > 0:", "\n", "", "center_plus", "=", "np", ".", "dot", "(", "vplus", ",", "self", ".", "syncmap", ")", "/", "plus_mass", "\n", "#else:", "\n", "#\tcenter_plus= np.dot(vplus,self.syncmap)", "\n", "\n", "#print(center_plus)", "\n", "#exit()", "\n", "#if minus_mass > 0:", "\n", "center_minus", "=", "np", ".", "dot", "(", "vminus", ",", "self", ".", "syncmap", ")", "/", "minus_mass", "\n", "#else:", "\n", "#\tcenter_minus= np.dot(vminus,self.syncmap)", "\n", "\n", "\n", "#print(\"mass\", minus_mass)", "\n", "#print(center_plus)", "\n", "#print(\"minus\",vminus)", "\n", "#print(center_minus/minus_mass)", "\n", "#print(self.syncmap)", "\n", "#exit()", "\n", "\n", "#print(vplus)", "\n", "#print(self.syncmap.shape)", "\n", "#a= np.matmul(np.transpose(vplus),self.syncmap)", "\n", "#a= vplus.dot(self.syncmap)", "\n", "#a= (vplus*self.syncmap.transpose()).transpose()", "\n", "#update_plus= vplus[:,np.newaxis]*self.syncmap", "\n", "#\tupdate_plus= vplus[:,np.newaxis]*(center_plus -center_minus)*plus_mass", "\n", "update_plus", "=", "vplus", "[", ":", ",", "np", ".", "newaxis", "]", "*", "(", "center_plus", "-", "center_minus", ")", "\n", "#\tupdate_plus= vplus[:,np.newaxis]*(center_plus -center_minus)/plus_mass", "\n", "#update_plus= vplus[:,np.newaxis]*(center_plus -self.syncmap)", "\n", "#\tupdate_minus= vminus[:,np.newaxis]*(center_minus -center_plus)*minus_mass", "\n", "update_minus", "=", "vminus", "[", ":", ",", "np", ".", "newaxis", "]", "*", "(", "center_minus", "-", "center_plus", ")", "\n", "#\tupdate_minus= vminus[:,np.newaxis]*(center_minus -center_plus)/minus_mass", "\n", "#update_minus= vminus[:,np.newaxis]*(center_minus -self.syncmap)", "\n", "#print(self.syncmap)", "\n", "#print(center_plus)", "\n", "#print(center_plus - self.syncmap)", "\n", "#update_minus= vminus[:,np.newaxis]*self.syncmap", "\n", "\n", "#self.plot()", "\n", "\n", "#ax.scatter(center_plus[0], center_plus[1])", "\n", "#ax.scatter(center_minus[0], center_minus[1])", "\n", "\n", "#plt.show()", "\n", "\n", "update", "=", "update_plus", "+", "update_minus", "\n", "self", ".", "syncmap", "+=", "self", ".", "adaptation_rate", "*", "update", "\n", "\n", "maximum", "=", "self", ".", "syncmap", ".", "max", "(", ")", "\n", "self", ".", "syncmap", "=", "self", ".", "space_size", "*", "self", ".", "syncmap", "/", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.organize": [[165, 172], ["sklearn.cluster.DBSCAN().fit_predict", "sklearn.cluster.DBSCAN"], "methods", ["None"], ["", "", "def", "organize", "(", "self", ")", ":", "\n", "\n", "\t\t", "self", ".", "organized", "=", "True", "\n", "#self.labels= DBSCAN(eps=3, min_samples=2).fit_predict(self.syncmap)", "\n", "self", ".", "labels", "=", "DBSCAN", "(", "eps", "=", "3", ",", "min_samples", "=", "2", ")", ".", "fit_predict", "(", "self", ".", "syncmap", ")", "\n", "\n", "return", "self", ".", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.activate": [[173, 186], ["numpy.argmax", "print"], "methods", ["None"], ["", "def", "activate", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "'''\n\t\tReturn the label of the index with maximum input value\n\t\t'''", "\n", "\n", "if", "self", ".", "organized", "==", "False", ":", "\n", "\t\t\t", "print", "(", "\"Activating a non-organized SyncMap\"", ")", "\n", "return", "\n", "\n", "#maximum output", "\n", "", "max_index", "=", "np", ".", "argmax", "(", "x", ")", "\n", "\n", "return", "self", ".", "labels", "[", "max_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.plotSequence": [[187, 205], ["numpy.asarray", "matplotlib.plot", "matplotlib.plot", "matplotlib.savefig", "matplotlib.show", "matplotlib.close", "SyncMap.SyncMap.activate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.activate"], ["", "def", "plotSequence", "(", "self", ",", "input_sequence", ",", "input_class", ",", "filename", "=", "\"plot.png\"", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "input_sequence", "[", "1", ":", "500", "]", "\n", "input_class", "=", "input_class", "[", "1", ":", "500", "]", "\n", "\n", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "c", "=", "[", "self", ".", "activate", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ",", "'-g'", ")", "\n", "plt", ".", "plot", "(", "t", ",", "c", ",", "'-.k'", ")", "\n", "#plt.ylim([-0.01,1.2])", "\n", "\n", "\n", "plt", ".", "savefig", "(", "filename", ",", "quality", "=", "1", ",", "dpi", "=", "300", ")", "\n", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.plot": [[207, 233], ["print", "matplotlib.show", "matplotlib.close", "matplotlib.scatter", "matplotlib.figure", "matplotlib.axes", "matplotlib.axes.scatter3D", "matplotlib.savefig"], "methods", ["None"], ["", "def", "plot", "(", "self", ",", "color", "=", "None", ",", "save", "=", "False", ",", "filename", "=", "\"plot_map.png\"", ")", ":", "\n", "\n", "\t\t", "if", "color", "is", "None", ":", "\n", "\t\t\t", "color", "=", "self", ".", "labels", "\n", "\n", "", "print", "(", "self", ".", "syncmap", ")", "\n", "#print(self.syncmap)", "\n", "#print(self.syncmap[:,0])", "\n", "#print(self.syncmap[:,1])", "\n", "if", "self", ".", "dimensions", "==", "2", ":", "\n", "#print(type(color))", "\n", "#print(color.shape)", "\n", "\t\t\t", "ax", "=", "plt", ".", "scatter", "(", "self", ".", "syncmap", "[", ":", ",", "0", "]", ",", "self", ".", "syncmap", "[", ":", ",", "1", "]", ",", "c", "=", "color", ")", "\n", "\n", "", "if", "self", ".", "dimensions", "==", "3", ":", "\n", "\t\t\t", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "axes", "(", "projection", "=", "'3d'", ")", "\n", "\n", "ax", ".", "scatter3D", "(", "self", ".", "syncmap", "[", ":", ",", "0", "]", ",", "self", ".", "syncmap", "[", ":", ",", "1", "]", ",", "self", ".", "syncmap", "[", ":", ",", "2", "]", ",", "c", "=", "color", ")", ";", "\n", "#ax.plot3D(self.syncmap[:,0],self.syncmap[:,1], self.syncmap[:,2])", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "filename", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.save": [[234, 239], ["open", "open.write", "open.close", "cPickle.dumps"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "\t\t", "\"\"\"save class as self.name.txt\"\"\"", "\n", "file", "=", "open", "(", "filename", "+", "'.txt'", ",", "'w'", ")", "\n", "file", ".", "write", "(", "cPickle", ".", "dumps", "(", "self", ".", "__dict__", ")", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.SyncMap.SyncMap.load": [[240, 247], ["open", "open.read", "open.close", "cPickle.loads"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "filename", ")", ":", "\n", "\t\t", "\"\"\"try load self.name.txt\"\"\"", "\n", "file", "=", "open", "(", "filename", "+", "'.txt'", ",", "'r'", ")", "\n", "dataPickle", "=", "file", ".", "read", "(", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n", "self", ".", "__dict__", "=", "cPickle", ".", "loads", "(", "dataPickle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.__init__": [[10, 21], ["None"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ")", ":", "\n", "\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "output_size", "=", "10", "\n", "self", ".", "counter", "=", "-", "1", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "time_delay", "\n", "self", ".", "output_class", "=", "0", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "\n", "self", ".", "sequenceA_length", "=", "4", "\n", "self", ".", "sequenceB_length", "=", "4", "#np.random.randint(2)+5", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.trueLabel": [[22, 25], ["numpy.array"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "truelabel", "=", "np", ".", "array", "(", "(", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "2", ",", "2", ",", "2", ",", "2", ",", "1", ")", ")", "\n", "return", "truelabel", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.updateTimeDelay": [[26, 33], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.getInput": [[35, 78], ["LongChunkTest.LongChunkTest.updateTimeDelay", "numpy.random.randint", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "if", "reset", "==", "True", ":", "\n", "\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "-", "1", "\n", "\n", "", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\t\t\t", "if", "self", ".", "chunk", "==", "0", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceA_length", ":", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "1", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceB_length", ":", "\n", "\t\t\t\t\t", "self", ".", "sequenceB_length", "=", "np", ".", "random", ".", "randint", "(", "20", ")", "+", "5", "\n", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "chunk", "==", "0", ":", "\n", "#input_value = np.random.randint(10)", "\n", "#input_value= self.counter", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible output: 0,1,2,3", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "4", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible output: 5,6,7,8", "\n", "self", ".", "output_class", "=", "5", "+", "np", ".", "random", ".", "randint", "(", "4", ")", "\n", "\n", "\n", "", "", "noise_intensity", "=", "0", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "#input_value = np_utils.to_categorical(input_value, 10)  + np.random.rand(10)*0.2", "\n", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.getOutputSize": [[79, 81], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.getSequence": [[82, 95], ["numpy.empty", "numpy.empty", "range", "LongChunkTest.LongChunkTest.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "iterations", ")", ":", "\n", "\n", "\t\t", "input_class", "=", "np", ".", "empty", "(", "iterations", ")", "\n", "input_sequence", "=", "np", ".", "empty", "(", "(", "iterations", ",", "self", ".", "output_size", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "iterations", ")", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "input_class", "[", "i", "]", "=", "self", ".", "chunk", "\n", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "", "return", "input_sequence", ",", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.plot": [[96, 112], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.LongChunkTest.LongChunkTest.plotSuperposed": [[113, 135], ["numpy.asarray", "print", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "print", "(", "input_sequence", ".", "shape", ")", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.__init__": [[10, 50], ["networkx.DiGraph", "GraphWalkTest.GraphWalkTest.G.nodes", "numpy.asarray", "GraphWalkTest.GraphWalkTest.G.number_of_nodes", "networkx.adj_matrix", "GraphWalkTest.GraphWalkTest.A.todense", "numpy.array", "range", "numpy.random.randint", "networkx.nx_agraph.read_dot", "list", "int", "numpy.asarray", "GraphWalkTest.GraphWalkTest.A[].sum", "print", "print", "exit"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ",", "filename", "=", "\"graph.dot\"", ")", ":", "\n", "\t\t", "'''\n\t\t'''", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "0", "\n", "\n", "self", ".", "G", "=", "nx", ".", "DiGraph", "(", "nx", ".", "nx_agraph", ".", "read_dot", "(", "filename", ")", ")", "\n", "#print(nx.get_node_attributes(self.G,'1'))", "\n", "#print(self.G.nodes)", "\n", "label", "=", "self", ".", "G", ".", "nodes", "(", "data", "=", "\"label\"", ")", "\n", "label", "=", "np", ".", "asarray", "(", "list", "(", "label", ")", ")", "\n", "#print(label)", "\n", "#print(label[:,1])", "\n", "self", ".", "true_label", "=", "label", "[", ":", ",", "1", "]", "\n", "\n", "self", ".", "true_label", "=", "[", "int", "(", "x", ")", "for", "x", "in", "self", ".", "true_label", "]", "\n", "#print(self.true_label)", "\n", "self", ".", "true_label", "=", "np", ".", "asarray", "(", "self", ".", "true_label", ")", "-", "1", "\n", "#print(list(self.true_label))", "\n", "\n", "self", ".", "output_size", "=", "self", ".", "G", ".", "number_of_nodes", "(", ")", "\n", "\n", "self", ".", "A", "=", "nx", ".", "adj_matrix", "(", "self", ".", "G", ")", "\n", "self", ".", "A", "=", "self", ".", "A", ".", "todense", "(", ")", "\n", "self", ".", "A", "=", "np", ".", "array", "(", "self", ".", "A", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "output_size", ")", ":", "\n", "\t\t\t", "accum", "=", "self", ".", "A", "[", "i", "]", ".", "sum", "(", ")", "\n", "if", "accum", "!=", "0", ":", "\n", "\t\t\t\t", "self", ".", "A", "[", "i", "]", "=", "self", ".", "A", "[", "i", "]", "/", "accum", "\n", "", "else", ":", "\n", "\t\t\t\t", "print", "(", "\"ERROR: Node \"", ",", "i", ",", "\" without connections from found\"", ")", "\n", "exit", "(", ")", "\n", "", "print", "(", "self", ".", "A", "[", "i", "]", ")", "\n", "\n", "\n", "#random start\t", "\n", "", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "output_size", ")", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "self", ".", "previous_previous_output_class", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.trueLabel": [[55, 57], ["None"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "true_label", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.getOutputSize": [[58, 60], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.updateTimeDelay": [[61, 70], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "self", ".", "previous_previous_output_class", "=", "self", ".", "previous_output_class", "\n", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.getInput": [[72, 109], ["GraphWalkTest.GraphWalkTest.updateTimeDelay", "numpy.random.choice", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\n", "#print(self.G)", "\n", "#print(A.shape)", "\n", "#transition= self.A[self.output_class]", "\n", "#print(len(transition))", "\n", "#print(transition.shape)", "\n", "#print(transition)", "\n", "\n", "\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "output_size", ",", "1", ",", "p", "=", "self", ".", "A", "[", "self", ".", "output_class", "]", ")", "[", "0", "]", "\n", "#print(choice)", "\n", "#print(A[0])", "\n", "#print(A[1])", "\n", "#print(A[2])", "\n", "\n", "", "noise_intensity", "=", "0", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "\n", "#\t\tnoise_intensity=0", "\n", "\n", "#\t\tif  self.previous_output_class is None or np.array_equal(self.previous_output_class, self.output_class):", "\n", "#\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity", "\n", "#\t\telse:", "\n", "#\t\t\tif  self.previous_previous_output_class is None or np.array_equal(self.previous_previous_output_class, self.previous_output_class):", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay))", "\n", "#\t\t\telse:", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay)) + self.previous_previous_output_class*np.exp(-0.1*(self.time_counter+2.0*self.time_delay))", "\n", "#\t", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.getSequence": [[124, 142], ["numpy.empty", "numpy.empty", "range", "GraphWalkTest.GraphWalkTest.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "sequence_size", ")", ":", "\n", "\n", "#print(self.data.shape[0])", "\n", "#print(input_sequence.shape)", "\n", "#exit()", "\n", "\t\t", "self", ".", "input_sequence", "=", "np", ".", "empty", "(", "(", "sequence_size", ",", "self", ".", "output_size", ")", ")", "\n", "self", ".", "input_class", "=", "np", ".", "empty", "(", "sequence_size", ")", "\n", "\n", "for", "i", "in", "range", "(", "sequence_size", ")", ":", "\n", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "self", ".", "input_class", "[", "i", "]", "=", "self", ".", "output_class", "\n", "self", ".", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "", "return", "self", ".", "input_sequence", ",", "self", ".", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.plotGraph": [[143, 156], ["networkx.draw_networkx", "matplotlib.show", "matplotlib.savefig"], "methods", ["None"], ["", "def", "plotGraph", "(", "self", ",", "save", "=", "True", ")", ":", "\n", "\n", "\t\t", "options", "=", "{", "\n", "'node_size'", ":", "100", ",", "\n", "'arrowstyle'", ":", "'-|>'", ",", "\n", "'arrowsize'", ":", "12", ",", "\n", "}", "\n", "nx", ".", "draw_networkx", "(", "self", ".", "G", ",", "arrows", "=", "True", ",", "**", "options", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"graph_plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.plot": [[157, 173], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.GraphWalkTest.GraphWalkTest.plotSuperposed": [[174, 194], ["numpy.asarray", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.__init__": [[9, 20], ["None"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ")", ":", "\n", "\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "output_size", "=", "10", "\n", "self", ".", "counter", "=", "-", "1", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "time_delay", "\n", "self", ".", "output_class", "=", "0", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "\n", "self", ".", "sequenceA_length", "=", "4", "\n", "self", ".", "sequenceB_length", "=", "4", "#np.random.randint(2)+5", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.trueLabel": [[21, 26], ["None"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "'''\n\t\tTODO\n\t\t'''", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.getOutputSize": [[27, 29], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.updateTimeDelay": [[30, 37], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.getInput": [[39, 81], ["ChunkTest.ChunkTest.updateTimeDelay", "numpy.random.randint", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "if", "reset", "==", "True", ":", "\n", "\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "-", "1", "\n", "\n", "", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\t\t\t", "if", "self", ".", "chunk", "==", "0", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceA_length", ":", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "1", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceB_length", ":", "\n", "#self.sequenceB_length = np.random.randint(20)+5", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "chunk", "==", "0", ":", "\n", "#input_value = np.random.randint(10)", "\n", "#input_value= self.counter", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible output: 0,1,2,3", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "4", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible output: 5,6,7,8", "\n", "self", ".", "output_class", "=", "5", "+", "np", ".", "random", ".", "randint", "(", "4", ")", "\n", "\n", "", "", "noise_intensity", "=", "0", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "#input_value = np_utils.to_categorical(input_value, 10)  + np.random.rand(10)*0.2", "\n", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.getSequence": [[82, 97], ["numpy.empty", "numpy.empty", "range", "ChunkTest.ChunkTest.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "iterations", ")", ":", "\n", "\n", "\t\t", "input_class", "=", "np", ".", "empty", "(", "iterations", ")", "\n", "input_sequence", "=", "np", ".", "empty", "(", "(", "iterations", ",", "self", ".", "output_size", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "iterations", ")", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "input_class", "[", "i", "]", "=", "self", ".", "chunk", "\n", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "\n", "\n", "", "return", "input_sequence", ",", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.plot": [[98, 114], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.ChunkTest.ChunkTest.plotSuperposed": [[115, 137], ["numpy.asarray", "print", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "print", "(", "input_sequence", ".", "shape", ")", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.__init__": [[9, 71], ["numpy.loadtxt", "numpy.zeros", "enumerate", "enumerate", "FixedChunkTest.FixedChunkTest.chunk.append", "numpy.asarray", "numpy.random.randint", "len", "int", "numpy.asarray", "tmp.sum", "new_chunk.append", "FixedChunkTest.FixedChunkTest.chunk.append", "numpy.asarray"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ",", "filename", "=", "\"fixed_chunk2.txt\"", ")", ":", "\n", "\t\t", "'''\n\t\tChunks are written in the filename in which every line is a sequence of outputs followed by the number of the respective chunk\n\t\tAll chunk numbers must be in ascending order and must have the same number of outputs\n\t\tChunks will be shuffled and presented repeatedly throughout\n\t\t'''", "\n", "dataset", "=", "np", ".", "loadtxt", "(", "filename", ",", "dtype", "=", "\"i\"", ",", "delimiter", "=", "\",\"", ")", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "0", "\n", "self", ".", "current_index", "=", "0", "\n", "\n", "self", ".", "output_size", "=", "dataset", ".", "shape", "[", "1", "]", "-", "1", "\n", "self", ".", "data", "=", "dataset", "[", ":", ",", ":", "self", ".", "output_size", "]", "\n", "self", ".", "data_class", "=", "dataset", "[", ":", ",", "self", ".", "output_size", "]", "\n", "\n", "acc", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "data_class", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", ",", "sample", "in", "enumerate", "(", "self", ".", "data", ")", ":", "\n", "#print(sample)", "\n", "#print(self.data_class)", "\n", "\t\t\t", "tmp", "=", "sample", "*", "self", ".", "data_class", "\n", "acc", "[", "i", "]", "=", "int", "(", "tmp", ".", "sum", "(", ")", ")", "\n", "\n", "", "acc", "-=", "1", "\n", "self", ".", "true_labels", "=", "acc", "\n", "\n", "self", ".", "chunk", "=", "[", "]", "\n", "new_chunk", "=", "None", "\n", "new_chunk_index", "=", "None", "\n", "for", "i", ",", "sample", "in", "enumerate", "(", "self", ".", "data", ")", ":", "\n", "\t\t\t", "if", "new_chunk", "is", "None", ":", "\n", "\t\t\t\t", "new_chunk_index", "=", "self", ".", "data_class", "[", "i", "]", "\n", "new_chunk", "=", "[", "sample", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "if", "new_chunk_index", "==", "self", ".", "data_class", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "new_chunk", ".", "append", "(", "sample", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "chunk", ".", "append", "(", "np", ".", "asarray", "(", "new_chunk", ")", ")", "\n", "new_chunk", "=", "[", "sample", "]", "\n", "new_chunk_index", "=", "self", ".", "data_class", "[", "i", "]", "\n", "\n", "", "", "", "self", ".", "chunk", ".", "append", "(", "np", ".", "asarray", "(", "new_chunk", ")", ")", "\n", "\n", "self", ".", "chunk", "=", "np", ".", "asarray", "(", "self", ".", "chunk", ")", "\n", "self", ".", "number_of_chunks", "=", "self", ".", "chunk", ".", "shape", "[", "0", "]", "\n", "self", ".", "chunk_index", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "number_of_chunks", ")", "\n", "\n", "#print(self.chunk)", "\n", "#\t\tprint(self.chunk.shape)", "\n", "#\t\tfor i in range(10):", "\n", "#\t\t\trand= np.random.randint(self.number_of_chunks)", "\n", "#\t\t\tprint(self.chunk[rand])", "\n", "\n", "#\t\texit()", "\n", "\n", "\n", "\n", "#\t\tself.chunk= 0", "\n", "#\t\tself.output_size = output_size", "\n", "#\t\tself.counter = -1", "\n", "#\t\tself.output_class= data_class[current_index]", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "self", ".", "previous_previous_output_class", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.getOutputSize": [[78, 80], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.trueLabel": [[81, 83], ["None"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "true_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.updateTimeDelay": [[84, 93], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "self", ".", "previous_previous_output_class", "=", "self", ".", "previous_output_class", "\n", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.getInput": [[95, 132], ["FixedChunkTest.FixedChunkTest.updateTimeDelay", "numpy.array_equal", "numpy.random.randint", "numpy.exp", "numpy.random.randn", "numpy.exp", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "if", "reset", "==", "True", ":", "\n", "\t\t\t", "self", ".", "current_index", "=", "0", "\n", "self", ".", "time_counter", "=", "0", "\n", "\n", "", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "#print(self.chunk[self.chunk_index].shape)", "\n", "#exit()", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\n", "\t\t\t", "self", ".", "current_index", "+=", "1", "\n", "\n", "#check if a new chunk should start", "\n", "if", "self", ".", "current_index", ">=", "self", ".", "chunk", "[", "self", ".", "chunk_index", "]", ".", "shape", "[", "0", "]", ":", "\n", "\t\t\t\t", "self", ".", "chunk_index", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "number_of_chunks", ")", "\n", "self", ".", "current_index", "=", "0", "\n", "\n", "\n", "\n", "#chunk is the cluster it pertains", "\n", "#output class is the current output", "\n", "#self.chunk_index= ", "\n", "#print(\"chunk\",self.chunk)", "\n", "", "", "self", ".", "output_class", "=", "self", ".", "chunk", "[", "self", ".", "chunk_index", "]", "[", "self", ".", "current_index", "]", "\n", "\n", "noise_intensity", "=", "0", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "np", ".", "array_equal", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_class", ")", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "output_class", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "output_class", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "self", ".", "previous_output_class", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "\n", "\n", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.getSequence": [[133, 151], ["numpy.empty", "numpy.empty", "range", "FixedChunkTest.FixedChunkTest.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "sequence_size", ")", ":", "\n", "\n", "#print(self.data.shape[0])", "\n", "#print(input_sequence.shape)", "\n", "#exit()", "\n", "\t\t", "self", ".", "input_sequence", "=", "np", ".", "empty", "(", "(", "sequence_size", ",", "self", ".", "data", ".", "shape", "[", "1", "]", ")", ")", "\n", "self", ".", "input_class", "=", "np", ".", "empty", "(", "sequence_size", ")", "\n", "\n", "for", "i", "in", "range", "(", "sequence_size", ")", ":", "\n", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "self", ".", "input_class", "[", "i", "]", "=", "self", ".", "chunk_index", "\n", "self", ".", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "", "return", "self", ".", "input_sequence", ",", "self", ".", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.plot": [[153, 169], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.FixedChunkTest.FixedChunkTest.plotSuperposed": [[170, 190], ["numpy.asarray", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.__init__": [[9, 20], ["None"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ")", ":", "\n", "\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "output_size", "=", "10", "\n", "self", ".", "counter", "=", "-", "1", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "time_delay", "\n", "self", ".", "output_class", "=", "0", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "\n", "self", ".", "sequenceA_length", "=", "4", "\n", "self", ".", "sequenceB_length", "=", "4", "#np.random.randint(2)+5", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.getOutputSize": [[81, 83], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.trueLabel": [[24, 27], ["numpy.array"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "truelabel", "=", "np", ".", "array", "(", "(", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "return", "truelabel", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.updateTimeDelay": [[28, 35], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.getInput": [[37, 80], ["OverlapChunkTest2.OverlapChunkTest2.updateTimeDelay", "numpy.random.randint", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "if", "reset", "==", "True", ":", "\n", "\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "-", "1", "\n", "\n", "", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\t\t\t", "if", "self", ".", "chunk", "==", "0", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceA_length", ":", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "1", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceB_length", ":", "\n", "#self.sequenceB_length = np.random.randint(20)+5", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "chunk", "==", "0", ":", "\n", "#input_value = np.random.randint(10)", "\n", "#input_value= self.counter", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "\n", "#possible outputs are 0,1,2,3,4", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "5", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible outputs are 0,1,2,3,4,5,6,7,8,9", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "10", ")", "\n", "\n", "", "", "noise_intensity", "=", "0", "\n", "#\t\tinput_value = np_utils.to_categorical(self.output_class, self.output_size) + np.random.randn(self.output_size)*noise_intensity", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.getSequence": [[84, 99], ["numpy.empty", "numpy.empty", "range", "OverlapChunkTest2.OverlapChunkTest2.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "iterations", ")", ":", "\n", "\n", "\t\t", "input_class", "=", "np", ".", "empty", "(", "iterations", ")", "\n", "input_sequence", "=", "np", ".", "empty", "(", "(", "iterations", ",", "self", ".", "output_size", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "iterations", ")", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "input_class", "[", "i", "]", "=", "self", ".", "chunk", "\n", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "\n", "\n", "", "return", "input_sequence", ",", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.plot": [[100, 116], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest2.OverlapChunkTest2.plotSuperposed": [[117, 139], ["numpy.asarray", "print", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "print", "(", "input_sequence", ".", "shape", ")", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.__init__": [[9, 21], ["None"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "time_delay", ")", ":", "\n", "\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "output_size", "=", "8", "\n", "self", ".", "counter", "=", "-", "1", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "time_counter", "=", "time_delay", "\n", "self", ".", "output_class", "=", "0", "\n", "self", ".", "previous_output_class", "=", "None", "\n", "\n", "self", ".", "sequenceA_length", "=", "4", "\n", "self", ".", "sequenceB_length", "=", "4", "#np.random.randint(2)+5", "\n", "self", ".", "previous_previous_output_class", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getOutputSize": [[22, 24], ["None"], "methods", ["None"], ["", "def", "getOutputSize", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.trueLabel": [[25, 28], ["numpy.array"], "methods", ["None"], ["", "def", "trueLabel", "(", "self", ")", ":", "\n", "\t\t", "truelabel", "=", "np", ".", "array", "(", "(", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ")", ")", "\n", "return", "truelabel", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay": [[29, 36], ["None"], "methods", ["None"], ["", "def", "updateTimeDelay", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "time_counter", "+=", "1", "\n", "if", "self", ".", "time_counter", ">", "self", ".", "time_delay", ":", "\n", "\t\t\t", "self", ".", "time_counter", "=", "0", "\n", "return", "True", "\n", "", "else", ":", "\n", "\t\t\t", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput": [[38, 92], ["OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay", "numpy.random.randint", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn", "keras.utils.np_utils.to_categorical", "numpy.exp", "keras.utils.np_utils.to_categorical", "numpy.exp", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.updateTimeDelay"], ["", "", "def", "getInput", "(", "self", ",", "reset", "=", "False", ")", ":", "\n", "\n", "\t\t", "if", "reset", "==", "True", ":", "\n", "\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "-", "1", "\n", "\n", "", "update", "=", "self", ".", "updateTimeDelay", "(", ")", "\n", "\n", "if", "update", "==", "True", ":", "\n", "\t\t\t", "if", "self", ".", "chunk", "==", "0", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceA_length", ":", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "1", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "if", "self", ".", "counter", ">", "self", ".", "sequenceB_length", ":", "\n", "#self.sequenceB_length = np.random.randint(20)+5", "\n", "\t\t\t\t\t", "self", ".", "chunk", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "counter", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "chunk", "==", "0", ":", "\n", "#input_value = np.random.randint(10)", "\n", "#input_value= self.counter", "\n", "\t\t\t\t", "self", ".", "previous_previous_output_class", "=", "self", ".", "previous_output_class", "\n", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "\n", "#possible outputs are 0,1,2,3,4", "\n", "self", ".", "output_class", "=", "np", ".", "random", ".", "randint", "(", "5", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "previous_previous_output_class", "=", "self", ".", "previous_output_class", "\n", "self", ".", "previous_output_class", "=", "self", ".", "output_class", "\n", "#possible outputs are 3,4,5,6,7", "\n", "self", ".", "output_class", "=", "3", "+", "np", ".", "random", ".", "randint", "(", "5", ")", "\n", "\n", "", "", "noise_intensity", "=", "0.0", "\n", "#input_value = np_utils.to_categorical(self.output_class, self.output_size) + np.random.randn(self.output_size)*noise_intensity", "\n", "if", "self", ".", "previous_output_class", "is", "None", "or", "self", ".", "previous_output_class", "==", "self", ".", "output_class", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "\n", "", "else", ":", "\n", "\t\t\t", "input_value", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "self", ".", "time_counter", ")", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "output_size", ")", "*", "noise_intensity", "+", "np_utils", ".", "to_categorical", "(", "self", ".", "previous_output_class", ",", "self", ".", "output_size", ")", "*", "np", ".", "exp", "(", "-", "0.1", "*", "(", "self", ".", "time_counter", "+", "self", ".", "time_delay", ")", ")", "\n", "\n", "#\t\tif  self.previous_output_class is None or np.array_equal(self.previous_output_class, self.output_class):", "\n", "#\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity", "\n", "#\t\telse:", "\n", "#\t\t\tif  self.previous_previous_output_class is None or np.array_equal(self.previous_previous_output_class, self.previous_output_class):", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay))", "\n", "#\t\t\telse:", "\n", "#\t\t\t\tinput_value = self.output_class*np.exp(-0.1*self.time_counter) + np.random.randn(self.output_size)*noise_intensity + self.previous_output_class*np.exp(-0.1*(self.time_counter+self.time_delay)) + self.previous_previous_output_class*np.exp(-0.1*(self.time_counter+2.0*self.time_delay))", "\n", "\n", "\n", "", "return", "input_value", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getSequence": [[93, 108], ["numpy.empty", "numpy.empty", "range", "OverlapChunkTest1.OverlapChunkTest1.getInput"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.getInput"], ["", "def", "getSequence", "(", "self", ",", "iterations", ")", ":", "\n", "\n", "\t\t", "input_class", "=", "np", ".", "empty", "(", "iterations", ")", "\n", "input_sequence", "=", "np", ".", "empty", "(", "(", "iterations", ",", "self", ".", "output_size", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "iterations", ")", ":", "\n", "\t\t\t", "input_value", "=", "self", ".", "getInput", "(", ")", "\n", "#input_class.append(self.chunk)", "\n", "#input_sequence.append(input_value)", "\n", "input_class", "[", "i", "]", "=", "self", ".", "chunk", "\n", "input_sequence", "[", "i", "]", "=", "input_value", "\n", "\n", "\n", "\n", "", "return", "input_sequence", ",", "input_class", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.plot": [[109, 125], ["numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plot", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "input_sequence", "!=", "None", ":", "\n", "\t\t\t", "sequence", "=", "[", "np", ".", "argmax", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "plt", ".", "plot", "(", "t", ",", "sequence", ")", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.OverlapChunkTest1.OverlapChunkTest1.plotSuperposed": [[126, 148], ["numpy.asarray", "print", "range", "numpy.asarray", "matplotlib.plot", "matplotlib.show", "matplotlib.close", "matplotlib.plot", "matplotlib.savefig", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot"], ["", "def", "plotSuperposed", "(", "self", ",", "input_class", ",", "input_sequence", "=", "None", ",", "save", "=", "False", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "np", ".", "asarray", "(", "input_sequence", ")", "\n", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "input_sequence", ")", "]", "\n", "\n", "print", "(", "input_sequence", ".", "shape", ")", "\n", "\n", "#exit()", "\n", "\n", "for", "i", "in", "range", "(", "input_sequence", ".", "shape", "[", "1", "]", ")", ":", "\n", "\t\t\t", "a", "=", "input_sequence", "[", ":", ",", "i", "]", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "plt", ".", "plot", "(", "t", ",", "a", ")", "\n", "\n", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "\"plot.png\"", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.__init__": [[14, 30], ["numpy.zeros", "VAE.VAE.createModel", "VAE.VAE.createMap"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createModel", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createMap"], ["\t", "def", "__init__", "(", "self", ",", "input_size", ",", "latent_dim", ",", "timesteps", ")", ":", "\n", "\n", "\t\t", "self", ".", "organized", "=", "False", "\n", "self", ".", "latent_dim", "=", "latent_dim", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "timesteps", "=", "timesteps", "\n", "self", ".", "counter", "=", "0", "\n", "self", ".", "x_train", "=", "[", "]", "\n", "self", ".", "y_train", "=", "[", "]", "\n", "self", ".", "x_test", "=", "[", "]", "\n", "self", ".", "y_test", "=", "[", "]", "\n", "\n", "self", ".", "map", "=", "np", ".", "zeros", "(", "(", "self", ".", "input_size", ",", "latent_dim", ")", ")", "\n", "self", ".", "createModel", "(", ")", "\n", "\n", "self", ".", "createMap", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createModel": [[31, 34], ["VAE.VAE.createConvModel"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createConvModel"], ["", "def", "createModel", "(", "self", ")", ":", "\n", "\n", "\t\t", "self", ".", "createConvModel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createConvModel": [[35, 46], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense"], "methods", ["None"], ["", "def", "createConvModel", "(", "self", ")", ":", "\n", "\n", "\t\t", "input_shape", "=", "(", "self", ".", "input_size", ")", "\n", "input_layer", "=", "Input", "(", "shape", "=", "input_shape", ")", "\n", "layer", "=", "Dense", "(", "self", ".", "latent_dim", ")", "(", "input_layer", ")", "\n", "#layer = Droupout(0.4)(layer)", "\n", "#layer = Dense(latent_dim)(layer)", "\n", "output", "=", "Dense", "(", "self", ".", "input_size", ",", "activation", "=", "'sigmoid'", ")", "(", "layer", ")", "\n", "\n", "self", ".", "model", "=", "Model", "(", "input_layer", ",", "output", ")", "\n", "self", ".", "encoder", "=", "Model", "(", "input_layer", ",", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createLSTMModel": [[48, 59], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.RepeatVector", "tensorflow.keras.layers.LSTM"], "methods", ["None"], ["", "def", "createLSTMModel", "(", "self", ")", ":", "\n", "\n", "\t\t", "inputs", "=", "Input", "(", "shape", "=", "(", "self", ".", "timesteps", ",", "self", ".", "input_size", ")", ")", "\n", "encoded", "=", "LSTM", "(", "self", ".", "latent_dim", ")", "(", "inputs", ")", "\n", "\n", "decoded", "=", "RepeatVector", "(", "self", ".", "timesteps", ")", "(", "encoded", ")", "\n", "decoded", "=", "LSTM", "(", "self", ".", "input_size", ",", "return_sequences", "=", "True", ")", "(", "decoded", ")", "\n", "\n", "\n", "self", ".", "model", "=", "Model", "(", "inputs", ",", "decoded", ")", "\n", "self", ".", "encoder", "=", "Model", "(", "inputs", ",", "encoded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.input": [[60, 116], ["enumerate", "tensorflow.keras.optimizers.Adam", "VAE.VAE.model.compile", "numpy.array", "numpy.array", "VAE.VAE.model.fit", "int", "numpy.sum", "numpy.sum.sum", "VAE.VAE.x_train.append", "VAE.VAE.y_train.append"], "methods", ["None"], ["", "def", "input", "(", "self", ",", "x", ")", ":", "\n", "\n", "#convert to n-gram or skip-gram", "\n", "\t\t", "for", "i", ",", "sample", "in", "enumerate", "(", "x", ")", ":", "\n", "\t\t\t", "if", "i", "-", "self", ".", "timesteps", ">=", "0", ":", "\n", "\t\t\t\t", "position", "=", "int", "(", "self", ".", "timesteps", "/", "2", ")", "\n", "y", "=", "x", "[", "i", "-", "position", "]", "\n", "a", "=", "i", "-", "self", ".", "timesteps", "\n", "b", "=", "i", "-", "position", "\n", "c", "=", "i", "-", "position", "+", "1", "\n", "d", "=", "i", "+", "1", "\n", "#rint(a,b,c,d)", "\n", "#xit()", "\n", "#sample = x[i-self.timesteps:(i-position)] + x[i-position+1:i+1]", "\n", "sample", "=", "x", "[", "np", ".", "r_", "[", "a", ":", "b", ",", "c", ":", "d", "]", "]", "\n", "\n", "#print(sample)", "\n", "#sample= [a.argmax() for a in sample]", "\n", "sample", "=", "np", ".", "sum", "(", "sample", ",", "axis", "=", "0", ")", "\n", "#print(sample)", "\n", "sample", "/=", "sample", ".", "sum", "(", ")", "\n", "#print(sample)", "\n", "#exit()", "\n", "#skip-gram", "\n", "#self.dataset.append((y, sample))", "\n", "self", ".", "x_train", ".", "append", "(", "y", ")", "\n", "self", ".", "y_train", ".", "append", "(", "sample", ")", "\n", "#print(sample)", "\n", "#sample= np.argmax(sample)", "\n", "#print(sample)", "\n", "#exit()", "\n", "#n-gram", "\n", "#self.dataset.append((sample, y))", "\n", "\n", "\n", "", "", "learning_rate", "=", "1e-3", "\n", "epochs", "=", "10", "\n", "batch_size", "=", "64", "\n", "loss", "=", "\"mean_squared_error\"", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "Adam", "(", "lr", "=", "learning_rate", ")", "\n", "self", ".", "model", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "loss", ",", "metrics", "=", "[", "'acc'", "]", ")", "\n", "\n", "np_x_train", "=", "np", ".", "array", "(", "self", ".", "x_train", ")", "\n", "np_y_train", "=", "np", ".", "array", "(", "self", ".", "y_train", ")", "\n", "\n", "#self.x_train = self.x_train[:,None]", "\n", "\n", "#print(self.x_train.shape, self.y_train.shape)", "\n", "\n", "self", ".", "model", ".", "fit", "(", "\n", "np_x_train", ",", "\n", "np_y_train", ",", "\n", "epochs", "=", "epochs", ",", "\n", "#validation_data=(x_val, val_labels),", "\n", "verbose", "=", "2", ",", "# Logs once per epoch.", "\n", "batch_size", "=", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createMap": [[125, 135], ["enumerate", "keras.utils.np_utils.to_categorical", "VAE.VAE.encoder.predict", "range"], "methods", ["None"], ["", "def", "createMap", "(", "self", ")", ":", "\n", "\n", "\n", "\t\t", "all_possible_inputs", "=", "[", "np_utils", ".", "to_categorical", "(", "i", ",", "self", ".", "input_size", ")", "for", "i", "in", "range", "(", "self", ".", "input_size", ")", "]", "\n", "for", "i", ",", "a", "in", "enumerate", "(", "all_possible_inputs", ")", ":", "\n", "\t\t\t", "sample", "=", "a", "[", "None", ",", ":", "]", "\n", "#print(\"a shape\", a.shape)", "\n", "predicted", "=", "self", ".", "encoder", ".", "predict", "(", "sample", ")", "\n", "#print(predicted)", "\n", "self", ".", "map", "[", "i", "]", "=", "predicted", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.organize": [[137, 147], ["VAE.VAE.createMap", "sklearn.cluster.DBSCAN().fit_predict", "sklearn.cluster.DBSCAN"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.createMap"], ["", "", "def", "organize", "(", "self", ")", ":", "\n", "\n", "\t\t", "self", ".", "organized", "=", "True", "\n", "#self.labels= DBSCAN(eps=3, min_samples=2).fit_predict(self.syncmap)", "\n", "\n", "self", ".", "createMap", "(", ")", "\n", "\n", "self", ".", "labels", "=", "DBSCAN", "(", "eps", "=", "1", ",", "min_samples", "=", "2", ")", ".", "fit_predict", "(", "self", ".", "map", ")", "\n", "\n", "return", "self", ".", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.activate": [[148, 161], ["numpy.argmax", "print"], "methods", ["None"], ["", "def", "activate", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "'''\n\t\tReturn the label of the index with maximum input value\n\t\t'''", "\n", "\n", "if", "self", ".", "organized", "==", "False", ":", "\n", "\t\t\t", "print", "(", "\"Activating a non-organized SyncMap\"", ")", "\n", "return", "\n", "\n", "#maximum output", "\n", "", "max_index", "=", "np", ".", "argmax", "(", "x", ")", "\n", "\n", "return", "self", ".", "labels", "[", "max_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plotSequence": [[162, 180], ["numpy.asarray", "matplotlib.plot", "matplotlib.plot", "matplotlib.savefig", "matplotlib.show", "matplotlib.close", "VAE.VAE.activate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot", "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.activate"], ["", "def", "plotSequence", "(", "self", ",", "input_sequence", ",", "input_class", ",", "filename", "=", "\"plot.png\"", ")", ":", "\n", "\n", "\t\t", "input_sequence", "=", "input_sequence", "[", "1", ":", "500", "]", "\n", "input_class", "=", "input_class", "[", "1", ":", "500", "]", "\n", "\n", "a", "=", "np", ".", "asarray", "(", "input_class", ")", "\n", "t", "=", "[", "i", "for", "i", ",", "value", "in", "enumerate", "(", "a", ")", "]", "\n", "c", "=", "[", "self", ".", "activate", "(", "x", ")", "for", "x", "in", "input_sequence", "]", "\n", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "a", ",", "'-g'", ")", "\n", "plt", ".", "plot", "(", "t", ",", "c", ",", "'-.k'", ")", "\n", "#plt.ylim([-0.01,1.2])", "\n", "\n", "\n", "plt", ".", "savefig", "(", "filename", ",", "quality", "=", "1", ",", "dpi", "=", "300", ")", "\n", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.plot": [[182, 207], ["matplotlib.show", "matplotlib.close", "matplotlib.scatter", "matplotlib.figure", "matplotlib.axes", "matplotlib.axes.scatter3D", "matplotlib.savefig"], "methods", ["None"], ["", "def", "plot", "(", "self", ",", "color", "=", "None", ",", "save", "=", "False", ",", "filename", "=", "\"plot_map.png\"", ")", ":", "\n", "\n", "\t\t", "if", "color", "is", "None", ":", "\n", "\t\t\t", "color", "=", "self", ".", "labels", "\n", "\n", "#print(self.syncmap)", "\n", "#print(self.syncmap[:,0])", "\n", "#print(self.syncmap[:,1])", "\n", "", "if", "self", ".", "latent_dim", "==", "2", ":", "\n", "#print(type(color))", "\n", "#print(color.shape)", "\n", "\t\t\t", "ax", "=", "plt", ".", "scatter", "(", "self", ".", "map", "[", ":", ",", "0", "]", ",", "self", ".", "map", "[", ":", ",", "1", "]", ",", "c", "=", "color", ")", "\n", "\n", "", "if", "self", ".", "latent_dim", "==", "3", ":", "\n", "\t\t\t", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "axes", "(", "projection", "=", "'3d'", ")", "\n", "\n", "ax", ".", "scatter3D", "(", "self", ".", "map", "[", ":", ",", "0", "]", ",", "self", ".", "map", "[", ":", ",", "1", "]", ",", "self", ".", "map", "[", ":", ",", "2", "]", ",", "c", "=", "color", ")", ";", "\n", "#ax.plot3D(self.syncmap[:,0],self.syncmap[:,1], self.syncmap[:,2])", "\n", "\n", "", "if", "save", "==", "True", ":", "\n", "\t\t\t", "plt", ".", "savefig", "(", "filename", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.save": [[208, 213], ["open", "open.write", "open.close", "cPickle.dumps"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "\t\t", "\"\"\"save class as self.name.txt\"\"\"", "\n", "file", "=", "open", "(", "filename", "+", "'.txt'", ",", "'w'", ")", "\n", "file", ".", "write", "(", "cPickle", ".", "dumps", "(", "self", ".", "__dict__", ")", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.zweifel_SyncMap.None.VAE.VAE.load": [[214, 221], ["open", "open.read", "open.close", "cPickle.loads"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "filename", ")", ":", "\n", "\t\t", "\"\"\"try load self.name.txt\"\"\"", "\n", "file", "=", "open", "(", "filename", "+", "'.txt'", ",", "'r'", ")", "\n", "dataPickle", "=", "file", ".", "read", "(", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n", "self", ".", "__dict__", "=", "cPickle", ".", "loads", "(", "dataPickle", ")", "\n", "\n"]]}