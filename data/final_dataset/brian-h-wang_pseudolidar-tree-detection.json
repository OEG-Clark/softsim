{"home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_all": [[19, 32], ["pathlib.Path", "pointcloud_annotation.dataset.Counter", "subdirs.sort", "print", "convert_zed_data.convert_dataset", "os.listdir", "os.path.isdir", "pathlib.Path().exists", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_dataset"], ["def", "convert_all", "(", "parent_path", ",", "output_path", ",", "skip_frames", "=", "0", ",", "skip_images", "=", "False", ")", ":", "\n", "    ", "parent_path", "=", "Path", "(", "parent_path", ")", "\n", "counter", "=", "Counter", "(", ")", "\n", "subdirs", "=", "[", "d", "for", "d", "in", "os", ".", "listdir", "(", "parent_path", ")", "if", "os", ".", "path", ".", "isdir", "(", "parent_path", "/", "d", ")", "]", "\n", "subdirs", ".", "sort", "(", ")", "\n", "for", "subdir", "in", "subdirs", ":", "\n", "        ", "if", "not", "Path", "(", "parent_path", "/", "subdir", "/", "\"pointcloud\"", ")", ".", "exists", "(", ")", ":", "\n", "# Skip non-dataset folders", "\n", "            ", "continue", "\n", "", "print", "(", "\"Converting data in '%s'.\"", "%", "subdir", ")", "\n", "convert_dataset", "(", "dataset_path", "=", "parent_path", "/", "subdir", ",", "\n", "output_path", "=", "output_path", ",", "\n", "counter", "=", "counter", ",", "skip_frames", "=", "skip_frames", ",", "skip_images", "=", "skip_images", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_dataset": [[34, 102], ["pathlib.Path", "os.listdir", "frame_numbers.sort", "pointcloud_annotation.zed_utils.load_zed_calib", "print", "counter.next", "pointcloud_annotation.zed_utils.load_zed_calib.to_kitti_calib_file", "convert_zed_data.convert_velodyne", "os.path.exists", "dir.mkdir", "filename.split", "frame_numbers.append", "convert_zed_data.convert_image", "int", "print", "str"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_zed_calib", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Counter.next", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.CameraCalibration.to_kitti_calib_file", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_velodyne", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_image"], ["", "", "def", "convert_dataset", "(", "dataset_path", ",", "output_path", ",", "counter", ",", "skip_frames", "=", "0", ",", "skip_images", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Convert all the data in a specific dataset (e.g. \"forest-straight-1\")\n\n    Parameters\n    ----------\n    dataset_path: Path\n    counter: Counter\n\n    Returns\n    -------\n    None\n\n    \"\"\"", "\n", "\n", "# Prepare input and output file paths", "\n", "rgb_path", "=", "dataset_path", "/", "\"rgb\"", "\n", "pcd_path", "=", "dataset_path", "/", "\"pointcloud\"", "\n", "calib_path", "=", "dataset_path", "/", "\"calibration.yaml\"", "\n", "\n", "output_path", "=", "Path", "(", "output_path", ")", "\n", "calib_output_directory", "=", "output_path", "/", "\"calib\"", "\n", "velodyne_output_directory", "=", "output_path", "/", "\"velodyne\"", "\n", "image_output_directory", "=", "output_path", "/", "\"image_2\"", "\n", "\n", "# Create any output directories that don't exist yet", "\n", "for", "dir", "in", "[", "calib_output_directory", ",", "velodyne_output_directory", ",", "image_output_directory", "]", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "            ", "dir", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# Get all the numbers of time steps", "\n", "", "", "frame_numbers", "=", "[", "]", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "rgb_path", ")", ":", "\n", "        ", "s", "=", "filename", ".", "split", "(", "'.'", ")", "[", "0", "]", "# gives just the number", "\n", "try", ":", "\n", "            ", "frame_numbers", ".", "append", "(", "int", "(", "s", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "print", "(", "\"[WARNING] Found invalid filename '%s'\"", "%", "filename", ")", "\n", "", "", "frame_numbers", ".", "sort", "(", ")", "\n", "\n", "\n", "if", "skip_frames", ">", "1", ":", "\n", "        ", "frame_numbers", "=", "frame_numbers", "[", "0", ":", ":", "skip_frames", "]", "\n", "\n", "\n", "# Load calibration once - stays the same for all frame numbers", "\n", "", "calib", "=", "load_zed_calib", "(", "calib_path", ")", "\n", "\n", "for", "fn", "in", "frame_numbers", ":", "\n", "        ", "print", "(", "\"Processing dataset '%s', frame %d...\"", "%", "(", "str", "(", "dataset_path", ")", ",", "fn", ")", ")", "\n", "output_index", "=", "counter", ".", "next", "(", ")", "\n", "\n", "rgb_in_filename", "=", "rgb_path", "/", "(", "\"%d.jpeg\"", "%", "fn", ")", "\n", "pcd_in_filename", "=", "pcd_path", "/", "(", "\"%d.npz\"", "%", "fn", ")", "\n", "\n", "calib_out_filename", "=", "calib_output_directory", "/", "(", "\"%06d.txt\"", "%", "output_index", ")", "\n", "image_out_filename", "=", "image_output_directory", "/", "(", "\"%06d.png\"", "%", "output_index", ")", "\n", "velodyne_out_filename", "=", "velodyne_output_directory", "/", "(", "\"%06d.bin\"", "%", "output_index", ")", "\n", "\n", "# Write calibration", "\n", "calib", ".", "to_kitti_calib_file", "(", "calib_out_filename", ")", "\n", "\n", "# Write image", "\n", "if", "not", "skip_images", ":", "\n", "            ", "convert_image", "(", "rgb_in_filename", ",", "image_out_filename", ")", "\n", "\n", "# Write stereo pointcloud to \"velodyne\" data", "\n", "", "convert_velodyne", "(", "pcd_in_filename", ",", "velodyne_out_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_image": [[104, 108], ["skimage.io.imread", "skimage.io.imsave"], "function", ["None"], ["", "", "def", "convert_image", "(", "image_in_filename", ",", "image_out_filename", ")", ":", "\n", "# Load image", "\n", "    ", "image", "=", "imread", "(", "image_in_filename", ")", "\n", "imsave", "(", "image_out_filename", ",", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.None.convert_zed_data.convert_velodyne": [[110, 128], ["pointcloud_annotation.zed_utils.load_pointcloud_from_zed_npz", "numpy.asarray", "numpy.zeros", "open", "np.zeros.astype", "pointcloud_kitti.astype.tofile"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_pointcloud_from_zed_npz"], ["", "def", "convert_velodyne", "(", "pcd_in_filename", ",", "velodyne_out_filename", ")", ":", "\n", "    ", "pcd", "=", "load_pointcloud_from_zed_npz", "(", "pcd_in_filename", ")", "\n", "# Convert to x forwards, y left, z up", "\n", "# pcd.transform([[0, 0, 1, 0], [-1, 0, 0, 0], [0, -1, 0, 0], [0, 0, 0, 1]])", "\n", "points", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "\n", "\n", "# Convert from camera coordinates to KITTI styles", "\n", "# airsim is x right, y forwards, z up", "\n", "# rtabmap is x right, y down, z forwards", "\n", "# KITTI is x forwards, y left, z up", "\n", "\n", "pointcloud_kitti", "=", "np", ".", "zeros", "(", "(", "points", ".", "shape", "[", "0", "]", ",", "4", ")", ")", "\n", "pointcloud_kitti", "[", ":", ",", "0", ":", "3", "]", "=", "points", "\n", "pointcloud_kitti", "[", ":", ",", "3", "]", "=", "1", "# Set intensity values to all 1s", "\n", "\n", "with", "open", "(", "velodyne_out_filename", ",", "'w'", ")", "as", "output_file", ":", "\n", "        ", "out_pointcloud", "=", "pointcloud_kitti", ".", "astype", "(", "np", ".", "float32", ")", "\n", "out_pointcloud", ".", "tofile", "(", "output_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.__init__": [[13, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "x", ",", "y", ",", "z", ",", "h", ",", "w", ",", "l", ",", "rotation_y", ",", "track_id", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        x: float\n        y: float\n        z: float\n        h: float\n        w: float\n        l: float\n        \"\"\"", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "z", "=", "z", "\n", "self", ".", "height", "=", "h", "\n", "self", ".", "width", "=", "w", "\n", "self", ".", "length", "=", "l", "\n", "self", ".", "rotation_y", "=", "rotation_y", "\n", "self", ".", "track_id", "=", "track_id", "\n", "self", ".", "color", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.from_kitti": [[35, 65], ["kitti_str.split", "int", "int", "float", "float", "float", "float", "float", "float", "float", "tracking.TrackerBoundingBox"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_kitti", "(", "kitti_str", ")", ":", "\n", "        ", "\"\"\"\n        Create a TrackerBoundingBox from KITTI format data.\n\n        Parameters\n        ----------\n        kitti_str: str\n            Object information, including 3D bounding box,\n            in KITTI object detection format.\n\n        Returns\n        -------\n        TrackerBoundingBox\n\n        \"\"\"", "\n", "split", "=", "kitti_str", ".", "split", "(", "' '", ")", "\n", "frame", "=", "int", "(", "split", "[", "0", "]", ")", "\n", "track_id", "=", "int", "(", "split", "[", "1", "]", ")", "\n", "# object_type = split[2]", "\n", "# indices 3,4,5,6,7,8 are 'truncated', 'occluded', and the four 2D bounding box coords", "\n", "h", "=", "float", "(", "split", "[", "10", "]", ")", "\n", "w", "=", "float", "(", "split", "[", "11", "]", ")", "\n", "l", "=", "float", "(", "split", "[", "12", "]", ")", "\n", "x", "=", "float", "(", "split", "[", "13", "]", ")", "\n", "y", "=", "float", "(", "split", "[", "14", "]", ")", "\n", "z", "=", "float", "(", "split", "[", "15", "]", ")", "\n", "# Ignore rotation_y - will be approx. zero for all bboxes", "\n", "rotation_y", "=", "float", "(", "split", "[", "5", "]", ")", "\n", "return", "frame", ",", "TrackerBoundingBox", "(", "x", "=", "x", ",", "y", "=", "y", ",", "z", "=", "z", ",", "h", "=", "h", ",", "w", "=", "w", ",", "l", "=", "l", ",", "rotation_y", "=", "rotation_y", ",", "track_id", "=", "track_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range": [[66, 69], ["numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "range", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "sqrt", "(", "self", ".", "z", "**", "2", "+", "self", ".", "x", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.distance": [[70, 84], ["numpy.sqrt"], "methods", ["None"], ["", "def", "distance", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"\n        Computes the distance between the center of this box and another box\n\n        Parameters\n        ----------\n        other: TrackerBoundingBox\n\n        Returns\n        -------\n        float\n            Distance between the box centers\n        \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "(", "self", ".", "x", "-", "other", ".", "x", ")", "**", "2", "+", "(", "self", ".", "z", "-", "other", ".", "z", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.from_kitti_detection": [[85, 113], ["kitti_str.split", "float", "float", "float", "float", "float", "float", "float", "tracking.TrackerBoundingBox"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_kitti_detection", "(", "kitti_str", ")", ":", "\n", "        ", "\"\"\"\n        Create a TrackerBoundingBox from KITTI object detection format data.\n\n        Parameters\n        ----------\n        kitti_str: str\n            Object information, including 3D bounding box,\n            in KITTI object detection format.\n\n        Returns\n        -------\n        TrackerBoundingBox\n\n        \"\"\"", "\n", "split", "=", "kitti_str", ".", "split", "(", "' '", ")", "\n", "# object_type = split[0]", "\n", "# indices 3,4,5,6,7,8 are 'truncated', 'occluded', and the four 2D bounding box coords", "\n", "h", "=", "float", "(", "split", "[", "8", "]", ")", "\n", "w", "=", "float", "(", "split", "[", "9", "]", ")", "\n", "l", "=", "float", "(", "split", "[", "10", "]", ")", "\n", "x", "=", "float", "(", "split", "[", "11", "]", ")", "\n", "y", "=", "float", "(", "split", "[", "12", "]", ")", "\n", "z", "=", "float", "(", "split", "[", "13", "]", ")", "\n", "# Ignore rotation_y - will be approx. zero for all bboxes", "\n", "rotation_y", "=", "float", "(", "split", "[", "14", "]", ")", "\n", "return", "TrackerBoundingBox", "(", "x", "=", "x", ",", "y", "=", "y", ",", "z", "=", "z", ",", "h", "=", "h", ",", "w", "=", "w", ",", "l", "=", "l", ",", "rotation_y", "=", "rotation_y", ",", "track_id", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.to_o3d": [[114, 143], ["numpy.zeros", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "open3d.geometry.TriangleMesh.create_cylinder", "numpy.zeros", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.rotate", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.translate", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.paint_uniform_color"], "methods", ["None"], ["", "def", "to_o3d", "(", "self", ",", "cylinder", "=", "False", ")", ":", "\n", "        ", "if", "not", "cylinder", ":", "\n", "            ", "points", "=", "np", ".", "zeros", "(", "(", "8", ",", "3", ")", ")", "\n", "i", "=", "0", "\n", "\n", "size", "=", "self", ".", "size", "# ignore length, height", "\n", "# Note: x, y, z are in camera coords", "\n", "for", "dx", "in", "[", "-", "size", "/", "2.", ",", "size", "/", "2.", "]", ":", "\n", "                ", "for", "dy", "in", "[", "0", ",", "-", "HEIGHT", "]", ":", "\n", "                    ", "for", "dz", "in", "[", "-", "size", "/", "2.", ",", "size", "/", "2", "]", ":", "\n", "                        ", "points", "[", "i", ",", ":", "]", "=", "[", "self", ".", "x", "+", "dx", ",", "self", ".", "y", "+", "dy", ",", "self", ".", "z", "+", "dz", "]", "\n", "i", "+=", "1", "\n", "\n", "", "", "", "points_v3d", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", ")", "\n", "bbox_o3d", "=", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "points_v3d", ")", "\n", "bbox_o3d", ".", "color", "=", "self", ".", "color", "\n", "bbox_o3d", "\n", "\n", "", "else", ":", "\n", "            ", "bbox_o3d", ":", "o3d", ".", "geometry", ".", "TriangleMesh", "=", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_cylinder", "(", "radius", "=", "self", ".", "size", "/", "2", ",", "height", "=", "HEIGHT", ")", "\n", "R", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "R", "[", "0", ",", "0", "]", "=", "1", "\n", "R", "[", "1", ",", "2", "]", "=", "1", "\n", "R", "[", "2", ",", "1", "]", "=", "1", "\n", "bbox_o3d", ".", "rotate", "(", "R", ",", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "bbox_o3d", ".", "translate", "(", "[", "self", ".", "x", ",", "self", ".", "y", "-", "HEIGHT", "/", "2", ",", "self", ".", "z", "]", ")", "\n", "bbox_o3d", ".", "paint_uniform_color", "(", "self", ".", "color", ")", "\n", "\n", "", "return", "bbox_o3d", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.__str__": [[144, 150], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"--------------------------------------\\n\"", "\"Bounding box ID: %d\\n\"", "\"Position (x,y,z): [%.3f, %.3f, %.3f]\\n\"", "\"Dimensions (h,w,l): [%.3f, %.3f, %.3f]\\n\"", "\"--------------------------------------\"", "%", "(", "self", ".", "track_id", ",", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ",", "self", ".", "height", ",", "self", ".", "width", ",", "self", ".", "length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.size": [[151, 154], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "width", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBoxWithVariance.__init__": [[157, 173], ["tracking.TrackerBoundingBox.__init__"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x", ",", "y", ",", "z", ",", "h", ",", "w", ",", "l", ",", "rotation_y", ",", "track_id", ",", "var_x", ",", "var_z", ",", "var_size", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        x: float\n        y: float\n        z: float\n        h: float\n        w: float\n        l: float\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "x", ",", "y", ",", "z", ",", "h", ",", "w", ",", "l", ",", "rotation_y", ",", "track_id", ")", "\n", "self", ".", "var_x", "=", "var_x", "\n", "self", ".", "var_z", "=", "var_z", "\n", "self", ".", "var_size", "=", "var_size", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBoxWithVariance.from_kitti": [[175, 215], ["kitti_str.split", "int", "int", "float", "float", "float", "float", "float", "float", "float", "var_str.split", "int", "int", "float", "float", "float", "tracking.TrackerBoundingBoxWithVariance"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_kitti", "(", "kitti_str", ",", "var_str", ")", ":", "\n", "        ", "\"\"\"\n        Create a TrackerBoundingBox from KITTI format data.\n\n        Parameters\n        ----------\n        kitti_str: str\n            Object information, including 3D bounding box,\n            in KITTI object detection format.\n\n        Returns\n        -------\n        TrackerBoundingBox\n\n        \"\"\"", "\n", "split", "=", "kitti_str", ".", "split", "(", "' '", ")", "\n", "frame", "=", "int", "(", "split", "[", "0", "]", ")", "\n", "track_id", "=", "int", "(", "split", "[", "1", "]", ")", "\n", "# object_type = split[2]", "\n", "# indices 3,4,5,6,7,8 are 'truncated', 'occluded', and the four 2D bounding box coords", "\n", "h", "=", "float", "(", "split", "[", "10", "]", ")", "\n", "w", "=", "float", "(", "split", "[", "11", "]", ")", "\n", "l", "=", "float", "(", "split", "[", "12", "]", ")", "\n", "x", "=", "float", "(", "split", "[", "13", "]", ")", "\n", "y", "=", "float", "(", "split", "[", "14", "]", ")", "\n", "z", "=", "float", "(", "split", "[", "15", "]", ")", "\n", "# Ignore rotation_y - will be approx. zero for all bboxes", "\n", "rotation_y", "=", "float", "(", "split", "[", "5", "]", ")", "\n", "\n", "var_split", "=", "var_str", ".", "split", "(", "' '", ")", "\n", "var_frame", "=", "int", "(", "var_split", "[", "0", "]", ")", "\n", "var_track_id", "=", "int", "(", "var_split", "[", "1", "]", ")", "\n", "assert", "var_frame", "==", "frame", ",", "\"Error: Line of variances file does not match trk file.\"", "\n", "assert", "var_track_id", "==", "track_id", ",", "\"Error: Line of variances file does not match trk file.\"", "\n", "var_x", "=", "float", "(", "var_split", "[", "2", "]", ")", "\n", "var_z", "=", "float", "(", "var_split", "[", "3", "]", ")", "\n", "var_size", "=", "float", "(", "var_split", "[", "4", "]", ")", "\n", "return", "frame", ",", "TrackerBoundingBoxWithVariance", "(", "x", "=", "x", ",", "y", "=", "y", ",", "z", "=", "z", ",", "h", "=", "h", ",", "w", "=", "w", ",", "l", "=", "l", ",", "rotation_y", "=", "rotation_y", ",", "track_id", "=", "track_id", ",", "\n", "var_x", "=", "var_x", ",", "var_z", "=", "var_z", ",", "var_size", "=", "var_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.__init__": [[219, 223], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "box_color", "=", "None", ")", ":", "\n", "        ", "self", ".", "_results", "=", "{", "}", "\n", "self", ".", "colors", "=", "{", "}", "\n", "self", ".", "box_color", "=", "box_color", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.__getitem__": [[224, 229], ["tracking.TrackerResults._results.keys"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "time_step", ")", ":", "\n", "        ", "if", "time_step", "not", "in", "self", ".", "_results", ".", "keys", "(", ")", ":", "\n", "            ", "return", "[", "]", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_results", "[", "time_step", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.add": [[230, 242], ["isinstance", "type", "tracking.TrackerResults.colors.keys", "list", "numpy.random.random"], "methods", ["None"], ["", "", "def", "add", "(", "self", ",", "time_step", ",", "tracker_bbox", ")", ":", "\n", "        ", "assert", "type", "(", "time_step", ")", "==", "int", ",", "\"Must give an int time step as input\"", "\n", "assert", "isinstance", "(", "tracker_bbox", ",", "TrackerBoundingBox", ")", ",", "\"TrackerResults.add takes in a TrackerBoundingBox input\"", "\n", "if", "tracker_bbox", ".", "track_id", "not", "in", "self", ".", "colors", ".", "keys", "(", ")", ":", "\n", "            ", "if", "self", ".", "box_color", "is", "None", ":", "\n", "# new_color = list(np.random.random(3) * 0.7 + 0.2)", "\n", "                ", "new_color", "=", "list", "(", "np", ".", "random", ".", "random", "(", "3", ")", ")", "\n", "self", ".", "colors", "[", "tracker_bbox", ".", "track_id", "]", "=", "new_color", "\n", "", "else", ":", "\n", "                ", "self", ".", "colors", "[", "tracker_bbox", ".", "track_id", "]", "=", "self", ".", "box_color", "\n", "", "", "tracker_bbox", ".", "color", "=", "self", ".", "colors", "[", "tracker_bbox", ".", "track_id", "]", "\n", "self", ".", "_results", "[", "time_step", "]", "=", "self", "[", "time_step", "]", "+", "[", "tracker_bbox", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.n_frames": [[243, 246], ["numpy.max", "list", "tracking.TrackerResults._results.keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_frames", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "max", "(", "list", "(", "self", ".", "_results", ".", "keys", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load": [[247, 293], ["tracking.TrackerResults", "open", "tracking.TrackerBoundingBox.from_kitti", "tracking.TrackerResults.add", "l.rstrip", "data_file.readlines"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBoxWithVariance.from_kitti", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.add"], ["", "@", "staticmethod", "\n", "def", "load", "(", "data_path", ",", "box_color", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Loads a tracking results file and creates a TrackingResults object,\n        which can be used for accessing the tracker data.\n\n        The lines of the input file should contain, in order:\n        (Descriptions adapted from KITTI tracking devkit readme)\n\n        #Values    Name      Description\n        ----------------------------------------------------------------------------\n           1    frame        Frame within the sequence where the object appearers\n           1    track id     Unique tracking id of this object within this sequence\n           1    type         Describes the type of object: 'Car', 'Van', 'Truck',\n                             'Pedestrian', 'Person_sitting', 'Cyclist', 'Tram',\n                             'Misc' or 'DontCare'\n           1    truncated    Integer (0,1,2) indicating the level of truncation.\n                             Note that this is in contrast to the object detection\n                             benchmark where truncation is a float in [0,1].\n           1    occluded     Integer (0,1,2,3) indicating occlusion state:\n                             0 = fully visible, 1 = partly occluded\n                             2 = largely occluded, 3 = unknown\n           1    alpha        Observation angle of object, ranging [-pi..pi]\n           4    bbox         2D bounding box of object in the image (0-based index):\n                             contains left, top, right, bottom pixel coordinates\n           3    dimensions   3D object dimensions: height, width, length (in meters)\n           3    location     3D object location x,y,z in camera coordinates (in meters)\n           1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]\n           1    score        Only for results: Float, indicating confidence in\n                             detection, needed for p/r curves, higher is better.\n\n        Parameters\n        ----------\n        data_path\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "results", "=", "TrackerResults", "(", "box_color", "=", "box_color", ")", "\n", "with", "open", "(", "data_path", ",", "'r'", ")", "as", "data_file", ":", "\n", "            ", "lines", "=", "[", "l", ".", "rstrip", "(", ")", "for", "l", "in", "data_file", ".", "readlines", "(", ")", "]", "\n", "", "for", "line", "in", "lines", ":", "\n", "            ", "frame", ",", "bbox", "=", "TrackerBoundingBox", ".", "from_kitti", "(", "line", ")", "\n", "results", ".", "add", "(", "frame", ",", "bbox", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load_from_detections": [[294, 342], ["pathlib.Path", "tracking.TrackerResults", "os.listdir", "int", "open", "tracking.TrackerBoundingBox.from_kitti_detection", "tracking.TrackerResults.add", "filename.split", "l.rstrip", "detections_file.readlines"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.from_kitti_detection", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.add"], ["", "@", "staticmethod", "\n", "def", "load_from_detections", "(", "detections_path", ",", "box_color", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Loads a tracking results file and creates a TrackingResults object,\n        which can be used for accessing the tracker data.\n\n        The lines of the input file should contain, in order:\n        (Descriptions adapted from KITTI tracking devkit readme)\n\n        #Values    Name      Description\n        ----------------------------------------------------------------------------\n           1    type         Describes the type of object: 'Car', 'Van', 'Truck',\n                             'Pedestrian', 'Person_sitting', 'Cyclist', 'Tram',\n                             'Misc' or 'DontCare'\n           1    truncated    Integer (0,1,2) indicating the level of truncation.\n                             Note that this is in contrast to the object detection\n                             benchmark where truncation is a float in [0,1].\n           1    occluded     Integer (0,1,2,3) indicating occlusion state:\n                             0 = fully visible, 1 = partly occluded\n                             2 = largely occluded, 3 = unknown\n           1    alpha        Observation angle of object, ranging [-pi..pi]\n           4    bbox         2D bounding box of object in the image (0-based index):\n                             contains left, top, right, bottom pixel coordinates\n           3    dimensions   3D object dimensions: height, width, length (in meters)\n           3    location     3D object location x,y,z in camera coordinates (in meters)\n           1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]\n           1    score        Only for results: Float, indicating confidence in\n                             detection, needed for p/r curves, higher is better.\n\n        Parameters\n        ----------\n        data_path\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "detections_path", "=", "Path", "(", "detections_path", ")", "\n", "results", "=", "TrackerResults", "(", "box_color", "=", "box_color", ")", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "detections_path", ")", ":", "\n", "            ", "frame", "=", "int", "(", "filename", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "\n", "with", "open", "(", "detections_path", "/", "filename", ",", "'r'", ")", "as", "detections_file", ":", "\n", "                ", "lines", "=", "[", "l", ".", "rstrip", "(", ")", "for", "l", "in", "detections_file", ".", "readlines", "(", ")", "]", "\n", "", "for", "line", "in", "lines", ":", "\n", "                ", "bbox", "=", "TrackerBoundingBox", ".", "from_kitti_detection", "(", "line", ")", "\n", "results", ".", "add", "(", "frame", ",", "bbox", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load_with_variance": [[343, 397], ["tracking.TrackerResults", "zip", "open", "open", "tracking.TrackerBoundingBoxWithVariance.from_kitti", "tracking.TrackerResults.add", "l.rstrip", "l.rstrip", "data_file.readlines", "data_file.readlines"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBoxWithVariance.from_kitti", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.add"], ["", "@", "staticmethod", "\n", "def", "load_with_variance", "(", "trk_path", ",", "var_path", ",", "box_color", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Loads a tracking results file and a tracker estimate variances file,\n        and creates a TrackingResults object,\n        which can be used for accessing the tracker data.\n\n        The lines of the input file should contain, in order:\n        (Descriptions adapted from KITTI tracking devkit readme)\n\n        #Values    Name      Description\n        ----------------------------------------------------------------------------\n           1    frame        Frame within the sequence where the object appearers\n           1    track id     Unique tracking id of this object within this sequence\n           1    type         Describes the type of object: 'Car', 'Van', 'Truck',\n                             'Pedestrian', 'Person_sitting', 'Cyclist', 'Tram',\n                             'Misc' or 'DontCare'\n           1    truncated    Integer (0,1,2) indicating the level of truncation.\n                             Note that this is in contrast to the object detection\n                             benchmark where truncation is a float in [0,1].\n           1    occluded     Integer (0,1,2,3) indicating occlusion state:\n                             0 = fully visible, 1 = partly occluded\n                             2 = largely occluded, 3 = unknown\n           1    alpha        Observation angle of object, ranging [-pi..pi]\n           4    bbox         2D bounding box of object in the image (0-based index):\n                             contains left, top, right, bottom pixel coordinates\n           3    dimensions   3D object dimensions: height, width, length (in meters)\n           3    location     3D object location x,y,z in camera coordinates (in meters)\n           1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]\n           1    score        Only for results: Float, indicating confidence in\n                             detection, needed for p/r curves, higher is better.\n\n\n        Variance file is:\n        frame   track_id     var_x     var_z      var_size (width)\n\n\n        Parameters\n        ----------\n        data_path\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "results", "=", "TrackerResults", "(", "box_color", "=", "box_color", ")", "\n", "with", "open", "(", "trk_path", ",", "'r'", ")", "as", "data_file", ":", "\n", "            ", "lines_trk", "=", "[", "l", ".", "rstrip", "(", ")", "for", "l", "in", "data_file", ".", "readlines", "(", ")", "]", "\n", "", "with", "open", "(", "var_path", ",", "'r'", ")", "as", "data_file", ":", "\n", "            ", "lines_var", "=", "[", "l", ".", "rstrip", "(", ")", "for", "l", "in", "data_file", ".", "readlines", "(", ")", "]", "\n", "", "for", "l_trk", ",", "l_var", "in", "zip", "(", "lines_trk", ",", "lines_var", ")", ":", "\n", "            ", "frame", ",", "bbox", "=", "TrackerBoundingBoxWithVariance", ".", "from_kitti", "(", "l_trk", ",", "l_var", ")", "\n", "results", ".", "add", "(", "frame", ",", "bbox", ")", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.__init__": [[22, 79], ["pathlib.Path", "open3d.visualization.Visualizer", "open3d.visualization.Visualizer", "visualization.TrackingVisualizer.vis.create_window", "open3d.geometry.PointCloud", "open3d.geometry.PointCloud", "numpy.fromfile", "numpy.fromfile", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "visualization.TrackingVisualizer.vis.add_geometry", "visualization.TrackingVisualizer.vis.get_render_option", "visualization.TrackingVisualizer.vis.get_view_control", "visualization.TrackingVisualizer.set_up", "visualization.TrackingVisualizer.set_front", "visualization.TrackingVisualizer.set_lookat", "visualization.TrackingVisualizer.set_zoom", "tracker_vis.tracking.TrackerResults.load", "tracker_vis.tracking.TrackerResults.load_from_detections", "tracker_vis.tracking.TrackerResults.load", "pathlib.Path", "skimage.io.imread_collection", "open3d.visualization.Visualizer", "open3d.visualization.Visualizer", "visualization.TrackingVisualizer.image_vis.create_window", "numpy.fromfile.reshape", "visualization.cam_to_velo_frame", "visualization.TrackingVisualizer.vis.add_geometry", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "pathlib.Path", "pathlib.Path", "pathlib.Path", "str", "open3d.geometry.TriangleMesh.create_coordinate_frame", "open3d.geometry.TriangleMesh.create_coordinate_frame"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load_from_detections", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.cam_to_velo_frame"], ["    ", "def", "__init__", "(", "self", ",", "pointcloud_path", ",", "results_path", "=", "None", ",", "gt_path", "=", "None", ",", "detections_path", "=", "None", ",", "image_path", "=", "None", ",", "\n", "fps", "=", "60", ",", "n_skip", "=", "1", ",", "show_ax", "=", "False", ",", "frame", "=", "None", ")", ":", "\n", "        ", "self", ".", "tracking_results", "=", "self", ".", "detections", "=", "self", ".", "ground_truth", "=", "None", "\n", "if", "results_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "tracking_results", "=", "TrackerResults", ".", "load", "(", "Path", "(", "results_path", ")", ")", "\n", "", "if", "detections_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "detections", "=", "TrackerResults", ".", "load_from_detections", "(", "Path", "(", "detections_path", ")", ",", "box_color", "=", "DET_COLOR", ")", "\n", "", "if", "gt_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "ground_truth", "=", "TrackerResults", ".", "load", "(", "Path", "(", "gt_path", ")", ",", "box_color", "=", "GT_BOX_COLOR", ")", "\n", "", "self", ".", "pointcloud_path", "=", "Path", "(", "pointcloud_path", ")", "\n", "self", ".", "vis", "=", "o3d", ".", "visualization", ".", "Visualizer", "(", ")", "\n", "self", ".", "vis", ".", "create_window", "(", "height", "=", "720", ",", "width", "=", "960", ")", "\n", "self", ".", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "\n", "self", ".", "show_images", "=", "image_path", "is", "not", "None", "\n", "if", "self", ".", "show_images", ":", "\n", "            ", "self", ".", "image_path", "=", "Path", "(", "image_path", ")", "\n", "self", ".", "images", "=", "imread_collection", "(", "str", "(", "self", ".", "image_path", "/", "\"*.png\"", ")", ",", "conserve_memory", "=", "True", ")", "\n", "self", ".", "image_vis", "=", "o3d", ".", "visualization", ".", "Visualizer", "(", ")", "\n", "self", ".", "image_vis", ".", "create_window", "(", "height", "=", "720", ",", "width", "=", "720", ",", "left", "=", "1024", ")", "\n", "\n", "# Load the first point cloud", "\n", "# Without doing this, the point cloud colors and visualizer zoom are weird", "\n", "", "points", "=", "np", ".", "fromfile", "(", "self", ".", "pointcloud_path", "/", "(", "\"%06d.bin\"", "%", "0", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "points", "=", "(", "points", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "points", "=", "cam_to_velo_frame", "(", "points", ".", "T", ")", ".", "T", "\n", "self", ".", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", ")", "\n", "\n", "self", ".", "vis", ".", "add_geometry", "(", "self", ".", "pcd", ")", "\n", "if", "show_ax", ":", "\n", "            ", "self", ".", "vis", ".", "add_geometry", "(", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_coordinate_frame", "(", ")", ")", "\n", "", "self", ".", "prev_bboxes", "=", "[", "]", "\n", "self", ".", "fps", "=", "fps", "\n", "if", "n_skip", "<", "1", ":", "\n", "            ", "n_skip", "=", "1", "\n", "", "self", ".", "n_skip", "=", "n_skip", "\n", "\n", "# Adjust render options", "\n", "render_option", ":", "o3d", ".", "visualization", ".", "RenderOption", "=", "self", ".", "vis", ".", "get_render_option", "(", ")", "\n", "# render_option.background_color = [0.005, 0.005, 0.005]", "\n", "# render_option.background_color = [0.95, 0.95, 0.95]", "\n", "render_option", ".", "background_color", "=", "[", "0.1", ",", "0.1", ",", "0.1", "]", "\n", "# render_option.point_size = 3.0", "\n", "# render_option.point_size = 0.05", "\n", "render_option", ".", "point_size", "=", "1.5", "\n", "\n", "# Set viewpoint to camera position", "\n", "vc", "=", "self", ".", "vis", ".", "get_view_control", "(", ")", "\n", "vc", ".", "set_up", "(", "np", ".", "array", "(", "[", "0", ",", "-", "1", ",", "1", "]", ")", ")", "\n", "vc", ".", "set_front", "(", "np", ".", "array", "(", "[", "0", ",", "-", "0.5", ",", "-", "1", "]", ")", ")", "\n", "vc", ".", "set_lookat", "(", "[", "0", ",", "0", ",", "5", "]", ")", "\n", "vc", ".", "set_zoom", "(", "0.1", ")", "\n", "\n", "# For making scatter plot of bounding box ranges", "\n", "self", ".", "box_ranges", "=", "[", "]", "\n", "self", ".", "box_time_steps", "=", "[", "]", "\n", "self", ".", "single_frame", "=", "frame", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.visualize_all": [[81, 106], ["time.time", "visualization.TrackingVisualizer.visualize_frame", "visualization.TrackingVisualizer.vis.run", "time.time", "visualization.TrackingVisualizer.update_vis", "print", "visualization.TrackingVisualizer.visualize_frame"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.visualize_frame", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.run", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.update_vis", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.visualize_frame"], ["", "def", "visualize_all", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "single_frame", ":", "\n", "            ", "self", ".", "visualize_frame", "(", "self", ".", "single_frame", ")", "\n", "self", ".", "vis", ".", "run", "(", ")", "\n", "\n", "", "t_prev_frame", "=", "time", ".", "time", "(", ")", "\n", "if", "self", ".", "tracking_results", ":", "\n", "            ", "n_frames", "=", "self", ".", "tracking_results", ".", "n_frames", "\n", "", "elif", "self", ".", "ground_truth", ":", "\n", "            ", "n_frames", "=", "self", ".", "ground_truth", ".", "n_frames", "\n", "", "elif", "self", ".", "detections", ":", "\n", "            ", "n_frames", "=", "self", ".", "detections", ".", "n_frames", "\n", "", "frame", "=", "0", "\n", "\n", "while", "True", ":", "\n", "            ", "t", "=", "time", ".", "time", "(", ")", "\n", "if", "t", "-", "t_prev_frame", ">=", "(", "1.0", "/", "self", ".", "fps", ")", ":", "\n", "# print(\"\\r[Frame %d]\" % (frame), end='')", "\n", "                ", "print", "(", "\"[Frame %d]\"", "%", "(", "frame", ")", ")", "\n", "self", ".", "visualize_frame", "(", "frame", ")", "\n", "frame", "+=", "self", ".", "n_skip", "\n", "if", "frame", ">=", "n_frames", ":", "\n", "                    ", "break", "\n", "", "t_prev_frame", "=", "t", "\n", "", "self", ".", "update_vis", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.visualize_frame": [[108, 170], ["numpy.fromfile", "numpy.fromfile", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "visualization.TrackingVisualizer.vis.update_geometry", "numpy.asarray.reshape", "visualization.cam_to_velo_frame", "numpy.ones", "numpy.ones", "bbox.to_o3d", "visualization.TrackingVisualizer.vis.run", "open3d.geometry.Image", "open3d.geometry.Image", "visualization.TrackingVisualizer.image_vis.clear_geometries", "visualization.TrackingVisualizer.image_vis.add_geometry", "visualization.TrackingVisualizer.image_vis.poll_events", "visualization.TrackingVisualizer.vis.remove_geometry", "prev_bbox.remove_line", "visualization.TrackingVisualizer.vis.add_geometry", "numpy.asarray", "numpy.asarray", "visualization.LineMesh", "visualization.LineMesh.add_line", "line_meshes.append", "bbox.get_box_points"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.cam_to_velo_frame", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.run", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.remove_line", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.add_line"], ["", "", "def", "visualize_frame", "(", "self", ",", "frame", ",", "block", "=", "False", ")", ":", "\n", "        ", "use_line_mesh", "=", "True", "\n", "# Load points as a numpy array", "\n", "points", "=", "np", ".", "fromfile", "(", "self", ".", "pointcloud_path", "/", "(", "\"%06d.bin\"", "%", "frame", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "self", ".", "show_images", ":", "\n", "            ", "try", ":", "\n", "                ", "image", "=", "self", ".", "images", "[", "frame", "]", "\n", "img_o3d", "=", "o3d", ".", "geometry", ".", "Image", "(", "image", ")", "\n", "self", ".", "image_vis", ".", "clear_geometries", "(", ")", "\n", "self", ".", "image_vis", ".", "add_geometry", "(", "img_o3d", ")", "\n", "self", ".", "image_vis", ".", "poll_events", "(", ")", "\n", "", "except", ":", "\n", "                ", "pass", "\n", "", "", "points", "=", "(", "points", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "points", "=", "cam_to_velo_frame", "(", "points", ".", "T", ")", ".", "T", "\n", "self", ".", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", ")", "\n", "colors", "=", "np", ".", "ones", "(", "points", ".", "shape", ")", "*", "0.5", "\n", "\n", "bboxes", "=", "[", "]", "\n", "if", "self", ".", "tracking_results", "is", "not", "None", ":", "\n", "            ", "bboxes", "+=", "self", ".", "tracking_results", "[", "frame", "]", "\n", "", "if", "self", ".", "ground_truth", "is", "not", "None", ":", "\n", "            ", "bboxes", "+=", "self", ".", "ground_truth", "[", "frame", "]", "\n", "", "if", "self", ".", "detections", "is", "not", "None", ":", "\n", "            ", "bboxes", "+=", "self", ".", "detections", "[", "frame", "]", "\n", "\n", "", "bboxes_o3d", "=", "[", "bbox", ".", "to_o3d", "(", ")", "for", "bbox", "in", "bboxes", "]", "\n", "\n", "for", "prev_bbox", "in", "self", ".", "prev_bboxes", ":", "\n", "            ", "if", "not", "use_line_mesh", ":", "\n", "                ", "self", ".", "vis", ".", "remove_geometry", "(", "prev_bbox", ",", "reset_bounding_box", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "prev_bbox", ".", "remove_line", "(", "self", ".", "vis", ")", "\n", "", "", "bbox", ":", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", "\n", "line_meshes", "=", "[", "]", "\n", "for", "bbox", "in", "bboxes_o3d", ":", "\n", "            ", "if", "not", "use_line_mesh", ":", "\n", "                ", "self", ".", "vis", ".", "add_geometry", "(", "bbox", ",", "reset_bounding_box", "=", "False", ")", "\n", "# in_box = bbox.get_point_indices_within_bounding_box(self.pcd.points)", "\n", "# colors[in_box,:] = bbox.color", "\n", "", "else", ":", "\n", "                ", "points", "=", "np", ".", "asarray", "(", "bbox", ".", "get_box_points", "(", ")", ")", "\n", "color", "=", "bbox", ".", "color", "\n", "# l = [[0,1],[0,2],[0,3],[3,6],[1,6],[3,5],[2,5],[4,5],[4,6],[1,7],[2,7],[4,7]]", "\n", "l", "=", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "0", ",", "3", "]", ",", "[", "1", ",", "7", "]", ",", "[", "1", ",", "6", "]", ",", "[", "3", ",", "6", "]", ",", "[", "3", ",", "5", "]", ",", "[", "2", ",", "5", "]", ",", "[", "4", ",", "5", "]", ",", "[", "4", ",", "7", "]", ",", "[", "2", ",", "7", "]", ",", "[", "4", ",", "6", "]", "]", "\n", "lines", "=", "LineMesh", "(", "points", ",", "colors", "=", "color", ",", "lines", "=", "l", ",", "radius", "=", "0.03", ")", "\n", "lines", ".", "add_line", "(", "self", ".", "vis", ")", "\n", "line_meshes", ".", "append", "(", "lines", ")", "\n", "", "", "if", "not", "use_line_mesh", ":", "\n", "            ", "self", ".", "prev_bboxes", "=", "bboxes_o3d", "\n", "", "else", ":", "\n", "            ", "self", ".", "prev_bboxes", "=", "line_meshes", "\n", "\n", "", "if", "self", ".", "detections", "is", "not", "None", ":", "\n", "            ", "self", ".", "box_ranges", "+=", "[", "bbox", ".", "range", "for", "bbox", "in", "self", ".", "detections", "[", "frame", "]", "]", "\n", "self", ".", "box_time_steps", "+=", "[", "frame", "for", "_", "in", "self", ".", "detections", "[", "frame", "]", "]", "\n", "\n", "# self.pcd.colors = o3d.utility.Vector3dVector(colors)", "\n", "\n", "", "self", ".", "vis", ".", "update_geometry", "(", "self", ".", "pcd", ")", "\n", "if", "block", ":", "\n", "            ", "self", ".", "vis", ".", "run", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.plot_ranges": [[171, 178], ["matplotlib.plot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.show", "matplotlib.show", "len"], "methods", ["None"], ["", "", "def", "plot_ranges", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "box_ranges", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "plt", ".", "plot", "(", "self", ".", "box_time_steps", ",", "self", ".", "box_ranges", ",", "'.'", ")", "\n", "plt", ".", "xlabel", "(", "\"Time step\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Bounding box range\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.update_vis": [[180, 183], ["visualization.TrackingVisualizer.vis.poll_events", "visualization.TrackingVisualizer.vis.update_renderer"], "methods", ["None"], ["", "def", "update_vis", "(", "self", ")", ":", "\n", "        ", "self", ".", "vis", ".", "poll_events", "(", ")", "\n", "self", ".", "vis", ".", "update_renderer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.close": [[184, 186], ["visualization.TrackingVisualizer.vis.close"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "vis", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.__init__": [[226, 245], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "visualization.LineMesh.create_line_mesh", "numpy.array", "numpy.array", "visualization.LineMesh.lines_from_ordered_points"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.create_line_mesh", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.lines_from_ordered_points"], ["    ", "def", "__init__", "(", "self", ",", "points", ",", "lines", "=", "None", ",", "colors", "=", "[", "0", ",", "1", ",", "0", "]", ",", "radius", "=", "0.15", ")", ":", "\n", "        ", "\"\"\"Creates a line represented as sequence of cylinder triangular meshes\n\n        Arguments:\n            points {ndarray} -- Numpy array of ponts Nx3.\n\n        Keyword Arguments:\n            lines {list[list] or None} -- List of point index pairs denoting line segments. If None, implicit lines from ordered pairwise points. (default: {None})\n            colors {list} -- list of colors, or single color of the line (default: {[0, 1, 0]})\n            radius {float} -- radius of cylinder (default: {0.15})\n        \"\"\"", "\n", "self", ".", "points", "=", "np", ".", "array", "(", "points", ")", "\n", "self", ".", "lines", "=", "np", ".", "array", "(", "\n", "lines", ")", "if", "lines", "is", "not", "None", "else", "self", ".", "lines_from_ordered_points", "(", "self", ".", "points", ")", "\n", "self", ".", "colors", "=", "np", ".", "array", "(", "colors", ")", "\n", "self", ".", "radius", "=", "radius", "\n", "self", ".", "cylinder_segments", "=", "[", "]", "\n", "\n", "self", ".", "create_line_mesh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.create_from_bounding_box": [[246, 253], ["numpy.asarray", "numpy.asarray", "visualization.LineMesh", "bbox.get_box_points"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "create_from_bounding_box", "(", "bbox", ")", ":", "\n", "        ", "points", "=", "np", ".", "asarray", "(", "bbox", ".", "get_box_points", "(", ")", ")", "\n", "color", "=", "bbox", ".", "color", "\n", "# l = [[0,1],[0,2],[0,3],[3,6],[1,6],[3,5],[2,5],[4,5],[4,6],[1,7],[2,7],[4,7]]", "\n", "l", "=", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "0", ",", "3", "]", ",", "[", "1", ",", "7", "]", ",", "[", "1", ",", "6", "]", ",", "[", "3", ",", "6", "]", ",", "[", "3", ",", "5", "]", ",", "[", "2", ",", "5", "]", ",", "[", "4", ",", "5", "]", ",", "[", "4", ",", "7", "]", ",", "[", "2", ",", "7", "]", ",", "[", "4", ",", "6", "]", "]", "\n", "return", "LineMesh", "(", "points", ",", "colors", "=", "color", ",", "lines", "=", "l", ",", "radius", "=", "0.03", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.lines_from_ordered_points": [[254, 258], ["numpy.array", "numpy.array", "range"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "@", "staticmethod", "\n", "def", "lines_from_ordered_points", "(", "points", ")", ":", "\n", "        ", "lines", "=", "[", "[", "i", ",", "i", "+", "1", "]", "for", "i", "in", "range", "(", "0", ",", "points", ".", "shape", "[", "0", "]", "-", "1", ",", "1", ")", "]", "\n", "return", "np", ".", "array", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.create_line_mesh": [[259, 290], ["visualization.normalized", "numpy.array", "numpy.array", "range", "visualization.align_vector_to_another", "open3d.geometry.TriangleMesh.create_cylinder", "open3d.geometry.TriangleMesh.create_cylinder", "cylinder_segment.rotate.rotate.translate", "cylinder_segment.rotate.rotate.paint_uniform_color", "visualization.LineMesh.cylinder_segments.append", "cylinder_segment.rotate.rotate.rotate", "open3d.geometry.get_rotation_matrix_from_axis_angle", "open3d.geometry.get_rotation_matrix_from_axis_angle", "cylinder_segment.rotate.rotate.get_center"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.normalized", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.align_vector_to_another"], ["", "def", "create_line_mesh", "(", "self", ")", ":", "\n", "        ", "first_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "0", "]", ",", ":", "]", "\n", "second_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "1", "]", ",", ":", "]", "\n", "line_segments", "=", "second_points", "-", "first_points", "\n", "line_segments_unit", ",", "line_lengths", "=", "normalized", "(", "line_segments", ")", "\n", "\n", "z_axis", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "\n", "# Create triangular mesh cylinder segments of line", "\n", "for", "i", "in", "range", "(", "line_segments_unit", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "line_segment", "=", "line_segments_unit", "[", "i", ",", ":", "]", "\n", "line_length", "=", "line_lengths", "[", "i", "]", "\n", "# get axis angle rotation to allign cylinder with line segment", "\n", "axis", ",", "angle", "=", "align_vector_to_another", "(", "z_axis", ",", "line_segment", ")", "\n", "# Get translation vector", "\n", "translation", "=", "first_points", "[", "i", ",", ":", "]", "+", "line_segment", "*", "line_length", "*", "0.5", "\n", "# create cylinder and apply transformations", "\n", "cylinder_segment", "=", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_cylinder", "(", "\n", "self", ".", "radius", ",", "line_length", ")", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "translate", "(", "\n", "translation", ",", "relative", "=", "False", ")", "\n", "if", "axis", "is", "not", "None", ":", "\n", "                ", "axis_a", "=", "axis", "*", "angle", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "rotate", "(", "\n", "R", "=", "o3d", ".", "geometry", ".", "get_rotation_matrix_from_axis_angle", "(", "axis_a", ")", ",", "center", "=", "cylinder_segment", ".", "get_center", "(", ")", ")", "\n", "# cylinder_segment = cylinder_segment.rotate(", "\n", "#   axis_a, center=True, type=o3d.geometry.RotationType.AxisAngle)", "\n", "# color cylinder", "\n", "", "color", "=", "self", ".", "colors", "if", "self", ".", "colors", ".", "ndim", "==", "1", "else", "self", ".", "colors", "[", "i", ",", ":", "]", "\n", "cylinder_segment", ".", "paint_uniform_color", "(", "color", ")", "\n", "\n", "self", ".", "cylinder_segments", ".", "append", "(", "cylinder_segment", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.add_line": [[291, 295], ["vis.add_geometry"], "methods", ["None"], ["", "", "def", "add_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Adds this line to the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "add_geometry", "(", "cylinder", ",", "reset_bounding_box", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.LineMesh.remove_line": [[296, 300], ["vis.remove_geometry"], "methods", ["None"], ["", "", "def", "remove_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Removes this line from the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "remove_geometry", "(", "cylinder", ",", "reset_bounding_box", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.cam_to_velo_frame": [[16, 19], ["numpy.array", "np.array.dot"], "function", ["None"], ["def", "cam_to_velo_frame", "(", "velo_points", ")", ":", "\n", "    ", "R", "=", "np", ".", "array", "(", "[", "[", "0", ",", "-", "1", ",", "0", "]", ",", "[", "0", ",", "0", ",", "-", "1", "]", ",", "[", "1", ",", "0", ",", "0", "]", "]", ")", "\n", "return", "R", ".", "dot", "(", "velo_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.align_vector_to_another": [[205, 216], ["numpy.array", "numpy.array", "numpy.array_equal", "numpy.cross", "numpy.arccos", "numpy.linalg.norm", "numpy.dot"], "function", ["None"], ["def", "align_vector_to_another", "(", "a", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", ",", "b", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", ":", "\n", "    ", "\"\"\"\n    Aligns vector a to vector b with axis angle rotation\n    \"\"\"", "\n", "if", "np", ".", "array_equal", "(", "a", ",", "b", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "axis_", "=", "np", ".", "cross", "(", "a", ",", "b", ")", "\n", "axis_", "=", "axis_", "/", "np", ".", "linalg", ".", "norm", "(", "axis_", ")", "\n", "angle", "=", "np", ".", "arccos", "(", "np", ".", "dot", "(", "a", ",", "b", ")", ")", "\n", "\n", "return", "axis_", ",", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.normalized": [[218, 223], ["numpy.atleast_1d", "numpy.linalg.norm", "numpy.expand_dims"], "function", ["None"], ["", "def", "normalized", "(", "a", ",", "axis", "=", "-", "1", ",", "order", "=", "2", ")", ":", "\n", "    ", "\"\"\"Normalizes a numpy array of points\"\"\"", "\n", "l2", "=", "np", ".", "atleast_1d", "(", "np", ".", "linalg", ".", "norm", "(", "a", ",", "order", ",", "axis", ")", ")", "\n", "l2", "[", "l2", "==", "0", "]", "=", "1", "\n", "return", "a", "/", "np", ".", "expand_dims", "(", "l2", ",", "axis", ")", ",", "l2", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.__init__": [[25, 37], ["str", "pathlib.Path", "os.path.exists", "pathlib.Path.mkdir"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "svo_path", ",", "output_path", ",", "verbose", "=", "False", ",", "\n", "depth_quality_map", "=", "sl", ".", "DEPTH_MODE", ".", "ULTRA", ",", "depth_quality_pointcloud", "=", "sl", ".", "DEPTH_MODE", ".", "ULTRA", ")", ":", "\n", "        ", "self", ".", "svo_path", "=", "str", "(", "svo_path", ")", "\n", "self", ".", "output_path", "=", "Path", "(", "output_path", ")", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "pose_history", "=", "[", "]", "# note - use list append, not numpy arrray append, for speed", "\n", "\n", "self", ".", "depth_quality_map", "=", "depth_quality_map", "\n", "self", ".", "depth_quality_pointcloud", "=", "depth_quality_pointcloud", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "output_path", ")", ":", "\n", "            ", "Path", ".", "mkdir", "(", "self", ".", "output_path", ",", "parents", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.default_init_params": [[41, 49], ["pyzed.InitParameters", "pyzed.InitParameters.set_from_svo_file"], "methods", ["None"], ["", "", "def", "default_init_params", "(", "self", ")", ":", "\n", "        ", "init_params", "=", "sl", ".", "InitParameters", "(", ")", "\n", "init_params", ".", "set_from_svo_file", "(", "self", ".", "svo_path", ")", "\n", "init_params", ".", "camera_resolution", "=", "sl", ".", "RESOLUTION", ".", "HD720", "# Use HD720 video mode (default fps: 60)", "\n", "init_params", ".", "coordinate_system", "=", "sl", ".", "COORDINATE_SYSTEM", ".", "RIGHT_HANDED_Z_UP_X_FWD", "# Use ROS-style coordinate system", "\n", "init_params", ".", "coordinate_units", "=", "sl", ".", "UNIT", ".", "METER", "# Set units in meters", "\n", "init_params", ".", "depth_maximum_distance", "=", "40.0", "\n", "return", "init_params", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.process_svo_map_and_pose": [[50, 137], ["svo_processing.SVOFileProcessor.default_init_params", "pyzed.Camera", "pyzed.Camera.open", "pyzed.PositionalTrackingParameters", "pyzed.Camera.enable_positional_tracking", "pyzed.SpatialMappingParameters", "pyzed.SpatialMappingParameters.get_resolution_preset", "pyzed.SpatialMappingParameters.get_range_preset", "pyzed.Camera.enable_spatial_mapping", "pyzed.Camera.get_svo_number_of_frames", "svo_processing.SVOFileProcessor.write_poses", "svo_processing.SVOFileProcessor.write_map", "pyzed.Camera.close", "print", "pyzed.Camera.get_svo_number_of_frames", "pyzed.Camera.grab", "type", "print", "pose_history.append", "print", "svo_processing.get_zed_pose"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.default_init_params", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_poses", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_map", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.close", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.get_zed_pose"], ["", "def", "process_svo_map_and_pose", "(", "self", ",", "map_file", "=", "\"map.obj\"", ",", "poses_file", "=", "\"poses.txt\"", ",", "n_frames_to_skip", "=", "1", ",", "\n", "n_frames_to_trim", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Process the ZED SVO file and write to file:\n            - A fused point cloud map\n            - The camera pose history\n\n        This function processes the SVO file with the maximum possible depth sensing quality,\n        to maximize mapping and pose estimation quality.\n\n        Parameters\n        ----------\n        map_file: str\n            Name of the map file to output. Should be .obj file format.\n        poses_file: str\n            Name of the poses file ot output. Should be .txt format.\n        n_frames_to_skip: int, default 0\n            If set to 2 or higher, the pose history output will skip frames. Use this to subsample the SVO output.\n            For example, skip_frames=2 will include every other frame in the pose file.\n            Does not affect the map creation.\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "# Initialize the ZED Camera object", "\n", "init_params", "=", "self", ".", "default_init_params", "(", ")", "\n", "init_params", ".", "depth_mode", "=", "self", ".", "depth_quality_map", "\n", "zed", "=", "sl", ".", "Camera", "(", ")", "\n", "err", "=", "zed", ".", "open", "(", "init_params", ")", "\n", "\n", "if", "err", "==", "sl", ".", "ERROR_CODE", ".", "INVALID_SVO_FILE", ":", "\n", "            ", "print", "(", "\"Error processing SVO file: '%s'\"", "%", "self", ".", "svo_path", ")", "\n", "return", "\n", "\n", "# Initialize positional tracking", "\n", "", "tracking_parameters", "=", "sl", ".", "PositionalTrackingParameters", "(", ")", "\n", "zed", ".", "enable_positional_tracking", "(", "tracking_parameters", ")", "\n", "\n", "# Initialize spatial mapping", "\n", "mapping_parameters", "=", "sl", ".", "SpatialMappingParameters", "(", ")", "\n", "mapping_parameters", ".", "map_type", "=", "sl", ".", "SPATIAL_MAP_TYPE", ".", "FUSED_POINT_CLOUD", "\n", "# mapping_parameters.resolution_meter = mapping_parameters.get_resolution_preset(sl.MAPPING_RESOLUTION.MEDIUM)", "\n", "mapping_parameters", ".", "resolution_meter", "=", "mapping_parameters", ".", "get_resolution_preset", "(", "sl", ".", "MAPPING_RESOLUTION", ".", "HIGH", ")", "\n", "\n", "# Map at short range (3.5m) to maximize quality", "\n", "# This should reduce errors like points in the sky", "\n", "# mapping_parameters.range_meter = mapping_parameters.get_range_preset(sl.MAPPING_RANGE.SHORT)", "\n", "# mapping_parameters.range_meter = mapping_parameters.get_range_preset(sl.MAPPING_RANGE.LONG)", "\n", "mapping_parameters", ".", "range_meter", "=", "mapping_parameters", ".", "get_range_preset", "(", "sl", ".", "MAPPING_RANGE", ".", "MEDIUM", ")", "\n", "zed", ".", "enable_spatial_mapping", "(", "mapping_parameters", ")", "\n", "\n", "pose_history", "=", "[", "]", "\n", "\n", "n_frames", "=", "zed", ".", "get_svo_number_of_frames", "(", ")", "\n", "\n", "assert", "type", "(", "n_frames_to_skip", ")", "==", "int", "and", "(", "1", "<=", "n_frames_to_skip", "<", "n_frames", ")", ",", "\"n_frames_to_skip parameter must be an int between 1 and number of frames in the SVO.\"", "\n", "\n", "svo_position", "=", "0", "# Keep a separate counter instead of using zed.get_svo_position() - svo position skips sometimes", "\n", "next_frame", "=", "0", "# keep track of next frame to process, for subsampling frames", "\n", "\n", "last_frame", "=", "zed", ".", "get_svo_number_of_frames", "(", ")", "-", "n_frames_to_trim", "\n", "\n", "# SVO processing loop", "\n", "exit", "=", "False", "\n", "while", "not", "exit", ":", "\n", "# With spatial mapping enabled, zed.grab() updates the map in the background", "\n", "            ", "err", "=", "zed", ".", "grab", "(", ")", "\n", "if", "err", "==", "sl", ".", "ERROR_CODE", ".", "SUCCESS", ":", "\n", "\n", "                ", "if", "svo_position", "<", "last_frame", "and", "svo_position", ">=", "next_frame", ":", "\n", "                    ", "print", "(", "\"\\r[Processing frame %d of %d]\"", "%", "(", "svo_position", ",", "n_frames", ")", ",", "end", "=", "''", ")", "\n", "pose_history", ".", "append", "(", "get_zed_pose", "(", "zed", ")", ")", "\n", "next_frame", "+=", "n_frames_to_skip", "\n", "", "svo_position", "+=", "1", "\n", "\n", "\n", "", "elif", "err", "==", "sl", ".", "ERROR_CODE", ".", "END_OF_SVOFILE_REACHED", ":", "\n", "                ", "print", "(", "\"Mapping module: Reached end of SVO file\"", ")", "\n", "exit", "=", "True", "\n", "\n", "# Write outputs", "\n", "", "", "self", ".", "write_poses", "(", "pose_history", ",", "self", ".", "output_path", "/", "poses_file", ")", "\n", "self", ".", "write_map", "(", "zed", ",", "self", ".", "output_path", "/", "map_file", ")", "\n", "zed", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.process_svo_rgb_and_pointcloud": [[138, 226], ["svo_processing.SVOFileProcessor.default_init_params", "pyzed.Camera", "pyzed.Camera.open", "pyzed.Camera.get_svo_number_of_frames", "svo_processing.SVOFileProcessor.write_calib", "pyzed.Camera.close", "print", "pyzed.Camera.get_svo_number_of_frames", "pyzed.Camera.grab", "os.path.exists", "pathlib.Path.mkdir", "type", "print", "print", "svo_processing.SVOFileProcessor.write_rgb_image", "svo_processing.SVOFileProcessor.write_sparse_point_cloud_npz", "svo_processing.SVOFileProcessor.write_point_cloud_npz"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.default_init_params", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_calib", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.visualization.TrackingVisualizer.close", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_rgb_image", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_sparse_point_cloud_npz", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_point_cloud_npz"], ["", "def", "process_svo_rgb_and_pointcloud", "(", "self", ",", "rgb_directory", "=", "\"rgb\"", ",", "pointcloud_directory", "=", "\"pointcloud\"", ",", "\n", "calib_file", "=", "\"calibration.yaml\"", ",", "n_frames_to_skip", "=", "1", ",", "n_frames_to_trim", "=", "0", ",", "\n", "sparsify", "=", "True", ",", "skip_images", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Process the ZED SVO file and write to file:\n            - Stereo point clouds, generated using performance quality\n            - RGB images\n            - Calibration information in yaml format\n\n        This function generates point clouds using performance quality, to simulate running on a resource-constrained\n        robot online.\n\n        Parameters\n        ----------\n        rgb_directory: str\n            Name of the directory to save images to. Default \"rgb\"\n        pointcloud_directory: str\n            Name of the directory to save point clouds to. Default \"pointcloud\"\n        calib_file: str\n            Name of the output calibration file, .yaml file type.\n            Default \"calibration.yaml\"\n        n_frames_to_skip: int, default 0\n            If set to 2 or higher, the image/pointcloud saving will skip frames. Use this to subsample the SVO output.\n            For example, skip_frames=2 will save the image/pointcloud from every other frame.\n        skip_images: bool\n            If True, will skip writing images (write point clouds only)\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "# Create output directories", "\n", "rgb_output_directory", "=", "self", ".", "output_path", "/", "rgb_directory", "\n", "pcd_output_directory", "=", "self", ".", "output_path", "/", "pointcloud_directory", "\n", "for", "dir", "in", "[", "rgb_output_directory", ",", "pcd_output_directory", "]", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "                ", "Path", ".", "mkdir", "(", "dir", ",", "parents", "=", "True", ")", "\n", "\n", "# Initialize the ZED Camera object", "\n", "", "", "init_params", "=", "self", ".", "default_init_params", "(", ")", "\n", "init_params", ".", "depth_mode", "=", "self", ".", "depth_quality_pointcloud", "\n", "zed", "=", "sl", ".", "Camera", "(", ")", "\n", "err", "=", "zed", ".", "open", "(", "init_params", ")", "\n", "\n", "if", "err", "==", "sl", ".", "ERROR_CODE", ".", "INVALID_SVO_FILE", ":", "\n", "            ", "print", "(", "\"Error processing SVO file: '%s'\"", "%", "self", ".", "svo_path", ")", "\n", "return", "\n", "\n", "", "n_frames", "=", "zed", ".", "get_svo_number_of_frames", "(", ")", "\n", "\n", "\n", "assert", "type", "(", "n_frames_to_skip", ")", "==", "int", "and", "(", "1", "<=", "n_frames_to_skip", "<", "n_frames", ")", ",", "\"n_frames_to_skip parameter must be an int between 1 and number of frames in the SVO.\"", "\n", "svo_position", "=", "0", "# Keep a separate counter instead of using zed.get_svo_position() - svo position skips sometimes", "\n", "image_counter", "=", "0", "# Tracks how many images have been written", "\n", "next_frame", "=", "0", "# keep track of next frame to process, for subsampling frames", "\n", "\n", "last_frame", "=", "zed", ".", "get_svo_number_of_frames", "(", ")", "-", "n_frames_to_trim", "\n", "\n", "# SVO processing loop", "\n", "exit", "=", "False", "\n", "while", "not", "exit", ":", "\n", "            ", "err", "=", "zed", ".", "grab", "(", ")", "\n", "if", "err", "==", "sl", ".", "ERROR_CODE", ".", "SUCCESS", ":", "\n", "\n", "                ", "if", "svo_position", "<", "last_frame", "and", "svo_position", ">=", "next_frame", ":", "\n", "                    ", "print", "(", "\"\\r[Processing frame %d of %d]\"", "%", "(", "svo_position", ",", "n_frames", ")", ",", "end", "=", "''", ")", "\n", "if", "not", "skip_images", ":", "\n", "                        ", "self", ".", "write_rgb_image", "(", "zed", ",", "rgb_directory", "=", "rgb_output_directory", ",", "image_index", "=", "image_counter", ")", "\n", "", "if", "sparsify", ":", "\n", "                        ", "self", ".", "write_sparse_point_cloud_npz", "(", "zed", ",", "pcd_output_directory", ",", "image_index", "=", "image_counter", ",", "\n", "lines", "=", "128", ",", "max_range", "=", "15", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "write_point_cloud_npz", "(", "zed", ",", "pcd_output_directory", ",", "image_index", "=", "image_counter", ")", "\n", "# self.write_point_cloud_binary(zed, pcd_output_directory, image_index=svo_position)", "\n", "", "image_counter", "+=", "1", "\n", "next_frame", "+=", "n_frames_to_skip", "\n", "", "svo_position", "+=", "1", "\n", "\n", "\n", "", "elif", "err", "==", "sl", ".", "ERROR_CODE", ".", "END_OF_SVOFILE_REACHED", ":", "\n", "                ", "print", "(", "\"Pointcloud saver: Reached end of SVO file\"", ")", "\n", "exit", "=", "True", "\n", "\n", "# Write calibration file", "\n", "", "", "self", ".", "write_calib", "(", "zed", ",", "self", ".", "output_path", "/", "calib_file", ")", "\n", "zed", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_rgb_image": [[227, 233], ["pyzed.Mat", "zed.retrieve_image", "pyzed.Mat.write", "str", "pathlib.Path"], "methods", ["None"], ["", "def", "write_rgb_image", "(", "self", ",", "zed", ",", "rgb_directory", ",", "image_index", ")", ":", "\n", "        ", "rgb_image", "=", "sl", ".", "Mat", "(", ")", "\n", "zed", ".", "retrieve_image", "(", "rgb_image", ",", "sl", ".", "VIEW", ".", "LEFT", ")", "\n", "\n", "# Write RGB image to file", "\n", "rgb_image", ".", "write", "(", "str", "(", "Path", "(", "rgb_directory", ")", "/", "(", "\"%d.jpeg\"", "%", "image_index", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_depth_image": [[235, 241], ["pyzed.Mat", "zed.retrieve_measure", "numpy.save", "pyzed.Mat.get_data", "pathlib.Path"], "methods", ["None"], ["", "def", "write_depth_image", "(", "self", ",", "zed", ",", "depth_directory", ",", "image_index", ")", ":", "\n", "        ", "depth_image", "=", "sl", ".", "Mat", "(", ")", "\n", "zed", ".", "retrieve_measure", "(", "depth_image", ",", "sl", ".", "MEASURE", ".", "DEPTH", ")", "\n", "\n", "# Write depth image as numpy array to preserve float32 values (distance in meters)", "\n", "np", ".", "save", "(", "Path", "(", "depth_directory", ")", "/", "(", "\"%d.npy\"", "%", "image_index", ")", ",", "depth_image", ".", "get_data", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_point_cloud_npz": [[242, 257], ["pyzed.Mat", "zed.retrieve_measure", "pyzed.Mat.get_data().reshape", "svo_processing.zed_rgba_to_color_array", "numpy.savez_compressed", "pathlib.Path", "pyzed.Mat.get_data", "numpy.isfinite().any", "numpy.isfinite"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.zed_rgba_to_color_array"], ["", "def", "write_point_cloud_npz", "(", "self", ",", "zed", ",", "pcd_output_directory", ",", "image_index", ")", ":", "\n", "        ", "point_cloud", "=", "sl", ".", "Mat", "(", ")", "\n", "zed", ".", "retrieve_measure", "(", "point_cloud", ",", "sl", ".", "MEASURE", ".", "XYZRGBA", ")", "\n", "# get_data() gives a (720 X 1280 X 4) array", "\n", "pcd_data", "=", "point_cloud", ".", "get_data", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "# Remove NaN/inf values", "\n", "pcd_data", "=", "pcd_data", "[", "np", ".", "isfinite", "(", "pcd_data", ")", ".", "any", "(", "axis", "=", "1", ")", "]", "\n", "\n", "colors", "=", "zed_rgba_to_color_array", "(", "pcd_data", "[", ":", ",", "3", "]", ")", "\n", "\n", "points", "=", "pcd_data", "[", ":", ",", "0", ":", "3", "]", "\n", "\n", "pcd_filename", "=", "Path", "(", "pcd_output_directory", ")", "/", "(", "\"%d.npz\"", "%", "image_index", ")", "\n", "np", ".", "savez_compressed", "(", "pcd_filename", ",", "points", "=", "points", ",", "colors", "=", "colors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_sparse_point_cloud_npz": [[258, 283], ["pyzed.Mat", "zed.retrieve_measure", "pyzed.Mat.get_data", "pcd_data.reshape.reshape.reshape", "svo_processing.zed_rgba_to_color_array", "svo_processing.sparsify_points", "numpy.savez_compressed", "svo_processing.get_points_within_max_range", "pathlib.Path", "numpy.isfinite().any", "numpy.isfinite"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.zed_rgba_to_color_array", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.sparsify_points", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.get_points_within_max_range"], ["", "def", "write_sparse_point_cloud_npz", "(", "self", ",", "zed", ",", "pcd_output_directory", ",", "image_index", ",", "lines", "=", "64", ",", "max_range", "=", "0", ")", ":", "\n", "        ", "point_cloud", "=", "sl", ".", "Mat", "(", ")", "\n", "zed", ".", "retrieve_measure", "(", "point_cloud", ",", "sl", ".", "MEASURE", ".", "XYZRGBA", ")", "\n", "# get_data() gives a (720 X 1280 X 4) array", "\n", "pcd_data", "=", "point_cloud", ".", "get_data", "(", ")", "\n", "\n", "pcd_data", "=", "pcd_data", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "# Remove NaN/inf values", "\n", "pcd_data", "=", "pcd_data", "[", "np", ".", "isfinite", "(", "pcd_data", ")", ".", "any", "(", "axis", "=", "1", ")", "]", "\n", "colors_f32", "=", "pcd_data", "[", ":", ",", "3", "]", "\n", "\n", "points", "=", "pcd_data", "[", ":", ",", "0", ":", "3", "]", "\n", "\n", "# limit max range", "\n", "if", "max_range", ">", "0", ":", "\n", "            ", "below_max", "=", "get_points_within_max_range", "(", "points", ",", "max_range", ")", "\n", "points", "=", "points", "[", "below_max", ",", ":", "]", "\n", "colors_f32", "=", "colors_f32", "[", "below_max", "]", "\n", "\n", "", "colors", "=", "zed_rgba_to_color_array", "(", "colors_f32", ")", "\n", "points_sparse", ",", "colors_sparse", "=", "sparsify_points", "(", "points", ",", "colors", ",", "H", "=", "lines", ")", "\n", "\n", "pcd_filename", "=", "Path", "(", "pcd_output_directory", ")", "/", "(", "\"%d.npz\"", "%", "image_index", ")", "\n", "np", ".", "savez_compressed", "(", "pcd_filename", ",", "points", "=", "points_sparse", ",", "colors", "=", "colors_sparse", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_point_cloud_binary": [[284, 301], ["pyzed.Mat", "zed.retrieve_measure", "pyzed.Mat.get_data().reshape", "svo_processing.zed_rgba_to_color_array", "pcd_data[].astype", "pcd_data[].astype.tofile", "zed_rgba_to_color_array.tofile", "pathlib.Path", "pathlib.Path", "pyzed.Mat.get_data", "numpy.isfinite().any", "numpy.isfinite"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.zed_rgba_to_color_array"], ["", "def", "write_point_cloud_binary", "(", "self", ",", "zed", ",", "pcd_output_directory", ",", "image_index", ")", ":", "\n", "        ", "point_cloud", "=", "sl", ".", "Mat", "(", ")", "\n", "zed", ".", "retrieve_measure", "(", "point_cloud", ",", "sl", ".", "MEASURE", ".", "XYZRGBA", ")", "\n", "# get_data() gives a (720 X 1280 X 4) array", "\n", "pcd_data", "=", "point_cloud", ".", "get_data", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "# Remove NaN/inf values", "\n", "pcd_data", "=", "pcd_data", "[", "np", ".", "isfinite", "(", "pcd_data", ")", ".", "any", "(", "axis", "=", "1", ")", "]", "\n", "\n", "colors", "=", "zed_rgba_to_color_array", "(", "pcd_data", "[", ":", ",", "3", "]", ")", "\n", "\n", "points", "=", "pcd_data", "[", ":", ",", "0", ":", "3", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "points_filename", "=", "Path", "(", "pcd_output_directory", ")", "/", "(", "\"%d.bin\"", "%", "image_index", ")", "\n", "colors_filename", "=", "Path", "(", "pcd_output_directory", ")", "/", "(", "\"%d_colors.bin\"", "%", "image_index", ")", "\n", "points", ".", "tofile", "(", "points_filename", ")", "\n", "colors", ".", "tofile", "(", "colors_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_poses": [[302, 315], ["str", "print", "numpy.array", "open", "numpy.savetxt"], "methods", ["None"], ["", "def", "write_poses", "(", "self", ",", "pose_history", ",", "pose_output_path", "=", "'poses.txt'", ",", "replace_last_row", "=", "True", ")", ":", "\n", "        ", "pose_output_path", "=", "str", "(", "pose_output_path", ")", "\n", "print", "(", "\"Writing pose history to '%s'\"", "%", "pose_output_path", ")", "\n", "output_array", "=", "np", ".", "array", "(", "pose_history", ")", "\n", "\n", "if", "replace_last_row", ":", "\n", "# H264 compressed .svo files can give NaNs or wrong values in the last row of the pose history", "\n", "# Replace last row of pose history with second-to-last row (except for time stamp)", "\n", "            ", "last", "=", "output_array", ".", "shape", "[", "0", "]", "-", "1", "\n", "output_array", "[", "last", ",", "1", ":", "]", "=", "output_array", "[", "last", "-", "1", ",", "1", ":", "]", "# do not copy the timestamp (column 0)", "\n", "\n", "", "with", "open", "(", "pose_output_path", ",", "'w'", ")", "as", "output_file", ":", "\n", "            ", "np", ".", "savetxt", "(", "output_file", ",", "output_array", ",", "fmt", "=", "'%f'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_map": [[316, 324], ["str", "print", "pyzed.FusedPointCloud", "zed.extract_whole_spatial_map", "pyzed.FusedPointCloud.save", "str", "print"], "methods", ["None"], ["", "", "def", "write_map", "(", "self", ",", "zed", ",", "map_output_path", "=", "\"map.obj\"", ")", ":", "\n", "        ", "map_output_path", "=", "str", "(", "map_output_path", ")", "\n", "print", "(", "\"Writing full spatial map to '%s'\"", "%", "map_output_path", ")", "\n", "pointcloud", "=", "sl", ".", "FusedPointCloud", "(", ")", "\n", "zed", ".", "extract_whole_spatial_map", "(", "pointcloud", ")", "\n", "err", "=", "pointcloud", ".", "save", "(", "str", "(", "map_output_path", ")", ",", "typeMesh", "=", "sl", ".", "MESH_FILE_FORMAT", ".", "PLY", ")", "\n", "if", "not", "err", ":", "\n", "            ", "print", "(", "\"Error while saving ZED point cloud!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.SVOFileProcessor.write_calib": [[325, 339], ["str", "zed.get_camera_information", "open", "yaml.dump"], "methods", ["None"], ["", "", "def", "write_calib", "(", "self", ",", "zed", ",", "calib_file_path", "=", "\"calib.yaml\"", ")", ":", "\n", "        ", "calib_file_path", "=", "str", "(", "calib_file_path", ")", "\n", "calib", "=", "zed", ".", "get_camera_information", "(", ")", ".", "calibration_parameters", "\n", "fx", "=", "calib", ".", "left_cam", ".", "fx", "\n", "fy", "=", "calib", ".", "left_cam", ".", "fy", "\n", "cx", "=", "calib", ".", "left_cam", ".", "cx", "\n", "cy", "=", "calib", ".", "left_cam", ".", "cy", "\n", "w", "=", "calib", ".", "left_cam", ".", "image_size", ".", "width", "\n", "h", "=", "calib", ".", "left_cam", ".", "image_size", ".", "height", "\n", "yaml_dict", "=", "{", "'fx'", ":", "fx", ",", "'fy'", ":", "fy", ",", "\n", "'cx'", ":", "cx", ",", "'cy'", ":", "cy", ",", "\n", "'image_width'", ":", "w", ",", "'image_height'", ":", "h", "}", "\n", "with", "open", "(", "calib_file_path", ",", "'w'", ")", "as", "yaml_file", ":", "\n", "            ", "yaml", ".", "dump", "(", "yaml_dict", ",", "yaml_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.get_zed_pose": [[340, 382], ["pyzed.Pose", "zed.get_position", "pyzed.Translation", "round", "round", "round", "sl.Pose.timestamp.get_nanoseconds", "pyzed.Orientation", "round", "round", "round", "round", "float", "print", "print", "sl.Pose.get_translation().get", "sl.Pose.get_translation().get", "sl.Pose.get_translation().get", "sl.Pose.get_orientation().get", "sl.Pose.get_orientation().get", "sl.Pose.get_orientation().get", "sl.Pose.get_orientation().get", "sl.Pose.get_translation", "sl.Pose.get_translation", "sl.Pose.get_translation", "sl.Pose.get_orientation", "sl.Pose.get_orientation", "sl.Pose.get_orientation", "sl.Pose.get_orientation"], "function", ["None"], ["", "", "", "def", "get_zed_pose", "(", "zed", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n\n    Parameters\n    ----------\n    zed: sl.Camera\n        The ZED camera object\n    verbose: bool\n        If true, will print the translation + orientation to the console\n\n    Returns\n    -------\n    list\n        Pose as [time, tx, ty, tz, ox, oy, oz, ow]\n        time is given in seconds.\n        The camera position is [tx, ty, tz]\n        And orientation is the quaternion [ox, oy, oz, ow]\n\n    \"\"\"", "\n", "# Call zed.grab() each time before calling this function", "\n", "zed_pose", "=", "sl", ".", "Pose", "(", ")", "\n", "\n", "# Get the pose of the camera relative to the world frame", "\n", "state", "=", "zed", ".", "get_position", "(", "zed_pose", ",", "sl", ".", "REFERENCE_FRAME", ".", "WORLD", ")", "\n", "# Display translation and timestamp", "\n", "py_translation", "=", "sl", ".", "Translation", "(", ")", "\n", "tx", "=", "round", "(", "zed_pose", ".", "get_translation", "(", "py_translation", ")", ".", "get", "(", ")", "[", "0", "]", ",", "3", ")", "\n", "ty", "=", "round", "(", "zed_pose", ".", "get_translation", "(", "py_translation", ")", ".", "get", "(", ")", "[", "1", "]", ",", "3", ")", "\n", "tz", "=", "round", "(", "zed_pose", ".", "get_translation", "(", "py_translation", ")", ".", "get", "(", ")", "[", "2", "]", ",", "3", ")", "\n", "time_nsec", "=", "zed_pose", ".", "timestamp", ".", "get_nanoseconds", "(", ")", "\n", "time_sec", "=", "float", "(", "time_nsec", ")", "/", "1e9", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Translation: tx: {0}, ty:  {1}, tz:  {2}, timestamp: {3}\"", ".", "format", "(", "tx", ",", "ty", ",", "tz", ",", "time_sec", ")", ")", "\n", "# Display orientation quaternion", "\n", "", "py_orientation", "=", "sl", ".", "Orientation", "(", ")", "\n", "ox", "=", "round", "(", "zed_pose", ".", "get_orientation", "(", "py_orientation", ")", ".", "get", "(", ")", "[", "0", "]", ",", "3", ")", "\n", "oy", "=", "round", "(", "zed_pose", ".", "get_orientation", "(", "py_orientation", ")", ".", "get", "(", ")", "[", "1", "]", ",", "3", ")", "\n", "oz", "=", "round", "(", "zed_pose", ".", "get_orientation", "(", "py_orientation", ")", ".", "get", "(", ")", "[", "2", "]", ",", "3", ")", "\n", "ow", "=", "round", "(", "zed_pose", ".", "get_orientation", "(", "py_orientation", ")", ".", "get", "(", ")", "[", "3", "]", ",", "3", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Orientation: ox: {0}, oy:  {1}, oz: {2}, ow: {3}\\n\"", ".", "format", "(", "ox", ",", "oy", ",", "oz", ",", "ow", ")", ")", "\n", "", "return", "[", "time_sec", ",", "tx", ",", "ty", ",", "tz", ",", "ox", ",", "oy", ",", "oz", ",", "ow", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.zed_rgba_to_color_array": [[383, 411], ["list", "numpy.zeros", "enumerate", "int", "int", "int", "bin", "len", "struct.unpack", "struct.pack"], "function", ["None"], ["", "def", "zed_rgba_to_color_array", "(", "rgba_values", ")", ":", "\n", "    ", "\"\"\"\n    Convert RGBA float32 values to an N by 3 array of RGB color values\n\n    :param rgba_values: ndarray\n    :return: ndarray\n    \"\"\"", "\n", "rgba_values", "=", "list", "(", "rgba_values", ")", "\n", "# Convert float32 RGBA values to unsigned int, then to binary", "\n", "# uint_values = [unpack('I', pack('f', rgba))[0] for rgba in rgba_values]", "\n", "# Convert uint values to binary", "\n", "# binary_values = [bin(ui)[2:] for ui in uint_values]", "\n", "binary_values", "=", "[", "bin", "(", "unpack", "(", "'I'", ",", "pack", "(", "'f'", ",", "rgba", ")", ")", "[", "0", "]", ")", "[", "2", ":", "]", "for", "rgba", "in", "rgba_values", "]", "\n", "\n", "# Separate out 32-bit binary representation into 4 separate 8-bit values for R,G,B,A", "\n", "# alpha = [int(b[0:8], 2) for b in binary_values]", "\n", "# blue = [int(b[8:16], 2) for b in binary_values]", "\n", "# green = [int(b[16:24], 2) for b in binary_values]", "\n", "# red = [int(b[24:], 2) for b in binary_values]", "\n", "\n", "# color_array = np.array([red, green, blue], dtype=np.uint8).T", "\n", "\n", "color_array", "=", "np", ".", "zeros", "(", "(", "len", "(", "binary_values", ")", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "binary_values", ")", ":", "\n", "        ", "color_array", "[", "i", ",", "2", "]", "=", "int", "(", "b", "[", "8", ":", "16", "]", ",", "2", ")", "\n", "color_array", "[", "i", ",", "1", "]", "=", "int", "(", "b", "[", "16", ":", "24", "]", ",", "2", ")", "\n", "color_array", "[", "i", ",", "0", "]", "=", "int", "(", "b", "[", "24", ":", "]", ",", "2", ")", "\n", "", "return", "color_array", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.sparsify_points": [[412, 463], ["numpy.radians", "numpy.sqrt", "numpy.sqrt", "numpy.arcsin", "depth_map.reshape.reshape", "colors_sparse.reshape.reshape", "numpy.radians", "numpy.radians", "numpy.arcsin", "numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "sparsify_points", "(", "points", ",", "colors", ",", "H", "=", "64", ",", "W", "=", "512", ",", "slice", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Adapted from KITTI sparsification code written by Yan Wang\n\n    :param H: the row num of depth map, could be 64(default), 32, 16\n    :param W: the col num of depth map\n    :param slice: output every slice lines\n    :param max_range: depth points above this value will be removed. set to 0 to disable\n    \"\"\"", "\n", "# fov = np.deg2rad(70)  # ZED 2 field of view, vertically", "\n", "fov_deg", "=", "70", "\n", "\n", "dtheta", "=", "np", ".", "radians", "(", "fov_deg", ")", "/", "H", "\n", "dphi", "=", "np", ".", "radians", "(", "90.0", "/", "W", ")", "\n", "\n", "x", ",", "y", ",", "z", "=", "points", "[", ":", ",", "0", "]", ",", "points", "[", ":", ",", "1", "]", ",", "points", "[", ":", ",", "2", "]", "\n", "\n", "d", "=", "np", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", "+", "z", "**", "2", ")", "\n", "r", "=", "np", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", ")", "\n", "\n", "d", "[", "d", "==", "0", "]", "=", "0.000001", "\n", "r", "[", "r", "==", "0", "]", "=", "0.000001", "\n", "phi", "=", "np", ".", "radians", "(", "45.", ")", "-", "np", ".", "arcsin", "(", "y", "/", "r", ")", "\n", "phi_", "=", "(", "phi", "/", "dphi", ")", ".", "astype", "(", "int", ")", "\n", "phi_", "[", "phi_", "<", "0", "]", "=", "0", "\n", "phi_", "[", "phi_", ">=", "W", "]", "=", "W", "-", "1", "\n", "\n", "# theta = np.radians(2.) - np.arcsin(z / d)", "\n", "theta", "=", "np", ".", "arcsin", "(", "z", "/", "d", ")", "\n", "theta_", "=", "(", "theta", "/", "dtheta", "+", "H", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "theta_", "[", "theta_", "<", "0", "]", "=", "0", "\n", "theta_", "[", "theta_", ">=", "H", "]", "=", "H", "-", "1", "\n", "\n", "depth_map", "=", "-", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "3", ")", ")", "\n", "depth_map", "[", "theta_", ",", "phi_", ",", "0", "]", "=", "x", "\n", "depth_map", "[", "theta_", ",", "phi_", ",", "1", "]", "=", "y", "\n", "depth_map", "[", "theta_", ",", "phi_", ",", "2", "]", "=", "z", "\n", "depth_map", "=", "depth_map", "[", "0", ":", ":", "slice", ",", ":", ",", ":", "]", "\n", "depth_map", "=", "depth_map", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "depth_map", "=", "depth_map", "[", "depth_map", "[", ":", ",", "0", "]", "!=", "-", "1.0", "]", "\n", "\n", "colors_sparse", "=", "-", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "3", ")", ")", "\n", "r", ",", "g", ",", "b", "=", "colors", "[", ":", ",", "0", "]", ",", "colors", "[", ":", ",", "1", "]", ",", "colors", "[", ":", ",", "2", "]", "\n", "colors_sparse", "[", "theta_", ",", "phi_", ",", "0", "]", "=", "r", "\n", "colors_sparse", "[", "theta_", ",", "phi_", ",", "1", "]", "=", "g", "\n", "colors_sparse", "[", "theta_", ",", "phi_", ",", "2", "]", "=", "b", "\n", "colors_sparse", "=", "colors_sparse", "[", "0", ":", ":", "slice", ",", ":", ",", ":", "]", "\n", "colors_sparse", "=", "colors_sparse", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "colors_sparse", "=", "colors_sparse", "[", "colors_sparse", "[", ":", ",", "0", "]", "!=", "-", "1.0", "]", "\n", "\n", "return", "depth_map", ",", "colors_sparse", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.zed_svo_processing.svo_processing.get_points_within_max_range": [[464, 468], ["numpy.sqrt"], "function", ["None"], ["", "def", "get_points_within_max_range", "(", "points", ",", "max_range", ")", ":", "\n", "    ", "x", ",", "y", "=", "points", "[", ":", ",", "0", "]", ",", "points", "[", ":", ",", "1", "]", "\n", "r", "=", "np", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", ")", "\n", "return", "r", "<=", "max_range", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d._BaseParams.__init__": [[18, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# Tree clustering parameters", "\n", "        ", "self", ".", "dbscan_eps", "=", "0", "#", "\n", "self", ".", "dbscan_min", "=", "0", "\n", "self", ".", "min_cluster_size", "=", "1", "\n", "\n", "self", ".", "visibility_radius", "=", "100000", "# used in spherical projection for open3d hidden point removal function.", "\n", "# A large value, e.g. 100k or 1million, seems to work well", "\n", "\n", "self", ".", "plot", "=", "False", "\n", "self", ".", "verbose", "=", "False", "\n", "self", ".", "_scale_factor", "=", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d._BaseParams.scale_factor": [[35, 39], ["type"], "methods", ["None"], ["", "@", "scale_factor", ".", "setter", "\n", "def", "scale_factor", "(", "self", ",", "s", ")", ":", "\n", "        ", "assert", "type", "(", "s", ")", "==", "float", "and", "s", ">", "0", ",", "\"Scale factor must be a float value greater than zero.\"", "\n", "self", ".", "_scale_factor", "=", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.__init__": [[45, 85], ["pathlib.Path", "bbox3d.PointCloudDataset.load_global_point_cloud", "os.listdir", "bbox3d.PointCloudDataset.time_steps.sort", "print", "bbox3d._BaseParams", "pathlib.Path", "os.path.exists", "print", "pathlib.Path().mkdir", "filename.startswith", "type", "str", "pathlib.Path", "filename.split", "s.split", "bbox3d.PointCloudDataset.time_steps.append", "int", "print"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.load_global_point_cloud"], ["def", "__init__", "(", "self", ",", "data_path", ",", "annotations_directory", "=", "\"label_2\"", ",", "params", "=", "None", ")", ":", "\n", "# Root path for the data, e.g. data/airsim_data/forest_1", "\n", "        ", "self", ".", "data_path", "=", "Path", "(", "data_path", ")", "\n", "\n", "if", "params", "is", "None", "or", "type", "(", "params", ")", "!=", "self", ".", "params_type", ":", "\n", "            ", "print", "(", "\"[INFO] Using default parameters\"", ")", "\n", "self", ".", "params", "=", "_BaseParams", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "params", "=", "params", "\n", "\n", "# Load in the global point cloud - contains points for the whole forest world, in global frame coordinates", "\n", "", "pcd", "=", "self", ".", "load_global_point_cloud", "(", ")", "\n", "\n", "# Create folder for annotations if it doesn't exist", "\n", "self", ".", "annotations_path", "=", "self", ".", "data_path", "/", "\"kitti_object\"", "/", "Path", "(", "annotations_directory", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "annotations_path", ")", ":", "\n", "            ", "print", "(", "\"[INFO] Creating annotations directory at '%s'...\"", "%", "str", "(", "self", ".", "annotations_path", ")", ")", "\n", "Path", "(", "self", ".", "annotations_path", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "", "self", ".", "global_pointcloud", "=", "pcd", "\n", "\n", "## Set paths to other folders in the data", "\n", "\n", "# Contains individual point clouds seen by the camera at each time step. Points are in camera frame coordinates", "\n", "self", ".", "local_pointcloud_path", "=", "self", ".", "data_path", "/", "\"coords_cam\"", "\n", "# Contains camera pose at each time step", "\n", "self", ".", "pose_path", "=", "self", ".", "data_path", "/", "\"pose\"", "\n", "\n", "## Get time step indices from the filenames", "\n", "\n", "self", ".", "time_steps", "=", "[", "]", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "self", ".", "pose_path", ")", ":", "\n", "            ", "if", "filename", ".", "startswith", "(", "\"pose\"", ")", ":", "\n", "                ", "s", "=", "filename", ".", "split", "(", "'_'", ")", "[", "1", "]", "# gives e.g. '001.txt'", "\n", "s", "=", "s", ".", "split", "(", "'.'", ")", "[", "0", "]", "# gives e.g. '001'", "\n", "try", ":", "\n", "                    ", "self", ".", "time_steps", ".", "append", "(", "int", "(", "s", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "print", "(", "\"[WARNING] Found invalid filename '%s'\"", "%", "filename", ")", "\n", "", "", "", "self", ".", "time_steps", ".", "sort", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.load_global_point_cloud": [[86, 88], ["None"], "methods", ["None"], ["", "def", "load_global_point_cloud", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.load_time_step": [[89, 116], ["numpy.load", "bbox3d.AirsimCameraPose", "str", "str"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["", "def", "load_time_step", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Load the local point cloud and camera pose at a time step\n        Parameters\n        ----------\n        i: int\n            Integer time step to load\n\n        Returns\n        -------\n        local_pointcloud: numpy.ndarray\n            N by 3 array of points observed by the camera at time step i\n            Points are given in the camera frame\n        pose: AirsimCameraPose\n            Contains camera parameters, position, and orientation at time step i\n\n        \"\"\"", "\n", "# Load local point cloud", "\n", "npz", "=", "np", ".", "load", "(", "str", "(", "self", ".", "local_pointcloud_path", "/", "(", "\"coords_cam_%03d.npz\"", "%", "i", ")", ")", ")", "\n", "# coords_cam files are saved as 4 by N arrays, where row 4 is all ones.", "\n", "local_pointcloud", "=", "npz", "[", "'coords_cam'", "]", ".", "T", "\n", "local_pointcloud", "=", "local_pointcloud", "[", ":", ",", "0", ":", "3", "]", "\n", "\n", "# Load camera pose", "\n", "pose", "=", "AirsimCameraPose", "(", "str", "(", "self", ".", "pose_path", "/", "(", "\"pose_%03d.txt\"", "%", "i", ")", ")", ")", "\n", "\n", "return", "local_pointcloud", ",", "pose", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.cluster_global_pointcloud": [[118, 151], ["pcd.to_numpy", "numpy.max", "open3d.utility.Vector3dVector", "pcd.cluster_trees"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.to_numpy", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.cluster_trees"], ["", "def", "cluster_global_pointcloud", "(", "self", ",", "plot", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Cluster tree trunks in the global point cloud.\n        This is done by removing points above a set Z-height, then clustering the remaining points using DBSCAN.\n\n        Parameters\n        ----------\n        plot\n        verbose\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "pcd", "=", "self", ".", "global_pointcloud", "\n", "pts", "=", "pcd", ".", "to_numpy", "(", ")", "\n", "z_max", "=", "np", ".", "max", "(", "pts", "[", ":", ",", "2", "]", ")", "\n", "trunks_index", "=", "pts", "[", ":", ",", "2", "]", "<", "self", ".", "params", ".", "trunk_z_cutoff", "\n", "pcd", ".", "_pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", "[", "trunks_index", ",", ":", "]", ")", "\n", "\n", "# pcd.downsample(downsample_voxel_size=0.15, verbose=True)  # Airsim pcd has density 0.15", "\n", "# pcd.remove_ground(plot=PLOT_PCD, verbose=True, ransac_iters=4000, ransac_dist=0.5)", "\n", "\n", "# Notes on getting DBSCAN to work with airsim data:", "\n", "# Set dbscan_eps to 0.1 for RealSense data", "\n", "# For Airsim, this gives no clusters.", "\n", "# Raising to 1.0 or greater seems to reduce the number of wrong clusters in the canopies", "\n", "clusters", ",", "cluster_indices", "=", "pcd", ".", "cluster_trees", "(", "dbscan_eps", "=", "self", ".", "params", ".", "dbscan_eps", ",", "\n", "dbscan_min", "=", "self", ".", "params", ".", "dbscan_min", ",", "\n", "min_cluster_size", "=", "self", ".", "params", ".", "min_cluster_size", ",", "\n", "plot", "=", "False", ",", "\n", "verbose", "=", "self", ".", "params", ".", "verbose", ")", "\n", "return", "clusters", ",", "cluster_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.write_kitti_annotations": [[153, 253], ["cluster_local.get_bounding_box_fit_to_max_height.PointCloudDataset.cluster_global_pointcloud", "cluster_local.get_bounding_box_fit_to_max_height.PointCloudDataset.load_time_step", "cluster_local.get_bounding_box_fit_to_max_height.PointCloudDataset.global_pointcloud.get_visible_indices", "pose.world_to_local_transform", "numpy.asarray", "bbox3d.transform_points", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "zip", "len", "open3d.visualization.draw_geometries", "open", "labelfile.writelines", "numpy.union1d", "pointcloud_annotation.clustering.PointCluster", "pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height", "pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height.get_point_indices_within_bounding_box", "geometries.append", "pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height.get_extent", "pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height.get_center", "bbox3d.calc_alpha", "lines.append", "print", "len", "tuple", "tuple", "bbox3d.transform_points", "str", "len"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_global_pointcloud", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.PointCloudDataset.load_time_step", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_visible_indices", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.world_to_local_transform", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.calc_alpha", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points"], ["", "def", "write_kitti_annotations", "(", "self", ")", ":", "\n", "# Generate clusters", "\n", "        ", "cluster_list", ",", "cluster_indices_list", "=", "self", ".", "cluster_global_pointcloud", "(", ")", "\n", "\n", "# Process for converting a cluster in the global point cloud to a local point cloud bounding box:", "\n", "# [TO BE UPDATED IF THIS GIVES WEIRD RESULTS]", "\n", "#   - Check if at least N of the points in the cluster are visible from the camera position at time step i", "\n", "#   - If yes: convert the cluster (all points) to the camera frame, then fit an AxisAlignedBoundingBox to it", "\n", "\n", "# Check which of the global bounding boxes are visible in the local pointcloud", "\n", "# A cluster is \"visible\" if at least N_min_visible points in the cluster are visible from the current camera pose", "\n", "n_min_visible", "=", "20", "\n", "\n", "\n", "for", "i", "in", "self", ".", "time_steps", ":", "\n", "            ", "local_pointcloud", ",", "pose", "=", "self", ".", "load_time_step", "(", "i", ")", "\n", "# Annotate this time step", "\n", "\n", "# Get indices of all points in the global point cloud which are visible from the current pose", "\n", "visible_indices", "=", "self", ".", "global_pointcloud", ".", "get_visible_indices", "(", "camera_position", "=", "pose", ".", "position", ")", "\n", "\n", "# Transform the full point cloud to the camera frame - needed for local points bounding boxes", "\n", "world_to_local", "=", "pose", ".", "world_to_local_transform", "(", ")", "\n", "points_global", "=", "np", ".", "asarray", "(", "self", ".", "global_pointcloud", ".", "original_pcd", ".", "points", ")", "# get original point cloud (not Z-cropped)", "\n", "points_local", "=", "transform_points", "(", "points_global", ",", "world_to_local", ")", "\n", "full_pcd_local", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "full_pcd_local", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points_local", ")", "\n", "\n", "pcd_local", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "pcd_local", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "local_pointcloud", ")", "\n", "\n", "geometries", "=", "[", "pcd_local", "]", "\n", "lines", "=", "[", "]", "\n", "\n", "for", "(", "cluster", ",", "cluster_indices", ")", "in", "zip", "(", "cluster_list", ",", "cluster_indices_list", ")", ":", "\n", "\n", "                ", "n_cluster_points_visible", "=", "len", "(", "np", ".", "union1d", "(", "visible_indices", ",", "cluster_indices", ")", ")", "\n", "cluster_is_visible", "=", "n_cluster_points_visible", ">=", "n_min_visible", "\n", "\n", "if", "cluster_is_visible", ":", "\n", "# Transform the points in the cluster into the camera frame", "\n", "                    ", "cluster_local", "=", "PointCluster", "(", "points", "=", "transform_points", "(", "cluster", ".", "points", ",", "world_to_local", ")", ")", "\n", "bbox3d", "=", "cluster_local", ".", "get_bounding_box_fit_to_max_height", "(", "full_pcd_local", ")", "\n", "\n", "# Make sure the local point cloud contains at least one point inside the bounding box", "\n", "# Skip otherwise", "\n", "local_points_in_box", "=", "bbox3d", ".", "get_point_indices_within_bounding_box", "(", "pcd_local", ".", "points", ")", "\n", "if", "len", "(", "local_points_in_box", ")", "<=", "n_min_visible", ":", "\n", "                        ", "continue", "\n", "\n", "", "geometries", ".", "append", "(", "bbox3d", ")", "\n", "\n", "bbox_dimensions", "=", "bbox3d", ".", "get_extent", "(", ")", "# x,y,z dimensions", "\n", "bbox_center", "=", "bbox3d", ".", "get_center", "(", ")", "\n", "\n", "# Calculate bounding box height, width, length in local point cloud", "\n", "# Point cloud has x-axis right, y forwards, z up", "\n", "height", "=", "bbox_dimensions", "[", "2", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "width", "=", "bbox_dimensions", "[", "0", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "length", "=", "bbox_dimensions", "[", "1", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "\n", "# Note: Airsim data has x-axis pointing right, y forwards, z up", "\n", "# Need to convert to camera coordinates - x right, y down, z forwards", "\n", "# open3D", "\n", "x3d", "=", "bbox_center", "[", "0", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "y3d", "=", "(", "-", "bbox_center", "[", "2", "]", "*", "self", ".", "params", ".", "scale_factor", ")", "+", "height", "/", "2", "# for KITTI, location point should be at bottom of bounding box", "\n", "z3d", "=", "bbox_center", "[", "1", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "\n", "\n", "\n", "# Create KITTI style annotation", "\n", "object_type", "=", "'Car'", "#  placeholder, label obstacles as 'Car' for compatibility with KITTI", "\n", "truncated", "=", "0.0", "# float", "\n", "occluded", "=", "0", "# int, (0,1,2,3) [currently always 0]", "\n", "\n", "rotation_y", "=", "0", "\n", "alpha", "=", "calc_alpha", "(", "rotation_y", ",", "x3d", ",", "z3d", ")", "\n", "\n", "bbox", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "dimensions", "=", "[", "height", ",", "width", ",", "length", "]", "\n", "location", "=", "[", "x3d", ",", "y3d", ",", "z3d", "]", "\n", "\n", "bbox2d_str", "=", "\"%.2f %.2f %.2f %.2f\"", "%", "tuple", "(", "bbox", ")", "\n", "bbox3d_str", "=", "\"%.2f %.2f %.2f %.2f %.2f %.2f %.2f\"", "%", "tuple", "(", "dimensions", "+", "location", "+", "[", "rotation_y", "]", ")", "\n", "label", "=", "\"%s %.2f %.d %.2f %s %s\\n\"", "%", "(", "object_type", ",", "truncated", ",", "occluded", ",", "alpha", ",", "bbox2d_str", ",", "bbox3d_str", ")", "\n", "lines", ".", "append", "(", "label", ")", "\n", "\n", "", "", "if", "self", ".", "params", ".", "plot", ":", "\n", "# for visualizing the axes", "\n", "# geometries += [o3d.geometry.TriangleMesh.create_coordinate_frame(size=10, origin=[0,0,0])]", "\n", "# pts = np.array([[10.5, 2.5, 5.5], [0, 0, 0]])", "\n", "# geometries += [o3d.geometry.AxisAlignedBoundingBox.create_from_points(o3d.utility.Vector3dVector(pts))]", "\n", "                ", "o3d", ".", "visualization", ".", "draw_geometries", "(", "geometries", ")", "\n", "\n", "# Write to file", "\n", "", "path", "=", "self", ".", "annotations_path", "/", "(", "\"%06d.txt\"", "%", "i", ")", "\n", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "labelfile", ":", "\n", "                ", "if", "self", ".", "params", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"Writing labels to '%s'. Annotating %d bounding boxes\"", "%", "(", "str", "(", "path", ")", ",", "len", "(", "lines", ")", ")", ")", "\n", "", "labelfile", ".", "writelines", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.AirsimCameraPose.__init__": [[258, 269], ["scipy.spatial.transform.Rotation.from_quat", "numpy.array", "open", "yaml.load"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["def", "__init__", "(", "self", ",", "pose_filename", ")", ":", "\n", "        ", "with", "open", "(", "pose_filename", ",", "'r'", ")", "as", "pose_file", ":", "\n", "            ", "pose_yaml", "=", "yaml", ".", "load", "(", "pose_file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "# Load fields from YAML format", "\n", "", "self", ".", "cx", "=", "pose_yaml", "[", "'cx'", "]", "\n", "self", ".", "cy", "=", "pose_yaml", "[", "'cy'", "]", "\n", "self", ".", "f", "=", "pose_yaml", "[", "'f'", "]", "\n", "r", "=", "pose_yaml", "[", "\"orientation\"", "]", "\n", "self", ".", "orientation", "=", "Rotation", ".", "from_quat", "(", "[", "r", "[", "'xr'", "]", ",", "r", "[", "'yr'", "]", ",", "r", "[", "'zr'", "]", ",", "r", "[", "'wr'", "]", "]", ")", "\n", "p", "=", "pose_yaml", "[", "\"position\"", "]", "\n", "self", ".", "position", "=", "np", ".", "array", "(", "[", "p", "[", "'x'", "]", ",", "p", "[", "'y'", "]", ",", "p", "[", "'z'", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.AirsimCameraPose.rotation_matrix": [[270, 272], ["bbox3d.AirsimCameraPose.orientation.as_matrix"], "methods", ["None"], ["", "def", "rotation_matrix", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "orientation", ".", "as_matrix", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.AirsimCameraPose.world_to_local_transform": [[273, 283], ["numpy.zeros", "R.dot().flatten", "bbox3d.AirsimCameraPose.rotation_matrix", "R.dot", "bbox3d.AirsimCameraPose.position.reshape"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.rotation_matrix"], ["", "def", "world_to_local_transform", "(", "self", ")", ":", "\n", "        ", "T", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ")", "\n", "\n", "R", "=", "self", ".", "rotation_matrix", "(", ")", ".", "T", "# global to robot frame rotation", "\n", "T", "[", "0", ":", "3", ",", "0", ":", "3", "]", "=", "R", "\n", "T", "[", "0", ":", "3", ",", "3", "]", "=", "R", ".", "dot", "(", "-", "self", ".", "position", ".", "reshape", "(", "(", "3", ",", "1", ")", ")", ")", ".", "flatten", "(", ")", "\n", "\n", "T", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "return", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.transform_points": [[284, 293], ["numpy.array().reshape", "numpy.ones", "transform.dot", "numpy.array"], "function", ["None"], ["", "", "def", "transform_points", "(", "points", ",", "transform", ")", ":", "\n", "    ", "points", "=", "np", ".", "array", "(", "points", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "n_points", "=", "points", ".", "shape", "[", "0", "]", "\n", "\n", "points_H", "=", "np", ".", "ones", "(", "(", "n_points", ",", "4", ")", ")", "\n", "points_H", "[", ":", ",", "0", ":", "3", "]", "=", "points", "\n", "\n", "points_transformed_H", "=", "(", "transform", ".", "dot", "(", "points_H", ".", "T", ")", ")", ".", "T", "\n", "return", "points_transformed_H", "[", ":", ",", "0", ":", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.bbox3d.calc_alpha": [[295, 301], ["numpy.arctan2"], "function", ["None"], ["", "def", "calc_alpha", "(", "rot_y", ",", "x", ",", "z", ")", ":", "\n", "# Calculate the alpha (viewing angle) for KITTI labels", "\n", "# calculate the ry after rotation", "\n", "    ", "beta", "=", "np", ".", "arctan2", "(", "z", ",", "x", ")", "\n", "alpha", "=", "rot_y", "+", "beta", "-", "np", ".", "pi", "/", "2", "#np.sign(beta)*np.pi/2", "\n", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.__init__": [[24, 43], ["numpy.array", "numpy.array", "line_mesh.LineMesh.create_line_mesh", "numpy.array", "line_mesh.LineMesh.lines_from_ordered_points"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.create_line_mesh", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.lines_from_ordered_points"], ["    ", "def", "__init__", "(", "self", ",", "points", ",", "lines", "=", "None", ",", "colors", "=", "[", "0", ",", "1", ",", "0", "]", ",", "radius", "=", "0.15", ")", ":", "\n", "        ", "\"\"\"Creates a line represented as sequence of cylinder triangular meshes\n\n        Arguments:\n            points {ndarray} -- Numpy array of ponts Nx3.\n\n        Keyword Arguments:\n            lines {list[list] or None} -- List of point index pairs denoting line segments. If None, implicit lines from ordered pairwise points. (default: {None})\n            colors {list} -- list of colors, or single color of the line (default: {[0, 1, 0]})\n            radius {float} -- radius of cylinder (default: {0.15})\n        \"\"\"", "\n", "self", ".", "points", "=", "np", ".", "array", "(", "points", ")", "\n", "self", ".", "lines", "=", "np", ".", "array", "(", "\n", "lines", ")", "if", "lines", "is", "not", "None", "else", "self", ".", "lines_from_ordered_points", "(", "self", ".", "points", ")", "\n", "self", ".", "colors", "=", "np", ".", "array", "(", "colors", ")", "\n", "self", ".", "radius", "=", "radius", "\n", "self", ".", "cylinder_segments", "=", "[", "]", "\n", "\n", "self", ".", "create_line_mesh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.create_from_bounding_box": [[44, 51], ["numpy.asarray", "line_mesh.LineMesh", "bbox.get_box_points"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "create_from_bounding_box", "(", "bbox", ",", "radius", "=", "0.03", ")", ":", "\n", "        ", "points", "=", "np", ".", "asarray", "(", "bbox", ".", "get_box_points", "(", ")", ")", "\n", "color", "=", "bbox", ".", "color", "\n", "# l = [[0,1],[0,2],[0,3],[3,6],[1,6],[3,5],[2,5],[4,5],[4,6],[1,7],[2,7],[4,7]]", "\n", "l", "=", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "0", ",", "3", "]", ",", "[", "1", ",", "7", "]", ",", "[", "1", ",", "6", "]", ",", "[", "3", ",", "6", "]", ",", "[", "3", ",", "5", "]", ",", "[", "2", ",", "5", "]", ",", "[", "4", ",", "5", "]", ",", "[", "4", ",", "7", "]", ",", "[", "2", ",", "7", "]", ",", "[", "4", ",", "6", "]", "]", "\n", "return", "LineMesh", "(", "points", ",", "colors", "=", "color", ",", "lines", "=", "l", ",", "radius", "=", "radius", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.lines_from_ordered_points": [[52, 56], ["numpy.array", "range"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "@", "staticmethod", "\n", "def", "lines_from_ordered_points", "(", "points", ")", ":", "\n", "        ", "lines", "=", "[", "[", "i", ",", "i", "+", "1", "]", "for", "i", "in", "range", "(", "0", ",", "points", ".", "shape", "[", "0", "]", "-", "1", ",", "1", ")", "]", "\n", "return", "np", ".", "array", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.create_line_mesh": [[57, 88], ["line_mesh.normalized", "numpy.array", "range", "line_mesh.align_vector_to_another", "open3d.geometry.TriangleMesh.create_cylinder", "cylinder_segment.rotate.rotate.translate", "cylinder_segment.rotate.rotate.paint_uniform_color", "line_mesh.LineMesh.cylinder_segments.append", "cylinder_segment.rotate.rotate.rotate", "open3d.geometry.get_rotation_matrix_from_axis_angle", "cylinder_segment.rotate.rotate.get_center"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.normalized", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.align_vector_to_another"], ["", "def", "create_line_mesh", "(", "self", ")", ":", "\n", "        ", "first_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "0", "]", ",", ":", "]", "\n", "second_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "1", "]", ",", ":", "]", "\n", "line_segments", "=", "second_points", "-", "first_points", "\n", "line_segments_unit", ",", "line_lengths", "=", "normalized", "(", "line_segments", ")", "\n", "\n", "z_axis", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "\n", "# Create triangular mesh cylinder segments of line", "\n", "for", "i", "in", "range", "(", "line_segments_unit", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "line_segment", "=", "line_segments_unit", "[", "i", ",", ":", "]", "\n", "line_length", "=", "line_lengths", "[", "i", "]", "\n", "# get axis angle rotation to allign cylinder with line segment", "\n", "axis", ",", "angle", "=", "align_vector_to_another", "(", "z_axis", ",", "line_segment", ")", "\n", "# Get translation vector", "\n", "translation", "=", "first_points", "[", "i", ",", ":", "]", "+", "line_segment", "*", "line_length", "*", "0.5", "\n", "# create cylinder and apply transformations", "\n", "cylinder_segment", "=", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_cylinder", "(", "\n", "self", ".", "radius", ",", "line_length", ")", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "translate", "(", "\n", "translation", ",", "relative", "=", "False", ")", "\n", "if", "axis", "is", "not", "None", ":", "\n", "                ", "axis_a", "=", "axis", "*", "angle", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "rotate", "(", "\n", "R", "=", "o3d", ".", "geometry", ".", "get_rotation_matrix_from_axis_angle", "(", "axis_a", ")", ",", "center", "=", "cylinder_segment", ".", "get_center", "(", ")", ")", "\n", "# cylinder_segment = cylinder_segment.rotate(", "\n", "#   axis_a, center=True, type=o3d.geometry.RotationType.AxisAngle)", "\n", "# color cylinder", "\n", "", "color", "=", "self", ".", "colors", "if", "self", ".", "colors", ".", "ndim", "==", "1", "else", "self", ".", "colors", "[", "i", ",", ":", "]", "\n", "cylinder_segment", ".", "paint_uniform_color", "(", "color", ")", "\n", "\n", "self", ".", "cylinder_segments", ".", "append", "(", "cylinder_segment", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.add_line": [[89, 93], ["vis.add_geometry"], "methods", ["None"], ["", "", "def", "add_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Adds this line to the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "add_geometry", "(", "cylinder", ",", "reset_bounding_box", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.LineMesh.remove_line": [[94, 98], ["vis.remove_geometry"], "methods", ["None"], ["", "", "def", "remove_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Removes this line from the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "remove_geometry", "(", "cylinder", ",", "reset_bounding_box", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.align_vector_to_another": [[4, 15], ["numpy.array", "numpy.array", "numpy.array_equal", "numpy.cross", "numpy.arccos", "numpy.linalg.norm", "numpy.dot"], "function", ["None"], ["def", "align_vector_to_another", "(", "a", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", ",", "b", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", ":", "\n", "    ", "\"\"\"\n    Aligns vector a to vector b with axis angle rotation\n    \"\"\"", "\n", "if", "np", ".", "array_equal", "(", "a", ",", "b", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "axis_", "=", "np", ".", "cross", "(", "a", ",", "b", ")", "\n", "axis_", "=", "axis_", "/", "np", ".", "linalg", ".", "norm", "(", "axis_", ")", "\n", "angle", "=", "np", ".", "arccos", "(", "np", ".", "dot", "(", "a", ",", "b", ")", ")", "\n", "\n", "return", "axis_", ",", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.line_mesh.normalized": [[17, 22], ["numpy.atleast_1d", "numpy.linalg.norm", "numpy.expand_dims"], "function", ["None"], ["", "def", "normalized", "(", "a", ",", "axis", "=", "-", "1", ",", "order", "=", "2", ")", ":", "\n", "    ", "\"\"\"Normalizes a numpy array of points\"\"\"", "\n", "l2", "=", "np", ".", "atleast_1d", "(", "np", ".", "linalg", ".", "norm", "(", "a", ",", "order", ",", "axis", ")", ")", "\n", "l2", "[", "l2", "==", "0", "]", "=", "1", "\n", "return", "a", "/", "np", ".", "expand_dims", "(", "l2", ",", "axis", ")", ",", "l2", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.__init__": [[12, 54], ["open3d.geometry.PointCloud", "ValueError", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "ValueError", "open3d.io.read_point_cloud", "open3d.io.read_triangle_mesh", "open3d.geometry.PointCloud", "str", "str"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "points", "=", "None", ",", "filename", "=", "None", ",", "o3d_pcd", "=", "None", ",", "load_zed_obj", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        points: ndarray\n            Numpy array. Can be N x 3 (for x, y, z) or N x 6 (for x, y, z, R, G, B)\n        filename: str\n        \"\"\"", "\n", "if", "points", "is", "None", "and", "filename", "is", "None", "and", "o3d_pcd", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Must provide either 'points' or 'filename' argument to TreePointCloud constructor.\"", ")", "\n", "", "elif", "points", "is", "not", "None", ":", "\n", "# Construct from numpy array", "\n", "            ", "self", ".", "_pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "if", "points", ".", "shape", "[", "1", "]", "==", "3", ":", "\n", "# Columns are x, y, z", "\n", "                ", "self", ".", "_pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", ")", "\n", "", "elif", "points", ".", "shape", "[", "1", "]", "==", "6", ":", "\n", "# Columns are x, y, z, r, g, b (RGB must be divided by 255 for valid values)", "\n", "                ", "self", ".", "_pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "self", ".", "_pcd", ".", "colors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", "[", ":", ",", "3", ":", "]", "/", "255.", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Invalid numpy array input. Must have 3 or 6 columns\"", ")", "\n", "\n", "", "", "elif", "filename", "is", "not", "None", ":", "\n", "            ", "if", "not", "load_zed_obj", ":", "\n", "# Construct from a .ply file", "\n", "                ", "self", ".", "_pcd", "=", "o3d", ".", "io", ".", "read_point_cloud", "(", "str", "(", "filename", ")", ")", "\n", "", "else", ":", "\n", "# Construct from a ZED .obj file", "\n", "                ", "mesh", "=", "o3d", ".", "io", ".", "read_triangle_mesh", "(", "str", "(", "filename", ")", ")", "\n", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "pcd", ".", "points", "=", "mesh", ".", "vertices", "\n", "pcd", ".", "colors", "=", "mesh", ".", "vertex_colors", "\n", "self", ".", "_pcd", "=", "pcd", "\n", "", "", "elif", "o3d_pcd", "is", "not", "None", ":", "\n", "            ", "self", ".", "_pcd", "=", "o3d_pcd", "\n", "", "self", ".", "ground_plane", "=", "None", "\n", "self", ".", "clusters", "=", "[", "]", "\n", "self", ".", "original_pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", "self", ".", "_pcd", ")", "\n", "self", ".", "_visibility", "=", "{", "}", "# dictionary where keys are camera positions; values are the indices of points that are visible from that position", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.n_points": [[55, 58], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_points", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_pcd", ".", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_o3d": [[59, 61], ["None"], "methods", ["None"], ["", "def", "get_o3d", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_pcd", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.to_numpy": [[62, 64], ["numpy.asarray"], "methods", ["None"], ["", "def", "to_numpy", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "self", ".", "_pcd", ".", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.downsample": [[65, 70], ["clustering.TreePointCloud._pcd.voxel_down_sample", "print"], "methods", ["None"], ["", "def", "downsample", "(", "self", ",", "downsample_voxel_size", "=", "0.01", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "n_points_before", "=", "self", ".", "n_points", "\n", "self", ".", "_pcd", "=", "self", ".", "_pcd", ".", "voxel_down_sample", "(", "voxel_size", "=", "downsample_voxel_size", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Downsampled from %d points to %d points.\"", "%", "(", "n_points_before", ",", "self", ".", "n_points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.remove_ground": [[71, 89], ["clustering.TreePointCloud._pcd.segment_plane", "clustering.TreePointCloud._pcd.select_by_index", "clustering.TreePointCloud._pcd.select_by_index", "print", "print", "clustering.TreePointCloud.paint_uniform_color", "open3d.visualization.draw_geometries"], "methods", ["None"], ["", "", "def", "remove_ground", "(", "self", ",", "ransac_dist", "=", "0.5", ",", "ransac_n", "=", "3", ",", "ransac_iters", "=", "1000", ",", "plot", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Removing ground plane...\"", ")", "\n", "", "plane_model", ",", "inliers", "=", "self", ".", "_pcd", ".", "segment_plane", "(", "distance_threshold", "=", "ransac_dist", ",", "\n", "ransac_n", "=", "ransac_n", ",", "\n", "num_iterations", "=", "ransac_iters", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Done!\"", ")", "\n", "\n", "", "plane_cloud", "=", "self", ".", "_pcd", ".", "select_by_index", "(", "inliers", ")", "\n", "if", "plot", ":", "\n", "            ", "plane_cloud", ".", "paint_uniform_color", "(", "[", "0.7", ",", "0.7", ",", "0.7", "]", ")", "\n", "", "tree_cloud", "=", "self", ".", "_pcd", ".", "select_by_index", "(", "inliers", ",", "invert", "=", "True", ")", "\n", "self", ".", "ground_plane", "=", "plane_cloud", "\n", "self", ".", "_pcd", "=", "tree_cloud", "\n", "\n", "if", "plot", ":", "\n", "            ", "o3d", ".", "visualization", ".", "draw_geometries", "(", "[", "plane_cloud", ",", "tree_cloud", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.remove_points_above_height": [[90, 99], ["numpy.asarray", "clustering.TreePointCloud._pcd.select_by_index", "print", "range"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "", "def", "remove_points_above_height", "(", "self", ",", "z_cutoff", "=", "0.0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Removing points above height %.2f...\"", "%", "z_cutoff", ")", "\n", "# plane_model, inliers = self._pcd.segment_plane(distance_threshold=ransac_dist,", "\n", "#                                                ransac_n=ransac_n,", "\n", "#                                                num_iterations=ransac_iters)", "\n", "", "points", "=", "np", ".", "asarray", "(", "self", ".", "_pcd", ".", "points", ")", "\n", "below_cutoff", "=", "[", "i", "for", "i", "in", "range", "(", "points", ".", "shape", "[", "0", "]", ")", "if", "points", "[", "i", ",", "2", "]", "<=", "z_cutoff", "]", "\n", "self", ".", "_pcd", "=", "self", ".", "_pcd", ".", "select_by_index", "(", "below_cutoff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.cluster_trees": [[100, 152], ["numpy.array", "clustering.TreePointCloud.to_numpy", "numpy.unique", "len", "print", "clustering.TreePointCloud._pcd.cluster_dbscan", "print", "print", "open3d.visualization.draw_geometries", "numpy.sum", "clustering.PointCluster", "clusters.append", "indices_list.append", "c.to_o3d", "range"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.to_numpy", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "def", "cluster_trees", "(", "self", ",", "dbscan_eps", "=", "0.1", ",", "dbscan_min", "=", "50", ",", "min_cluster_size", "=", "100", ",", "plot", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Cluster the trees using DBSCAN.\n        For best results, use remove_ground() and downsample() before clustering.\n\n        Parameters\n        ----------\n        dbscan_eps\n        dbscan_min\n        plot\n        verbose\n\n        Returns\n        -------\n        clusters_list, indices_list : (PointCluster list, int list list)\n            These lists are the same length.\n            Gives a PointCluster object for each cluster, as well as a corresponding list of\n            indices for the points that appear in that cluster.\n\n        \"\"\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Clustering points...\"", ")", "\n", "\n", "# cluster non-plane points", "\n", "", "labels", "=", "np", ".", "array", "(", "self", ".", "_pcd", ".", "cluster_dbscan", "(", "eps", "=", "dbscan_eps", ",", "min_points", "=", "dbscan_min", ",", "\n", "print_progress", "=", "verbose", ")", ")", "\n", "points", "=", "self", ".", "to_numpy", "(", ")", "\n", "unique_labels", "=", "np", ".", "unique", "(", "labels", ")", "\n", "clusters", "=", "[", "]", "\n", "indices_list", "=", "[", "]", "\n", "for", "l", "in", "unique_labels", ":", "\n", "            ", "if", "l", "==", "-", "1", ":", "# skip outliers label", "\n", "                ", "continue", "\n", "", "if", "np", ".", "sum", "(", "labels", "==", "l", ")", ">=", "min_cluster_size", ":", "\n", "                ", "cluster_points", "=", "points", "[", "labels", "==", "l", ",", ":", "]", "\n", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "points", ".", "shape", "[", "0", "]", ")", "if", "labels", "[", "i", "]", "==", "l", "]", "\n", "cluster", "=", "PointCluster", "(", "cluster_points", ")", "\n", "clusters", ".", "append", "(", "cluster", ")", "\n", "indices_list", ".", "append", "(", "indices", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"[INFO] Done!\"", ")", "\n", "\n", "", "n_clusters", "=", "len", "(", "clusters", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "f\"point cloud has {n_clusters} clusters\"", ")", "\n", "\n", "", "if", "plot", ":", "\n", "            ", "o3d", ".", "visualization", ".", "draw_geometries", "(", "[", "c", ".", "to_o3d", "(", ")", "for", "c", "in", "clusters", "]", ")", "\n", "\n", "", "return", "clusters", ",", "indices_list", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_visible_indices": [[157, 164], ["numpy.array().reshape", "tuple", "numpy.array().reshape.flatten", "clustering.TreePointCloud._pcd.hidden_point_removal", "numpy.array"], "methods", ["None"], ["", "def", "get_visible_indices", "(", "self", ",", "camera_position", ",", "hidden_point_radius", "=", "1000000", ")", ":", "\n", "        ", "camera_position", "=", "np", ".", "array", "(", "camera_position", ")", ".", "reshape", "(", "(", "3", ",", "1", ")", ")", "\n", "key", "=", "tuple", "(", "camera_position", ".", "flatten", "(", ")", ")", "\n", "if", "key", "not", "in", "self", ".", "_visibility", ":", "\n", "            ", "_", ",", "pt_map", "=", "self", ".", "_pcd", ".", "hidden_point_removal", "(", "camera_position", ",", "radius", "=", "hidden_point_radius", ")", "\n", "self", ".", "_visibility", "[", "key", "]", "=", "pt_map", "\n", "", "return", "self", ".", "_visibility", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.write_point_cloud": [[165, 167], ["open3d.io.write_point_cloud"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.write_point_cloud"], ["", "def", "write_point_cloud", "(", "self", ",", "filename", ")", ":", "\n", "        ", "o3d", ".", "io", ".", "write_point_cloud", "(", "filename", ",", "self", ".", "_pcd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.__init__": [[188, 206], ["numpy.array", "points.reshape.reshape.reshape", "numpy.array", "max", "max", "max", "random.random", "random.random", "random.random"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "points", ",", "color", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        points: ndarray\n            3D points as an (N x 3) array.\n        color: ndarray\n            Color, specified as [R,G,B], values from 0 to 1.0.\n            If not provided, a random color will be assigned.\n        \"\"\"", "\n", "points", "=", "np", ".", "array", "(", "points", ")", "\n", "points", "=", "points", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n", "if", "color", "is", "None", ":", "\n", "            ", "color", "=", "[", "max", "(", "random", ".", "random", "(", ")", ",", "0.2", ")", ",", "max", "(", "random", ".", "random", "(", ")", ",", "0.2", ")", ",", "max", "(", "random", ".", "random", "(", ")", ",", "0.2", ")", "]", "\n", "", "self", ".", "color", "=", "np", ".", "array", "(", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d": [[207, 212], ["open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.geometry.PointCloud.paint_uniform_color"], "methods", ["None"], ["", "def", "to_o3d", "(", "self", ")", ":", "\n", "        ", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "self", ".", "points", ")", "\n", "pcd", ".", "paint_uniform_color", "(", "self", ".", "color", ")", "\n", "return", "pcd", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.shape": [[213, 216], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "points", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.__len__": [[217, 219], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "points", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_visible_points": [[220, 224], ["clustering.PointCluster.to_o3d", "clustering.PointCluster.hidden_point_removal"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d"], ["", "def", "get_visible_points", "(", "self", ",", "camera_pose", ",", "radius", "=", "100000", ")", ":", "\n", "        ", "pcd", "=", "self", ".", "to_o3d", "(", ")", "\n", "_", ",", "pt_map", "=", "pcd", ".", "hidden_point_removal", "(", "camera_pose", ",", "radius", ")", "\n", "return", "pt_map", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box": [[225, 228], ["open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points"], "methods", ["None"], ["", "def", "get_bounding_box", "(", "self", ")", ":", "\n", "        ", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "self", ".", "points", ")", "\n", "return", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_max_height": [[229, 245], ["clustering.PointCluster.get_bounding_box_fit_to_pointcloud_max"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_pointcloud_max"], ["", "def", "get_bounding_box_fit_to_max_height", "(", "self", ",", "pcd", ")", ":", "\n", "        ", "\"\"\"\n        Calculate a 3D bounding box with the top set to the highest z-coordinate of all points that\n        lie within the cluster (from a top-down view).\n\n        Parameters\n        ----------\n        pcd: o3d.geometry.PointCloud\n            The full point cloud.\n\n        Returns\n        -------\n        o3d.geometry.AxisAlignedBoundingBox\n\n        \"\"\"", "\n", "return", "self", ".", "get_bounding_box_fit_to_pointcloud_max", "(", "pcd", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_pointcloud_max": [[246, 287], ["numpy.asarray", "numpy.max", "numpy.mean", "numpy.append", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.get_point_indices_within_bounding_box", "numpy.argmax", "numpy.append", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "numpy.mean.reshape", "numpy.asarray", "points_in_box[].reshape"], "methods", ["None"], ["", "def", "get_bounding_box_fit_to_pointcloud_max", "(", "self", ",", "pcd", ",", "axis", ")", ":", "\n", "        ", "\"\"\"\n        Creates a bounding box around this cluster, but with one side of the bounding box\n        extended to the maximum point (in one direction) in the full point cloud.\n\n        Used e.g. for taking a bounding box that fits around the trunk of a tree only,\n        and extending it to the top of the tree.\n\n        Parameters\n        ----------\n        pcd\n        axis: int\n            0, 1, or 2\n            Axis along which to extend the box\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "assert", "axis", "==", "0", "or", "axis", "==", "1", "or", "axis", "==", "2", ",", "\"axis arg must be 0, 1, or 2\"", "\n", "pts", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "\n", "# Find the highest coordinate out of all points in the full point cloud", "\n", "max_all", "=", "np", ".", "max", "(", "pts", "[", ":", ",", "axis", "]", ")", "\n", "\n", "# Create an \"extension point\" - an extra point which is the cluster centroid,", "\n", "# but set to the point cloud max value along the axis to be extended", "\n", "max_point", "=", "np", ".", "mean", "(", "self", ".", "points", ",", "axis", "=", "0", ")", "\n", "max_point", "[", "axis", "]", "=", "max_all", "\n", "pts", "=", "np", ".", "append", "(", "self", ".", "points", ",", "max_point", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Fit a bounding box around the cluster + extension point", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "max_box", "=", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "point_indices", "=", "max_box", ".", "get_point_indices_within_bounding_box", "(", "pcd", ".", "points", ")", "\n", "points_in_box", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "[", "point_indices", ",", ":", "]", "\n", "# Find the point in the full point cloud with the highest z-coordinate, that is also", "\n", "# within the bounding box (in the x- and y- axes)", "\n", "z_max_index", "=", "np", ".", "argmax", "(", "points_in_box", "[", ":", ",", "axis", "]", ")", "\n", "pts", "=", "np", ".", "append", "(", "self", ".", "points", ",", "points_in_box", "[", "z_max_index", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "axis", "=", "0", ")", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "return", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_pointcloud_min": [[288, 329], ["numpy.asarray", "numpy.min", "numpy.mean", "numpy.append", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.get_point_indices_within_bounding_box", "numpy.argmin", "numpy.append", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "numpy.mean.reshape", "numpy.asarray", "points_in_box[].reshape"], "methods", ["None"], ["", "def", "get_bounding_box_fit_to_pointcloud_min", "(", "self", ",", "pcd", ",", "axis", ")", ":", "\n", "        ", "\"\"\"\n        Creates a bounding box around this cluster, but with one side of the bounding box\n        extended to the maximum point (in one direction) in the full point cloud.\n\n        Used e.g. for taking a bounding box that fits around the midsection of a tree trunk,\n        and extending it down to the ground.\n\n        Parameters\n        ----------\n        pcd\n        axis: int\n            0, 1, or 2\n            Axis along which to extend the box\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "assert", "axis", "==", "0", "or", "axis", "==", "1", "or", "axis", "==", "2", ",", "\"axis arg must be 0, 1, or 2\"", "\n", "pts", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "\n", "# Find the highest coordinate out of all points in the full point cloud", "\n", "max_all", "=", "np", ".", "min", "(", "pts", "[", ":", ",", "axis", "]", ")", "\n", "\n", "# Create an \"extension point\" - an extra point which is the cluster centroid,", "\n", "# but set to the point cloud max value along the axis to be extended", "\n", "max_point", "=", "np", ".", "mean", "(", "self", ".", "points", ",", "axis", "=", "0", ")", "\n", "max_point", "[", "axis", "]", "=", "max_all", "\n", "pts", "=", "np", ".", "append", "(", "self", ".", "points", ",", "max_point", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Fit a bounding box around the cluster + extension point", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "max_box", "=", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "point_indices", "=", "max_box", ".", "get_point_indices_within_bounding_box", "(", "pcd", ".", "points", ")", "\n", "points_in_box", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "[", "point_indices", ",", ":", "]", "\n", "# Find the point in the full point cloud with the highest z-coordinate, that is also", "\n", "# within the bounding box (in the x- and y- axes)", "\n", "z_max_index", "=", "np", ".", "argmin", "(", "points_in_box", "[", ":", ",", "axis", "]", ")", "\n", "pts", "=", "np", ".", "append", "(", "self", ".", "points", ",", "points_in_box", "[", "z_max_index", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "axis", "=", "0", ")", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "return", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_pointcloud_extrema": [[330, 376], ["numpy.asarray", "numpy.max", "numpy.min", "numpy.mean", "numpy.mean", "numpy.concatenate", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "open3d.geometry.AxisAlignedBoundingBox.create_from_points.get_point_indices_within_bounding_box", "numpy.argmax", "numpy.argmin", "numpy.concatenate", "open3d.utility.Vector3dVector", "open3d.geometry.AxisAlignedBoundingBox.create_from_points", "numpy.asarray", "numpy.mean.reshape", "numpy.mean.reshape", "points_in_box[].reshape", "points_in_box[].reshape"], "methods", ["None"], ["", "def", "get_bounding_box_fit_to_pointcloud_extrema", "(", "self", ",", "pcd", ",", "axis", ")", ":", "\n", "        ", "\"\"\"\n        Creates a bounding box around this cluster,\n        extended to the maximum and minimum point (in one direction) in the full point cloud.\n\n        Used e.g. for taking a bounding box that fits around the midsection of a tree trunk,\n        and extending it vertically in both directions to cover the whole tree trunk\n\n        Parameters\n        ----------\n        pcd\n        axis: int\n            0, 1, or 2\n            Axis along which to extend the box\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "assert", "axis", "==", "0", "or", "axis", "==", "1", "or", "axis", "==", "2", ",", "\"axis arg must be 0, 1, or 2\"", "\n", "pts", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "\n", "# Find the highest coordinate out of all points in the full point cloud", "\n", "max_all", "=", "np", ".", "max", "(", "pts", "[", ":", ",", "axis", "]", ")", "\n", "min_all", "=", "np", ".", "min", "(", "pts", "[", ":", ",", "axis", "]", ")", "\n", "\n", "# Create an \"extension point\" - an extra point which is the cluster centroid,", "\n", "# but set to the point cloud max value along the axis to be extended", "\n", "max_point", "=", "np", ".", "mean", "(", "self", ".", "points", ",", "axis", "=", "0", ")", "\n", "max_point", "[", "axis", "]", "=", "max_all", "\n", "min_point", "=", "np", ".", "mean", "(", "self", ".", "points", ",", "axis", "=", "0", ")", "\n", "min_point", "[", "axis", "]", "=", "min_all", "\n", "pts", "=", "np", ".", "concatenate", "(", "[", "self", ".", "points", ",", "max_point", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "min_point", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# Fit a bounding box around the cluster + extension point", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "max_box", "=", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "point_indices", "=", "max_box", ".", "get_point_indices_within_bounding_box", "(", "pcd", ".", "points", ")", "\n", "points_in_box", "=", "np", ".", "asarray", "(", "pcd", ".", "points", ")", "[", "point_indices", ",", ":", "]", "\n", "# Find the point in the full point cloud with the highest z-coordinate, that is also", "\n", "# within the bounding box (in the x- and y- axes)", "\n", "z_max_index", "=", "np", ".", "argmax", "(", "points_in_box", "[", ":", ",", "axis", "]", ")", "\n", "z_min_index", "=", "np", ".", "argmin", "(", "points_in_box", "[", ":", ",", "axis", "]", ")", "\n", "pts", "=", "np", ".", "concatenate", "(", "[", "self", ".", "points", ",", "points_in_box", "[", "z_max_index", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", ",", "\n", "points_in_box", "[", "z_min_index", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "3", ")", ")", "]", ",", "axis", "=", "0", ")", "\n", "v_points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pts", ")", "\n", "return", "o3d", ".", "geometry", ".", "AxisAlignedBoundingBox", ".", "create_from_points", "(", "v_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.visualize": [[377, 383], ["multiprocessing.Process", "multiprocessing.Process.start", "c.to_o3d"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d"], ["", "", "def", "visualize", "(", "tree_cloud", ",", "clusters", ")", ":", "\n", "# Visualize clusters without blocking (so skimage viewer can also be open)", "\n", "    ", "geometries", "=", "[", "tree_cloud", "]", "+", "[", "c", ".", "to_o3d", "(", ")", "for", "c", "in", "clusters", "]", "\n", "p", "=", "Process", "(", "target", "=", "o3d", ".", "visualization", ".", "draw_geometries", ",", "args", "=", "(", "geometries", ",", ")", ",", "\n", "daemon", "=", "True", ")", "\n", "p", ".", "start", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Params.__init__": [[43, 65], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# Tree clustering parameters", "\n", "        ", "self", ".", "dbscan_eps", "=", "0.1", "#", "\n", "self", ".", "dbscan_min", "=", "10", "\n", "self", ".", "min_cluster_size", "=", "200", "\n", "self", ".", "downsample_voxel_size", "=", "0.05", "\n", "\n", "self", ".", "visibility_radius", "=", "1000000", "# used in spherical projection for open3d hidden point removal function.", "\n", "# A large value, e.g. 100k or 1million, seems to work well", "\n", "\n", "self", ".", "plot", "=", "False", "\n", "self", ".", "verbose", "=", "False", "\n", "self", ".", "plot_global_pcd", "=", "False", "\n", "self", ".", "_scale_factor", "=", "1.0", "\n", "self", ".", "ransac_iters", "=", "4000", "\n", "self", ".", "ransac_dist", "=", "0.5", "\n", "self", ".", "plot_ground_removal", "=", "False", "\n", "self", ".", "plot_clusters", "=", "False", "\n", "self", ".", "load_clusters_file", "=", "False", "\n", "self", ".", "max_z_cutoff", "=", "None", "\n", "self", ".", "labels_dir", "=", "\"label_2\"", "\n", "self", ".", "box_max_range", "=", "15", "# boxes beyond this range are ignored", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Params.scale_factor": [[70, 74], ["type"], "methods", ["None"], ["", "@", "scale_factor", ".", "setter", "\n", "def", "scale_factor", "(", "self", ",", "s", ")", ":", "\n", "        ", "assert", "type", "(", "s", ")", "==", "float", "and", "s", ">", "0", ",", "\"Scale factor must be a float value greater than zero.\"", "\n", "self", ".", "_scale_factor", "=", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Counter.__init__": [[83, 85], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_count", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Counter.next": [[86, 89], ["None"], "methods", ["None"], ["", "def", "next", "(", "self", ")", ":", "\n", "        ", "self", ".", "_count", "+=", "1", "\n", "return", "self", ".", "_count", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.__init__": [[94, 130], ["pathlib.Path", "dataset.Dataset.get_path_to_global_pointcloud", "print", "print", "pointcloud_annotation.clustering.TreePointCloud", "dataset.Dataset.get_time_steps_list", "dataset.Dataset.time_steps.sort", "print", "dataset.Dataset.create_default_params", "dataset.Counter", "pathlib.Path", "os.path.exists", "print", "pathlib.Path().mkdir", "issubclass", "type", "pathlib.Path", "type", "pathlib.Path", "str", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.get_path_to_global_pointcloud", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.get_time_steps_list", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.create_default_params"], ["def", "__init__", "(", "self", ",", "data_path", ",", "annotations_directory", "=", "None", ",", "\n", "params", "=", "None", ",", "counter", "=", "None", ",", "load_pointcloud_from_obj", "=", "False", ")", ":", "\n", "# Root path for the data, e.g. data/rs_forest_straight/forest-straight-1", "\n", "        ", "self", ".", "data_path", "=", "Path", "(", "data_path", ")", "\n", "\n", "if", "params", "is", "None", "or", "not", "issubclass", "(", "type", "(", "params", ")", ",", "Params", ")", ":", "\n", "            ", "print", "(", "\"[INFO] Using default dataset parameters\"", ")", "\n", "self", ".", "params", "=", "self", ".", "create_default_params", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "params", "=", "params", "\n", "\n", "", "if", "counter", "is", "None", "or", "type", "(", "counter", ")", "!=", "Counter", ":", "\n", "            ", "counter", "=", "Counter", "(", ")", "\n", "", "self", ".", "_counter", "=", "counter", "\n", "\n", "# Create folder for annotations if it doesn't exist", "\n", "if", "annotations_directory", "is", "None", ":", "\n", "# Default is [data directory]/kitti_object/label_2", "\n", "            ", "self", ".", "annotations_path", "=", "self", ".", "data_path", "/", "Path", "(", "\"kitti_object\"", ")", "/", "Path", "(", "\"label_2\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "annotations_path", "=", "Path", "(", "annotations_directory", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "annotations_path", ")", ":", "\n", "            ", "print", "(", "\"[INFO] Creating annotations directory at '%s'...\"", "%", "str", "(", "self", ".", "annotations_path", ")", ")", "\n", "Path", "(", "self", ".", "annotations_path", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# Load in the global point cloud - contains points for the world map, in global frame coordinates", "\n", "", "global_pcd_path", "=", "self", ".", "get_path_to_global_pointcloud", "(", ")", "\n", "print", "(", "\"[INFO] Loading file for global point cloud from '%s'...\"", "%", "global_pcd_path", ")", "\n", "print", "(", "\"[INFO] Loading ZED-style .obj file\"", ")", "\n", "self", ".", "global_pointcloud", "=", "TreePointCloud", "(", "filename", "=", "global_pcd_path", ",", "load_zed_obj", "=", "load_pointcloud_from_obj", ")", "\n", "\n", "## Get time step indices from the RGB image filenames", "\n", "self", ".", "time_steps", "=", "self", ".", "get_time_steps_list", "(", ")", "\n", "self", ".", "time_steps", ".", "sort", "(", ")", "\n", "\n", "self", ".", "clusters_path", "=", "self", ".", "data_path", "/", "\"clusters.npz\"", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.create_default_params": [[131, 144], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "create_default_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Should take in no arguments (besides self), and return an object of type DatasetParams,\n        or a subclass of DatasetParams\n\n        Returns\n        -------\n        Params\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.get_path_to_global_pointcloud": [[145, 155], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_path_to_global_pointcloud", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Should take in no arguments (besides self), and return the path to the global point cloud file\n        Returns\n        -------\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.get_time_steps_list": [[156, 173], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_time_steps_list", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Should take in no arguments (besides self), and return a list of integers containing the time step numbers\n        for all images/local point clouds.\n\n        For an Airsim dataset this will be [1, 2, 3, 4, ... , N]\n        For an Rtabmap dataset, this will be different, since rtabmap does not necessarily give successive numbers\n        to the time steps. So the time steps may look like e.g. [13, 15, 16, 18, 20, 23, ...]\n\n        Returns\n        -------\n        list [int]\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.load_local_pointcloud": [[174, 195], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "load_local_pointcloud", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method\n        Load the local point cloud at a time step\n        Parameters\n        ----------\n        i: int\n            Index of time step to load.\n            Should be an index, *not* the number in the image filename.\n            e.g. if the images are [4.jpg, 8.jpg, 52.jpg],\n            load_time_step(0) will load the image 4.jpg\n            This distinction is important for rtabmap datasets,\n            because rtabmap does not necessarily give successive numbers to the time steps in the image filenames.\n\n        Returns\n        -------\n        o3d.geometry.PointCloud\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.load_pose": [[196, 218], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "load_pose", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Load the camera pose at a time step\n        Parameters\n        ----------\n        i: int\n            Index of time step to load.\n            Should be an index, *not* the number in the image filename.\n            e.g. if the images are [4.jpg, 8.jpg, 52.jpg],\n            load_time_step(0) will load the image 4.jpg\n            This distinction is important for rtabmap datasets,\n            because rtabmap does not necessarily give successive numbers to the time steps in the image filenames.\n\n        Returns\n        -------\n        pose: Pose\n            Contains camera position and orientation at time step i\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.load_calibration": [[219, 230], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "load_calibration", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Returns an object of class Calibration, which stores the camera calibration parameters (intrinsics)\n\n        Returns\n        -------\n        CameraCalibration\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.bounding_box_from_cluster": [[231, 254], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "bounding_box_from_cluster", "(", "self", ",", "cluster", ",", "full_pcd", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        Converts a point cluster to a bounding box, in the local camera frame coordinates.\n\n        Parameters\n        ----------\n        cluster: PointCluster\n            Contains a cluster of points representing one object instance.\n            Points are in the local camera frame.\n        full_pcd: open3d PointCloud\n            Contains the full world point cloud.\n            This is used for things like setting the bottom of the bounding box to be at ground level,\n             according to the full point cloud.\n            Points are in the local camera frame.\n\n        Returns\n        -------\n        open3D bounding box\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.load_clusters": [[255, 258], ["numpy.load", "pointcloud_annotation.clustering.PointCluster", "numpy.load.values"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["", "def", "load_clusters", "(", "self", ")", ":", "\n", "        ", "npz", "=", "np", ".", "load", "(", "self", ".", "clusters_path", ")", "\n", "return", "[", "PointCluster", "(", "points", "=", "points", ")", "for", "points", "in", "npz", ".", "values", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_global_pointcloud": [[260, 277], ["dataset.Dataset.cluster_pointcloud"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_pointcloud"], ["", "def", "cluster_global_pointcloud", "(", "self", ",", "plot", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        TODO this can be removed later - keeping it for compatibility\n        Cluster tree trunks in the global point cloud.\n        This is done by removing points above a set Z-height, then clustering the remaining points using DBSCAN.\n\n        Parameters\n        ----------\n        plot\n        verbose\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "pcd", "=", "self", ".", "global_pointcloud", "\n", "return", "self", ".", "cluster_pointcloud", "(", "pcd", ",", "plot", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_pointcloud": [[278, 309], ["pcd.remove_ground", "pcd.cluster_trees", "pcd.downsample", "pcd.remove_points_above_height", "print"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.remove_ground", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.cluster_trees", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.downsample", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.remove_points_above_height"], ["", "def", "cluster_pointcloud", "(", "self", ",", "pcd", ",", "plot", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Cluster tree trunks in the global point cloud.\n        This is done by removing points above a set Z-height, then clustering the remaining points using DBSCAN.\n\n        Parameters\n        ----------\n        pcd: TreePointCloud\n        plot\n        verbose\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "if", "self", ".", "params", ".", "downsample_voxel_size", ">", "0", ":", "\n", "            ", "pcd", ".", "downsample", "(", "downsample_voxel_size", "=", "self", ".", "params", ".", "downsample_voxel_size", ",", "verbose", "=", "self", ".", "params", ".", "verbose", ")", "\n", "", "elif", "self", ".", "params", ".", "verbose", ":", "\n", "            ", "print", "(", "\"downsample_voxel_size parameter is 0, skipping downsampling...\"", ")", "\n", "", "pcd", ".", "remove_ground", "(", "plot", "=", "self", ".", "params", ".", "plot_ground_removal", ",", "verbose", "=", "self", ".", "params", ".", "verbose", ",", "\n", "ransac_iters", "=", "self", ".", "params", ".", "ransac_iters", ",", "\n", "ransac_dist", "=", "self", ".", "params", ".", "ransac_dist", ")", "\n", "if", "self", ".", "params", ".", "max_z_cutoff", "is", "not", "None", ":", "\n", "            ", "pcd", ".", "remove_points_above_height", "(", "z_cutoff", "=", "self", ".", "params", ".", "max_z_cutoff", ",", "verbose", "=", "self", ".", "params", ".", "verbose", ")", "\n", "\n", "", "clusters", ",", "cluster_indices", "=", "pcd", ".", "cluster_trees", "(", "dbscan_eps", "=", "self", ".", "params", ".", "dbscan_eps", ",", "\n", "dbscan_min", "=", "self", ".", "params", ".", "dbscan_min", ",", "\n", "min_cluster_size", "=", "self", ".", "params", ".", "min_cluster_size", ",", "\n", "plot", "=", "self", ".", "params", ".", "plot_clusters", ",", "\n", "verbose", "=", "self", ".", "params", ".", "verbose", ")", "\n", "return", "clusters", ",", "cluster_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.write_kitti_annotations": [[311, 479], ["numpy.asarray", "range", "len", "dataset.Dataset.load_local_pointcloud", "dataset.Dataset.load_pose", "enumerate", "dataset.Dataset.cluster_global_pointcloud", "dataset.Dataset.load_clusters", "dataset.Dataset.global_pointcloud.remove_ground", "dataset.Dataset.cluster_pointcloud", "numpy.eye", "dataset.Dataset.world_to_local_transform", "dataset.transform_points", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "pointcloud_annotation.clustering.PointCluster", "dataset.Dataset.bounding_box_from_cluster", "dataset.Dataset.get_extent", "dataset.Dataset.get_center", "dataset.calc_alpha", "lines.append", "open3d.visualization.draw_geometries", "open", "labelfile.writelines", "print", "open3d.visualization.draw_geometries", "pointcloud_annotation.clustering.TreePointCloud", "geometries.append", "tuple", "tuple", "open3d.geometry.TriangleMesh.create_coordinate_frame", "dataset.Dataset.global_pointcloud.to_numpy", "dataset.transform_points", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.geometry.PointCloud.paint_uniform_color", "dataset.Dataset._counter.next", "open", "labelfile.writelines", "tracking_gt_lines.append", "print", "dataset.transform_points", "numpy.sqrt", "dataset.Dataset.world_to_local_transform", "print", "c.to_o3d", "len", "str", "len"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_local_pointcloud", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_pose", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_global_pointcloud", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.load_clusters", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.remove_ground", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_pointcloud", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.world_to_local_transform", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.bounding_box_from_cluster", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.calc_alpha", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.to_numpy", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Counter.next", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.world_to_local_transform", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.to_o3d"], ["", "def", "write_kitti_annotations", "(", "self", ",", "tracking_gt", "=", "False", ",", "clustering_baseline", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        tracking_gt: bool\n            If True, will write labels in tracking format\n        clustering_baseline: bool\n            If True, will cluster individual local point clouds using ground plane removal + DBSCAN,\n            and output cluster results as the bounding box annotations.\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "# Generate clusters, or load from file", "\n", "if", "not", "clustering_baseline", ":", "\n", "            ", "if", "not", "self", ".", "params", ".", "load_clusters_file", ":", "\n", "                ", "cluster_list", ",", "_", "=", "self", ".", "cluster_global_pointcloud", "(", ")", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "params", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"Loading clusters from %s\"", "%", "self", ".", "clusters_path", ")", "\n", "", "cluster_list", "=", "self", ".", "load_clusters", "(", ")", "\n", "if", "self", ".", "params", ".", "plot_clusters", ":", "\n", "                    ", "o3d", ".", "visualization", ".", "draw_geometries", "(", "[", "c", ".", "to_o3d", "(", ")", "for", "c", "in", "cluster_list", "]", ")", "\n", "\n", "", "self", ".", "global_pointcloud", ".", "remove_ground", "(", "plot", "=", "self", ".", "params", ".", "plot_ground_removal", ",", "verbose", "=", "self", ".", "params", ".", "verbose", ",", "\n", "ransac_iters", "=", "self", ".", "params", ".", "ransac_iters", ",", "\n", "ransac_dist", "=", "self", ".", "params", ".", "ransac_dist", ")", "\n", "\n", "# Process for converting a cluster in the global point cloud to a local point cloud bounding box:", "\n", "#   - Fit a 3D bounding box around the cluster points.", "\n", "#       - This box is aligned to the camera axes, in the current time step", "\n", "#   - Check if any points in the local point cloud fall within this 3D bounding box", "\n", "#   - If yes: convert the cluster (all points) to the camera frame, then fit an AxisAlignedBoundingBox to it", "\n", "\n", "# Check which of the global bounding boxes are visible in the local pointcloud", "\n", "# A cluster is \"visible\" if at least N_min_visible points in the cluster are visible from the current camera pose", "\n", "\n", "", "", "points_global", "=", "np", ".", "asarray", "(", "self", ".", "global_pointcloud", ".", "original_pcd", ".", "points", ")", "# get original point cloud", "\n", "\n", "tracking_gt_lines", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "time_steps", ")", ")", ":", "\n", "\n", "# Load the local point cloud and camera pose at the current time step", "\n", "            ", "pcd_local", "=", "self", ".", "load_local_pointcloud", "(", "i", ")", "\n", "pose", "=", "self", ".", "load_pose", "(", "i", ")", "\n", "# Annotate this time step", "\n", "\n", "if", "clustering_baseline", ":", "\n", "                ", "cluster_list", ",", "_", "=", "self", ".", "cluster_pointcloud", "(", "TreePointCloud", "(", "o3d_pcd", "=", "pcd_local", ")", ")", "\n", "world_to_local", "=", "np", ".", "eye", "(", "4", ")", "# no separate world and local frames", "\n", "full_pcd_local", "=", "pcd_local", "\n", "\n", "# Get indices of all points in the global point cloud which are visible from the current pose", "\n", "# visible_indices = self.global_pointcloud.get_visible_indices(camera_position=pose.position)", "\n", "\n", "", "else", ":", "\n", "# Transform the full fused point cloud to the camera frame - needed for local points bounding boxes", "\n", "                ", "world_to_local", "=", "pose", ".", "world_to_local_transform", "(", ")", "\n", "points_local", "=", "transform_points", "(", "points_global", ",", "world_to_local", ")", "\n", "full_pcd_local", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "full_pcd_local", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points_local", ")", "\n", "\n", "", "geometries", "=", "[", "pcd_local", "]", "\n", "lines", "=", "[", "]", "\n", "\n", "for", "(", "cluster_id", ",", "cluster", ")", "in", "enumerate", "(", "cluster_list", ")", ":", "\n", "\n", "# Transform the points in the cluster into the camera frame", "\n", "                ", "cluster_local", "=", "PointCluster", "(", "points", "=", "transform_points", "(", "cluster", ".", "points", ",", "world_to_local", ")", ")", "\n", "bbox3d", "=", "self", ".", "bounding_box_from_cluster", "(", "cluster_local", ",", "full_pcd_local", ")", "\n", "\n", "# Make sure the local point cloud contains at least one point inside the bounding box", "\n", "# Skip otherwise", "\n", "# local_points_in_box = bbox3d.get_point_indices_within_bounding_box(pcd_local.points)", "\n", "# if len(local_points_in_box) == 0:", "\n", "#     continue", "\n", "\n", "bbox_dimensions", "=", "bbox3d", ".", "get_extent", "(", ")", "# x,y,z dimensions", "\n", "bbox_center", "=", "bbox3d", ".", "get_center", "(", ")", "\n", "\n", "# Calculate bounding box height, width, length in local point cloud", "\n", "# Point cloud has x-axis right, y forwards, z up", "\n", "# height = bbox_dimensions[1] * self.params.scale_factor", "\n", "# width = bbox_dimensions[0] * self.params.scale_factor", "\n", "# length = bbox_dimensions[2] * self.params.scale_factor", "\n", "\n", "# THIS IS USED FOR ZED ROS-STYLE COORDINATES - update other datasets to use the same format later", "\n", "height", "=", "bbox_dimensions", "[", "2", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "width", "=", "bbox_dimensions", "[", "0", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "length", "=", "bbox_dimensions", "[", "1", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "\n", "# KITTI 3D box annotations are in camera coordinates", "\n", "# Need to convert to camera coordinates - x right, y down, z forwards", "\n", "# open3D", "\n", "x3d", "=", "-", "bbox_center", "[", "1", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "y3d", "=", "-", "bbox_center", "[", "2", "]", "*", "self", ".", "params", ".", "scale_factor", "+", "height", "/", "2", "# for KITTI, location point should be at bottom of bounding box", "\n", "z3d", "=", "bbox_center", "[", "0", "]", "*", "self", ".", "params", ".", "scale_factor", "\n", "\n", "# Check that bounding box is within range limit, skip if not", "\n", "# Also skip bounding boxes that are behind the camera", "\n", "if", "np", ".", "sqrt", "(", "x3d", "**", "2", "+", "y3d", "**", "2", ")", ">", "self", ".", "params", ".", "box_max_range", "or", "z3d", "<=", "0", ":", "\n", "                    ", "continue", "\n", "\n", "# Create geometry for plotting", "\n", "", "if", "self", ".", "params", ".", "plot", ":", "\n", "                    ", "bbox3d", ".", "color", "=", "[", "0.1", ",", "1.0", ",", "0.2", "]", "# bright green", "\n", "geometries", ".", "append", "(", "bbox3d", ")", "\n", "# geometries += LineMesh.create_from_bounding_box(bbox3d).cylinder_segments", "\n", "\n", "# Create KITTI style annotation", "\n", "", "object_type", "=", "'Car'", "#  placeholder, label obstacles as 'Car' for compatibility with KITTI", "\n", "truncated", "=", "0.0", "# float", "\n", "occluded", "=", "0", "# int, (0,1,2,3) [currently always 0]", "\n", "\n", "rotation_y", "=", "0", "\n", "alpha", "=", "calc_alpha", "(", "rotation_y", ",", "x3d", ",", "z3d", ")", "\n", "\n", "bbox", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "dimensions", "=", "[", "height", ",", "width", ",", "length", "]", "\n", "location", "=", "[", "x3d", ",", "y3d", ",", "z3d", "]", "\n", "\n", "bbox2d_str", "=", "\"%.2f %.2f %.2f %.2f\"", "%", "tuple", "(", "bbox", ")", "\n", "bbox3d_str", "=", "\"%.2f %.2f %.2f %.2f %.2f %.2f %.2f\"", "%", "tuple", "(", "dimensions", "+", "location", "+", "[", "rotation_y", "]", ")", "\n", "label", "=", "\"%s %.2f %.d %.2f %s %s\\n\"", "%", "(", "object_type", ",", "truncated", ",", "occluded", ",", "alpha", ",", "bbox2d_str", ",", "bbox3d_str", ")", "\n", "if", "tracking_gt", ":", "\n", "# Tracking format - add in cluster ID", "\n", "                    ", "label", "=", "\"%d %s\"", "%", "(", "cluster_id", "+", "1", ",", "label", ")", "\n", "", "lines", ".", "append", "(", "label", ")", "\n", "\n", "", "if", "self", ".", "params", ".", "plot", ":", "\n", "# for visualizing the camera position and axes", "\n", "                ", "geometries", "+=", "[", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_coordinate_frame", "(", ")", "]", "\n", "if", "self", ".", "params", ".", "plot_global_pcd", ":", "\n", "                    ", "global_pts", "=", "self", ".", "global_pointcloud", ".", "to_numpy", "(", ")", "\n", "global_pts_cam_frame", "=", "transform_points", "(", "global_pts", ",", "pose", ".", "world_to_local_transform", "(", ")", ")", "\n", "global_pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "global_pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "global_pts_cam_frame", ")", "\n", "global_pcd", ".", "paint_uniform_color", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "geometries", "+=", "[", "global_pcd", "]", "\n", "", "o3d", ".", "visualization", ".", "draw_geometries", "(", "geometries", ",", "width", "=", "640", ",", "height", "=", "320", ")", "\n", "# vis = o3d.visualization.VisualizerWithEditing()", "\n", "# vis.create_window()", "\n", "# render_option: o3d.visualization.RenderOption = vis.get_render_option()", "\n", "# render_option.background_color = [0.1, 0.1, 0.1]", "\n", "# for g in geometries:", "\n", "#     vis.add_geometry(g)", "\n", "# vis.run()", "\n", "\n", "# Write to file", "\n", "", "path", "=", "self", ".", "annotations_path", "/", "(", "\"%06d.txt\"", "%", "self", ".", "_counter", ".", "next", "(", ")", ")", "\n", "if", "not", "tracking_gt", ":", "\n", "                ", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "labelfile", ":", "\n", "                    ", "if", "self", ".", "params", ".", "verbose", ":", "\n", "                        ", "print", "(", "\"Writing labels to '%s'. Annotating %d bounding boxes\"", "%", "(", "str", "(", "path", ")", ",", "len", "(", "lines", ")", ")", ")", "\n", "", "labelfile", ".", "writelines", "(", "lines", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "l", "in", "lines", ":", "\n", "# Add frame number at the start of all object lines from this frame", "\n", "                    ", "tracking_gt_lines", ".", "append", "(", "\"%d %s\"", "%", "(", "i", ",", "l", ")", ")", "\n", "", "if", "self", ".", "params", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"[INFO] Tracking ground truth: %d objects at frame %d\"", "%", "(", "len", "(", "lines", ")", ",", "i", ")", ")", "\n", "", "", "", "if", "tracking_gt", ":", "\n", "            ", "trk_gt_path", "=", "self", ".", "annotations_path", "/", "(", "\"tracking_gt_updated.txt\"", ")", "\n", "with", "open", "(", "trk_gt_path", ",", "\"w\"", ")", "as", "labelfile", ":", "\n", "                ", "labelfile", ".", "writelines", "(", "tracking_gt_lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.MultiDataset.__init__": [[483, 501], ["pathlib.Path", "dataset.MultiDataset.Counter", "subdirs.sort", "pathlib.Path", "pathlib.Path", "os.listdir", "os.path.isdir", "dataset.MultiDataset.MultiDataset.create_dataset", "datasets.append", "print", "print"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.MultiZedDataset.create_dataset"], ["    ", "def", "__init__", "(", "self", ",", "parent_directory", ",", "annotations_directory", ",", "params", "=", "None", ")", ":", "\n", "        ", "parent_directory", "=", "Path", "(", "parent_directory", ")", "\n", "annotations_directory", "=", "Path", "(", "annotations_directory", ")", "/", "Path", "(", "params", ".", "labels_dir", ")", "\n", "datasets", "=", "[", "]", "\n", "counter", "=", "Counter", "(", ")", "\n", "subdirs", "=", "[", "d", "for", "d", "in", "os", ".", "listdir", "(", "parent_directory", ")", "if", "os", ".", "path", ".", "isdir", "(", "parent_directory", "/", "d", ")", "]", "\n", "subdirs", ".", "sort", "(", ")", "\n", "for", "subdir", "in", "subdirs", ":", "\n", "            ", "data_directory", "=", "parent_directory", "/", "subdir", "\n", "try", ":", "\n", "                ", "dataset", "=", "self", ".", "create_dataset", "(", "data_directory", ",", "annotations_directory", ",", "\n", "params", ",", "counter", ")", "\n", "datasets", ".", "append", "(", "dataset", ")", "\n", "print", "(", "\"Loaded dataset from '%s'.\"", "%", "subdir", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "\"[WARNING] Error with processing dataset at '%s', skipping...\"", "%", "subdir", ")", "\n", "\n", "", "", "self", ".", "datasets", "=", "datasets", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.MultiDataset.create_dataset": [[502, 505], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "create_dataset", "(", "self", ",", "data_directory", ",", "annotations_directory", ",", "params", ",", "counter", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.MultiDataset.write_kitti_annotations": [[507, 511], ["enumerate", "print", "dataset.write_kitti_annotations", "len"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.MultiDataset.write_kitti_annotations"], ["", "def", "write_kitti_annotations", "(", "self", ",", "tracking_gt", "=", "False", ")", ":", "\n", "        ", "for", "i", ",", "dataset", "in", "enumerate", "(", "self", ".", "datasets", ")", ":", "\n", "            ", "print", "(", "\"Processing dataset [%d / %d]\"", "%", "(", "i", "+", "1", ",", "len", "(", "self", ".", "datasets", ")", ")", ")", "\n", "dataset", ".", "write_kitti_annotations", "(", "tracking_gt", "=", "tracking_gt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.__init__": [[518, 532], ["scipy.spatial.transform.Rotation.from_quat", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "position", ",", "quaternion", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        position : ndarray\n            Size 3\n            Contains x, y, z\n        quaternion : ndarray\n            Size 4\n            Contains quaternion in scalar-last format (same format used for Scipy rotations)\n        \"\"\"", "\n", "self", ".", "orientation", "=", "Rotation", ".", "from_quat", "(", "quaternion", ")", "\n", "self", ".", "position", "=", "np", ".", "array", "(", "position", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.rotation_matrix": [[533, 535], ["dataset.Pose.orientation.as_matrix"], "methods", ["None"], ["", "def", "rotation_matrix", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "orientation", ".", "as_matrix", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.world_to_local_transform": [[536, 546], ["numpy.zeros", "R.dot().flatten", "dataset.Pose.rotation_matrix", "R.dot", "dataset.Pose.position.reshape"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Pose.rotation_matrix"], ["", "def", "world_to_local_transform", "(", "self", ")", ":", "\n", "        ", "T", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ")", "\n", "\n", "R", "=", "self", ".", "rotation_matrix", "(", ")", ".", "T", "# global to robot frame rotation", "\n", "T", "[", "0", ":", "3", ",", "0", ":", "3", "]", "=", "R", "\n", "T", "[", "0", ":", "3", ",", "3", "]", "=", "R", ".", "dot", "(", "-", "self", ".", "position", ".", "reshape", "(", "(", "3", ",", "1", ")", ")", ")", ".", "flatten", "(", ")", "\n", "\n", "T", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "return", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.CameraCalibration.__init__": [[557, 564], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "image_width", ",", "image_height", ",", "fx", ",", "fy", ",", "cx", ",", "cy", ")", ":", "\n", "        ", "self", ".", "width", "=", "image_width", "\n", "self", ".", "height", "=", "image_height", "\n", "self", ".", "fx", "=", "fx", "\n", "self", ".", "fy", "=", "fy", "\n", "self", ".", "cx", "=", "cx", "\n", "self", ".", "cy", "=", "cy", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.CameraCalibration.to_open3d": [[565, 570], ["open3d.camera.PinholeCameraIntrinsic", "open3d.camera.PinholeCameraIntrinsic.set_intrinsics"], "methods", ["None"], ["", "def", "to_open3d", "(", "self", ")", ":", "\n", "        ", "camera_intrinsics", "=", "o3d", ".", "camera", ".", "PinholeCameraIntrinsic", "(", ")", "\n", "camera_intrinsics", ".", "set_intrinsics", "(", "self", ".", "width", ",", "self", ".", "height", ",", "\n", "self", ".", "fx", ",", "self", ".", "fy", ",", "self", ".", "cx", ",", "self", ".", "cy", ")", "\n", "return", "camera_intrinsics", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.CameraCalibration.to_kitti_calib_file": [[571, 613], ["pathlib.Path", "numpy.array2string", "numpy.array2string", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "numpy.eye().flatten", "[].flatten", "open", "outfile.writelines", "numpy.eye", "numpy.eye"], "methods", ["None"], ["", "def", "to_kitti_calib_file", "(", "self", ",", "calib_output_path", ")", ":", "\n", "        ", "\"\"\"\n        Writes the calibration info to a KITTI-style calibration file\n\n        Parameters\n        ----------\n        calib_output_path: Path\n            Path to the output file name.\n\n        Returns\n        -------\n        None\n\n        \"\"\"", "\n", "calib_out_path", "=", "Path", "(", "calib_output_path", ")", "\n", "\n", "# String for projection and transformation matrices", "\n", "P", "=", "(", "\"%f 0.0 %f 0.0 0.0 %f %f 0.0 0.0 0.0 1.0 0.0\\n\"", "%", "(", "self", ".", "fx", ",", "self", ".", "cx", ",", "self", ".", "fy", ",", "self", ".", "cy", ")", ")", "\n", "\n", "# Transformation matrix just needs to convert axes from camera frame to x-forward, y-left", "\n", "# Since there's no separate camera and velodyne sensors", "\n", "R0", "=", "np", ".", "array2string", "(", "np", ".", "eye", "(", "3", ")", ".", "flatten", "(", ")", ",", "formatter", "=", "{", "'float_kind'", ":", "lambda", "x", ":", "\"%.1f\"", "%", "x", "}", ")", "\n", "R0", "=", "R0", "[", "1", ":", "-", "1", "]", "# remove brackets", "\n", "R0", "=", "R0", "+", "'\\n'", "\n", "\n", "Tcam", "=", "'0 -1 0 0 0 0 -1 0 1 0 0 0\\n'", "\n", "\n", "T", "=", "np", ".", "array2string", "(", "np", ".", "eye", "(", "4", ")", "[", "0", ":", "3", ",", ":", "]", ".", "flatten", "(", ")", ",", "formatter", "=", "{", "'float_kind'", ":", "lambda", "x", ":", "\"%.1f\"", "%", "x", "}", ")", "\n", "T", "=", "T", "[", "1", ":", "-", "1", "]", "# remove brackets", "\n", "T", "=", "T", "+", "'\\n'", "\n", "\n", "lines", "=", "[", "]", "\n", "lines", ".", "append", "(", "\"P0: \"", "+", "P", ")", "\n", "lines", ".", "append", "(", "\"P1: \"", "+", "P", ")", "\n", "lines", ".", "append", "(", "\"P2: \"", "+", "P", ")", "\n", "lines", ".", "append", "(", "\"P3: \"", "+", "P", ")", "\n", "lines", ".", "append", "(", "\"R0_rect: \"", "+", "R0", ")", "\n", "lines", ".", "append", "(", "\"Tr_velo_to_cam: \"", "+", "Tcam", ")", "\n", "lines", ".", "append", "(", "\"Tr_imu_to_velo: \"", "+", "T", ")", "\n", "\n", "with", "open", "(", "calib_out_path", ",", "'w'", ")", "as", "outfile", ":", "\n", "            ", "outfile", ".", "writelines", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.transform_points": [[615, 624], ["numpy.array().reshape", "numpy.ones", "transform.dot", "numpy.array"], "function", ["None"], ["", "", "", "def", "transform_points", "(", "points", ",", "transform", ")", ":", "\n", "    ", "points", "=", "np", ".", "array", "(", "points", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "n_points", "=", "points", ".", "shape", "[", "0", "]", "\n", "\n", "points_H", "=", "np", ".", "ones", "(", "(", "n_points", ",", "4", ")", ")", "\n", "points_H", "[", ":", ",", "0", ":", "3", "]", "=", "points", "\n", "\n", "points_transformed_H", "=", "(", "transform", ".", "dot", "(", "points_H", ".", "T", ")", ")", ".", "T", "\n", "return", "points_transformed_H", "[", ":", ",", "0", ":", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.calc_alpha": [[626, 632], ["numpy.arctan2"], "function", ["None"], ["", "def", "calc_alpha", "(", "rot_y", ",", "x", ",", "z", ")", ":", "\n", "# Calculate the alpha (viewing angle) for KITTI labels", "\n", "# calculate the ry after rotation", "\n", "    ", "beta", "=", "np", ".", "arctan2", "(", "z", ",", "x", ")", "\n", "alpha", "=", "rot_y", "+", "beta", "-", "np", ".", "pi", "/", "2", "#np.sign(beta)*np.pi/2", "\n", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedParams.__init__": [[26, 40], ["pointcloud_annotation.dataset.Params.__init__"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# Tree clustering parameters", "\n", "self", ".", "dbscan_eps", "=", "0.1", "#", "\n", "self", ".", "dbscan_min", "=", "10", "\n", "\n", "self", ".", "downsample_voxel_size", "=", "0.0", "\n", "\n", "self", ".", "visibility_radius", "=", "1000000", "# used in spherical projection for open3d hidden point removal function.", "\n", "# A large value, e.g. 100k or 1million, seems to work well", "\n", "\n", "self", ".", "_scale_factor", "=", "1.0", "\n", "self", ".", "ransac_iters", "=", "1000", "\n", "self", ".", "ransac_dist", "=", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.MultiZedDataset.__init__": [[44, 46], ["pointcloud_annotation.dataset.MultiDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.__init__"], ["    ", "def", "__init__", "(", "self", ",", "parent_directory", ",", "annotations_directory", ",", "params", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "parent_directory", ",", "annotations_directory", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.MultiZedDataset.create_dataset": [[47, 49], ["zed_utils.ZedDataset"], "methods", ["None"], ["", "def", "create_dataset", "(", "self", ",", "data_directory", ",", "annotations_directory", ",", "params", ",", "counter", ")", ":", "\n", "        ", "return", "ZedDataset", "(", "data_directory", ",", "annotations_directory", ",", "params", ",", "counter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.__init__": [[54, 73], ["pathlib.Path", "zed_utils.ZedDataset.load_calibration", "numpy.loadtxt", "pointcloud_annotation.dataset.Dataset.__init__", "str"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_calibration", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.__init__"], ["def", "__init__", "(", "self", ",", "zed_data_path", ",", "annotations_directory", "=", "None", ",", "params", "=", "None", ",", "counter", "=", "None", ",", "pcd_dir", "=", "\"pointcloud\"", ")", ":", "\n", "        ", "zed_data_path", "=", "Path", "(", "zed_data_path", ")", "\n", "# Set ZED-specific paths", "\n", "# Paths to RGB and depth images, from the ZED", "\n", "self", ".", "rgb_path", "=", "zed_data_path", "/", "\"rgb\"", "\n", "self", ".", "depth_path", "=", "zed_data_path", "/", "\"depth\"", "\n", "self", ".", "pcd_path", "=", "zed_data_path", "/", "pcd_dir", "\n", "\n", "# Load calibration/camera parameters", "\n", "self", ".", "calib_path", "=", "zed_data_path", "/", "\"calibration.yaml\"", "\n", "self", ".", "calib", "=", "self", ".", "load_calibration", "(", ")", "\n", "\n", "# Contains camera pose at each time step", "\n", "self", ".", "pose_path", "=", "zed_data_path", "/", "\"poses.txt\"", "\n", "self", ".", "pose_history", "=", "np", ".", "loadtxt", "(", "str", "(", "self", ".", "pose_path", ")", ")", "\n", "\n", "# Call parent class constructor", "\n", "super", "(", ")", ".", "__init__", "(", "zed_data_path", ",", "annotations_directory", ",", "params", ",", "counter", ",", "\n", "load_pointcloud_from_obj", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.create_default_params": [[75, 77], ["zed_utils.ZedParams"], "methods", ["None"], ["", "def", "create_default_params", "(", "self", ")", ":", "\n", "        ", "return", "ZedParams", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.get_path_to_global_pointcloud": [[78, 80], ["None"], "methods", ["None"], ["", "def", "get_path_to_global_pointcloud", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_path", "/", "\"map.obj\"", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.get_time_steps_list": [[81, 90], ["os.listdir", "filename.split", "time_steps.append", "int", "print"], "methods", ["None"], ["", "def", "get_time_steps_list", "(", "self", ")", ":", "\n", "        ", "time_steps", "=", "[", "]", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "self", ".", "rgb_path", ")", ":", "\n", "            ", "s", "=", "filename", ".", "split", "(", "'.'", ")", "[", "0", "]", "# gives just the number", "\n", "try", ":", "\n", "                ", "time_steps", ".", "append", "(", "int", "(", "s", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "\"[WARNING] Found invalid filename '%s'\"", "%", "filename", ")", "\n", "", "", "return", "time_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_local_pointcloud": [[92, 97], ["zed_utils.load_pointcloud_from_zed_npz"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_pointcloud_from_zed_npz"], ["", "def", "load_local_pointcloud", "(", "self", ",", "i", ")", ":", "\n", "        ", "img_num", "=", "self", ".", "time_steps", "[", "i", "]", "\n", "pcd_path", "=", "self", ".", "pcd_path", "/", "(", "\"%d.npz\"", "%", "img_num", ")", "\n", "local_pointcloud", "=", "load_pointcloud_from_zed_npz", "(", "pcd_path", ")", "\n", "return", "local_pointcloud", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_pose": [[98, 103], ["pointcloud_annotation.dataset.Pose"], "methods", ["None"], ["", "def", "load_pose", "(", "self", ",", "i", ")", ":", "\n", "# Get pose from the poses array. A row contains time stamp, position, and quaternion", "\n", "        ", "position", "=", "self", ".", "pose_history", "[", "i", ",", "1", ":", "4", "]", "\n", "quat", "=", "self", ".", "pose_history", "[", "i", ",", "4", ":", "]", "\n", "return", "Pose", "(", "position", ",", "quat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.load_calibration": [[104, 106], ["zed_utils.load_zed_calib"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_zed_calib"], ["", "def", "load_calibration", "(", "self", ")", ":", "\n", "        ", "return", "load_zed_calib", "(", "self", ".", "calib_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.ZedDataset.bounding_box_from_cluster": [[107, 111], ["cluster.get_bounding_box_fit_to_pointcloud_extrema"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.PointCluster.get_bounding_box_fit_to_pointcloud_extrema"], ["", "def", "bounding_box_from_cluster", "(", "self", ",", "cluster", ",", "full_pcd", ")", ":", "\n", "# Fit bounding box around lowest and highest points in the full pointcloud, within the bounding box's", "\n", "# x-y limits. This accounts for removing points below (ground plane removal) and above (leaves/sky removal)", "\n", "        ", "return", "cluster", ".", "get_bounding_box_fit_to_pointcloud_extrema", "(", "full_pcd", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_zed_calib": [[113, 126], ["pointcloud_annotation.dataset.CameraCalibration", "open", "yaml.load"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["", "", "def", "load_zed_calib", "(", "calib_path", ")", ":", "\n", "    ", "with", "open", "(", "calib_path", ",", "'r'", ")", "as", "yamlfile", ":", "\n", "# read the calibration params dictionary from yaml", "\n", "        ", "calib", "=", "yaml", ".", "load", "(", "yamlfile", ")", "\n", "# get width, height, fx, fy, cx, cy from yaml file", "\n", "", "w", "=", "calib", "[", "'image_width'", "]", "\n", "h", "=", "calib", "[", "'image_height'", "]", "\n", "fx", "=", "calib", "[", "'fx'", "]", "\n", "fy", "=", "calib", "[", "'fy'", "]", "\n", "cx", "=", "calib", "[", "'cx'", "]", "\n", "cy", "=", "calib", "[", "'cy'", "]", "\n", "\n", "return", "CameraCalibration", "(", "w", ",", "h", ",", "fx", ",", "fy", ",", "cx", ",", "cy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_pointcloud_from_zed_npz": [[128, 142], ["numpy.load", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "o3d.geometry.PointCloud.remove_non_finite_points", "npz_data[].astype", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["", "def", "load_pointcloud_from_zed_npz", "(", "npz_file_path", ",", "max_range", "=", "15.0", ")", ":", "\n", "    ", "npz_data", "=", "np", ".", "load", "(", "npz_file_path", ")", "\n", "points", "=", "npz_data", "[", "\"points\"", "]", "\n", "colors", "=", "npz_data", "[", "\"colors\"", "]", ".", "astype", "(", "np", ".", "float", ")", "/", "255", "\n", "\n", "in_range", "=", "np", ".", "sqrt", "(", "points", "[", ":", ",", "0", "]", "**", "2", "+", "points", "[", ":", ",", "1", "]", "**", "2", ")", "<", "max_range", "\n", "points", "=", "points", "[", "in_range", ",", ":", "]", "\n", "colors", "=", "colors", "[", "in_range", ",", ":", "]", "\n", "\n", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points", ")", "\n", "pcd", ".", "colors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "colors", ")", "\n", "pcd", ".", "remove_non_finite_points", "(", ")", "\n", "return", "pcd", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.zed_utils.load_pointcloud_from_zed_pointclouds": [[143, 150], ["open3d.geometry.PointCloud", "numpy.load", "points_np.reshape.reshape", "open3d.utility.Vector3dVector", "o3d.geometry.PointCloud.remove_non_finite_points"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerResults.load"], ["", "def", "load_pointcloud_from_zed_pointclouds", "(", "pcd_path", ")", ":", "\n", "    ", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "points_np", "=", "np", ".", "load", "(", "pcd_path", ")", "\n", "points_np", "=", "points_np", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "points_np", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "pcd", ".", "remove_non_finite_points", "(", ")", "\n", "return", "pcd", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection.get_visible_points": [[9, 25], ["full_cloud._pcd.select_by_index", "pointcloud_annotation.clustering.PointCluster", "numpy.intersect1d", "numpy.asarray", "full_cloud.get_visible_indices"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_visible_indices"], ["def", "get_visible_points", "(", "cluster", ",", "cluster_indices", ",", "full_cloud", ",", "camera_position", ")", ":", "\n", "    ", "\"\"\"\n\n    Parameters\n    ----------\n    cluster: PointCluster\n    full_pointcloud: TreePointCloud\n    camera_position\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "# TODO clean up this line to get rid of _pcd access", "\n", "visible", "=", "full_cloud", ".", "_pcd", ".", "select_by_index", "(", "np", ".", "intersect1d", "(", "full_cloud", ".", "get_visible_indices", "(", "camera_position", ")", ",", "cluster_indices", ")", ")", "\n", "return", "PointCluster", "(", "np", ".", "asarray", "(", "visible", ".", "points", ")", ",", "color", "=", "cluster", ".", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection.world_to_camera_frame": [[26, 43], ["scipy.spatial.transform.Rotation.from_quat", "numpy.zeros", "rot_matrix.dot", "len", "numpy.empty", "projection._world_to_camera_helper", "R.from_quat.as_matrix"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection._world_to_camera_helper"], ["", "def", "world_to_camera_frame", "(", "cluster", ",", "camera_position", ",", "camera_quaternion", ",", "P", ",", "remove_hidden", "=", "False", ")", ":", "\n", "# Transform the 3D points in the cluster to the 3D camera frame", "\n", "\n", "# Define transformation matrix from world frame to camera frame", "\n", "    ", "rot", "=", "R", ".", "from_quat", "(", "camera_quaternion", ")", "\n", "rot_matrix", "=", "rot", ".", "as_matrix", "(", ")", ".", "T", "\n", "T_world_to_camera", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ")", "\n", "T_world_to_camera", "[", "0", ":", "3", ",", "0", ":", "3", "]", "=", "rot_matrix", "\n", "T_world_to_camera", "[", "0", ":", "3", ",", "3", "]", "=", "rot_matrix", ".", "dot", "(", "-", "camera_position", ")", "\n", "T_world_to_camera", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "# Transform points", "\n", "n_points", "=", "len", "(", "cluster", ")", "\n", "points_W", "=", "cluster", ".", "points", "\n", "points_C", "=", "np", ".", "empty", "(", "points_W", ".", "shape", ")", "# Camera frame 3D points", "\n", "points_C", "=", "_world_to_camera_helper", "(", "points_W", ",", "T_world_to_camera", ",", "points_C", ")", "\n", "return", "points_C", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection._world_to_camera_helper": [[44, 52], ["numpy.array", "range", "T_world_to_camera.dot().flatten", "T_world_to_camera.dot", "np.array.reshape"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "@", "nb", ".", "njit", "\n", "def", "_world_to_camera_helper", "(", "points_W", ",", "T_world_to_camera", ",", "points_C", ")", ":", "\n", "    ", "n_points", "=", "points_C", ".", "shape", "[", "0", "]", "\n", "p_W", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1.0", "]", ")", "# Homogeneous coordinates vector", "\n", "for", "i", "in", "range", "(", "n_points", ")", ":", "\n", "        ", "p_W", "[", "0", ":", "3", "]", "=", "points_W", "[", "i", ",", ":", "]", "\n", "points_C", "[", "i", ",", ":", "]", "=", "T_world_to_camera", ".", "dot", "(", "p_W", ".", "reshape", "(", "(", "4", ",", "1", ")", ")", ")", ".", "flatten", "(", ")", "[", "0", ":", "3", "]", "\n", "", "return", "points_C", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection.project_to_image": [[54, 59], ["numpy.empty", "projection._project_to_image_helper"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection._project_to_image_helper"], ["", "def", "project_to_image", "(", "points_C", ",", "projection_matrix", ")", ":", "\n", "    ", "n_points", "=", "points_C", ".", "shape", "[", "0", "]", "\n", "projected", "=", "np", ".", "empty", "(", "(", "n_points", ",", "2", ")", ")", "\n", "projected", "=", "_project_to_image_helper", "(", "points_C", ",", "projection_matrix", ",", "projected", ")", "\n", "return", "projected", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection._project_to_image_helper": [[60, 71], ["numpy.array().reshape", "range", "points_C[].reshape", "projection_matrix.dot", "numpy.array"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "@", "nb", ".", "njit", "\n", "def", "_project_to_image_helper", "(", "points_C", ",", "projection_matrix", ",", "projected", ")", ":", "\n", "    ", "n_points", "=", "points_C", ".", "shape", "[", "0", "]", "\n", "p_C", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1.0", "]", ")", ".", "reshape", "(", "(", "4", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "n_points", ")", ":", "\n", "        ", "p_C", "[", "0", ":", "3", ",", ":", "]", "=", "points_C", "[", "i", ",", ":", "]", ".", "reshape", "(", "(", "3", ",", "1", ")", ")", "# 3D point in camera frame", "\n", "p", "=", "projection_matrix", ".", "dot", "(", "p_C", ")", "\n", "# Divide x and y coordinates by z-coordinate to get pixel coordinates", "\n", "projected", "[", "i", ",", "0", "]", "=", "p", "[", "0", ",", "0", "]", "/", "p", "[", "2", ",", "0", "]", "\n", "projected", "[", "i", ",", "1", "]", "=", "p", "[", "1", ",", "0", "]", "/", "p", "[", "2", ",", "0", "]", "\n", "", "return", "projected", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.projection.draw_projected": [[72, 88], ["range", "zip", "int", "int", "int", "numpy.floor", "numpy.floor"], "function", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.tracker_visualization.tracking.TrackerBoundingBox.range"], ["", "@", "nb", ".", "njit", "\n", "def", "draw_projected", "(", "image", ",", "projected_points", ",", "color", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "projected_points", ".", "shape", "[", "0", "]", ")", ":", "\n", "# projected points are in x-y format, so index 0 is column and 1 is row", "\n", "        ", "col", "=", "projected_points", "[", "i", ",", "0", "]", "\n", "row", "=", "projected_points", "[", "i", ",", "1", "]", "\n", "# if 0+radius < row < image.shape[0]-radius and 0+radius < col < image.shape[1]-radius:", "\n", "#     image[row, col, :] = [c*255 for c in color[0:3]]", "\n", "# rs = [row-1, row, row, row, row+1]", "\n", "# cs = [col, col-1, col, col+1, col]", "\n", "rs", "=", "[", "row", "-", "2", ",", "row", "-", "1", ",", "row", "-", "1", ",", "row", "-", "1", ",", "row", ",", "row", ",", "row", ",", "row", ",", "row", ",", "row", "+", "1", ",", "row", "+", "1", ",", "row", "+", "1", ",", "row", "+", "2", "]", "\n", "cs", "=", "[", "col", ",", "col", "-", "1", ",", "col", ",", "col", "+", "1", ",", "col", "-", "2", ",", "col", "-", "1", ",", "col", ",", "col", "+", "1", ",", "col", "+", "2", ",", "col", "-", "1", ",", "col", ",", "col", "+", "1", ",", "col", "]", "\n", "for", "r", ",", "c", "in", "zip", "(", "rs", ",", "cs", ")", ":", "\n", "            ", "if", "0", "<", "r", "<", "image", ".", "shape", "[", "0", "]", "and", "0", "<", "c", "<", "image", ".", "shape", "[", "1", "]", ":", "\n", "                ", "for", "j", "in", "[", "0", ",", "1", ",", "2", "]", ":", "\n", "                    ", "image", "[", "int", "(", "np", ".", "floor", "(", "r", ")", ")", ",", "int", "(", "np", ".", "floor", "(", "c", ")", ")", ",", "j", "]", "=", "int", "(", "color", "[", "j", "]", "*", "255", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.__init__": [[47, 72], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        dataset : Dataset\n        \"\"\"", "\n", "# self.vis = o3d.visualization.Visualizer()", "\n", "# self.vis.create_window()", "\n", "\n", "# Clusters are stored as a dict, where the key is the int index of the cluster,", "\n", "# and values are a list of point indices belonging to that cluster", "\n", "self", ".", "clusters", "=", "{", "}", "\n", "self", ".", "dataset", "=", "dataset", "\n", "\n", "# Add the open3D point cloud to the visualizer", "\n", "# self.vis.add_geometry(dataset.global_pointcloud.get_o3d())", "\n", "# self.vis.register_animation_callback(test_calback)", "\n", "# self.vis.run()", "\n", "\n", "# while True:", "\n", "# self.update_vis()", "\n", "self", ".", "n_auto_correct", "=", "0", "\n", "self", ".", "n_auto_incorrect", "=", "0", "\n", "self", ".", "n_user_added", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.run": [[78, 86], ["labeller.Labeller.auto_cluster", "print", "labeller.Labeller.review_clusters", "print", "print", "labeller.Labeller.add_clusters", "print"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.auto_cluster", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.review_clusters", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.add_clusters"], ["", "def", "run", "(", "self", ")", ":", "\n", "        ", "self", ".", "auto_cluster", "(", ")", "\n", "print", "(", "\"Review auto-clustering results\"", ")", "\n", "self", ".", "review_clusters", "(", ")", "\n", "print", "(", "\"Finished reviewing clusters from auto-clustering.\"", ")", "\n", "print", "(", "\"Next, add new clusters if needed.\"", ")", "\n", "self", ".", "add_clusters", "(", ")", "\n", "print", "(", "\"Finished adding new clusters. Labelling done!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.auto_cluster": [[87, 102], ["print", "labeller.Labeller.dataset.cluster_global_pointcloud", "print", "enumerate"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.dataset.Dataset.cluster_global_pointcloud"], ["", "def", "auto_cluster", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run automated clustering on the point cloud.\n        These clusters will later be reviewed by the user.\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "print", "(", "\"[INFO] Removing ground and clustering point cloud. This may take some time...\"", ")", "\n", "clusters", ",", "cluster_indices", "=", "self", ".", "dataset", ".", "cluster_global_pointcloud", "(", ")", "\n", "print", "(", "\"[INFO] Finished clustering\"", ")", "\n", "for", "i", ",", "indices", "in", "enumerate", "(", "cluster_indices", ")", ":", "\n", "# Begin cluster numbering from 1", "\n", "            ", "self", ".", "clusters", "[", "i", "+", "1", "]", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.review_clusters": [[103, 154], ["labeller.Labeller.dataset.global_pointcloud.get_o3d", "open3d.geometry.PointCloud", "numpy.asarray", "open3d.utility.Vector3dVector", "print", "print", "print"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_o3d"], ["", "", "def", "review_clusters", "(", "self", ")", ":", "\n", "        ", "final_clusters", "=", "{", "}", "\n", "next_cluster", "=", "1", "\n", "pcd", ":", "o3d", ".", "geometry", ".", "PointCloud", "=", "self", ".", "dataset", ".", "global_pointcloud", ".", "get_o3d", "(", ")", "\n", "ground_plane_pcd", "=", "self", ".", "dataset", ".", "global_pointcloud", ".", "ground_plane", "\n", "# Darken the ground plane", "\n", "# ground_plane_pcd.colors = o3d.utility.Vector3dVector(np.asarray(ground_plane_pcd.colors) * 0.05)", "\n", "\n", "pcd_vis", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", "pcd", ")", "\n", "colors_vis", "=", "np", ".", "asarray", "(", "pcd_vis", ".", "colors", ")", "\n", "\n", "for", "c", "in", "self", ".", "clusters", ":", "\n", "            ", "cluster_indices", "=", "self", ".", "clusters", "[", "c", "]", "\n", "\n", "colors_vis", "[", "cluster_indices", ",", ":", "]", "=", "HIGHLIGHT_PURPLE", "\n", "pcd_vis", ".", "colors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "colors_vis", ")", "\n", "\n", "# Move visualizer viewpoint to this cluster", "\n", "# Viewpoint changes to directly above the cluster centroid", "\n", "# centroid = np.mean(pcd_points[self.clusters[c], :], axis=0)", "\n", "\n", "# view control cannot be changed with draw_geometries in open3d 0.10.", "\n", "# in open3d 0.11, draw_geometries gets inputs which allow moving the camera", "\n", "# view = vis.get_view_control()", "\n", "# view.set_front(centroid + [0, 0, view_distance])", "\n", "# view.set_lookat(centroid)", "\n", "# view.set_front([1.0, 1.0, 0])", "\n", "# view.set_up([0, 0, 1.0])", "\n", "# view.set_zoom(0.3)", "\n", "\n", "print", "(", "\"Review highlighted cluster in the visualizer window. Press Q (with the visualizer window active) when done.\"", ")", "\n", "\n", "#o3d.visualization.draw_geometries([pcd_vis, ground_plane_pcd])", "\n", "\n", "# Prompt user for action", "\n", "#command = self.get_user_command_review_clusters(c)", "\n", "\n", "command", "=", "KEY_KEEP", "\n", "\n", "if", "command", "==", "KEY_DELETE", ":", "\n", "# Skip adding this cluster to the new clusters dict", "\n", "                ", "print", "(", "\"Deleting cluster\"", ")", "\n", "colors_vis", "[", "cluster_indices", ",", ":", "]", "=", "HIGHLIGHT_GRAY", "\n", "self", ".", "n_auto_incorrect", "+=", "1", "\n", "", "else", ":", "# command == KEY_KEEP", "\n", "                ", "print", "(", "\"Keeping cluster.\"", ")", "\n", "final_clusters", "[", "next_cluster", "]", "=", "self", ".", "clusters", "[", "c", "]", "\n", "next_cluster", "+=", "1", "\n", "colors_vis", "[", "cluster_indices", ",", ":", "]", "=", "HIGHLIGHT_BLUE", "\n", "self", ".", "n_auto_correct", "+=", "1", "\n", "", "", "self", ".", "clusters", "=", "final_clusters", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.add_clusters": [[155, 196], ["labeller.Labeller.dataset.global_pointcloud.get_o3d", "max", "open3d.geometry.PointCloud", "numpy.asarray", "labeller.Labeller.clusters.values", "open3d.utility.Vector3dVector", "labeller.Labeller.get_user_command_add_clusters", "numpy.random.random", "labeller.Labeller.select_cluster", "labeller.Labeller.clusters.values", "len", "print", "labeller.Labeller.clusters.pop", "print", "labeller.Labeller.clusters.keys", "print", "open3d.visualization.draw_geometries"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_o3d", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.get_user_command_add_clusters", "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.select_cluster"], ["", "def", "add_clusters", "(", "self", ")", ":", "\n", "        ", "next_cluster", "=", "max", "(", "[", "i", "for", "i", "in", "self", ".", "clusters", ".", "keys", "(", ")", "]", ")", "+", "1", "\n", "# Get the current point cloud, with ground plane removed", "\n", "pcd", ":", "o3d", ".", "geometry", ".", "PointCloud", "=", "self", ".", "dataset", ".", "global_pointcloud", ".", "get_o3d", "(", ")", "\n", "ground_plane_pcd", "=", "self", ".", "dataset", ".", "global_pointcloud", ".", "ground_plane", "\n", "\n", "# Paint points that are already clustered", "\n", "while", "True", ":", "\n", "# Paint existing clusters blue", "\n", "            ", "pcd_vis", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", "pcd", ")", "\n", "colors_vis", "=", "np", ".", "asarray", "(", "pcd_vis", ".", "colors", ")", "\n", "for", "cluster_indices", "in", "self", ".", "clusters", ".", "values", "(", ")", ":", "\n", "# colors_vis[cluster_indices, :] = HIGHLIGHT_BLUE", "\n", "                ", "colors_vis", "[", "cluster_indices", ",", ":", "]", "=", "np", ".", "random", ".", "random", "(", "3", ")", "\n", "", "pcd_vis", ".", "colors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "colors_vis", ")", "\n", "\n", "# Get command from user", "\n", "command", "=", "self", ".", "get_user_command_add_clusters", "(", ")", "\n", "if", "command", "==", "KEY_ADD", ":", "\n", "# Select points and add a new cluster", "\n", "                ", "selected", "=", "self", ".", "select_cluster", "(", "pcd_vis", ")", "\n", "# Remove any selected points which belong to another cluster", "\n", "for", "cluster_indices", "in", "self", ".", "clusters", ".", "values", "(", ")", ":", "\n", "                    ", "selected", "=", "[", "i", "for", "i", "in", "selected", "if", "not", "i", "in", "cluster_indices", "]", "\n", "", "if", "len", "(", "selected", ")", "==", "0", ":", "\n", "                    ", "print", "(", "\"No points selected, will not add cluster\"", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "clusters", "[", "next_cluster", "]", "=", "selected", "\n", "# Increment number for next cluster", "\n", "next_cluster", "+=", "1", "\n", "self", ".", "n_user_added", "+=", "1", "\n", "", "", "elif", "command", "==", "KEY_UNDO", ":", "\n", "                ", "next_cluster", "-=", "1", "\n", "self", ".", "clusters", ".", "pop", "(", "next_cluster", ")", "\n", "print", "(", "\"Removed cluster %d\"", "%", "next_cluster", ")", "\n", "self", ".", "n_user_added", "-=", "1", "\n", "", "elif", "command", "==", "KEY_VIEW", ":", "\n", "                ", "print", "(", "\"Visualizing point cloud. Press 'Q' to exit visualizer.\"", ")", "\n", "o3d", ".", "visualization", ".", "draw_geometries", "(", "[", "pcd_vis", ",", "ground_plane_pcd", "]", ")", "\n", "", "else", ":", "# command == KEY_QUIT", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.write_clusters": [[197, 215], ["numpy.asarray", "print", "numpy.savez_compressed", "labeller.Labeller.get_dataset_pcd", "str", "len"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.get_dataset_pcd"], ["", "", "", "def", "write_clusters", "(", "self", ")", ":", "\n", "# lines = []", "\n", "# for c in self.clusters:", "\n", "#     point_indices = self.clusters[c]", "\n", "#     for p in point_indices:", "\n", "#         lines.append(\"%d %d\\n\" % (p, c))", "\n", "# with open(clusters_filename, 'w') as clusters_file:", "\n", "#     clusters_file.writelines(lines)", "\n", "# print(\"Wrote %d lines to file '%s'\" % (len(lines), clusters_filename))", "\n", "        ", "clusters_filename", "=", "self", ".", "dataset", ".", "clusters_path", "\n", "npz_dict", "=", "{", "}", "\n", "points", "=", "np", ".", "asarray", "(", "self", ".", "get_dataset_pcd", "(", ")", ".", "points", ")", "\n", "for", "c", "in", "self", ".", "clusters", ":", "\n", "            ", "cluster_indices", "=", "self", ".", "clusters", "[", "c", "]", "\n", "cluster_points", "=", "points", "[", "cluster_indices", ",", ":", "]", "\n", "npz_dict", "[", "str", "(", "c", ")", "]", "=", "cluster_points", "\n", "", "print", "(", "\"Saved %d clusters to file %s\"", "%", "(", "len", "(", "npz_dict", ")", ",", "clusters_filename", ")", ")", "\n", "np", ".", "savez_compressed", "(", "clusters_filename", ",", "**", "npz_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.write_stats": [[216, 223], ["lines.append", "lines.append", "lines.append", "open", "stats_file.writelines"], "methods", ["None"], ["", "def", "write_stats", "(", "self", ",", "filename", ")", ":", "\n", "        ", "lines", "=", "[", "]", "\n", "lines", ".", "append", "(", "\"Correct auto-generated clusters: %d\\n\"", "%", "self", ".", "n_auto_correct", ")", "\n", "lines", ".", "append", "(", "\"Incorrect auto-generated clusters: %d\\n\"", "%", "self", ".", "n_auto_incorrect", ")", "\n", "lines", ".", "append", "(", "\"User-added clusters: %d\\n\"", "%", "self", ".", "n_user_added", ")", "\n", "with", "open", "(", "filename", ",", "'w'", ")", "as", "stats_file", ":", "\n", "            ", "stats_file", ".", "writelines", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.get_dataset_pcd": [[224, 226], ["labeller.Labeller.dataset.global_pointcloud.get_o3d"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.clustering.TreePointCloud.get_o3d"], ["", "", "def", "get_dataset_pcd", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dataset", ".", "global_pointcloud", ".", "get_o3d", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.get_user_command_review_clusters": [[228, 249], ["print", "print", "print", "print", "print", "input", "user_input[].lower", "len", "print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_user_command_review_clusters", "(", "cluster_index", "=", "-", "1", ")", ":", "\n", "        ", "print", "(", "\"----------------------------------\"", ")", "\n", "if", "cluster_index", "is", "not", "-", "1", ":", "\n", "            ", "print", "(", "\"[Cluster %d]\"", "%", "cluster_index", ")", "\n", "", "print", "(", "\"Enter one of the following commands:\"", ")", "\n", "print", "(", "\"(%s) Keep the cluster as-is, no need for any changes.\"", "%", "KEY_KEEP", ")", "\n", "# print(\"(%s) Re-select the points for this cluster. \"", "\n", "#       \"Use this option if auto-clustering made some mistakes in selecting points.\" % KEY_RESELECT)", "\n", "print", "(", "\"(%s) Delete this cluster. \"", "\n", "\"Use this option if auto-clustering made a mistake.\"", "%", "KEY_DELETE", ")", "\n", "while", "True", ":", "\n", "            ", "user_input", "=", "input", "(", "\"Enter command [Default: 'k'eep]: \"", ")", "\n", "if", "len", "(", "user_input", ")", "==", "0", ":", "\n", "                ", "user_input", "=", "KEY_KEEP", "\n", "", "command", "=", "user_input", "[", "0", "]", ".", "lower", "(", ")", "\n", "if", "command", "not", "in", "REVIEW_CLUSTER_COMMANDS", ":", "\n", "                ", "print", "(", "\"Invalid command '%s'. Try again.\"", "%", "command", ")", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "", "return", "command", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.prompt_reselect": [[250, 253], ["print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "prompt_reselect", "(", ")", ":", "\n", "        ", "print", "(", "\"Select points for \"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.get_user_command_add_clusters": [[254, 273], ["print", "print", "print", "print", "print", "print", "input", "len", "user_input[].lower", "print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_user_command_add_clusters", "(", ")", ":", "\n", "        ", "print", "(", "\"----------------------------------\"", ")", "\n", "print", "(", "\"Enter one of the following commands:\"", ")", "\n", "print", "(", "\"(%s) Add a new cluster and select points for it.\"", "%", "KEY_ADD", ")", "\n", "print", "(", "\"(%s) Visualize the point cloud and current clusters.\"", "%", "KEY_VIEW", ")", "\n", "print", "(", "\"(%s) Undo, remove last added cluster.\"", "%", "KEY_UNDO", ")", "\n", "print", "(", "\"(%s) Finish adding new clusters and quit. \"", "%", "KEY_QUIT", ")", "\n", "while", "True", ":", "\n", "            ", "user_input", "=", "input", "(", "\"Enter command: \"", ")", "\n", "if", "len", "(", "user_input", ")", ">", "0", ":", "\n", "                ", "command", "=", "user_input", "[", "0", "]", ".", "lower", "(", ")", "\n", "", "else", ":", "\n", "                ", "command", "=", "user_input", "\n", "", "if", "command", "not", "in", "ADD_CLUSTER_COMMANDS", ":", "\n", "                ", "print", "(", "\"Invalid command '%s'. Try again.\"", "%", "command", ")", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "", "return", "command", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.select_cluster": [[274, 295], ["print", "print", "print", "print", "open3d.visualization.VisualizerWithVertexSelection", "open3d.visualization.VisualizerWithVertexSelection.create_window", "open3d.visualization.VisualizerWithVertexSelection.add_geometry", "open3d.visualization.VisualizerWithVertexSelection.run", "open3d.visualization.VisualizerWithVertexSelection.destroy_window", "print", "open3d.visualization.VisualizerWithVertexSelection.get_picked_points"], "methods", ["home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.Labeller.run"], ["", "@", "staticmethod", "\n", "def", "select_cluster", "(", "pcd", ")", ":", "\n", "        ", "\"\"\"\n        Prompt the user to select points in the visualizer window.\n\n        Reference: http://www.open3d.org/docs/release/tutorial/visualization/interactive_visualization.html\n        \"\"\"", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "\n", "\"1) Hold down [shift + left click] to drag a box around points\"", "\n", ")", "\n", "print", "(", "\"   You may need to rotate the viewpoint and repeat this a few times to select all the points.\"", ")", "\n", "print", "(", "\"2) After picking points, press 'Q' to close the window\"", ")", "\n", "vis", "=", "o3d", ".", "visualization", ".", "VisualizerWithVertexSelection", "(", ")", "\n", "vis", ".", "create_window", "(", ")", "\n", "vis", ".", "add_geometry", "(", "pcd", ")", "\n", "vis", ".", "run", "(", ")", "# user picks points", "\n", "vis", ".", "destroy_window", "(", ")", "\n", "print", "(", "\"\"", ")", "\n", "return", "[", "pt", ".", "index", "for", "pt", "in", "vis", ".", "get_picked_points", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.brian-h-wang_pseudolidar-tree-detection.pointcloud_annotation.labeller.test_calback": [[39, 44], ["vis.get_picked_points", "len", "print", "len"], "function", ["None"], ["def", "test_calback", "(", "vis", ")", ":", "\n", "    ", "selected", "=", "vis", ".", "get_picked_points", "(", ")", "\n", "if", "len", "(", "selected", ")", ">", "0", ":", "\n", "        ", "print", "(", "len", "(", "selected", ")", ")", "\n", "", "return", "True", "\n", "\n"]]}