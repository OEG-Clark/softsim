{"home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d": [[27, 53], ["Conv2D", "Conv2D"], "function", ["None"], ["def", "conv_2d", "(", "filters", ",", "kernel_shape", ",", "strides", ",", "padding", ",", "input_shape", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Defines the right convolutional layer according to the\n  version of Keras that is installed.\n  :param filters: (required integer) the dimensionality of the output\n                  space (i.e. the number output of filters in the\n                  convolution)\n  :param kernel_shape: (required tuple or list of 2 integers) specifies\n                       the kernel shape of the convolution\n  :param strides: (required tuple or list of 2 integers) specifies\n                       the strides of the convolution along the width and\n                       height.\n  :param padding: (required string) can be either 'valid' (no padding around\n                  input or feature map) or 'same' (pad to ensure that the\n                  output feature map size is identical to the layer input)\n  :param input_shape: (optional) give input shape if this is the first\n                      layer of the model\n  :return: the Keras layer\n  \"\"\"", "\n", "if", "input_shape", "is", "not", "None", ":", "\n", "    ", "return", "Conv2D", "(", "filters", "=", "filters", ",", "kernel_size", "=", "kernel_shape", ",", "\n", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "input_shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "    ", "return", "Conv2D", "(", "filters", "=", "filters", ",", "kernel_size", "=", "kernel_shape", ",", "\n", "strides", "=", "strides", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.vgg19_model": [[54, 136], ["Sequential", "Sequential.add", "tensorflow.keras.backend.image_data_format", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "Flatten", "Dense", "Activation", "Dense", "Sequential.add", "Sequential.", "Activation", "tensorflow.keras.backend.image_data_format"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d"], ["", "", "def", "vgg19_model", "(", "logits", "=", "False", ",", "input_ph", "=", "None", ",", "img_rows", "=", "28", ",", "img_cols", "=", "28", ",", "\n", "channels", "=", "1", ",", "nb_classes", "=", "10", ")", ":", "\n", "      ", "\"\"\"\n      Defines a CNN model using Keras sequential model\n      :param logits: If set to False, returns a Keras model, otherwise will also\n                      return logits tensor\n      :param input_ph: The TensorFlow tensor for the input\n                      (needed if returning logits)\n                      (\"ph\" stands for placeholder but it need not actually be a\n                      placeholder)\n      :param img_rows: number of row in the image\n      :param img_cols: number of columns in the image\n      :param channels: number of color channels (e.g., 1 for MNIST)\n      :param nb_filters: number of convolutional filters per layer\n      :param nb_classes: the number of output classes\n      :return:\n      \"\"\"", "\n", "model", "=", "Sequential", "(", ")", "\n", "\n", "# Define the layers successively (convolution layers are version dependent)", "\n", "if", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "        ", "input_shape", "=", "(", "channels", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "        ", "assert", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_last'", "\n", "input_shape", "=", "(", "img_rows", ",", "img_cols", ",", "channels", ")", "\n", "\n", "\n", "", "layers", "=", "[", "conv_2d", "(", "64", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ",", "\n", "input_shape", "=", "input_shape", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "64", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "128", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "128", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "256", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "256", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "256", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "256", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "512", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Dense", "(", "256", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Dense", "(", "nb_classes", ")", "]", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "        ", "model", ".", "add", "(", "layer", ")", "\n", "\n", "", "if", "logits", ":", "\n", "        ", "logits_tensor", "=", "model", "(", "input_ph", ")", "\n", "\n", "", "model", ".", "add", "(", "Activation", "(", "'softmax'", ")", ")", "\n", "\n", "if", "logits", ":", "\n", "        ", "return", "model", ",", "logits_tensor", "\n", "", "else", ":", "\n", "        ", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.detector_model": [[139, 176], ["Sequential", "Sequential.add", "tensorflow.keras.backend.image_data_format", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "MaxPooling2D", "Flatten", "Dense", "Activation", "Dense", "Sequential.add", "Sequential.", "Activation", "tensorflow.keras.backend.image_data_format"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d"], ["", "", "def", "detector_model", "(", "logits", "=", "False", ",", "input_ph", "=", "None", ",", "img_rows", "=", "28", ",", "img_cols", "=", "28", ",", "\n", "channels", "=", "1", ",", "nb_classes", "=", "10", ")", ":", "\n", "# Limited to Sequential(), can be turned into Model()", "\n", "    ", "model", "=", "Sequential", "(", ")", "\n", "\n", "# Define the layers successively (convolution layers are version dependent)", "\n", "if", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "        ", "input_shape", "=", "(", "channels", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "        ", "assert", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_last'", "\n", "input_shape", "=", "(", "img_rows", ",", "img_cols", ",", "channels", ")", "\n", "\n", "# Body", "\n", "", "layers", "=", "[", "conv_2d", "(", "32", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ",", "\n", "input_shape", "=", "input_shape", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "64", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Dense", "(", "64", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Dense", "(", "nb_classes", ")", "]", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "       ", "model", ".", "add", "(", "layer", ")", "\n", "\n", "", "if", "logits", ":", "\n", "        ", "logits_tensor", "=", "model", "(", "input_ph", ")", "\n", "\n", "", "model", ".", "add", "(", "Activation", "(", "'softmax'", ")", ")", "\n", "\n", "if", "logits", ":", "\n", "        ", "return", "model", ",", "logits_tensor", "\n", "", "else", ":", "\n", "        ", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.copycat_model": [[178, 220], ["Sequential", "Sequential.add", "tensorflow.keras.backend.image_data_format", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "aux_models.conv_2d", "Activation", "aux_models.conv_2d", "Activation", "MaxPooling2D", "Flatten", "Dense", "Activation", "Dense", "Sequential.add", "Sequential.", "Activation", "tensorflow.keras.backend.image_data_format"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_models.conv_2d"], ["", "", "def", "copycat_model", "(", "logits", "=", "False", ",", "input_ph", "=", "None", ",", "img_rows", "=", "28", ",", "img_cols", "=", "28", ",", "\n", "channels", "=", "1", ",", "nb_classes", "=", "10", ")", ":", "\n", "# Limited to Sequential(), can be turned into Model()", "\n", "# But will require mandatory input tensor, at least in TF1.X", "\n", "    ", "model", "=", "Sequential", "(", ")", "\n", "\n", "# Define the layers successively (convolution layers are version dependent)", "\n", "if", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "        ", "input_shape", "=", "(", "channels", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "        ", "assert", "tf", ".", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_last'", "\n", "input_shape", "=", "(", "img_rows", ",", "img_cols", ",", "channels", ")", "\n", "\n", "# Body", "\n", "", "layers", "=", "[", "conv_2d", "(", "32", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ",", "\n", "input_shape", "=", "input_shape", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "32", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "conv_2d", "(", "64", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "64", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Dense", "(", "64", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Dense", "(", "nb_classes", ")", "]", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "       ", "model", ".", "add", "(", "layer", ")", "\n", "\n", "", "if", "logits", ":", "\n", "        ", "logits_tensor", "=", "model", "(", "input_ph", ")", "\n", "\n", "", "model", ".", "add", "(", "Activation", "(", "'softmax'", ")", ")", "\n", "\n", "if", "logits", ":", "\n", "        ", "return", "model", ",", "logits_tensor", "\n", "", "else", ":", "\n", "        ", "return", "model", "", "", "", ""]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.__init__": [[36, 51], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "\n", "default_rand_init", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a PatchProjectedGradientDescent instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "\n", "super", "(", "PatchProjectedGradientDescent", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", "=", "sess", ",", "\n", "dtypestr", "=", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'eps_iter'", ",", "'y'", ",", "'y_target'", ",", "'clip_min'", ",", "\n", "'clip_max'", ",", "'mask'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'ord'", ",", "'nb_iter'", ",", "'rand_init'", ",", "'clip_grad'", ",", "\n", "'sanity_checks'", "]", "\n", "self", ".", "default_rand_init", "=", "default_rand_init", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.generate": [[52, 177], ["aux_attacks.PatchProjectedGradientDescent.parse_params", "cleverhans.utils_tf.clip_eta", "tensorflow.multiply", "aux_attacks.PatchProjectedGradientDescent.FGM_CLASS", "tensorflow.while_loop", "asserts.append", "asserts.append", "asserts.append", "cleverhans.utils_tf.random_lp_vector", "tensorflow.zeros", "cleverhans.utils_tf.clip_by_value", "NotImplementedError", "tensorflow.less", "aux_attacks.PatchProjectedGradientDescent.generate", "tensorflow.multiply", "cleverhans.utils_tf.clip_eta", "cleverhans.utils_tf.assert_less_equal", "asserts.append", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "tensorflow.shape", "tensorflow.cast", "tensorflow.shape", "aux_attacks.PatchProjectedGradientDescent.model.get_probs", "tensorflow.reduce_max", "tensorflow.to_float", "tensorflow.stop_gradient", "getattr", "cleverhans.utils_tf.clip_by_value", "tensorflow.zeros", "tensorflow.cast", "tensorflow.cast", "cleverhans.utils_tf.assert_less_equal", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.cast", "tensorflow.cast", "tensorflow.equal", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.parse_params", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.generate"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "asserts", "=", "[", "]", "\n", "\n", "# If a data range was specified, check that the input was in that range", "\n", "if", "self", ".", "clip_min", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_greater_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "# Initialize loop variables", "\n", "", "if", "self", ".", "rand_init", ":", "\n", "      ", "eta", "=", "random_lp_vector", "(", "tf", ".", "shape", "(", "x", ")", ",", "self", ".", "ord", ",", "\n", "tf", ".", "cast", "(", "self", ".", "rand_init_eps", ",", "x", ".", "dtype", ")", ",", "\n", "dtype", "=", "x", ".", "dtype", ")", "\n", "", "else", ":", "\n", "      ", "eta", "=", "tf", ".", "zeros", "(", "tf", ".", "shape", "(", "x", ")", ")", "\n", "\n", "# Clip eta", "\n", "", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "# Apply masking", "\n", "eta", "=", "tf", ".", "multiply", "(", "eta", ",", "self", ".", "mask", ")", "\n", "adv_x", "=", "x", "+", "eta", "\n", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "or", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "adv_x", "=", "utils_tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "if", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "y", "=", "self", ".", "y_target", "\n", "targeted", "=", "True", "\n", "", "elif", "self", ".", "y", "is", "not", "None", ":", "\n", "      ", "y", "=", "self", ".", "y", "\n", "targeted", "=", "False", "\n", "", "else", ":", "\n", "      ", "model_preds", "=", "self", ".", "model", ".", "get_probs", "(", "x", ")", "\n", "preds_max", "=", "tf", ".", "reduce_max", "(", "model_preds", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "y", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "model_preds", ",", "preds_max", ")", ")", "\n", "y", "=", "tf", ".", "stop_gradient", "(", "y", ")", "\n", "targeted", "=", "False", "\n", "del", "model_preds", "\n", "\n", "", "y_kwarg", "=", "'y_target'", "if", "targeted", "else", "'y'", "\n", "\n", "fgm_params", "=", "{", "\n", "'eps'", ":", "self", ".", "eps_iter", ",", "\n", "y_kwarg", ":", "y", ",", "\n", "'ord'", ":", "self", ".", "ord", ",", "\n", "'clip_min'", ":", "self", ".", "clip_min", ",", "\n", "'clip_max'", ":", "self", ".", "clip_max", ",", "\n", "'clip_grad'", ":", "self", ".", "clip_grad", "\n", "}", "\n", "if", "self", ".", "ord", "==", "1", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"FGM is not a good inner loop step for PGD \"", "\n", "\" when ord=1, because ord=1 FGM changes only \"", "\n", "\" one pixel at a time. Use the SparseL1Descent \"", "\n", "\" attack instead, which allows fine-grained \"", "\n", "\" control over the sparsity of the gradient \"", "\n", "\" updates.\"", ")", "\n", "\n", "# Use getattr() to avoid errors in eager execution attacks", "\n", "", "FGM", "=", "self", ".", "FGM_CLASS", "(", "\n", "self", ".", "model", ",", "\n", "sess", "=", "getattr", "(", "self", ",", "'sess'", ",", "None", ")", ",", "\n", "dtypestr", "=", "self", ".", "dtypestr", ")", "\n", "\n", "def", "cond", "(", "i", ",", "_", ")", ":", "\n", "      ", "\"\"\"Iterate until requested number of iterations is completed\"\"\"", "\n", "return", "tf", ".", "less", "(", "i", ",", "self", ".", "nb_iter", ")", "\n", "\n", "", "def", "body", "(", "i", ",", "adv_x", ")", ":", "\n", "      ", "\"\"\"Do a projected gradient step\"\"\"", "\n", "adv_x", "=", "FGM", ".", "generate", "(", "adv_x", ",", "**", "fgm_params", ")", "\n", "\n", "# Clipping perturbation eta to self.ord norm ball", "\n", "eta", "=", "adv_x", "-", "x", "\n", "eta", "=", "tf", ".", "multiply", "(", "eta", ",", "self", ".", "mask", ")", "\n", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "adv_x", "=", "x", "+", "eta", "\n", "\n", "# Redo the clipping.", "\n", "# FGM already did it, but subtracting and re-adding eta can add some", "\n", "# small numerical error.", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "or", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "        ", "adv_x", "=", "utils_tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "return", "i", "+", "1", ",", "adv_x", "\n", "\n", "", "_", ",", "adv_x", "=", "tf", ".", "while_loop", "(", "cond", ",", "body", ",", "(", "tf", ".", "zeros", "(", "[", "]", ")", ",", "adv_x", ")", ",", "back_prop", "=", "True", ",", "\n", "maximum_iterations", "=", "self", ".", "nb_iter", ")", "\n", "\n", "# Asserts run only on CPU.", "\n", "# When multi-GPU eval code tries to force all PGD ops onto GPU, this", "\n", "# can cause an error.", "\n", "common_dtype", "=", "tf", ".", "float32", "\n", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "tf", ".", "cast", "(", "self", ".", "eps_iter", ",", "\n", "dtype", "=", "common_dtype", ")", ",", "\n", "tf", ".", "cast", "(", "self", ".", "eps", ",", "dtype", "=", "common_dtype", ")", ")", ")", "\n", "if", "self", ".", "ord", "==", "np", ".", "inf", "and", "self", ".", "clip_min", "is", "not", "None", ":", "\n", "# The 1e-6 is needed to compensate for numerical error.", "\n", "# Without the 1e-6 this fails when e.g. eps=.2, clip_min=.5,", "\n", "# clip_max=.7", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "tf", ".", "cast", "(", "self", ".", "eps", ",", "x", ".", "dtype", ")", ",", "\n", "1e-6", "+", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "\n", "x", ".", "dtype", ")", "\n", "-", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "sanity_checks", ":", "\n", "      ", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "adv_x", "=", "tf", ".", "identity", "(", "adv_x", ")", "\n", "\n", "", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_attacks.PatchProjectedGradientDescent.parse_params": [[178, 266], ["isinstance", "isinstance", "ValueError", "ValueError", "ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "0.3", ",", "\n", "eps_iter", "=", "0.05", ",", "\n", "nb_iter", "=", "10", ",", "\n", "y", "=", "None", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "rand_init", "=", "None", ",", "\n", "rand_init_eps", "=", "None", ",", "\n", "clip_grad", "=", "False", ",", "\n", "sanity_checks", "=", "True", ",", "\n", "mask", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float) maximum distortion of adversarial example\n                compared to original input\n    :param eps_iter: (optional float) step size for each attack iteration\n    :param nb_iter: (optional int) Number of attack iterations.\n    :param y: (optional) A tensor with the true labels.\n    :param y_target: (optional) A tensor with the labels to target. Leave\n                     y_target=None if y is also set. Labels should be\n                     one-hot-encoded.\n    :param ord: (optional) Order of the norm (mimics Numpy).\n                Possible values: np.inf, 1 or 2.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    :param rand_init: (optional) Start the gradient descent from a point chosen\n                      uniformly at random in the norm ball of radius\n                      rand_init_eps\n    :param rand_init_eps: (optional float) size of the norm ball from which\n                          the initial starting point is chosen. Defaults to eps\n    :param clip_grad: (optional bool) Ignore gradient components at positions\n                      where the input is already at the boundary of the domain,\n                      and the update step will get clipped out.\n    :param sanity_checks: bool Insert tf asserts checking values\n        (Some tests need to run with no sanity checks because the\n         tests intentionally configure the attack strangely)\n    \"\"\"", "\n", "\n", "# Save attack-specific parameters", "\n", "self", ".", "eps", "=", "eps", "\n", "if", "rand_init", "is", "None", ":", "\n", "      ", "rand_init", "=", "self", ".", "default_rand_init", "\n", "", "self", ".", "rand_init", "=", "rand_init", "\n", "if", "rand_init_eps", "is", "None", ":", "\n", "      ", "rand_init_eps", "=", "self", ".", "eps", "\n", "", "self", ".", "rand_init_eps", "=", "rand_init_eps", "\n", "\n", "self", ".", "eps_iter", "=", "eps_iter", "\n", "self", ".", "nb_iter", "=", "nb_iter", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "clip_grad", "=", "clip_grad", "\n", "\n", "# Numpy mask with batch size dimension", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "if", "isinstance", "(", "eps", ",", "float", ")", "and", "isinstance", "(", "eps_iter", ",", "float", ")", ":", "\n", "# If these are both known at compile time, we can check before anything", "\n", "# is run. If they are tf, we can't check them yet.", "\n", "      ", "assert", "eps_iter", "<=", "eps", ",", "(", "eps_iter", ",", "eps", ")", "\n", "\n", "", "if", "self", ".", "y", "is", "not", "None", "and", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must not set both y and y_target\"", ")", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", ",", "1", ",", "2", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be either np.inf, 1, or 2.\"", ")", "\n", "\n", "", "if", "self", ".", "clip_grad", "and", "(", "self", ".", "clip_min", "is", "None", "or", "self", ".", "clip_max", "is", "None", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must set clip_min and clip_max if clip_grad is set\"", ")", "\n", "\n", "", "self", ".", "sanity_checks", "=", "sanity_checks", "\n", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "", "", "", ""]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.binary_fpr_metric": [[28, 40], ["keras.backend.cast", "keras.backend.cast", "keras.backend.cast", "keras.backend.less", "keras.backend.greater", "keras.backend.less", "keras.backend.sum", "tensorflow.multiply", "keras.backend.epsilon", "keras.backend.sum", "keras.backend.sum", "tensorflow.multiply", "tensorflow.multiply"], "function", ["None"], ["def", "binary_fpr_metric", "(", "y_true", ",", "y_pred", ")", ":", "\n", "# Find locations", "\n", "    ", "true_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "y_true", ",", "0.5", ")", ",", "'float32'", ")", "\n", "pred_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "greater", "(", "y_pred", ",", "0.5", ")", ",", "'float32'", ")", "\n", "pred_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "y_pred", ",", "0.5", ")", ",", "'float32'", ")", "\n", "\n", "# Metric", "\n", "fpr", "=", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_negative_idx", ")", ")", "/", "(", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_negative_idx", ")", ")", "+", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_negative_idx", ",", "true_negative_idx", ")", ")", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "\n", "return", "fpr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.binary_tpr_metric": [[42, 54], ["keras.backend.cast", "keras.backend.cast", "keras.backend.cast", "keras.backend.greater", "keras.backend.greater", "keras.backend.less", "keras.backend.sum", "tensorflow.multiply", "keras.backend.epsilon", "keras.backend.sum", "keras.backend.sum", "tensorflow.multiply", "tensorflow.multiply"], "function", ["None"], ["", "def", "binary_tpr_metric", "(", "y_true", ",", "y_pred", ")", ":", "\n", "# Find locations", "\n", "    ", "true_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "greater", "(", "y_true", ",", "0.5", ")", ",", "'float32'", ")", "\n", "pred_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "greater", "(", "y_pred", ",", "0.5", ")", ",", "'float32'", ")", "\n", "pred_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "y_pred", ",", "0.5", ")", ",", "'float32'", ")", "\n", "\n", "# Metric", "\n", "tpr", "=", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_positive_idx", ")", ")", "/", "(", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_positive_idx", ")", ")", "+", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_negative_idx", ",", "true_positive_idx", ")", ")", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "\n", "return", "tpr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.fpr_metric": [[56, 68], ["keras.backend.cast", "keras.backend.cast", "keras.backend.cast", "keras.backend.equal", "keras.backend.equal", "keras.backend.equal", "keras.backend.sum", "keras.backend.argmax", "keras.backend.argmax", "keras.backend.argmax", "tensorflow.multiply", "keras.backend.epsilon", "keras.backend.sum", "keras.backend.sum", "tensorflow.multiply", "tensorflow.multiply"], "function", ["None"], ["", "def", "fpr_metric", "(", "y_true", ",", "y_pred", ")", ":", "\n", "# Find locations", "\n", "    ", "true_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_true", ",", "axis", "=", "-", "1", ")", ",", "0", ")", ",", "'float32'", ")", "\n", "pred_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_pred", ",", "axis", "=", "-", "1", ")", ",", "1", ")", ",", "'float32'", ")", "\n", "pred_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_pred", ",", "axis", "=", "-", "1", ")", ",", "0", ")", ",", "'float32'", ")", "\n", "\n", "# Metric", "\n", "fpr", "=", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_negative_idx", ")", ")", "/", "(", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_negative_idx", ")", ")", "+", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_negative_idx", ",", "true_negative_idx", ")", ")", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "\n", "return", "fpr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.tpr_metric": [[70, 82], ["keras.backend.cast", "keras.backend.cast", "keras.backend.cast", "keras.backend.equal", "keras.backend.equal", "keras.backend.equal", "keras.backend.sum", "keras.backend.argmax", "keras.backend.argmax", "keras.backend.argmax", "tensorflow.multiply", "keras.backend.epsilon", "keras.backend.sum", "keras.backend.sum", "tensorflow.multiply", "tensorflow.multiply"], "function", ["None"], ["", "def", "tpr_metric", "(", "y_true", ",", "y_pred", ")", ":", "\n", "# Find locations", "\n", "    ", "true_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_true", ",", "axis", "=", "-", "1", ")", ",", "1", ")", ",", "'float32'", ")", "\n", "pred_positive_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_pred", ",", "axis", "=", "-", "1", ")", ",", "1", ")", ",", "'float32'", ")", "\n", "pred_negative_idx", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "K", ".", "argmax", "(", "y_pred", ",", "axis", "=", "-", "1", ")", ",", "0", ")", ",", "'float32'", ")", "\n", "\n", "# Metric", "\n", "tpr", "=", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_positive_idx", ")", ")", "/", "(", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_positive_idx", ",", "true_positive_idx", ")", ")", "+", "K", ".", "sum", "(", "tf", ".", "multiply", "(", "pred_negative_idx", ",", "true_positive_idx", ")", ")", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "\n", "return", "tpr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.gaussian_patch_images": [[84, 104], ["numpy.copy", "range", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint"], "function", ["None"], ["", "def", "gaussian_patch_images", "(", "inputs", ",", "max_size", ",", "min_size", ",", "\n", "train_mean", ",", "train_std", ",", "eps", "=", "1e-7", ")", ":", "\n", "# Outputs", "\n", "    ", "outputs", "=", "np", ".", "copy", "(", "inputs", ")", "\n", "num_images", "=", "inputs", ".", "shape", "[", "0", "]", "\n", "# Patch each image", "\n", "corner_pixel", "=", "[", "np", ".", "random", ".", "randint", "(", "low", "=", "0.", ",", "high", "=", "inputs", ".", "shape", "[", "1", "]", "-", "max_size", "[", "0", "]", ",", "size", "=", "(", "num_images", ",", ")", ")", ",", "\n", "np", ".", "random", ".", "randint", "(", "low", "=", "0.", ",", "high", "=", "inputs", ".", "shape", "[", "2", "]", "-", "max_size", "[", "1", "]", ",", "size", "=", "(", "num_images", ",", ")", ")", "]", "\n", "patch_size", "=", "[", "np", ".", "random", ".", "randint", "(", "low", "=", "min_size", "[", "0", "]", ",", "high", "=", "max_size", "[", "0", "]", "+", "1", ",", "size", "=", "(", "num_images", ",", ")", ")", ",", "\n", "np", ".", "random", ".", "randint", "(", "low", "=", "min_size", "[", "1", "]", ",", "high", "=", "max_size", "[", "1", "]", "+", "1", ",", "size", "=", "(", "num_images", ",", ")", ")", "]", "\n", "\n", "# In a loop", "\n", "for", "image_idx", "in", "range", "(", "num_images", ")", ":", "\n", "        ", "outputs", "[", "image_idx", ",", "\n", "corner_pixel", "[", "0", "]", "[", "image_idx", "]", ":", "corner_pixel", "[", "0", "]", "[", "image_idx", "]", "+", "patch_size", "[", "0", "]", "[", "image_idx", "]", ",", "\n", "corner_pixel", "[", "1", "]", "[", "image_idx", "]", ":", "corner_pixel", "[", "1", "]", "[", "image_idx", "]", "+", "patch_size", "[", "1", "]", "[", "image_idx", "]", ",", "\n", ":", "]", "=", "(", "np", ".", "random", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "256", ",", "size", "=", "(", "patch_size", "[", "0", "]", "[", "image_idx", "]", ",", "\n", "patch_size", "[", "1", "]", "[", "image_idx", "]", ",", "3", ")", ")", "-", "train_mean", ")", "/", "(", "train_std", "+", "1e-7", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.attack_images": [[106, 129], ["int", "numpy.empty", "tqdm.tqdm", "numpy.ceil", "range", "numpy.append", "tensor_out.eval"], "function", ["None"], ["", "def", "attack_images", "(", "inputs", ",", "labels", ",", "\n", "tensor_out", ",", "tensor_in", ",", "tensor_labels", ",", "\n", "batch_size", ",", "sess", ",", "masked", ",", "mask_tensor", ",", "\n", "mask_numpy", ")", ":", "\n", "# Compute number of batches", "\n", "    ", "num_batches", "=", "int", "(", "np", ".", "ceil", "(", "inputs", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "\n", "# Run attack in batches", "\n", "adv", "=", "np", ".", "empty", "(", "(", "0", ",", ")", "+", "(", "inputs", ".", "shape", "[", "1", "]", ",", "inputs", ".", "shape", "[", "2", "]", ",", "inputs", ".", "shape", "[", "3", "]", ")", ")", "\n", "for", "batch_idx", "in", "tqdm", "(", "range", "(", "num_batches", ")", ")", ":", "\n", "# Construct dictionary", "\n", "        ", "if", "masked", ":", "\n", "            ", "feed_dict", "=", "{", "tensor_in", ":", "inputs", "[", "batch_idx", "*", "batch_size", ":", "(", "batch_idx", "+", "1", ")", "*", "batch_size", "]", ",", "\n", "tensor_labels", ":", "labels", "[", "batch_idx", "*", "batch_size", ":", "(", "batch_idx", "+", "1", ")", "*", "batch_size", "]", ",", "\n", "mask_tensor", ":", "mask_numpy", "}", "\n", "", "else", ":", "\n", "            ", "feed_dict", "=", "{", "tensor_in", ":", "inputs", "[", "batch_idx", "*", "batch_size", ":", "(", "batch_idx", "+", "1", ")", "*", "batch_size", "]", ",", "\n", "tensor_labels", ":", "labels", "[", "batch_idx", "*", "batch_size", ":", "(", "batch_idx", "+", "1", ")", "*", "batch_size", "]", "}", "\n", "# Extract adversarial samples", "\n", "", "adv", "=", "np", ".", "append", "(", "adv", ",", "tensor_out", ".", "eval", "(", "session", "=", "sess", ",", "feed_dict", "=", "feed_dict", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Return", "\n", "", "return", "adv", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.get_residual": [[131, 153], ["tqdm.tqdm", "range", "numpy.any", "numpy.isnan", "numpy.copy", "skimage.restoration.denoise_wavelet", "numpy.copy", "skimage.restoration.denoise_wavelet"], "function", ["None"], ["", "def", "get_residual", "(", "inputs", ",", "train_mean", ",", "train_std", ",", "\n", "sigma", ",", "scale", "=", "255.", ",", "eps", "=", "1e-7", ",", "method", "=", "'wavelet'", ")", ":", "\n", "# Copy", "\n", "    ", "filtered", "=", "(", "np", ".", "copy", "(", "inputs", ")", "*", "(", "train_std", "+", "eps", ")", "+", "train_mean", ")", "/", "scale", "\n", "# Denoise with wavelet (or other methods)", "\n", "for", "image_idx", "in", "tqdm", "(", "range", "(", "filtered", ".", "shape", "[", "0", "]", ")", ")", ":", "\n", "        ", "filtered", "[", "image_idx", "]", "=", "(", "denoise_wavelet", "(", "filtered", "[", "image_idx", "]", ",", "sigma", "=", "sigma", ",", "\n", "method", "=", "'BayesShrink'", ",", "multichannel", "=", "True", ",", "\n", "convert2ycbcr", "=", "True", ")", "*", "255.", "-", "train_mean", ")", "/", "(", "train_std", "+", "1e-7", ")", "\n", "# If any nan value is present, then image is BW and needs to be run without YCBCR conversion", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "filtered", "[", "image_idx", "]", ")", ")", ":", "\n", "# Restore and recompute", "\n", "            ", "filtered", "[", "image_idx", "]", "=", "(", "np", ".", "copy", "(", "inputs", "[", "image_idx", "]", ")", "*", "(", "train_std", "+", "eps", ")", "+", "train_mean", ")", "/", "scale", "\n", "filtered", "[", "image_idx", "]", "=", "(", "denoise_wavelet", "(", "filtered", "[", "image_idx", "]", ",", "sigma", "=", "sigma", ",", "\n", "method", "=", "'BayesShrink'", ",", "multichannel", "=", "True", ",", "\n", "convert2ycbcr", "=", "False", ")", "*", "255.", "-", "train_mean", ")", "/", "(", "train_std", "+", "1e-7", ")", "\n", "# Estimate residuals", "\n", "", "", "residuals", "=", "inputs", "-", "filtered", "\n", "\n", "return", "residuals", ",", "filtered", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.train_classifier": [[156, 200], ["aux_residual_classifier.ResidueClassifier", "keras.optimizers.Adam", "classifier.compile", "keras.callbacks.ModelCheckpoint", "keras.callbacks.EarlyStopping", "classifier.fit", "classifier.load_weights"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.ResidueClassifier"], ["", "def", "train_classifier", "(", "params", ")", ":", "\n", "# Unpack everything", "\n", "    ", "input_w", "=", "params", "[", "'input_w'", "]", "\n", "input_h", "=", "params", "[", "'input_h'", "]", "\n", "input_c", "=", "params", "[", "'input_c'", "]", "\n", "train_data", "=", "params", "[", "'train_data'", "]", "\n", "val_data", "=", "params", "[", "'val_data'", "]", "\n", "train_labels", "=", "params", "[", "'train_labels'", "]", "\n", "val_labels", "=", "params", "[", "'val_labels'", "]", "\n", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "num_epochs", "=", "params", "[", "'num_epochs'", "]", "\n", "sigma", "=", "params", "[", "'sigma'", "]", "\n", "restore", "=", "params", "[", "'restore'", "]", "\n", "\n", "# Construct and train the detection NN", "\n", "classifier", ",", "logit_exposer", "=", "ResidueClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "weight_reg", "=", "5e-3", ")", "\n", "\n", "# Loss", "\n", "loss", "=", "'categorical_crossentropy'", "\n", "metrics", "=", "[", "'acc'", ",", "fpr_metric", ",", "tpr_metric", "]", "\n", "# Optimizer", "\n", "optimizer", "=", "Adam", "(", "lr", "=", "0.001", ",", "amsgrad", "=", "True", ")", "\n", "# Compile", "\n", "classifier", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "loss", ",", "metrics", "=", "metrics", ")", "\n", "# Weight file", "\n", "weight_file", "=", "'weights_best_sigma%.3f.h5'", "%", "sigma", "\n", "# Callbacks", "\n", "best_model", "=", "ModelCheckpoint", "(", "weight_file", ",", "\n", "verbose", "=", "0", ",", "save_best_only", "=", "True", ",", "save_weights_only", "=", "True", ",", "period", "=", "5", ",", "\n", "monitor", "=", "'val_acc'", ")", "\n", "early_stop", "=", "EarlyStopping", "(", "monitor", "=", "'val_acc'", ",", "min_delta", "=", "0.01", ",", "patience", "=", "100", ")", "\n", "# Train or not", "\n", "if", "num_epochs", ">", "0.", ":", "\n", "        ", "_", "=", "classifier", ".", "fit", "(", "train_data", ",", "train_labels", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "num_epochs", ",", "\n", "validation_data", "=", "(", "val_data", ",", "val_labels", ")", ",", "\n", "callbacks", "=", "[", "best_model", ",", "early_stop", "]", ",", "\n", "shuffle", "=", "True", ",", "verbose", "=", "2", ")", "\n", "# Load best weights", "\n", "", "if", "restore", ":", "\n", "        ", "classifier", ".", "load_weights", "(", "weight_file", ")", "\n", "\n", "", "return", "classifier", ",", "logit_exposer", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.evaluate_classifier": [[202, 211], ["classifier.predict", "sklearn.metrics.confusion_matrix", "numpy.argmax", "numpy.argmax"], "function", ["None"], ["", "def", "evaluate_classifier", "(", "classifier", ",", "inputs", ",", "labels", ")", ":", "\n", "# Predict", "\n", "    ", "labels_hat", "=", "classifier", ".", "predict", "(", "inputs", ")", "\n", "# Evaluate", "\n", "C", "=", "confusion_matrix", "(", "np", ".", "argmax", "(", "labels", ",", "axis", "=", "-", "1", ")", ",", "np", ".", "argmax", "(", "labels_hat", ",", "axis", "=", "-", "1", ")", ")", "\n", "tpr", "=", "C", "[", "1", ",", "1", "]", "/", "(", "C", "[", "1", ",", "1", "]", "+", "C", "[", "1", ",", "0", "]", ")", "\n", "fpr", "=", "C", "[", "0", ",", "1", "]", "/", "(", "C", "[", "0", ",", "1", "]", "+", "C", "[", "0", ",", "0", "]", ")", "\n", "\n", "return", "C", ",", "tpr", ",", "fpr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.evaluate_joint_classifier": [[213, 251], ["numpy.zeros", "classifier.predict", "aux_evaluation.get_residual", "detector.predict", "numpy.concatenate", "numpy.sort", "numpy.where", "numpy.max", "numpy.where", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_evaluation.get_residual"], ["", "def", "evaluate_joint_classifier", "(", "classifier", ",", "detector", ",", "kappa", ",", "\n", "sigma", ",", "train_mean", ",", "train_std", ",", "\n", "inputs", ")", ":", "\n", "# Initially all samples are not detected", "\n", "    ", "labels_hat", "=", "np", ".", "zeros", "(", "(", "inputs", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "# Get classification logits", "\n", "class_logits", "=", "classifier", ".", "predict", "(", "inputs", ")", "\n", "\n", "# Compute image residuals", "\n", "residuals", ",", "_", "=", "get_residual", "(", "inputs", ",", "train_mean", ",", "train_std", ",", "\n", "sigma", ",", "scale", "=", "255.", ",", "eps", "=", "1e-7", ",", "method", "=", "'wavelet'", ")", "\n", "\n", "# Get detection logits", "\n", "det_logits", "=", "detector", ".", "predict", "(", "residuals", ")", "\n", "det_logit", "=", "det_logits", "[", ":", ",", "1", "]", "-", "det_logits", "[", ":", ",", "0", "]", "\n", "\n", "# Mark points where detection is triggered    ", "\n", "det_idx", "=", "np", ".", "where", "(", "det_logit", ">", "0", ")", "[", "0", "]", "\n", "labels_hat", "[", "det_idx", "]", "=", "1", "\n", "\n", "# Construct additional logit", "\n", "new_logit", "=", "(", "1", "+", "det_logit", ")", "*", "np", ".", "max", "(", "class_logits", ",", "axis", "=", "-", "1", ")", "\n", "# Merged logits", "\n", "merged_logits", "=", "np", ".", "concatenate", "(", "(", "class_logits", ",", "new_logit", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "# Sort and evaluate difference between logits", "\n", "sorted_logits", "=", "np", ".", "sort", "(", "merged_logits", ",", "axis", "=", "-", "1", ")", "\n", "# Confidence", "\n", "confidence", "=", "sorted_logits", "[", ":", ",", "-", "1", "]", "-", "sorted_logits", "[", ":", ",", "2", "]", "\n", "# Mark points where detection fails but confidence is not sufficient", "\n", "det_confidence_idx", "=", "np", ".", "where", "(", "(", "det_logit", "<=", "0", ")", "&", "(", "confidence", "<", "kappa", ")", ")", "[", "0", "]", "\n", "labels_hat", "[", "det_confidence_idx", "]", "=", "1", "\n", "\n", "# Construct a sigmoid probability", "\n", "det_prob", "=", "1", "-", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "confidence", "-", "kappa", ")", ")", "\n", "\n", "return", "labels_hat", ",", "det_prob", "", "", ""]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.BinaryResidueClassifier": [[28, 72], ["keras.regularizers.l2", "keras.layers.Input", "keras.models.Model", "keras.models.Model", "keras.models.Model.summary", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation"], "function", ["None"], ["def", "BinaryResidueClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "\n", "weight_reg", ")", ":", "\n", "\n", "# Weight regularizers", "\n", "    ", "l2_reg", "=", "l2", "(", "weight_reg", ")", "\n", "\n", "# Input", "\n", "input_img", "=", "Input", "(", "shape", "=", "(", "input_h", ",", "input_w", ",", "input_c", ")", ")", "\n", "\n", "# Block 1", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv1'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "input_img", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block1_pool'", ")", "(", "x", ")", "\n", "\n", "# Block 2", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block3_conv2'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block3_pool'", ")", "(", "x", ")", "\n", "\n", "# Flatten", "\n", "encoded", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "# FC", "\n", "encoded", "=", "Dense", "(", "64", ",", "activation", "=", "'relu'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "encoded", "=", "Dropout", "(", "rate", "=", "0.3", ")", "(", "encoded", ")", "\n", "\n", "# Output logits", "\n", "encoded", "=", "Dense", "(", "1", ",", "activation", "=", "'linear'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "exposed_logits", "=", "encoded", "\n", "\n", "# Output probabilities", "\n", "encoded", "=", "Activation", "(", "activation", "=", "'softmax'", ")", "(", "encoded", ")", "\n", "\n", "# Model", "\n", "classifier", "=", "Model", "(", "input_img", ",", "encoded", ")", "\n", "logit_exposer", "=", "Model", "(", "input_img", ",", "exposed_logits", ")", "\n", "classifier", ".", "summary", "(", ")", "\n", "\n", "return", "classifier", ",", "logit_exposer", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.ResidueLogitClassifier": [[74, 117], ["keras.regularizers.l2", "keras.layers.Input", "keras.layers.Input", "keras.models.Model", "keras.models.Model.summary", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Dropout", "keras.layers.Concatenate", "keras.layers.Dense"], "function", ["None"], ["", "def", "ResidueLogitClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "\n", "weight_reg", ")", ":", "\n", "\n", "# Weight regularizers", "\n", "    ", "l2_reg", "=", "l2", "(", "weight_reg", ")", "\n", "\n", "# Input", "\n", "input_img", "=", "Input", "(", "shape", "=", "(", "input_h", ",", "input_w", ",", "input_c", ")", ")", "\n", "input_logits", "=", "Input", "(", "shape", "=", "(", "10", ",", ")", ")", "\n", "\n", "# Block 1", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv1'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "input_img", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block1_pool'", ")", "(", "x", ")", "\n", "\n", "# Block 2", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block3_conv2'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block3_pool'", ")", "(", "x", ")", "\n", "\n", "# Flatten", "\n", "encoded", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "# FC", "\n", "encoded", "=", "Dense", "(", "64", ",", "activation", "=", "'relu'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "encoded", "=", "Dropout", "(", "rate", "=", "0.3", ")", "(", "encoded", ")", "\n", "\n", "# Merge with logits", "\n", "encoded", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "encoded", ",", "input_logits", "]", ")", "\n", "\n", "# Output (logistic)", "\n", "encoded", "=", "Dense", "(", "2", ",", "activation", "=", "'softmax'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "\n", "# Model", "\n", "classifier", "=", "Model", "(", "[", "input_img", ",", "input_logits", "]", ",", "encoded", ")", "\n", "classifier", ".", "summary", "(", ")", "\n", "\n", "return", "classifier", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.SmallResidueClassifier": [[119, 158], ["keras.regularizers.l2", "keras.layers.Input", "keras.models.Model", "keras.models.Model", "keras.models.Model.summary", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation"], "function", ["None"], ["", "def", "SmallResidueClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "\n", "weight_reg", ")", ":", "\n", "\n", "# Weight regularizers", "\n", "    ", "l2_reg", "=", "l2", "(", "weight_reg", ")", "\n", "\n", "# Input", "\n", "input_img", "=", "Input", "(", "shape", "=", "(", "input_h", ",", "input_w", ",", "input_c", ")", ")", "\n", "\n", "# Filter image", "\n", "#    x = AvgPool2D(pool_size=(2, 2))(input_img)", "\n", "\n", "# Block 1", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv1'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "input_img", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block1_pool'", ")", "(", "x", ")", "\n", "\n", "# Flatten", "\n", "encoded", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "# FC", "\n", "encoded", "=", "Dense", "(", "32", ",", "activation", "=", "'relu'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "encoded", "=", "Dropout", "(", "rate", "=", "0.3", ")", "(", "encoded", ")", "\n", "\n", "# Output logits", "\n", "encoded", "=", "Dense", "(", "2", ",", "activation", "=", "'linear'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "exposed_logits", "=", "encoded", "\n", "\n", "# Output probabilities", "\n", "encoded", "=", "Activation", "(", "'softmax'", ")", "(", "encoded", ")", "\n", "\n", "# Model", "\n", "classifier", "=", "Model", "(", "input_img", ",", "encoded", ")", "\n", "logit_exposer", "=", "Model", "(", "input_img", ",", "exposed_logits", ")", "\n", "classifier", ".", "summary", "(", ")", "\n", "\n", "return", "classifier", ",", "logit_exposer", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.ResidueClassifier": [[160, 204], ["keras.regularizers.l2", "keras.layers.Input", "keras.models.Model", "keras.models.Model", "keras.models.Model.summary", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation"], "function", ["None"], ["", "def", "ResidueClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "\n", "weight_reg", ")", ":", "\n", "\n", "# Weight regularizers", "\n", "    ", "l2_reg", "=", "l2", "(", "weight_reg", ")", "\n", "\n", "# Input", "\n", "input_img", "=", "Input", "(", "shape", "=", "(", "input_h", ",", "input_w", ",", "input_c", ")", ")", "\n", "\n", "# Block 1", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv1'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "input_img", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block1_pool'", ")", "(", "x", ")", "\n", "\n", "# Block 2", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block3_conv2'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block3_pool'", ")", "(", "x", ")", "\n", "\n", "# Flatten", "\n", "encoded", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "# FC", "\n", "encoded", "=", "Dense", "(", "64", ",", "activation", "=", "'relu'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "encoded", "=", "Dropout", "(", "rate", "=", "0.3", ")", "(", "encoded", ")", "\n", "\n", "# Output logits", "\n", "encoded", "=", "Dense", "(", "2", ",", "activation", "=", "'linear'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "exposed_logits", "=", "encoded", "\n", "\n", "# Output probabilities", "\n", "encoded", "=", "Activation", "(", "'softmax'", ")", "(", "encoded", ")", "\n", "\n", "# Model", "\n", "classifier", "=", "Model", "(", "input_img", ",", "encoded", ")", "\n", "logit_exposer", "=", "Model", "(", "input_img", ",", "exposed_logits", ")", "\n", "classifier", ".", "summary", "(", ")", "\n", "\n", "return", "classifier", ",", "logit_exposer", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.None.aux_residual_classifier.UnknownClassifier": [[206, 254], ["keras.regularizers.l2", "keras.layers.Input", "keras.models.Model", "keras.models.Model.summary", "keras.layers.Conv2D", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Conv2D", "keras.layers.Conv2D", "keras.layers.MaxPool2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Dropout", "keras.layers.Dense"], "function", ["None"], ["", "def", "UnknownClassifier", "(", "input_w", ",", "input_h", ",", "input_c", ",", "\n", "weight_reg", ")", ":", "\n", "# Weight regularizers", "\n", "    ", "l2_reg", "=", "l2", "(", "weight_reg", ")", "\n", "\n", "# Input", "\n", "input_img", "=", "Input", "(", "shape", "=", "(", "input_h", ",", "input_w", ",", "input_c", ")", ")", "\n", "\n", "# Block 1", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv1'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "input_img", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block1_conv2'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block1_pool'", ")", "(", "x", ")", "\n", "\n", "# Block 2", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block3_conv2'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "activation", "=", "'relu'", ",", "\n", "padding", "=", "'same'", ",", "\n", "name", "=", "'block3_conv3'", ",", "\n", "kernel_regularizer", "=", "l2_reg", ")", "(", "x", ")", "\n", "x", "=", "MaxPool2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'block3_pool'", ")", "(", "x", ")", "\n", "\n", "# Flatten", "\n", "encoded", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "# FC", "\n", "encoded", "=", "Dense", "(", "64", ",", "activation", "=", "'relu'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "encoded", "=", "Dropout", "(", "rate", "=", "0.3", ")", "(", "encoded", ")", "\n", "\n", "# Output", "\n", "encoded", "=", "Dense", "(", "2", ",", "activation", "=", "'softmax'", ",", "kernel_regularizer", "=", "l2_reg", ")", "(", "encoded", ")", "\n", "\n", "# Model", "\n", "classifier", "=", "Model", "(", "input_img", ",", "encoded", ")", "\n", "classifier", ".", "summary", "(", ")", "\n", "\n", "return", "classifier", "", "", ""]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.merge_and_generate_labels": [[28, 49], ["numpy.asarray", "print", "X_pos.reshape.reshape", "numpy.asarray", "print", "X_neg.reshape.reshape", "numpy.concatenate", "numpy.concatenate", "y.reshape.reshape", "numpy.ones", "numpy.zeros"], "function", ["None"], ["def", "merge_and_generate_labels", "(", "X_pos", ",", "X_neg", ")", ":", "\n", "    ", "\"\"\"\n    merge positve and nagative artifact and generate labels\n    :param X_pos: positive samples\n    :param X_neg: negative samples\n    :return: X: merged samples, 2D ndarray\n             y: generated labels (0/1): 2D ndarray same size as X\n    \"\"\"", "\n", "X_pos", "=", "np", ".", "asarray", "(", "X_pos", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "print", "(", "\"X_pos: \"", ",", "X_pos", ".", "shape", ")", "\n", "X_pos", "=", "X_pos", ".", "reshape", "(", "(", "X_pos", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n", "X_neg", "=", "np", ".", "asarray", "(", "X_neg", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "print", "(", "\"X_neg: \"", ",", "X_neg", ".", "shape", ")", "\n", "X_neg", "=", "X_neg", ".", "reshape", "(", "(", "X_neg", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n", "X", "=", "np", ".", "concatenate", "(", "(", "X_pos", ",", "X_neg", ")", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "(", "np", ".", "ones", "(", "X_pos", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "zeros", "(", "X_neg", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "y", "=", "y", ".", "reshape", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_kd": [[51, 131], ["print", "util.get_deep_representations", "util.get_deep_representations", "util.get_deep_representations", "util.get_deep_representations", "print", "range", "warnings.warn", "print", "range", "print", "model.predict_classes", "model.predict_classes", "model.predict_classes", "print", "util.score_samples", "util.score_samples", "util.score_samples", "print", "print", "print", "numpy.concatenate", "extract_characteristics.merge_and_generate_labels", "sklearn.neighbors.KernelDensity().fit", "numpy.where", "sklearn.neighbors.KernelDensity", "Y_train.argmax"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_deep_representations", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_deep_representations", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_deep_representations", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_deep_representations", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_samples", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_samples", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_samples", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.merge_and_generate_labels"], ["", "def", "get_kd", "(", "model", ",", "X_train", ",", "Y_train", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", ":", "\n", "    ", "\"\"\"\n    Get kernel density scores\n    :param model: \n    :param X_train: \n    :param Y_train: \n    :param X_test: \n    :param X_test_noisy: \n    :param X_test_adv: \n    :return: artifacts: positive and negative examples with kd values, \n            labels: adversarial (label: 1) and normal/noisy (label: 0) examples\n    \"\"\"", "\n", "# Get deep feature representations", "\n", "print", "(", "'Getting deep feature representations...'", ")", "\n", "X_train_features", "=", "get_deep_representations", "(", "model", ",", "X_train", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "X_test_normal_features", "=", "get_deep_representations", "(", "model", ",", "X_test", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "X_test_noisy_features", "=", "get_deep_representations", "(", "model", ",", "X_test_noisy", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "X_test_adv_features", "=", "get_deep_representations", "(", "model", ",", "X_test_adv", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "# Train one KDE per class", "\n", "print", "(", "'Training KDEs...'", ")", "\n", "class_inds", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "Y_train", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "class_inds", "[", "i", "]", "=", "np", ".", "where", "(", "Y_train", ".", "argmax", "(", "axis", "=", "1", ")", "==", "i", ")", "[", "0", "]", "\n", "", "kdes", "=", "{", "}", "\n", "warnings", ".", "warn", "(", "\"Using pre-set kernel bandwidths that were determined \"", "\n", "\"optimal for the specific CNN models of the paper. If you've \"", "\n", "\"changed your model, you'll need to re-optimize the \"", "\n", "\"bandwidth.\"", ")", "\n", "print", "(", "'bandwidth %.4f for %s'", "%", "(", "BANDWIDTHS", "[", "args", ".", "dataset", "]", ",", "args", ".", "dataset", ")", ")", "\n", "for", "i", "in", "range", "(", "Y_train", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "kdes", "[", "i", "]", "=", "KernelDensity", "(", "kernel", "=", "'gaussian'", ",", "\n", "bandwidth", "=", "BANDWIDTHS", "[", "args", ".", "dataset", "]", ")", ".", "fit", "(", "X_train_features", "[", "class_inds", "[", "i", "]", "]", ")", "\n", "# Get model predictions", "\n", "", "print", "(", "'Computing model predictions...'", ")", "\n", "preds_test_normal", "=", "model", ".", "predict_classes", "(", "X_test", ",", "verbose", "=", "0", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "preds_test_noisy", "=", "model", ".", "predict_classes", "(", "X_test_noisy", ",", "verbose", "=", "0", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "preds_test_adv", "=", "model", ".", "predict_classes", "(", "X_test_adv", ",", "verbose", "=", "0", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "# Get density estimates", "\n", "print", "(", "'computing densities...'", ")", "\n", "densities_normal", "=", "score_samples", "(", "\n", "kdes", ",", "\n", "X_test_normal_features", ",", "\n", "preds_test_normal", "\n", ")", "\n", "densities_noisy", "=", "score_samples", "(", "\n", "kdes", ",", "\n", "X_test_noisy_features", ",", "\n", "preds_test_noisy", "\n", ")", "\n", "densities_adv", "=", "score_samples", "(", "\n", "kdes", ",", "\n", "X_test_adv_features", ",", "\n", "preds_test_adv", "\n", ")", "\n", "\n", "print", "(", "\"densities_normal:\"", ",", "densities_normal", ".", "shape", ")", "\n", "print", "(", "\"densities_adv:\"", ",", "densities_adv", ".", "shape", ")", "\n", "print", "(", "\"densities_noisy:\"", ",", "densities_noisy", ".", "shape", ")", "\n", "\n", "## skip the normalization, you may want to try different normalizations later", "\n", "## so at this step, just save the raw values", "\n", "# densities_normal_z, densities_adv_z, densities_noisy_z = normalize(", "\n", "#     densities_normal,", "\n", "#     densities_adv,", "\n", "#     densities_noisy", "\n", "# )", "\n", "\n", "densities_pos", "=", "densities_adv", "\n", "densities_neg", "=", "np", ".", "concatenate", "(", "(", "densities_normal", ",", "densities_noisy", ")", ")", "\n", "artifacts", ",", "labels", "=", "merge_and_generate_labels", "(", "densities_pos", ",", "densities_neg", ")", "\n", "\n", "return", "artifacts", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_bu": [[132, 172], ["print", "util.get_mc_predictions().var().mean", "util.get_mc_predictions().var().mean", "util.get_mc_predictions().var().mean", "print", "print", "print", "numpy.concatenate", "extract_characteristics.merge_and_generate_labels", "util.get_mc_predictions().var", "util.get_mc_predictions().var", "util.get_mc_predictions().var", "util.get_mc_predictions", "util.get_mc_predictions", "util.get_mc_predictions"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.merge_and_generate_labels", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_mc_predictions", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_mc_predictions", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_mc_predictions"], ["", "def", "get_bu", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", ":", "\n", "    ", "\"\"\"\n    Get Bayesian uncertainty scores\n    :param model: \n    :param X_train: \n    :param Y_train: \n    :param X_test: \n    :param X_test_noisy: \n    :param X_test_adv: \n    :return: artifacts: positive and negative examples with bu values, \n            labels: adversarial (label: 1) and normal/noisy (label: 0) examples\n    \"\"\"", "\n", "print", "(", "'Getting Monte Carlo dropout variance predictions...'", ")", "\n", "uncerts_normal", "=", "get_mc_predictions", "(", "model", ",", "X_test", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", ".", "var", "(", "axis", "=", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "uncerts_noisy", "=", "get_mc_predictions", "(", "model", ",", "X_test_noisy", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", ".", "var", "(", "axis", "=", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "uncerts_adv", "=", "get_mc_predictions", "(", "model", ",", "X_test_adv", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", ".", "var", "(", "axis", "=", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "\n", "print", "(", "\"uncerts_normal:\"", ",", "uncerts_normal", ".", "shape", ")", "\n", "print", "(", "\"uncerts_noisy:\"", ",", "uncerts_noisy", ".", "shape", ")", "\n", "print", "(", "\"uncerts_adv:\"", ",", "uncerts_adv", ".", "shape", ")", "\n", "\n", "## skip the normalization, you may want to try different normalizations later", "\n", "## so at this step, just save the raw values", "\n", "# uncerts_normal_z, uncerts_adv_z, uncerts_noisy_z = normalize(", "\n", "#     uncerts_normal,", "\n", "#     uncerts_adv,", "\n", "#     uncerts_noisy", "\n", "# )", "\n", "\n", "uncerts_pos", "=", "uncerts_adv", "\n", "uncerts_neg", "=", "np", ".", "concatenate", "(", "(", "uncerts_normal", ",", "uncerts_noisy", ")", ")", "\n", "artifacts", ",", "labels", "=", "merge_and_generate_labels", "(", "uncerts_pos", ",", "uncerts_neg", ")", "\n", "\n", "return", "artifacts", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_lid": [[173, 205], ["print", "util.get_lids_random_batch", "print", "print", "print", "numpy.concatenate", "extract_characteristics.merge_and_generate_labels"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_lids_random_batch", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.merge_and_generate_labels"], ["", "def", "get_lid", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "k", "=", "10", ",", "batch_size", "=", "100", ",", "dataset", "=", "'mnist'", ")", ":", "\n", "    ", "\"\"\"\n    Get local intrinsic dimensionality\n    :param model: \n    :param X_train: \n    :param Y_train: \n    :param X_test: \n    :param X_test_noisy: \n    :param X_test_adv: \n    :return: artifacts: positive and negative examples with lid values, \n            labels: adversarial (label: 1) and normal/noisy (label: 0) examples\n    \"\"\"", "\n", "print", "(", "'Extract local intrinsic dimensionality: k = %s'", "%", "k", ")", "\n", "lids_normal", ",", "lids_noisy", ",", "lids_adv", "=", "get_lids_random_batch", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "\n", "X_test_adv", ",", "dataset", ",", "k", ",", "batch_size", ")", "\n", "print", "(", "\"lids_normal:\"", ",", "lids_normal", ".", "shape", ")", "\n", "print", "(", "\"lids_noisy:\"", ",", "lids_noisy", ".", "shape", ")", "\n", "print", "(", "\"lids_adv:\"", ",", "lids_adv", ".", "shape", ")", "\n", "\n", "## skip the normalization, you may want to try different normalizations later", "\n", "## so at this step, just save the raw values", "\n", "# lids_normal_z, lids_adv_z, lids_noisy_z = normalize(", "\n", "#     lids_normal,", "\n", "#     lids_adv,", "\n", "#     lids_noisy", "\n", "# )", "\n", "\n", "lids_pos", "=", "lids_adv", "\n", "lids_neg", "=", "np", ".", "concatenate", "(", "(", "lids_normal", ",", "lids_noisy", ")", ")", "\n", "artifacts", ",", "labels", "=", "merge_and_generate_labels", "(", "lids_pos", ",", "lids_neg", ")", "\n", "\n", "return", "artifacts", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_kmeans": [[206, 240], ["print", "util.get_kmeans_random_batch", "print", "print", "print", "numpy.concatenate", "extract_characteristics.merge_and_generate_labels"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_kmeans_random_batch", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.merge_and_generate_labels"], ["", "def", "get_kmeans", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "k", "=", "10", ",", "batch_size", "=", "100", ",", "dataset", "=", "'mnist'", ")", ":", "\n", "    ", "\"\"\"\n    Calculate the average distance to k nearest neighbours as a feature.\n    This is used to compare density vs LID. Why density doesn't work?\n    :param model: \n    :param X_train: \n    :param Y_train: \n    :param X_test: \n    :param X_test_noisy: \n    :param X_test_adv: \n    :return: artifacts: positive and negative examples with lid values, \n            labels: adversarial (label: 1) and normal/noisy (label: 0) examples\n    \"\"\"", "\n", "print", "(", "'Extract k means feature: k = %s'", "%", "k", ")", "\n", "kms_normal", ",", "kms_noisy", ",", "kms_adv", "=", "get_kmeans_random_batch", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "\n", "X_test_adv", ",", "dataset", ",", "k", ",", "batch_size", ",", "\n", "pca", "=", "True", ")", "\n", "print", "(", "\"kms_normal:\"", ",", "kms_normal", ".", "shape", ")", "\n", "print", "(", "\"kms_noisy:\"", ",", "kms_noisy", ".", "shape", ")", "\n", "print", "(", "\"kms_adv:\"", ",", "kms_adv", ".", "shape", ")", "\n", "\n", "## skip the normalization, you may want to try different normalizations later", "\n", "## so at this step, just save the raw values", "\n", "# kms_normal_z, kms_noisy_z, kms_adv_z = normalize(", "\n", "#     kms_normal,", "\n", "#     kms_noisy,", "\n", "#     kms_adv", "\n", "# )", "\n", "\n", "kms_pos", "=", "kms_adv", "\n", "kms_neg", "=", "np", ".", "concatenate", "(", "(", "kms_normal", ",", "kms_noisy", ")", ")", "\n", "artifacts", ",", "labels", "=", "merge_and_generate_labels", "(", "kms_pos", ",", "kms_neg", ")", "\n", "\n", "return", "artifacts", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.main": [[241, 377], ["os.path.join", "os.path.isfile", "os.path.join", "os.path.isfile", "print", "keras.models.load_model", "util.get_data", "print", "zip", "keras.models.load_model.predict_classes", "print", "print", "print", "print", "NotImplementedError", "numpy.load", "print", "os.path.join", "os.path.isfile", "keras.models.load_model.evaluate", "print", "numpy.where", "extract_characteristics.get_kd", "print", "os.path.join", "numpy.concatenate", "numpy.save", "numpy.load", "print", "util.get_noisy_samples", "numpy.save", "numpy.linalg.norm().mean", "print", "len", "extract_characteristics.get_bu", "print", "os.path.join", "numpy.concatenate", "numpy.save", "Y_test.argmax", "extract_characteristics.get_lid", "print", "os.path.join", "numpy.concatenate", "numpy.save", "numpy.linalg.norm", "extract_characteristics.get_kmeans", "print", "os.path.join", "numpy.concatenate", "numpy.save", "extract_characteristics.get_kd", "os.path.join", "numpy.concatenate", "numpy.save", "extract_characteristics.get_bu", "os.path.join", "numpy.concatenate", "numpy.save", "extract_characteristics.get_lid", "os.path.join", "numpy.concatenate", "numpy.save", "dataset.reshape", "X_test.reshape", "len", "len"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_data", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_kd", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_noisy_samples", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_bu", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_lid", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_kmeans", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_kd", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_bu", "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.extract_characteristics.get_lid"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "assert", "args", ".", "dataset", "in", "[", "'mnist'", ",", "'cifar'", ",", "'svhn'", "]", ",", "\"Dataset parameter must be either 'mnist', 'cifar' or 'svhn'\"", "\n", "assert", "args", ".", "attack", "in", "[", "'fgsm'", ",", "'bim-a'", ",", "'bim-b'", ",", "'jsma'", ",", "'cw-l2'", ",", "'all'", "]", ",", "\"Attack parameter must be either 'fgsm', 'bim-a', 'bim-b', \"", "\"'jsma' or 'cw-l2'\"", "\n", "assert", "args", ".", "characteristic", "in", "[", "'kd'", ",", "'bu'", ",", "'lid'", ",", "'km'", ",", "'all'", "]", ",", "\"Characteristic(s) to use 'kd', 'bu', 'lid', 'km', 'all'\"", "\n", "model_file", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "\"model_%s.h5\"", "%", "args", ".", "dataset", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "model_file", ")", ",", "'model file not found... must first train model using train_model.py.'", "\n", "adv_file", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "\"Adv_%s_%s.npy\"", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "adv_file", ")", ",", "'adversarial sample file not found... must first craft adversarial '", "'samples using craft_adv_samples.py'", "\n", "\n", "print", "(", "'Loading the data and model...'", ")", "\n", "# Load the model", "\n", "model", "=", "load_model", "(", "model_file", ")", "\n", "# Load the dataset", "\n", "X_train", ",", "Y_train", ",", "X_test", ",", "Y_test", "=", "get_data", "(", "args", ".", "dataset", ")", "\n", "# Check attack type, select adversarial and noisy samples accordingly", "\n", "print", "(", "'Loading noisy and adversarial samples...'", ")", "\n", "if", "args", ".", "attack", "==", "'all'", ":", "\n", "# TODO: implement 'all' option", "\n", "# X_test_adv = ...", "\n", "# X_test_noisy = ...", "\n", "        ", "raise", "NotImplementedError", "(", "\"'All' types detector not yet implemented.\"", ")", "\n", "", "else", ":", "\n", "# Load adversarial samples", "\n", "        ", "X_test_adv", "=", "np", ".", "load", "(", "adv_file", ")", "\n", "print", "(", "\"X_test_adv: \"", ",", "X_test_adv", ".", "shape", ")", "\n", "\n", "# as there are some parameters to tune for noisy example, so put the generation", "\n", "# step here instead of the adversarial step which can take many hours", "\n", "noisy_file", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'Noisy_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "noisy_file", ")", ":", "\n", "            ", "X_test_noisy", "=", "np", ".", "load", "(", "noisy_file", ")", "\n", "", "else", ":", "\n", "# Craft an equal number of noisy samples", "\n", "            ", "print", "(", "'Crafting %s noisy samples. '", "%", "args", ".", "dataset", ")", "\n", "X_test_noisy", "=", "get_noisy_samples", "(", "X_test", ",", "X_test_adv", ",", "args", ".", "dataset", ",", "args", ".", "attack", ")", "\n", "np", ".", "save", "(", "noisy_file", ",", "X_test_noisy", ")", "\n", "\n", "# Check model accuracies on each sample type", "\n", "", "", "for", "s_type", ",", "dataset", "in", "zip", "(", "[", "'normal'", ",", "'noisy'", ",", "'adversarial'", "]", ",", "\n", "[", "X_test", ",", "X_test_noisy", ",", "X_test_adv", "]", ")", ":", "\n", "        ", "_", ",", "acc", "=", "model", ".", "evaluate", "(", "dataset", ",", "Y_test", ",", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "verbose", "=", "0", ")", "\n", "print", "(", "\"Model accuracy on the %s test set: %0.2f%%\"", "%", "\n", "(", "s_type", ",", "100", "*", "acc", ")", ")", "\n", "# Compute and display average perturbation sizes", "\n", "if", "not", "s_type", "==", "'normal'", ":", "\n", "            ", "l2_diff", "=", "np", ".", "linalg", ".", "norm", "(", "\n", "dataset", ".", "reshape", "(", "(", "len", "(", "X_test", ")", ",", "-", "1", ")", ")", "-", "\n", "X_test", ".", "reshape", "(", "(", "len", "(", "X_test", ")", ",", "-", "1", ")", ")", ",", "\n", "axis", "=", "1", "\n", ")", ".", "mean", "(", ")", "\n", "print", "(", "\"Average L-2 perturbation size of the %s test set: %0.2f\"", "%", "\n", "(", "s_type", ",", "l2_diff", ")", ")", "\n", "\n", "# Refine the normal, noisy and adversarial sets to only include samples for", "\n", "# which the original version was correctly classified by the model", "\n", "", "", "preds_test", "=", "model", ".", "predict_classes", "(", "X_test", ",", "verbose", "=", "0", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ")", "\n", "inds_correct", "=", "np", ".", "where", "(", "preds_test", "==", "Y_test", ".", "argmax", "(", "axis", "=", "1", ")", ")", "[", "0", "]", "\n", "print", "(", "\"Number of correctly predict images: %s\"", "%", "(", "len", "(", "inds_correct", ")", ")", ")", "\n", "\n", "X_test", "=", "X_test", "[", "inds_correct", "]", "\n", "X_test_noisy", "=", "X_test_noisy", "[", "inds_correct", "]", "\n", "X_test_adv", "=", "X_test_adv", "[", "inds_correct", "]", "\n", "print", "(", "\"X_test: \"", ",", "X_test", ".", "shape", ")", "\n", "print", "(", "\"X_test_noisy: \"", ",", "X_test_noisy", ".", "shape", ")", "\n", "print", "(", "\"X_test_adv: \"", ",", "X_test_adv", ".", "shape", ")", "\n", "\n", "if", "args", ".", "characteristic", "==", "'kd'", ":", "\n", "# extract kernel density", "\n", "        ", "characteristics", ",", "labels", "=", "get_kd", "(", "model", ",", "X_train", ",", "Y_train", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", "\n", "print", "(", "\"KD: [characteristic shape: \"", ",", "characteristics", ".", "shape", ",", "\", label shape: \"", ",", "labels", ".", "shape", ")", "\n", "\n", "# save to file", "\n", "bandwidth", "=", "BANDWIDTHS", "[", "args", ".", "dataset", "]", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'kd_%s_%s_%.4f.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ",", "bandwidth", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "", "elif", "args", ".", "characteristic", "==", "'bu'", ":", "\n", "# extract Bayesian uncertainty", "\n", "        ", "characteristics", ",", "labels", "=", "get_bu", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", "\n", "print", "(", "\"BU: [characteristic shape: \"", ",", "characteristics", ".", "shape", ",", "\", label shape: \"", ",", "labels", ".", "shape", ")", "\n", "\n", "# save to file", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'bu_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "", "elif", "args", ".", "characteristic", "==", "'lid'", ":", "\n", "# extract local intrinsic dimensionality", "\n", "        ", "characteristics", ",", "labels", "=", "get_lid", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "\n", "args", ".", "k_nearest", ",", "args", ".", "batch_size", ",", "args", ".", "dataset", ")", "\n", "print", "(", "\"LID: [characteristic shape: \"", ",", "characteristics", ".", "shape", ",", "\", label shape: \"", ",", "labels", ".", "shape", ")", "\n", "\n", "# save to file", "\n", "# file_name = os.path.join(PATH_DATA, 'lid_%s_%s.npy' % (args.dataset, args.attack))", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "'../data_grid_search/lid_large_batch/'", ",", "'lid_%s_%s_%s.npy'", "%", "\n", "(", "args", ".", "dataset", ",", "args", ".", "attack", ",", "args", ".", "k_nearest", ")", ")", "\n", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "", "elif", "args", ".", "characteristic", "==", "'km'", ":", "\n", "# extract k means distance", "\n", "        ", "characteristics", ",", "labels", "=", "get_kmeans", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "\n", "args", ".", "k_nearest", ",", "args", ".", "batch_size", ",", "args", ".", "dataset", ")", "\n", "print", "(", "\"K-Mean: [characteristic shape: \"", ",", "characteristics", ".", "shape", ",", "\", label shape: \"", ",", "labels", ".", "shape", ")", "\n", "\n", "# save to file", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'km_pca_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "", "elif", "args", ".", "characteristic", "==", "'all'", ":", "\n", "# extract kernel density", "\n", "        ", "characteristics", ",", "labels", "=", "get_kd", "(", "model", ",", "X_train", ",", "Y_train", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'kd_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "\n", "# extract Bayesian uncertainty", "\n", "characteristics", ",", "labels", "=", "get_bu", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'bu_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "\n", "# extract local intrinsic dimensionality", "\n", "characteristics", ",", "labels", "=", "get_lid", "(", "model", ",", "X_test", ",", "X_test_noisy", ",", "X_test_adv", ",", "\n", "args", ".", "k_nearest", ",", "args", ".", "batch_size", ",", "args", ".", "dataset", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'lid_%s_%s.npy'", "%", "(", "args", ".", "dataset", ",", "args", ".", "attack", ")", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "characteristics", ",", "labels", ")", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "file_name", ",", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_data": [[57, 115], ["np.transpose.astype", "np.transpose.astype", "keras.utils.np_utils.to_categorical", "keras.utils.np_utils.to_categorical", "print", "print", "print", "print", "keras.datasets.mnist.load_data", "np.transpose.reshape", "np.transpose.reshape", "keras.datasets.cifar10.load_data", "scipy.loadmat", "scipy.loadmat", "numpy.transpose", "numpy.transpose", "os.path.isfile", "print", "subprocess.call", "os.path.isfile", "print", "subprocess.call", "os.path.join", "os.path.join", "numpy.reshape", "numpy.reshape", "os.path.join", "os.path.join"], "function", ["None"], ["def", "get_data", "(", "dataset", "=", "'mnist'", ")", ":", "\n", "    ", "\"\"\"\n    images in [-0.5, 0.5] (instead of [0, 1]) which suits C&W attack and generally gives better performance\n    \n    :param dataset:\n    :return: \n    \"\"\"", "\n", "assert", "dataset", "in", "[", "'mnist'", ",", "'cifar'", ",", "'svhn'", "]", ",", "\"dataset parameter must be either 'mnist' 'cifar' or 'svhn'\"", "\n", "if", "dataset", "==", "'mnist'", ":", "\n", "# the data, shuffled and split between train and test sets", "\n", "        ", "(", "X_train", ",", "y_train", ")", ",", "(", "X_test", ",", "y_test", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "# reshape to (n_samples, 28, 28, 1)", "\n", "X_train", "=", "X_train", ".", "reshape", "(", "-", "1", ",", "28", ",", "28", ",", "1", ")", "\n", "X_test", "=", "X_test", ".", "reshape", "(", "-", "1", ",", "28", ",", "28", ",", "1", ")", "\n", "", "elif", "dataset", "==", "'cifar'", ":", "\n", "# the data, shuffled and split between train and test sets", "\n", "        ", "(", "X_train", ",", "y_train", ")", ",", "(", "X_test", ",", "y_test", ")", "=", "cifar10", ".", "load_data", "(", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "\"svhn_train.mat\"", ")", ")", ":", "\n", "            ", "print", "(", "'Downloading SVHN train set...'", ")", "\n", "call", "(", "\n", "\"curl -o ../data/svhn_train.mat \"", "\n", "\"http://ufldl.stanford.edu/housenumbers/train_32x32.mat\"", ",", "\n", "shell", "=", "True", "\n", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "\"svhn_test.mat\"", ")", ")", ":", "\n", "            ", "print", "(", "'Downloading SVHN test set...'", ")", "\n", "call", "(", "\n", "\"curl -o ../data/svhn_test.mat \"", "\n", "\"http://ufldl.stanford.edu/housenumbers/test_32x32.mat\"", ",", "\n", "shell", "=", "True", "\n", ")", "\n", "", "train", "=", "sio", ".", "loadmat", "(", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'svhn_train.mat'", ")", ")", "\n", "test", "=", "sio", ".", "loadmat", "(", "os", ".", "path", ".", "join", "(", "PATH_DATA", ",", "'svhn_test.mat'", ")", ")", "\n", "X_train", "=", "np", ".", "transpose", "(", "train", "[", "'X'", "]", ",", "axes", "=", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "\n", "X_test", "=", "np", ".", "transpose", "(", "test", "[", "'X'", "]", ",", "axes", "=", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "\n", "# reshape (n_samples, 1) to (n_samples,) and change 1-index", "\n", "# to 0-index", "\n", "y_train", "=", "np", ".", "reshape", "(", "train", "[", "'y'", "]", ",", "(", "-", "1", ",", ")", ")", "-", "1", "\n", "y_test", "=", "np", ".", "reshape", "(", "test", "[", "'y'", "]", ",", "(", "-", "1", ",", ")", ")", "-", "1", "\n", "\n", "# cast pixels to floats, normalize to [0, 1] range", "\n", "", "X_train", "=", "X_train", ".", "astype", "(", "'float32'", ")", "\n", "X_test", "=", "X_test", ".", "astype", "(", "'float32'", ")", "\n", "X_train", "=", "(", "X_train", "/", "255.0", ")", "-", "(", "1.0", "-", "CLIP_MAX", ")", "\n", "X_test", "=", "(", "X_test", "/", "255.0", ")", "-", "(", "1.0", "-", "CLIP_MAX", ")", "\n", "\n", "# one-hot-encode the labels", "\n", "Y_train", "=", "np_utils", ".", "to_categorical", "(", "y_train", ",", "10", ")", "\n", "Y_test", "=", "np_utils", ".", "to_categorical", "(", "y_test", ",", "10", ")", "\n", "\n", "print", "(", "\"X_train:\"", ",", "X_train", ".", "shape", ")", "\n", "print", "(", "\"Y_train:\"", ",", "Y_train", ".", "shape", ")", "\n", "print", "(", "\"X_test:\"", ",", "X_test", ".", "shape", ")", "\n", "print", "(", "\"Y_test\"", ",", "Y_test", ".", "shape", ")", "\n", "\n", "return", "X_train", ",", "Y_train", ",", "X_test", ",", "Y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_model": [[116, 224], ["keras.models.Sequential", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.layers.Conv2D", "keras.layers.Activation", "BatchNormalization", "keras.layers.Conv2D", "keras.layers.Activation", "BatchNormalization", "keras.layers.MaxPooling2D", "keras.layers.Dropout", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Activation", "BatchNormalization", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.Conv2D", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Activation", "keras.layers.Dense", "keras.layers.Conv2D", "keras.layers.Activation", "BatchNormalization", "keras.layers.Conv2D", "keras.layers.Activation", "BatchNormalization", "keras.layers.MaxPooling2D", "keras.layers.Dropout", "keras.layers.Flatten", "keras.layers.Dense", "keras.layers.Activation", "BatchNormalization", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation", "BatchNormalization", "keras.layers.Dropout", "keras.layers.Dense"], "function", ["None"], ["", "def", "get_model", "(", "dataset", "=", "'mnist'", ",", "softmax", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Takes in a parameter indicating which model type to use ('mnist',\n    'cifar' or 'svhn') and returns the appropriate Keras model.\n    :param dataset: A string indicating which dataset we are building\n                    a model for.\n    :param softmax: if add softmax to the last layer.\n    :return: The model; a Keras 'Sequential' instance.\n    \"\"\"", "\n", "assert", "dataset", "in", "[", "'mnist'", ",", "'cifar'", ",", "'svhn'", "]", ",", "\"dataset parameter must be either 'mnist' 'cifar' or 'svhn'\"", "\n", "if", "dataset", "==", "'mnist'", ":", "\n", "# MNIST model: 0, 2, 7, 10", "\n", "        ", "layers", "=", "[", "\n", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'valid'", ",", "input_shape", "=", "(", "28", ",", "28", ",", "1", ")", ")", ",", "# 0", "\n", "Activation", "(", "'relu'", ")", ",", "# 1", "\n", "BatchNormalization", "(", ")", ",", "# 2", "\n", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ")", ",", "# 3", "\n", "Activation", "(", "'relu'", ")", ",", "# 4", "\n", "BatchNormalization", "(", ")", ",", "# 5", "\n", "MaxPooling2D", "(", "pool_size", "=", "(", "2", ",", "2", ")", ")", ",", "# 6", "\n", "Dropout", "(", "0.5", ")", ",", "# 7", "\n", "Flatten", "(", ")", ",", "# 8", "\n", "Dense", "(", "128", ")", ",", "# 9            ", "\n", "Activation", "(", "'relu'", ")", ",", "# 10", "\n", "BatchNormalization", "(", ")", ",", "# 11", "\n", "Dropout", "(", "0.5", ")", ",", "# 12", "\n", "Dense", "(", "10", ")", ",", "# 13", "\n", "]", "\n", "", "elif", "dataset", "==", "'cifar'", ":", "\n", "# This is the VGG19 model", "\n", "# CIFAR-10 model", "\n", "        ", "layers", "=", "[", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ",", "\n", "input_shape", "=", "(", "(", "32", ",", "32", ",", "3", ")", ")", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Conv2D", "(", "128", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "128", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "MaxPooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Dense", "(", "256", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Dense", "(", "10", ")", "\n", "]", "\n", "", "else", ":", "\n", "# SVHN model", "\n", "        ", "layers", "=", "[", "\n", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'valid'", ",", "input_shape", "=", "(", "32", ",", "32", ",", "3", ")", ")", ",", "# 0", "\n", "Activation", "(", "'relu'", ")", ",", "# 1", "\n", "BatchNormalization", "(", ")", ",", "# 2", "\n", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ")", ",", "# 3", "\n", "Activation", "(", "'relu'", ")", ",", "# 4", "\n", "BatchNormalization", "(", ")", ",", "# 5", "\n", "MaxPooling2D", "(", "pool_size", "=", "(", "2", ",", "2", ")", ")", ",", "# 6", "\n", "\n", "Dropout", "(", "0.5", ")", ",", "# 7", "\n", "Flatten", "(", ")", ",", "# 8", "\n", "\n", "Dense", "(", "512", ")", ",", "# 9", "\n", "Activation", "(", "'relu'", ")", ",", "# 10", "\n", "BatchNormalization", "(", ")", ",", "# 11", "\n", "Dropout", "(", "0.5", ")", ",", "# 12", "\n", "\n", "Dense", "(", "128", ")", ",", "# 13", "\n", "Activation", "(", "'relu'", ")", ",", "# 14", "\n", "BatchNormalization", "(", ")", ",", "# 15", "\n", "Dropout", "(", "0.5", ")", ",", "# 16", "\n", "Dense", "(", "10", ")", ",", "# 17", "\n", "]", "\n", "\n", "", "model", "=", "Sequential", "(", ")", "\n", "for", "layer", "in", "layers", ":", "\n", "        ", "model", ".", "add", "(", "layer", ")", "\n", "", "if", "softmax", ":", "\n", "        ", "model", ".", "add", "(", "Activation", "(", "'softmax'", ")", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.cross_entropy": [[225, 227], ["tensorflow.nn.softmax_cross_entropy_with_logits"], "function", ["None"], ["", "def", "cross_entropy", "(", "y_true", ",", "y_pred", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits", "(", "labels", "=", "y_true", ",", "logits", "=", "y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.lid_term": [[228, 256], ["tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.sqrt", "tensorflow.nn.top_k", "tensorflow.transpose", "tensorflow.reduce_sum", "tensorflow.square", "tensorflow.transpose", "tensorflow.multiply", "tensorflow.log", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.transpose"], "function", ["None"], ["", "def", "lid_term", "(", "logits", ",", "batch_size", "=", "100", ")", ":", "\n", "    ", "\"\"\"Calculate LID loss term for a minibatch of logits\n\n    :param logits: \n    :return: \n    \"\"\"", "\n", "# y_pred = tf.nn.softmax(logits)", "\n", "y_pred", "=", "logits", "\n", "\n", "# calculate pairwise distance", "\n", "r", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "y_pred", ")", ",", "axis", "=", "1", ")", "\n", "# turn r into column vector", "\n", "r", "=", "tf", ".", "reshape", "(", "r", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "D", "=", "r", "-", "2", "*", "tf", ".", "matmul", "(", "y_pred", ",", "tf", ".", "transpose", "(", "y_pred", ")", ")", "+", "tf", ".", "transpose", "(", "r", ")", "\n", "\n", "# find the k nearest neighbor", "\n", "D1", "=", "tf", ".", "sqrt", "(", "D", "+", "1e-9", ")", "\n", "D2", ",", "_", "=", "tf", ".", "nn", ".", "top_k", "(", "-", "D1", ",", "k", "=", "21", ",", "sorted", "=", "True", ")", "\n", "D3", "=", "-", "D2", "[", ":", ",", "1", ":", "]", "\n", "\n", "m", "=", "tf", ".", "transpose", "(", "tf", ".", "multiply", "(", "tf", ".", "transpose", "(", "D3", ")", ",", "1.0", "/", "D3", "[", ":", ",", "-", "1", "]", ")", ")", "\n", "v_log", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "m", "+", "1e-9", ")", ",", "axis", "=", "1", ")", "# to avoid nan", "\n", "lids", "=", "-", "20", "/", "v_log", "\n", "\n", "## batch normalize lids", "\n", "# lids = tf.nn.l2_normalize(lids, dim=0, epsilon=1e-12)", "\n", "\n", "return", "lids", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.lid_adv_term": [[257, 292], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.sqrt", "tensorflow.nn.top_k", "tensorflow.transpose", "tensorflow.reduce_sum", "tensorflow.nn.l2_normalize", "tensorflow.square", "tensorflow.square", "tensorflow.multiply", "tensorflow.log", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.transpose"], "function", ["None"], ["", "def", "lid_adv_term", "(", "clean_logits", ",", "adv_logits", ",", "batch_size", "=", "100", ")", ":", "\n", "    ", "\"\"\"Calculate LID loss term for a minibatch of advs logits\n\n    :param logits: clean logits\n    :param A_logits: adversarial logits\n    :return: \n    \"\"\"", "\n", "# y_pred = tf.nn.softmax(logits)", "\n", "c_pred", "=", "tf", ".", "reshape", "(", "clean_logits", ",", "(", "batch_size", ",", "-", "1", ")", ")", "\n", "a_pred", "=", "tf", ".", "reshape", "(", "adv_logits", ",", "(", "batch_size", ",", "-", "1", ")", ")", "\n", "\n", "# calculate pairwise distance", "\n", "r_a", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "a_pred", ")", ",", "axis", "=", "1", ")", "\n", "# turn r_a into column vector", "\n", "r_a", "=", "tf", ".", "reshape", "(", "r_a", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "\n", "r_c", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "c_pred", ")", ",", "axis", "=", "1", ")", "\n", "# turn r_c into row vector", "\n", "r_c", "=", "tf", ".", "reshape", "(", "r_c", ",", "[", "1", ",", "-", "1", "]", ")", "\n", "\n", "D", "=", "r_a", "-", "2", "*", "tf", ".", "matmul", "(", "a_pred", ",", "tf", ".", "transpose", "(", "c_pred", ")", ")", "+", "r_c", "\n", "\n", "# find the k nearest neighbor", "\n", "D1", "=", "tf", ".", "sqrt", "(", "D", "+", "1e-9", ")", "\n", "D2", ",", "_", "=", "tf", ".", "nn", ".", "top_k", "(", "-", "D1", ",", "k", "=", "21", ",", "sorted", "=", "True", ")", "\n", "D3", "=", "-", "D2", "[", ":", ",", "1", ":", "]", "\n", "\n", "m", "=", "tf", ".", "transpose", "(", "tf", ".", "multiply", "(", "tf", ".", "transpose", "(", "D3", ")", ",", "1.0", "/", "D3", "[", ":", ",", "-", "1", "]", ")", ")", "\n", "v_log", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "m", "+", "1e-9", ")", ",", "axis", "=", "1", ")", "# to avoid nan", "\n", "lids", "=", "-", "20", "/", "v_log", "\n", "\n", "## batch normalize lids", "\n", "lids", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "lids", ",", "dim", "=", "0", ",", "epsilon", "=", "1e-12", ")", "\n", "\n", "return", "lids", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.flip": [[293, 308], ["numpy.copy", "numpy.random.choice", "numpy.reshape", "numpy.reshape", "numpy.where"], "function", ["None"], ["", "def", "flip", "(", "x", ",", "nb_diff", ")", ":", "\n", "    ", "\"\"\"\n    Helper function for get_noisy_samples\n    :param x:\n    :param nb_diff:\n    :return:\n    \"\"\"", "\n", "original_shape", "=", "x", ".", "shape", "\n", "x", "=", "np", ".", "copy", "(", "np", ".", "reshape", "(", "x", ",", "(", "-", "1", ",", ")", ")", ")", "\n", "candidate_inds", "=", "np", ".", "where", "(", "x", "<", "CLIP_MAX", ")", "[", "0", "]", "\n", "assert", "candidate_inds", ".", "shape", "[", "0", "]", ">=", "nb_diff", "\n", "inds", "=", "np", ".", "random", ".", "choice", "(", "candidate_inds", ",", "nb_diff", ")", "\n", "x", "[", "inds", "]", "=", "CLIP_MAX", "\n", "\n", "return", "np", ".", "reshape", "(", "x", ",", "original_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_noisy_samples": [[310, 346], ["numpy.zeros_like", "range", "warnings.warn", "numpy.minimum", "len", "len", "util.flip", "numpy.maximum", "numpy.where", "numpy.random.normal"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.flip"], ["", "def", "get_noisy_samples", "(", "X_test", ",", "X_test_adv", ",", "dataset", ",", "attack", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param X_test:\n    :param X_test_adv:\n    :param dataset:\n    :param attack:\n    :return:\n    \"\"\"", "\n", "if", "attack", "in", "[", "'jsma'", ",", "'cw-l0'", "]", ":", "\n", "        ", "X_test_noisy", "=", "np", ".", "zeros_like", "(", "X_test", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "X_test", ")", ")", ":", "\n", "# Count the number of pixels that are different", "\n", "            ", "nb_diff", "=", "len", "(", "np", ".", "where", "(", "X_test", "[", "i", "]", "!=", "X_test_adv", "[", "i", "]", ")", "[", "0", "]", ")", "\n", "# Randomly flip an equal number of pixels (flip means move to max", "\n", "# value of 1)", "\n", "X_test_noisy", "[", "i", "]", "=", "flip", "(", "X_test", "[", "i", "]", ",", "nb_diff", ")", "\n", "", "", "else", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Important: using pre-set Gaussian scale sizes to craft noisy \"", "\n", "\"samples. You will definitely need to manually tune the scale \"", "\n", "\"according to the L2 print below, otherwise the result \"", "\n", "\"will inaccurate. In future scale sizes will be inferred \"", "\n", "\"automatically. For now, manually tune the scales around \"", "\n", "\"mnist: L2/20.0, cifar: L2/54.0, svhn: L2/60.0\"", ")", "\n", "# Add Gaussian noise to the samples", "\n", "# print(STDEVS[dataset][attack])", "\n", "X_test_noisy", "=", "np", ".", "minimum", "(", "\n", "np", ".", "maximum", "(", "\n", "X_test", "+", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "STDEVS", "[", "dataset", "]", "[", "attack", "]", ",", "\n", "size", "=", "X_test", ".", "shape", ")", ",", "\n", "CLIP_MIN", "\n", ")", ",", "\n", "CLIP_MAX", "\n", ")", "\n", "\n", "", "return", "X_test_noisy", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_mc_predictions": [[348, 376], ["keras.function", "tqdm.tqdm", "numpy.asarray", "int", "numpy.zeros", "range", "range", "preds_mc.append", "keras.learning_phase", "numpy.ceil", "util.get_mc_predictions.predict"], "function", ["None"], ["", "def", "get_mc_predictions", "(", "model", ",", "X", ",", "nb_iter", "=", "50", ",", "batch_size", "=", "256", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param model:\n    :param X:\n    :param nb_iter:\n    :param batch_size:\n    :return:\n    \"\"\"", "\n", "output_dim", "=", "model", ".", "layers", "[", "-", "1", "]", ".", "output", ".", "shape", "[", "-", "1", "]", ".", "value", "\n", "get_output", "=", "K", ".", "function", "(", "\n", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ",", "K", ".", "learning_phase", "(", ")", "]", ",", "\n", "[", "model", ".", "layers", "[", "-", "1", "]", ".", "output", "]", "\n", ")", "\n", "\n", "def", "predict", "(", ")", ":", "\n", "        ", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "X", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "output", "=", "np", ".", "zeros", "(", "shape", "=", "(", "len", "(", "X", ")", ",", "output_dim", ")", ")", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "output", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", "=", "get_output", "(", "[", "X", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ",", "1", "]", ")", "[", "0", "]", "\n", "", "return", "output", "\n", "\n", "", "preds_mc", "=", "[", "]", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "nb_iter", ")", ")", ":", "\n", "        ", "preds_mc", ".", "append", "(", "predict", "(", ")", ")", "\n", "\n", "", "return", "np", ".", "asarray", "(", "preds_mc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_deep_representations": [[378, 400], ["keras.function", "int", "numpy.zeros", "range", "numpy.ceil", "keras.learning_phase", "K.function.", "float", "len"], "function", ["None"], ["", "def", "get_deep_representations", "(", "model", ",", "X", ",", "batch_size", "=", "256", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param model:\n    :param X:\n    :param batch_size:\n    :return:\n    \"\"\"", "\n", "# last hidden layer is always at index -4", "\n", "output_dim", "=", "model", ".", "layers", "[", "-", "4", "]", ".", "output", ".", "shape", "[", "-", "1", "]", ".", "value", "\n", "get_encoding", "=", "K", ".", "function", "(", "\n", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ",", "K", ".", "learning_phase", "(", ")", "]", ",", "\n", "[", "model", ".", "layers", "[", "-", "4", "]", ".", "output", "]", "\n", ")", "\n", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "X", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "output", "=", "np", ".", "zeros", "(", "shape", "=", "(", "len", "(", "X", ")", ",", "output_dim", ")", ")", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "        ", "output", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", "=", "get_encoding", "(", "[", "X", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_layer_wise_activations": [[401, 424], ["acts.extend", "acts.extend", "acts.extend"], "function", ["None"], ["", "def", "get_layer_wise_activations", "(", "model", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"\n    Get the deep activation outputs.\n    :param model:\n    :param dataset: 'mnist', 'cifar', 'svhn', has different submanifolds architectures  \n    :return: \n    \"\"\"", "\n", "assert", "dataset", "in", "[", "'mnist'", ",", "'cifar'", ",", "'svhn'", "]", ",", "\"dataset parameter must be either 'mnist' 'cifar' or 'svhn'\"", "\n", "if", "dataset", "==", "'mnist'", ":", "\n", "# mnist model", "\n", "        ", "acts", "=", "[", "model", ".", "layers", "[", "0", "]", ".", "input", "]", "\n", "acts", ".", "extend", "(", "[", "layer", ".", "output", "for", "layer", "in", "model", ".", "layers", "[", "1", ":", "]", "]", ")", "\n", "", "elif", "dataset", "==", "'cifar'", ":", "\n", "# cifar-10 model", "\n", "#        acts = [model.layers[0].input]", "\n", "        ", "acts", "=", "[", "]", "\n", "acts", ".", "extend", "(", "[", "layer", ".", "output", "for", "layer", "in", "model", ".", "layers", "[", "1", ":", "]", "]", ")", "\n", "", "else", ":", "\n", "# svhn model", "\n", "        ", "acts", "=", "[", "model", ".", "layers", "[", "0", "]", ".", "input", "]", "\n", "acts", ".", "extend", "(", "[", "layer", ".", "output", "for", "layer", "in", "model", ".", "layers", "[", "1", ":", "]", "]", ")", "\n", "", "return", "acts", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.mle_single": [[426, 440], ["numpy.asarray", "numpy.asarray", "min", "scipy.spatial.distance.cdist", "numpy.apply_along_axis", "x.reshape.reshape", "numpy.apply_along_axis", "len", "numpy.sum", "numpy.log"], "function", ["None"], ["", "def", "mle_single", "(", "data", ",", "x", ",", "k", "=", "20", ")", ":", "\n", "    ", "data", "=", "np", ".", "asarray", "(", "data", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# print('x.ndim',x.ndim)", "\n", "if", "x", ".", "ndim", "==", "1", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "# dim = x.shape[1]", "\n", "\n", "", "k", "=", "min", "(", "k", ",", "len", "(", "data", ")", "-", "1", ")", "\n", "f", "=", "lambda", "v", ":", "-", "k", "/", "np", ".", "sum", "(", "np", ".", "log", "(", "v", "/", "v", "[", "-", "1", "]", ")", ")", "\n", "a", "=", "cdist", "(", "x", ",", "data", ")", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "np", ".", "sort", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "[", ":", ",", "1", ":", "k", "+", "1", "]", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "f", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "\n", "return", "a", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.mle_batch": [[442, 452], ["numpy.asarray", "numpy.asarray", "min", "scipy.spatial.distance.cdist", "numpy.apply_along_axis", "numpy.apply_along_axis", "len", "numpy.sum", "numpy.log"], "function", ["None"], ["", "def", "mle_batch", "(", "data", ",", "batch", ",", "k", ")", ":", "\n", "    ", "data", "=", "np", ".", "asarray", "(", "data", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "batch", "=", "np", ".", "asarray", "(", "batch", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "k", "=", "min", "(", "k", ",", "len", "(", "data", ")", "-", "1", ")", "\n", "f", "=", "lambda", "v", ":", "-", "k", "/", "np", ".", "sum", "(", "np", ".", "log", "(", "v", "/", "v", "[", "-", "1", "]", ")", ")", "\n", "a", "=", "cdist", "(", "batch", ",", "data", ")", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "np", ".", "sort", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "[", ":", ",", "1", ":", "k", "+", "1", "]", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "f", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.kmean_batch": [[454, 464], ["numpy.asarray", "numpy.asarray", "min", "scipy.spatial.distance.cdist", "numpy.apply_along_axis", "numpy.mean", "numpy.apply_along_axis", "len"], "function", ["None"], ["", "def", "kmean_batch", "(", "data", ",", "batch", ",", "k", ")", ":", "\n", "    ", "data", "=", "np", ".", "asarray", "(", "data", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "batch", "=", "np", ".", "asarray", "(", "batch", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "k", "=", "min", "(", "k", ",", "len", "(", "data", ")", "-", "1", ")", "\n", "f", "=", "lambda", "v", ":", "np", ".", "mean", "(", "v", ")", "\n", "a", "=", "cdist", "(", "batch", ",", "data", ")", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "np", ".", "sort", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "[", ":", ",", "1", ":", "k", "+", "1", "]", "\n", "a", "=", "np", ".", "apply_along_axis", "(", "f", ",", "axis", "=", "1", ",", "arr", "=", "a", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.kmean_pca_batch": [[466, 475], ["numpy.asarray", "numpy.asarray", "numpy.zeros", "numpy.arange", "numpy.concatenate", "sklearn.decomposition.PCA().fit_transform", "util.kmean_batch", "sklearn.decomposition.PCA"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.kmean_batch"], ["", "def", "kmean_pca_batch", "(", "data", ",", "batch", ",", "k", "=", "10", ")", ":", "\n", "    ", "data", "=", "np", ".", "asarray", "(", "data", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "batch", "=", "np", ".", "asarray", "(", "batch", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "a", "=", "np", ".", "zeros", "(", "batch", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "batch", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "tmp", "=", "np", ".", "concatenate", "(", "(", "data", ",", "[", "batch", "[", "i", "]", "]", ")", ")", "\n", "tmp_pca", "=", "PCA", "(", "n_components", "=", "2", ")", ".", "fit_transform", "(", "tmp", ")", "\n", "a", "[", "i", "]", "=", "kmean_batch", "(", "tmp_pca", "[", ":", "-", "1", "]", ",", "tmp_pca", "[", "-", "1", "]", ",", "k", "=", "k", ")", "\n", "", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_lids_random_batch": [[476, 544], ["len", "print", "int", "tqdm.tqdm", "numpy.asarray", "numpy.asarray", "numpy.asarray", "keras.function", "numpy.minimum", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.ceil", "range", "util.get_lids_random_batch.estimate"], "function", ["None"], ["", "def", "get_lids_random_batch", "(", "model", ",", "X", ",", "X_noisy", ",", "X_adv", ",", "dataset", ",", "k", "=", "10", ",", "batch_size", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Get the local intrinsic dimensionality of each Xi in X_adv\n    estimated by k close neighbours in the random batch it lies in.\n    :param model:\n    :param X: normal images\n    :param X_noisy: noisy images\n    :param X_adv: advserial images    \n    :param dataset: 'mnist', 'cifar', 'svhn', has different DNN architectures  \n    :param k: the number of nearest neighbours for LID estimation  \n    :param batch_size: default 100\n    :return: lids: LID of normal images of shape (num_examples, lid_dim)\n            lids_adv: LID of advs images of shape (num_examples, lid_dim)\n    \"\"\"", "\n", "# get deep representations", "\n", "funcs", "=", "[", "K", ".", "function", "(", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ",", "K", ".", "learning_phase", "(", ")", "]", ",", "[", "out", "]", ")", "\n", "for", "out", "in", "get_layer_wise_activations", "(", "model", ",", "dataset", ")", "]", "\n", "lid_dim", "=", "len", "(", "funcs", ")", "\n", "print", "(", "\"Number of layers to estimate: \"", ",", "lid_dim", ")", "\n", "\n", "def", "estimate", "(", "i_batch", ")", ":", "\n", "        ", "start", "=", "i_batch", "*", "batch_size", "\n", "end", "=", "np", ".", "minimum", "(", "len", "(", "X", ")", ",", "(", "i_batch", "+", "1", ")", "*", "batch_size", ")", "\n", "n_feed", "=", "end", "-", "start", "\n", "lid_batch", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "lid_batch_adv", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "lid_batch_noisy", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "lid_dim", ")", ")", "\n", "for", "i", ",", "func", "in", "enumerate", "(", "funcs", ")", ":", "\n", "            ", "X_act", "=", "func", "(", "[", "X", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_act", "=", "np", ".", "asarray", "(", "X_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_act: \", X_act.shape)", "\n", "\n", "X_adv_act", "=", "func", "(", "[", "X_adv", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_adv_act", "=", "np", ".", "asarray", "(", "X_adv_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_adv_act: \", X_adv_act.shape)", "\n", "\n", "X_noisy_act", "=", "func", "(", "[", "X_noisy", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_noisy_act", "=", "np", ".", "asarray", "(", "X_noisy_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_noisy_act: \", X_noisy_act.shape)", "\n", "\n", "# random clean samples", "\n", "# Maximum likelihood estimation of local intrinsic dimensionality (LID)", "\n", "lid_batch", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch: \", lid_batch.shape)", "\n", "lid_batch_adv", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_adv_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_adv: \", lid_batch_adv.shape)", "\n", "lid_batch_noisy", "[", ":", ",", "i", "]", "=", "mle_batch", "(", "X_act", ",", "X_noisy_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_noisy: \", lid_batch_noisy.shape)", "\n", "", "return", "lid_batch", ",", "lid_batch_noisy", ",", "lid_batch_adv", "\n", "\n", "", "lids", "=", "[", "]", "\n", "lids_adv", "=", "[", "]", "\n", "lids_noisy", "=", "[", "]", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "X", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "i_batch", "in", "tqdm", "(", "range", "(", "n_batches", ")", ")", ":", "\n", "        ", "lid_batch", ",", "lid_batch_noisy", ",", "lid_batch_adv", "=", "estimate", "(", "i_batch", ")", "\n", "lids", ".", "extend", "(", "lid_batch", ")", "\n", "lids_adv", ".", "extend", "(", "lid_batch_adv", ")", "\n", "lids_noisy", ".", "extend", "(", "lid_batch_noisy", ")", "\n", "# print(\"lids: \", lids.shape)", "\n", "# print(\"lids_adv: \", lids_noisy.shape)", "\n", "# print(\"lids_noisy: \", lids_noisy.shape)", "\n", "\n", "", "lids", "=", "np", ".", "asarray", "(", "lids", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "lids_noisy", "=", "np", ".", "asarray", "(", "lids_noisy", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "lids_adv", "=", "np", ".", "asarray", "(", "lids_adv", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "return", "lids", ",", "lids_noisy", ",", "lids_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.get_kmeans_random_batch": [[545, 623], ["len", "print", "int", "tqdm.tqdm", "numpy.asarray", "numpy.asarray", "numpy.asarray", "keras.function", "numpy.minimum", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.ceil", "range", "util.get_lids_random_batch.estimate"], "function", ["None"], ["", "def", "get_kmeans_random_batch", "(", "model", ",", "X", ",", "X_noisy", ",", "X_adv", ",", "dataset", ",", "k", "=", "10", ",", "batch_size", "=", "100", ",", "pca", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Get the mean distance of each Xi in X_adv to its k nearest neighbors.\n\n    :param model:\n    :param X: normal images\n    :param X_noisy: noisy images\n    :param X_adv: advserial images    \n    :param dataset: 'mnist', 'cifar', 'svhn', has different DNN architectures  \n    :param k: the number of nearest neighbours for LID estimation  \n    :param batch_size: default 100\n    :param pca: using pca or not, if True, apply pca to the referenced sample and a \n            minibatch of normal samples, then compute the knn mean distance of the referenced sample.\n    :return: kms_normal: kmean of normal images (num_examples, 1)\n            kms_noisy: kmean of normal images (num_examples, 1)\n            kms_adv: kmean of adv images (num_examples, 1)\n    \"\"\"", "\n", "# get deep representations", "\n", "funcs", "=", "[", "K", ".", "function", "(", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ",", "K", ".", "learning_phase", "(", ")", "]", ",", "[", "model", ".", "layers", "[", "-", "2", "]", ".", "output", "]", ")", "]", "\n", "km_dim", "=", "len", "(", "funcs", ")", "\n", "print", "(", "\"Number of layers to use: \"", ",", "km_dim", ")", "\n", "\n", "def", "estimate", "(", "i_batch", ")", ":", "\n", "        ", "start", "=", "i_batch", "*", "batch_size", "\n", "end", "=", "np", ".", "minimum", "(", "len", "(", "X", ")", ",", "(", "i_batch", "+", "1", ")", "*", "batch_size", ")", "\n", "n_feed", "=", "end", "-", "start", "\n", "km_batch", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "km_dim", ")", ")", "\n", "km_batch_adv", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "km_dim", ")", ")", "\n", "km_batch_noisy", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_feed", ",", "km_dim", ")", ")", "\n", "for", "i", ",", "func", "in", "enumerate", "(", "funcs", ")", ":", "\n", "            ", "X_act", "=", "func", "(", "[", "X", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_act", "=", "np", ".", "asarray", "(", "X_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_act: \", X_act.shape)", "\n", "\n", "X_adv_act", "=", "func", "(", "[", "X_adv", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_adv_act", "=", "np", ".", "asarray", "(", "X_adv_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_adv_act: \", X_adv_act.shape)", "\n", "\n", "X_noisy_act", "=", "func", "(", "[", "X_noisy", "[", "start", ":", "end", "]", ",", "0", "]", ")", "[", "0", "]", "\n", "X_noisy_act", "=", "np", ".", "asarray", "(", "X_noisy_act", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "(", "n_feed", ",", "-", "1", ")", ")", "\n", "# print(\"X_noisy_act: \", X_noisy_act.shape)", "\n", "\n", "# Maximum likelihood estimation of local intrinsic dimensionality (LID)", "\n", "if", "pca", ":", "\n", "                ", "km_batch", "[", ":", ",", "i", "]", "=", "kmean_pca_batch", "(", "X_act", ",", "X_act", ",", "k", "=", "k", ")", "\n", "", "else", ":", "\n", "                ", "km_batch", "[", ":", ",", "i", "]", "=", "kmean_batch", "(", "X_act", ",", "X_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch: \", lid_batch.shape)", "\n", "", "if", "pca", ":", "\n", "                ", "km_batch_adv", "[", ":", ",", "i", "]", "=", "kmean_pca_batch", "(", "X_act", ",", "X_adv_act", ",", "k", "=", "k", ")", "\n", "", "else", ":", "\n", "                ", "km_batch_adv", "[", ":", ",", "i", "]", "=", "kmean_batch", "(", "X_act", ",", "X_adv_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_adv: \", lid_batch_adv.shape)", "\n", "", "if", "pca", ":", "\n", "                ", "km_batch_noisy", "[", ":", ",", "i", "]", "=", "kmean_pca_batch", "(", "X_act", ",", "X_noisy_act", ",", "k", "=", "k", ")", "\n", "", "else", ":", "\n", "                ", "km_batch_noisy", "[", ":", ",", "i", "]", "=", "kmean_batch", "(", "X_act", ",", "X_noisy_act", ",", "k", "=", "k", ")", "\n", "# print(\"lid_batch_noisy: \", lid_batch_noisy.shape)", "\n", "", "", "return", "km_batch", ",", "km_batch_noisy", ",", "km_batch_adv", "\n", "\n", "", "kms", "=", "[", "]", "\n", "kms_adv", "=", "[", "]", "\n", "kms_noisy", "=", "[", "]", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "X", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "i_batch", "in", "tqdm", "(", "range", "(", "n_batches", ")", ")", ":", "\n", "        ", "km_batch", ",", "km_batch_noisy", ",", "km_batch_adv", "=", "estimate", "(", "i_batch", ")", "\n", "kms", ".", "extend", "(", "km_batch", ")", "\n", "kms_adv", ".", "extend", "(", "km_batch_adv", ")", "\n", "kms_noisy", ".", "extend", "(", "km_batch_noisy", ")", "\n", "# print(\"kms: \", kms.shape)", "\n", "# print(\"kms_adv: \", kms_noisy.shape)", "\n", "# print(\"kms_noisy: \", kms_noisy.shape)", "\n", "\n", "", "kms", "=", "np", ".", "asarray", "(", "kms", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "kms_noisy", "=", "np", ".", "asarray", "(", "kms_noisy", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "kms_adv", "=", "np", ".", "asarray", "(", "kms_adv", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "return", "kms", ",", "kms_noisy", ",", "kms_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_point": [[624, 633], ["kde.score_samples", "numpy.reshape"], "function", ["home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_samples"], ["", "def", "score_point", "(", "tup", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param tup:\n    :return:\n    \"\"\"", "\n", "x", ",", "kde", "=", "tup", "\n", "\n", "return", "kde", ".", "score_samples", "(", "np", ".", "reshape", "(", "x", ",", "(", "1", ",", "-", "1", ")", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.score_samples": [[635, 658], ["numpy.asarray", "mp.Pool.close", "mp.Pool.join", "multiprocessing.Pool", "multiprocessing.Pool", "mp.Pool.map", "zip"], "function", ["None"], ["", "def", "score_samples", "(", "kdes", ",", "samples", ",", "preds", ",", "n_jobs", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param kdes:\n    :param samples:\n    :param preds:\n    :param n_jobs:\n    :return:\n    \"\"\"", "\n", "if", "n_jobs", "is", "not", "None", ":", "\n", "        ", "p", "=", "mp", ".", "Pool", "(", "n_jobs", ")", "\n", "", "else", ":", "\n", "        ", "p", "=", "mp", ".", "Pool", "(", ")", "\n", "", "results", "=", "np", ".", "asarray", "(", "\n", "p", ".", "map", "(", "\n", "score_point", ",", "\n", "[", "(", "x", ",", "kdes", "[", "i", "]", ")", "for", "x", ",", "i", "in", "zip", "(", "samples", ",", "preds", ")", "]", "\n", ")", "\n", ")", "\n", "p", ".", "close", "(", ")", "\n", "p", ".", "join", "(", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.normalize": [[660, 672], ["len", "sklearn.preprocessing.scale", "numpy.concatenate"], "function", ["None"], ["", "def", "normalize", "(", "normal", ",", "adv", ",", "noisy", ")", ":", "\n", "    ", "\"\"\"Z-score normalisation\n    TODO\n    :param normal:\n    :param adv:\n    :param noisy:\n    :return:\n    \"\"\"", "\n", "n_samples", "=", "len", "(", "normal", ")", "\n", "total", "=", "scale", "(", "np", ".", "concatenate", "(", "(", "normal", ",", "adv", ",", "noisy", ")", ")", ")", "\n", "\n", "return", "total", "[", ":", "n_samples", "]", ",", "total", "[", "n_samples", ":", "2", "*", "n_samples", "]", ",", "total", "[", "2", "*", "n_samples", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.train_lr": [[674, 683], ["sklearn.linear_model.LogisticRegressionCV().fit", "sklearn.linear_model.LogisticRegressionCV"], "function", ["None"], ["", "def", "train_lr", "(", "X", ",", "y", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param X: the data samples\n    :param y: the labels\n    :return:\n    \"\"\"", "\n", "lr", "=", "LogisticRegressionCV", "(", "n_jobs", "=", "-", "1", ")", ".", "fit", "(", "X", ",", "y", ")", "\n", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.train_lr_rfeinman": [[685, 710], ["numpy.concatenate().transpose", "numpy.concatenate().transpose", "numpy.concatenate", "numpy.concatenate", "sklearn.linear_model.LogisticRegressionCV().fit", "numpy.concatenate", "numpy.concatenate", "numpy.zeros_like", "numpy.ones_like", "sklearn.linear_model.LogisticRegressionCV", "densities_neg.reshape", "uncerts_neg.reshape", "densities_pos.reshape", "uncerts_pos.reshape"], "function", ["None"], ["", "def", "train_lr_rfeinman", "(", "densities_pos", ",", "densities_neg", ",", "uncerts_pos", ",", "uncerts_neg", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param densities_pos:\n    :param densities_neg:\n    :param uncerts_pos:\n    :param uncerts_neg:\n    :return:\n    \"\"\"", "\n", "values_neg", "=", "np", ".", "concatenate", "(", "\n", "(", "densities_neg", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ",", "\n", "uncerts_neg", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ")", ",", "\n", "axis", "=", "0", ")", ".", "transpose", "(", "[", "1", ",", "0", "]", ")", "\n", "values_pos", "=", "np", ".", "concatenate", "(", "\n", "(", "densities_pos", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ",", "\n", "uncerts_pos", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ")", ",", "\n", "axis", "=", "0", ")", ".", "transpose", "(", "[", "1", ",", "0", "]", ")", "\n", "\n", "values", "=", "np", ".", "concatenate", "(", "(", "values_neg", ",", "values_pos", ")", ")", "\n", "labels", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "zeros_like", "(", "densities_neg", ")", ",", "np", ".", "ones_like", "(", "densities_pos", ")", ")", ")", "\n", "\n", "lr", "=", "LogisticRegressionCV", "(", "n_jobs", "=", "-", "1", ")", ".", "fit", "(", "values", ",", "labels", ")", "\n", "\n", "return", "values", ",", "labels", ",", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.compute_roc": [[712, 733], ["sklearn.metrics.roc_curve", "sklearn.metrics.roc_auc_score", "matplotlib.figure", "matplotlib.plot", "matplotlib.legend", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show"], "function", ["None"], ["", "def", "compute_roc", "(", "y_true", ",", "y_pred", ",", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param y_true: ground truth\n    :param y_pred: predictions\n    :param plot:\n    :return:\n    \"\"\"", "\n", "fpr", ",", "tpr", ",", "_", "=", "roc_curve", "(", "y_true", ",", "y_pred", ")", "\n", "auc_score", "=", "roc_auc_score", "(", "y_true", ",", "y_pred", ")", "\n", "if", "plot", ":", "\n", "        ", "plt", ".", "figure", "(", "figsize", "=", "(", "7", ",", "6", ")", ")", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'blue'", ",", "\n", "label", "=", "'ROC (AUC = %0.4f)'", "%", "auc_score", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ")", "\n", "plt", ".", "title", "(", "\"ROC Curve\"", ")", "\n", "plt", ".", "xlabel", "(", "\"FPR\"", ")", "\n", "plt", ".", "ylabel", "(", "\"TPR\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "fpr", ",", "tpr", ",", "auc_score", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.compute_roc_rfeinman": [[735, 758], ["numpy.concatenate", "numpy.concatenate", "sklearn.metrics.roc_curve", "sklearn.metrics.auc", "matplotlib.figure", "matplotlib.plot", "matplotlib.legend", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "numpy.zeros_like", "numpy.ones_like"], "function", ["None"], ["", "def", "compute_roc_rfeinman", "(", "probs_neg", ",", "probs_pos", ",", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    TODO\n    :param probs_neg:\n    :param probs_pos:\n    :param plot:\n    :return:\n    \"\"\"", "\n", "probs", "=", "np", ".", "concatenate", "(", "(", "probs_neg", ",", "probs_pos", ")", ")", "\n", "labels", "=", "np", ".", "concatenate", "(", "(", "np", ".", "zeros_like", "(", "probs_neg", ")", ",", "np", ".", "ones_like", "(", "probs_pos", ")", ")", ")", "\n", "fpr", ",", "tpr", ",", "_", "=", "roc_curve", "(", "labels", ",", "probs", ")", "\n", "auc_score", "=", "auc", "(", "fpr", ",", "tpr", ")", "\n", "if", "plot", ":", "\n", "        ", "plt", ".", "figure", "(", "figsize", "=", "(", "7", ",", "6", ")", ")", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'blue'", ",", "\n", "label", "=", "'ROC (AUC = %0.4f)'", "%", "auc_score", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ")", "\n", "plt", ".", "title", "(", "\"ROC Curve\"", ")", "\n", "plt", ".", "xlabel", "(", "\"FPR\"", ")", "\n", "plt", ".", "ylabel", "(", "\"TPR\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "fpr", ",", "tpr", ",", "auc_score", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.random_split": [[759, 776], ["print", "int", "numpy.random.permutation"], "function", ["None"], ["", "def", "random_split", "(", "X", ",", "Y", ")", ":", "\n", "    ", "\"\"\"\n    Random split the data into 80% for training and 20% for testing\n    :param X: \n    :param Y: \n    :return: \n    \"\"\"", "\n", "print", "(", "\"random split 80%, 20% for training and testing\"", ")", "\n", "num_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "num_train", "=", "int", "(", "num_samples", "*", "0.8", ")", "\n", "rand_pert", "=", "np", ".", "random", ".", "permutation", "(", "num_samples", ")", "\n", "X", "=", "X", "[", "rand_pert", "]", "\n", "Y", "=", "Y", "[", "rand_pert", "]", "\n", "X_train", ",", "X_test", "=", "X", "[", ":", "num_train", "]", ",", "X", "[", "num_train", ":", "]", "\n", "Y_train", ",", "Y_test", "=", "Y", "[", ":", "num_train", "]", ",", "Y", "[", "num_train", ":", "]", "\n", "\n", "return", "X_train", ",", "Y_train", ",", "X_test", ",", "Y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.mariusarvinte_wavelet-patch-detection.LID.util.block_split": [[777, 800], ["print", "int", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "int"], "function", ["None"], ["", "def", "block_split", "(", "X", ",", "Y", ")", ":", "\n", "    ", "\"\"\"\n    Split the data into 80% for training and 20% for testing\n    in a block size of 100.\n    :param X: \n    :param Y: \n    :return: \n    \"\"\"", "\n", "print", "(", "\"Isolated split 80%, 20% for training and testing\"", ")", "\n", "num_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "partition", "=", "int", "(", "num_samples", "/", "3", ")", "\n", "X_adv", ",", "Y_adv", "=", "X", "[", ":", "partition", "]", ",", "Y", "[", ":", "partition", "]", "\n", "X_norm", ",", "Y_norm", "=", "X", "[", "partition", ":", "2", "*", "partition", "]", ",", "Y", "[", "partition", ":", "2", "*", "partition", "]", "\n", "X_noisy", ",", "Y_noisy", "=", "X", "[", "2", "*", "partition", ":", "]", ",", "Y", "[", "2", "*", "partition", ":", "]", "\n", "num_train", "=", "int", "(", "partition", "*", "0.008", ")", "*", "100", "\n", "\n", "X_train", "=", "np", ".", "concatenate", "(", "(", "X_norm", "[", ":", "num_train", "]", ",", "X_noisy", "[", ":", "num_train", "]", ",", "X_adv", "[", ":", "num_train", "]", ")", ")", "\n", "Y_train", "=", "np", ".", "concatenate", "(", "(", "Y_norm", "[", ":", "num_train", "]", ",", "Y_noisy", "[", ":", "num_train", "]", ",", "Y_adv", "[", ":", "num_train", "]", ")", ")", "\n", "\n", "X_test", "=", "np", ".", "concatenate", "(", "(", "X_norm", "[", "num_train", ":", "]", ",", "X_noisy", "[", "num_train", ":", "]", ",", "X_adv", "[", "num_train", ":", "]", ")", ")", "\n", "Y_test", "=", "np", ".", "concatenate", "(", "(", "Y_norm", "[", "num_train", ":", "]", ",", "Y_noisy", "[", "num_train", ":", "]", ",", "Y_adv", "[", "num_train", ":", "]", ")", ")", "\n", "\n", "return", "X_train", ",", "Y_train", ",", "X_test", ",", "Y_test", "\n", "\n"]]}