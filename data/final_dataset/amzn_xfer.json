{"home.repos.pwc.inspect_result.amzn_xfer.docs.conf.Mock.__getattr__": [[27, 30], ["unittest.mock.MagicMock"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "__getattr__", "(", "cls", ",", "name", ")", ":", "\n", "        ", "return", "MagicMock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mxnet_module": [[39, 48], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.mod.Module"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "create_mxnet_module", "(", ")", ":", "\n", "# Define an mxnet Module with 2 layers", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", ",", "name", "=", "RepurposerTestUtils", ".", "LAYER_FC1", ",", "num_hidden", "=", "64", ")", "\n", "relu1", "=", "mx", ".", "sym", ".", "Activation", "(", "fc1", ",", "name", "=", "RepurposerTestUtils", ".", "LAYER_RELU", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "relu1", ",", "name", "=", "RepurposerTestUtils", ".", "LAYER_FC2", ",", "num_hidden", "=", "5", ")", "\n", "out", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "fc2", ",", "name", "=", "RepurposerTestUtils", ".", "LAYER_SOFTMAX", ")", "\n", "return", "mx", ".", "mod", ".", "Module", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object": [[49, 54], ["unittest.mock.Mock"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_mock_model_handler_object", "(", ")", ":", "\n", "        ", "mock_model_handler", "=", "Mock", "(", ")", "\n", "mock_model_handler", ".", "layer_names", "=", "RepurposerTestUtils", ".", "ALL_LAYERS", "\n", "return", "mock_model_handler", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_image_iterator": [[55, 61], ["mxnet.image.ImageIter"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_image_iterator", "(", ")", ":", "\n", "        ", "image_list", "=", "[", "[", "0", ",", "'accordion/image_0001.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0002.jpg'", "]", ",", "[", "1", ",", "'ant/image_0001.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0002.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0001.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0002.jpg'", "]", "]", "\n", "return", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "image_list", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmax_label'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal": [[62, 69], ["repurposer_test_utils.RepurposerTestUtils.assert_provide_equal", "repurposer_test_utils.RepurposerTestUtils.assert_provide_equal", "repurposer1.__dict__.keys", "repurposer2.__dict__.keys", "repurposer1.get_params", "repurposer2.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_provide_equal", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_provide_equal", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "@", "staticmethod", "\n", "def", "_assert_common_attributes_equal", "(", "repurposer1", ",", "repurposer2", ")", ":", "\n", "        ", "assert", "repurposer1", ".", "__dict__", ".", "keys", "(", ")", "==", "repurposer2", ".", "__dict__", ".", "keys", "(", ")", "\n", "assert", "repurposer1", ".", "_save_source_model_default", "==", "repurposer2", ".", "_save_source_model_default", "\n", "RepurposerTestUtils", ".", "assert_provide_equal", "(", "repurposer1", ".", "provide_data", ",", "repurposer2", ".", "provide_data", ")", "\n", "RepurposerTestUtils", ".", "assert_provide_equal", "(", "repurposer1", ".", "provide_label", ",", "repurposer2", ".", "provide_label", ")", "\n", "assert", "repurposer1", ".", "get_params", "(", ")", "==", "repurposer2", ".", "get_params", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_provide_equal": [[70, 78], ["len", "len", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "assert_provide_equal", "(", "provide1", ",", "provide2", ")", ":", "\n", "        ", "if", "provide1", "is", "None", ":", "\n", "            ", "assert", "provide2", "is", "None", "\n", "return", "\n", "", "assert", "len", "(", "provide1", ")", "==", "len", "(", "provide2", ")", "\n", "assert", "provide1", "[", "0", "]", "[", "0", "]", "==", "provide2", "[", "0", "]", "[", "0", "]", "\n", "assert", "len", "(", "provide1", "[", "0", "]", "[", "1", "]", ")", "==", "len", "(", "provide2", "[", "0", "]", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix": [[79, 84], ["os.listdir", "filename.startswith", "os.remove"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_remove_files_with_prefix", "(", "prefix", ")", ":", "\n", "        ", "for", "filename", "in", "os", ".", "listdir", "(", "'.'", ")", ":", "\n", "            ", "if", "filename", ".", "startswith", "(", "prefix", ")", ":", "\n", "                ", "os", ".", "remove", "(", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.download_vgg19": [[85, 90], ["mxnet.test_utils.download", "mxnet.test_utils.download"], "methods", ["None"], ["", "", "", "@", "staticmethod", "\n", "def", "download_vgg19", "(", ")", ":", "\n", "# Download vgg19 (trained on imagenet)", "\n", "        ", "[", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'vgg/vgg19-0000.params'", ")", ",", "\n", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'vgg/vgg19-symbol.json'", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.download_squeezenet": [[91, 96], ["mxnet.test_utils.download", "mxnet.test_utils.download"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "download_squeezenet", "(", ")", ":", "\n", "# Download squeezenet (trained on imagenet)", "\n", "        ", "[", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'squeezenet/squeezenet_v1.1-0000.params'", ")", ",", "\n", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'squeezenet/squeezenet_v1.1-symbol.json'", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.download_resnet": [[97, 102], ["mxnet.test_utils.download", "mxnet.test_utils.download"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "download_resnet", "(", ")", ":", "\n", "# Download reset (trained on imagenet)", "\n", "        ", "[", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'resnet/101-layers/resnet-101-0000.params'", ")", ",", "\n", "mx", ".", "test_utils", ".", "download", "(", "MXNET_MODEL_ZOO_PATH", "+", "'resnet/101-layers/resnet-101-symbol.json'", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.unzip_mnist_sample": [[103, 108], ["zipfile.ZipFile", "zipfile.ZipFile.extractall", "zipfile.ZipFile.close"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "unzip_mnist_sample", "(", ")", ":", "\n", "        ", "zip_ref", "=", "zipfile", ".", "ZipFile", "(", "'tests/data/mnist_sample.zip'", ",", "'r'", ")", "\n", "zip_ref", ".", "extractall", "(", "'.'", ")", "\n", "zip_ref", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_img_iter": [[109, 134], ["classes.sort", "zip", "random.shuffle", "mxnet.image.ImageIter", "os.path.isdir", "ValueError", "glob.glob", "glob.glob.sort", "imglist.append", "x.split", "glob.glob", "len", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "create_img_iter", "(", "data_dir", ",", "batch_size", ",", "label_name", "=", "'softmax_label'", ")", ":", "\n", "# assert dir exists", "\n", "        ", "if", "not", "os", ".", "path", ".", "isdir", "(", "data_dir", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Directory not found: {}'", ".", "format", "(", "data_dir", ")", ")", "\n", "# get class names", "\n", "", "classes", "=", "[", "x", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "for", "x", "in", "glob", ".", "glob", "(", "data_dir", "+", "'/*'", ")", "]", "\n", "classes", ".", "sort", "(", ")", "\n", "fnames", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "for", "c", "in", "classes", ":", "\n", "# get all the image filenames and labels", "\n", "            ", "images", "=", "glob", ".", "glob", "(", "data_dir", "+", "'/'", "+", "c", "+", "'/*'", ")", "\n", "images", ".", "sort", "(", ")", "\n", "fnames", "+=", "images", "\n", "labels", "+=", "[", "c", "]", "*", "len", "(", "images", ")", "\n", "# create imglist for ImageIter", "\n", "", "imglist", "=", "[", "]", "\n", "for", "label", ",", "filename", "in", "zip", "(", "labels", ",", "fnames", ")", ":", "\n", "            ", "imglist", ".", "append", "(", "[", "int", "(", "label", ")", ",", "filename", "]", ")", "\n", "\n", "", "random", ".", "shuffle", "(", "imglist", ")", "\n", "# make iterators", "\n", "iterator", "=", "mx", ".", "image", ".", "ImageIter", "(", "batch_size", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "imglist", ",", "label_name", "=", "label_name", ",", "path_root", "=", "''", ")", "\n", "return", "iterator", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_labels": [[135, 145], ["iterator.reset", "iterator.next().label[].asnumpy().astype().tolist", "iterator.next().label[].asnumpy().astype", "iterator.next().label[].asnumpy", "iterator.next"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset"], ["", "@", "staticmethod", "\n", "def", "get_labels", "(", "iterator", ")", ":", "\n", "        ", "iterator", ".", "reset", "(", ")", "\n", "labels", "=", "[", "]", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "labels", "=", "labels", "+", "iterator", ".", "next", "(", ")", ".", "label", "[", "0", "]", ".", "asnumpy", "(", ")", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_feature_indices_equal": [[146, 159], ["AssertionError", "AssertionError", "type", "type", "expected_feature_indices.keys", "actual_feature_indices.keys", "numpy.array_equal", "AssertionError", "type", "type", "actual_feature_indices.keys", "expected_feature_indices.keys"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "assert_feature_indices_equal", "(", "expected_feature_indices", ",", "actual_feature_indices", ")", ":", "\n", "        ", "if", "not", "type", "(", "expected_feature_indices", ")", "==", "type", "(", "actual_feature_indices", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Incorrect feature_indices type: {}. Expected: {}\"", "\n", ".", "format", "(", "type", "(", "actual_feature_indices", ")", ",", "type", "(", "expected_feature_indices", ")", ")", ")", "\n", "\n", "", "if", "not", "expected_feature_indices", ".", "keys", "(", ")", "==", "actual_feature_indices", ".", "keys", "(", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Incorrect keys in feature_indices: {}. Expected: {}\"", "\n", ".", "format", "(", "actual_feature_indices", ".", "keys", "(", ")", ",", "expected_feature_indices", ".", "keys", "(", ")", ")", ")", "\n", "\n", "", "for", "key", "in", "expected_feature_indices", ":", "\n", "            ", "if", "not", "np", ".", "array_equal", "(", "expected_feature_indices", "[", "key", "]", ",", "actual_feature_indices", "[", "key", "]", ")", ":", "\n", "                ", "raise", "AssertionError", "(", "\"Incorrect values in feature_indices dictionary\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mnist_test_iterator": [[160, 164], ["mxnet.io.MNISTIter"], "methods", ["None"], ["", "", "", "@", "staticmethod", "\n", "def", "create_mnist_test_iterator", "(", ")", ":", "\n", "# Create data iterator for mnist test images", "\n", "        ", "return", "mx", ".", "io", ".", "MNISTIter", "(", "image", "=", "'tests/data/t10k-images-idx3-ubyte'", ",", "label", "=", "'tests/data/t10k-labels-idx1-ubyte'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.tests.conftest.pytest_addoption": [[20, 24], ["parser.addoption"], "function", ["None"], ["def", "pytest_addoption", "(", "parser", ")", ":", "\n", "    ", "for", "option", "in", "test_flags", ":", "\n", "        ", "parser", ".", "addoption", "(", "\n", "\"--{}\"", ".", "format", "(", "option", ")", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ",", "help", "=", "\"run {} tests\"", ".", "format", "(", "option", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.tests.conftest.pytest_collection_modifyitems": [[27, 36], ["config.getoption", "pytest.mark.skip", "item.add_marker"], "function", ["None"], ["", "", "def", "pytest_collection_modifyitems", "(", "config", ",", "items", ")", ":", "\n", "    ", "for", "option", "in", "test_flags", ":", "\n", "        ", "if", "config", ".", "getoption", "(", "\"--{}\"", ".", "format", "(", "option", ")", ")", ":", "\n", "# --option given in cli: do not skip 'option' tests", "\n", "            ", "continue", "\n", "", "skip_test", "=", "pytest", ".", "mark", ".", "skip", "(", "reason", "=", "\"need --{} option to run\"", ".", "format", "(", "option", ")", ")", "\n", "for", "item", "in", "items", ":", "\n", "            ", "if", "option", "in", "item", ".", "keywords", ":", "\n", "                ", "item", ".", "add_marker", "(", "skip_test", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.setUp": [[34, 37], ["repurposer_test_utils.RepurposerTestUtils.create_mxnet_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mxnet_module"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "source_model", "=", "RepurposerTestUtils", ".", "create_mxnet_module", "(", ")", "\n", "self", ".", "repurposer_class", "=", "MetaModelRepurposer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.test_instantiation_valid_input": [[38, 44], ["test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertTrue"], "methods", ["None"], ["", "def", "test_instantiation_valid_input", "(", "self", ")", ":", "\n", "        ", "feature_layer_names_in_source_model", "=", "[", "RepurposerTestUtils", ".", "LAYER_FC1", "]", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "source_model", ",", "feature_layer_names_in_source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "source_model", "==", "self", ".", "source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "feature_layer_names", "==", "feature_layer_names_in_source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "source_model_handler", ".", "layer_names", "==", "RepurposerTestUtils", ".", "ALL_LAYERS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.test_instantiation_feature_layer_names_not_in_source_model": [[45, 55], ["test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertRaisesRegex", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertRaisesRegex"], "methods", ["None"], ["", "def", "test_instantiation_feature_layer_names_not_in_source_model", "(", "self", ")", ":", "\n", "# Some feature_layer_names not found in source_model", "\n", "        ", "feature_layer_names_some_not_in_source_model", "=", "[", "RepurposerTestUtils", ".", "LAYER_FC1", ",", "'phantom_layer_2'", "]", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "\"feature_layer_name 'phantom_layer_2' is not found in source_model\"", ",", "\n", "self", ".", "repurposer_class", ",", "self", ".", "source_model", ",", "feature_layer_names_some_not_in_source_model", ")", "\n", "\n", "# All feature_layer_names not found in source_model", "\n", "feature_layer_names_all_not_in_source_model", "=", "[", "'phantom_layer_1'", ",", "'phantom_layer_2'", "]", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "\"feature_layer_name 'phantom_layer_1' is not found in source_model\"", ",", "\n", "self", ".", "repurposer_class", ",", "self", ".", "source_model", ",", "feature_layer_names_all_not_in_source_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.test_get_features_from_source_model_single_layer": [[56, 64], ["collections.OrderedDict", "numpy.arange", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest._test_get_features_from_source_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model"], ["", "def", "test_get_features_from_source_model_single_layer", "(", "self", ")", ":", "\n", "# Test with one feature layer", "\n", "        ", "feature_layer_names", "=", "[", "'fullyconnected1'", "]", "\n", "expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "0", ",", "64", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "64", ")", ",", "\n", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.test_get_features_from_source_model_multiple_layers": [[65, 82], ["collections.OrderedDict", "numpy.arange", "numpy.arange", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest._test_get_features_from_source_model", "collections.OrderedDict", "numpy.arange", "numpy.arange", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest._test_get_features_from_source_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model"], ["", "def", "test_get_features_from_source_model_multiple_layers", "(", "self", ")", ":", "\n", "# Test with two feature layers", "\n", "        ", "feature_layer_names", "=", "[", "'fullyconnected1'", ",", "'fullyconnected2'", "]", "\n", "expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "0", ",", "64", ")", "\n", "expected_feature_indices", "[", "'fullyconnected2'", "]", "=", "np", ".", "arange", "(", "64", ",", "74", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "74", ")", ",", "\n", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n", "feature_layer_names", "=", "[", "'fullyconnected2'", ",", "'fullyconnected1'", "]", "\n", "expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected2'", "]", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "\n", "expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "10", ",", "74", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "74", ")", ",", "\n", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_meta_model_repurposer.MetaModelRepurposerIntegrationTest._test_get_features_from_source_model": [[83, 98], ["mxnet.module.Module.load", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.repurposer_class", "repurposer_test_utils.RepurposerTestUtils.create_mnist_test_iterator", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.get_features_from_source_model", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerIntegrationTest.assertTrue", "repurposer_test_utils.RepurposerTestUtils.assert_feature_indices_equal", "numpy.array_equal", "repurposer_test_utils.RepurposerTestUtils.get_labels"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mnist_test_iterator", "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_feature_indices_equal", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_labels"], ["", "def", "_test_get_features_from_source_model", "(", "self", ",", "feature_layer_names", ",", "expected_outputs", ")", ":", "\n", "# Create repurposer", "\n", "        ", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "prefix", "=", "RepurposerTestUtils", ".", "MNIST_MODEL_PATH_PREFIX", ",", "epoch", "=", "10", ")", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "source_model", "=", "source_model", ",", "feature_layer_names", "=", "feature_layer_names", ")", "\n", "\n", "# Create data iterator to extract features from source model", "\n", "data_iterator", "=", "RepurposerTestUtils", ".", "create_mnist_test_iterator", "(", ")", "\n", "meta_model_data", "=", "repurposer", ".", "get_features_from_source_model", "(", "data_iterator", "=", "data_iterator", ")", "\n", "\n", "# Compare with expected outputs", "\n", "self", ".", "assertTrue", "(", "meta_model_data", ".", "features", ".", "shape", "==", "expected_outputs", "[", "self", ".", "EXPECTED_FEATURE_SHAPE", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "meta_model_data", ".", "labels", ",", "RepurposerTestUtils", ".", "get_labels", "(", "data_iterator", ")", ")", ")", "\n", "expected_feature_indices_per_layer", "=", "expected_outputs", "[", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", "]", "\n", "RepurposerTestUtils", ".", "assert_feature_indices_equal", "(", "expected_feature_indices_per_layer", ",", "\n", "meta_model_data", ".", "feature_indices_per_layer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.WorkflowTestCase.setUp": [[31, 52], ["numpy.random.seed", "random.seed", "mxnet.random.seed", "repurposer_test_utils.RepurposerTestUtils.download_squeezenet", "repurposer_test_utils.RepurposerTestUtils.unzip_mnist_sample", "mxnet.module.Module.load", "repurposer_test_utils.RepurposerTestUtils.create_img_iter", "repurposer_test_utils.RepurposerTestUtils.create_img_iter", "repurposer_test_utils.RepurposerTestUtils.get_labels"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.download_squeezenet", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.unzip_mnist_sample", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_img_iter", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_img_iter", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_labels"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "random", ".", "seed", "(", "1", ")", "\n", "mx", ".", "random", ".", "seed", "(", "1", ")", "\n", "\n", "self", ".", "label_name", "=", "'prob_label'", "\n", "self", ".", "save_name", "=", "self", ".", "__class__", ".", "__name__", "\n", "self", ".", "meta_model_feature_layer_name", "=", "[", "'flatten'", "]", "\n", "self", ".", "pre_saved_prefix", "=", "'tests/data/pre_saved_repurposers/pre_saved_'", "\n", "self", ".", "expected_accuracy", "=", "None", "# Overridden in derived classes", "\n", "\n", "RepurposerTestUtils", ".", "download_squeezenet", "(", ")", "\n", "RepurposerTestUtils", ".", "unzip_mnist_sample", "(", ")", "\n", "\n", "# Load source model", "\n", "self", ".", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'squeezenet_v1.1'", ",", "0", ",", "label_names", "=", "[", "self", ".", "label_name", "]", ",", "\n", "data_names", "=", "(", "'data'", ",", ")", ")", "\n", "# Create train and test data iterators", "\n", "self", ".", "train_iter", "=", "RepurposerTestUtils", ".", "create_img_iter", "(", "'mnist_sample/train'", ",", "20", ",", "self", ".", "label_name", ")", "\n", "self", ".", "test_iter", "=", "RepurposerTestUtils", ".", "create_img_iter", "(", "'mnist_sample/test'", ",", "20", ",", "self", ".", "label_name", ")", "\n", "self", ".", "test_labels", "=", "RepurposerTestUtils", ".", "get_labels", "(", "self", ".", "test_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.WorkflowTestCase.get_repurposer": [[53, 56], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.WorkflowTestCase.test_workflow": [[57, 95], ["repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "test_workflow.WorkflowTestCase.get_repurposer", "numpy.random.seed", "random.seed", "mxnet.random.seed", "xfer.load.repurpose", "xfer.load.predict_label", "numpy.mean", "test_workflow.WorkflowTestCase.assert_accuracy", "xfer.load.save_repurposer", "repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "xfer.load.predict_label", "numpy.mean", "test_workflow.WorkflowTestCase.assert_accuracy", "xfer.load", "xfer.load"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.get_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.assert_accuracy", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.assert_accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "def", "test_workflow", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Test workflow\n\n        Instantiate repurposer(1), repurpose(2), predict(3), save & load with source model(4),\n        predict(5), repurpose(6), predict(7), save & load without model(8), predict(9)\n        \"\"\"", "\n", "if", "self", ".", "__class__", "==", "WorkflowTestCase", ":", "# base class", "\n", "            ", "return", "\n", "# remove any old saved repurposer files", "\n", "", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "self", ".", "save_name", ")", "\n", "\n", "# instantiate repurposer (1)", "\n", "rep", "=", "self", ".", "get_repurposer", "(", "self", ".", "source_model", ")", "\n", "\n", "for", "save_source_model", "in", "[", "True", ",", "False", "]", ":", "\n", "# (2/6) repurpose", "\n", "# random seeds are set before repurposing to ensure training is the same", "\n", "            ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "random", ".", "seed", "(", "1", ")", "\n", "mx", ".", "random", ".", "seed", "(", "1", ")", "\n", "rep", ".", "repurpose", "(", "self", ".", "train_iter", ")", "\n", "# (3/7) predict", "\n", "results", "=", "rep", ".", "predict_label", "(", "self", ".", "test_iter", ")", "\n", "accuracy", "=", "np", ".", "mean", "(", "results", "==", "self", ".", "test_labels", ")", "\n", "self", ".", "assert_accuracy", "(", "accuracy", ")", "\n", "# (4/8) serialise", "\n", "rep", ".", "save_repurposer", "(", "self", ".", "save_name", ",", "save_source_model", "=", "save_source_model", ")", "\n", "del", "rep", "\n", "if", "save_source_model", ":", "\n", "                ", "rep", "=", "xfer", ".", "load", "(", "self", ".", "save_name", ")", "\n", "", "else", ":", "\n", "                ", "rep", "=", "xfer", ".", "load", "(", "self", ".", "save_name", ",", "source_model", "=", "self", ".", "source_model", ")", "\n", "", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "self", ".", "save_name", ")", "\n", "# (5/9) predict", "\n", "results", "=", "rep", ".", "predict_label", "(", "self", ".", "test_iter", ")", "\n", "accuracy", "=", "np", ".", "mean", "(", "results", "==", "self", ".", "test_labels", ")", "\n", "self", ".", "assert_accuracy", "(", "accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.WorkflowTestCase.test_load_pre_saved_repurposer": [[96, 107], ["xfer.load", "xfer.load.predict_label", "numpy.mean", "test_workflow.WorkflowTestCase.assert_accuracy"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.assert_accuracy"], ["", "", "def", "test_load_pre_saved_repurposer", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test case to check for backward compatibility of deserialization \"\"\"", "\n", "if", "self", ".", "__class__", "==", "WorkflowTestCase", ":", "# base class", "\n", "            ", "return", "\n", "# Load pre-saved repurposer from file", "\n", "", "repurposer_file_prefix", "=", "self", ".", "pre_saved_prefix", "+", "self", ".", "__class__", ".", "__name__", "\n", "repurposer", "=", "xfer", ".", "load", "(", "repurposer_file_prefix", ",", "source_model", "=", "self", ".", "source_model", ")", "\n", "# Validate accuracy of predictions", "\n", "predicted_labels", "=", "repurposer", ".", "predict_label", "(", "self", ".", "test_iter", ")", "\n", "accuracy", "=", "np", ".", "mean", "(", "predicted_labels", "==", "self", ".", "test_labels", ")", "\n", "self", ".", "assert_accuracy", "(", "accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.WorkflowTestCase.assert_accuracy": [[108, 111], ["test_workflow.WorkflowTestCase.assertTrue"], "methods", ["None"], ["", "def", "assert_accuracy", "(", "self", ",", "accuracy", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "accuracy", "==", "self", ".", "expected_accuracy", ",", "\n", "'accuracy: {}, expected: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "expected_accuracy", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.LrWorkflowTestCase.setUp": [[114, 118], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "# Will assert that accuracy of model is equal to expected_accuracy", "\n", "self", ".", "expected_accuracy", "=", "0.95", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.LrWorkflowTestCase.get_repurposer": [[119, 121], ["xfer.LrRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "xfer", ".", "LrRepurposer", "(", "source_model", ",", "self", ".", "meta_model_feature_layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.SvmWorkflowTestCase.setUp": [[124, 127], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "expected_accuracy", "=", "0.92", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.SvmWorkflowTestCase.get_repurposer": [[128, 130], ["xfer.SvmRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "xfer", ".", "SvmRepurposer", "(", "source_model", ",", "self", ".", "meta_model_feature_layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.SvmWorkflowTestCase.test_load_pre_saved_repurposer": [[131, 135], ["pytest.mark.skipif"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "sys", ".", "version_info", ">", "(", "3", ",", "4", ")", ",", "reason", "=", "'test fails on versions of python newer than 3.4 due to '", "\n", "'pickle not working with newer version of scikit-learn'", ")", "\n", "def", "test_load_pre_saved_repurposer", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.GpWorkflowTestCase.setUp": [[138, 141], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "expected_accuracy", "=", "0.88", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.GpWorkflowTestCase.get_repurposer": [[142, 146], ["xfer.GpRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "rep", "=", "xfer", ".", "GpRepurposer", "(", "source_model", ",", "self", ".", "meta_model_feature_layer_name", ",", "apply_l2_norm", "=", "True", ")", "\n", "rep", ".", "NUM_INDUCING_SPARSE_GP", "=", "5", "\n", "return", "rep", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.BnnWorkflowTestCase.setUp": [[149, 152], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "min_accuracy", "=", "0.59", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.BnnWorkflowTestCase.get_repurposer": [[153, 156], ["xfer.BnnRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "xfer", ".", "BnnRepurposer", "(", "source_model", ",", "self", ".", "meta_model_feature_layer_name", ",", "num_samples_mc_prediction", "=", "10", ",", "\n", "num_epochs", "=", "200", ",", "num_samples_mc", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.BnnWorkflowTestCase.assert_accuracy": [[157, 160], ["test_workflow.BnnWorkflowTestCase.assertTrue"], "methods", ["None"], ["", "def", "assert_accuracy", "(", "self", ",", "accuracy", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "accuracy", ">=", "self", ".", "min_accuracy", ",", "\n", "'accuracy: {}, minimum expected: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "min_accuracy", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnftWorkflowTestCase.setUp": [[163, 168], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "# Will assert that accuracy of model is >= min_accuracy", "\n", "self", ".", "min_accuracy", "=", "0.40", "\n", "self", ".", "prev_accuracy", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnftWorkflowTestCase.get_repurposer": [[169, 172], ["xfer.NeuralNetworkFineTuneRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "xfer", ".", "NeuralNetworkFineTuneRepurposer", "(", "source_model", ",", "transfer_layer_name", "=", "'flatten'", ",", "target_class_count", "=", "5", ",", "\n", "num_epochs", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnftWorkflowTestCase.assert_accuracy": [[173, 179], ["None"], "methods", ["None"], ["", "def", "assert_accuracy", "(", "self", ",", "accuracy", ")", ":", "\n", "        ", "assert", "accuracy", ">=", "self", ".", "min_accuracy", ",", "'accuracy: {}, min expected: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "min_accuracy", ")", "\n", "if", "self", ".", "prev_accuracy", "is", "None", ":", "\n", "            ", "self", ".", "prev_accuracy", "=", "accuracy", "\n", "", "else", ":", "\n", "            ", "assert", "accuracy", "==", "self", ".", "prev_accuracy", ",", "'accuracy: {}, previous: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "prev_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.setUp": [[182, 186], ["test_workflow.WorkflowTestCase.setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "min_accuracy", "=", "0.58", "\n", "self", ".", "prev_accuracy", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.get_repurposer": [[187, 194], ["xfer.NeuralNetworkRandomFreezeRepurposer"], "methods", ["None"], ["", "def", "get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "fixed_layers", "=", "[", "'conv1'", ",", "'fire2_squeeze1x1'", ",", "'fire2_expand1x1'", ",", "'fire2_expand3x3'", ",", "'fire3_squeeze1x1'", ",", "\n", "'fire3_expand1x1'", ",", "'fire3_expand3x3'", ",", "'fire4_squeeze1x1'", ",", "'fire4_expand1x1'", ",", "'fire4_expand3x3'", ",", "\n", "'fire5_squeeze1x1'", ",", "'fire5_expand1x1'", ",", "'fire5_expand3x3'", "]", "\n", "random_layers", "=", "[", "'conv10'", "]", "\n", "return", "xfer", ".", "NeuralNetworkRandomFreezeRepurposer", "(", "source_model", ",", "target_class_count", "=", "5", ",", "fixed_layers", "=", "fixed_layers", ",", "\n", "random_layers", "=", "random_layers", ",", "num_epochs", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.integration.test_workflow.NnrfWorkflowTestCase.assert_accuracy": [[195, 201], ["None"], "methods", ["None"], ["", "def", "assert_accuracy", "(", "self", ",", "accuracy", ")", ":", "\n", "        ", "assert", "accuracy", ">=", "self", ".", "min_accuracy", ",", "'accuracy: {}, min expected: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "min_accuracy", ")", "\n", "if", "self", ".", "prev_accuracy", "is", "None", ":", "\n", "            ", "self", ".", "prev_accuracy", "=", "accuracy", "\n", "", "else", ":", "\n", "            ", "assert", "accuracy", "==", "self", ".", "prev_accuracy", ",", "'accuracy: {}, previous: {}'", ".", "format", "(", "accuracy", ",", "self", ".", "prev_accuracy", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._notebook_run": [[22, 55], ["os.path.isfile", "os.remove", "os.remove", "open", "open", "nbformat.read", "subprocess.check_call", "print"], "function", ["None"], ["def", "_notebook_run", "(", "notebook", ")", ":", "\n", "    ", "\"\"\"\n    Execute a notebook via nbconvert and collect output.\n       :return: (parsed nb object, execution errors)\n    \"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "temp_notebook", ")", ":", "\n", "        ", "os", ".", "remove", "(", "temp_notebook", ")", "\n", "\n", "", "with", "open", "(", "temp_notebook", ",", "'w'", ")", "as", "fout", ":", "\n", "# with tempfile.NamedTemporaryFile(suffix=\".ipynb\") as fout:", "\n", "        ", "args", "=", "[", "\"jupyter\"", ",", "\"nbconvert\"", ",", "\"--to\"", ",", "\"notebook\"", ",", "\"--execute\"", ",", "\"--allow-errors\"", ",", "\n", "\"--ExecutePreprocessor.timeout=-1\"", ",", "\n", "\"--output\"", ",", "fout", ".", "name", ",", "notebook", "]", "\n", "try", ":", "\n", "            ", "subprocess", ".", "check_call", "(", "args", ")", "\n", "", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "\n", "            ", "if", "e", ".", "returncode", "==", "1", ":", "\n", "# print the message and ignore error with code 1 as this indicates there were errors in the notebook", "\n", "                ", "print", "(", "e", ".", "output", ")", "\n", "pass", "\n", "", "else", ":", "\n", "# all other codes indicate some other problem, rethrow", "\n", "                ", "raise", "\n", "\n", "", "", "", "with", "open", "(", "temp_notebook", ",", "'r'", ")", "as", "fout", ":", "\n", "        ", "nb", "=", "nbformat", ".", "read", "(", "fout", ",", "nbformat", ".", "current_nbformat", ")", "\n", "\n", "", "errors", "=", "[", "output", "for", "cell", "in", "nb", ".", "cells", "if", "\"outputs\"", "in", "cell", "for", "output", "in", "cell", "[", "\"outputs\"", "]", "\n", "if", "output", ".", "output_type", "==", "\"error\"", "]", "\n", "\n", "os", ".", "remove", "(", "temp_notebook", ")", "\n", "return", "nb", ",", "errors", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._test_ipynb": [[57, 70], ["test_notebooks._notebook_run", "os.chdir", "os.chdir"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._notebook_run"], ["", "def", "_test_ipynb", "(", "notebook", ")", ":", "\n", "# Skip any temporary notebook", "\n", "    ", "if", "notebook", "==", "temp_notebook", ":", "\n", "        ", "return", "\n", "# Change working dir to demo directory", "\n", "", "if", "demo_path", "is", "not", "''", ":", "\n", "        ", "os", ".", "chdir", "(", "demo_path", ")", "\n", "# Run notebook and collect errors", "\n", "", "nb", ",", "errors", "=", "_notebook_run", "(", "notebook", ")", "\n", "# Revert to orginal working directory", "\n", "os", ".", "chdir", "(", "original_path", ")", "\n", "# Assert no errors were collected from notebook", "\n", "assert", "errors", "==", "[", "]", ",", "'Errors found in {}\\n{}'", ".", "format", "(", "notebook", ",", "errors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks.test_ipynb": [[72, 76], ["pytest.mark.parametrize", "test_notebooks._test_ipynb"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._test_ipynb"], ["", "@", "pytest", ".", "mark", ".", "notebook", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"notebook\"", ",", "demo_notebooks", ")", "\n", "def", "test_ipynb", "(", "notebook", ")", ":", "\n", "    ", "_test_ipynb", "(", "notebook", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks.test_hpo_ipynb": [[78, 83], ["pytest.mark.parametrize", "pytest.mark.skip", "test_notebooks._test_ipynb"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._test_ipynb"], ["", "@", "pytest", ".", "mark", ".", "notebook_hpo", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"notebook\"", ",", "hpo_notebook", ")", "\n", "@", "pytest", ".", "mark", ".", "skip", "(", "\"This test fails and needs to be fixed.\"", ")", "\n", "def", "test_hpo_ipynb", "(", "notebook", ")", ":", "\n", "    ", "_test_ipynb", "(", "notebook", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks.test_gluon_ipynb": [[85, 89], ["pytest.mark.parametrize", "test_notebooks._test_ipynb"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.notebook.test_notebooks._test_ipynb"], ["", "@", "pytest", ".", "mark", ".", "notebook_gluon", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"notebook\"", ",", "gluon_notebook", ")", "\n", "def", "test_gluon_ipynb", "(", "notebook", ")", ":", "\n", "    ", "_test_ipynb", "(", "notebook", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.setUp": [[25, 35], ["super().setUp", "numpy.loadtxt"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", "LrRepurposerTestCase", ",", "self", ")", ".", "setUp", "(", ")", "\n", "\n", "# Override base repurpose_class with 'LrRepurposer' to run base tests with instance of Lr Repurposer", "\n", "self", ".", "repurposer_class", "=", "LrRepurposer", "\n", "\n", "self", ".", "expected_model_coef_", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'LRmodel.coef_.out'", ")", "\n", "self", ".", "expected_model_intercept_", "=", "[", "0.", ",", "0.", ",", "0.", ",", "0.", "]", "\n", "self", ".", "expected_accuracy", "=", "0.52857142857142858", "\n", "self", ".", "target_model_path", "=", "self", ".", "_test_data_dir", "+", "'lr_model.sav'", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_train_model_from_features": [[36, 40], ["xfer.LrRepurposer", "xfer.LrRepurposer._train_model_from_features", "test_lr_repurposer.LrRepurposerTestCase._validate_trained_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model"], ["", "def", "test_train_model_from_features", "(", "self", ")", ":", "\n", "        ", "lr_repurposer", "=", "LrRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "lr_model", "=", "lr_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ")", "\n", "self", ".", "_validate_trained_model", "(", "lr_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_predict_probability_from_features": [[41, 43], ["test_lr_repurposer.LrRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "def", "test_predict_probability_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "True", ",", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_predict_label_from_features": [[44, 46], ["test_lr_repurposer.LrRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "def", "test_predict_label_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "False", ",", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_repurpose": [[47, 54], ["unittest.mock.patch", "repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_lr_repurposer.LrRepurposerTestCase._test_repurpose", "test_lr_repurposer.LrRepurposerTestCase._test_repurpose"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose"], ["", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose", "(", "self", ",", "mock_model_handler", ")", ":", "\n", "# Patch model_handler and then create lr_repurposer", "\n", "        ", "mock_model_handler", ".", "return_value", "=", "RepurposerTestUtils", ".", "get_mock_model_handler_object", "(", ")", "\n", "mock_model_handler", ".", "return_value", ".", "get_layer_output", ".", "return_value", "=", "self", ".", "train_feature_dict", ",", "self", ".", "train_labels", "\n", "self", ".", "_test_repurpose", "(", "n_jobs", "=", "-", "1", ")", "# Use all cores", "\n", "self", ".", "_test_repurpose", "(", "n_jobs", "=", "1", ")", "# Use single core", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase._test_repurpose": [[55, 58], ["xfer.LrRepurposer", "test_lr_repurposer.LrRepurposerTestCase._run_common_repurposer_tests"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._run_common_repurposer_tests"], ["", "def", "_test_repurpose", "(", "self", ",", "n_jobs", "=", "-", "1", ")", ":", "\n", "        ", "lr_repurposer", "=", "LrRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "n_jobs", "=", "n_jobs", ")", "\n", "self", ".", "_run_common_repurposer_tests", "(", "lr_repurposer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_repurpose_calls_validate": [[59, 63], ["unittest.mock.patch.object", "unittest.mock.patch", "test_lr_repurposer.LrRepurposerTestCase._test_repurpose_calls_validate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_repurpose_calls_validate"], ["", "@", "patch", ".", "object", "(", "LrRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_REPURPOSE_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose_calls_validate", "(", "self", ",", "mock_model_handler", ",", "mock_validate_method", ")", ":", "\n", "        ", "self", ".", "_test_repurpose_calls_validate", "(", "mock_model_handler", ",", "mock_validate_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_predict_probability": [[64, 69], ["unittest.mock.patch.object", "unittest.mock.patch", "test_lr_repurposer.LrRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "LrRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_probability", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "True", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_predict_label": [[70, 75], ["unittest.mock.patch.object", "unittest.mock.patch", "test_lr_repurposer.LrRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "LrRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_label", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase._validate_trained_model": [[76, 87], ["type", "test_lr_repurposer.LrRepurposerTestCase.assertTrue", "test_lr_repurposer.LrRepurposerTestCase.assertTrue", "test_lr_repurposer.LrRepurposerTestCase.assertTrue", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose", "numpy.isclose"], "methods", ["None"], ["", "def", "_validate_trained_model", "(", "self", ",", "model", ")", ":", "\n", "# Validate type of model", "\n", "        ", "expected_type", "=", "sklearn", ".", "linear_model", ".", "LogisticRegression", "\n", "actual_type", "=", "type", "(", "model", ")", "\n", "self", ".", "assertTrue", "(", "actual_type", "==", "expected_type", ",", "\n", "\"Expected model of type: {}. Instead got: {}\"", ".", "format", "(", "expected_type", ",", "actual_type", ")", ")", "\n", "\n", "# Validate properties of model", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "intercept_", ",", "self", ".", "expected_model_intercept_", ")", ".", "all", "(", ")", ",", "\n", "\"LR model intercept is incorrect\"", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "coef_", ",", "self", ".", "expected_model_coef_", ")", ".", "all", "(", ")", ",", "\"LR model co-efficient is incorrect\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_lr_repurposer.LrRepurposerTestCase.test_get_params": [[88, 102], ["xfer.LrRepurposer", "xfer.LrRepurposer.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "test_get_params", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "LrRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "\n", "params", "=", "repurposer", ".", "get_params", "(", ")", "\n", "expected_params", "=", "{", "\n", "'context_function'", ":", "'cpu'", ",", "\n", "'num_devices'", ":", "1", ",", "\n", "'feature_layer_names'", ":", "[", "'fc1'", ",", "'fc2'", "]", ",", "\n", "'tol'", ":", "0.0001", ",", "\n", "'c'", ":", "1.0", ",", "\n", "'n_jobs'", ":", "-", "1", "\n", "}", "\n", "\n", "assert", "params", "==", "expected_params", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.setUp": [[22, 31], ["super().setUp", "mxnet.image.ImageIter"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "repurposer_class", "=", "NeuralNetworkRandomFreezeRepurposer", "\n", "\n", "self", ".", "data_name", "=", "'data'", "\n", "self", ".", "imglist", "=", "[", "[", "0", ",", "'accordion/image_0001.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0002.jpg'", "]", ",", "[", "1", ",", "'ant/image_0001.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0002.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0001.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0002.jpg'", "]", "]", "\n", "self", ".", "train_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmax_label'", ",", "data_name", "=", "self", ".", "data_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.test_create_target_module__invalid_fixed_layer": [[32, 38], ["test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.repurposer_class", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.assertRaises", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._create_target_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._create_target_module"], ["", "def", "test_create_target_module__invalid_fixed_layer", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "target_class_count", "=", "2", ",", "fixed_layers", "=", "[", "'invented_layer'", "]", ",", "\n", "random_layers", "=", "[", "]", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "repurposer", ".", "_create_target_module", "(", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.test_create_target_module__invalid_random_layer": [[39, 45], ["test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.repurposer_class", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.assertRaises", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._create_target_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._create_target_module"], ["", "", "def", "test_create_target_module__invalid_random_layer", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "target_class_count", "=", "2", ",", "random_layers", "=", "[", "'invented_layer'", "]", ",", "\n", "fixed_layers", "=", "[", "]", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "repurposer", ".", "_create_target_module", "(", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.test_get_target_model_symbol__valid_transfer_layer_name": [[46, 57], ["test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.repurposer_class", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._create_target_module", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._create_target_module.symbol.get_internals().list_outputs", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._create_target_module.symbol.get_internals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._create_target_module"], ["", "", "def", "test_get_target_model_symbol__valid_transfer_layer_name", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "target_class_count", "=", "2", ",", "random_layers", "=", "[", "'fc2'", "]", ",", "\n", "fixed_layers", "=", "[", "'fc1'", "]", ")", "\n", "\n", "# Get target module", "\n", "target_module", "=", "repurposer", ".", "_create_target_module", "(", "self", ".", "train_iter", ")", "\n", "target_model_outputs", "=", "target_module", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "assert", "target_model_outputs", "==", "[", "'data'", ",", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'relu1_output'", ",", "\n", "'new_fully_connected_layer_weight'", ",", "'new_fully_connected_layer_bias'", ",", "\n", "'new_fully_connected_layer_output'", ",", "'softmax_label'", ",", "'softmax_output'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.test_get_params": [[58, 77], ["test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.repurposer_class", "test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "test_get_params", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "target_class_count", "=", "4", ",", "random_layers", "=", "[", "'rand1'", ",", "'rand2'", "]", ",", "\n", "fixed_layers", "=", "[", "'fixed1'", ",", "'fixed2'", ",", "'fixed3'", "]", ")", "\n", "\n", "params", "=", "repurposer", ".", "get_params", "(", ")", "\n", "expected_params", "=", "{", "\n", "'context_function'", ":", "'cpu'", ",", "\n", "'num_devices'", ":", "1", ",", "\n", "'optimizer'", ":", "'sgd'", ",", "\n", "'optimizer_params'", ":", "{", "'learning_rate'", ":", "0.001", "}", ",", "\n", "'batch_size'", ":", "64", ",", "\n", "'num_epochs'", ":", "5", ",", "\n", "'target_class_count'", ":", "4", ",", "\n", "'fixed_layers'", ":", "[", "'fixed1'", ",", "'fixed2'", ",", "'fixed3'", "]", ",", "\n", "'random_layers'", ":", "[", "'rand1'", ",", "'rand2'", "]", ",", "\n", "'num_layers_to_drop'", ":", "2", "\n", "}", "\n", "\n", "assert", "params", "==", "expected_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase._get_repurposer": [[78, 81], ["test_neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposerTestCase.repurposer_class"], "methods", ["None"], ["", "def", "_get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "self", ".", "repurposer_class", "(", "source_model", ",", "target_class_count", "=", "2", ",", "random_layers", "=", "[", "'conv2'", "]", ",", "\n", "fixed_layers", "=", "[", "'conv1'", "]", ",", "num_epochs", "=", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.setUp": [[27, 53], ["numpy.random.seed", "random.seed", "mxnet.random.seed", "mxnet.cpu", "xfer.prob.GaussianPrior", "xfer.prob.GaussianPrior", "xfer.prob.GaussianPrior", "xfer.prob.GaussianVariationalPosterior", "xfer.prob.GaussianVariationalPosterior", "xfer.prob.GaussianVariationalPosterior", "mxnet.nd.array", "mxnet.nd.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "random", ".", "seed", "(", "1", ")", "\n", "mx", ".", "random", ".", "seed", "(", "1", ")", "\n", "\n", "self", ".", "context", "=", "mx", ".", "cpu", "(", "0", ")", "\n", "self", ".", "obs_variables", "=", "[", "nd", ".", "array", "(", "[", "[", "1", ",", "0.5", ",", "1.5", "]", ",", "[", "2", ",", "2.5", ",", "2", "]", "]", ",", "ctx", "=", "self", ".", "context", ")", ",", "\n", "nd", ".", "array", "(", "[", "[", "3", ",", "-", "0.5", ",", "1", "]", "]", ",", "ctx", "=", "self", ".", "context", ")", "]", "\n", "self", ".", "shapes", "=", "[", "x", ".", "shape", "for", "x", "in", "self", ".", "obs_variables", "]", "\n", "\n", "self", ".", "prior1", "=", "mbprob", ".", "GaussianPrior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", "]", ",", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "self", ".", "prior2", "=", "mbprob", ".", "GaussianPrior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", "]", ",", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "self", ".", "prior3", "=", "mbprob", ".", "GaussianPrior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.5", ",", "1.0", "]", ",", "[", "-", "0.5", ",", "0.5", ",", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", ",", "3.0", ",", "4.0", "]", "]", ")", "]", ",", "\n", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "\n", "self", ".", "posterior1", "=", "mbprob", ".", "GaussianVariationalPosterior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", "]", ",", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "self", ".", "posterior2", "=", "mbprob", ".", "GaussianVariationalPosterior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", "]", ",", "self", ".", "shapes", ",", "\n", "self", ".", "context", ")", "\n", "self", ".", "posterior3", "=", "mbprob", ".", "GaussianVariationalPosterior", "(", "\n", "[", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.5", ",", "1.0", "]", ",", "[", "-", "0.5", ",", "0.5", ",", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", ",", "3.0", ",", "4.0", "]", "]", ")", "]", ",", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_prior_log_pdf": [[54, 59], ["test_prob.TestProb.prior1.log_pdf", "test_prob.TestProb.prior2.log_pdf", "test_prob.TestProb.prior3.log_pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf"], ["", "def", "test_prior_log_pdf", "(", "self", ")", ":", "\n", "# GaussianPrior", "\n", "        ", "assert", "self", ".", "prior1", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "22.270447", "\n", "assert", "self", ".", "prior2", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "20.006138", "\n", "assert", "self", ".", "prior3", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "18.323502", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_posterior_log_pdf": [[60, 65], ["test_prob.TestProb.posterior1.log_pdf", "test_prob.TestProb.posterior2.log_pdf", "test_prob.TestProb.posterior3.log_pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf"], ["", "def", "test_posterior_log_pdf", "(", "self", ")", ":", "\n", "# GaussianVariationalPosterior", "\n", "        ", "assert", "self", ".", "posterior1", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "22.270447", "\n", "assert", "self", ".", "posterior2", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "20.006138", "\n", "assert", "self", ".", "posterior3", ".", "log_pdf", "(", "self", ".", "obs_variables", ")", "==", "-", "18.323502", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_posterior_get_mean": [[66, 72], ["zip", "numpy.array", "numpy.array", "x.asnumpy", "numpy.allclose", "test_prob.TestProb.posterior3.get_mean"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.get_mean"], ["", "def", "test_posterior_get_mean", "(", "self", ")", ":", "\n", "# GaussianVariationalPosterior", "\n", "        ", "mean_ref", "=", "[", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.5", ",", "1.0", "]", ",", "[", "-", "0.5", ",", "0.5", ",", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", "\n", "mean", "=", "[", "x", ".", "asnumpy", "(", ")", "for", "x", "in", "self", ".", "posterior3", ".", "get_mean", "(", ")", "]", "\n", "for", "m", ",", "m_ref", "in", "zip", "(", "mean", ",", "mean_ref", ")", ":", "\n", "            ", "assert", "np", ".", "allclose", "(", "m", ",", "m_ref", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_posterior_is_conjugate": [[73, 76], ["test_prob.TestProb.posterior3.is_conjugate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.is_conjugate"], ["", "", "def", "test_posterior_is_conjugate", "(", "self", ")", ":", "\n", "# GaussianVariationalPosterior", "\n", "        ", "assert", "self", ".", "posterior3", ".", "is_conjugate", "(", "self", ".", "prior2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_posterior_KL": [[77, 84], ["test_prob.TestProb.posterior1.KL", "test_prob.TestProb.posterior2.KL", "test_prob.TestProb.posterior3.KL", "test_prob.TestProb.posterior3.KL", "test_prob.TestProb.posterior1.KL"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL"], ["", "def", "test_posterior_KL", "(", "self", ")", ":", "\n", "# GaussianVariationalPosterior", "\n", "        ", "assert", "self", ".", "posterior1", ".", "KL", "(", "self", ".", "prior1", ")", "==", "0", "\n", "assert", "self", ".", "posterior2", ".", "KL", "(", "self", ".", "prior2", ")", "==", "0", "\n", "assert", "self", ".", "posterior3", ".", "KL", "(", "self", ".", "prior3", ")", "==", "0", "\n", "assert", "(", "self", ".", "posterior3", ".", "KL", "(", "self", ".", "prior2", ")", "-", "2.4013877", ")", "<", "1e-5", "\n", "assert", "(", "self", ".", "posterior1", ".", "KL", "(", "self", ".", "prior2", ")", "-", "1.3294418", ")", "<", "1e-5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_likelihood_logpdf": [[85, 91], ["xfer.prob.Categorical", "test_prob.TestProb.likelihood1.set_unnormalized_mean", "mxnet.nd.array", "mxnet.nd.array", "test_prob.TestProb.likelihood1.log_pdf().asnumpy", "test_prob.TestProb.likelihood1.log_pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.set_unnormalized_mean", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf"], ["", "def", "test_likelihood_logpdf", "(", "self", ")", ":", "\n", "# Categorical", "\n", "        ", "self", ".", "likelihood1", "=", "mbprob", ".", "Categorical", "(", "self", ".", "context", ")", "\n", "self", ".", "likelihood1", ".", "set_unnormalized_mean", "(", "nd", ".", "array", "(", "[", "[", "1", ",", "0.5", ",", "1.5", "]", ",", "[", "2", ",", "2.5", ",", "2", "]", "]", ",", "ctx", "=", "self", ".", "context", ")", ")", "\n", "y", "=", "nd", ".", "array", "(", "[", "[", "1", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", ",", "0.0", "]", "]", ",", "ctx", "=", "self", ".", "context", ")", "\n", "assert", "self", ".", "likelihood1", ".", "log_pdf", "(", "y", ")", ".", "asnumpy", "(", ")", "==", "-", "1.9746466", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_prob_base_register_param": [[92, 111], ["mxnet.init.Constant", "xfer.prob.Probability", "xfer.prob.Probability._register_param", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "xfer.prob.Probability._register_param", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "[].data().asnumpy", "[].asnumpy", "[].data().asnumpy", "numpy.array", "[].asnumpy", "numpy.array", "[].data().asnumpy", "[].asnumpy", "[].data().asnumpy", "numpy.array", "[].asnumpy", "numpy.array", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "[].data", "[].data", "[].data", "[].data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param"], ["", "def", "test_prob_base_register_param", "(", "self", ")", ":", "\n", "        ", "init_means1", "=", "mx", ".", "init", ".", "Constant", "(", "3.0", ")", "\n", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "probability1", ".", "_register_param", "(", "\"mean1\"", ",", "init_means1", ",", "fix", "=", "True", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "3.0", "*", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "asnumpy", "(", ")", ",", "3.0", "*", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "3.0", "]", "]", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "3.0", "]", "]", ")", ")", "\n", "assert", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "grad_req", "==", "\"null\"", "\n", "assert", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "grad_req", "==", "\"null\"", "\n", "\n", "probability1", ".", "_register_param", "(", "\"mean2\"", ",", "init_means1", ",", "fix", "=", "[", "False", ",", "True", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "3.0", "*", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "asnumpy", "(", ")", ",", "3.0", "*", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "3.0", "]", "]", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "3.0", "]", "]", ")", ")", "\n", "assert", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "grad_req", "==", "\"write\"", "\n", "assert", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "grad_req", "==", "\"null\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_prob_base_register_param_value": [[112, 143], ["xfer.prob.Probability", "xfer.prob.Probability._register_param_value", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "xfer.prob.Probability._register_param_value", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "[].data().asnumpy", "[].asnumpy", "[].data().asnumpy", "[].asnumpy", "numpy.array", "numpy.array", "[].data().asnumpy", "[].asnumpy", "[].data().asnumpy", "[].asnumpy", "numpy.array", "numpy.array", "test_prob.TestProb.assertRaises", "xfer.prob.Probability._register_param_value", "numpy.array", "numpy.array", "numpy.array", "test_prob.TestProb.assertRaises", "xfer.prob.Probability._register_param_value", "[].data", "[].data", "[].data", "[].data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value"], ["", "def", "test_prob_base_register_param_value", "(", "self", ")", ":", "\n", "        ", "means1", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "\n", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", "\n", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "probability1", ".", "_register_param_value", "(", "\"mean1\"", ",", "means1", ",", "fix", "=", "True", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means1", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "asnumpy", "(", ")", ",", "means1", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means1", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "asnumpy", "(", ")", ",", "means1", "[", "1", "]", ")", "\n", "assert", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "0", "]", ".", "grad_req", "==", "\"null\"", "\n", "assert", "probability1", ".", "params", "[", "\"mean1\"", "]", "[", "1", "]", ".", "grad_req", "==", "\"null\"", "\n", "\n", "means2", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "\n", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", "]", "\n", "probability1", ".", "_register_param_value", "(", "\"mean2\"", ",", "means2", ",", "fix", "=", "[", "False", ",", "True", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means2", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "asnumpy", "(", ")", ",", "means2", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means2", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "probability1", ".", "raw_params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "asnumpy", "(", ")", ",", "means2", "[", "1", "]", ")", "\n", "assert", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "0", "]", ".", "grad_req", "==", "\"write\"", "\n", "assert", "probability1", ".", "params", "[", "\"mean2\"", "]", "[", "1", "]", ".", "grad_req", "==", "\"null\"", "\n", "\n", "means3", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1.0", ",", "2.0", "]", "]", ")", "]", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "probability1", ".", "_register_param_value", "(", "\"means3\"", ",", "means3", ",", "fix", "=", "True", ")", "\n", "", "means4", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "probability1", ".", "_register_param_value", "(", "\"means4\"", ",", "means4", ",", "fix", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_prob_base_replicate_shared_parameters": [[144, 153], ["xfer.prob.Probability", "xfer.prob.Probability._register_param_value", "xfer.prob.Probability._replicate_shared_parameters", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "[].asnumpy", "numpy.array", "[].asnumpy", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters"], ["", "", "def", "test_prob_base_replicate_shared_parameters", "(", "self", ")", ":", "\n", "        ", "means1", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", "\n", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "probability1", ".", "_register_param_value", "(", "\"mean1\"", ",", "means1", ",", "fix", "=", "True", ")", "\n", "raw_params_ext", "=", "probability1", ".", "_replicate_shared_parameters", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "raw_params_ext", "[", "\"mean1\"", "]", "[", "0", "]", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "\n", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "raw_params_ext", "[", "\"mean1\"", "]", "[", "1", "]", ".", "asnumpy", "(", ")", ",", "np", ".", "array", "(", "[", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_check_observation_shapes": [[154, 164], ["xfer.prob.Probability", "xfer.prob.Probability.check_observation_shapes", "numpy.zeros", "numpy.ones", "numpy.zeros", "numpy.ones", "numpy.ones", "numpy.zeros", "numpy.ones", "test_prob.TestProb.assertRaises", "xfer.prob.Probability.check_observation_shapes", "test_prob.TestProb.assertRaises", "xfer.prob.Probability.check_observation_shapes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes"], ["", "def", "test_check_observation_shapes", "(", "self", ")", ":", "\n", "        ", "obs1", "=", "[", "np", ".", "zeros", "(", "(", "2", ",", "3", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "3", ")", ")", "]", "\n", "obs2", "=", "[", "np", ".", "zeros", "(", "(", "2", ",", "3", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "3", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "3", ")", ")", "]", "\n", "obs3", "=", "[", "np", ".", "zeros", "(", "(", "2", ",", "3", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "4", ")", ")", "]", "\n", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "probability1", ".", "check_observation_shapes", "(", "obs1", ")", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "probability1", ".", "check_observation_shapes", "(", "obs2", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "probability1", ".", "check_observation_shapes", "(", "obs3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_get_params_list": [[165, 177], ["xfer.prob.Probability", "xfer.prob.Probability._register_param_value", "xfer.prob.Probability._register_param_value", "xfer.prob.Probability.get_params_list", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list_params[].data().asnumpy", "list_params[].data().asnumpy", "list_params[].data().asnumpy", "list_params[].data().asnumpy", "list_params[].data", "list_params[].data", "list_params[].data", "list_params[].data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.get_params_list"], ["", "", "def", "test_get_params_list", "(", "self", ")", ":", "\n", "        ", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "means1", "=", "[", "np", ".", "array", "(", "[", "[", "0.03629481", ",", "-", "0.4902442", ",", "-", "0.95017916", "]", ",", "[", "0.03751944", ",", "-", "0.72984636", ",", "-", "2.0401056", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", "]", "\n", "means2", "=", "[", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3.0", "]", "]", ")", "]", "\n", "probability1", ".", "_register_param_value", "(", "\"param1\"", ",", "means1", ",", "fix", "=", "True", ")", "\n", "probability1", ".", "_register_param_value", "(", "\"param2\"", ",", "means2", ",", "fix", "=", "True", ")", "\n", "list_params", "=", "probability1", ".", "get_params_list", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "list_params", "[", "0", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means1", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "list_params", "[", "1", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means1", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "list_params", "[", "2", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means2", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "list_params", "[", "3", "]", ".", "data", "(", ")", ".", "asnumpy", "(", ")", ",", "means2", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_parse_grad_req": [[178, 189], ["xfer.prob.Probability", "xfer.prob.Probability._parse_grad_req", "xfer.prob.Probability._parse_grad_req", "xfer.prob.Probability._parse_grad_req"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req"], ["", "def", "test_parse_grad_req", "(", "self", ")", ":", "\n", "        ", "probability1", "=", "mbprob", ".", "Probability", "(", "self", ".", "shapes", ",", "self", ".", "context", ")", "\n", "grad_req1", "=", "probability1", ".", "_parse_grad_req", "(", "False", ",", "2", ")", "\n", "grad_req2", "=", "probability1", ".", "_parse_grad_req", "(", "True", ",", "2", ")", "\n", "grad_req3", "=", "probability1", ".", "_parse_grad_req", "(", "[", "False", ",", "True", "]", ")", "\n", "assert", "grad_req1", "[", "0", "]", "==", "\"write\"", "\n", "assert", "grad_req1", "[", "1", "]", "==", "\"write\"", "\n", "assert", "grad_req2", "[", "0", "]", "==", "\"null\"", "\n", "assert", "grad_req2", "[", "1", "]", "==", "\"null\"", "\n", "assert", "grad_req3", "[", "0", "]", "==", "\"write\"", "\n", "assert", "grad_req3", "[", "1", "]", "==", "\"null\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_prob.TestProb.test_gaussian_var_post_save_load": [[190, 218], ["test_prob.TestProb.posterior1.save", "os.path.isfile", "os.path.isfile", "xfer.prob.GaussianVariationalPosterior.load", "test_prob.TestProb.posterior1.raw_params.keys", "test_prob.TestProb.posterior1.params.keys", "os.remove", "os.remove", "os.path.isfile", "os.path.isfile", "enumerate", "enumerate", "numpy.array_equal", "numpy.array_equal", "[].asnumpy", "[].asnumpy", "value.data", "[].data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "def", "test_gaussian_var_post_save_load", "(", "self", ")", ":", "\n", "        ", "file_path", "=", "'gvp_save'", "\n", "assert", "not", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "assert", "not", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'_params.npz'", ")", "\n", "\n", "self", ".", "posterior1", ".", "save", "(", "file_path", ")", "\n", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'_params.npz'", ")", "\n", "\n", "loaded", "=", "mbprob", ".", "GaussianVariationalPosterior", ".", "load", "(", "file_path", ")", "\n", "\n", "assert", "self", ".", "posterior1", ".", "shapes", "==", "loaded", ".", "shapes", "\n", "assert", "self", ".", "posterior1", ".", "ctx", "==", "loaded", ".", "ctx", "\n", "\n", "for", "key", "in", "self", ".", "posterior1", ".", "raw_params", ".", "keys", "(", ")", ":", "\n", "            ", "for", "count", ",", "_", "in", "enumerate", "(", "self", ".", "posterior1", ".", "raw_params", "[", "key", "]", ")", ":", "\n", "                ", "assert", "np", ".", "array_equal", "(", "self", ".", "posterior1", ".", "raw_params", "[", "key", "]", "[", "count", "]", ".", "asnumpy", "(", ")", ",", "\n", "loaded", ".", "raw_params", "[", "key", "]", "[", "count", "]", ".", "asnumpy", "(", ")", ")", "\n", "\n", "", "", "for", "key", "in", "self", ".", "posterior1", ".", "params", ".", "keys", "(", ")", ":", "\n", "            ", "for", "count", ",", "value", "in", "enumerate", "(", "self", ".", "posterior1", ".", "params", "[", "key", "]", ")", ":", "\n", "                ", "assert", "np", ".", "array_equal", "(", "value", ".", "data", "(", ")", ",", "loaded", ".", "params", "[", "key", "]", "[", "count", "]", ".", "data", "(", ")", ")", "\n", "assert", "value", ".", "grad_req", "==", "loaded", ".", "params", "[", "key", "]", "[", "count", "]", ".", "grad_req", "\n", "assert", "value", ".", "name", "==", "loaded", ".", "params", "[", "key", "]", "[", "count", "]", ".", "name", "\n", "\n", "", "", "os", ".", "remove", "(", "file_path", "+", "'.json'", ")", "\n", "os", ".", "remove", "(", "file_path", "+", "'_params.npz'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.setUp": [[32, 58], ["repurposer_test_utils.RepurposerTestUtils.create_mxnet_module", "numpy.loadtxt", "numpy.loadtxt", "len", "numpy.loadtxt().astype", "numpy.loadtxt().astype", "len", "unittest.mock.Mock", "numpy.unique", "numpy.loadtxt", "numpy.loadtxt"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mxnet_module"], ["EXPECTED_FEATURE_SHAPE", "=", "'expected_feature_shape'", "\n", "\n", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "source_model", "=", "RepurposerTestUtils", ".", "create_mxnet_module", "(", ")", "\n", "self", ".", "repurposer_class", "=", "MetaModelRepurposer", "\n", "\n", "", "def", "test_instantiation_valid_input", "(", "self", ")", ":", "\n", "        ", "feature_layer_names_in_source_model", "=", "[", "RepurposerTestUtils", ".", "LAYER_FC1", "]", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "source_model", ",", "feature_layer_names_in_source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "source_model", "==", "self", ".", "source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "feature_layer_names", "==", "feature_layer_names_in_source_model", ")", "\n", "self", ".", "assertTrue", "(", "repurposer", ".", "source_model_handler", ".", "layer_names", "==", "RepurposerTestUtils", ".", "ALL_LAYERS", ")", "\n", "\n", "", "def", "test_instantiation_feature_layer_names_not_in_source_model", "(", "self", ")", ":", "\n", "# Some feature_layer_names not found in source_model", "\n", "        ", "feature_layer_names_some_not_in_source_model", "=", "[", "RepurposerTestUtils", ".", "LAYER_FC1", ",", "'phantom_layer_2'", "]", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "\"feature_layer_name 'phantom_layer_2' is not found in source_model\"", ",", "\n", "self", ".", "repurposer_class", ",", "self", ".", "source_model", ",", "feature_layer_names_some_not_in_source_model", ")", "\n", "\n", "# All feature_layer_names not found in source_model", "\n", "feature_layer_names_all_not_in_source_model", "=", "[", "'phantom_layer_1'", ",", "'phantom_layer_2'", "]", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "\"feature_layer_name 'phantom_layer_1' is not found in source_model\"", ",", "\n", "self", ".", "repurposer_class", ",", "self", ".", "source_model", ",", "feature_layer_names_all_not_in_source_model", ")", "\n", "\n", "", "def", "test_get_features_from_source_model_single_layer", "(", "self", ")", ":", "\n", "# Test with one feature layer", "\n", "        ", "feature_layer_names", "=", "[", "'fullyconnected1'", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_instantiation_valid_input": [[59, 65], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object"], ["expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "0", ",", "64", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "64", ")", ",", "\n", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n", "", "def", "test_get_features_from_source_model_multiple_layers", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_instantiation_source_model_is_none": [[66, 71], ["unittest.mock.Mock", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex"], "methods", ["None"], ["# Test with two feature layers", "\n", "        ", "feature_layer_names", "=", "[", "'fullyconnected1'", ",", "'fullyconnected2'", "]", "\n", "expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "0", ",", "64", ")", "\n", "expected_feature_indices", "[", "'fullyconnected2'", "]", "=", "np", ".", "arange", "(", "64", ",", "74", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "74", ")", ",", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_instantiation_feature_layer_names_empty": [[72, 77], ["test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex"], "methods", ["None"], ["self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n", "feature_layer_names", "=", "[", "'fullyconnected2'", ",", "'fullyconnected1'", "]", "\n", "expected_feature_indices", "=", "OrderedDict", "(", ")", "\n", "expected_feature_indices", "[", "'fullyconnected2'", "]", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_instantiation_feature_layer_names_invalid_type": [[78, 91], ["test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex"], "methods", ["None"], ["expected_feature_indices", "[", "'fullyconnected1'", "]", "=", "np", ".", "arange", "(", "10", ",", "74", ")", "\n", "expected_outputs", "=", "{", "self", ".", "EXPECTED_FEATURE_SHAPE", ":", "(", "9984", ",", "74", ")", ",", "\n", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", ":", "expected_feature_indices", "}", "\n", "self", ".", "_test_get_features_from_source_model", "(", "feature_layer_names", ",", "expected_outputs", ")", "\n", "\n", "", "def", "_test_get_features_from_source_model", "(", "self", ",", "feature_layer_names", ",", "expected_outputs", ")", ":", "\n", "# Create repurposer", "\n", "        ", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "prefix", "=", "RepurposerTestUtils", ".", "MNIST_MODEL_PATH_PREFIX", ",", "epoch", "=", "10", ")", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "source_model", "=", "source_model", ",", "feature_layer_names", "=", "feature_layer_names", ")", "\n", "\n", "# Create data iterator to extract features from source model", "\n", "data_iterator", "=", "RepurposerTestUtils", ".", "create_mnist_test_iterator", "(", ")", "\n", "meta_model_data", "=", "repurposer", ".", "get_features_from_source_model", "(", "data_iterator", "=", "data_iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_instantiation_feature_layer_names_not_in_source_model": [[92, 104], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object"], ["# Compare with expected outputs", "\n", "self", ".", "assertTrue", "(", "meta_model_data", ".", "features", ".", "shape", "==", "expected_outputs", "[", "self", ".", "EXPECTED_FEATURE_SHAPE", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "meta_model_data", ".", "labels", ",", "RepurposerTestUtils", ".", "get_labels", "(", "data_iterator", ")", ")", ")", "\n", "expected_feature_indices_per_layer", "=", "expected_outputs", "[", "self", ".", "EXPECTED_FEATURE_INDICES_PER_LAYER", "]", "\n", "RepurposerTestUtils", ".", "assert_feature_indices_equal", "(", "expected_feature_indices_per_layer", ",", "\n", "meta_model_data", ".", "feature_indices_per_layer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_validate_before_predict": [[105, 119], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertRaisesRegex", "repurposer_test_utils.RepurposerTestUtils.create_mxnet_module", "test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_before_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mxnet_module", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_get_features_from_source_model": [[120, 157], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "numpy.array", "numpy.array", "collections.OrderedDict", "collections.OrderedDict", "numpy.array", "test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model", "collections.OrderedDict", "collections.OrderedDict", "numpy.array", "numpy.array", "numpy.array", "test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model", "collections.OrderedDict", "collections.OrderedDict", "numpy.array", "numpy.array", "numpy.array", "test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_get_features_from_source_model": [[158, 168], ["test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "numpy.array", "test_meta_model_repurposer.MetaModelRepurposerTestCase.get_features_from_source_model", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "repurposer_test_utils.RepurposerTestUtils.assert_feature_indices_equal", "numpy.array_equal", "numpy.array_equal", "unittest.mock.Mock"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.assert_feature_indices_equal"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase.test_serialisation": [[169, 174], ["test_meta_model_repurposer.MetaModelRepurposerTestCase._test_save_load_repurposed_model", "test_meta_model_repurposer.MetaModelRepurposerTestCase._test_save_load_repurposed_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_save_load_repurposed_model": [[175, 225], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "mxnet.module.Module.load", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "xfer.BnnRepurposer._train_model_from_features", "xfer.BnnRepurposer.predict_label", "os.path.isfile", "repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "xfer.load.predict_label", "test_meta_model_repurposer.MetaModelRepurposerTestCase._assert_target_model_equal", "numpy.mean", "numpy.mean", "test_meta_model_repurposer.MetaModelRepurposerTestCase._assert_attributes_equal", "xfer.BnnRepurposer", "os.path.isfile", "xfer.BnnRepurposer.save_repurposer", "os.path.isfile", "os.path.isfile", "xfer.load", "xfer.BnnRepurposer.save_repurposer", "xfer.load", "type", "type", "numpy.isclose", "os.path.isfile", "os.path.isfile"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._assert_target_model_equal", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._assert_attributes_equal", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._assert_target_model_equal": [[226, 237], ["model1.__dict__.keys", "model1.__dict__.keys", "model2.__dict__.keys", "type", "isinstance", "numpy.array_equal", "type", "isinstance", "list", "list"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_predict": [[238, 280], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "mock_validate_method.reset_mock", "predict_function", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_prediction_results", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurpose", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "open", "pickle.load"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_predict_from_features": [[281, 300], ["test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_prediction_results", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "open", "pickle.load", "test_meta_model_repurposer.MetaModelRepurposerTestCase._predict_probability_from_features", "test_meta_model_repurposer.MetaModelRepurposerTestCase._predict_label_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_prediction_results": [[301, 334], ["test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "numpy.mean", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "len", "numpy.sum", "numpy.ones", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "numpy.argmax", "numpy.isclose", "len", "len", "type", "type", "numpy.allclose"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._run_common_repurposer_tests": [[335, 347], ["test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "repurposer.repurpose", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue", "test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_trained_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_repurpose_calls_validate": [[348, 363], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurposer_class", "mock_validate_method.reset_mock", "test_meta_model_repurposer.MetaModelRepurposerTestCase.repurpose", "test_meta_model_repurposer.MetaModelRepurposerTestCase.assertTrue"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._assert_attributes_equal": [[364, 366], ["repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._validate_trained_model": [[367, 370], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.setUp": [[27, 34], ["super().setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", "SvmRepurposerTestCase", ",", "self", ")", ".", "setUp", "(", ")", "\n", "\n", "# Override base repurpose_class with 'SvmRepurposer' to run base tests with SVM repurposer", "\n", "self", ".", "repurposer_class", "=", "SvmRepurposer", "\n", "self", ".", "target_model_path", "=", "self", ".", "_test_data_dir", "+", "'svm_model_probability.sav'", "\n", "self", ".", "expected_accuracy", "=", "0.6571428571428571", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_train_model_from_features": [[35, 39], ["xfer.SvmRepurposer", "xfer.SvmRepurposer._train_model_from_features", "test_svm_repurposer.SvmRepurposerTestCase._validate_trained_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model"], ["", "def", "test_train_model_from_features", "(", "self", ")", ":", "\n", "        ", "svm_repurposer", "=", "SvmRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "model", "=", "svm_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", "[", ":", "10", "]", ",", "self", ".", "train_labels", "[", ":", "10", "]", ")", "\n", "self", ".", "_validate_trained_model", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_predict_label_from_features": [[40, 44], ["pytest.mark.skipif", "test_svm_repurposer.SvmRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "sys", ".", "version_info", ">", "(", "3", ",", "4", ")", ",", "reason", "=", "'test fails on versions of python newer than 3.4 due to '", "\n", "'pickle not working with newer version of scikit-learn'", ")", "\n", "def", "test_predict_label_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "False", ",", "expected_accuracy", "=", "0.657142857143", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_predict_probability_from_features": [[45, 49], ["pytest.mark.skipif", "test_svm_repurposer.SvmRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "sys", ".", "version_info", ">", "(", "3", ",", "4", ")", ",", "reason", "=", "'test fails on versions of python newer than 3.4 due to '", "\n", "'pickle not working with newer version of scikit-learn'", ")", "\n", "def", "test_predict_probability_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "True", ",", "expected_accuracy", "=", "0.6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_predict_label": [[50, 58], ["unittest.mock.patch.object", "unittest.mock.patch", "pytest.mark.skipif", "test_svm_repurposer.SvmRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "SvmRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "sys", ".", "version_info", ">", "(", "3", ",", "4", ")", ",", "reason", "=", "'test fails on versions of python newer than 3.4 due to '", "\n", "'pickle not working with newer version of scikit-learn'", ")", "\n", "def", "test_predict_label", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "\"\"\" Test predict_label wrapper in meta model base class using svm_repurposer object\"\"\"", "\n", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "0.657142857143", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_predict_probability": [[59, 66], ["unittest.mock.patch.object", "unittest.mock.patch", "pytest.mark.skipif", "test_svm_repurposer.SvmRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "SvmRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "sys", ".", "version_info", ">", "(", "3", ",", "4", ")", ",", "reason", "=", "'test fails on versions of python newer than 3.4 due to '", "\n", "'pickle not working with newer version of scikit-learn'", ")", "\n", "def", "test_predict_probability", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "\"\"\" Test predict_probability wrapper in meta model base class using svm_repurposer object\"\"\"", "\n", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "True", ",", "expected_accuracy", "=", "0.6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_repurpose": [[67, 76], ["unittest.mock.patch", "repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "xfer.SvmRepurposer", "test_svm_repurposer.SvmRepurposerTestCase._run_common_repurposer_tests", "test_svm_repurposer.SvmRepurposerTestCase.train_feature_dict.items"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._run_common_repurposer_tests"], ["", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose", "(", "self", ",", "mock_model_handler", ")", ":", "\n", "        ", "\"\"\" Test Repurpose wrapper in meta model base class using svm repurposer object\"\"\"", "\n", "mock_model_handler", ".", "return_value", "=", "RepurposerTestUtils", ".", "get_mock_model_handler_object", "(", ")", "\n", "N", "=", "10", "\n", "train_feature_dict_subset", "=", "{", "k", ":", "v", "[", ":", "N", "]", "for", "k", ",", "v", "in", "self", ".", "train_feature_dict", ".", "items", "(", ")", "}", "\n", "mock_model_handler", ".", "return_value", ".", "get_layer_output", ".", "return_value", "=", "train_feature_dict_subset", ",", "self", ".", "train_labels", "[", ":", "N", "]", "\n", "repurposer", "=", "SvmRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "self", ".", "_run_common_repurposer_tests", "(", "repurposer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_repurpose_calls_validate": [[77, 81], ["unittest.mock.patch.object", "unittest.mock.patch", "test_svm_repurposer.SvmRepurposerTestCase._test_repurpose_calls_validate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_repurpose_calls_validate"], ["", "@", "patch", ".", "object", "(", "SvmRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_REPURPOSE_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose_calls_validate", "(", "self", ",", "mock_model_handler", ",", "mock_validate_method", ")", ":", "\n", "        ", "self", ".", "_test_repurpose_calls_validate", "(", "mock_model_handler", ",", "mock_validate_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase._validate_trained_model": [[82, 101], ["type", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "numpy.loadtxt", "numpy.loadtxt", "numpy.loadtxt", "numpy.loadtxt", "numpy.loadtxt", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "test_svm_repurposer.SvmRepurposerTestCase.assertTrue", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose", "numpy.isclose", "numpy.isclose", "numpy.isclose", "numpy.isclose"], "methods", ["None"], ["", "def", "_validate_trained_model", "(", "self", ",", "model", ")", ":", "\n", "# Validate type of model", "\n", "        ", "expected_type", "=", "SVC", "\n", "actual_type", "=", "type", "(", "model", ")", "\n", "self", ".", "assertTrue", "(", "actual_type", "==", "expected_type", ",", "\n", "\"Expected model of type: {}. Instead got: {}\"", ".", "format", "(", "expected_type", ",", "actual_type", ")", ")", "\n", "\n", "# Validate model properties", "\n", "expected_model_intercept", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'SVMmodel.intercept_.out'", ")", "\n", "expected_model_dual_coef", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'SVMmodel.dual_coef_.out'", ")", "\n", "expected_model_n_support", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'SVMmodel.n_support_.out'", ")", "\n", "expected_model_support", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'SVMmodel.support_.out'", ")", "\n", "expected_model_support_vectors", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'SVMmodel.support_vectors_.out'", ")", "\n", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "intercept_", ",", "expected_model_intercept", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "dual_coef_", ",", "expected_model_dual_coef", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "n_support_", ",", "expected_model_n_support", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "support_", ",", "expected_model_support", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "model", ".", "support_vectors_", ",", "expected_model_support_vectors", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_svm_repurposer.SvmRepurposerTestCase.test_get_params": [[102, 117], ["xfer.SvmRepurposer", "xfer.SvmRepurposer.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "test_get_params", "(", "self", ")", ":", "\n", "        ", "svm_repurposer", "=", "SvmRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "\n", "params", "=", "svm_repurposer", ".", "get_params", "(", ")", "\n", "expected_params", "=", "{", "\n", "'context_function'", ":", "'cpu'", ",", "\n", "'num_devices'", ":", "1", ",", "\n", "'feature_layer_names'", ":", "[", "'fc1'", ",", "'fc2'", "]", ",", "\n", "'c'", ":", "1.0", ",", "\n", "'kernel'", ":", "'linear'", ",", "\n", "'gamma'", ":", "'auto'", ",", "\n", "'enable_probability_estimates'", ":", "False", "\n", "}", "\n", "\n", "assert", "params", "==", "expected_params", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.setUp": [[29, 45], ["numpy.random.seed", "random.seed", "mxnet.random.seed", "super().setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "random", ".", "seed", "(", "1", ")", "\n", "mx", ".", "random", ".", "seed", "(", "1", ")", "\n", "\n", "super", "(", "BnnRepurposerTestCase", ",", "self", ")", ".", "setUp", "(", ")", "\n", "\n", "N", "=", "10", "\n", "self", ".", "train_features", "=", "self", ".", "train_features", "[", ":", "N", "]", "\n", "self", ".", "train_labels", "=", "self", ".", "train_labels", "[", ":", "N", "]", "\n", "\n", "# Override base repurpose_class with 'BnnRepurposer' to run base tests with instance of BNN Repurposer", "\n", "self", ".", "repurposer_class", "=", "BnnRepurposer", "\n", "\n", "# Minimum expected performance", "\n", "self", ".", "minimum_expected_accuracy", "=", "0.2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_train_model_from_features": [[46, 50], ["xfer.BnnRepurposer", "xfer.BnnRepurposer._train_model_from_features", "test_bnn_repurposer.BnnRepurposerTestCase._validate_trained_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model"], ["", "def", "test_train_model_from_features", "(", "self", ")", ":", "\n", "        ", "bnn_repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_epochs", "=", "3", ")", "\n", "bnn_model", "=", "bnn_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ")", "\n", "self", ".", "_validate_trained_model", "(", "bnn_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_predict_probability_from_features": [[51, 54], ["test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "def", "test_predict_probability_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "True", ",", "\n", "expected_accuracy", "=", "self", ".", "minimum_expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_predict_label_from_features": [[55, 58], ["test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features"], ["", "def", "test_predict_label_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_predict_from_features", "(", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "self", ".", "minimum_expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict_from_features": [[61, 75], ["test_bnn_repurposer.BnnRepurposerTestCase.repurposer_class", "test_bnn_repurposer.BnnRepurposerTestCase._train_model_from_features", "test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results", "test_bnn_repurposer.BnnRepurposerTestCase._predict_probability_from_features", "test_bnn_repurposer.BnnRepurposerTestCase._predict_label_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features"], ["", "def", "_test_predict_from_features", "(", "self", ",", "test_predict_probability", ",", "expected_accuracy", ")", ":", "\n", "        ", "\"\"\" Used to test 'predict_from_features' implementation in derived classes \"\"\"", "\n", "# Create repurposer", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_samples_mc_prediction", "=", "5", ",", "\n", "num_epochs", "=", "2", ",", "num_samples_mc", "=", "1", ")", "\n", "\n", "repurposer", ".", "target_model", "=", "repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ")", "\n", "\n", "if", "test_predict_probability", ":", "\n", "            ", "results", "=", "repurposer", ".", "_predict_probability_from_features", "(", "self", ".", "test_features", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "repurposer", ".", "_predict_label_from_features", "(", "self", ".", "test_features", ")", "\n", "\n", "", "self", ".", "_validate_prediction_results", "(", "results", ",", "test_predict_probability", ",", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_predict_probability": [[76, 81], ["unittest.mock.patch.object", "unittest.mock.patch", "test_bnn_repurposer.BnnRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "BnnRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_probability", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "True", ",", "\n", "expected_accuracy", "=", "self", ".", "minimum_expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_predict_label": [[82, 87], ["unittest.mock.patch.object", "unittest.mock.patch", "test_bnn_repurposer.BnnRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "BnnRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_label", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "self", ".", "minimum_expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_predict": [[90, 121], ["repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_bnn_repurposer.BnnRepurposerTestCase.repurposer_class", "test_bnn_repurposer.BnnRepurposerTestCase._train_model_from_features", "mock_validate_method.reset_mock", "predict_function", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results"], ["", "def", "_test_predict", "(", "self", ",", "mock_model_handler", ",", "mock_validate_method", ",", "test_predict_probability", ",", "expected_accuracy", ")", ":", "\n", "        ", "\"\"\" Test for predict wrapper in meta model base class \"\"\"", "\n", "# Patch model_handler and then create repurposer object", "\n", "mock_model_handler", ".", "return_value", "=", "RepurposerTestUtils", ".", "get_mock_model_handler_object", "(", ")", "\n", "\n", "# Create repurposer", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_samples_mc_prediction", "=", "5", ",", "\n", "num_epochs", "=", "2", ")", "\n", "\n", "# Identify which predict function to test", "\n", "if", "test_predict_probability", ":", "\n", "            ", "predict_function", "=", "repurposer", ".", "predict_probability", "\n", "", "else", ":", "\n", "            ", "predict_function", "=", "repurposer", ".", "predict_label", "\n", "\n", "# Load target model from file", "\n", "", "model", "=", "repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ")", "\n", "repurposer", ".", "target_model", "=", "model", "\n", "\n", "# Call predict method and get prediction results", "\n", "mock_model_handler", ".", "return_value", ".", "get_layer_output", ".", "return_value", "=", "self", ".", "test_feature_dict", ",", "self", ".", "test_labels", "\n", "mock_validate_method", ".", "reset_mock", "(", ")", "\n", "# Mocking iterator because get_layer_output is patched", "\n", "results", "=", "predict_function", "(", "test_iterator", "=", "self", ".", "mock_object", ")", "\n", "\n", "# Check if predict called validate", "\n", "self", ".", "assertTrue", "(", "mock_validate_method", ".", "call_count", "==", "1", ",", "\n", "\"Predict expected to called {} once. Found {} calls\"", ".", "\n", "format", "(", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ",", "mock_validate_method", ".", "call_count", ")", ")", "\n", "\n", "self", ".", "_validate_prediction_results", "(", "results", ",", "test_predict_probability", ",", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_trained_model": [[122, 134], ["type", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "zip", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "model.model.collect_params().values", "model.model.collect_params"], "methods", ["None"], ["", "def", "_validate_trained_model", "(", "self", ",", "model", ")", ":", "\n", "# Validate type of model", "\n", "        ", "expected_type", "=", "BnnClassifier", "\n", "actual_type", "=", "type", "(", "model", ")", "\n", "self", ".", "assertTrue", "(", "actual_type", "==", "expected_type", ",", "\n", "\"Expected model of type: {}. Instead got: {}\"", ".", "format", "(", "expected_type", ",", "actual_type", ")", ")", "\n", "\n", "shapes_model", "=", "[", "x", ".", "shape", "for", "x", "in", "model", ".", "model", ".", "collect_params", "(", ")", ".", "values", "(", ")", "]", "\n", "shapes_posterior", "=", "model", ".", "var_posterior", ".", "shapes", "\n", "for", "shape_model", ",", "shape_posterior", "in", "zip", "(", "shapes_model", ",", "shapes_posterior", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "shape_model", "==", "shape_posterior", ",", "\"Shapes of the model and the variational posterior do not \\\n             match. {} vs {}\"", ".", "format", "(", "shape_model", ",", "shape_posterior", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_repurpose": [[135, 144], ["unittest.mock.patch", "repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose", "test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose", "test_bnn_repurposer.BnnRepurposerTestCase.train_feature_dict.items"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose"], ["", "", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose", "(", "self", ",", "mock_model_handler", ")", ":", "\n", "# Patch model_handler and then create bnn_repurposer", "\n", "        ", "mock_model_handler", ".", "return_value", "=", "RepurposerTestUtils", ".", "get_mock_model_handler_object", "(", ")", "\n", "N", "=", "5", "\n", "train_feature_dict_subset", "=", "{", "k", ":", "v", "[", ":", "N", "]", "for", "k", ",", "v", "in", "self", ".", "train_feature_dict", ".", "items", "(", ")", "}", "\n", "mock_model_handler", ".", "return_value", ".", "get_layer_output", ".", "return_value", "=", "train_feature_dict_subset", ",", "self", ".", "train_labels", "[", ":", "N", "]", "\n", "self", ".", "_test_repurpose", "(", "n_jobs", "=", "-", "1", ")", "# Use all cores", "\n", "self", ".", "_test_repurpose", "(", "n_jobs", "=", "1", ")", "# Use single core", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._test_repurpose": [[145, 160], ["xfer.BnnRepurposer", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "xfer.BnnRepurposer.repurpose", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "test_bnn_repurposer.BnnRepurposerTestCase._validate_trained_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model"], ["", "def", "_test_repurpose", "(", "self", ",", "n_jobs", "=", "-", "1", ")", ":", "\n", "        ", "bnn_repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_epochs", "=", "2", ")", "\n", "\n", "# Target model is not initialized yet", "\n", "self", ".", "assertTrue", "(", "bnn_repurposer", ".", "target_model", "is", "None", ",", "\"Target model not expected to be initialized at this \\\n        point\"", ")", "\n", "\n", "# Call repurpose", "\n", "bnn_repurposer", ".", "repurpose", "(", "self", ".", "mock_object", ")", "\n", "\n", "# Validate target model is now set", "\n", "self", ".", "assertTrue", "(", "bnn_repurposer", ".", "target_model", "is", "not", "None", ",", "\"Repurpose failed to set target model\"", ")", "\n", "\n", "# Validate trained model", "\n", "self", ".", "_validate_trained_model", "(", "bnn_repurposer", ".", "target_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_build_nn": [[161, 187], ["xfer.BnnRepurposer", "test_bnn_repurposer.BnnRepurposerTestCase.train_features.astype", "test_bnn_repurposer.BnnRepurposerTestCase.train_labels.astype", "mxnet.gluon.data.DataLoader", "xfer.BnnRepurposer._build_nn", "range", "numpy.dtype", "numpy.dtype", "mxnet.gluon.data.ArrayDataset", "len", "isinstance", "numpy.unique", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._build_nn", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype"], ["", "def", "test_build_nn", "(", "self", ")", ":", "\n", "        ", "bnn_repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "x_tr", "=", "self", ".", "train_features", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float32", ")", ")", "\n", "y_tr", "=", "self", ".", "train_labels", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float32", ")", ")", "\n", "train_data", "=", "gluon", ".", "data", ".", "DataLoader", "(", "gluon", ".", "data", ".", "ArrayDataset", "(", "x_tr", ",", "y_tr", ")", ",", "\n", "batch_size", "=", "bnn_repurposer", ".", "batch_size", ",", "shuffle", "=", "True", ")", "\n", "\n", "neural_network", ",", "shapes", "=", "bnn_repurposer", ".", "_build_nn", "(", "train_data", ",", "len", "(", "np", ".", "unique", "(", "y_tr", ")", ")", ")", "\n", "for", "layer", "in", "neural_network", ":", "\n", "            ", "assert", "isinstance", "(", "layer", ",", "gluon", ".", "nn", ".", "Dense", ")", "\n", "\n", "# Input layer: Fully connected layer with 2 parameters (affine transformation plus bias)", "\n", "", "assert", "shapes", "[", "0", "]", "==", "(", "bnn_repurposer", ".", "n_hidden", ",", "self", ".", "train_features", ".", "shape", "[", "1", "]", ")", "\n", "assert", "shapes", "[", "1", "]", "==", "(", "bnn_repurposer", ".", "n_hidden", ",", ")", "\n", "\n", "# Intermediate layers: Each of them is a Fully connected layer with 2 parameters (affine transformation plus", "\n", "# bias)", "\n", "for", "ss", "in", "range", "(", "2", ",", "len", "(", "shapes", ")", "-", "2", ")", ":", "\n", "            ", "if", "ss", "%", "2", "==", "0", ":", "\n", "                ", "assert", "shapes", "[", "ss", "]", "==", "(", "bnn_repurposer", ".", "n_hidden", ",", "bnn_repurposer", ".", "n_hidden", ")", "\n", "", "else", ":", "\n", "                ", "assert", "shapes", "[", "ss", "]", "==", "(", "bnn_repurposer", ".", "n_hidden", ",", ")", "\n", "\n", "# Output layer: Fully connected layer with 2 parameters (affine transformation plus bias)", "\n", "", "", "assert", "shapes", "[", "len", "(", "shapes", ")", "-", "2", "]", "==", "(", "self", ".", "n_classes", ",", "bnn_repurposer", ".", "n_hidden", ")", "\n", "assert", "shapes", "[", "len", "(", "shapes", ")", "-", "1", "]", "==", "(", "self", ".", "n_classes", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results": [[188, 215], ["test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "numpy.sum", "numpy.ones", "test_bnn_repurposer.BnnRepurposerTestCase.assertTrue", "numpy.argmax", "type", "type", "numpy.allclose", "numpy.mean", "numpy.mean"], "methods", ["None"], ["", "def", "_validate_prediction_results", "(", "self", ",", "results", ",", "test_predict_probability", ",", "expected_minimum_accuracy", ")", ":", "\n", "# Validate type of prediction results", "\n", "        ", "self", ".", "assertTrue", "(", "type", "(", "results", ")", "==", "np", ".", "ndarray", ",", "\n", "\"Prediction results expected to be numpy array. Instead got: {}\"", ".", "format", "(", "type", "(", "results", ")", ")", ")", "\n", "\n", "# Validate shape of prediction results", "\n", "if", "test_predict_probability", ":", "\n", "            ", "expected_shape", "=", "(", "self", ".", "n_test_instances", ",", "self", ".", "n_classes", ")", "\n", "", "else", ":", "\n", "            ", "expected_shape", "=", "(", "self", ".", "n_test_instances", ",", ")", "\n", "", "self", ".", "assertTrue", "(", "results", ".", "shape", "==", "expected_shape", ",", "\n", "\"Prediction results shape is incorrect. Expected: {}. Got: {}\"", ".", "format", "(", "expected_shape", ",", "\n", "results", ".", "shape", ")", ")", "\n", "\n", "# Validate if prediction probabilities sum to 1", "\n", "if", "test_predict_probability", ":", "\n", "            ", "probability_sum", "=", "np", ".", "sum", "(", "results", ",", "axis", "=", "1", ")", "\n", "array_of_ones", "=", "np", ".", "ones", "(", "shape", "=", "(", "self", ".", "n_test_instances", ",", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "probability_sum", ",", "array_of_ones", ")", ",", "\"Sum of predicted probabilities is not 1\"", ")", "\n", "\n", "# Validate accuracy of prediction results", "\n", "", "labels", "=", "np", ".", "argmax", "(", "results", ",", "axis", "=", "1", ")", "if", "test_predict_probability", "else", "results", "\n", "\n", "self", ".", "assertTrue", "(", "np", ".", "mean", "(", "labels", "==", "self", ".", "test_labels", ")", ">=", "expected_minimum_accuracy", ",", "\"Prediction accuracy is \"", "+", "\n", "\"incorrect. Minimum accuracy expected: {}. Actual accuracy: {}\"", ".", "format", "(", "\n", "expected_minimum_accuracy", ",", "\n", "np", ".", "mean", "(", "labels", "==", "self", ".", "test_labels", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._assert_target_model_equal": [[216, 232], ["model1.var_posterior.raw_params.keys", "model1.var_posterior.params.keys", "enumerate", "enumerate", "numpy.array_equal", "numpy.array_equal", "[].asnumpy", "[].asnumpy", "value.data", "[].data"], "methods", ["None"], ["", "def", "_assert_target_model_equal", "(", "self", ",", "model1", ",", "model2", ")", ":", "\n", "        ", "assert", "model1", ".", "normalizer", ".", "__dict__", "==", "model2", ".", "normalizer", ".", "__dict__", "\n", "\n", "assert", "model1", ".", "var_posterior", ".", "shapes", "==", "model2", ".", "var_posterior", ".", "shapes", "\n", "assert", "model1", ".", "var_posterior", ".", "ctx", "==", "model2", ".", "var_posterior", ".", "ctx", "\n", "\n", "for", "key", "in", "model1", ".", "var_posterior", ".", "raw_params", ".", "keys", "(", ")", ":", "\n", "            ", "for", "count", ",", "_", "in", "enumerate", "(", "model1", ".", "var_posterior", ".", "raw_params", "[", "key", "]", ")", ":", "\n", "                ", "assert", "np", ".", "array_equal", "(", "model1", ".", "var_posterior", ".", "raw_params", "[", "key", "]", "[", "count", "]", ".", "asnumpy", "(", ")", ",", "\n", "model2", ".", "var_posterior", ".", "raw_params", "[", "key", "]", "[", "count", "]", ".", "asnumpy", "(", ")", ")", "\n", "\n", "", "", "for", "key", "in", "model1", ".", "var_posterior", ".", "params", ".", "keys", "(", ")", ":", "\n", "            ", "for", "count", ",", "value", "in", "enumerate", "(", "model1", ".", "var_posterior", ".", "params", "[", "key", "]", ")", ":", "\n", "                ", "assert", "np", ".", "array_equal", "(", "value", ".", "data", "(", ")", ",", "model2", ".", "var_posterior", ".", "params", "[", "key", "]", "[", "count", "]", ".", "data", "(", ")", ")", "\n", "assert", "value", ".", "grad_req", "==", "model2", ".", "var_posterior", ".", "params", "[", "key", "]", "[", "count", "]", ".", "grad_req", "\n", "assert", "value", ".", "name", "==", "model2", ".", "var_posterior", ".", "params", "[", "key", "]", "[", "count", "]", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._assert_attributes_equal": [[233, 236], ["super()._assert_attributes_equal"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._assert_attributes_equal"], ["", "", "", "def", "_assert_attributes_equal", "(", "self", ",", "repurposer1", ",", "repurposer2", ")", ":", "\n", "        ", "super", "(", ")", ".", "_assert_attributes_equal", "(", "repurposer1", ",", "repurposer2", ")", "\n", "assert", "repurposer1", ".", "annealing_weight", "==", "repurposer2", ".", "annealing_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_get_params": [[237, 260], ["xfer.BnnRepurposer", "xfer.BnnRepurposer.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "test_get_params", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "\n", "params", "=", "repurposer", ".", "get_params", "(", ")", "\n", "expected_params", "=", "{", "\n", "'context_function'", ":", "'cpu'", ",", "\n", "'num_devices'", ":", "1", ",", "\n", "'feature_layer_names'", ":", "[", "'fc1'", ",", "'fc2'", "]", ",", "\n", "'bnn_context_function'", ":", "'cpu'", ",", "\n", "'sigma'", ":", "100.0", ",", "\n", "'num_layers'", ":", "1", ",", "\n", "'n_hidden'", ":", "10", ",", "\n", "'num_samples_mc'", ":", "3", ",", "\n", "'learning_rate'", ":", "0.001", ",", "\n", "'batch_size'", ":", "20", ",", "\n", "'num_epochs'", ":", "200", ",", "\n", "'start_annealing'", ":", "20", ",", "\n", "'end_annealing'", ":", "40", ",", "\n", "'num_samples_mc_prediction'", ":", "100", ",", "\n", "'verbose'", ":", "0", "\n", "}", "\n", "\n", "assert", "params", "==", "expected_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase.test_verbose": [[261, 275], ["xfer.BnnRepurposer", "print", "xfer.BnnRepurposer", "test_bnn_repurposer.BnnRepurposerTestCase.assertLogs", "xfer.BnnRepurposer._train_model_from_features", "len", "test_bnn_repurposer.BnnRepurposerTestCase.assertRaises", "test_bnn_repurposer.BnnRepurposerTestCase.assertLogs", "xfer.BnnRepurposer._train_model_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features"], ["", "def", "test_verbose", "(", "self", ")", ":", "\n", "        ", "bnn_repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_epochs", "=", "3", ",", "verbose", "=", "True", ",", "\n", "num_samples_mc", "=", "1", ")", "\n", "N", "=", "2", "\n", "with", "self", ".", "assertLogs", "(", ")", "as", "cm", ":", "\n", "            ", "bnn_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", "[", ":", "N", "]", ",", "self", ".", "train_labels", "[", ":", "N", "]", ")", "\n", "", "print", "(", "cm", ".", "output", ")", "\n", "assert", "len", "(", "cm", ".", "output", ")", "==", "3", "\n", "\n", "bnn_repurposer", "=", "BnnRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "num_epochs", "=", "3", ",", "verbose", "=", "False", ",", "\n", "num_samples_mc", "=", "1", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "with", "self", ".", "assertLogs", "(", ")", ":", "\n", "                ", "bnn_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", "[", ":", "N", "]", ",", "self", ".", "train_labels", "[", ":", "N", "]", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.setUp": [[30, 46], ["numpy.random.seed", "mxnet.module.Module.load", "xfer.model_handler.ModelHandler", "mxnet.image.ImageIter", "json.loads", "test_model_handler.TestModelHandler.mh.symbol.tojson"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "self", ".", "data_name", "=", "'data'", "\n", "mod", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ",", "\n", "data_names", "=", "(", "self", ".", "data_name", ",", ")", ")", "\n", "self", ".", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ",", "mx", ".", "context", ".", "cpu", ",", "1", ",", "self", ".", "data_name", ")", "\n", "self", ".", "imglist", "=", "[", "[", "0", ",", "'accordion/image_0001.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0002.jpg'", "]", ",", "[", "1", ",", "'ant/image_0001.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0002.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0001.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0002.jpg'", "]", "]", "\n", "self", ".", "image_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmaxoutput1_label'", ",", "data_name", "=", "self", ".", "data_name", ")", "\n", "self", ".", "symbol_dict", "=", "json", ".", "loads", "(", "self", ".", "mh", ".", "symbol", ".", "tojson", "(", ")", ")", "\n", "self", ".", "nodes", "=", "self", ".", "symbol_dict", "[", "'nodes'", "]", "\n", "self", ".", "arg_nodes", "=", "self", ".", "symbol_dict", "[", "'arg_nodes'", "]", "\n", "self", ".", "heads", "=", "self", ".", "symbol_dict", "[", "'heads'", "]", "\n", "self", ".", "act1_id", "=", "4", "\n", "self", ".", "conv2_id", "=", "7", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.tearDown": [[47, 49], ["None"], "methods", ["None"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "        ", "del", "self", ".", "mh", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_resnet": [[50, 61], ["repurposer_test_utils.RepurposerTestUtils.download_resnet", "mxnet.mod.Module.load", "xfer.model_handler.ModelHandler", "xfer.model_handler.ModelHandler.drop_layer_top", "xfer.model_handler.ModelHandler.drop_layer_bottom", "sorted", "sorted", "list", "set().difference", "set", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.download_resnet", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_resnet", "(", "self", ")", ":", "\n", "        ", "\"\"\"Assert that ModelHandler can drop layers from resnet without errors\"\"\"", "\n", "RepurposerTestUtils", ".", "download_resnet", "(", ")", "\n", "mod", "=", "mx", ".", "mod", ".", "Module", ".", "load", "(", "'resnet-101'", ",", "0", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ")", "\n", "old_layer_names", "=", "mh", ".", "layer_names", "\n", "\n", "mh", ".", "drop_layer_top", "(", ")", "\n", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "\n", "assert", "sorted", "(", "list", "(", "set", "(", "old_layer_names", ")", ".", "difference", "(", "set", "(", "mh", ".", "layer_names", ")", ")", ")", ")", "==", "sorted", "(", "[", "'bn_data'", ",", "'softmax'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_constructor_binded_module": [[62, 70], ["mxnet.module.Module.load", "mxnet.module.Module.load.bind", "xfer.model_handler.ModelHandler", "xfer.model_handler.ModelHandler.drop_layer_top", "xfer.model_handler.ModelHandler.drop_layer_bottom"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_constructor_binded_module", "(", "self", ")", ":", "\n", "# Assert module that is binded can be used to init a ModelHandler object and can add/drop layers", "\n", "        ", "mod", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ")", "\n", "mod", ".", "bind", "(", "data_shapes", "=", "[", "(", "'data'", ",", "self", ".", "image_iter", ".", "provide_data", "[", "0", "]", "[", "1", "]", ")", "]", ",", "label_shapes", "=", "self", ".", "image_iter", ".", "provide_label", ")", "\n", "assert", "mod", ".", "binded", "and", "mod", ".", "params_initialized", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ",", "mx", ".", "context", ".", "cpu", ",", "1", ")", "\n", "mh", ".", "drop_layer_top", "(", ")", "\n", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_constructor_no_weight": [[71, 80], ["mxnet.model.load_checkpoint", "mxnet.module.Module", "xfer.model_handler.ModelHandler", "numpy.array_equal", "numpy.array_equal", "xfer.model_handler.ModelHandler.drop_layer_top", "xfer.model_handler.ModelHandler.drop_layer_bottom"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_constructor_no_weight", "(", "self", ")", ":", "\n", "# Assert module that is unbinded can be used to init a ModelHandler object and can add/drop layers", "\n", "        ", "sym", ",", "_", ",", "_", "=", "mx", ".", "model", ".", "load_checkpoint", "(", "'tests/data/testnetv1'", ",", "0", ")", "\n", "mod", "=", "mx", ".", "module", ".", "Module", "(", "sym", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ",", "mx", ".", "context", ".", "cpu", ",", "1", ")", "\n", "assert", "np", ".", "array_equal", "(", "mh", ".", "arg_params", ",", "{", "}", ")", "\n", "assert", "np", ".", "array_equal", "(", "mh", ".", "aux_params", ",", "{", "}", ")", "\n", "mh", ".", "drop_layer_top", "(", ")", "\n", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_top_1": [[81, 91], ["test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.drop_layer_top", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "list", "set().symmetric_difference", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "set", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top"], ["", "def", "test_drop_layer_top_1", "(", "self", ")", ":", "\n", "        ", "assert", "'softmaxoutput1'", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "drop_layer_top", "(", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "assert", "'softmaxoutput1'", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "assert", "set", "(", "outputs_pre", ")", ".", "symmetric_difference", "(", "set", "(", "outputs_post", ")", ")", "==", "{", "'softmaxoutput1_output'", ",", "\n", "'softmaxoutput1_label'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_top_3": [[92, 107], ["test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.drop_layer_top", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "set().symmetric_difference", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "set", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top"], ["", "def", "test_drop_layer_top_3", "(", "self", ")", ":", "\n", "        ", "for", "layer_name", "in", "[", "'softmaxoutput1'", ",", "'fullyconnected0'", ",", "'flatten1'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "drop_layer_top", "(", "3", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'softmaxoutput1'", ",", "'fullyconnected0'", ",", "'flatten1'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "", "assert", "set", "(", "outputs_pre", ")", ".", "symmetric_difference", "(", "set", "(", "outputs_post", ")", ")", "==", "{", "'flatten1_output'", ",", "'fullyconnected0_weight'", ",", "\n", "'fullyconnected0_bias'", ",", "\n", "'fullyconnected0_output'", ",", "\n", "'softmaxoutput1_label'", ",", "\n", "'softmaxoutput1_output'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_top_too_many": [[108, 111], ["test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.drop_layer_top"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top"], ["", "def", "test_drop_layer_top_too_many", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "model_handler", ".", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "drop_layer_top", "(", "8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_top_two_outputs": [[112, 133], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.Group", "mxnet.mod.Module", "xfer.model_handler.ModelHandler", "test_model_handler.TestModelHandler.assertRaises", "xfer.model_handler.ModelHandler.drop_layer_top"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top"], ["", "", "def", "test_drop_layer_top_two_outputs", "(", "self", ")", ":", "\n", "# Build a symbol with two softmax output layers", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1'", ",", "num_hidden", "=", "128", ")", "\n", "act1", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1", ",", "name", "=", "'relu1'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act1", ",", "name", "=", "'fc2'", ",", "num_hidden", "=", "64", ")", "\n", "act2", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc2", ",", "name", "=", "'relu2'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act2", ",", "name", "=", "'fc3'", ",", "num_hidden", "=", "10", ")", "\n", "\n", "fc4", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_1'", ",", "num_hidden", "=", "10", ")", "\n", "sm1", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc4", ",", "name", "=", "'softmax1'", ")", "\n", "fc5", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_2'", ",", "num_hidden", "=", "10", ")", "\n", "sm2", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc5", ",", "name", "=", "'softmax2'", ")", "\n", "\n", "softmax", "=", "mx", ".", "sym", ".", "Group", "(", "[", "sm1", ",", "sm2", "]", ")", "\n", "\n", "mod", "=", "mx", ".", "mod", ".", "Module", "(", "softmax", ",", "label_names", "=", "[", "'softmax1_label'", ",", "'softmax2_label'", "]", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "mh", ".", "drop_layer_top", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_top_split": [[134, 141], ["test_model_handler.TestModelHandler._build_split_net", "mh.drop_layer_top", "test_model_handler.TestModelHandler.assertRaises", "mh.drop_layer_top", "test_model_handler.TestModelHandler.assertRaises", "mh.drop_layer_top"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._build_split_net", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top"], ["", "", "def", "test_drop_layer_top_split", "(", "self", ")", ":", "\n", "        ", "mh", ",", "plus_layer_name", "=", "self", ".", "_build_split_net", "(", ")", "\n", "mh", ".", "drop_layer_top", "(", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "mh", ".", "drop_layer_top", "(", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "mh", ".", "drop_layer_top", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_bottom_1": [[142, 152], ["test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.drop_layer_bottom", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "list", "set().symmetric_difference", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "set", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "", "def", "test_drop_layer_bottom_1", "(", "self", ")", ":", "\n", "        ", "assert", "'conv1'", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "assert", "'conv1'", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "assert", "set", "(", "outputs_pre", ")", ".", "symmetric_difference", "(", "set", "(", "outputs_post", ")", ")", "==", "{", "'conv1_bias'", ",", "'conv1_weight'", ",", "\n", "'conv1_output'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_bottom_3": [[153, 168], ["test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.drop_layer_bottom", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "set().symmetric_difference", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "set", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_drop_layer_bottom_3", "(", "self", ")", ":", "\n", "        ", "for", "layer_name", "in", "[", "'conv1'", ",", "'act1'", ",", "'conv2'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "drop_layer_bottom", "(", "3", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'conv1'", ",", "'act1'", ",", "'conv2'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "assert", "set", "(", "outputs_pre", ")", ".", "symmetric_difference", "(", "set", "(", "outputs_post", ")", ")", "==", "{", "'conv1_bias'", ",", "'conv1_weight'", ",", "\n", "'conv1_output'", ",", "'act1_output'", ",", "\n", "'conv2_bias'", ",", "'conv2_output'", ",", "\n", "'conv2_weight'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_bottom_too_many": [[169, 172], ["test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.drop_layer_bottom"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_drop_layer_bottom_too_many", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "model_handler", ".", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "drop_layer_bottom", "(", "8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._build_split_net": [[173, 192], ["mxnet.sym.var", "mxnet.sym.flatten", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected.__add__", "mxnet.sym.SoftmaxOutput", "mxnet.mod.Module", "xfer.model_handler.ModelHandler"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["", "", "@", "staticmethod", "\n", "def", "_build_split_net", "(", ")", ":", "\n", "        ", "\"\"\"Instantiate MH for a model that diverges into two and then joins back into one.\"\"\"", "\n", "data", "=", "mx", ".", "sym", ".", "var", "(", "'data'", ")", "\n", "data", "=", "mx", ".", "sym", ".", "flatten", "(", "data", "=", "data", ",", "name", "=", "'flatten0'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", ",", "num_hidden", "=", "5", ",", "name", "=", "'a_1'", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "fc1", ",", "num_hidden", "=", "5", ",", "name", "=", "'a_2'", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "fc2", ",", "num_hidden", "=", "5", ",", "name", "=", "'a_3'", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", ",", "num_hidden", "=", "5", ",", "name", "=", "'b_1'", ")", "\n", "fc2b", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "fc2", ",", "num_hidden", "=", "5", ",", "name", "=", "'b_2'", ")", "\n", "plus", "=", "fc3", ".", "__add__", "(", "fc2b", ")", "\n", "\n", "softmax", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "plus", ",", "name", "=", "'softmax'", ")", "\n", "mod", "=", "mx", ".", "mod", ".", "Module", "(", "softmax", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ")", "\n", "\n", "plus_layer_name", "=", "mh", ".", "layer_names", "[", "6", "]", "\n", "\n", "return", "mh", ",", "plus_layer_name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_drop_layer_bottom_split": [[193, 200], ["test_model_handler.TestModelHandler._build_split_net", "mh.drop_layer_bottom", "test_model_handler.TestModelHandler.assertRaises", "mh.drop_layer_bottom", "test_model_handler.TestModelHandler.assertRaises", "mh.drop_layer_bottom"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._build_split_net", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom"], ["", "def", "test_drop_layer_bottom_split", "(", "self", ")", ":", "\n", "        ", "mh", ",", "_", "=", "self", ".", "_build_split_net", "(", ")", "\n", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "mh", ".", "drop_layer_bottom", "(", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "mh", ".", "drop_layer_bottom", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_top": [[201, 213], ["test_model_handler.TestModelHandler.mh.drop_layer_top", "mxnet.sym.FullyConnected", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_top", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top"], ["", "", "def", "test_add_layer_top", "(", "self", ")", ":", "\n", "# Drop output layer so that layers can be added to top", "\n", "        ", "self", ".", "mh", ".", "drop_layer_top", "(", ")", "\n", "layer1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'fc1'", ",", "num_hidden", "=", "5", ")", "\n", "assert", "'fc1'", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_top", "(", "[", "layer1", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "assert", "'fc1'", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "assert", "outputs_post", "==", "outputs_pre", "+", "[", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_top_2": [[214, 230], ["test_model_handler.TestModelHandler.mh.drop_layer_top", "mxnet.sym.FullyConnected", "mxnet.sym.Convolution", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_top", "test_model_handler.TestModelHandler.mh.add_layer_top", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top"], ["", "def", "test_add_layer_top_2", "(", "self", ")", ":", "\n", "        ", "self", ".", "mh", ".", "drop_layer_top", "(", ")", "\n", "layer1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'fc1'", ",", "num_hidden", "=", "5", ")", "\n", "layer2", "=", "mx", ".", "sym", ".", "Convolution", "(", "name", "=", "'conv1_1'", ",", "kernel", "=", "(", "3", ",", "3", ")", ",", "num_filter", "=", "10", ")", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_top", "(", "[", "layer1", "]", ")", "\n", "self", ".", "mh", ".", "add_layer_top", "(", "[", "layer2", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "", "assert", "outputs_post", "==", "outputs_pre", "+", "[", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'conv1_1_weight'", ",", "'conv1_1_bias'", ",", "\n", "'conv1_1_output'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_top_list": [[231, 246], ["test_model_handler.TestModelHandler.mh.drop_layer_top", "mxnet.sym.FullyConnected", "mxnet.sym.Convolution", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_top", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top"], ["", "def", "test_add_layer_top_list", "(", "self", ")", ":", "\n", "        ", "self", ".", "mh", ".", "drop_layer_top", "(", ")", "\n", "layer1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'fc1'", ",", "num_hidden", "=", "5", ")", "\n", "layer2", "=", "mx", ".", "sym", ".", "Convolution", "(", "name", "=", "'conv1_1'", ",", "kernel", "=", "(", "3", ",", "3", ")", ",", "num_filter", "=", "10", ")", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_top", "(", "[", "layer1", ",", "layer2", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "", "assert", "outputs_post", "==", "outputs_pre", "+", "[", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'conv1_1_weight'", ",", "'conv1_1_bias'", ",", "\n", "'conv1_1_output'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_top_over_output": [[247, 252], ["mxnet.sym.FullyConnected", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.add_layer_top"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top"], ["", "def", "test_add_layer_top_over_output", "(", "self", ")", ":", "\n", "# Assert model error raised when a layer is added above an output layer", "\n", "        ", "layer", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "num_hidden", "=", "5", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "add_layer_top", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_bottom": [[253, 263], ["mxnet.sym.Convolution", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_bottom", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_bottom"], ["", "", "def", "test_add_layer_bottom", "(", "self", ")", ":", "\n", "        ", "layer1", "=", "mx", ".", "sym", ".", "Convolution", "(", "name", "=", "'conv1_1'", ",", "kernel", "=", "(", "3", ",", "3", ")", ",", "num_filter", "=", "10", ")", "\n", "assert", "'conv1_1'", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_bottom", "(", "[", "layer1", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "assert", "'conv1_1'", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "assert", "outputs_post", "==", "[", "self", ".", "data_name", ",", "'conv1_1_weight'", ",", "'conv1_1_bias'", ",", "'conv1_1_output'", "]", "+", "outputs_pre", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_bottom_2": [[264, 279], ["mxnet.sym.Convolution", "mxnet.sym.FullyConnected", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_bottom", "test_model_handler.TestModelHandler.mh.add_layer_bottom", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_bottom", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_bottom"], ["", "def", "test_add_layer_bottom_2", "(", "self", ")", ":", "\n", "        ", "layer1", "=", "mx", ".", "sym", ".", "Convolution", "(", "name", "=", "'conv1_1'", ",", "kernel", "=", "(", "3", ",", "3", ")", ",", "num_filter", "=", "10", ")", "\n", "layer2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'fc1'", ",", "num_hidden", "=", "10", ")", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_bottom", "(", "[", "layer1", "]", ")", "\n", "self", ".", "mh", ".", "add_layer_bottom", "(", "[", "layer2", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "", "assert", "outputs_post", "==", "[", "self", ".", "data_name", ",", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'conv1_1_weight'", ",", "\n", "'conv1_1_bias'", ",", "'conv1_1_output'", "]", "+", "outputs_pre", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_add_layer_bottom_list": [[280, 294], ["mxnet.sym.Convolution", "mxnet.sym.FullyConnected", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.add_layer_bottom", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "list", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "list", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys", "test_model_handler.TestModelHandler.mh.layer_type_dict.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_bottom"], ["", "def", "test_add_layer_bottom_list", "(", "self", ")", ":", "\n", "        ", "layer1", "=", "mx", ".", "sym", ".", "Convolution", "(", "name", "=", "'conv1_1'", ",", "kernel", "=", "(", "3", ",", "3", ")", ",", "num_filter", "=", "10", ")", "\n", "layer2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'fc1'", ",", "num_hidden", "=", "10", ")", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "not", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n", "", "outputs_pre", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "mh", ".", "add_layer_bottom", "(", "[", "layer1", ",", "layer2", "]", ")", "\n", "outputs_post", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "for", "layer_name", "in", "[", "'fc1'", ",", "'conv1_1'", "]", ":", "\n", "            ", "assert", "layer_name", "in", "list", "(", "self", ".", "mh", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "", "assert", "outputs_post", "==", "[", "self", ".", "data_name", ",", "'conv1_1_weight'", ",", "'conv1_1_bias'", ",", "'conv1_1_output'", ",", "'fc1_weight'", ",", "\n", "'fc1_bias'", ",", "'fc1_output'", "]", "+", "outputs_pre", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_assert_model_has_single_output": [[295, 317], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.SoftmaxOutput", "mxnet.sym.Group", "mxnet.sym.Group", "test_model_handler.TestModelHandler.mh._assert_model_has_single_output", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_model_has_single_output", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_model_has_single_output", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.mh._get_symbol_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_model_has_single_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_model_has_single_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_model_has_single_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict"], ["", "def", "test_assert_model_has_single_output", "(", "self", ")", ":", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1'", ",", "num_hidden", "=", "128", ")", "\n", "act1", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1", ",", "name", "=", "'relu1'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act1", ",", "name", "=", "'fc2'", ",", "num_hidden", "=", "64", ")", "\n", "act2", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc2", ",", "name", "=", "'relu2'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act2", ",", "name", "=", "'fc3'", ",", "num_hidden", "=", "10", ")", "\n", "fc4", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_1'", ",", "num_hidden", "=", "10", ")", "\n", "sm1", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc4", ",", "name", "=", "'softmax1'", ")", "\n", "fc5", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_2'", ",", "num_hidden", "=", "10", ")", "\n", "sm2", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc5", ",", "name", "=", "'softmax2'", ")", "\n", "sm3", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc2", ",", "name", "=", "'softmax3'", ")", "\n", "\n", "output_1", "=", "sm1", "\n", "output_2", "=", "mx", ".", "sym", ".", "Group", "(", "[", "sm1", ",", "sm2", "]", ")", "\n", "output_3", "=", "mx", ".", "sym", ".", "Group", "(", "[", "sm1", ",", "sm2", ",", "sm3", "]", ")", "\n", "\n", "self", ".", "mh", ".", "_assert_model_has_single_output", "(", "self", ".", "mh", ".", "_get_symbol_dict", "(", "output_1", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_model_has_single_output", "(", "self", ".", "mh", ".", "_get_symbol_dict", "(", "output_2", ")", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_model_has_single_output", "(", "self", ".", "mh", ".", "_get_symbol_dict", "(", "output_3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_names_of_inputs_to_layer": [[318, 324], ["test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer"], ["", "", "def", "test_get_names_of_inputs_to_layer", "(", "self", ")", ":", "\n", "        ", "symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "self", ".", "mh", ".", "symbol", ")", "\n", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "7", ")", "==", "[", "4", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "8", ")", "==", "[", "7", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "15", ")", "==", "[", "13", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_names_of_inputs_to_layer_split_2": [[325, 339], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected.__add__", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer"], ["", "def", "test_get_names_of_inputs_to_layer_split_2", "(", "self", ")", ":", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1'", ",", "num_hidden", "=", "128", ")", "\n", "act1", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1", ",", "name", "=", "'relu1'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act1", ",", "name", "=", "'fc2'", ",", "num_hidden", "=", "64", ")", "\n", "act2", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc2", ",", "name", "=", "'relu2'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act2", ",", "name", "=", "'fc3'", ",", "num_hidden", "=", "10", ")", "\n", "plus", "=", "fc2", ".", "__add__", "(", "fc3", ")", "\n", "\n", "symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "plus", ")", "\n", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "7", ")", "==", "[", "4", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "8", ")", "==", "[", "7", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "12", ")", "==", "[", "7", ",", "11", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_names_of_inputs_to_layer_split_3": [[340, 354], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.concat", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer", "test_model_handler.TestModelHandler.mh._get_names_of_inputs_to_layer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer"], ["", "def", "test_get_names_of_inputs_to_layer_split_3", "(", "self", ")", ":", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1'", ",", "num_hidden", "=", "128", ")", "\n", "act1", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1", ",", "name", "=", "'relu1'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act1", ",", "name", "=", "'fc2'", ",", "num_hidden", "=", "64", ")", "\n", "act2", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc2", ",", "name", "=", "'relu2'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act2", ",", "name", "=", "'fc3'", ",", "num_hidden", "=", "10", ")", "\n", "concat", "=", "mx", ".", "sym", ".", "concat", "(", "fc1", ",", "fc2", ",", "fc3", ",", "name", "=", "'concat1'", ")", "\n", "\n", "symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "concat", ")", "\n", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "4", ")", "==", "[", "3", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "11", ")", "==", "[", "8", "]", "\n", "assert", "self", ".", "mh", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "12", ")", "==", "[", "3", ",", "7", ",", "11", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_arg_nodes": [[355, 363], ["test_model_handler.TestModelHandler.mh._get_arg_nodes", "test_model_handler.TestModelHandler.mh._get_arg_nodes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes"], ["", "def", "test_get_arg_nodes", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "mh", ".", "_get_arg_nodes", "(", "self", ".", "nodes", ")", "==", "[", "0", ",", "1", ",", "2", ",", "5", ",", "6", ",", "11", ",", "12", ",", "14", "]", "\n", "\n", "null_node", "=", "{", "'op'", ":", "'null'", "}", "\n", "op_node", "=", "{", "'op'", ":", "'FullyConnected'", "}", "\n", "nodes", "=", "[", "null_node", ",", "op_node", ",", "op_node", ",", "null_node", ",", "null_node", ",", "null_node", ",", "op_node", "]", "\n", "\n", "assert", "self", ".", "mh", ".", "_get_arg_nodes", "(", "nodes", ")", "==", "[", "0", ",", "3", ",", "4", ",", "5", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_heads": [[364, 368], ["test_model_handler.TestModelHandler.mh._get_heads", "test_model_handler.TestModelHandler.mh._get_heads", "test_model_handler.TestModelHandler.mh._get_heads"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads"], ["", "def", "test_get_heads", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "mh", ".", "_get_heads", "(", "self", ".", "nodes", ",", "'softmaxoutput1'", ")", "in", "[", "[", "[", "15", ",", "0", ",", "0", "]", "]", ",", "[", "[", "15", ",", "0", "]", "]", "]", "\n", "assert", "self", ".", "mh", ".", "_get_heads", "(", "self", ".", "nodes", "[", "-", "11", ":", "]", ",", "'softmaxoutput1'", ")", "in", "[", "[", "[", "10", ",", "0", ",", "0", "]", "]", ",", "[", "[", "10", ",", "0", "]", "]", "]", "\n", "assert", "self", ".", "mh", ".", "_get_heads", "(", "self", ".", "nodes", "[", "-", "7", ":", "]", ",", "'softmaxoutput1'", ")", "in", "[", "[", "[", "6", ",", "0", ",", "0", "]", "]", ",", "[", "[", "6", ",", "0", "]", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_output_layer_names": [[369, 390], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.FullyConnected", "mxnet.sym.SoftmaxOutput", "mxnet.sym.SoftmaxOutput", "zip", "test_model_handler.TestModelHandler.mh._get_output_layer_names", "mxnet.sym.Group", "mxnet.sym.Group", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "test_model_handler.TestModelHandler.mh._get_output_layer_names"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_output_layer_names", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_output_layer_names"], ["", "def", "test_get_output_layer_names", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "mh", ".", "_get_output_layer_names", "(", "self", ".", "symbol_dict", ")", "==", "[", "'softmaxoutput1'", "]", "\n", "\n", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1'", ",", "num_hidden", "=", "128", ")", "\n", "act1", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1", ",", "name", "=", "'relu1'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc2", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act1", ",", "name", "=", "'fc2'", ",", "num_hidden", "=", "64", ")", "\n", "act2", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc2", ",", "name", "=", "'relu2'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc3", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "act2", ",", "name", "=", "'fc3'", ",", "num_hidden", "=", "10", ")", "\n", "fc4", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_1'", ",", "num_hidden", "=", "10", ")", "\n", "sm1", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc4", ",", "name", "=", "'softmax1'", ")", "\n", "fc5", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "fc3", ",", "name", "=", "'fc4_2'", ",", "num_hidden", "=", "10", ")", "\n", "sm2", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc5", ",", "name", "=", "'softmax2'", ")", "\n", "sm3", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "fc2", ",", "name", "=", "'softmax3'", ")", "\n", "\n", "outputs", "=", "[", "sm1", ",", "mx", ".", "sym", ".", "Group", "(", "[", "sm1", ",", "sm2", "]", ")", ",", "mx", ".", "sym", ".", "Group", "(", "[", "sm1", ",", "sm2", ",", "sm3", "]", ")", "]", "\n", "output_names", "=", "[", "[", "'softmax1'", "]", ",", "[", "'softmax1'", ",", "'softmax2'", "]", ",", "[", "'softmax1'", ",", "'softmax2'", ",", "'softmax3'", "]", "]", "\n", "\n", "for", "output", ",", "output_name", "in", "zip", "(", "outputs", ",", "output_names", ")", ":", "\n", "            ", "symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "output", ")", "\n", "self", ".", "mh", ".", "_get_output_layer_names", "(", "symbol_dict", ")", "==", "output_name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._build_symbol_with_nodes_with_zero_input": [[391, 401], ["mxnet.sym.Variable", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.FullyConnected", "mxnet.sym.Activation", "mxnet.sym.Activation.__add__", "mxnet.sym.SoftmaxOutput"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_build_symbol_with_nodes_with_zero_input", "(", ")", ":", "\n", "        ", "data", "=", "mx", ".", "sym", ".", "Variable", "(", "'data'", ")", "\n", "fc1a", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1a'", ",", "num_hidden", "=", "128", ")", "\n", "act1a", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1a", ",", "name", "=", "'relu1a'", ",", "act_type", "=", "\"relu\"", ")", "\n", "fc1b", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "data", "=", "data", ",", "name", "=", "'fc1b'", ",", "num_hidden", "=", "64", ")", "\n", "act1b", "=", "mx", ".", "sym", ".", "Activation", "(", "data", "=", "fc1b", ",", "name", "=", "'relu1b'", ",", "act_type", "=", "\"relu\"", ")", "\n", "plus", "=", "act1a", ".", "__add__", "(", "act1b", ")", "\n", "softmax", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "data", "=", "plus", ",", "name", "=", "'softmax'", ")", "\n", "return", "softmax", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layers_with_node_idx_as_input": [[402, 420], ["test_model_handler.TestModelHandler._build_symbol_with_nodes_with_zero_input", "test_model_handler.TestModelHandler.mh._get_symbol_dict", "range", "test_model_handler.TestModelHandler.mh._get_layers_with_node_idx_as_input"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._build_symbol_with_nodes_with_zero_input", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layers_with_node_idx_as_input"], ["", "def", "test_get_layers_with_node_idx_as_input", "(", "self", ")", ":", "\n", "        ", "softmax", "=", "self", ".", "_build_symbol_with_nodes_with_zero_input", "(", ")", "\n", "symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "softmax", ")", "\n", "\n", "expected_ids", "=", "[", "\n", "[", "3", ",", "7", "]", ",", "\n", "[", "3", "]", ",", "\n", "[", "3", "]", ",", "\n", "[", "4", "]", ",", "\n", "[", "9", "]", ",", "\n", "[", "7", "]", ",", "\n", "[", "7", "]", ",", "\n", "[", "8", "]", ",", "\n", "[", "9", "]", ",", "\n", "[", "11", "]", "\n", "]", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "            ", "assert", "self", ".", "mh", ".", "_get_layers_with_node_idx_as_input", "(", "i", ",", "symbol_dict", "[", "'nodes'", "]", ")", "==", "expected_ids", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.create_csv_iterator": [[421, 445], ["numpy.random.seed", "numpy.random.rand", "numpy.savetxt", "numpy.array", "numpy.savetxt", "mxnet.io.CSVIter", "os.remove", "os.remove"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "create_csv_iterator", "(", "batch_size", "=", "1", ")", ":", "\n", "# Save data as csv", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "csv_data", "=", "np", ".", "random", ".", "rand", "(", "6", ",", "3", "*", "224", "*", "224", ")", "\n", "data_path", "=", "'./csv_iterator_data.csv'", "\n", "np", ".", "savetxt", "(", "data_path", ",", "csv_data", ",", "delimiter", "=", "','", ")", "\n", "\n", "# Save labels as csv", "\n", "labels", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "0", "]", ",", "[", "1", "]", ",", "[", "1", "]", ",", "[", "2", "]", ",", "[", "2", "]", "]", ")", "\n", "label_path", "=", "'./csv_iterator_labels.csv'", "\n", "np", ".", "savetxt", "(", "label_path", ",", "labels", ",", "delimiter", "=", "','", ")", "\n", "\n", "# Create CSV iterator using data file and labels file", "\n", "# round_batch should be False for resets to work", "\n", "# (https://mxnet.incubator.apache.org/api/python/io/io.html#mxnet.io.CSVIter)", "\n", "csv_iterator", "=", "mx", ".", "io", ".", "CSVIter", "(", "data_csv", "=", "data_path", ",", "data_shape", "=", "(", "3", ",", "224", ",", "224", ")", ",", "label_csv", "=", "label_path", ",", "\n", "batch_size", "=", "batch_size", ",", "label_name", "=", "'softmaxoutput1_label'", ",", "round_batch", "=", "False", ")", "\n", "\n", "# Remove data and label files", "\n", "os", ".", "remove", "(", "data_path", ")", "\n", "os", ".", "remove", "(", "label_path", ")", "\n", "\n", "return", "csv_iterator", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_module_csv_iterator": [[446, 448], ["test_model_handler.TestModelHandler._test_get_module", "test_model_handler.TestModelHandler.create_csv_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_module", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.create_csv_iterator"], ["", "def", "test_get_module_csv_iterator", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_get_module", "(", "iterator", "=", "self", ".", "create_csv_iterator", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_module_image_iterator": [[449, 451], ["test_model_handler.TestModelHandler._test_get_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_module"], ["", "def", "test_get_module_image_iterator", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_get_module", "(", "iterator", "=", "self", ".", "image_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_module": [[452, 473], ["mxnet.nd.random.normal", "mxnet.nd.random.normal", "mxnet.nd.random.normal", "test_model_handler.TestModelHandler.assertLogs", "test_model_handler.TestModelHandler.mh.get_module", "type", "numpy.array_equal", "test_model_handler.TestModelHandler.mh.arg_params[].asnumpy", "[].asnumpy", "numpy.array_equal", "test_model_handler.TestModelHandler.mh.arg_params[].asnumpy", "[].asnumpy", "test_model_handler.TestModelHandler.get_params", "test_model_handler.TestModelHandler.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_module", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "_test_get_module", "(", "self", ",", "iterator", ")", ":", "\n", "        ", "fixed_layer_parameters", "=", "[", "'conv1_weight'", ",", "'conv1_bias'", ",", "'conv1_foo'", "]", "\n", "random_layer_parameters", "=", "[", "'conv2_weight'", ",", "'conv2_bias'", ",", "'conv2_foo'", "]", "\n", "# Set biases to random arrays so they are not empty arrays", "\n", "self", ".", "mh", ".", "arg_params", "[", "'conv1_bias'", "]", "=", "mx", ".", "nd", ".", "random", ".", "normal", "(", "shape", "=", "(", "1", ")", ")", "\n", "self", ".", "mh", ".", "arg_params", "[", "'conv2_bias'", "]", "=", "mx", ".", "nd", ".", "random", ".", "normal", "(", "shape", "=", "(", "8", ")", ")", "\n", "self", ".", "mh", ".", "arg_params", "[", "'fullyconnected0_bias'", "]", "=", "mx", ".", "nd", ".", "random", ".", "normal", "(", "shape", "=", "(", "4", ")", ")", "\n", "with", "self", ".", "assertLogs", "(", ")", "as", "cm", ":", "\n", "            ", "mod", "=", "self", ".", "mh", ".", "get_module", "(", "iterator", ",", "fixed_layer_parameters", "=", "fixed_layer_parameters", ",", "\n", "random_layer_parameters", "=", "random_layer_parameters", ")", "\n", "", "assert", "type", "(", "mod", ")", "==", "mx", ".", "mod", ".", "Module", "\n", "assert", "mod", ".", "_fixed_param_names", "==", "[", "'conv1_weight'", ",", "'conv1_bias'", "]", "\n", "# Assert finetune layer weights are equal to pretrained weights", "\n", "for", "f_tune_key", "in", "[", "'fullyconnected0_weight'", ",", "'conv1_weight'", ",", "'fullyconnected0_bias'", ",", "'conv1_bias'", "]", ":", "\n", "            ", "assert", "np", ".", "array_equal", "(", "self", ".", "mh", ".", "arg_params", "[", "f_tune_key", "]", ".", "asnumpy", "(", ")", ",", "mod", ".", "get_params", "(", ")", "[", "0", "]", "[", "f_tune_key", "]", ".", "asnumpy", "(", ")", ")", "\n", "# Assert random layer weights are different to pretrained weights", "\n", "", "for", "rand_key", "in", "[", "'conv2_weight'", ",", "'conv2_bias'", "]", ":", "\n", "            ", "assert", "not", "np", ".", "array_equal", "(", "self", ".", "mh", ".", "arg_params", "[", "rand_key", "]", ".", "asnumpy", "(", ")", ",", "mod", ".", "get_params", "(", ")", "[", "0", "]", "[", "rand_key", "]", ".", "asnumpy", "(", ")", ")", "\n", "# Assert logs written for fixed and random parameters that were not present in model", "\n", "", "assert", "cm", ".", "output", "==", "[", "'WARNING:root:Could not find layer parameters: conv1_foo'", ",", "\n", "'WARNING:root:Could not find layer parameters: conv2_foo'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_module_set_params_error": [[474, 487], ["pytest.mark.skip", "mxnet.image.ImageIter", "test_model_handler.TestModelHandler.assertRaisesRegex", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_module"], ["", "@", "pytest", ".", "mark", ".", "skip", "(", "reason", "=", "'This test causes an MXNet error to be raised because the weights provided to the model '", "\n", "'do not match the shape of the model. On TravisCI machines, this raised error causes the '", "\n", "'build to crash.'", ")", "\n", "def", "test_get_module_set_params_error", "(", "self", ")", ":", "\n", "# Assert ModelArchitectureError is raised when iterator dimensions do not match module weights", "\n", "        ", "image_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "123", ",", "123", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "path_root", "=", "'test_images'", ",", "\n", "label_name", "=", "'softmaxoutput1_label'", ")", "\n", "with", "self", ".", "assertRaises", "(", "model_handler", ".", "exceptions", ".", "ModelArchitectureError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_module", "(", "image_iter", ")", "\n", "", "self", ".", "assertRaisesRegex", "(", "model_handler", ".", "exceptions", ".", "ModelArchitectureError", ",", "'Weight shape mismatch: Expected shape='", "\n", "'\\(4,46225\\), Actual shape=\\(4,12996\\). This can be caused by incorrect layer shapes or '", "\n", "'incorrect input data shapes.'", ",", "\n", "self", ".", "mh", ".", "get_module", ",", "image_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_type": [[488, 497], ["layer_type.append", "test_model_handler.TestModelHandler.mh.get_layer_type"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_type"], ["", "def", "test_get_layer_type", "(", "self", ")", ":", "\n", "        ", "layer_type", "=", "[", "]", "\n", "for", "name", "in", "[", "'conv1'", ",", "'act1'", ",", "'conv2'", ",", "'act2'", ",", "'pool1'", ",", "'flatten1'", ",", "\n", "'fullyconnected0'", ",", "'softmaxoutput1'", "]", ":", "\n", "            ", "layer_type", ".", "append", "(", "self", ".", "mh", ".", "get_layer_type", "(", "name", ")", ")", "\n", "\n", "", "assert", "layer_type", "==", "[", "'Convolution'", ",", "'Activation'", ",", "'Convolution'", ",", "\n", "'Activation'", ",", "'Pooling'", ",", "'Flatten'", ",", "\n", "'FullyConnected'", ",", "'SoftmaxOutput'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_type_failure": [[498, 501], ["test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_layer_type"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_type"], ["", "def", "test_get_layer_type_failure", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_layer_type", "(", "'fake_layer_name'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_names_matching_type": [[502, 517], ["test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "test_model_handler.TestModelHandler.mh.get_layer_names_matching_type", "sorted", "sorted", "sorted", "sorted"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type"], ["", "", "def", "test_get_layer_names_matching_type", "(", "self", ")", ":", "\n", "        ", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'CONVOLUTION'", ")", "\n", "assert", "sorted", "(", "layers_found", ")", "==", "sorted", "(", "[", "'conv1'", ",", "'conv2'", "]", ")", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'activation'", ")", "\n", "assert", "sorted", "(", "layers_found", ")", "==", "sorted", "(", "[", "'act1'", ",", "'act2'", "]", ")", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'Pooling'", ")", "\n", "assert", "layers_found", "==", "[", "'pool1'", "]", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'flatten'", ")", "\n", "assert", "layers_found", "==", "[", "'flatten1'", "]", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'fullyconnected'", ")", "\n", "assert", "layers_found", "==", "[", "'fullyconnected0'", "]", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'SoftmaxOutput'", ")", "\n", "assert", "layers_found", "==", "[", "'softmaxoutput1'", "]", "\n", "layers_found", "=", "self", ".", "mh", ".", "get_layer_names_matching_type", "(", "'BatchNorm'", ")", "\n", "assert", "layers_found", "==", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_image_iterator": [[518, 541], ["mxnet.image.ImageIter", "test_model_handler.TestModelHandler.mh.get_layer_output", "numpy.array", "numpy.allclose", "type", "list", "sorted", "sorted", "features.keys", "features.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output"], ["", "def", "_test_get_layer_output_image_iterator", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "layer1", ",", "layer2", "=", "(", "'fullyconnected0'", ",", "'flatten1'", ")", "\n", "image_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "batch_size", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "\n", "path_root", "=", "'tests/data/test_images'", ",", "label_name", "=", "'softmaxoutput1_label'", ",", "\n", "data_name", "=", "self", ".", "data_name", ")", "\n", "features", ",", "labels", "=", "self", ".", "mh", ".", "get_layer_output", "(", "image_iter", ",", "[", "layer1", ",", "layer2", "]", ")", "\n", "assert", "type", "(", "features", ")", "==", "OrderedDict", "\n", "assert", "list", "(", "features", ".", "keys", "(", ")", ")", "==", "[", "'fullyconnected0'", ",", "'flatten1'", "]", "\n", "tolerance", "=", "5e-2", "\n", "\n", "expected_labels", "=", "[", "0", ",", "0", ",", "1", ",", "1", ",", "2", ",", "2", "]", "\n", "assert", "(", "labels", "==", "expected_labels", ")", ".", "all", "(", ")", ",", "'Expected {}, got {}'", ".", "format", "(", "expected_labels", ",", "labels", ")", "\n", "assert", "sorted", "(", "features", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "layer1", ",", "layer2", "]", ")", "\n", "\n", "expected_features", "=", "{", "}", "\n", "expected_features", "[", "layer1", "]", "=", "np", ".", "array", "(", "[", "[", "-", "2026513.375", ",", "-", "1203439.", ",", "-", "1706091.", ",", "402870.3125", "]", ",", "\n", "[", "-", "5010966.", ",", "-", "611501.375", ",", "-", "1003263.4375", ",", "2879037.", "]", ",", "\n", "[", "-", "145177.96875", ",", "-", "4538920.5", ",", "219717.46875", ",", "1895801.25", "]", ",", "\n", "[", "-", "2568541.5", ",", "-", "341903.75", ",", "-", "2446673.", ",", "716777.3125", "]", ",", "\n", "[", "491937.84375", ",", "-", "336953.78125", ",", "-", "717204.75", ",", "941894.", "]", ",", "\n", "[", "-", "3536730.", ",", "-", "3252726.75", ",", "196532.796875", ",", "1375444.125", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "features", "[", "layer1", "]", ",", "expected_features", "[", "layer1", "]", ",", "rtol", "=", "tolerance", ")", "\n", "assert", "features", "[", "layer2", "]", ".", "shape", "==", "(", "6", ",", "46225", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_csv_iterator": [[542, 544], ["test_model_handler.TestModelHandler._test_get_layer_output", "test_model_handler.TestModelHandler.create_csv_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.create_csv_iterator"], ["", "def", "_test_get_layer_output_csv_iterator", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "_test_get_layer_output", "(", "iterator", "=", "self", ".", "create_csv_iterator", "(", "batch_size", "=", "batch_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_NDArray_iterator": [[545, 549], ["numpy.random.rand", "mxnet.io.NDArrayIter", "test_model_handler.TestModelHandler._test_get_layer_output", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output"], ["", "def", "_test_get_layer_output_NDArray_iterator", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "data", "=", "np", ".", "random", ".", "rand", "(", "6", ",", "3", ",", "224", ",", "224", ")", "\n", "nda_iter", "=", "mx", ".", "io", ".", "NDArrayIter", "(", "data", "=", "data", ",", "label", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "2", ",", "2", "]", ")", ",", "batch_size", "=", "batch_size", ")", "\n", "self", ".", "_test_get_layer_output", "(", "iterator", "=", "nda_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output": [[550, 596], ["test_model_handler.TestModelHandler.mh.get_layer_output", "numpy.array", "len", "enumerate", "enumerate", "type", "list", "sorted", "sorted", "hash", "len", "hash", "len", "test_model_handler.TestModelHandler.assertTrue", "test_model_handler.TestModelHandler.assertTrue", "test_model_handler.TestModelHandler.assertTrue", "features.keys", "features.keys", "str", "str", "numpy.allclose", "[].astype", "[].astype"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output"], ["", "def", "_test_get_layer_output", "(", "self", ",", "iterator", ")", ":", "\n", "        ", "layer1", ",", "layer2", "=", "(", "'fullyconnected0'", ",", "'flatten1'", ")", "\n", "features", ",", "labels", "=", "self", ".", "mh", ".", "get_layer_output", "(", "iterator", ",", "[", "layer1", ",", "layer2", "]", ")", "\n", "assert", "type", "(", "features", ")", "==", "OrderedDict", "\n", "assert", "list", "(", "features", ".", "keys", "(", ")", ")", "==", "[", "'fullyconnected0'", ",", "'flatten1'", "]", "\n", "tolerance", "=", "1e-4", "\n", "\n", "assert", "sorted", "(", "features", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "layer1", ",", "layer2", "]", ")", "\n", "\n", "expected_features", "=", "{", "}", "\n", "expected_features", "[", "layer1", "]", "=", "np", ".", "array", "(", "[", "[", "-", "14632.44140625", ",", "-", "15410.29882812", ",", "401.85760498", ",", "3048.72143555", "]", ",", "\n", "[", "-", "14077.45507812", ",", "-", "14598.43457031", ",", "1666.03442383", ",", "7222.70019531", "]", ",", "\n", "[", "-", "16092.02929688", ",", "-", "16345.94042969", ",", "-", "2379.76391602", ",", "6223.95605469", "]", ",", "\n", "[", "-", "15005.03808594", ",", "-", "15088.01660156", ",", "5304.77539062", ",", "6113.68164062", "]", ",", "\n", "[", "-", "12687.98339844", ",", "-", "14598.75097656", ",", "1158.26794434", ",", "4819.8671875", "]", ",", "\n", "[", "-", "11366.10351562", ",", "-", "16437.70507812", ",", "-", "4690.74951172", ",", "8055.31982422", "]", "]", ")", "\n", "expected_labels", "=", "[", "0", ",", "0", ",", "1", ",", "1", ",", "2", ",", "2", "]", "\n", "num_test_instances", "=", "len", "(", "expected_labels", ")", "\n", "\n", "expected_feature_label_dict", "=", "{", "}", "\n", "for", "index", ",", "expected_label", "in", "enumerate", "(", "expected_labels", ")", ":", "\n", "            ", "key", "=", "hash", "(", "str", "(", "expected_features", "[", "layer1", "]", "[", "index", "]", ".", "astype", "(", "int", ")", ")", ")", "\n", "expected_feature_label_dict", "[", "key", "]", "=", "(", "expected_features", "[", "layer1", "]", "[", "index", "]", ",", "expected_label", ")", "\n", "", "assert", "len", "(", "expected_feature_label_dict", ")", "==", "num_test_instances", "\n", "\n", "actual_feature_label_dict", "=", "{", "}", "\n", "for", "index", ",", "actual_label", "in", "enumerate", "(", "labels", ")", ":", "\n", "            ", "key", "=", "hash", "(", "str", "(", "features", "[", "layer1", "]", "[", "index", "]", ".", "astype", "(", "int", ")", ")", ")", "\n", "actual_feature_label_dict", "[", "key", "]", "=", "(", "features", "[", "layer1", "]", "[", "index", "]", ",", "actual_label", ")", "\n", "", "assert", "len", "(", "actual_feature_label_dict", ")", "==", "num_test_instances", "\n", "\n", "# Compare if <feature, label> pairs are returned as expected", "\n", "for", "key", "in", "expected_feature_label_dict", ":", "\n", "            ", "self", ".", "assertTrue", "(", "key", "in", "actual_feature_label_dict", ",", "\"Expected features not found\"", ")", "\n", "\n", "expected_features", "=", "expected_feature_label_dict", "[", "key", "]", "[", "0", "]", "\n", "actual_features", "=", "actual_feature_label_dict", "[", "key", "]", "[", "0", "]", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "expected_features", ",", "actual_features", ",", "rtol", "=", "tolerance", ")", ",", "\n", "\"Expected features:{}. Actual:{}\"", ".", "format", "(", "expected_features", ",", "actual_features", ")", ")", "\n", "\n", "expected_label", "=", "expected_feature_label_dict", "[", "key", "]", "[", "1", "]", "\n", "actual_label", "=", "actual_feature_label_dict", "[", "key", "]", "[", "1", "]", "\n", "self", ".", "assertTrue", "(", "expected_label", "==", "actual_label", ",", "\n", "\"Expected label:{}. Actual:{}\"", ".", "format", "(", "expected_label", ",", "actual_label", ")", ")", "\n", "\n", "", "assert", "features", "[", "layer2", "]", ".", "shape", "==", "(", "6", ",", "46225", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_image_iterator": [[597, 600], ["test_model_handler.TestModelHandler._test_get_layer_output_image_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_image_iterator"], ["", "def", "test_get_layer_output_image_iterator", "(", "self", ")", ":", "\n", "# test for when there is no padding", "\n", "        ", "self", ".", "_test_get_layer_output_image_iterator", "(", "batch_size", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_image_iterator_padding": [[601, 604], ["test_model_handler.TestModelHandler._test_get_layer_output_image_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_image_iterator"], ["", "def", "test_get_layer_output_image_iterator_padding", "(", "self", ")", ":", "\n", "# test for padding", "\n", "        ", "self", ".", "_test_get_layer_output_image_iterator", "(", "batch_size", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_NDArray_iterator": [[605, 608], ["test_model_handler.TestModelHandler._test_get_layer_output_NDArray_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_NDArray_iterator"], ["", "def", "test_get_layer_output_NDArray_iterator", "(", "self", ")", ":", "\n", "# test for when there is no padding", "\n", "        ", "self", ".", "_test_get_layer_output_NDArray_iterator", "(", "batch_size", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_NDArray_iterator_padding": [[609, 612], ["test_model_handler.TestModelHandler._test_get_layer_output_NDArray_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_NDArray_iterator"], ["", "def", "test_get_layer_output_NDArray_iterator_padding", "(", "self", ")", ":", "\n", "# test for padding", "\n", "        ", "self", ".", "_test_get_layer_output_NDArray_iterator", "(", "batch_size", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_csv_iterator_padding": [[618, 621], ["test_model_handler.TestModelHandler._test_get_layer_output_csv_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._test_get_layer_output_csv_iterator"], ["", "def", "test_get_layer_output_csv_iterator_padding", "(", "self", ")", ":", "\n", "# test for padding", "\n", "        ", "self", ".", "_test_get_layer_output_csv_iterator", "(", "batch_size", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_output_invalid_type": [[622, 630], ["test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_layer_output", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_layer_output", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_layer_output"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output"], ["", "def", "test_get_layer_output_invalid_type", "(", "self", ")", ":", "\n", "        ", "layer1", ",", "layer2", "=", "(", "'fullyconnected0'", ",", "'flatten1'", ")", "\n", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_layer_output", "(", "None", ",", "[", "layer1", ",", "layer2", "]", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_layer_output", "(", "'iter'", ",", "[", "layer1", ",", "layer2", "]", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_layer_output", "(", "self", ".", "image_iter", ",", "layer1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_parameters": [[631, 637], ["test_model_handler.TestModelHandler.mh.get_layer_parameters", "test_model_handler.TestModelHandler.mh.get_layer_parameters", "sorted", "sorted", "sorted", "sorted"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters"], ["", "", "def", "test_get_layer_parameters", "(", "self", ")", ":", "\n", "        ", "layer_params", "=", "self", ".", "mh", ".", "get_layer_parameters", "(", "self", ".", "mh", ".", "layer_names", ")", "\n", "assert", "sorted", "(", "layer_params", ")", "==", "sorted", "(", "[", "'conv1_bias'", ",", "'conv1_weight'", ",", "'conv2_bias'", ",", "'conv2_weight'", ",", "\n", "'fullyconnected0_bias'", ",", "'fullyconnected0_weight'", "]", ")", "\n", "layer_params", "=", "self", ".", "mh", ".", "get_layer_parameters", "(", "[", "'fullyconnected0'", "]", ")", "\n", "assert", "sorted", "(", "layer_params", ")", "==", "sorted", "(", "[", "'fullyconnected0_bias'", ",", "'fullyconnected0_weight'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_parameters_not_list": [[638, 641], ["test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh.get_layer_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters"], ["", "def", "test_get_layer_parameters_not_list", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "get_layer_parameters", "(", "'fullyconnected0'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_visualize_net": [[642, 644], ["isinstance", "test_model_handler.TestModelHandler.mh.visualize_net"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.visualize_net"], ["", "", "def", "test_visualize_net", "(", "self", ")", ":", "\n", "        ", "assert", "isinstance", "(", "self", ".", "mh", ".", "visualize_net", "(", ")", ",", "graphviz", ".", "dot", ".", "Digraph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_save_symbol": [[645, 653], ["test_model_handler.TestModelHandler.mh.save_symbol", "os.path.isfile", "mxnet.sym.load", "os.remove", "os.path.isfile", "test_model_handler.TestModelHandler.mh.symbol.get_internals().list_outputs", "mxnet.sym.load.get_internals().list_outputs", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "mxnet.sym.load.get_internals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.save_symbol", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "def", "test_save_symbol", "(", "self", ")", ":", "\n", "        ", "assert", "not", "os", ".", "path", ".", "isfile", "(", "'temp-test-symbol.json'", ")", "\n", "self", ".", "mh", ".", "save_symbol", "(", "'temp-test'", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "'temp-test-symbol.json'", ")", "\n", "\n", "saved_sym", "=", "mx", ".", "sym", ".", "load", "(", "'temp-test-symbol.json'", ")", "\n", "assert", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "==", "saved_sym", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "os", ".", "remove", "(", "'temp-test-symbol.json'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_validate_layer_name": [[654, 671], ["test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._validate_layer_name"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name"], ["", "def", "test_validate_layer_name", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv2'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'prob_label'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv3_output'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv3_weight'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv3_moving_mean'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv3_beta_q'", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_validate_layer_name", "(", "self", ".", "data_name", ")", "\n", "", "self", ".", "mh", ".", "_validate_layer_name", "(", "'conv3'", ")", "\n", "self", ".", "mh", ".", "_validate_layer_name", "(", "'weighted'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_prune_parameters": [[672, 680], ["test_model_handler.TestModelHandler.assertLogs", "test_model_handler.TestModelHandler.mh._prune_parameters", "set().symmetric_difference", "set", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._prune_parameters"], ["", "def", "test_prune_parameters", "(", "self", ")", ":", "\n", "# Assert that parameters are pruned and logs are written", "\n", "        ", "parameter_names_pre", "=", "[", "'conv1_weight'", ",", "'conv1_bias'", ",", "'conv1_moving_mean'", ",", "'made_up_param'", "]", "\n", "with", "self", ".", "assertLogs", "(", ")", "as", "cm", ":", "\n", "            ", "parameter_names_post", "=", "self", ".", "mh", ".", "_prune_parameters", "(", "parameter_names_pre", ")", "\n", "", "assert", "set", "(", "parameter_names_pre", ")", ".", "symmetric_difference", "(", "set", "(", "parameter_names_post", ")", ")", "==", "{", "'conv1_moving_mean'", ",", "\n", "'made_up_param'", "}", "\n", "assert", "cm", ".", "output", "==", "[", "'WARNING:root:Could not find layer parameters: conv1_moving_mean, made_up_param'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_prune_parameters_no_extra": [[681, 688], ["test_model_handler.TestModelHandler.assertRaises", "set().symmetric_difference", "set", "test_model_handler.TestModelHandler.assertLogs", "test_model_handler.TestModelHandler.mh._prune_parameters", "set", "set"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._prune_parameters"], ["", "def", "test_prune_parameters_no_extra", "(", "self", ")", ":", "\n", "# Assert no parameters are removed and no logs are written", "\n", "        ", "parameter_names_pre", "=", "[", "'conv1_weight'", ",", "'conv1_bias'", "]", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "with", "self", ".", "assertLogs", "(", ")", ":", "\n", "                ", "parameter_names_post", "=", "self", ".", "mh", ".", "_prune_parameters", "(", "parameter_names_pre", ")", "\n", "", "", "assert", "set", "(", "parameter_names_pre", ")", ".", "symmetric_difference", "(", "set", "(", "parameter_names_post", ")", ")", "==", "set", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_remove_random_parameters": [[689, 699], ["test_model_handler.TestModelHandler.assertLogs", "test_model_handler.TestModelHandler.mh._remove_random_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._remove_random_parameters"], ["", "def", "test_remove_random_parameters", "(", "self", ")", ":", "\n", "        ", "random_parameters", "=", "[", "'conv1_weight'", ",", "'conv1_bias'", ",", "'conv1_moving_var'", ",", "'conv3_weight'", ",", "'conv3_moving_var'", "]", "\n", "self", ".", "mh", ".", "arg_params", "=", "{", "'conv1_weight'", ":", "1", ",", "'conv1_bias'", ":", "1", ",", "'conv2_weight'", ":", "1", ",", "'conv2_bias'", ":", "1", "}", "\n", "self", ".", "mh", ".", "aux_params", "=", "{", "'conv1_moving_var'", ":", "1", ",", "'conv2_moving_var'", ":", "1", "}", "\n", "with", "self", ".", "assertLogs", "(", ")", "as", "cm", ":", "\n", "            ", "arg_params", ",", "aux_params", "=", "self", ".", "mh", ".", "_remove_random_parameters", "(", "random_parameters", ")", "\n", "\n", "", "assert", "arg_params", "==", "{", "'conv2_weight'", ":", "1", ",", "'conv2_bias'", ":", "1", "}", "\n", "assert", "aux_params", "==", "{", "'conv2_moving_var'", ":", "1", "}", "\n", "assert", "cm", ".", "output", "==", "[", "'WARNING:root:Could not find layer parameters: conv3_weight, conv3_moving_var'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_devices_cpu": [[700, 703], ["test_model_handler.TestModelHandler.mh._get_devices", "mxnet.cpu", "mxnet.cpu", "mxnet.cpu"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_devices"], ["", "def", "test_get_devices_cpu", "(", "self", ")", ":", "\n", "        ", "devices", "=", "self", ".", "mh", ".", "_get_devices", "(", "mx", ".", "context", ".", "cpu", ",", "3", ")", "\n", "assert", "devices", "==", "[", "mx", ".", "cpu", "(", "0", ")", ",", "mx", ".", "cpu", "(", "1", ")", ",", "mx", ".", "cpu", "(", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_devices_gpu": [[704, 707], ["test_model_handler.TestModelHandler.mh._get_devices", "mxnet.gpu", "mxnet.gpu", "mxnet.gpu"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_devices"], ["", "def", "test_get_devices_gpu", "(", "self", ")", ":", "\n", "        ", "devices", "=", "self", ".", "mh", ".", "_get_devices", "(", "mx", ".", "context", ".", "gpu", ",", "3", ")", "\n", "assert", "devices", "==", "[", "mx", ".", "gpu", "(", "0", ")", ",", "mx", ".", "gpu", "(", "1", ")", ",", "mx", ".", "gpu", "(", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_assert_drop_layer_valid": [[708, 724], ["test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid", "test_model_handler.TestModelHandler.assertRaises", "test_model_handler.TestModelHandler.mh._assert_drop_layer_valid"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid"], ["", "def", "test_assert_drop_layer_valid", "(", "self", ")", ":", "\n", "        ", "self", ".", "mh", ".", "layer_type_dict", "=", "{", "}", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "1", ")", "\n", "", "self", ".", "mh", ".", "layer_type_dict", "=", "{", "'a'", ":", "1", "}", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "1", ")", "\n", "", "self", ".", "mh", ".", "layer_type_dict", "=", "{", "'a'", ":", "1", ",", "'b'", ":", "2", "}", "\n", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "1", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "2", ")", "\n", "", "self", ".", "mh", ".", "layer_type_dict", "=", "{", "'a'", ":", "1", ",", "'b'", ":", "2", ",", "'c'", ":", "3", "}", "\n", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "1", ")", "\n", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "2", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelError", ")", ":", "\n", "            ", "self", ".", "mh", ".", "_assert_drop_layer_valid", "(", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_layer_type_dict": [[725, 730], ["collections.OrderedDict", "list", "list", "test_model_handler.TestModelHandler.mh._get_layer_type_dict().items", "collections.OrderedDict.items", "test_model_handler.TestModelHandler.mh._get_layer_type_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layer_type_dict"], ["", "", "def", "test_get_layer_type_dict", "(", "self", ")", ":", "\n", "        ", "expected_dict", "=", "OrderedDict", "(", "[", "(", "'conv1'", ",", "'Convolution'", ")", ",", "(", "'act1'", ",", "'Activation'", ")", ",", "(", "'conv2'", ",", "'Convolution'", ")", ",", "\n", "(", "'act2'", ",", "'Activation'", ")", ",", "(", "'pool1'", ",", "'Pooling'", ")", ",", "(", "'flatten1'", ",", "'Flatten'", ")", ",", "\n", "(", "'fullyconnected0'", ",", "'FullyConnected'", ")", ",", "(", "'softmaxoutput1'", ",", "'SoftmaxOutput'", ")", "]", ")", "\n", "assert", "list", "(", "self", ".", "mh", ".", "_get_layer_type_dict", "(", ")", ".", "items", "(", ")", ")", "==", "list", "(", "expected_dict", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_get_symbol_dict": [[731, 745], ["test_model_handler.TestModelHandler.mh._get_symbol_dict", "open", "json.load", "expected_symbol_dict[].keys", "real_symbol_dict[].keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "def", "test_get_symbol_dict", "(", "self", ")", ":", "\n", "        ", "with", "open", "(", "'tests/data/symbol_dict.json'", ")", "as", "json_data", ":", "\n", "            ", "expected_symbol_dict", "=", "json", ".", "load", "(", "json_data", ")", "\n", "\n", "", "real_symbol_dict", "=", "self", ".", "mh", ".", "_get_symbol_dict", "(", "self", ".", "mh", ".", "symbol", ")", "\n", "\n", "# Remove mxnet version number from symbol dictionaries so test doesn't break on new version", "\n", "MXNET_VERSION", "=", "'mxnet_version'", "\n", "if", "MXNET_VERSION", "in", "expected_symbol_dict", "[", "consts", ".", "ATTRIBUTES", "]", ".", "keys", "(", ")", ":", "\n", "            ", "del", "expected_symbol_dict", "[", "consts", ".", "ATTRIBUTES", "]", "[", "'mxnet_version'", "]", "\n", "", "if", "MXNET_VERSION", "in", "real_symbol_dict", "[", "consts", ".", "ATTRIBUTES", "]", ".", "keys", "(", ")", ":", "\n", "            ", "del", "real_symbol_dict", "[", "consts", ".", "ATTRIBUTES", "]", "[", "'mxnet_version'", "]", "\n", "\n", "", "assert", "expected_symbol_dict", "==", "real_symbol_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_layer_names": [[746, 751], ["None"], "methods", ["None"], ["", "def", "test_layer_names", "(", "self", ")", ":", "\n", "        ", "expected_layer_names", "=", "[", "'conv1'", ",", "'act1'", ",", "'conv2'", ",", "'act2'", ",", "'pool1'", ",", "'flatten1'", ",", "'fullyconnected0'", ",", "\n", "'softmaxoutput1'", "]", "\n", "\n", "assert", "self", ".", "mh", ".", "layer_names", "==", "expected_layer_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_clean_params": [[752, 768], ["test_model_handler.TestModelHandler.mh._clean_params", "test_model_handler.TestModelHandler.mh._clean_params", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "sorted", "sorted", "sorted", "sorted", "test_model_handler.TestModelHandler.mh.symbol.get_internals", "sorted", "sorted", "sorted", "sorted", "test_model_handler.TestModelHandler.mh.arg_params.keys", "test_model_handler.TestModelHandler.keys", "test_model_handler.TestModelHandler.mh.arg_params.keys", "test_model_handler.TestModelHandler.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._clean_params", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._clean_params"], ["", "def", "test_clean_params", "(", "self", ")", ":", "\n", "        ", "symbol", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", "[", "self", ".", "act1_id", "]", "\n", "assert", "sorted", "(", "self", ".", "mh", ".", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv2_bias'", ",", "'conv1_bias'", ",", "'conv2_weight'", ",", "\n", "'fullyconnected0_weight'", ",", "'fullyconnected0_bias'", "]", ")", "\n", "\n", "arg_params", "=", "self", ".", "mh", ".", "_clean_params", "(", "symbol", ",", "self", ".", "mh", ".", "arg_params", ")", "\n", "\n", "assert", "sorted", "(", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv1_bias'", "]", ")", "\n", "\n", "symbol", "=", "self", ".", "mh", ".", "symbol", ".", "get_internals", "(", ")", "[", "self", ".", "conv2_id", "]", "\n", "assert", "sorted", "(", "self", ".", "mh", ".", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv2_bias'", ",", "'conv1_bias'", ",", "'conv2_weight'", ",", "\n", "'fullyconnected0_weight'", ",", "'fullyconnected0_bias'", "]", ")", "\n", "\n", "arg_params", "=", "self", ".", "mh", ".", "_clean_params", "(", "symbol", ",", "self", ".", "mh", ".", "arg_params", ")", "\n", "\n", "assert", "sorted", "(", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv2_bias'", ",", "'conv1_bias'", ",", "'conv2_weight'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler.test_update_sym": [[769, 795], ["mxnet.module.Module.load", "xfer.model_handler.ModelHandler", "xfer.model_handler.ModelHandler.update_sym", "test_model_handler.TestModelHandler._compare_symbols", "mxnet.module.Module.load", "xfer.model_handler.ModelHandler", "xfer.model_handler.ModelHandler.update_sym", "test_model_handler.TestModelHandler._compare_symbols", "xfer.model_handler.ModelHandler.symbol.get_internals", "collections.OrderedDict", "xfer.model_handler.ModelHandler.symbol.tojson", "symbol.tojson", "sorted", "sorted", "xfer.model_handler.ModelHandler.symbol.get_internals", "collections.OrderedDict", "xfer.model_handler.ModelHandler.symbol.tojson", "symbol.tojson", "sorted", "sorted", "xfer.model_handler.ModelHandler.arg_params.keys", "xfer.model_handler.ModelHandler.arg_params.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._compare_symbols", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._compare_symbols"], ["", "def", "test_update_sym", "(", "self", ")", ":", "\n", "        ", "mod", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ",", "mx", ".", "context", ".", "cpu", ",", "1", ")", "\n", "symbol", "=", "mh", ".", "symbol", ".", "get_internals", "(", ")", "[", "self", ".", "act1_id", "]", "\n", "self", ".", "mh", ".", "aux_params", "=", "{", "1", ":", "2", ",", "2", ":", "3", ",", "4", ":", "5", ",", "7", ":", "3", ",", "6", ":", "8", ",", "3", ":", "5", ",", "12", ":", "5", "}", "\n", "\n", "mh", ".", "update_sym", "(", "symbol", ")", "\n", "\n", "assert", "mh", ".", "layer_type_dict", "==", "OrderedDict", "(", "[", "(", "'conv1'", ",", "'Convolution'", ")", ",", "(", "'act1'", ",", "'Activation'", ")", "]", ")", "\n", "assert", "mh", ".", "symbol", ".", "tojson", "(", ")", "==", "symbol", ".", "tojson", "(", ")", "\n", "self", ".", "_compare_symbols", "(", "mh", ".", "symbol", ",", "symbol", ")", "\n", "assert", "sorted", "(", "mh", ".", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv1_bias'", "]", ")", "\n", "assert", "mh", ".", "aux_params", "==", "{", "}", "\n", "\n", "mod", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ")", "\n", "mh", "=", "model_handler", ".", "ModelHandler", "(", "mod", ",", "mx", ".", "context", ".", "cpu", ",", "1", ")", "\n", "symbol", "=", "mh", ".", "symbol", ".", "get_internals", "(", ")", "[", "self", ".", "conv2_id", "]", "\n", "\n", "mh", ".", "update_sym", "(", "symbol", ")", "\n", "\n", "assert", "mh", ".", "layer_type_dict", "==", "OrderedDict", "(", "[", "(", "'conv1'", ",", "'Convolution'", ")", ",", "(", "'act1'", ",", "'Activation'", ")", ",", "\n", "(", "'conv2'", ",", "'Convolution'", ")", "]", ")", "\n", "assert", "mh", ".", "symbol", ".", "tojson", "(", ")", "==", "symbol", ".", "tojson", "(", ")", "\n", "self", ".", "_compare_symbols", "(", "mh", ".", "symbol", ",", "symbol", ")", "\n", "assert", "sorted", "(", "mh", ".", "arg_params", ".", "keys", "(", ")", ")", "==", "sorted", "(", "[", "'conv1_weight'", ",", "'conv2_bias'", ",", "'conv1_bias'", ",", "'conv2_weight'", "]", ")", "\n", "assert", "mh", ".", "aux_params", "==", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_model_handler.TestModelHandler._compare_symbols": [[796, 814], ["enumerate", "sym1.get_internals().list_outputs", "sym2.get_internals().list_outputs", "sym2.get_internals().list_outputs", "sym1.get_internals().list_outputs", "sym1.get_internals", "sym1.infer_shape", "sym2.infer_shape", "[].get_internals().list_outputs", "[].get_internals().list_outputs", "sym1.get_internals", "sym2.get_internals", "sym2.get_internals", "sym1.get_internals", "[].get_internals", "[].get_internals", "sym1.get_internals", "sym1.get_internals"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compare_symbols", "(", "sym1", ",", "sym2", ")", ":", "\n", "        ", "\"\"\"\n        Compare two symbols.\n\n        :param sym1: Actual symbol\n        :param sym2: Expected symbol\n        \"\"\"", "\n", "assert", "sym1", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "==", "sym2", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", ",", "'Symbol outputs \\\n            mismatch. Expected: {}, Got: {}'", ".", "format", "(", "sym2", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", ",", "\n", "sym1", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", ")", "\n", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "sym1", ".", "get_internals", "(", ")", ")", ":", "\n", "            ", "assert", "sym1", ".", "get_internals", "(", ")", "[", "i", "]", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "==", "sym1", ".", "get_internals", "(", ")", "[", "i", "]", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "\n", "", "data_shape", "=", "(", "5", ",", "3", ",", "224", ",", "224", ")", "\n", "assert", "sym1", ".", "infer_shape", "(", "data", "=", "data_shape", ")", "==", "sym2", ".", "infer_shape", "(", "data", "=", "data_shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.setUp": [[21, 24], ["super().setUp"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "repurposer_class", "=", "NeuralNetworkFineTuneRepurposer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.test_get_target_model_symbol__invalid_transfer_layer_name": [[25, 34], ["test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertTrue", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.repurposer_class", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertRaisesRegex"], "methods", ["None"], ["", "def", "test_get_target_model_symbol__invalid_transfer_layer_name", "(", "self", ")", ":", "\n", "        ", "invalid_transfer_layer_name", "=", "'phantom_layer'", "\n", "self", ".", "assertTrue", "(", "invalid_transfer_layer_name", "not", "in", "self", ".", "source_layers", ",", "\n", "RepurposerTestUtils", ".", "ERROR_INCORRECT_INPUT", ")", "\n", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "transfer_layer_name", "=", "invalid_transfer_layer_name", ",", "\n", "target_class_count", "=", "2", ")", "\n", "expected_error_msg", "=", "'transfer_layer_name: {} not found in source model'", ".", "format", "(", "invalid_transfer_layer_name", ")", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "expected_error_msg", ",", "repurposer", ".", "_get_target_symbol", ",", "self", ".", "source_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.test_get_target_model_symbol__valid_transfer_layer_name": [[35, 59], ["test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertTrue", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.repurposer_class", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase._get_target_symbol", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertTrue", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.mxnet_model.symbol.get_internals().list_outputs", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertTrue", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase._get_target_symbol.get_internals().list_outputs", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.assertTrue", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.mxnet_model.symbol.get_internals", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase._get_target_symbol.get_internals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._get_target_symbol"], ["", "def", "test_get_target_model_symbol__valid_transfer_layer_name", "(", "self", ")", ":", "\n", "# Create repurposer with valid transfer layer name", "\n", "        ", "valid_transfer_layer_name", "=", "'relu1'", "\n", "self", ".", "assertTrue", "(", "valid_transfer_layer_name", "in", "self", ".", "source_layers", ",", "RepurposerTestUtils", ".", "ERROR_INCORRECT_INPUT", ")", "\n", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "transfer_layer_name", "=", "valid_transfer_layer_name", ",", "\n", "target_class_count", "=", "2", ")", "\n", "\n", "# Get target symbol", "\n", "target_symbol", "=", "repurposer", ".", "_get_target_symbol", "(", "self", ".", "source_layers", ")", "\n", "\n", "# Validate if target symbol is transferred at the given 'transfer layer'", "\n", "self", ".", "assertTrue", "(", "target_symbol", ".", "name", "==", "valid_transfer_layer_name", ",", "\n", "'Target symbol is transferred at incorrect layer:{} instead of:{}'", ".", "format", "\n", "(", "target_symbol", ".", "name", ",", "valid_transfer_layer_name", ")", ")", "\n", "\n", "# Valid if target symbol contains all layer outputs up to the transfer layer", "\n", "source_symbol_outputs", "=", "self", ".", "mxnet_model", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "assertTrue", "(", "source_symbol_outputs", "==", "[", "'data'", ",", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'relu1_output'", ",", "\n", "'fc2_weight'", ",", "'fc2_bias'", ",", "'fc2_output'", ",", "'softmax_label'", ",", "\n", "'softmax_output'", "]", ",", "\n", "RepurposerTestUtils", ".", "ERROR_INCORRECT_INPUT", ")", "\n", "target_symbol_outputs", "=", "target_symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "\n", "self", ".", "assertTrue", "(", "target_symbol_outputs", "==", "[", "'data'", ",", "'fc1_weight'", ",", "'fc1_bias'", ",", "'fc1_output'", ",", "'relu1_output'", "]", ",", "\n", "'Target symbol has incorrect layer outputs'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.test_get_params": [[60, 76], ["test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.repurposer_class", "test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "test_get_params", "(", "self", ")", ":", "\n", "        ", "repurposer", "=", "self", ".", "repurposer_class", "(", "self", ".", "mxnet_model", ",", "'fc1'", ",", "4", ")", "\n", "\n", "params", "=", "repurposer", ".", "get_params", "(", ")", "\n", "expected_params", "=", "{", "\n", "'context_function'", ":", "'cpu'", ",", "\n", "'num_devices'", ":", "1", ",", "\n", "'optimizer'", ":", "'sgd'", ",", "\n", "'optimizer_params'", ":", "{", "'learning_rate'", ":", "0.001", "}", ",", "\n", "'batch_size'", ":", "64", ",", "\n", "'num_epochs'", ":", "5", ",", "\n", "'transfer_layer_name'", ":", "'fc1'", ",", "\n", "'target_class_count'", ":", "4", "\n", "}", "\n", "\n", "assert", "params", "==", "expected_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase._get_repurposer": [[77, 80], ["test_neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposerTestCase.repurposer_class"], "methods", ["None"], ["", "def", "_get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "return", "self", ".", "repurposer_class", "(", "source_model", ",", "transfer_layer_name", "=", "'fullyconnected0'", ",", "target_class_count", "=", "4", ",", "\n", "num_epochs", "=", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_utils.UtilsTestCase.setUp": [[22, 24], ["None"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_utils.UtilsTestCase.test_serialize_ctx_fn": [[25, 34], ["xfer.utils.serialize_ctx_fn", "xfer.utils.serialize_ctx_fn", "test_utils.UtilsTestCase.assertRaises", "xfer.utils.serialize_ctx_fn"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn"], ["", "def", "test_serialize_ctx_fn", "(", "self", ")", ":", "\n", "        ", "op", "=", "utils", ".", "serialize_ctx_fn", "(", "mx", ".", "cpu", ")", "\n", "assert", "op", "==", "'cpu'", "\n", "\n", "op", "=", "utils", ".", "serialize_ctx_fn", "(", "mx", ".", "gpu", ")", "\n", "assert", "op", "==", "'gpu'", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "utils", ".", "serialize_ctx_fn", "(", "'cpu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_utils.UtilsTestCase.test_deserialize_ctx_fn": [[35, 49], ["xfer.utils.deserialize_ctx_fn", "xfer.utils.deserialize_ctx_fn", "test_utils.UtilsTestCase.assertRaises", "xfer.utils.deserialize_ctx_fn", "test_utils.UtilsTestCase.assertRaises", "xfer.utils.deserialize_ctx_fn"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn"], ["", "", "def", "test_deserialize_ctx_fn", "(", "self", ")", ":", "\n", "        ", "op", "=", "utils", ".", "deserialize_ctx_fn", "(", "'cpu'", ")", "\n", "assert", "op", "==", "mx", ".", "cpu", "\n", "assert", "op", "==", "mx", ".", "context", ".", "cpu", "\n", "\n", "op", "=", "utils", ".", "deserialize_ctx_fn", "(", "'gpu'", ")", "\n", "assert", "op", "==", "mx", ".", "gpu", "\n", "assert", "op", "==", "mx", ".", "context", ".", "gpu", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "utils", ".", "deserialize_ctx_fn", "(", "mx", ".", "cpu", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "utils", ".", "deserialize_ctx_fn", "(", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_utils.UtilsTestCase.test_assert_repurposer_file_exists": [[50, 56], ["test_utils.UtilsTestCase.assertRaises", "xfer.utils._assert_repurposer_file_exists", "test_utils.UtilsTestCase.assertRaises", "xfer.utils._assert_repurposer_file_exists"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils._assert_repurposer_file_exists", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils._assert_repurposer_file_exists"], ["", "", "def", "test_assert_repurposer_file_exists", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "NameError", ")", ":", "\n", "            ", "utils", ".", "_assert_repurposer_file_exists", "(", "[", "'madeupfile'", "]", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "NameError", ")", ":", "\n", "            ", "utils", ".", "_assert_repurposer_file_exists", "(", "[", "3", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.setUp": [[27, 32], ["repurposer_test_utils.RepurposerTestUtils.create_mxnet_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mxnet_module"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "repurposer_class", "=", "NeuralNetworkRepurposer", "\n", "self", ".", "mxnet_model", "=", "RepurposerTestUtils", ".", "create_mxnet_module", "(", ")", "\n", "self", ".", "dropout_model_path_prefix", "=", "'tests/data/test_model_with_dropout'", "\n", "self", ".", "source_layers", "=", "RepurposerTestUtils", ".", "ALL_LAYERS", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_validate_before_repurpose": [[33, 46], ["xfer.NeuralNetworkRepurposer", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertRaisesRegex", "xfer.NeuralNetworkRepurposer", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertRaisesRegex", "xfer.NeuralNetworkRepurposer", "xfer.NeuralNetworkRepurposer._validate_before_repurpose"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_repurpose"], ["", "def", "test_validate_before_repurpose", "(", "self", ")", ":", "\n", "# Test invalid inputs", "\n", "        ", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "None", ")", "\n", "self", ".", "assertRaisesRegex", "(", "TypeError", ",", "\"Cannot repurpose because source_model is not an `mxnet.mod.Module` object\"", ",", "\n", "neural_network_repurposer", ".", "_validate_before_repurpose", ")", "\n", "\n", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "''", ")", "\n", "self", ".", "assertRaisesRegex", "(", "TypeError", ",", "\"Cannot repurpose because source_model is not an `mxnet.mod.Module` object\"", ",", "\n", "neural_network_repurposer", ".", "_validate_before_repurpose", ")", "\n", "\n", "# Test valid input", "\n", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "self", ".", "mxnet_model", ")", "\n", "neural_network_repurposer", ".", "_validate_before_repurpose", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_validate_before_predict": [[47, 68], ["xfer.NeuralNetworkRepurposer", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertRaisesRegex", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertRaisesRegex", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertRaisesRegex", "mxnet.module.Module.load", "xfer.NeuralNetworkRepurposer._validate_before_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict"], ["", "def", "test_validate_before_predict", "(", "self", ")", ":", "\n", "# Test invalid inputs", "\n", "        ", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "self", ".", "mxnet_model", ")", "\n", "\n", "# Target model is neither created through repurpose nor explicitly assigned", "\n", "self", ".", "assertRaisesRegex", "(", "TypeError", ",", "\"Cannot predict because target_model is not an `mxnet.mod.Module` object\"", ",", "\n", "neural_network_repurposer", ".", "_validate_before_predict", ")", "\n", "\n", "neural_network_repurposer", ".", "target_model", "=", "{", "}", "\n", "self", ".", "assertRaisesRegex", "(", "TypeError", ",", "\"Cannot predict because target_model is not an `mxnet.mod.Module` object\"", ",", "\n", "neural_network_repurposer", ".", "_validate_before_predict", ")", "\n", "\n", "# Assert validate raises error for mxnet module that is not trained yet", "\n", "neural_network_repurposer", ".", "target_model", "=", "self", ".", "mxnet_model", "\n", "self", ".", "assertRaisesRegex", "(", "ValueError", ",", "\n", "\"target_model params aren't initialized. Ensure model is trained before calling predict\"", ",", "\n", "neural_network_repurposer", ".", "_validate_before_predict", ")", "\n", "\n", "# Test valid input", "\n", "neural_network_repurposer", ".", "target_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "prefix", "=", "self", ".", "dropout_model_path_prefix", ",", "epoch", "=", "0", ")", "\n", "neural_network_repurposer", ".", "_validate_before_predict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_predict_label": [[69, 72], ["unittest.mock.patch.object", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "NeuralNetworkRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "def", "test_predict_label", "(", "self", ",", "mock_validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_validate_method", ",", "test_predict_probability", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_predict_probability": [[73, 76], ["unittest.mock.patch.object", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "NeuralNetworkRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "def", "test_predict_probability", "(", "self", ",", "mock_validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_validate_method", ",", "test_predict_probability", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict": [[77, 98], ["xfer.NeuralNetworkRepurposer", "mxnet.module.Module.load", "repurposer_test_utils.RepurposerTestUtils.create_mnist_test_iterator", "mock_validate_method.reset_mock", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertTrue", "numpy.mean", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertTrue", "numpy.argmax", "xfer.NeuralNetworkRepurposer.predict_label", "numpy.isclose", "xfer.NeuralNetworkRepurposer.predict_probability", "repurposer_test_utils.RepurposerTestUtils.get_labels"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.create_mnist_test_iterator", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_probability", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_labels"], ["", "def", "_test_predict", "(", "self", ",", "mock_validate_method", ",", "test_predict_probability", ")", ":", "\n", "        ", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "None", ")", "\n", "neural_network_repurposer", ".", "target_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "\n", "prefix", "=", "RepurposerTestUtils", ".", "MNIST_MODEL_PATH_PREFIX", ",", "epoch", "=", "10", ",", "label_names", "=", "None", ")", "\n", "test_iterator", "=", "RepurposerTestUtils", ".", "create_mnist_test_iterator", "(", ")", "\n", "mock_validate_method", ".", "reset_mock", "(", ")", "\n", "\n", "if", "test_predict_probability", ":", "\n", "            ", "labels", "=", "np", ".", "argmax", "(", "neural_network_repurposer", ".", "predict_probability", "(", "test_iterator", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "labels", "=", "neural_network_repurposer", ".", "predict_label", "(", "test_iterator", ")", "\n", "\n", "# Check if predict called validate", "\n", "", "self", ".", "assertTrue", "(", "mock_validate_method", ".", "call_count", "==", "1", ",", "\n", "\"Predict expected to called {} once. Found {} calls\"", ".", "\n", "format", "(", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ",", "mock_validate_method", ".", "call_count", ")", ")", "\n", "\n", "expected_accuracy", "=", "0.96985", "\n", "accuracy", "=", "np", ".", "mean", "(", "labels", "==", "RepurposerTestUtils", ".", "get_labels", "(", "test_iterator", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isclose", "(", "accuracy", ",", "expected_accuracy", ",", "rtol", "=", "1e-3", ")", ",", "\n", "\"Prediction accuracy is incorrect. Expected:{}. Got:{}\"", ".", "format", "(", "expected_accuracy", ",", "accuracy", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_repurpose_calls_validate": [[99, 110], ["unittest.mock.patch.object", "unittest.mock.patch.object", "xfer.NeuralNetworkRepurposer", "mxnet.module.Module.load", "mock_validate_method.reset_mock", "xfer.NeuralNetworkRepurposer.repurpose", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertTrue", "unittest.mock.Mock"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose"], ["", "@", "patch", ".", "object", "(", "NeuralNetworkRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_REPURPOSE_METHOD_NAME", ")", "\n", "@", "patch", ".", "object", "(", "NeuralNetworkRepurposer", ",", "'_create_target_module'", ")", "\n", "def", "test_repurpose_calls_validate", "(", "self", ",", "mock_create_target_module", ",", "mock_validate_method", ")", ":", "\n", "        ", "neural_network_repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "self", ".", "mxnet_model", ")", "\n", "neural_network_repurposer", ".", "target_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "prefix", "=", "self", ".", "dropout_model_path_prefix", ",", "epoch", "=", "0", ")", "\n", "\n", "mock_validate_method", ".", "reset_mock", "(", ")", "\n", "neural_network_repurposer", ".", "repurpose", "(", "Mock", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "mock_validate_method", ".", "call_count", "==", "1", ",", "\n", "\"Repurpose expected to called {} once. Found {} calls\"", ".", "\n", "format", "(", "RepurposerTestUtils", ".", "VALIDATE_REPURPOSE_METHOD_NAME", ",", "mock_validate_method", ".", "call_count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_prediction_consistency": [[111, 128], ["repurposer_test_utils.RepurposerTestUtils.get_image_iterator", "mxnet.module.Module.load", "xfer.NeuralNetworkRepurposer", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._predict_and_compare_results", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._predict_and_compare_results"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_image_iterator", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._predict_and_compare_results", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._predict_and_compare_results"], ["", "def", "test_prediction_consistency", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test if predict method returns consistent predictions using the same model and test data \"\"\"", "\n", "if", "self", ".", "repurposer_class", "!=", "NeuralNetworkRepurposer", ":", "\n", "            ", "return", "\n", "# Create test data iterator to run predictions on", "\n", "", "test_iterator", "=", "RepurposerTestUtils", ".", "get_image_iterator", "(", ")", "\n", "# Load a pre-trained model to predict. The model has a dropout layer used for training.", "\n", "# This test is to ensure that dropout doesn't happen during prediction.", "\n", "target_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "prefix", "=", "self", ".", "dropout_model_path_prefix", ",", "epoch", "=", "0", ",", "label_names", "=", "None", ")", "\n", "\n", "# Create repurposer and set the target model loaded from file", "\n", "repurposer", "=", "NeuralNetworkRepurposer", "(", "source_model", "=", "None", ")", "\n", "repurposer", ".", "target_model", "=", "target_model", "\n", "\n", "# Ensure prediction results are consistent", "\n", "self", ".", "_predict_and_compare_results", "(", "repurposer", ",", "test_iterator", ",", "test_predict_probability", "=", "True", ")", "\n", "self", ".", "_predict_and_compare_results", "(", "repurposer", ",", "test_iterator", ",", "test_predict_probability", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._predict_and_compare_results": [[129, 139], ["predict_function", "range", "predict_function", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.assertTrue", "numpy.array_equal"], "methods", ["None"], ["", "def", "_predict_and_compare_results", "(", "self", ",", "repurposer", ",", "test_iterator", ",", "test_predict_probability", ")", ":", "\n", "# Identify predict method to test", "\n", "        ", "predict_function", "=", "repurposer", ".", "predict_probability", "if", "test_predict_probability", "else", "repurposer", ".", "predict_label", "\n", "\n", "# Call predict method multiple times and check if the predictions are consistent", "\n", "current_prediction", "=", "predict_function", "(", "test_iterator", "=", "test_iterator", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "10", ")", ":", "\n", "            ", "previous_prediction", "=", "current_prediction", "\n", "current_prediction", "=", "predict_function", "(", "test_iterator", "=", "test_iterator", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "previous_prediction", ",", "current_prediction", ")", ",", "'Predictions are inconsistent'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_serialisation": [[140, 160], ["mxnet.image.ImageIter", "mxnet.image.ImageIter", "numpy.loadtxt", "numpy.loadtxt().astype", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model", "numpy.loadtxt"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model"], ["", "", "def", "test_serialisation", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "repurposer_class", "==", "NeuralNetworkRepurposer", ":", "\n", "            ", "return", "\n", "", "self", ".", "data_name", "=", "'data'", "\n", "self", ".", "imglist", "=", "[", "[", "0", ",", "'accordion/image_0001.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0002.jpg'", "]", ",", "[", "1", ",", "'ant/image_0001.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0002.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0001.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0002.jpg'", "]", "]", "\n", "self", ".", "train_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmaxoutput1_label'", ",", "data_name", "=", "self", ".", "data_name", ")", "\n", "self", ".", "imglist", "=", "[", "[", "0", ",", "'accordion/image_0003.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0004.jpg'", "]", ",", "[", "1", ",", "'ant/image_0003.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0004.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0003.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0004.jpg'", "]", "]", "\n", "self", ".", "test_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "2", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "self", ".", "imglist", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmaxoutput1_label'", ",", "data_name", "=", "self", ".", "data_name", ")", "\n", "\n", "self", ".", "_test_data_dir", "=", "'tests/data/meta_model_repurposer_data/'", "\n", "self", ".", "labels", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'_labels.out'", ")", "\n", "self", ".", "_test_indices", "=", "np", ".", "loadtxt", "(", "self", ".", "_test_data_dir", "+", "'_test_indices.out'", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "test_labels", "=", "self", ".", "labels", "[", "self", ".", "_test_indices", "]", "\n", "\n", "self", ".", "_test_save_load_repurposed_model", "(", "save_source", "=", "True", ")", "\n", "self", ".", "_test_save_load_repurposed_model", "(", "save_source", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_save_load_repurposed_model": [[161, 186], ["repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "mxnet.module.Module.load", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._get_repurposer", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.repurpose", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.predict_label", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.save_repurposer", "os.path.isfile", "xfer.load.predict_label", "numpy.mean", "numpy.mean", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._assert_attributes_equal", "repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "os.path.isfile", "xfer.load", "xfer.load", "type", "type", "abs", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.get_params", "xfer.load.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._get_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._assert_attributes_equal", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "_test_save_load_repurposed_model", "(", "self", ",", "save_source", ")", ":", "\n", "        ", "file_path", "=", "'test_serialisation'", "\n", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "file_path", ")", "\n", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ",", "\n", "data_names", "=", "(", "'data'", ",", ")", ")", "\n", "repurposer", "=", "self", ".", "_get_repurposer", "(", "source_model", ")", "\n", "repurposer", ".", "repurpose", "(", "self", ".", "train_iter", ")", "\n", "results", "=", "repurposer", ".", "predict_label", "(", "test_iterator", "=", "self", ".", "test_iter", ")", "\n", "assert", "not", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "repurposer", ".", "save_repurposer", "(", "model_name", "=", "file_path", ",", "save_source_model", "=", "save_source", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "if", "save_source", ":", "\n", "            ", "loaded_repurposer", "=", "load", "(", "file_path", ")", "\n", "", "else", ":", "\n", "            ", "loaded_repurposer", "=", "load", "(", "file_path", ",", "source_model", "=", "repurposer", ".", "source_model", ")", "\n", "", "results_loaded", "=", "loaded_repurposer", ".", "predict_label", "(", "test_iterator", "=", "self", ".", "test_iter", ")", "\n", "\n", "assert", "type", "(", "repurposer", ")", "==", "type", "(", "loaded_repurposer", ")", "\n", "accuracy1", "=", "np", ".", "mean", "(", "results", "==", "self", ".", "test_labels", ")", "\n", "accuracy2", "=", "np", ".", "mean", "(", "results_loaded", "==", "self", ".", "test_labels", ")", "\n", "assert", "abs", "(", "accuracy1", "-", "accuracy2", ")", "<", "0.05", "\n", "\n", "assert", "repurposer", ".", "get_params", "(", ")", "==", "loaded_repurposer", ".", "get_params", "(", ")", "\n", "self", ".", "_assert_attributes_equal", "(", "repurposer", ",", "loaded_repurposer", ")", "\n", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._get_repurposer": [[187, 189], ["None"], "methods", ["None"], ["", "def", "_get_repurposer", "(", "self", ",", "source_model", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._assert_attributes_equal": [[190, 192], ["repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal"], ["", "def", "_assert_attributes_equal", "(", "self", ",", "repurposer1", ",", "repurposer2", ")", ":", "\n", "        ", "RepurposerTestUtils", ".", "_assert_common_attributes_equal", "(", "repurposer1", ",", "repurposer2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.test_iterator_reset": [[193, 222], ["unittest.mock.patch", "mxnet.image.ImageIter", "mxnet.module.Module.load", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._get_repurposer", "range", "test_neural_network_repurposer.NeuralNetworkRepurposerTestCase.repurpose", "int", "mxnet.image.ImageIter.next", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._get_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose"], ["", "@", "patch", "(", "'mxnet.mod.Module.fit'", ")", "\n", "def", "test_iterator_reset", "(", "self", ",", "mock_func", ")", ":", "\n", "        ", "if", "self", ".", "repurposer_class", "==", "NeuralNetworkRepurposer", ":", "\n", "            ", "return", "\n", "", "data_name", "=", "'data'", "\n", "batch_size", "=", "2", "\n", "imglist", "=", "[", "[", "0", ",", "'accordion/image_0001.jpg'", "]", ",", "[", "0", ",", "'accordion/image_0002.jpg'", "]", ",", "[", "1", ",", "'ant/image_0001.jpg'", "]", ",", "\n", "[", "1", ",", "'ant/image_0002.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0001.jpg'", "]", ",", "[", "2", ",", "'anchor/image_0002.jpg'", "]", "]", "\n", "train_iter", "=", "mx", ".", "image", ".", "ImageIter", "(", "batch_size", ",", "(", "3", ",", "224", ",", "224", ")", ",", "imglist", "=", "imglist", ",", "path_root", "=", "'tests/data/test_images'", ",", "\n", "label_name", "=", "'softmaxoutput1_label'", ",", "data_name", "=", "data_name", ")", "\n", "\n", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "'tests/data/testnetv1'", ",", "0", ",", "label_names", "=", "[", "'softmaxoutput1_label'", "]", ",", "\n", "data_names", "=", "(", "'data'", ",", ")", ")", "\n", "\n", "repurposer", "=", "self", ".", "_get_repurposer", "(", "source_model", ")", "\n", "\n", "# The iterator cursor should start at 0 and be 6", "\n", "assert", "train_iter", ".", "cur", "==", "0", "\n", "# iterate through every batch of iterator", "\n", "for", "_", "in", "range", "(", "int", "(", "len", "(", "imglist", ")", "/", "batch_size", ")", ")", ":", "\n", "            ", "train_iter", ".", "next", "(", ")", "\n", "", "assert", "train_iter", ".", "cur", "==", "6", "\n", "\n", "repurposer", ".", "repurpose", "(", "train_iter", ")", "\n", "\n", "# This is the iterator that Module.fit() is called with", "\n", "fit_iter", "=", "mock_func", ".", "call_args_list", "[", "0", "]", "[", "0", "]", "[", "0", "]", "\n", "\n", "assert", "fit_iter", ".", "cur", "==", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp": [[26, 35], ["super().setUp", "numpy.arange", "test_gp_repurposer.GpRepurposerTestCase.train_features.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.setUp"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "self", ".", "repurposer_class", "=", "GpRepurposer", "\n", "self", ".", "expected_accuracy", "=", "0.45714285714285713", "\n", "self", ".", "expected_accuracy_from_features", "=", "0.7", "\n", "self", ".", "train_feature_indices", "=", "np", ".", "arange", "(", "0", ",", "self", ".", "train_features", ".", "shape", "[", "1", "]", ")", "\n", "self", ".", "feature_mean", "=", "self", ".", "train_features", ".", "mean", "(", "axis", "=", "0", ")", "\n", "self", ".", "num_data_points_to_predict", "=", "10", "\n", "self", ".", "num_data_points_to_train", "=", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_train_model_from_features": [[36, 41], ["test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features"], ["", "def", "test_train_model_from_features", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_train_model_from_features", "(", "sparse_gp", "=", "True", ",", "multiple_kernels", "=", "True", ")", "\n", "self", ".", "_test_train_model_from_features", "(", "sparse_gp", "=", "True", ",", "multiple_kernels", "=", "False", ")", "\n", "self", ".", "_test_train_model_from_features", "(", "sparse_gp", "=", "False", ",", "multiple_kernels", "=", "True", ")", "\n", "self", ".", "_test_train_model_from_features", "(", "sparse_gp", "=", "False", ",", "multiple_kernels", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_train_model_from_features": [[42, 63], ["xfer.GpRepurposer", "numpy.array_equal", "test_gp_repurposer.GpRepurposerTestCase._validate_trained_gp_model", "test_gp_repurposer.GpRepurposerTestCase.train_features.mean", "xfer.GpRepurposer._train_model_from_features", "xfer.GpRepurposer._train_model_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_gp_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features"], ["", "def", "_test_train_model_from_features", "(", "self", ",", "sparse_gp", ",", "multiple_kernels", ")", ":", "\n", "        ", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "\n", "num_inducing", "=", "self", ".", "num_data_points_to_train", "\n", "gp_repurposer", ".", "NUM_INDUCING_SPARSE_GP", "=", "num_inducing", "\n", "\n", "if", "not", "sparse_gp", ":", "# Select a small data set to apply normal GP classification", "\n", "            ", "self", ".", "train_features", "=", "self", ".", "train_features", "[", ":", "num_inducing", "]", "\n", "self", ".", "train_labels", "=", "self", ".", "train_labels", "[", ":", "num_inducing", "]", "\n", "self", ".", "feature_mean", "=", "self", ".", "train_features", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "", "if", "multiple_kernels", ":", "\n", "            ", "trained_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "[", ":", "4", "]", ",", "\n", "'l2'", ":", "self", ".", "train_feature_indices", "[", "4", ":", "]", "}", ")", "\n", "", "else", ":", "\n", "            ", "trained_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "self", ".", "train_labels", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "}", ")", "\n", "\n", "", "assert", "np", ".", "array_equal", "(", "gp_repurposer", ".", "feature_mean", ",", "self", ".", "feature_mean", ")", "\n", "self", ".", "_validate_trained_gp_model", "(", "trained_model", ",", "sparse_gp", ",", "num_inducing", ",", "multiple_kernels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_gp_model": [[64, 86], ["enumerate", "all", "all", "numpy.array_equal", "numpy.loadtxt().reshape", "numpy.array_equal", "numpy.array_equal", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "numpy.loadtxt"], "methods", ["None"], ["", "def", "_validate_trained_gp_model", "(", "self", ",", "trained_model", ",", "sparse_gp", ",", "num_inducing", ",", "multiple_kernels", ")", ":", "\n", "# Validate type of model", "\n", "        ", "if", "sparse_gp", ":", "\n", "            ", "assert", "all", "(", "isinstance", "(", "model", ",", "GPy", ".", "models", ".", "SparseGPClassification", ")", "for", "model", "in", "trained_model", ")", "\n", "", "else", ":", "\n", "            ", "assert", "all", "(", "isinstance", "(", "model", ",", "GPy", ".", "models", ".", "GPClassification", ")", "for", "model", "in", "trained_model", ")", "\n", "\n", "", "for", "index", ",", "model", "in", "enumerate", "(", "trained_model", ")", ":", "\n", "            ", "if", "multiple_kernels", ":", "\n", "                ", "assert", "isinstance", "(", "model", ".", "kern", ",", "GPy", ".", "kern", ".", "Add", ")", "\n", "assert", "isinstance", "(", "model", ".", "kern", ".", "l1", ",", "GPy", ".", "kern", ".", "RBF", ")", "\n", "assert", "isinstance", "(", "model", ".", "kern", ".", "l2", ",", "GPy", ".", "kern", ".", "RBF", ")", "\n", "", "else", ":", "\n", "                ", "assert", "isinstance", "(", "model", ".", "kern", ",", "GPy", ".", "kern", ".", "RBF", ")", "\n", "", "assert", "np", ".", "array_equal", "(", "model", ".", "kern", ".", "active_dims", ",", "self", ".", "train_feature_indices", ")", "\n", "expected_labels", "=", "np", ".", "loadtxt", "(", "'{}GPmodel.{}.Y.out'", ".", "format", "(", "self", ".", "_test_data_dir", ",", "index", ")", ")", ".", "reshape", "(", "103", ",", "1", ")", "\n", "expected_features", "=", "self", ".", "train_features", "-", "self", ".", "feature_mean", "\n", "if", "not", "sparse_gp", ":", "# A smaller data set was selected to apply normal GP classification", "\n", "                ", "expected_labels", "=", "expected_labels", "[", ":", "num_inducing", "]", "\n", "expected_features", "=", "expected_features", "[", ":", "num_inducing", "]", "\n", "", "assert", "np", ".", "array_equal", "(", "model", ".", "Y", ",", "expected_labels", ")", "\n", "assert", "np", ".", "array_equal", "(", "model", ".", "X", ",", "expected_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_predict_label_from_features": [[87, 98], ["xfer.GpRepurposer", "xfer.GpRepurposer._train_model_from_features", "xfer.GpRepurposer._predict_label_from_features", "test_gp_repurposer.GpRepurposerTestCase._validate_prediction_results"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results"], ["", "", "def", "test_predict_label_from_features", "(", "self", ")", ":", "\n", "        ", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "apply_l2_norm", "=", "True", ")", "\n", "gp_repurposer", ".", "target_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "\n", "self", ".", "train_features", "[", ":", "self", ".", "num_data_points_to_train", "]", ",", "\n", "self", ".", "train_labels", "[", ":", "self", ".", "num_data_points_to_train", "]", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "}", ")", "\n", "predicted_labels", "=", "gp_repurposer", ".", "_predict_label_from_features", "(", "self", ".", "test_features", "\n", "[", ":", "self", ".", "num_data_points_to_predict", "]", ")", "\n", "self", ".", "_validate_prediction_results", "(", "predicted_labels", ",", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy_from_features", ",", "\n", "num_predictions", "=", "self", ".", "num_data_points_to_predict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_predict_probability_from_features": [[99, 110], ["xfer.GpRepurposer", "xfer.GpRepurposer._train_model_from_features", "xfer.GpRepurposer._predict_probability_from_features", "test_gp_repurposer.GpRepurposerTestCase._validate_prediction_results"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_bnn_repurposer.BnnRepurposerTestCase._validate_prediction_results"], ["", "def", "test_predict_probability_from_features", "(", "self", ")", ":", "\n", "        ", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "apply_l2_norm", "=", "True", ")", "\n", "gp_repurposer", ".", "target_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "\n", "self", ".", "train_features", "[", ":", "self", ".", "num_data_points_to_train", "]", ",", "\n", "self", ".", "train_labels", "[", ":", "self", ".", "num_data_points_to_train", "]", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "}", ")", "\n", "predictions", "=", "gp_repurposer", ".", "_predict_probability_from_features", "(", "self", ".", "test_features", "\n", "[", ":", "self", ".", "num_data_points_to_predict", "]", ")", "\n", "self", ".", "_validate_prediction_results", "(", "predictions", ",", "test_predict_probability", "=", "True", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy_from_features", ",", "\n", "num_predictions", "=", "self", ".", "num_data_points_to_predict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_repurpose": [[111, 119], ["unittest.mock.patch", "repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "xfer.GpRepurposer", "test_gp_repurposer.GpRepurposerTestCase._run_common_repurposer_tests"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils.get_mock_model_handler_object", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._run_common_repurposer_tests"], ["", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose", "(", "self", ",", "mock_model_handler", ")", ":", "\n", "# Patch model_handler and then create gp_repurposer", "\n", "        ", "mock_model_handler", ".", "return_value", "=", "RepurposerTestUtils", ".", "get_mock_model_handler_object", "(", ")", "\n", "mock_model_handler", ".", "return_value", ".", "get_layer_output", ".", "return_value", "=", "{", "'l1'", ":", "self", ".", "train_features", "}", ",", "self", ".", "train_labels", "\n", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "gp_repurposer", ".", "NUM_INDUCING_SPARSE_GP", "=", "5", "# To speed-up unit test running time", "\n", "self", ".", "_run_common_repurposer_tests", "(", "gp_repurposer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_model": [[120, 122], ["test_gp_repurposer.GpRepurposerTestCase._validate_trained_gp_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._validate_trained_gp_model"], ["", "def", "_validate_trained_model", "(", "self", ",", "target_model", ")", ":", "\n", "        ", "self", ".", "_validate_trained_gp_model", "(", "target_model", ",", "sparse_gp", "=", "True", ",", "num_inducing", "=", "100", ",", "multiple_kernels", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_repurpose_calls_validate": [[123, 127], ["unittest.mock.patch.object", "unittest.mock.patch", "test_gp_repurposer.GpRepurposerTestCase._test_repurpose_calls_validate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_meta_model_repurposer.MetaModelRepurposerTestCase._test_repurpose_calls_validate"], ["", "@", "patch", ".", "object", "(", "GpRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_REPURPOSE_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_repurpose_calls_validate", "(", "self", ",", "mock_model_handler", ",", "mock_validate_method", ")", ":", "\n", "        ", "self", ".", "_test_repurpose_calls_validate", "(", "mock_model_handler", ",", "mock_validate_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_predict_label": [[128, 133], ["unittest.mock.patch.object", "unittest.mock.patch", "test_gp_repurposer.GpRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "GpRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_label", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "False", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_predict_probability": [[134, 139], ["unittest.mock.patch.object", "unittest.mock.patch", "test_gp_repurposer.GpRepurposerTestCase._test_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_neural_network_repurposer.NeuralNetworkRepurposerTestCase._test_predict"], ["", "@", "patch", ".", "object", "(", "GpRepurposer", ",", "RepurposerTestUtils", ".", "VALIDATE_PREDICT_METHOD_NAME", ")", "\n", "@", "patch", "(", "RepurposerTestUtils", ".", "META_MODEL_REPURPOSER_MODEL_HANDLER_CLASS", ")", "\n", "def", "test_predict_probability", "(", "self", ",", "mock_model_handler", ",", "validate_method", ")", ":", "\n", "        ", "self", ".", "_test_predict", "(", "mock_model_handler", ",", "validate_method", ",", "test_predict_probability", "=", "True", ",", "\n", "expected_accuracy", "=", "self", ".", "expected_accuracy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_serialisation": [[140, 145], ["test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation"], ["", "def", "test_serialisation", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_gp_serialisation", "(", "sparse_gp", "=", "True", ",", "multiple_kernels", "=", "False", ")", "\n", "self", ".", "_test_gp_serialisation", "(", "sparse_gp", "=", "True", ",", "multiple_kernels", "=", "True", ")", "\n", "self", ".", "_test_gp_serialisation", "(", "sparse_gp", "=", "False", ",", "multiple_kernels", "=", "True", ")", "\n", "self", ".", "_test_gp_serialisation", "(", "sparse_gp", "=", "False", ",", "multiple_kernels", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._test_gp_serialisation": [[146, 194], ["xfer.GpRepurposer", "test_gp_repurposer.GpRepurposerTestCase._save_and_load_repurposer", "test_gp_repurposer.GpRepurposerTestCase._compare_gp_repurposers", "xfer.GpRepurposer._predict_probability_from_features", "test_gp_repurposer.GpRepurposerTestCase._predict_probability_from_features", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "enumerate", "numpy.argmax", "numpy.mean", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "test_gp_repurposer.GpRepurposerTestCase.train_features.mean", "xfer.GpRepurposer._train_model_from_features", "xfer.GpRepurposer._train_model_from_features", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._save_and_load_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._compare_gp_repurposers", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features"], ["", "def", "_test_gp_serialisation", "(", "self", ",", "sparse_gp", ",", "multiple_kernels", ")", ":", "\n", "        ", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ",", "apply_l2_norm", "=", "True", ")", "\n", "num_inducing", "=", "2", "\n", "gp_repurposer", ".", "NUM_INDUCING_SPARSE_GP", "=", "num_inducing", "\n", "\n", "if", "not", "sparse_gp", ":", "# Select a small data set to apply normal GP classification", "\n", "            ", "self", ".", "train_features", "=", "self", ".", "train_features", "[", ":", "num_inducing", "]", "\n", "self", ".", "train_labels", "=", "self", ".", "train_labels", "[", ":", "num_inducing", "]", "\n", "self", ".", "feature_mean", "=", "self", ".", "train_features", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "", "if", "multiple_kernels", ":", "\n", "            ", "gp_repurposer", ".", "target_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "\n", "self", ".", "train_labels", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "[", ":", "4", "]", ",", "\n", "'l2'", ":", "self", ".", "train_feature_indices", "[", "\n", "4", ":", "]", "}", ")", "\n", "", "else", ":", "\n", "            ", "gp_repurposer", ".", "target_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "self", ".", "train_features", ",", "\n", "self", ".", "train_labels", ",", "\n", "{", "'l1'", ":", "self", ".", "train_feature_indices", "}", ")", "\n", "\n", "# Save and load repurposer to test serialization", "\n", "", "loaded_repurposer", "=", "self", ".", "_save_and_load_repurposer", "(", "gp_repurposer", ")", "\n", "\n", "# Validate repurposer properties", "\n", "self", ".", "_compare_gp_repurposers", "(", "gp_repurposer", ",", "loaded_repurposer", ")", "\n", "\n", "# Get prediction results using both repurposers", "\n", "predictions_before", "=", "gp_repurposer", ".", "_predict_probability_from_features", "(", "self", ".", "test_features", "\n", "[", ":", "self", ".", "num_data_points_to_predict", "]", ")", "\n", "predictions_after", "=", "loaded_repurposer", ".", "_predict_probability_from_features", "(", "self", ".", "test_features", "\n", "[", ":", "self", ".", "num_data_points_to_predict", "]", ")", "\n", "\n", "# Compare probabilities predicted per test instance", "\n", "self", ".", "assertTrue", "(", "predictions_before", ".", "shape", "==", "predictions_after", ".", "shape", ",", "\n", "\"Prediction shape is incorrect. Expected: {} Actual: {}\"", "\n", ".", "format", "(", "predictions_before", ".", "shape", ",", "predictions_after", ".", "shape", ")", ")", "\n", "\n", "for", "sample_id", ",", "prediction", "in", "enumerate", "(", "predictions_before", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "prediction", ",", "predictions_after", "[", "sample_id", "]", ")", ",", "\n", "\"Incorrect prediction for sample id: {}. Expected: {} Actual: {}\"", "\n", ".", "format", "(", "sample_id", ",", "predictions_before", "[", "sample_id", "]", ",", "predictions_after", "[", "sample_id", "]", ")", ")", "\n", "\n", "# Validate if accuracy is above expected threshold", "\n", "", "predicted_labels", "=", "np", ".", "argmax", "(", "predictions_after", ",", "axis", "=", "1", ")", "\n", "accuracy", "=", "np", ".", "mean", "(", "predicted_labels", "==", "self", ".", "test_labels", "[", ":", "self", ".", "num_data_points_to_predict", "]", ")", "\n", "expected_accuracy", "=", "0.3", "\n", "self", ".", "assertTrue", "(", "accuracy", ">=", "expected_accuracy", ",", "\"Accuracy {} less than {}\"", ".", "format", "(", "accuracy", ",", "expected_accuracy", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._save_and_load_repurposer": [[195, 204], ["repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "gp_repurposer.save_repurposer", "os.path.isfile", "xfer.load", "repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "os.path.isfile"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._remove_files_with_prefix"], ["", "def", "_save_and_load_repurposer", "(", "self", ",", "gp_repurposer", ")", ":", "\n", "        ", "file_path", "=", "'test_serialisation'", "\n", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "file_path", ")", "\n", "assert", "not", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "gp_repurposer", ".", "save_repurposer", "(", "model_name", "=", "file_path", ",", "save_source_model", "=", "False", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "file_path", "+", "'.json'", ")", "\n", "loaded_repurposer", "=", "load", "(", "file_path", ",", "source_model", "=", "gp_repurposer", ".", "source_model", ")", "\n", "RepurposerTestUtils", ".", "_remove_files_with_prefix", "(", "file_path", ")", "\n", "return", "loaded_repurposer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase._compare_gp_repurposers": [[205, 220], ["test_gp_repurposer.GpRepurposerTestCase.assertTrue", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "enumerate", "repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal", "isinstance", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "type", "type", "type", "type", "type", "type", "type", "len", "len", "len", "len", "isinstance", "type", "type", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.tests.repurposer_test_utils.RepurposerTestUtils._assert_common_attributes_equal"], ["", "def", "_compare_gp_repurposers", "(", "self", ",", "repurposer1", ",", "repurposer2", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "type", "(", "repurposer1", ")", "==", "type", "(", "repurposer2", ")", ",", "\n", "\"Incorrect repurposer type. Expected: {} Actual: {}\"", ".", "format", "(", "type", "(", "repurposer1", ")", ",", "\n", "type", "(", "repurposer2", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "repurposer2", ".", "target_model", ",", "type", "(", "repurposer1", ".", "target_model", ")", ")", ",", "\n", "\"Incorrect target_model type. Expected: {} Actual: {}\"", ".", "format", "(", "type", "(", "repurposer1", ".", "target_model", ")", ",", "\n", "type", "(", "repurposer2", ".", "target_model", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "repurposer1", ".", "target_model", ")", "==", "len", "(", "repurposer2", ".", "target_model", ")", ",", "\n", "\"Incorrect number of target_models. Expected:{} Actual:{}\"", "\n", ".", "format", "(", "len", "(", "repurposer1", ".", "target_model", ")", ",", "len", "(", "repurposer2", ".", "target_model", ")", ")", ")", "\n", "for", "model_id", ",", "target_model", "in", "enumerate", "(", "repurposer1", ".", "target_model", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "isinstance", "(", "repurposer2", ".", "target_model", "[", "model_id", "]", ",", "type", "(", "target_model", ")", ")", ",", "\n", "\"Incorrect GP model type. Expected:{} Actual:{}\"", "\n", ".", "format", "(", "type", "(", "repurposer1", ".", "target_model", "[", "model_id", "]", ")", ",", "type", "(", "repurposer2", ".", "target_model", "[", "model_id", "]", ")", ")", ")", "\n", "", "RepurposerTestUtils", ".", "_assert_common_attributes_equal", "(", "repurposer1", ",", "repurposer2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_gp_repurposer.GpRepurposerTestCase.test_binary_classification": [[221, 247], ["numpy.array", "numpy.array", "xfer.GpRepurposer", "xfer.GpRepurposer._train_model_from_features", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "numpy.array", "numpy.array", "numpy.array", "xfer.GpRepurposer._predict_probability_from_features", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "xfer.GpRepurposer._predict_label_from_features", "test_gp_repurposer.GpRepurposerTestCase.assertTrue", "numpy.allclose", "numpy.array_equal", "numpy.arange", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features"], ["", "def", "test_binary_classification", "(", "self", ")", ":", "\n", "        ", "train_features", "=", "np", ".", "array", "(", "[", "[", "0.0286274", ",", "0.41107054", ",", "0.30557073", "]", ",", "[", "0.18646135", ",", "0.71026038", ",", "0.87030804", "]", ",", "\n", "[", "0.46904668", ",", "0.96190886", ",", "0.85772885", "]", ",", "[", "0.40327128", ",", "0.5739354", ",", "0.21895921", "]", ",", "\n", "[", "0.53548", ",", "0.9645708", ",", "0.56493308", "]", ",", "[", "0.80917639", ",", "0.78891976", ",", "0.96257564", "]", ",", "\n", "[", "0.10951679", ",", "0.75733494", ",", "0.10935291", "]", "]", ")", "\n", "train_labels", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "1", "]", ")", "\n", "gp_repurposer", "=", "GpRepurposer", "(", "self", ".", "source_model", ",", "self", ".", "source_model_layers", ")", "\n", "gp_repurposer", ".", "target_model", "=", "gp_repurposer", ".", "_train_model_from_features", "(", "train_features", ",", "train_labels", ",", "\n", "{", "'l1'", ":", "np", ".", "arange", "(", "0", ",", "3", ")", "}", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "gp_repurposer", ".", "target_model", ")", "==", "1", ",", "\n", "\"Number of GP models expected: 1. Got: {}\"", ".", "format", "(", "len", "(", "gp_repurposer", ".", "target_model", ")", ")", ")", "\n", "\n", "# Validate predicted probabilities", "\n", "test_features", "=", "np", ".", "array", "(", "[", "[", "0.63747595", ",", "0.86516482", ",", "0.21255967", "]", ",", "\n", "[", "0.33403457", ",", "0.43162212", ",", "0.77119909", "]", ",", "\n", "[", "0.1678248", ",", "0.41870605", ",", "0.37232554", "]", "]", ")", "\n", "test_labels", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", "\n", "expected_probabilities", "=", "np", ".", "array", "(", "[", "[", "0.48597323", ",", "0.51402677", "]", ",", "\n", "[", "0.67488224", ",", "0.32511776", "]", ",", "\n", "[", "0.55386502", ",", "0.44613498", "]", "]", ")", "\n", "predicted_probabilities", "=", "gp_repurposer", ".", "_predict_probability_from_features", "(", "test_features", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "predicted_probabilities", ",", "expected_probabilities", ")", ")", "\n", "\n", "# Validate predicted labels", "\n", "predicted_labels", "=", "gp_repurposer", ".", "_predict_label_from_features", "(", "test_features", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "predicted_labels", ",", "test_labels", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_exceptions.TestExceptions.test_handle_mxnet_error": [[25, 32], ["test_exceptions.CustomError", "open", "tf.read", "test_exceptions.TestExceptions.assertRaises", "xfer.model_handler.exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["    ", "def", "test_handle_mxnet_error", "(", "self", ")", ":", "\n", "# Assert ModelArchitectureError is raised", "\n", "        ", "with", "open", "(", "'tests/data/exceptions/model_architecture_error.txt'", ",", "'r'", ")", "as", "tf", ":", "\n", "            ", "string", "=", "tf", ".", "read", "(", ")", "\n", "", "error", "=", "CustomError", "(", "string", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelArchitectureError", ")", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_exceptions.TestExceptions.test_handle_mxnet_error_140": [[33, 40], ["test_exceptions.CustomError", "open", "tf.read", "test_exceptions.TestExceptions.assertRaises", "xfer.model_handler.exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["", "", "def", "test_handle_mxnet_error_140", "(", "self", ")", ":", "\n", "# Assert ModelArchitectureError is raised", "\n", "        ", "with", "open", "(", "'tests/data/exceptions/model_architecture_error_140.txt'", ",", "'r'", ")", "as", "tf", ":", "\n", "            ", "string", "=", "tf", ".", "read", "(", ")", "\n", "", "error", "=", "CustomError", "(", "string", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelArchitectureError", ")", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_exceptions.TestExceptions.test_handle_mxnet_error_150": [[41, 48], ["test_exceptions.CustomError", "open", "tf.read", "test_exceptions.TestExceptions.assertRaises", "xfer.model_handler.exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["", "", "def", "test_handle_mxnet_error_150", "(", "self", ")", ":", "\n", "# Assert ModelArchitectureError is raised", "\n", "        ", "with", "open", "(", "'tests/data/exceptions/model_architecture_error_150.txt'", ",", "'r'", ")", "as", "tf", ":", "\n", "            ", "string", "=", "tf", ".", "read", "(", ")", "\n", "", "error", "=", "CustomError", "(", "string", ")", "\n", "with", "self", ".", "assertRaises", "(", "exceptions", ".", "ModelArchitectureError", ")", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_exceptions.TestExceptions.test_handle_mxnet_error_index_fail": [[49, 56], ["test_exceptions.CustomError", "open", "tf.read", "test_exceptions.TestExceptions.assertRaises", "xfer.model_handler.exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["", "", "def", "test_handle_mxnet_error_index_fail", "(", "self", ")", ":", "\n", "# Assert original error is raised when a ValueError is raised because string indexing fails", "\n", "        ", "with", "open", "(", "'tests/data/exceptions/model_architecture_error_fail.txt'", ",", "'r'", ")", "as", "tf", ":", "\n", "            ", "string", "=", "tf", ".", "read", "(", ")", "\n", "", "error", "=", "CustomError", "(", "string", ")", "\n", "with", "self", ".", "assertRaises", "(", "CustomError", ")", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.unit.test_exceptions.TestExceptions.test_handle_mxnet_error_random_string": [[57, 64], ["test_exceptions.CustomError", "test_exceptions.TestExceptions.assertRaises", "xfer.model_handler.exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["", "", "def", "test_handle_mxnet_error_random_string", "(", "self", ")", ":", "\n", "# Assert original error is raised when string does not match expected error string because error not related to", "\n", "# weight shape mismatch", "\n", "        ", "string", "=", "'cvbcbcbvb'", "\n", "error", "=", "CustomError", "(", "string", ")", "\n", "with", "self", ".", "assertRaises", "(", "CustomError", ")", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "error", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.__init__": [[46, 56], ["repurposer.Repurposer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "batch_size", "=", "64", ",", "\n", "num_epochs", "=", "5", ",", "optimizer", "=", "'sgd'", ",", "optimizer_params", "=", "None", ")", ":", "\n", "        ", "super", "(", "NeuralNetworkRepurposer", ",", "self", ")", ".", "__init__", "(", "source_model", ",", "context_function", ",", "num_devices", ")", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "num_epochs", "=", "num_epochs", "\n", "self", ".", "_save_source_model_default", "=", "False", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "optimizer_params", "=", "optimizer_params", "\n", "if", "self", ".", "optimizer_params", "is", "None", ":", "\n", "            ", "self", ".", "optimizer_params", "=", "{", "keys", ".", "LEARNING_RATE", ":", "consts", ".", "DEFAULT_LEARNING_RATE", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.get_params": [[57, 69], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", "NeuralNetworkRepurposer", ",", "self", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "OPTIMIZER", "]", "=", "self", ".", "optimizer", "\n", "param_dict", "[", "keys", ".", "OPTIMIZER_PARAMS", "]", "=", "self", ".", "optimizer_params", "\n", "param_dict", "[", "keys", ".", "BATCH_SIZE", "]", "=", "self", ".", "batch_size", "\n", "param_dict", "[", "keys", ".", "NUM_EPOCHS", "]", "=", "self", ".", "num_epochs", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer._get_attributes": [[70, 80], ["super()._get_attributes", "model_handler.ModelHandler"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "_get_attributes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer not in constructor\n\n        :rtype: dict\n        \"\"\"", "\n", "attr_dict", "=", "super", "(", ")", ".", "_get_attributes", "(", ")", "\n", "if", "self", ".", "target_model", "is", "not", "None", ":", "\n", "            ", "attr_dict", "[", "serialization_keys", ".", "LAST_LAYER_NAME_TARGET", "]", "=", "ModelHandler", "(", "self", ".", "target_model", ")", ".", "layer_names", "[", "-", "1", "]", "\n", "", "return", "attr_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.repurpose": [[81, 116], ["neural_network_repurposer.NeuralNetworkRepurposer._validate_before_repurpose", "neural_network_repurposer.NeuralNetworkRepurposer._create_target_module", "train_iterator.reset", "neural_network_repurposer.NeuralNetworkRepurposer.fit", "mxnet.callback.Speedometer", "mxnet.init.Xavier"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_repurpose", "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._create_target_module", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset"], ["", "def", "repurpose", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Train a neural network by transferring layers/weights from source_model.\n        Set self.target_model to the repurposed neural network.\n\n        :param train_iterator: Training data iterator to use to extract features from source_model\n        :type train_iterator: :class:`mxnet.io.DataIter`\n        \"\"\"", "\n", "\n", "# Validate the repurpose call", "\n", "self", ".", "_validate_before_repurpose", "(", ")", "\n", "\n", "# Prepare target model symbol (add or remove layers/ transfer weights/ freeze/ fine tune/ etc.)", "\n", "model", "=", "self", ".", "_create_target_module", "(", "train_iterator", ")", "\n", "\n", "# Reset iterator before using it to train", "\n", "train_iterator", ".", "reset", "(", ")", "\n", "\n", "# Train the model using given training data in batches", "\n", "model", ".", "fit", "(", "train_iterator", ",", "\n", "optimizer", "=", "self", ".", "optimizer", ",", "\n", "optimizer_params", "=", "self", ".", "optimizer_params", ",", "\n", "kvstore", "=", "'device'", ",", "\n", "eval_metric", "=", "'acc'", ",", "\n", "allow_missing", "=", "True", ",", "\n", "batch_end_callback", "=", "mx", ".", "callback", ".", "Speedometer", "(", "self", ".", "batch_size", ")", ",", "\n", "initializer", "=", "mx", ".", "init", ".", "Xavier", "(", "rnd_type", "=", "'gaussian'", ",", "factor_type", "=", "'in'", ",", "magnitude", "=", "2", ")", ",", "\n", "num_epoch", "=", "self", ".", "num_epochs", ")", "\n", "\n", "# Set self.target_model to the repurposed model", "\n", "self", ".", "target_model", "=", "model", "\n", "\n", "# Save data_shape and label_shapes", "\n", "self", ".", "provide_data", "=", "train_iterator", ".", "provide_data", "\n", "self", ".", "provide_label", "=", "train_iterator", ".", "provide_label", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.predict_probability": [[117, 137], ["neural_network_repurposer.NeuralNetworkRepurposer._validate_before_predict", "neural_network_repurposer.NeuralNetworkRepurposer.target_model.predict", "neural_network_repurposer.NeuralNetworkRepurposer.asnumpy", "neural_network_repurposer.NeuralNetworkRepurposer.target_model.bind"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "predict_probability", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Perform predictions on test data using the target_model (repurposed neural network).\n\n        :param test_iterator: Test data iterator to return predictions for\n        :type test_iterator: :class:`mxnet.io.DataIter`\n        :return: Predicted probabilities\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "\n", "# Validate the predict call", "\n", "self", ".", "_validate_before_predict", "(", ")", "\n", "\n", "# Bind target model symbol with data if not already bound", "\n", "if", "not", "self", ".", "target_model", ".", "binded", ":", "\n", "            ", "self", ".", "target_model", ".", "bind", "(", "data_shapes", "=", "test_iterator", ".", "provide_data", ",", "for_training", "=", "False", ")", "\n", "\n", "# Call mxnet.BaseModule.predict. It handles batch padding and resets iterator before prediction.", "\n", "", "predictions", "=", "self", ".", "target_model", ".", "predict", "(", "eval_data", "=", "test_iterator", ")", "\n", "return", "predictions", ".", "asnumpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.predict_label": [[138, 155], ["neural_network_repurposer.NeuralNetworkRepurposer.predict_probability", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_probability"], ["", "def", "predict_label", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Perform predictions on test data using the target_model (repurposed neural network).\n\n        :param test_iterator: Test data iterator to return predictions for\n        :type test_iterator: mxnet.io.DataIter\n        :return: Predicted labels\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "\n", "# Call predict_probability method to get soft predictions", "\n", "probabilities", "=", "self", ".", "predict_probability", "(", "test_iterator", ")", "\n", "\n", "# Select and return label with maximum probability for each test instance", "\n", "labels", "=", "np", ".", "argmax", "(", "probabilities", ",", "axis", "=", "1", ")", "\n", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer._create_target_module": [[156, 162], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_create_target_module", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer._validate_before_predict": [[163, 173], ["isinstance", "TypeError", "ValueError", "type"], "methods", ["None"], ["", "def", "_validate_before_predict", "(", "self", ")", ":", "\n", "# For neural network repurposers, target_model should be an MXNet module object", "\n", "        ", "if", "not", "isinstance", "(", "self", ".", "target_model", ",", "mx", ".", "mod", ".", "Module", ")", ":", "\n", "            ", "error", "=", "(", "\"Cannot predict because target_model is not an `mxnet.mod.Module` object. \"", "\n", "\" Instead got type: {}\"", ".", "format", "(", "type", "(", "self", ".", "target_model", ")", ")", ")", "\n", "raise", "TypeError", "(", "error", ")", "\n", "\n", "", "if", "not", "self", ".", "target_model", ".", "params_initialized", ":", "\n", "            ", "error", "=", "\"target_model params aren't initialized. Ensure model is trained before calling predict\"", "\n", "raise", "ValueError", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.serialize": [[174, 190], ["neural_network_repurposer.NeuralNetworkRepurposer.get_params", "output_dict.update", "utils.save_json", "utils.save_mxnet_model", "neural_network_repurposer.NeuralNetworkRepurposer._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_mxnet_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Serialize repurposer to dictionary.\n\n        :return: Dictionary describing repurposer\n        :rtype: dict\n        \"\"\"", "\n", "output_dict", "=", "{", "}", "\n", "output_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "=", "self", ".", "get_params", "(", ")", "\n", "output_dict", ".", "update", "(", "self", ".", "_get_attributes", "(", ")", ")", "\n", "\n", "# save serialised model file_path.json", "\n", "utils", ".", "save_json", "(", "file_prefix", ",", "output_dict", ")", "\n", "\n", "# Save target_model as file-path-symbol.json and file-path-0000.params", "\n", "utils", ".", "save_mxnet_model", "(", "self", ".", "target_model", ",", "file_prefix", ",", "0", ",", "self", ".", "provide_data", ",", "self", ".", "provide_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_repurposer.NeuralNetworkRepurposer.deserialize": [[191, 201], ["mxnet.mod.Module.load", "neural_network_repurposer.NeuralNetworkRepurposer._set_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes"], ["", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Uses dictionary to set attributes of repurposer.\n\n        :param dict input_dict: Dictionary containing values for attributes to be set to\n        \"\"\"", "\n", "self", ".", "target_model", "=", "mx", ".", "mod", ".", "Module", ".", "load", "(", "input_dict", "[", "serialization_keys", ".", "FILE_PATH", "]", ",", "0", ",", "\n", "label_names", "=", "[", "input_dict", "[", "serialization_keys", ".", "LAST_LAYER_NAME_TARGET", "]", "+", "\n", "serialization_constants", ".", "LABEL_SUFFIX", "]", ")", "\n", "self", ".", "_set_attributes", "(", "input_dict", ")", "# Set attributes of repurposer from input_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer.__init__": [[40, 59], ["meta_model_repurposer.MetaModelRepurposer.__init__", "sklearn.preprocessing.Normalizer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "feature_layer_names", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "\n", "max_function_evaluations", "=", "100", ",", "apply_l2_norm", "=", "False", ")", ":", "\n", "# Call base class constructor with parameters required for meta-models", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "source_model", ",", "feature_layer_names", ",", "context_function", ",", "num_devices", ")", "\n", "self", ".", "max_function_evaluations", "=", "max_function_evaluations", "\n", "self", ".", "apply_l2_norm", "=", "apply_l2_norm", "\n", "\n", "# Mean of features to use for normalization. Computed in training phase.", "\n", "# Used to normalize features in training and in prediction.", "\n", "self", ".", "feature_mean", "=", "None", "\n", "\n", "# Optimizer to use for training GP model", "\n", "self", ".", "optimizer", "=", "'lbfgs'", "\n", "\n", "# Number of inducing points to use for sparse GP", "\n", "self", ".", "NUM_INDUCING_SPARSE_GP", "=", "100", "\n", "\n", "# Normalizer to use when apply_l2_norm flag is set", "\n", "self", ".", "l2_normalizer", "=", "Normalizer", "(", "norm", "=", "'l2'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._train_model_from_features": [[60, 109], ["features.mean", "sklearn.preprocessing.LabelBinarizer().fit_transform", "gp_repurposer.GpRepurposer._build_kernel", "range", "gp_repurposer.GpRepurposer.l2_normalizer.fit_transform", "gp_repurposer.GpRepurposer.copy", "gp_repurposer.GpRepurposer._train_model_for_binary_label", "sklearn.preprocessing.LabelBinarizer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._build_kernel", "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._train_model_for_binary_label"], ["", "def", "_train_model_from_features", "(", "self", ",", "features", ",", "labels", ",", "feature_indices_per_layer", ")", ":", "\n", "        ", "\"\"\"\n        Train GP classification models using features extracted from the source neural network.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :param labels: Labels to use for training.\n        :type labels: :class:`numpy.ndarray`\n        :param feature_indices_per_layer: Mapping of feature_layer_names to dimension indices in features array\n                                          i.e. {layer_name, feature_indices}.\n                                          Used to build separate kernels for features from different layers.\n        :type feature_indices_per_layer: OrderedDict[str, :class:`numpy.ndarray`]\n        :return: List of GP classification models trained for each class (one-vs-all) in given training data.\n                 List of Sparse GP models returned if number of training instances is greater than\n                 NUM_INDUCING_SPARSE_GP.\n                 If there are only two classes in training data, then the output list contains a single model.\n        :rtype: list[:class:`GPy.models.GPClassification`] or list[:class:`GPy.models.SparseGPClassification`]\n        \"\"\"", "\n", "# Normalize features to train on", "\n", "self", ".", "feature_mean", "=", "features", ".", "mean", "(", "axis", "=", "0", ")", "# Compute mean for each feature across all training instances", "\n", "normalized_features", "=", "features", "-", "self", ".", "feature_mean", "# Normalize features to have zero mean", "\n", "if", "self", ".", "apply_l2_norm", ":", "# Apply L2 normalization if flag is set", "\n", "            ", "normalized_features", "=", "self", ".", "l2_normalizer", ".", "fit_transform", "(", "normalized_features", ")", "\n", "\n", "# Binarize labels in a one-vs-all fashion to train a separate model for each class", "\n", "# Output contains 'c' columns (c=number of classes) and each column contains binary labels w.r.t to that class.", "\n", "# If number of classes is two, then the output contains a single column with values 0 and 1", "\n", "", "binarized_labels", "=", "LabelBinarizer", "(", ")", ".", "fit_transform", "(", "labels", ")", "\n", "\n", "# Build kernel using given feature indices", "\n", "kernel", "=", "self", ".", "_build_kernel", "(", "feature_indices_per_layer", ")", "\n", "\n", "# Do spare GP if number of training instances is greater than chosen number of inducing points", "\n", "# Otherwise, do normal GP classification because the data set is small", "\n", "num_training_instances", "=", "features", ".", "shape", "[", "0", "]", "\n", "do_sparse_gp", "=", "(", "num_training_instances", ">", "self", ".", "NUM_INDUCING_SPARSE_GP", ")", "\n", "\n", "# Train a GP model for each class (one-vs-all) if there are more than two classes, and one model if there", "\n", "# are only two classes", "\n", "num_models", "=", "binarized_labels", ".", "shape", "[", "1", "]", "\n", "models", "=", "[", "None", "]", "*", "num_models", "\n", "for", "model_index", "in", "range", "(", "num_models", ")", ":", "\n", "            ", "binary_labels_for_current_class", "=", "binarized_labels", "[", ":", ",", "model_index", ":", "model_index", "+", "1", "]", "\n", "input_kernel", "=", "kernel", ".", "copy", "(", ")", "# Pass copy of kernel to avoid original kernel being updated by GPy", "\n", "models", "[", "model_index", "]", "=", "self", ".", "_train_model_for_binary_label", "(", "binary_label", "=", "binary_labels_for_current_class", ",", "\n", "features", "=", "normalized_features", ",", "\n", "kernel", "=", "input_kernel", ",", "\n", "do_sparse_gp", "=", "do_sparse_gp", ")", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._train_model_for_binary_label": [[110, 121], ["GPy.models.GPClassification.optimize", "GPy.models.SparseGPClassification", "GPy.models.GPClassification"], "methods", ["None"], ["", "def", "_train_model_for_binary_label", "(", "self", ",", "features", ",", "binary_label", ",", "kernel", ",", "do_sparse_gp", ")", ":", "\n", "# GPy is imported here in order to avoid importing it during 'import xfer'", "\n", "        ", "import", "GPy", "\n", "# Train a GPy model for binary classification with given features and kernel", "\n", "if", "do_sparse_gp", ":", "\n", "            ", "model", "=", "GPy", ".", "models", ".", "SparseGPClassification", "(", "X", "=", "features", ",", "Y", "=", "binary_label", ",", "kernel", "=", "kernel", ",", "\n", "num_inducing", "=", "self", ".", "NUM_INDUCING_SPARSE_GP", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "GPy", ".", "models", ".", "GPClassification", "(", "X", "=", "features", ",", "Y", "=", "binary_label", ",", "kernel", "=", "kernel", ")", "\n", "", "model", ".", "optimize", "(", "optimizer", "=", "self", ".", "optimizer", ",", "max_iters", "=", "self", ".", "max_function_evaluations", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._build_kernel": [[122, 146], ["GPy.kern.RBF", "active_dims.tolist"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_build_kernel", "(", "feature_indices_per_layer", ")", ":", "\n", "        ", "\"\"\"\n        Build separate RBF kernels for features from different layers and return the kernel that results from adding all\n        feature specific kernels.\n\n        :param feature_indices_per_layer: Mapping of feature_layer_names to dimension indices in features array\n                                          i.e. {layer_name, feature_indices}.\n        :type feature_indices_per_layer: dict[str, :class:`numpy.ndarray`]\n        :return: GPy RBF kernel if all features are from single layer or GPy Add kernel if features are from multiple\n                 layers.\n        :rtype: :class:`GPy.kern.RBF` or :class:`GPy.kern.Add`\n        \"\"\"", "\n", "# GPy is imported here in order to avoid importing it during 'import xfer'", "\n", "import", "GPy", "\n", "all_kernels", "=", "None", "\n", "for", "layer_name", "in", "feature_indices_per_layer", ":", "\n", "            ", "active_dims", "=", "feature_indices_per_layer", "[", "layer_name", "]", "# feature indices corresponding to current layer", "\n", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "active_dims", ".", "size", ",", "name", "=", "layer_name", ",", "active_dims", "=", "active_dims", ".", "tolist", "(", ")", ")", "\n", "if", "all_kernels", "is", "None", ":", "\n", "                ", "all_kernels", "=", "kernel", "\n", "", "else", ":", "\n", "                ", "all_kernels", "+=", "kernel", "\n", "", "", "return", "all_kernels", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._predict_probability_from_features": [[147, 187], ["len", "gp_repurposer.GpRepurposer.l2_normalizer.transform", "gp_repurposer.GpRepurposer.target_model[].predict", "numpy.hstack", "range", "numpy.nan_to_num", "numpy.sum().reshape", "binary_gp_model.predict", "predictions_per_class.append", "numpy.hstack", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "_predict_probability_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Compute predictions using self.target_model with features extracted from source neural network.\n        self.target_model is a list of GP classification models trained for each class in a one-vs-all fashion.\n        Use GPy's predict method on each model and compute probabilities predicted for individual classes.\n        The individual class probabilities are then normalized such that their sum is 1.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Normalized one-vs-all probabilities.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "normalized_features", "=", "features", "-", "self", ".", "feature_mean", "# Normalize features using the training features' means", "\n", "if", "self", ".", "apply_l2_norm", ":", "# Apply L2 normalization if flag is set", "\n", "            ", "normalized_features", "=", "self", ".", "l2_normalizer", ".", "transform", "(", "normalized_features", ")", "\n", "\n", "", "num_gp_models", "=", "len", "(", "self", ".", "target_model", ")", "\n", "if", "num_gp_models", "==", "1", ":", "\n", "# When there are only two classes, get probability for class_1 (P) and calculate probability for class_0", "\n", "# (1-P)", "\n", "            ", "prediction", ",", "_", "=", "self", ".", "target_model", "[", "0", "]", ".", "predict", "(", "normalized_features", ")", "\n", "normalized_predictions", "=", "np", ".", "hstack", "(", "[", "1.0", "-", "prediction", ",", "prediction", "]", ")", "\n", "\n", "", "else", ":", "\n", "# When there are more than two classes, get one-vs-all prediction scores for each class", "\n", "# from binary GP models", "\n", "            ", "predictions_per_class", "=", "[", "]", "\n", "for", "model_id", "in", "range", "(", "num_gp_models", ")", ":", "\n", "                ", "binary_gp_model", "=", "self", ".", "target_model", "[", "model_id", "]", "\n", "binary_prediction", ",", "_", "=", "binary_gp_model", ".", "predict", "(", "normalized_features", ")", "\n", "predictions_per_class", ".", "append", "(", "binary_prediction", ")", "\n", "\n", "# Convert scores list to numpy array", "\n", "", "predictions", "=", "np", ".", "nan_to_num", "(", "np", ".", "hstack", "(", "predictions_per_class", ")", ")", "\n", "\n", "# Normalize individual predictions to sum up to 1", "\n", "sum_of_predictions_per_instance", "=", "np", ".", "sum", "(", "predictions", ",", "axis", "=", "1", ")", ".", "reshape", "(", "predictions", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "normalized_predictions", "=", "predictions", "/", "sum_of_predictions_per_instance", "\n", "\n", "", "return", "normalized_predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._predict_label_from_features": [[188, 203], ["gp_repurposer.GpRepurposer._predict_probability_from_features", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features"], ["", "def", "_predict_label_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Return labels predicted using target_model with features extracted from source neural network.\n        target_model is a list of GP classification models trained for each class in a one-vs-all fashion.\n        Using GPy's predict method, compute one-vs-all probabilities per class and return the class with\n        maximum probability.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted labels i.e. Class with maximum probability for each test instance.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "predictions", "=", "self", ".", "_predict_probability_from_features", "(", "features", ")", "\n", "labels", "=", "np", ".", "argmax", "(", "predictions", ",", "axis", "=", "1", ")", "# Select label with maximum prediction for each test instance", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer.get_params": [[204, 214], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor's argument list.\n\n        :rtype: dict\n        \"\"\"", "\n", "params_dict", "=", "super", "(", ")", ".", "get_params", "(", ")", "\n", "params_dict", "[", "keys", ".", "MAX_FUNCTION_EVALUATIONS", "]", "=", "self", ".", "max_function_evaluations", "\n", "params_dict", "[", "keys", ".", "APPLY_L2_NORM", "]", "=", "self", ".", "apply_l2_norm", "\n", "return", "params_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._get_attributes": [[215, 226], ["super()._get_attributes", "gp_repurposer.GpRepurposer.feature_mean.tolist"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "_get_attributes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer not in constructor's argument list.\n\n        :rtype: dict\n        \"\"\"", "\n", "attributes_dict", "=", "super", "(", ")", ".", "_get_attributes", "(", ")", "\n", "attributes_dict", "[", "keys", ".", "OPTIMIZER", "]", "=", "self", ".", "optimizer", "\n", "attributes_dict", "[", "keys", ".", "NUM_INDUCING_SPARSE_GP", "]", "=", "self", ".", "NUM_INDUCING_SPARSE_GP", "\n", "attributes_dict", "[", "keys", ".", "FEATURE_MEAN", "]", "=", "self", ".", "feature_mean", ".", "tolist", "(", ")", "\n", "return", "attributes_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._set_attributes": [[227, 239], ["super()._set_attributes", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes"], ["", "def", "_set_attributes", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Set attributes of class from input_dict.\n        These attributes are the same as those returned by get_attributes method.\n\n        :param input_dict: Dictionary containing attribute values.\n        :return: None\n        \"\"\"", "\n", "super", "(", ")", ".", "_set_attributes", "(", "input_dict", ")", "\n", "self", ".", "optimizer", "=", "input_dict", "[", "keys", ".", "OPTIMIZER", "]", "\n", "self", ".", "NUM_INDUCING_SPARSE_GP", "=", "input_dict", "[", "keys", ".", "NUM_INDUCING_SPARSE_GP", "]", "\n", "self", ".", "feature_mean", "=", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "FEATURE_MEAN", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer.serialize": [[240, 258], ["output_dict.update", "gp_repurposer.GpRepurposer._serialize_target_gp_models", "utils.save_json", "gp_repurposer.GpRepurposer.get_params", "gp_repurposer.GpRepurposer._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._serialize_target_gp_models", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Serialize the GP repurposer (model and supporting info) and save to file.\n\n        :param str file_prefix: Prefix of file path to save the serialized repurposer to.\n        :return: None\n        \"\"\"", "\n", "# Get constructor params. This will be used to recreate repurposer object in deserialization flow.", "\n", "output_dict", "=", "{", "repurposer_keys", ".", "PARAMS", ":", "self", ".", "get_params", "(", ")", "}", "\n", "\n", "# Get rest of the attributes to save with the repurposer.", "\n", "output_dict", ".", "update", "(", "self", ".", "_get_attributes", "(", ")", ")", "\n", "\n", "# Serialize the GP models and save to output dictionary", "\n", "output_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", "=", "self", ".", "_serialize_target_gp_models", "(", "save_data", "=", "True", ")", "\n", "\n", "# Save the serialized params and attributes to file", "\n", "utils", ".", "save_json", "(", "file_prefix", ",", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer.deserialize": [[259, 271], ["gp_repurposer.GpRepurposer._set_attributes", "gp_repurposer.GpRepurposer._deserialize_target_gp_models"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes", "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._deserialize_target_gp_models"], ["", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Uses dictionary to set attributes of repurposer.\n\n        :param dict input_dict: Dictionary containing values for attributes to be set to.\n        :return: None\n        \"\"\"", "\n", "# Set attributes of the repurposer from input_dict", "\n", "self", ".", "_set_attributes", "(", "input_dict", ")", "\n", "\n", "# Deserialize and set the target GP models", "\n", "self", ".", "target_model", "=", "self", ".", "_deserialize_target_gp_models", "(", "input_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._serialize_target_gp_models": [[272, 278], ["serialized_models.append", "model.to_dict"], "methods", ["None"], ["", "def", "_serialize_target_gp_models", "(", "self", ",", "save_data", "=", "True", ")", ":", "\n", "# Serialize the gp models trained per class and add to output list", "\n", "        ", "serialized_models", "=", "[", "]", "\n", "for", "model", "in", "self", ".", "target_model", ":", "\n", "            ", "serialized_models", ".", "append", "(", "model", ".", "to_dict", "(", "save_data", "=", "save_data", ")", ")", "\n", "", "return", "serialized_models", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.gp_repurposer.GpRepurposer._deserialize_target_gp_models": [[279, 288], ["deserialized_models.append", "GPy.core.Model.from_dict"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_deserialize_target_gp_models", "(", "serialized_target_model", ")", ":", "\n", "# GPy is imported here in order to avoid importing it during 'import xfer'", "\n", "        ", "import", "GPy", "\n", "# Deserialize the GP models trained per class and return", "\n", "deserialized_models", "=", "[", "]", "\n", "for", "model_dict", "in", "serialized_target_model", ":", "\n", "            ", "deserialized_models", ".", "append", "(", "GPy", ".", "core", ".", "Model", ".", "from_dict", "(", "model_dict", ")", ")", "\n", "", "return", "deserialized_models", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.load_repurposer.load": [[32, 75], ["os.path.join", "utils._assert_repurposer_file_exists", "eval", "utils.deserialize_ctx_fn", "eval.", "repurposer_class.deserialize", "open", "json.load", "utils._assert_repurposer_file_exists", "mxnet.module.Module.load", "utils.deserialize_ctx_fn"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils._assert_repurposer_file_exists", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.deserialize", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils._assert_repurposer_file_exists", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn"], ["def", "load", "(", "model_name", ",", "model_directory", "=", "''", ",", "source_model", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Load the repurposed model (target_model and supporting info) from given file_path and deserialize\n\n    :param str model_name: Name of saved repurposer\n    :param str model_directory: Directory of saved repurposer\n    :param source_model: Source neural network to do transfer learning from. If this is None, then source model\n                         (model_name_source-symbol.json & model_name_source-0000.params) will be loaded from file\n    :type source_model: :class:`mxnet.mod.Module`\n    :return: Repurposer object loaded from file\n    :rtype: :class:`Repurposer` (Object returned will be resolved to originally saved class)\n    \"\"\"", "\n", "file_prefix", "=", "os", ".", "path", ".", "join", "(", "model_directory", ",", "model_name", ")", "\n", "utils", ".", "_assert_repurposer_file_exists", "(", "[", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", "]", ")", "\n", "\n", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'r'", ")", "as", "json_data", ":", "\n", "        ", "input_dict", "=", "json", ".", "load", "(", "json_data", ")", "\n", "\n", "# load source model from file if required", "\n", "", "if", "source_model", "is", "None", ":", "\n", "        ", "utils", ".", "_assert_repurposer_file_exists", "(", "[", "file_prefix", "+", "'_source-symbol.json'", ",", "file_prefix", "+", "'_source-0000.params'", "]", ")", "\n", "source_model", "=", "mx", ".", "module", ".", "Module", ".", "load", "(", "file_prefix", "+", "consts", ".", "SOURCE_SUFFIX", ",", "0", ",", "\n", "label_names", "=", "[", "input_dict", "[", "keys", ".", "LAST_LAYER_NAME_SOURCE", "]", "+", "\n", "consts", ".", "LABEL_SUFFIX", "]", ")", "\n", "\n", "# Add file_prefix to input dict", "\n", "", "input_dict", "[", "keys", ".", "FILE_PATH", "]", "=", "file_prefix", "\n", "\n", "repurposer_class", "=", "eval", "(", "input_dict", "[", "repurposer_keys", ".", "REPURPOSER_CLASS", "]", ")", "\n", "\n", "# Deserialize input dict", "\n", "context_function", "=", "utils", ".", "deserialize_ctx_fn", "(", "input_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "[", "repurposer_keys", ".", "CONTEXT_FN", "]", ")", "\n", "input_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "[", "repurposer_keys", ".", "CONTEXT_FN", "]", "=", "context_function", "\n", "\n", "if", "repurposer_class", "==", "BnnRepurposer", ":", "\n", "        ", "bnn_context_function", "=", "utils", ".", "deserialize_ctx_fn", "(", "input_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "\n", "[", "bnn_repurposer_keys", ".", "BNN_CONTEXT_FUNCTION", "]", ")", "\n", "input_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "[", "bnn_repurposer_keys", ".", "BNN_CONTEXT_FUNCTION", "]", "=", "bnn_context_function", "\n", "\n", "# Instantiate repurposer and deserialize input dictionary", "\n", "", "repurposer", "=", "repurposer_class", "(", "source_model", ",", "**", "input_dict", "[", "repurposer_keys", ".", "PARAMS", "]", ")", "\n", "repurposer", ".", "deserialize", "(", "input_dict", ")", "\n", "return", "repurposer", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer.__init__": [[44, 54], ["meta_model_repurposer.MetaModelRepurposer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "feature_layer_names", ",", "context_function", "=", "mx", ".", "cpu", ",", "num_devices", "=", "1", ",", "\n", "c", "=", "1.0", ",", "kernel", "=", "'linear'", ",", "gamma", "=", "'auto'", ",", "enable_probability_estimates", "=", "False", ")", ":", "\n", "# Call base class constructor with parameters required for meta-models", "\n", "        ", "super", "(", "SvmRepurposer", ",", "self", ")", ".", "__init__", "(", "source_model", ",", "feature_layer_names", ",", "context_function", ",", "num_devices", ")", "\n", "\n", "# Initialize SVM specific parameters", "\n", "self", ".", "c", "=", "c", "\n", "self", ".", "kernel", "=", "kernel", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "enable_probability_estimates", "=", "enable_probability_estimates", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer.get_params": [[55, 67], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor.\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", "SvmRepurposer", ",", "self", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "C", "]", "=", "self", ".", "c", "\n", "param_dict", "[", "keys", ".", "KERNEL", "]", "=", "self", ".", "kernel", "\n", "param_dict", "[", "keys", ".", "GAMMA", "]", "=", "self", ".", "gamma", "\n", "param_dict", "[", "keys", ".", "PROB_ESTIMATES", "]", "=", "self", ".", "enable_probability_estimates", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer._train_model_from_features": [[68, 92], ["sklearn.svm.SVC", "sklearn.svm.SVC.fit"], "methods", ["None"], ["", "def", "_train_model_from_features", "(", "self", ",", "features", ",", "labels", ",", "feature_indices_per_layer", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Train an SVM model using features extracted from source neural network.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :param labels: Labels to use for training.\n        :type labels: :class:`numpy.ndarray`\n        :param feature_indices_per_layer: Mapping of feature_layer_names to indices in features array\n                                          i.e. {layer_name, feature_indices} Note that this param is currently not\n                                          consumed by svm_repurposer.\n        :type feature_indices_per_layer: OrderedDict[str, :class:`numpy.ndarray`]\n        :return: SVM model trained with given features and labels using sci-kit learn library.\n        :rtype: :class: `sklearn.svm.SVC`\n        \"\"\"", "\n", "\n", "svm_classifier", "=", "SVC", "(", "C", "=", "self", ".", "c", ",", "\n", "kernel", "=", "self", ".", "kernel", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "decision_function_shape", "=", "'ovr'", ",", "\n", "random_state", "=", "1", ",", "\n", "probability", "=", "self", ".", "enable_probability_estimates", ")", "\n", "svm_classifier", ".", "fit", "(", "features", ",", "labels", ")", "\n", "return", "svm_classifier", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer._predict_probability_from_features": [[93, 107], ["svm_repurposer.SvmRepurposer.target_model.predict_proba", "ValueError"], "methods", ["None"], ["", "def", "_predict_probability_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use sklearn's SVM predict_proba method and return predicted probabilities.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted probabilities.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "if", "not", "self", ".", "target_model", ".", "probability", ":", "\n", "            ", "raise", "ValueError", "(", "\"Probability estimates should have been enabled during model training for this method to \\\n                             work\"", ")", "\n", "", "return", "self", ".", "target_model", ".", "predict_proba", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer._predict_label_from_features": [[108, 119], ["svm_repurposer.SvmRepurposer.target_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "_predict_label_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use sklearn's SVM predict method and return predicted labels.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted labels.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "return", "self", ".", "target_model", ".", "predict", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer.serialize": [[120, 132], ["svm_repurposer.SvmRepurposer.get_params", "utils.sklearn_model_to_dict", "output_dict.update", "utils.save_json", "svm_repurposer.SvmRepurposer._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_to_dict", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Saves repurposer (excluding source model) to file_prefix.json.\n\n        :param str file_prefix: Prefix to save file with.\n        \"\"\"", "\n", "output_dict", "=", "{", "}", "\n", "output_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "=", "self", ".", "get_params", "(", ")", "\n", "output_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", "=", "utils", ".", "sklearn_model_to_dict", "(", "self", ".", "target_model", ")", "\n", "output_dict", ".", "update", "(", "self", ".", "_get_attributes", "(", ")", ")", "\n", "\n", "utils", ".", "save_json", "(", "file_prefix", ",", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.svm_repurposer.SvmRepurposer.deserialize": [[133, 141], ["svm_repurposer.SvmRepurposer._set_attributes", "utils.sklearn_model_from_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_from_dict"], ["", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Uses dictionary to set attributes of repurposer.\n\n        :param dict input_dict: Dictionary containing values for attributes to be set to.\n        \"\"\"", "\n", "self", ".", "_set_attributes", "(", "input_dict", ")", "# Set attributes of the repurposer from input_dict", "\n", "self", ".", "target_model", "=", "utils", ".", "sklearn_model_from_dict", "(", "SVC", ",", "input_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer.__init__": [[39, 48], ["meta_model_repurposer.MetaModelRepurposer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "feature_layer_names", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "\n", "tol", "=", "1e-4", ",", "c", "=", "1.0", ",", "n_jobs", "=", "-", "1", ")", ":", "\n", "# Call base class constructor with parameters required for meta-models", "\n", "        ", "super", "(", "LrRepurposer", ",", "self", ")", ".", "__init__", "(", "source_model", ",", "feature_layer_names", ",", "context_function", ",", "num_devices", ")", "\n", "\n", "# Initialize LR specific parameters", "\n", "self", ".", "tol", "=", "tol", "\n", "self", ".", "c", "=", "c", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer.get_params": [[49, 60], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor.\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", "LrRepurposer", ",", "self", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "TOL", "]", "=", "self", ".", "tol", "\n", "param_dict", "[", "keys", ".", "C", "]", "=", "self", ".", "c", "\n", "param_dict", "[", "keys", ".", "N_JOBS", "]", "=", "self", ".", "n_jobs", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer._train_model_from_features": [[61, 86], ["sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit"], "methods", ["None"], ["", "def", "_train_model_from_features", "(", "self", ",", "features", ",", "labels", ",", "feature_indices_per_layer", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Train a Logistic Regression model using features extracted from source neural network.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :param labels: Labels to use for training.\n        :type labels: :class:`numpy.ndarray`\n        :param feature_indices_per_layer: Mapping of feature_layer_names to indices in features array.\n        i.e. {layer_name, feature_indices}. Note that this param is currently not consumed by lr_repurposer.\n        :type feature_indices_per_layer: OrderedDict[str, :class:`numpy.ndarray`]\n        :return: LR model trained with given features and labels using sci-kit learn library.\n        :rtype: :class: `sklearn.linear_model.LogisticRegression`\n        \"\"\"", "\n", "lr_model", "=", "LogisticRegression", "(", "penalty", "=", "'l2'", ",", "\n", "tol", "=", "self", ".", "tol", ",", "\n", "C", "=", "self", ".", "c", ",", "\n", "fit_intercept", "=", "False", ",", "\n", "class_weight", "=", "'balanced'", ",", "\n", "random_state", "=", "1", ",", "\n", "solver", "=", "'sag'", ",", "\n", "multi_class", "=", "'multinomial'", ",", "\n", "n_jobs", "=", "self", ".", "n_jobs", ")", "\n", "lr_model", ".", "fit", "(", "features", ",", "labels", ")", "\n", "return", "lr_model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer._predict_probability_from_features": [[87, 98], ["sklearn.linear_model.LogisticRegression.predict_proba"], "methods", ["None"], ["", "def", "_predict_probability_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use sklearn's LR predict_proba method and return predicted probabilities.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted probabilities.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "return", "LogisticRegression", ".", "predict_proba", "(", "self", ".", "target_model", ",", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer._predict_label_from_features": [[99, 110], ["sklearn.linear_model.LogisticRegression.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "_predict_label_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use sklearn's LR predict method and return predicted labels.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted labels.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "return", "LogisticRegression", ".", "predict", "(", "self", ".", "target_model", ",", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer.serialize": [[111, 123], ["lr_repurposer.LrRepurposer.get_params", "utils.sklearn_model_to_dict", "output_dict.update", "utils.save_json", "lr_repurposer.LrRepurposer._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_to_dict", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Saves repurposer (excluding source model) to file_prefix.json.\n\n        :param str file_prefix: Prefix to save file with.\n        \"\"\"", "\n", "output_dict", "=", "{", "}", "\n", "output_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "=", "self", ".", "get_params", "(", ")", "\n", "output_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", "=", "utils", ".", "sklearn_model_to_dict", "(", "self", ".", "target_model", ")", "\n", "output_dict", ".", "update", "(", "self", ".", "_get_attributes", "(", ")", ")", "\n", "\n", "utils", ".", "save_json", "(", "file_prefix", ",", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.lr_repurposer.LrRepurposer.deserialize": [[124, 132], ["lr_repurposer.LrRepurposer._set_attributes", "utils.sklearn_model_from_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_from_dict"], ["", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Uses dictionary to set attributes of repurposer.\n\n        :param dict input_dict: Dictionary containing values for attributes to be set to.\n        \"\"\"", "\n", "self", ".", "_set_attributes", "(", "input_dict", ")", "# Set attributes of the repurposer from input_dict", "\n", "self", ".", "target_model", "=", "utils", ".", "sklearn_model_from_dict", "(", "LogisticRegression", ",", "input_dict", "[", "repurposer_keys", ".", "TARGET_MODEL", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_classifier.BnnClassifier.__init__": [[35, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "gluon", ".", "nn", ".", "Sequential", ",", "var_posterior", ":", "VariationalPosterior", ",", "\n", "normalizer", ":", "Normalizer", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "var_posterior", "=", "var_posterior", "\n", "self", ".", "normalizer", "=", "normalizer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_classifier.BnnClassifier.predict": [[42, 80], ["mxnet.cpu", "bnn_classifier.BnnClassifier.astype", "bnn_classifier.BnnClassifier.normalizer.transform", "mxnet.nd.array", "data.as_in_context().reshape.as_in_context().reshape.as_in_context().reshape", "range", "bnn_classifier.BnnClassifier.var_posterior.get_mean", "RuntimeError", "numpy.dtype", "bnn_classifier.BnnClassifier.var_posterior.generate_sample", "prob.utils.replace_params_net", "bnn_classifier.BnnClassifier.model", "mxnet.nd.softmax().asnumpy", "range", "numpy.zeros.argmax", "data.as_in_context().reshape.as_in_context().reshape.as_in_context", "numpy.zeros", "output[].astype", "output[].astype.sum", "numpy.random.multinomial", "float", "mxnet.nd.softmax", "numpy.dtype"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.get_mean", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.generate_sample", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.replace_params_net", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype"], ["", "def", "predict", "(", "self", ",", "features", ",", "num_samples_mc_prediction", "=", "100", ",", "context", "=", "mx", ".", "cpu", "(", ")", ")", ":", "\n", "        ", "\"\"\"\n        Function to make predictions\n\n        :param features: Features extracted from source neural network\n        :type features: :class:`numpy.ndarray`\n        :param int num_samples_mc_prediction: Num of samples from the posterior to compute the predictions\n        :param context: MXNet context\n        :type context: :class:`mxnet.Context`\n        :return: Tuple containing predicted labels and probabilities\n        :rtype: tuple(:class:`numpy.ndarray`, :class:`numpy.ndarray`)\n        \"\"\"", "\n", "if", "self", ".", "var_posterior", ".", "get_mean", "(", ")", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Repurposer is not trained!\"", ")", "\n", "\n", "", "n_te", ",", "dim", "=", "features", ".", "shape", "\n", "features", "=", "features", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float32", ")", ")", "\n", "features", "=", "self", ".", "normalizer", ".", "transform", "(", "features", ")", "\n", "data", "=", "mx", ".", "nd", ".", "array", "(", "features", ")", "\n", "data", "=", "data", ".", "as_in_context", "(", "context", ")", ".", "reshape", "(", "(", "-", "1", ",", "dim", ")", ")", "\n", "\n", "for", "j", "in", "range", "(", "num_samples_mc_prediction", ")", ":", "\n", "            ", "layer_params", "=", "self", ".", "var_posterior", ".", "generate_sample", "(", ")", "\n", "\n", "replace_params_net", "(", "layer_params", ",", "self", ".", "model", ",", "context", ")", "\n", "\n", "output_temp", "=", "self", ".", "model", "(", "data", ")", "\n", "output", "=", "mx", ".", "nd", ".", "softmax", "(", "output_temp", ")", ".", "asnumpy", "(", ")", "\n", "\n", "if", "j", "==", "0", ":", "\n", "                ", "predictions", "=", "np", ".", "zeros", "(", "(", "n_te", ",", "output", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_te", ")", ":", "\n", "                ", "p", "=", "output", "[", "i", ",", ":", "]", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float64", ")", ")", "\n", "p", "/=", "p", ".", "sum", "(", ")", "\n", "predictions", "[", "i", ",", ":", "]", "+=", "np", ".", "random", ".", "multinomial", "(", "1", ",", "p", ")", "\n", "\n", "", "", "return", "predictions", ".", "argmax", "(", "axis", "=", "1", ")", ",", "predictions", "/", "float", "(", "num_samples_mc_prediction", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.__init__": [[37, 48], ["repurposer.Repurposer.__init__", "model_handler.ModelHandler"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "feature_layer_names", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "\n", "num_devices", "=", "1", ")", ":", "\n", "        ", "super", "(", "MetaModelRepurposer", ",", "self", ")", ".", "__init__", "(", "source_model", ",", "context_function", ",", "num_devices", ")", "\n", "\n", "# Create model handler for source model. Required to extract features(layer output) during repurpose and predict", "\n", "self", ".", "source_model_handler", "=", "ModelHandler", "(", "self", ".", "source_model", ",", "self", ".", "context_function", ",", "self", ".", "num_devices", ")", "\n", "\n", "self", ".", "feature_layer_names", "=", "feature_layer_names", "\n", "self", ".", "provide_data", "=", "None", "\n", "self", ".", "provide_label", "=", "None", "\n", "self", ".", "_save_source_model_default", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_params": [[49, 58], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor's argument list.\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", "MetaModelRepurposer", ",", "self", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "FEATURE_LAYERS", "]", "=", "self", ".", "feature_layer_names", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.feature_layer_names": [[66, 81], ["isinstance", "TypeError", "len", "ValueError", "ValueError", "type"], "methods", ["None"], ["", "@", "feature_layer_names", ".", "setter", "\n", "def", "feature_layer_names", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "value", ",", "list", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"feature_layer_names must be a list. Instead got type: {}\"", ".", "format", "(", "type", "(", "value", ")", ")", ")", "\n", "\n", "", "if", "len", "(", "value", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"feature_layer_names cannot be empty. At least one layer name is required to extract features\"", ")", "\n", "\n", "# Validate if feature_layer_names passed are found in source_model", "\n", "", "for", "layer_name", "in", "value", ":", "\n", "            ", "if", "layer_name", "not", "in", "self", ".", "source_model_handler", ".", "layer_names", ":", "\n", "                ", "raise", "ValueError", "(", "\"feature_layer_name \\'{}\\' is not found in source_model\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "", "self", ".", "_feature_layer_names", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.source_model": [[89, 98], ["isinstance", "TypeError", "type"], "methods", ["None"], ["", "@", "source_model", ".", "setter", "\n", "def", "source_model", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "value", ",", "mx", ".", "mod", ".", "Module", ")", ":", "\n", "            ", "error", "=", "(", "\"source_model must be a valid `mxnet.mod.Module` object because\"", "\n", "\" MetaModelRepurposer requires source_model to extract features for both repurpose and predict.\"", "\n", "\" Instead got type: {}\"", ".", "format", "(", "type", "(", "value", ")", ")", ")", "\n", "raise", "TypeError", "(", "error", ")", "\n", "\n", "", "self", ".", "_source_model", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.repurpose": [[99, 122], ["meta_model_repurposer.MetaModelRepurposer._validate_before_repurpose", "meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "meta_model_repurposer.MetaModelRepurposer._train_model_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_repurpose", "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features"], ["", "def", "repurpose", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Train a meta-model using features extracted from training data through the source neural network.\n\n        Set self.target_model to the trained meta-model.\n\n        :param train_iterator: Training data iterator to use to extract features from source_model.\n        :type train_iterator: :class: `mxnet.io.DataIter`\n        \"\"\"", "\n", "\n", "# Validate if repurpose call is valid", "\n", "self", ".", "_validate_before_repurpose", "(", ")", "\n", "\n", "# For given training data, extract features from source neural network", "\n", "train_data", "=", "self", ".", "get_features_from_source_model", "(", "train_iterator", ")", "\n", "\n", "# Train target model using the extracted features (transfer and learn)", "\n", "self", ".", "target_model", "=", "self", ".", "_train_model_from_features", "(", "train_data", ".", "features", ",", "train_data", ".", "labels", ",", "\n", "train_data", ".", "feature_indices_per_layer", ")", "\n", "\n", "# Save data_shape and label_shapes", "\n", "self", ".", "provide_data", "=", "train_iterator", ".", "provide_data", "\n", "self", ".", "provide_label", "=", "train_iterator", ".", "provide_label", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.predict_probability": [[123, 141], ["meta_model_repurposer.MetaModelRepurposer._validate_before_predict", "meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "meta_model_repurposer.MetaModelRepurposer._predict_probability_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict", "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features"], ["", "def", "predict_probability", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Predict class probabilities on test data using the target_model (repurposed meta-model).\n\n        :param test_iterator: Test data iterator to return predictions for.\n        :type test_iterator: mxnet.io.DataIter\n        :return: Predicted probabilities.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "\n", "# Validate if predict call is valid", "\n", "self", ".", "_validate_before_predict", "(", ")", "\n", "\n", "# For given test data, extract features from source neural network", "\n", "test_data", "=", "self", ".", "get_features_from_source_model", "(", "test_iterator", ")", "\n", "\n", "# Predict and return probabilities", "\n", "return", "self", ".", "_predict_probability_from_features", "(", "test_data", ".", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.predict_label": [[142, 158], ["meta_model_repurposer.MetaModelRepurposer._validate_before_predict", "meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "meta_model_repurposer.MetaModelRepurposer._predict_label_from_features"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict", "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features"], ["", "def", "predict_label", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Predict class labels on test data using the target_model (repurposed meta-model).\n\n        :param test_iterator: Test data iterator to return predictions for.\n        :type test_iterator: mxnet.io.DataIter\n        :return: Predicted labels.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "self", ".", "_validate_before_predict", "(", ")", "\n", "\n", "# For given test data, extract features from source neural network", "\n", "test_data", "=", "self", ".", "get_features_from_source_model", "(", "test_iterator", ")", "\n", "\n", "# Predict and return labels", "\n", "return", "self", ".", "_predict_label_from_features", "(", "test_data", ".", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer.get_features_from_source_model": [[159, 190], ["meta_model_repurposer.MetaModelRepurposer.source_model_handler.get_layer_output", "collections.OrderedDict", "meta_model_repurposer.MetaModelData", "numpy.arange", "numpy.hstack"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output"], ["", "def", "get_features_from_source_model", "(", "self", ",", "data_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Extract feature outputs from feature_layer_names in source_model, merge and return all features and labels.\n\n        In addition, return mapping of feature_layer_name to indices in feature array.\n\n        :param data_iterator: Iterator for data to be passed through the source network and extract features.\n        :type data_iterator: :class:`mxnet.io.DataIter`\n        :return: features, feature_indices_per_layer and labels.\n        :rtype: :class:`MetaModelData`\n        \"\"\"", "\n", "\n", "feature_dict", ",", "labels", "=", "self", ".", "source_model_handler", ".", "get_layer_output", "(", "data_iterator", ",", "self", ".", "feature_layer_names", ")", "\n", "\n", "# Merge feature outputs from all layers and save feature indices per layer", "\n", "# e.g. output of feature_dict {layer1:[f1,f2,f3], layer2:[f4,f5]} would be", "\n", "# [f1,f2,f3,f4,f5] and {layer1:[0,1,2], layer2:[3,4]}", "\n", "features", "=", "None", "\n", "feature_indices_per_layer", "=", "OrderedDict", "(", ")", "# mapping for {layer name, feature indices}", "\n", "for", "layer_name", "in", "feature_dict", ":", "\n", "            ", "if", "features", "is", "None", ":", "\n", "                ", "next_feature_index", "=", "0", "\n", "features", "=", "feature_dict", "[", "layer_name", "]", "\n", "", "else", ":", "\n", "                ", "next_feature_index", "=", "features", ".", "shape", "[", "1", "]", "# New feature column(axis=1) will be added at the end", "\n", "features", "=", "np", ".", "hstack", "(", "[", "features", ",", "feature_dict", "[", "layer_name", "]", "]", ")", "\n", "", "total_num_features", "=", "features", ".", "shape", "[", "1", "]", "\n", "feature_indices_per_layer", "[", "layer_name", "]", "=", "np", ".", "arange", "(", "next_feature_index", ",", "total_num_features", ")", "\n", "\n", "", "meta_model_data", "=", "MetaModelData", "(", "features", ",", "feature_indices_per_layer", ",", "labels", ")", "\n", "return", "meta_model_data", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer._train_model_from_features": [[191, 197], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_train_model_from_features", "(", "self", ",", "features", ",", "labels", ",", "feature_indices_per_layer", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer._predict_probability_from_features": [[198, 204], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_predict_probability_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelRepurposer._predict_label_from_features": [[205, 211], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_predict_label_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.meta_model_repurposer.MetaModelData.__init__": [[214, 229], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "features", ",", "feature_indices_per_layer", ",", "labels", ")", ":", "\n", "        ", "\"\"\"\n        Structured data used by meta model repurposer to pass information extracted from source model.\n\n        :param features: Features extracted from source neural network\n        :type features: :class:`numpy.ndarray`\n        :param feature_indices_per_layer: Mapping of feature_layer_names to indices in features array i.e. {layer_name,\n            feature_indices}\n        :type feature_indices_per_layer: OrderedDict[str, :class:`numpy.ndarray`]\n        :param labels: Labels for target dataset.\n        :type labels: :class:`numpy.ndarray`\n        \"\"\"", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "feature_indices_per_layer", "=", "feature_indices_per_layer", "\n", "self", ".", "labels", "=", "labels", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposer.__init__": [[51, 61], ["neural_network_repurposer.NeuralNetworkRepurposer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "target_class_count", ",", "fixed_layers", ",", "random_layers", ",", "\n", "num_layers_to_drop", "=", "2", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "batch_size", "=", "64", ",", "num_epochs", "=", "5", ",", "\n", "optimizer", "=", "'sgd'", ",", "optimizer_params", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "source_model", ",", "context_function", ",", "num_devices", ",", "batch_size", ",", "num_epochs", ",", "\n", "optimizer", ",", "optimizer_params", ")", "\n", "\n", "self", ".", "target_class_count", "=", "target_class_count", "\n", "self", ".", "fixed_layers", "=", "fixed_layers", "\n", "self", ".", "random_layers", "=", "random_layers", "\n", "self", ".", "num_layers_to_drop", "=", "num_layers_to_drop", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposer.get_params": [[62, 74], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "TARGET_CLASS_COUNT", "]", "=", "self", ".", "target_class_count", "\n", "param_dict", "[", "keys", ".", "FIXED_LAYERS", "]", "=", "self", ".", "fixed_layers", "\n", "param_dict", "[", "keys", ".", "RANDOM_LAYERS", "]", "=", "self", ".", "random_layers", "\n", "param_dict", "[", "keys", ".", "NUM_LAYERS_TO_DROP", "]", "=", "self", ".", "num_layers_to_drop", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_random_freeze_repurposer.NeuralNetworkRandomFreezeRepurposer._create_target_module": [[75, 115], ["model_handler.model_handler.ModelHandler.model_handler.ModelHandler", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.get_layer_parameters", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.get_layer_parameters", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.drop_layer_top", "mxnet.sym.FullyConnected", "[].replace", "mxnet.sym.SoftmaxOutput", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.add_layer_top", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.get_module", "type", "type", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_module"], ["", "def", "_create_target_module", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Function to create target module by transferring layers and weights of source model, removing layers from output\n        and freezing and randomising selected layers\n\n        Overrides abstract method in base NeuralNetworkRepurposer class. Called by repurpose method in base class to\n        create target MXNet module that needs to be trained with target data set.\n\n        :param train_iterator: Training data iterator. Used by this function to bind target module\n        :type train_iterator: :class: `mxnet.io.DataIter`\n        :return: Target MXNet module created by transferring layers from source model\n        :rtype: :class:`mxnet.mod.Module`\n        \"\"\"", "\n", "# Create model handler to manipulate the source model", "\n", "model_handler", "=", "ModelHandler", "(", "self", ".", "source_model", ",", "self", ".", "context_function", ",", "self", ".", "num_devices", ")", "\n", "\n", "# Check if random and frozen layers are present in source model", "\n", "assert", "type", "(", "self", ".", "fixed_layers", ")", "==", "list", ",", "'fixed_layers should be a list'", "\n", "assert", "type", "(", "self", ".", "random_layers", ")", "==", "list", ",", "'random_layers should be a list'", "\n", "for", "layer_name", "in", "self", ".", "fixed_layers", "+", "self", ".", "random_layers", ":", "\n", "            ", "if", "layer_name", "not", "in", "model_handler", ".", "layer_names", ":", "\n", "                ", "raise", "ValueError", "(", "'layer name: {} not found in source model'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "# Get lists of parameters to fix and randomise", "\n", "", "", "fixed_params", "=", "model_handler", ".", "get_layer_parameters", "(", "self", ".", "fixed_layers", ")", "\n", "random_params", "=", "model_handler", ".", "get_layer_parameters", "(", "self", ".", "random_layers", ")", "\n", "\n", "# Drop layers", "\n", "model_handler", ".", "drop_layer_top", "(", "self", ".", "num_layers_to_drop", ")", "\n", "\n", "# Add fully connected layer and softmax output", "\n", "fc", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "name", "=", "'new_fully_connected_layer'", ",", "num_hidden", "=", "self", ".", "target_class_count", ")", "\n", "# Softmax layer name should be set to the name provided by the iterator", "\n", "softmax_name", "=", "train_iterator", ".", "provide_label", "[", "0", "]", "[", "0", "]", ".", "replace", "(", "'_label'", ",", "''", ")", "\n", "softmax", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "name", "=", "softmax_name", ")", "\n", "model_handler", ".", "add_layer_top", "(", "[", "fc", ",", "softmax", "]", ")", "\n", "\n", "# Create and return target MXNet module using the fixed/random parameters", "\n", "return", "model_handler", ".", "get_module", "(", "train_iterator", ",", "fixed_layer_parameters", "=", "fixed_params", ",", "\n", "random_layer_parameters", "=", "random_params", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer.__init__": [[51, 59], ["neural_network_repurposer.NeuralNetworkRepurposer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "transfer_layer_name", ",", "target_class_count", ",", "\n", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "batch_size", "=", "64", ",", "num_epochs", "=", "5", ",", "\n", "optimizer", "=", "'sgd'", ",", "optimizer_params", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "source_model", ",", "context_function", ",", "num_devices", ",", "batch_size", ",", "num_epochs", ",", "\n", "optimizer", ",", "optimizer_params", ")", "\n", "\n", "self", ".", "transfer_layer_name", "=", "transfer_layer_name", "\n", "self", ".", "target_class_count", "=", "target_class_count", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer.get_params": [[60, 70], ["super().get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "TRANSFER_LAYER_NAME", "]", "=", "self", ".", "transfer_layer_name", "\n", "param_dict", "[", "keys", ".", "TARGET_CLASS_COUNT", "]", "=", "self", ".", "target_class_count", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._create_target_module": [[71, 106], ["model_handler.model_handler.ModelHandler.model_handler.ModelHandler", "neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._get_target_symbol", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.update_sym", "mxnet.sym.FullyConnected", "[].replace", "mxnet.sym.SoftmaxOutput", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.add_layer_top", "model_handler.model_handler.ModelHandler.model_handler.ModelHandler.get_module"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._get_target_symbol", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_module"], ["", "def", "_create_target_module", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Function to create target module by transferring layers and weights of source model from input layer up to and\n        including layer 'transfer_layer_name'. A fully connected layer and softmax layer are added after the transfer\n        layer.\n\n        Overrides abstract method in base NeuralNetworkRepurposer class. Called by repurpose method in base class to\n        create target MXNet module that needs to be trained with target data set.\n\n        :param train_iterator: Training data iterator. Used by this function to bind target module\n        :type train_iterator: :class: `mxnet.io.DataIter`\n        :return: Target MXNet module created by transferring layers from source model\n        :rtype: :class:`mxnet.mod.Module`\n        \"\"\"", "\n", "\n", "# Create model handler to manipulate the source model", "\n", "model_handler", "=", "ModelHandler", "(", "self", ".", "source_model", ",", "self", ".", "context_function", ",", "self", ".", "num_devices", ")", "\n", "\n", "# Create target symbol by transferring layers from source model up to and including 'transfer_layer_name'", "\n", "target_symbol", "=", "self", ".", "_get_target_symbol", "(", "model_handler", ".", "layer_names", ")", "\n", "\n", "# Update model handler by replacing source symbol with target symbol", "\n", "# and cleaning up weights of layers that were not transferred", "\n", "model_handler", ".", "update_sym", "(", "target_symbol", ")", "\n", "\n", "# Add a fully connected layer (with nodes equal to number of target classes) and a softmax output layer on top", "\n", "fully_connected_layer", "=", "mx", ".", "sym", ".", "FullyConnected", "(", "num_hidden", "=", "self", ".", "target_class_count", ",", "\n", "name", "=", "'fc_from_fine_tune_repurposer'", ")", "\n", "# Softmax layer name should be set to the name provided by the iterator", "\n", "softmax_name", "=", "train_iterator", ".", "provide_label", "[", "0", "]", "[", "0", "]", ".", "replace", "(", "'_label'", ",", "''", ")", "\n", "softmax_output_layer", "=", "mx", ".", "sym", ".", "SoftmaxOutput", "(", "name", "=", "softmax_name", ")", "\n", "model_handler", ".", "add_layer_top", "(", "[", "fully_connected_layer", ",", "softmax_output_layer", "]", ")", "\n", "\n", "# Create and return target MXNet module using the new symbol and params", "\n", "return", "model_handler", ".", "get_module", "(", "train_iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer._get_target_symbol": [[107, 126], ["neural_network_fine_tune_repurposer.NeuralNetworkFineTuneRepurposer.source_model.symbol.get_internals", "ValueError"], "methods", ["None"], ["", "def", "_get_target_symbol", "(", "self", ",", "source_model_layer_names", ")", ":", "\n", "        ", "\"\"\"\n        Create target symbol with source_model layers from input layer up to and including 'transfer_layer_name'\n\n        :param source_model_layer_names: All layer names in source model. Used to check if transfer_layer_name is valid.\n\n        :return: target_symbol\n        :rtype: :class: `mx.symbol.Symbol`\n        \"\"\"", "\n", "# Check if 'transfer_layer_name' is present in source model", "\n", "if", "self", ".", "transfer_layer_name", "not", "in", "source_model_layer_names", ":", "\n", "            ", "raise", "ValueError", "(", "'transfer_layer_name: {} not found in source model'", ".", "format", "(", "self", ".", "transfer_layer_name", ")", ")", "\n", "\n", "# Create target symbol by transferring layers from source model up to 'transfer_layer_name'", "\n", "# Get layer key with output suffix to lookup MXNet symbol group", "\n", "", "transfer_layer_key", "=", "self", ".", "transfer_layer_name", "+", "'_output'", "\n", "source_symbol", "=", "self", ".", "source_model", ".", "symbol", ".", "get_internals", "(", ")", "\n", "target_symbol", "=", "source_symbol", "[", "transfer_layer_key", "]", "\n", "return", "target_symbol", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.__init__": [[77, 118], ["meta_model_repurposer.MetaModelRepurposer.__init__", "sklearn.preprocessing.Normalizer", "bnn_repurposer.BnnRepurposer.bnn_context_function", "float"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "feature_layer_names", ",", "context_function", "=", "mx", ".", "cpu", ",", "num_devices", "=", "1", ",", "\n", "bnn_context_function", "=", "mx", ".", "cpu", ",", "sigma", "=", "100.0", ",", "num_layers", "=", "1", ",", "n_hidden", "=", "10", ",", "num_samples_mc", "=", "3", ",", "\n", "learning_rate", "=", "1e-3", ",", "batch_size", "=", "20", ",", "num_epochs", "=", "200", ",", "start_annealing", "=", "None", ",", "end_annealing", "=", "None", ",", "\n", "num_samples_mc_prediction", "=", "100", ",", "verbose", "=", "0", ")", ":", "\n", "\n", "# Call base class constructor with parameters required for meta-models", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "source_model", ",", "feature_layer_names", ",", "context_function", ",", "num_devices", ")", "\n", "\n", "# Initialize BNN specific parameters", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "num_samples_mc", "=", "num_samples_mc", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "num_epochs", "=", "num_epochs", "\n", "self", ".", "num_samples_mc_prediction", "=", "num_samples_mc_prediction", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "start_annealing", "=", "start_annealing", "\n", "self", ".", "end_annealing", "=", "end_annealing", "\n", "self", ".", "step_annealing_sample_weight", "=", "1.0", "/", "float", "(", "self", ".", "end_annealing", "-", "self", ".", "start_annealing", ")", "\n", "self", ".", "annealing_weight", "=", "0.0", "\n", "\n", "# Initialize variables to track performance", "\n", "self", ".", "train_acc", "=", "[", "]", "\n", "self", ".", "test_acc", "=", "[", "]", "\n", "self", ".", "moving_loss_total", "=", "[", "]", "\n", "self", ".", "current_loss_total", "=", "[", "]", "\n", "self", ".", "average_loss", "=", "[", "]", "\n", "self", ".", "anneal_weights", "=", "[", "]", "\n", "\n", "# L2 normalization of the features", "\n", "self", ".", "normalizer", "=", "Normalizer", "(", "norm", "=", "'l2'", ")", "\n", "\n", "self", ".", "bnn_context_function", "=", "bnn_context_function", "\n", "self", ".", "_context_bnn", "=", "self", ".", "bnn_context_function", "(", ")", "\n", "\n", "# init parameters for constructing network to None. These will be set during repurposing", "\n", "self", ".", "dim_input", "=", "None", "\n", "self", ".", "num_classes", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.get_params": [[119, 139], ["super().get_params", "utils.serialize_ctx_fn"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor.\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "super", "(", ")", ".", "get_params", "(", ")", "\n", "param_dict", "[", "keys", ".", "BNN_CONTEXT_FUNCTION", "]", "=", "utils", ".", "serialize_ctx_fn", "(", "self", ".", "bnn_context_function", ")", "\n", "param_dict", "[", "keys", ".", "SIGMA", "]", "=", "self", ".", "sigma", "\n", "param_dict", "[", "keys", ".", "NUM_LAYERS", "]", "=", "self", ".", "num_layers", "\n", "param_dict", "[", "keys", ".", "N_HIDDEN", "]", "=", "self", ".", "n_hidden", "\n", "param_dict", "[", "keys", ".", "NUM_SAMPLES_MC", "]", "=", "self", ".", "num_samples_mc", "\n", "param_dict", "[", "keys", ".", "LEARNING_RATE", "]", "=", "self", ".", "learning_rate", "\n", "param_dict", "[", "keys", ".", "BATCH_SIZE", "]", "=", "self", ".", "batch_size", "\n", "param_dict", "[", "keys", ".", "NUM_EPOCHS", "]", "=", "self", ".", "num_epochs", "\n", "param_dict", "[", "keys", ".", "START_ANNEALING", "]", "=", "self", ".", "start_annealing", "\n", "param_dict", "[", "keys", ".", "END_ANNEALING", "]", "=", "self", ".", "end_annealing", "\n", "param_dict", "[", "keys", ".", "VERBOSE", "]", "=", "self", ".", "verbose", "\n", "param_dict", "[", "keys", ".", "NUM_SAMPLES_MC_PREDICT", "]", "=", "self", ".", "num_samples_mc_prediction", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_attributes": [[140, 151], ["super()._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "_get_attributes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer not in constructor.\n\n        :rtype: dict\n        \"\"\"", "\n", "attr_dict", "=", "super", "(", ")", ".", "_get_attributes", "(", ")", "\n", "attr_dict", "[", "keys", ".", "ANNEALING_WEIGHT", "]", "=", "self", ".", "annealing_weight", "\n", "attr_dict", "[", "keys", ".", "DIM_INPUT", "]", "=", "self", ".", "dim_input", "\n", "attr_dict", "[", "keys", ".", "NUM_CLASSES", "]", "=", "self", ".", "num_classes", "\n", "return", "attr_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._set_attributes": [[152, 164], ["super()._set_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes"], ["", "def", "_set_attributes", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Set attributes of class from input_dict.\n        These attributes are the same as those returned by get_attributes method.\n\n        :param input_dict: Dictionary containing attribute values.\n        :return: None\n        \"\"\"", "\n", "super", "(", ")", ".", "_set_attributes", "(", "input_dict", ")", "\n", "self", ".", "annealing_weight", "=", "input_dict", "[", "keys", ".", "ANNEALING_WEIGHT", "]", "\n", "self", ".", "dim_input", "=", "input_dict", "[", "keys", ".", "DIM_INPUT", "]", "\n", "self", ".", "num_classes", "=", "input_dict", "[", "keys", ".", "NUM_CLASSES", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.start_annealing": [[172, 182], ["int", "int", "ValueError"], "methods", ["None"], ["", "@", "start_annealing", ".", "setter", "\n", "def", "start_annealing", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "value", "is", "None", ":", "\n", "            ", "self", ".", "_start_annealing", "=", "int", "(", "0.1", "*", "self", ".", "num_epochs", ")", "\n", "", "else", ":", "\n", "            ", "if", "value", ">=", "self", ".", "num_epochs", ":", "\n", "                ", "error", "=", "(", "\"start_annealing must be smaller than the number of epochs.\"", "\n", "\" Instead got start_annealing = {}, number of epochs = {}.\"", ".", "format", "(", "value", ",", "self", ".", "num_epochs", ")", ")", "\n", "raise", "ValueError", "(", "error", ")", "\n", "", "self", ".", "_start_annealing", "=", "int", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.end_annealing": [[190, 206], ["int", "int", "ValueError", "ValueError", "max"], "methods", ["None"], ["", "@", "end_annealing", ".", "setter", "\n", "def", "end_annealing", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "value", "is", "None", ":", "\n", "            ", "self", ".", "_end_annealing", "=", "self", ".", "start_annealing", "+", "int", "(", "max", "(", "0.1", "*", "self", ".", "num_epochs", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "if", "value", ">", "self", ".", "num_epochs", ":", "\n", "                ", "error", "=", "(", "\"end_annealing must be smaller than the number of epochs.\"", "\n", "\" Instead got end_annealing = {}, number of epochs = {}.\"", ".", "format", "(", "value", ",", "self", ".", "num_epochs", ")", ")", "\n", "raise", "ValueError", "(", "error", ")", "\n", "\n", "", "if", "value", "<=", "self", ".", "start_annealing", ":", "\n", "                ", "error", "=", "(", "\"end_annealing must be greater than start_annealing.\"", "\n", "\" Instead got start_annealing = {}, end_annealing = {}.\"", ".", "format", "(", "self", ".", "start_annealing", ",", "value", ")", ")", "\n", "raise", "ValueError", "(", "error", ")", "\n", "\n", "", "self", ".", "_end_annealing", "=", "int", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._build_nn": [[207, 218], ["next", "bnn_repurposer.BnnRepurposer._get_net", "bnn_repurposer.BnnRepurposer._get_shapes", "enumerate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_net", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_shapes"], ["", "", "def", "_build_nn", "(", "self", ",", "train_data", ",", "num_classes", ")", ":", "\n", "        ", "_", ",", "(", "data", ",", "_", ")", "=", "next", "(", "enumerate", "(", "train_data", ")", ")", "\n", "dim_input", "=", "data", ".", "shape", "[", "1", "]", "\n", "net", "=", "self", ".", "_get_net", "(", "num_classes", ")", "\n", "shapes", "=", "self", ".", "_get_shapes", "(", "net", ",", "data", ",", "dim_input", ")", "\n", "\n", "# save parameters used for constructing network", "\n", "self", ".", "dim_input", "=", "dim_input", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "return", "net", ",", "shapes", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_net": [[219, 228], ["mxnet.gluon.nn.Sequential", "mxnet.gluon.nn.Sequential", "mxnet.gluon.nn.Sequential.collect_params().initialize", "mxnet.gluon.nn.Sequential.name_scope", "range", "mxnet.gluon.nn.Sequential.add", "mxnet.init.Xavier", "mxnet.init.Xavier", "mxnet.gluon.nn.Sequential.add", "mxnet.gluon.nn.Dense", "mxnet.gluon.nn.Dense", "mxnet.gluon.nn.Sequential.collect_params", "mxnet.gluon.nn.Dense", "mxnet.gluon.nn.Dense"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["", "def", "_get_net", "(", "self", ",", "num_classes", ")", ":", "\n", "        ", "net", "=", "gluon", ".", "nn", ".", "Sequential", "(", ")", "\n", "with", "net", ".", "name_scope", "(", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "                ", "net", ".", "add", "(", "gluon", ".", "nn", ".", "Dense", "(", "self", ".", "n_hidden", ",", "activation", "=", "\"relu\"", ")", ")", "\n", "", "net", ".", "add", "(", "gluon", ".", "nn", ".", "Dense", "(", "num_classes", ")", ")", "\n", "# Init parameters", "\n", "", "net", ".", "collect_params", "(", ")", ".", "initialize", "(", "mx", ".", "init", ".", "Xavier", "(", "magnitude", "=", "2.24", ")", ",", "ctx", "=", "self", ".", "_context_bnn", ")", "\n", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_shapes": [[229, 235], ["data.as_in_context().reshape.as_in_context().reshape.as_in_context().reshape", "net", "data.as_in_context().reshape.as_in_context().reshape.as_in_context", "net.collect_params().values", "net.collect_params"], "methods", ["None"], ["", "def", "_get_shapes", "(", "self", ",", "net", ",", "data", ",", "dim_input", ")", ":", "\n", "# first pass to init size params", "\n", "        ", "data", "=", "data", ".", "as_in_context", "(", "self", ".", "_context_bnn", ")", ".", "reshape", "(", "(", "-", "1", ",", "dim_input", ")", ")", "\n", "net", "(", "data", ")", "\n", "shapes", "=", "[", "x", ".", "shape", "for", "x", "in", "net", ".", "collect_params", "(", ")", ".", "values", "(", ")", "]", "\n", "return", "shapes", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._update_annealing_weight": [[236, 239], ["None"], "methods", ["None"], ["", "def", "_update_annealing_weight", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "if", "(", "epoch", ">", "self", ".", "start_annealing", ")", "and", "(", "epoch", "<=", "self", ".", "end_annealing", ")", ":", "\n", "            ", "self", ".", "annealing_weight", "+=", "self", ".", "step_annealing_sample_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._compute_loss_grad": [[240, 249], ["mxnet.autograd.record", "mxnet.autograd.record", "bnn_loss", "bnn_loss.backward"], "methods", ["None"], ["", "", "def", "_compute_loss_grad", "(", "self", ",", "data", ",", "label_one_hot", ",", "num_train", ",", "net", ",", "bnn_loss", ")", ":", "\n", "        ", "with", "autograd", ".", "record", "(", ")", ":", "\n", "# calculate the loss", "\n", "# Note: It triggers the hybrid_forward method of the bnn_loss object", "\n", "            ", "loss", "=", "bnn_loss", "(", "data", ",", "net", ",", "label_one_hot", ",", "self", ".", "num_samples_mc", ",", "\n", "num_train", ",", "self", ".", "annealing_weight", ")", "\n", "# back-propagate for gradient calculation", "\n", "loss", ".", "backward", "(", ")", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._evaluate_accuracy": [[250, 262], ["enumerate", "data.as_in_context().reshape.as_in_context().reshape.as_in_context().reshape", "label.as_in_context.as_in_context.as_in_context", "prob.utils.replace_params_net", "net", "mxnet.argmax", "mxnet.argmax", "mxnet.sum", "mxnet.sum", "data.as_in_context().reshape.as_in_context().reshape.as_in_context"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.replace_params_net"], ["", "def", "_evaluate_accuracy", "(", "self", ",", "data_iterator", ",", "net", ",", "layer_params", ")", ":", "\n", "        ", "numerator", "=", "0.", "\n", "denominator", "=", "0.", "\n", "for", "i", ",", "(", "data", ",", "label", ")", "in", "enumerate", "(", "data_iterator", ")", ":", "\n", "            ", "data", "=", "data", ".", "as_in_context", "(", "self", ".", "_context_bnn", ")", ".", "reshape", "(", "(", "-", "1", ",", "data", ".", "shape", "[", "1", "]", ")", ")", "\n", "label", "=", "label", ".", "as_in_context", "(", "self", ".", "_context_bnn", ")", "\n", "replace_params_net", "(", "layer_params", ",", "net", ",", "self", ".", "_context_bnn", ")", "\n", "output", "=", "net", "(", "data", ")", "\n", "predictions", "=", "nd", ".", "argmax", "(", "output", ",", "axis", "=", "1", ")", "\n", "numerator", "+=", "nd", ".", "sum", "(", "predictions", "==", "label", ")", "\n", "denominator", "+=", "data", ".", "shape", "[", "0", "]", "\n", "", "return", "(", "numerator", "/", "denominator", ")", ".", "asscalar", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._monitor_acc": [[263, 280], ["bnn_repurposer.BnnRepurposer._evaluate_accuracy", "bnn_repurposer.BnnRepurposer.train_acc.append", "numpy.asscalar", "logging.info", "bnn_repurposer.BnnRepurposer._evaluate_accuracy", "bnn_repurposer.BnnRepurposer.test_acc.append", "numpy.asscalar", "logging.info"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._evaluate_accuracy", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._evaluate_accuracy"], ["", "def", "_monitor_acc", "(", "self", ",", "epoch", ",", "train_data", ",", "net", ",", "posterior_mean", ",", "test_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Monitor accuracy on training set and test set (if provided).\n        \"\"\"", "\n", "train_accuracy", "=", "self", ".", "_evaluate_accuracy", "(", "train_data", ",", "net", ",", "posterior_mean", ")", "\n", "self", ".", "train_acc", ".", "append", "(", "np", ".", "asscalar", "(", "train_accuracy", ")", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "logging", ".", "info", "(", "\"Epoch {}. Train Loss: {}, Train_acc {}\"", ".", "format", "(", "epoch", ",", "self", ".", "average_loss", "[", "-", "1", "]", ",", "\n", "self", ".", "train_acc", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "if", "test_data", "is", "not", "None", ":", "\n", "            ", "test_accuracy", "=", "self", ".", "_evaluate_accuracy", "(", "test_data", ",", "net", ",", "posterior_mean", ")", "\n", "self", ".", "test_acc", ".", "append", "(", "np", ".", "asscalar", "(", "test_accuracy", ")", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "logging", ".", "info", "(", "\"Epoch {}. Train Loss: {}, Train_acc {}, Test_acc {}\"", ".", "format", "(", "epoch", ",", "self", ".", "average_loss", "[", "-", "1", "]", ",", "\n", "self", ".", "train_acc", "[", "-", "1", "]", ",", "\n", "self", ".", "test_acc", "[", "-", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._train_model_from_features": [[281, 355], ["features.astype", "bnn_repurposer.BnnRepurposer.normalizer.fit_transform", "labels.astype", "len", "mxnet.gluon.data.DataLoader", "mxnet.gluon.data.DataLoader", "sum", "bnn_repurposer.BnnRepurposer._build_nn", "prob.GaussianPrior", "prob.GaussianVariationalPosterior", "prob.Categorical", "prob.BNNLoss", "mxnet.gluon.Trainer", "mxnet.gluon.Trainer", "range", "bnn_classifier.BnnClassifier", "numpy.dtype", "numpy.dtype", "set", "mxnet.gluon.data.ArrayDataset", "mxnet.gluon.data.ArrayDataset", "bnn_repurposer.BnnRepurposer._update_annealing_weight", "enumerate", "bnn_repurposer.BnnRepurposer.anneal_weights.append", "bnn_repurposer.BnnRepurposer.moving_loss_total.append", "bnn_repurposer.BnnRepurposer.current_loss_total.append", "bnn_repurposer.BnnRepurposer.average_loss.append", "bnn_repurposer.BnnRepurposer._monitor_acc", "numpy.array", "numpy.array", "data.as_in_context().reshape.as_in_context().reshape.as_in_context().reshape", "label.as_in_context.as_in_context.as_in_context", "mxnet.one_hot", "mxnet.one_hot", "bnn_repurposer.BnnRepurposer._compute_loss_grad", "mxnet.gluon.Trainer.step", "mxnet.mean().asscalar", "mxnet.mean().asscalar", "prob.GaussianVariationalPosterior.get_mean", "prob.GaussianVariationalPosterior.get_params_list", "prob.GaussianPrior.get_params_list", "float", "data.as_in_context().reshape.as_in_context().reshape.as_in_context", "mxnet.mean", "mxnet.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._build_nn", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._update_annealing_weight", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._monitor_acc", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._compute_loss_grad", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.get_mean", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.get_params_list", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.get_params_list"], ["", "", "", "def", "_train_model_from_features", "(", "self", ",", "features", ",", "labels", ",", "feature_indices_per_layer", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Train a BNN model using features extracted from source neural network.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :param labels: Labels to use for training.\n        :type labels: :class:`numpy.ndarray`\n        :param feature_indices_per_layer: Mapping of feature_layer_names to indices in features array\n        i.e. {layer_name, feature_indices} Note that this param is currently not consumed by bnn_repurposer.\n        :type feature_indices_per_layer: OrderedDict[str, :class:`numpy.ndarray`]\n        :return: BNN model trained with given features and labels.\n        :rtype: :class: `xfer.bnn_classifier.BnnClassifier`\n        \"\"\"", "\n", "\n", "# Load data", "\n", "x_tr", "=", "features", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float32", ")", ")", "\n", "x_tr", "=", "self", ".", "normalizer", ".", "fit_transform", "(", "x_tr", ")", "\n", "y_tr", "=", "labels", ".", "astype", "(", "np", ".", "dtype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "num_classes", "=", "len", "(", "set", "(", "y_tr", ")", ")", "\n", "\n", "train_data", "=", "gluon", ".", "data", ".", "DataLoader", "(", "gluon", ".", "data", ".", "ArrayDataset", "(", "x_tr", ",", "y_tr", ")", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ")", "\n", "num_train", "=", "sum", "(", "[", "self", ".", "batch_size", "for", "_", "in", "train_data", "]", ")", "\n", "\n", "# Build net and initialize parameters", "\n", "net", ",", "shapes", "=", "self", ".", "_build_nn", "(", "train_data", ",", "num_classes", ")", "\n", "\n", "# Create Prior, variational posterior and observation model", "\n", "prior", "=", "GaussianPrior", "(", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", "]", ",", "[", "np", ".", "array", "(", "[", "[", "self", ".", "sigma", "]", "]", ")", "]", ",", "shapes", ",", "self", ".", "_context_bnn", ")", "\n", "var_posterior", "=", "GaussianVariationalPosterior", "(", "mean_init", "=", "consts", ".", "MEAN_INIT_POSTERIOR", ",", "\n", "sigma_init", "=", "consts", ".", "SIGMA_INIT_POSTERIOR", ",", "shapes", "=", "shapes", ",", "\n", "ctx", "=", "self", ".", "_context_bnn", ")", "\n", "obs_model", "=", "Categorical", "(", "self", ".", "_context_bnn", ")", "\n", "\n", "# Build loss (negative of the ELBO)", "\n", "bnn_loss", "=", "BNNLoss", "(", "prior", "=", "prior", ",", "obs_model", "=", "obs_model", ",", "var_posterior", "=", "var_posterior", ")", "\n", "\n", "# Training", "\n", "\n", "trainer", "=", "gluon", ".", "Trainer", "(", "params", "=", "var_posterior", ".", "get_params_list", "(", ")", "+", "prior", ".", "get_params_list", "(", ")", ",", "\n", "optimizer", "=", "consts", ".", "BNN_OPTIMIZER", ",", "optimizer_params", "=", "{", "'learning_rate'", ":", "self", ".", "learning_rate", "}", ")", "\n", "smoothing_constant", "=", ".01", "\n", "moving_loss", "=", "0.0", "\n", "for", "e", "in", "range", "(", "self", ".", "num_epochs", ")", ":", "\n", "            ", "self", ".", "_update_annealing_weight", "(", "e", ")", "\n", "\n", "curr_loss_total", "=", "0.0", "\n", "for", "i", ",", "(", "data", ",", "label", ")", "in", "enumerate", "(", "train_data", ")", ":", "\n", "                ", "data", "=", "data", ".", "as_in_context", "(", "self", ".", "_context_bnn", ")", ".", "reshape", "(", "(", "-", "1", ",", "data", ".", "shape", "[", "1", "]", ")", ")", "\n", "label", "=", "label", ".", "as_in_context", "(", "self", ".", "_context_bnn", ")", "\n", "label_one_hot", "=", "nd", ".", "one_hot", "(", "label", ",", "num_classes", ")", "\n", "\n", "loss", "=", "self", ".", "_compute_loss_grad", "(", "data", ",", "label_one_hot", ",", "num_train", ",", "net", ",", "bnn_loss", ")", "\n", "\n", "trainer", ".", "step", "(", "data", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# calculate moving loss for monitoring convergence", "\n", "curr_loss", "=", "nd", ".", "mean", "(", "loss", ")", ".", "asscalar", "(", ")", "\n", "curr_loss_total", "=", "curr_loss_total", "+", "curr_loss", "\n", "moving_loss", "=", "(", "curr_loss", "if", "(", "(", "i", "==", "0", ")", "and", "(", "e", "==", "0", ")", ")", "\n", "else", "(", "1", "-", "smoothing_constant", ")", "*", "moving_loss", "+", "smoothing_constant", "*", "curr_loss", ")", "\n", "\n", "", "self", ".", "anneal_weights", ".", "append", "(", "self", ".", "annealing_weight", ")", "\n", "self", ".", "moving_loss_total", ".", "append", "(", "moving_loss", ")", "\n", "self", ".", "current_loss_total", ".", "append", "(", "curr_loss", ")", "\n", "self", ".", "average_loss", ".", "append", "(", "curr_loss_total", "/", "float", "(", "num_train", ")", ")", "\n", "\n", "# Monitor accuracy on training set and test set (if provided)", "\n", "#: as self.verbose in the constructor", "\n", "self", ".", "_monitor_acc", "(", "e", ",", "train_data", ",", "net", ",", "var_posterior", ".", "get_mean", "(", ")", ")", "\n", "\n", "", "return", "BnnClassifier", "(", "net", ",", "var_posterior", ",", "self", ".", "normalizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_probability_from_features": [[356, 367], ["bnn_repurposer.BnnRepurposer.target_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "_predict_probability_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use xfer.bnn_classifier.BnnClassifier's predict method and return predicted probabilities.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted probabilities.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "return", "self", ".", "target_model", ".", "predict", "(", "features", ",", "self", ".", "num_samples_mc_prediction", ",", "context", "=", "self", ".", "_context_bnn", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._predict_label_from_features": [[368, 379], ["bnn_repurposer.BnnRepurposer.target_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["", "def", "_predict_label_from_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Run predictions with target_model on features extracted from source neural network.\n        Use xfer.bnn_classifier.BnnClassifier's predict method and return predicted labels.\n\n        :param features: Features extracted from source neural network.\n        :type features: :class:`numpy.ndarray`\n        :return: Predicted labels.\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"", "\n", "return", "self", ".", "target_model", ".", "predict", "(", "features", ",", "self", ".", "num_samples_mc_prediction", ",", "context", "=", "self", ".", "_context_bnn", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.serialize": [[380, 394], ["bnn_repurposer.BnnRepurposer.get_params", "output_dict.update", "utils.save_json", "bnn_repurposer.BnnRepurposer.target_model.var_posterior.save", "bnn_repurposer.BnnRepurposer._get_attributes"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes"], ["", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Saves repurposer (excluding source model) to file_prefix.json, file_prefix_posterior.json,\n        file_prefix_posterior_params.npz.\n\n        :param str file_prefix: Prefix to save file with.\n        \"\"\"", "\n", "output_dict", "=", "{", "}", "\n", "output_dict", "[", "repurposer_keys", ".", "PARAMS", "]", "=", "self", ".", "get_params", "(", ")", "\n", "output_dict", ".", "update", "(", "self", ".", "_get_attributes", "(", ")", ")", "\n", "\n", "utils", ".", "save_json", "(", "file_prefix", ",", "output_dict", ")", "\n", "\n", "self", ".", "target_model", ".", "var_posterior", ".", "save", "(", "file_prefix", "+", "serialization_constants", ".", "POSTERIOR_SUFFIX", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer.deserialize": [[395, 413], ["bnn_repurposer.BnnRepurposer._set_attributes", "prob.GaussianVariationalPosterior.load", "bnn_repurposer.BnnRepurposer._get_net", "bnn_repurposer.BnnRepurposer.", "bnn_classifier.BnnClassifier", "mxnet.ndarray.zeros", "mxnet.ndarray.zeros"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.xfer.bnn_repurposer.BnnRepurposer._get_net"], ["", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Uses dictionary to set attributes of repurposer.\n\n        :param dict input_dict: Dictionary containing values for attributes to be set to.\n        \"\"\"", "\n", "# Set attributes of the repurposer from input_dict", "\n", "self", ".", "_set_attributes", "(", "input_dict", ")", "\n", "\n", "# Deserialize the target bnn model", "\n", "var_posterior", "=", "GaussianVariationalPosterior", ".", "load", "(", "input_dict", "[", "serialization_keys", ".", "FILE_PATH", "]", "+", "\n", "serialization_constants", ".", "POSTERIOR_SUFFIX", ")", "\n", "net", "=", "self", ".", "_get_net", "(", "self", ".", "num_classes", ")", "\n", "\n", "# Make a forward pass to initialize parameter shapes for the network", "\n", "net", "(", "mx", ".", "ndarray", ".", "zeros", "(", "shape", "=", "(", "self", ".", "batch_size", ",", "self", ".", "dim_input", ")", ")", ")", "\n", "\n", "self", ".", "target_model", "=", "BnnClassifier", "(", "net", ",", "var_posterior", ",", "self", ".", "normalizer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_to_dict": [[23, 48], ["copy.deepcopy", "target_model.get_params", "isinstance", "isinstance", "str", "model_dict[].tolist", "list"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["def", "sklearn_model_to_dict", "(", "target_model", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.sklearn_model_from_dict": [[50, 68], ["model_class", "isinstance", "isinstance", "setattr", "type", "setattr", "eval", "setattr", "tuple", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval"], ["", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils._assert_repurposer_file_exists": [[70, 74], ["os.path.isfile", "NameError"], "function", ["None"], ["", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_mxnet_model": [[76, 82], ["model.save_checkpoint", "model.bind", "ValueError"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.save_checkpoint"], ["", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n", "    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_json": [[84, 87], ["open", "json.dump"], "function", ["None"], ["", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn": [[89, 96], ["ValueError"], "function", ["None"], ["", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.deserialize_ctx_fn": [[98, 105], ["ValueError"], "function", ["None"], ["", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n", "", "elif", "context_function", "==", "keys", ".", "GPU", ":", "\n", "        ", "return", "mx", ".", "gpu", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.__init__": [[37, 45], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "source_model", ":", "mx", ".", "mod", ".", "Module", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ")", ":", "\n", "        ", "self", ".", "source_model", "=", "source_model", "\n", "self", ".", "context_function", "=", "context_function", "\n", "self", ".", "num_devices", "=", "num_devices", "\n", "self", ".", "target_model", "=", "None", "\n", "self", ".", "_save_source_model_default", "=", "None", "\n", "self", ".", "provide_data", "=", "None", "\n", "self", ".", "provide_label", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.repurpose": [[46, 52], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "repurpose", "(", "self", ",", "train_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_probability": [[53, 59], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict_probability", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.predict_label": [[60, 66], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict_label", "(", "self", ",", "test_iterator", ":", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params": [[67, 77], ["utils.serialize_ctx_fn"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.serialize_ctx_fn"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer that are in the constructor's argument list.\n\n        :rtype: dict\n        \"\"\"", "\n", "param_dict", "=", "{", "}", "\n", "param_dict", "[", "keys", ".", "CONTEXT_FN", "]", "=", "utils", ".", "serialize_ctx_fn", "(", "self", ".", "context_function", ")", "\n", "param_dict", "[", "keys", ".", "NUM_DEVICES", "]", "=", "self", ".", "num_devices", "\n", "return", "param_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._get_attributes": [[78, 91], ["model_handler.ModelHandler"], "methods", ["None"], ["", "def", "_get_attributes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get parameters of repurposer not in constructor's argument list.\n\n        :rtype: dict\n        \"\"\"", "\n", "attr_dict", "=", "{", "}", "\n", "attr_dict", "[", "keys", ".", "PROVIDE_DATA", "]", "=", "self", ".", "provide_data", "\n", "attr_dict", "[", "keys", ".", "PROVIDE_LABEL", "]", "=", "self", ".", "provide_label", "\n", "attr_dict", "[", "serialization_keys", ".", "VERSION", "]", "=", "constants", ".", "VERSION", "\n", "attr_dict", "[", "keys", ".", "REPURPOSER_CLASS", "]", "=", "self", ".", "__class__", ".", "__name__", "\n", "attr_dict", "[", "serialization_keys", ".", "LAST_LAYER_NAME_SOURCE", "]", "=", "ModelHandler", "(", "self", ".", "source_model", ")", ".", "layer_names", "[", "-", "1", "]", "\n", "return", "attr_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._set_attributes": [[92, 108], ["warnings.warn"], "methods", ["None"], ["", "def", "_set_attributes", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Set attributes of class from input_dict.\n        These attributes are the same as those returned by get_attributes method.\n\n        :param input_dict: Dictionary containing attribute values.\n        :return: None\n        \"\"\"", "\n", "\n", "# Raise warning if there is a version mismatch with the Xfer version saved in input_dict", "\n", "if", "not", "constants", ".", "VERSION", "==", "input_dict", "[", "serialization_keys", ".", "VERSION", "]", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"Running Xfer version: {} which is different from version saved in dictionary: {}. \"", "\n", "\"Ensure that you are using the correct version of Xfer\"", "\n", ".", "format", "(", "constants", ".", "VERSION", ",", "input_dict", "[", "serialization_keys", ".", "VERSION", "]", ")", ")", "\n", "", "self", ".", "provide_data", "=", "input_dict", "[", "keys", ".", "PROVIDE_DATA", "]", "\n", "self", ".", "provide_label", "=", "input_dict", "[", "keys", ".", "PROVIDE_LABEL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.serialize": [[109, 115], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "serialize", "(", "self", ",", "file_prefix", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.deserialize": [[116, 122], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "deserialize", "(", "self", ",", "input_dict", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.save_repurposer": [[123, 143], ["os.path.join", "repurposer.Repurposer._save_source_model", "repurposer.Repurposer.serialize", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._save_source_model", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.serialize"], ["", "def", "save_repurposer", "(", "self", ",", "model_name", ",", "model_directory", "=", "''", ",", "save_source_model", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Serialize the repurposed model (source_model, target_model and supporting info) and save it to given file_path.\n\n        :param str model_name: Name to save repurposer to.\n        :param str model_directory: File directory to save repurposer in.\n        :param boolean save_source_model: Flag to choose whether to save repurposer source model.\n                                          Will use default if set to None. (MetaModelRepurposer default: True,\n                                          NeuralNetworkRepurposer default: False)\n        \"\"\"", "\n", "# Assert repurpose() has been called successfully", "\n", "if", "self", ".", "target_model", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot save repurposer before source model has been repurposed'", ")", "\n", "\n", "", "file_prefix", "=", "os", ".", "path", ".", "join", "(", "model_directory", ",", "model_name", ")", "\n", "\n", "self", ".", "_save_source_model", "(", "file_prefix", ",", "save_source_model", ")", "\n", "\n", "# Serialize remainder of repurposer", "\n", "self", ".", "serialize", "(", "file_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._save_source_model": [[144, 151], ["utils.save_mxnet_model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.xfer.utils.save_mxnet_model"], ["", "def", "_save_source_model", "(", "self", ",", "file_prefix", ",", "save_source_model", ")", ":", "\n", "# Set save_source_model flag to class default if None", "\n", "        ", "save_source_model", "=", "self", ".", "_save_source_model_default", "if", "save_source_model", "is", "None", "else", "save_source_model", "\n", "if", "save_source_model", ":", "\n", "# save source_model as file-path_source-symbol.json and file-path_source-0000.params", "\n", "            ", "utils", ".", "save_mxnet_model", "(", "self", ".", "source_model", ",", "file_prefix", "+", "serialization_constants", ".", "SOURCE_SUFFIX", ",", "0", ",", "\n", "self", ".", "provide_data", ",", "self", ".", "provide_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_repurpose": [[152, 157], ["isinstance", "TypeError", "type"], "methods", ["None"], ["", "", "def", "_validate_before_repurpose", "(", "self", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "self", ".", "source_model", ",", "mx", ".", "mod", ".", "Module", ")", ":", "\n", "            ", "error", "=", "(", "\"Cannot repurpose because source_model is not an `mxnet.mod.Module` object.\"", "\n", "\" Instead got type: {}\"", ".", "format", "(", "type", "(", "self", ".", "source_model", ")", ")", ")", "\n", "raise", "TypeError", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer._validate_before_predict": [[158, 161], ["ValueError"], "methods", ["None"], ["", "", "def", "_validate_before_predict", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "target_model", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Cannot predict because target_model is not initialized\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.__init__": [[37, 52], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "shapes", ",", "ctx", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Default constructor\n\n        :param shapes: Shape of the variables over which the probability is defined.\n        :type shapes: list(tuple(int, int))\n        :param ctx: MXNet context\n        :type ctx: :class:`mxnet.Context`\n        \"\"\"", "\n", "\n", "self", ".", "ctx", "=", "ctx", "\n", "self", ".", "params", "=", "{", "}", "\n", "self", ".", "raw_params", "=", "{", "}", "\n", "self", ".", "shapes", "=", "shapes", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.get_params_list": [[53, 61], ["sorted"], "methods", ["None"], ["", "def", "get_params_list", "(", "self", ")", ":", "\n", "# Each element of the dictionary contains a parameter (list(nd.array)). This method", "\n", "# iterates over all the elements in the dictionary and outputs a single list(nd.array) containing", "\n", "# all parameters. The dictionary is sorted beforehand so the output is deterministic and the", "\n", "# method can be tested.", "\n", "        ", "return", "[", "x", "\n", "for", "kk", "in", "sorted", "(", "self", ".", "params", ")", "\n", "for", "x", "in", "self", ".", "params", "[", "kk", "]", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes": [[63, 68], ["ValueError"], "methods", ["None"], ["", "def", "check_observation_shapes", "(", "self", ",", "obs", ")", ":", "\n", "        ", "shape_obs", "=", "[", "o", ".", "shape", "for", "o", "in", "obs", "]", "\n", "if", "not", "self", ".", "shapes", "==", "shape_obs", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of observed variables {} does not match \\\n             the number of expected observed variables {}\"", ".", "format", "(", "shape_obs", ",", "self", ".", "shapes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.log_pdf": [[69, 71], ["None"], "methods", ["None"], ["", "", "def", "log_pdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.KL": [[72, 80], ["None"], "methods", ["None"], ["", "def", "KL", "(", "self", ",", "other_prob", ")", ":", "\n", "        ", "\"\"\"\n        Function to compute the KL divergence between self and a second Probability\n\n        :param other_prob: The probability object that we want to compute th KL distance to\n        :type other_prob: :class:`xfer.prob.Probability`\n        \"\"\"", "\n", "raise", "NotImplemented", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.KL_sample": [[81, 91], ["prob_base.Probability.log_pdf", "other_prob.log_pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf"], ["", "def", "KL_sample", "(", "self", ",", "other_prob", ",", "sample", ")", ":", "\n", "        ", "\"\"\"\n        Function to compute the KL divergence between a sample of self and a sample of a second Probability\n\n        :param other_prob: The probability that we want to compute the KL distance to\n        :type other_prob: :class:`xfer.prob.Probability`\n        :param sample: Sample used to compute the KL\n        list[:class:`np.ndarray`]\n        \"\"\"", "\n", "return", "self", ".", "log_pdf", "(", "sample", ")", "-", "other_prob", ".", "log_pdf", "(", "sample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req": [[92, 107], ["isinstance"], "methods", ["None"], ["", "def", "_parse_grad_req", "(", "self", ",", "fix", ",", "num_parameters", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param fix: define for each parameter whether the gradient is computed  (True) or\n            not (False). If it is a scalar, the value is replicated num_parameters times.\n        :type fix: boolean or list(boolean)\n        :return: define for each parameter whether the gradient is computed  (\"write\") or not (\"null\")\n        :rtype: list[string]\n        \"\"\"", "\n", "if", "isinstance", "(", "fix", ",", "list", ")", ":", "\n", "            ", "grad_req", "=", "[", "NULL", "if", "f", "else", "WRITE", "for", "f", "in", "fix", "]", "\n", "", "elif", "fix", ":", "\n", "            ", "grad_req", "=", "[", "NULL", "]", "*", "num_parameters", "\n", "", "else", ":", "\n", "            ", "grad_req", "=", "[", "WRITE", "]", "*", "num_parameters", "\n", "", "return", "grad_req", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param": [[108, 132], ["prob_base.Probability._parse_grad_req", "zip", "len", "mxnet.gluon.Parameter", "mxnet.gluon.Parameter.initialize", "par_list.append", "x.data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["", "def", "_register_param", "(", "self", ",", "name", ",", "init", ",", "fix", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Register a set of parameters using \"init\".\n\n        Its shape is equal to the shape of the variables over which the probability is defined (self.shapes).\n        In addition to updating the parameters' dictionary (self.params), this function updates a dictionary with the\n        value of the parameters (self.raw_params).\n\n        :param string name: Name of the set of parameters.\n        :param init: Define how to initialize the set of parameters\n        :type init: mxnet.Initializer\n        :param fix: define for each parameter whether the gradient is computed  (True) or not (False). If it is a single\n         boolean it is applied globally to the full set of variables.\n        :type fix: (boolean or list(boolean))\n        \"\"\"", "\n", "\n", "par_list", "=", "[", "]", "\n", "grad_req", "=", "self", ".", "_parse_grad_req", "(", "fix", ",", "len", "(", "self", ".", "shapes", ")", ")", "\n", "for", "shape", ",", "gg", "in", "zip", "(", "self", ".", "shapes", ",", "grad_req", ")", ":", "\n", "            ", "par", "=", "gluon", ".", "Parameter", "(", "name", ",", "shape", "=", "shape", ",", "init", "=", "init", ",", "grad_req", "=", "gg", ")", "\n", "par", ".", "initialize", "(", "ctx", "=", "self", ".", "ctx", ")", "\n", "par_list", ".", "append", "(", "par", ")", "\n", "", "self", ".", "params", "[", "name", "]", "=", "par_list", "\n", "self", ".", "raw_params", "[", "name", "]", "=", "[", "x", ".", "data", "(", "self", ".", "ctx", ")", "for", "x", "in", "self", ".", "params", "[", "name", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value": [[133, 170], ["prob_base.Probability._parse_grad_req", "zip", "zip", "len", "mxnet.init.Constant", "mxnet.gluon.Parameter", "mxnet.gluon.Parameter.initialize", "par_list.append", "x.data", "len", "ValueError", "ValueError", "len", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._parse_grad_req", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["", "def", "_register_param_value", "(", "self", ",", "name", ",", "values", ",", "fix", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Register a parameter and initialize it with values (list(nd.ndarray)).\n\n        It also checks whether the shape (given by \"values\") is compatible with the shape of the variables\n        over which the probability is defined (self.shapes).\n\n        :param string name: Name of the set of parameters.\n        :param values: Value of the set of parameters.\n                [np.array]: Parameters shared across all variables.\n                [np.array_1, ..., np.array_n]: Different parameters for each variable W_i\n        :type values: list[:class:`np.ndarray`]\n        :param fix: define for each parameter whether the gradient is computed  (True) or not (False). If it is a single\n         boolean it is applied globally to the full set of variables.\n        :type fix: (boolean or list(boolean))\n        \"\"\"", "\n", "values_shapes", "=", "[", "vv", ".", "shape", "for", "vv", "in", "values", "]", "\n", "\n", "if", "not", "len", "(", "values", ")", "==", "1", ":", "\n", "            ", "if", "not", "(", "len", "(", "values_shapes", ")", "==", "len", "(", "self", ".", "shapes", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Parameter {} size is not compatible\"", ".", "format", "(", "name", ")", ")", "\n", "", "for", "value_shape", ",", "parameter_shape", "in", "zip", "(", "values_shapes", ",", "self", ".", "shapes", ")", ":", "\n", "                ", "if", "not", "(", "value_shape", "==", "parameter_shape", "or", "value_shape", "==", "(", "1", ",", "1", ")", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Parameter {} size is not compatible\"", ".", "format", "(", "name", ")", ")", "\n", "", "", "", "else", ":", "\n", "            ", "if", "not", "values", "[", "0", "]", ".", "shape", "==", "(", "1", ",", "1", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Parameter {} size is not compatible\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "", "par_list", "=", "[", "]", "\n", "grad_req", "=", "self", ".", "_parse_grad_req", "(", "fix", ",", "len", "(", "values", ")", ")", "\n", "for", "vv", ",", "gg", "in", "zip", "(", "values", ",", "grad_req", ")", ":", "\n", "            ", "init", "=", "mx", ".", "init", ".", "Constant", "(", "vv", ")", "\n", "par", "=", "gluon", ".", "Parameter", "(", "name", ",", "shape", "=", "vv", ".", "shape", ",", "init", "=", "init", ",", "grad_req", "=", "gg", ")", "\n", "par", ".", "initialize", "(", "ctx", "=", "self", ".", "ctx", ")", "\n", "par_list", ".", "append", "(", "par", ")", "\n", "", "self", ".", "params", "[", "name", "]", "=", "par_list", "\n", "self", ".", "raw_params", "[", "name", "]", "=", "[", "x", ".", "data", "(", "self", ".", "ctx", ")", "for", "x", "in", "self", ".", "params", "[", "name", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters": [[171, 185], ["len", "range", "len"], "methods", ["None"], ["", "def", "_replicate_shared_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        It returns a dictionary containing the values of each set of parameters of the distribution.\n\n        The difference with self.raw_params is that the shared parameters are replicated.\n        \"\"\"", "\n", "raw_params_ext", "=", "{", "}", "\n", "for", "k", "in", "self", ".", "raw_params", ":", "\n", "            ", "if", "len", "(", "self", ".", "raw_params", "[", "k", "]", ")", "==", "1", ":", "\n", "# If the parameter is shared, replicate it len(self.shapes) times", "\n", "                ", "raw_params_ext", "[", "k", "]", "=", "[", "self", ".", "raw_params", "[", "k", "]", "[", "0", "]", "for", "_", "in", "range", "(", "len", "(", "self", ".", "shapes", ")", ")", "]", "\n", "", "else", ":", "\n", "                ", "raw_params_ext", "[", "k", "]", "=", "self", ".", "raw_params", "[", "k", "]", "\n", "", "", "return", "raw_params_ext", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._to_dict": [[186, 192], ["utils.serialise_ctx"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.serialise_ctx"], ["", "def", "_to_dict", "(", "self", ")", ":", "\n", "        ", "output_dict", "=", "{", "\n", "SHAPE", ":", "self", ".", "shapes", ",", "\n", "CONTEXT", ":", "serialise_ctx", "(", "self", ".", "ctx", ")", "\n", "}", "\n", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._save_params": [[193, 195], ["numpy.savez"], "methods", ["None"], ["", "def", "_save_params", "(", "self", ",", "filename", ")", ":", "\n", "        ", "np", ".", "savez", "(", "filename", ",", "**", "self", ".", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._load_params": [[196, 214], ["numpy.load", "raw_params[].append", "parameter.data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "@", "staticmethod", "\n", "def", "_load_params", "(", "filename", ")", ":", "\n", "        ", "load_data", "=", "np", ".", "load", "(", "filename", ",", "allow_pickle", "=", "True", ")", "\n", "params", "=", "{", "}", "\n", "raw_params", "=", "{", "}", "\n", "for", "key", "in", "load_data", ".", "files", ":", "\n", "            ", "params", "[", "key", "]", "=", "load_data", "[", "key", "]", "\n", "raw_params", "[", "key", "]", "=", "[", "]", "\n", "for", "parameter", "in", "params", "[", "key", "]", ":", "\n", "# Parameter class in mxnet<1.3.0 does not have _stype attribute which causes an error when Parameter", "\n", "# saved in mxnet<1.3.0 is loaded with mxnet==1.3.0", "\n", "                ", "try", ":", "\n", "                    ", "parameter", ".", "_stype", "\n", "", "except", "AttributeError", ":", "\n", "                    ", "parameter", ".", "_stype", "=", "'default'", "\n", "", "raw_params", "[", "key", "]", ".", "append", "(", "parameter", ".", "data", "(", ")", ")", "\n", "\n", "", "", "return", "params", ",", "raw_params", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var_loss.BNNLoss.__init__": [[36, 44], ["mxnet.cpu", "super().__init__", "var_loss.BNNLoss.var_posterior.is_conjugate"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.is_conjugate"], ["def", "__init__", "(", "self", ",", "prior", ",", "obs_model", ",", "var_posterior", ",", "weight", "=", "None", ",", "batch_axis", "=", "0", ",", "ctx", "=", "mx", ".", "cpu", "(", ")", ")", ":", "\n", "\n", "        ", "super", "(", "BNNLoss", ",", "self", ")", ".", "__init__", "(", "weight", ",", "batch_axis", ")", "\n", "self", ".", "obs_model", "=", "obs_model", "\n", "self", ".", "var_posterior", "=", "var_posterior", "\n", "self", ".", "prior", "=", "prior", "\n", "self", ".", "kldiv_exact", "=", "self", ".", "var_posterior", ".", "is_conjugate", "(", "self", ".", "prior", ")", "\n", "self", ".", "context", "=", "ctx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var_loss.BNNLoss.hybrid_forward": [[45, 73], ["range", "var_loss.BNNLoss.var_posterior.generate_sample", "utils.replace_params_net", "var_loss.BNNLoss.obs_model.set_unnormalized_mean", "var_loss.BNNLoss.obs_model.log_pdf", "float", "float", "net", "var_loss.BNNLoss.var_posterior.KL", "var_loss.BNNLoss.var_posterior.KL_sample"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.generate_sample", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.replace_params_net", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.set_unnormalized_mean", "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.KL_sample"], ["", "def", "hybrid_forward", "(", "self", ",", "F", ",", "data", ",", "net", ",", "label", ",", "num_samples", ",", "total_number_data", ",", "anneal_weight", "=", "1.0", ")", ":", "\n", "# This function overrides the hybrid_forward method in gluon.loss.Loss.", "\n", "# gluon.loss.Loss defines hybrid_forward  as a function call operator using __call__", "\n", "\n", "        ", "loss", "=", "0.0", "\n", "kl_weight", "=", "anneal_weight", "*", "(", "data", ".", "shape", "[", "0", "]", "/", "float", "(", "total_number_data", ")", ")", "\n", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "# generate sample", "\n", "            ", "layer_params", "=", "self", ".", "var_posterior", ".", "generate_sample", "(", ")", "\n", "\n", "replace_params_net", "(", "layer_params", ",", "net", ",", "self", ".", "context", ")", "\n", "\n", "# forward-propagate the batch", "\n", "self", ".", "obs_model", ".", "set_unnormalized_mean", "(", "net", "(", "data", ")", ")", "\n", "\n", "# loss for the current sample", "\n", "log_likelihood_sum", "=", "self", ".", "obs_model", ".", "log_pdf", "(", "label", ")", "\n", "loss", "=", "loss", "-", "log_likelihood_sum", "\n", "\n", "if", "not", "self", ".", "kldiv_exact", ":", "\n", "                ", "loss", "=", "loss", "+", "kl_weight", "*", "self", ".", "var_posterior", ".", "KL_sample", "(", "self", ".", "prior", ",", "layer_params", ")", "\n", "\n", "", "", "loss", "=", "loss", "/", "float", "(", "num_samples", ")", "\n", "\n", "# add exact kl", "\n", "if", "self", ".", "kldiv_exact", ":", "\n", "            ", "loss", "=", "loss", "+", "kl_weight", "*", "self", ".", "var_posterior", ".", "KL", "(", "self", ".", "prior", ")", "\n", "", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prior.Prior.__init__": [[21, 23], ["prob_base.Probability.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "shapes", ",", "ctx", ")", ":", "\n", "        ", "super", "(", "Prior", ",", "self", ")", ".", "__init__", "(", "shapes", ",", "ctx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prior.GaussianPrior.__init__": [[41, 63], ["prior.Prior.__init__", "prior.GaussianPrior._register_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior._register_params"], ["def", "__init__", "(", "self", ",", "means", ",", "sigmas", ",", "shapes", ",", "ctx", "=", "None", ",", "fix_means", "=", "True", ",", "fix_sigmas", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Default constructor\n\n        :param means: Mean of the prior. Can be:\n                [np.array]: Mean shared across all variables.\n                [np.array_1, ..., np.array_n]: Different mean for each variable W_i\n        :type means: list[:class:`np.ndarray`]\n        :param sigmas: Variance of the prior. Can be:\n                [np.array]: Variance shared across all variables.\n                [np.array_1, ..., np.array_n]: Different variance for each variable W_i\n        :type sigmas: list[:class:`np.ndarray`]\n        :param shapes: Define the shape of each variable W_i.\n        :type shapes: list(tuple(int, int))\n        :param fix_means: Fix the mean of the Prior.\n        :type fix_means: boolean or list(boolean)\n        :param fix_sigmas: Fix the variance of the Prior\n        :type fix_sigmas: boolean or list(boolean)\n        \"\"\"", "\n", "\n", "super", "(", "GaussianPrior", ",", "self", ")", ".", "__init__", "(", "shapes", ",", "ctx", ")", "\n", "self", ".", "_register_params", "(", "means", ",", "sigmas", ",", "fix_means", ",", "fix_sigmas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prior.GaussianPrior._register_params": [[64, 67], ["prior.GaussianPrior._register_param_value", "prior.GaussianPrior._register_param_value"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value"], ["", "def", "_register_params", "(", "self", ",", "means", ",", "sigmas", ",", "fix_means", ",", "fix_sigmas", ")", ":", "\n", "        ", "self", ".", "_register_param_value", "(", "\"mean\"", ",", "means", ",", "fix", "=", "fix_means", ")", "\n", "self", ".", "_register_param_value", "(", "\"sigma\"", ",", "sigmas", ",", "fix", "=", "fix_sigmas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.prior.GaussianPrior.log_pdf": [[68, 73], ["prior.GaussianPrior.check_observation_shapes", "prior.GaussianPrior._replicate_shared_parameters", "sum", "mxnet.sum", "utils.log_gaussian", "range", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.log_gaussian"], ["", "def", "log_pdf", "(", "self", ",", "obs", ")", ":", "\n", "        ", "self", ".", "check_observation_shapes", "(", "obs", ")", "\n", "raw_params_ext", "=", "self", ".", "_replicate_shared_parameters", "(", ")", "\n", "return", "sum", "(", "[", "nd", ".", "sum", "(", "log_gaussian", "(", "obs", "[", "ii", "]", ",", "raw_params_ext", "[", "\"mean\"", "]", "[", "ii", "]", ",", "raw_params_ext", "[", "\"sigma\"", "]", "[", "ii", "]", ")", ")", "\n", "for", "ii", "in", "range", "(", "len", "(", "self", ".", "shapes", ")", ")", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.VariationalPosterior.__init__": [[25, 27], ["prior.Probability.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "shapes", ",", "ctx", ")", ":", "\n", "        ", "super", "(", "VariationalPosterior", ",", "self", ")", ".", "__init__", "(", "shapes", ",", "ctx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.VariationalPosterior.generate_sample": [[28, 30], ["None"], "methods", ["None"], ["", "def", "generate_sample", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.VariationalPosterior.get_mean": [[31, 33], ["None"], "methods", ["None"], ["", "def", "get_mean", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.__init__": [[50, 77], ["var.VariationalPosterior.__init__", "var.GaussianVariationalPosterior._register_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior._register_params"], ["def", "__init__", "(", "self", ",", "mean_init", ",", "sigma_init", ",", "shapes", ",", "ctx", ",", "fix_means", "=", "False", ",", "fix_sigmas", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Default constructor\n\n        :param mean_init: The initial variational mean.\n            float: Different mean for each value of each W_i (sampled from N(mean_init, 1))\n            [np.array]: Mean shared across all variables.\n            [np.array_1, ..., np.array_n]: Different mean for each variable W_i\n        :type mean_init: float or list[:class:`np.ndarray`]\n        :param sigma_init: Initial variational variance.\n            float: Different variance for each variable (initialize to float value)\n            [np.array]: Variance shared across all variables.\n            [np.array_1, ..., np.array_n]: Different variance for each variable W_i\n        :type sigma_init: float or list[:class:`np.ndarray`]\n        :param shapes: Size of the variables [W_1, ..., W_n].\n        :type shapes: list(tuple(int, int))\n        :param ctx: MXNet context\n        :type ctx: :class:`mxnet.Context`\n        :param fix_means: Fix the mean of the Variational Posterior.\n        :type fix_means: boolean or list(boolean)\n        :param fix_sigmas: Fix the variance of the Variational Posterior.\n        :type fix_sigmas: boolean or list(boolean)\n        \"\"\"", "\n", "\n", "super", "(", "GaussianVariationalPosterior", ",", "self", ")", ".", "__init__", "(", "shapes", ",", "ctx", ")", "\n", "\n", "self", ".", "_register_params", "(", "mean_init", ",", "sigma_init", ",", "fix_means", ",", "fix_sigmas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior._register_params": [[78, 89], ["isinstance", "var.GaussianVariationalPosterior._register_param", "var.GaussianVariationalPosterior._register_param_value", "isinstance", "utils.softplus_inv_numpy", "var.GaussianVariationalPosterior._register_param", "var.GaussianVariationalPosterior._register_param_value", "mxnet.init.Normal", "mxnet.init.Normal", "mxnet.init.Constant", "mxnet.init.Constant", "utils.softplus_inv_numpy"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus_inv_numpy", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._register_param_value", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus_inv_numpy"], ["", "def", "_register_params", "(", "self", ",", "mean_init", ",", "sigma_init", ",", "fix_means", ",", "fix_sigmas", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "mean_init", ",", "list", ")", ":", "\n", "                ", "self", ".", "_register_param", "(", "MEAN", ",", "mx", ".", "init", ".", "Normal", "(", "mean_init", ")", ",", "fix_means", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_register_param_value", "(", "MEAN", ",", "mean_init", ",", "fix_means", ")", "\n", "", "if", "not", "isinstance", "(", "sigma_init", ",", "list", ")", ":", "\n", "                ", "rho_init", "=", "softplus_inv_numpy", "(", "sigma_init", ")", "\n", "self", ".", "_register_param", "(", "RHO", ",", "mx", ".", "init", ".", "Constant", "(", "rho_init", ")", ",", "fix_sigmas", ")", "\n", "", "else", ":", "\n", "                ", "rho_init", "=", "[", "softplus_inv_numpy", "(", "ss", ")", "for", "ss", "in", "sigma_init", "]", "\n", "self", ".", "_register_param_value", "(", "RHO", ",", "rho_init", ",", "fix_sigmas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.get_mean": [[90, 92], ["None"], "methods", ["None"], ["", "", "def", "get_mean", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "raw_params", "[", "MEAN", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.generate_sample": [[93, 98], ["utils.sample_epsilons", "var.GaussianVariationalPosterior._replicate_shared_parameters", "utils.transform_rhos", "utils.transform_gaussian_samples"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.sample_epsilons", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_rhos", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_gaussian_samples"], ["", "def", "generate_sample", "(", "self", ")", ":", "\n", "        ", "epsilons", "=", "sample_epsilons", "(", "self", ".", "shapes", ",", "self", ".", "ctx", ")", "\n", "raw_params_ext_var_posterior", "=", "self", ".", "_replicate_shared_parameters", "(", ")", "\n", "sigmas", "=", "transform_rhos", "(", "raw_params_ext_var_posterior", "[", "RHO", "]", ")", "\n", "return", "transform_gaussian_samples", "(", "raw_params_ext_var_posterior", "[", "MEAN", "]", ",", "sigmas", ",", "epsilons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.log_pdf": [[99, 105], ["var.GaussianVariationalPosterior.check_observation_shapes", "var.GaussianVariationalPosterior._replicate_shared_parameters", "utils.transform_rhos", "sum", "mxnet.sum", "mxnet.sum", "utils.log_gaussian", "range", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability.check_observation_shapes", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_rhos", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.log_gaussian"], ["", "def", "log_pdf", "(", "self", ",", "obs", ")", ":", "\n", "        ", "self", ".", "check_observation_shapes", "(", "obs", ")", "\n", "raw_params_ext", "=", "self", ".", "_replicate_shared_parameters", "(", ")", "\n", "sigmas", "=", "transform_rhos", "(", "raw_params_ext", "[", "RHO", "]", ")", "\n", "return", "sum", "(", "[", "nd", ".", "sum", "(", "log_gaussian", "(", "obs", "[", "ii", "]", ",", "raw_params_ext", "[", "MEAN", "]", "[", "ii", "]", ",", "sigmas", "[", "ii", "]", ")", ")", "\n", "for", "ii", "in", "range", "(", "len", "(", "self", ".", "shapes", ")", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.is_conjugate": [[106, 111], ["type"], "methods", ["None"], ["", "def", "is_conjugate", "(", "self", ",", "other_prob", ")", ":", "\n", "        ", "if", "type", "(", "other_prob", ")", "==", "GaussianPrior", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.KL": [[112, 138], ["var.GaussianVariationalPosterior._replicate_shared_parameters", "utils.transform_rhos", "other_prob._replicate_shared_parameters", "range", "var.GaussianVariationalPosterior.is_conjugate", "ValueError", "ValueError", "len", "numpy.all", "mxnet.sum", "mxnet.sum", "len", "len", "numpy.array", "mxnet.log", "mxnet.log", "mxnet.log", "mxnet.log", "zip"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_rhos", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._replicate_shared_parameters", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.is_conjugate"], ["", "", "def", "KL", "(", "self", ",", "other_prob", ")", ":", "\n", "        ", "if", "not", "self", ".", "is_conjugate", "(", "other_prob", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"KL cannot be computed in closed form.\"", ")", "\n", "\n", "", "if", "(", "not", "len", "(", "self", ".", "shapes", ")", "==", "len", "(", "other_prob", ".", "shapes", ")", ")", "or", "(", "not", "np", ".", "all", "(", "np", ".", "array", "(", "[", "s", "==", "o", "for", "s", ",", "o", "in", "zip", "(", "self", ".", "shapes", ",", "other_prob", ".", "shapes", ")", "]", ")", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"KL cannot be computed: The 2 distributions have different support\"", ")", "\n", "\n", "", "raw_params_ext_var_posterior", "=", "self", ".", "_replicate_shared_parameters", "(", ")", "\n", "sigmas_var_posterior", "=", "transform_rhos", "(", "raw_params_ext_var_posterior", "[", "RHO", "]", ")", "\n", "raw_params_ext_prior", "=", "other_prob", ".", "_replicate_shared_parameters", "(", ")", "\n", "\n", "out", "=", "0.0", "\n", "for", "ii", "in", "range", "(", "len", "(", "self", ".", "shapes", ")", ")", ":", "\n", "            ", "means_p", "=", "raw_params_ext_prior", "[", "MEAN", "]", "[", "ii", "]", "\n", "var_p", "=", "raw_params_ext_prior", "[", "\"sigma\"", "]", "[", "ii", "]", "**", "2", "\n", "means_q", "=", "raw_params_ext_var_posterior", "[", "MEAN", "]", "[", "ii", "]", "\n", "var_q", "=", "sigmas_var_posterior", "[", "ii", "]", "**", "2", "\n", "inc_means", "=", "(", "means_q", "-", "means_p", ")", "\n", "prec_p", "=", "1.0", "/", "var_p", "\n", "temp", "=", "0.5", "*", "(", "var_q", "*", "prec_p", "+", "(", "(", "inc_means", "**", "2", ")", "*", "prec_p", ")", "-", "1.0", "+", "nd", ".", "log", "(", "var_p", ")", "-", "nd", ".", "log", "(", "var_q", ")", ")", "\n", "if", "temp", ".", "shape", "==", "(", "1", ",", "1", ")", ":", "\n", "# If parameters are shared, multiply by the number of variables", "\n", "                ", "temp", "=", "temp", "*", "(", "self", ".", "shapes", "[", "ii", "]", "[", "0", "]", "*", "self", ".", "shapes", "[", "ii", "]", "[", "1", "]", ")", "\n", "", "out", "=", "out", "+", "nd", ".", "sum", "(", "temp", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save": [[139, 149], ["var.GaussianVariationalPosterior._save_params", "var.GaussianVariationalPosterior._to_dict", "open", "json.dump"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._save_params", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._to_dict"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\"\n        Save object to file. This will create two files: filename.json, filename_params.npz\n\n        :param filename: Name to give saved object files\n        \"\"\"", "\n", "self", ".", "_save_params", "(", "filename", "+", "PARAMS", ")", "\n", "output_dict", "=", "self", ".", "_to_dict", "(", ")", "\n", "with", "open", "(", "filename", "+", "JSON", ",", "'w'", ")", "as", "fp", ":", "\n", "            ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.load": [[150, 169], ["utils.deserialise_ctx", "utils.deserialise_shape", "var.GaussianVariationalPosterior", "GaussianVariationalPosterior._load_params", "open", "json.load"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.deserialise_ctx", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.deserialise_shape", "home.repos.pwc.inspect_result.amzn_xfer.prob.prob_base.Probability._load_params", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "", "@", "staticmethod", "\n", "def", "load", "(", "filename", ")", ":", "\n", "        ", "\"\"\"\n        Load object from file. This requires two files: filename.json, filename_params.npz\n\n        :param filename: Names of files to be opened and loaded\n        \"\"\"", "\n", "with", "open", "(", "filename", "+", "JSON", ",", "'r'", ")", "as", "json_data", ":", "\n", "            ", "input_dict", "=", "json", ".", "load", "(", "json_data", ")", "\n", "", "ctx", "=", "deserialise_ctx", "(", "input_dict", "[", "CONTEXT", "]", ")", "\n", "shape", "=", "deserialise_shape", "(", "input_dict", "[", "SHAPE", "]", ")", "\n", "\n", "gvp", "=", "GaussianVariationalPosterior", "(", "1", ",", "1", ",", "shape", ",", "ctx", ",", "False", ",", "False", ")", "\n", "\n", "params", ",", "raw_params", "=", "GaussianVariationalPosterior", ".", "_load_params", "(", "filename", "+", "PARAMS", "+", "NPZ", ")", "\n", "gvp", ".", "params", "=", "params", "\n", "gvp", ".", "raw_params", "=", "raw_params", "\n", "\n", "return", "gvp", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.log_gaussian": [[29, 31], ["mxnet.log", "numpy.log"], "function", ["None"], ["# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.sample_epsilons": [[33, 35], ["mxnet.random_normal"], "function", ["None"], ["model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_gaussian_samples": [[37, 39], ["range", "len"], "function", ["None"], ["            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus": [[41, 43], ["mxnet.log", "mxnet.exp"], "function", ["None"], ["# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus_inv": [[45, 47], ["mxnet.log", "mxnet.exp"], "function", ["None"], ["        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus_inv_numpy": [[49, 51], ["numpy.log", "numpy.exp"], "function", ["None"], ["\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_rhos": [[53, 55], ["utils.softplus"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus"], ["# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.transform_rhos_inverse": [[57, 59], ["utils.softplus_inv"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus_inv"], ["and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.replace_params_net": [[61, 68], ["zip", "net.collect_params().values", "ValueError", "net.collect_params", "len"], "function", ["None"], ["", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.serialise_ctx": [[70, 80], ["type", "ctx_list.append"], "function", ["None"], ["", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n", "\n", "", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n", "    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.deserialise_ctx": [[82, 95], ["mxnet.cpu", "ctx.append", "len"], "function", ["None"], ["\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.deserialise_shape": [[97, 105], ["deserialised_shape.append", "tuple"], "function", ["None"], ["\n", "", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n", "", "elif", "context_function", "==", "keys", ".", "GPU", ":", "\n", "        ", "return", "mx", ".", "gpu", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Likelihood.__init__": [[20, 22], ["prob_base.Probability.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "ctx", ")", ":", "\n", "        ", "super", "(", "Likelihood", ",", "self", ")", ".", "__init__", "(", "None", ",", "ctx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.__init__": [[25, 27], ["obs.Likelihood.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "ctx", ")", ":", "\n", "        ", "super", "(", "Categorical", ",", "self", ")", ".", "__init__", "(", "ctx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.set_unnormalized_mean": [[28, 30], ["None"], "methods", ["None"], ["", "def", "set_unnormalized_mean", "(", "self", ",", "unnormalized_mean", ")", ":", "\n", "        ", "self", ".", "unnormalized_mean", "=", "unnormalized_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.prob.obs.Categorical.log_pdf": [[31, 33], ["mxnet.sum", "mxnet.nansum", "mxnet.log_softmax"], "methods", ["None"], ["", "def", "log_pdf", "(", "self", ",", "y", ")", ":", "\n", "        ", "return", "nd", ".", "sum", "(", "nd", ".", "nansum", "(", "y", "*", "nd", ".", "log_softmax", "(", "self", ".", "unnormalized_mean", ")", ",", "axis", "=", "0", ",", "exclude", "=", "True", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error": [[30, 53], ["error.__str__", "re.compile", "re.search", "error.__str__.index", "re.search().start", "exceptions.ModelArchitectureError", "error.__str__.index", "len", "error.__str__.index", "len", "re.search", "re.compile"], "function", ["None"], ["", "def", "_handle_mxnet_error", "(", "error", ")", ":", "\n", "    ", "error_string", "=", "error", ".", "__str__", "(", ")", "\n", "error_regex", "=", "re", ".", "compile", "(", "'Check failed: assign\\(&dattr,.*vec.*i.*\\).*Incompatible attr in node'", ")", "\n", "\n", "try", ":", "\n", "        ", "if", "re", ".", "search", "(", "error_regex", ",", "error_string", ")", "is", "not", "None", ":", "\n", "            ", "start_str1", "=", "'expected ['", "\n", "start_index1", "=", "error_string", ".", "index", "(", "start_str1", ")", "+", "len", "(", "start_str1", ")", "\n", "end_str1", "=", "'], got'", "\n", "end_index1", "=", "error_string", ".", "index", "(", "end_str1", ")", "\n", "\n", "start_str2", "=", "'], got ['", "\n", "start_index2", "=", "error_string", ".", "index", "(", "start_str2", ")", "+", "len", "(", "start_str2", ")", "\n", "end_index2", "=", "re", ".", "search", "(", "re", ".", "compile", "(", "']\\n.*Stack trace'", ",", "re", ".", "DOTALL", ")", ",", "error_string", ")", ".", "start", "(", ")", "\n", "\n", "correct_shape", "=", "error_string", "[", "start_index1", ":", "end_index1", "]", "\n", "actual_shape", "=", "error_string", "[", "start_index2", ":", "end_index2", "]", "\n", "raise", "ModelArchitectureError", "(", "'Weight shape mismatch: Expected shape=({}), Actual shape=({}). This can be '", "\n", "'caused by incorrect layer shapes or incorrect input data shapes.'", ".", "format", "(", "\n", "correct_shape", ",", "actual_shape", ")", ")", "\n", "", "", "except", "ValueError", ":", "\n", "        ", "raise", "error", "\n", "", "raise", "error", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.__init__": [[34, 45], ["model_handler.ModelHandler._get_layer_type_dict", "model_handler.ModelHandler._get_devices", "module.get_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layer_type_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_devices", "home.repos.pwc.inspect_result.amzn_xfer.xfer.repurposer.Repurposer.get_params"], ["def", "__init__", "(", "self", ",", "module", ",", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ",", "data_name", "=", "consts", ".", "DATA", ")", ":", "\n", "        ", "self", ".", "symbol", "=", "module", ".", "symbol", "\n", "if", "module", ".", "binded", "and", "module", ".", "params_initialized", ":", "\n", "            ", "self", ".", "arg_params", ",", "self", ".", "aux_params", "=", "module", ".", "get_params", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "arg_params", "=", "module", ".", "_arg_params", "if", "module", ".", "_arg_params", "is", "not", "None", "else", "{", "}", "\n", "self", ".", "aux_params", "=", "module", ".", "_aux_params", "if", "module", ".", "_aux_params", "is", "not", "None", "else", "{", "}", "\n", "\n", "", "self", ".", "layer_type_dict", "=", "self", ".", "_get_layer_type_dict", "(", ")", "\n", "self", ".", "devices", "=", "self", ".", "_get_devices", "(", "context_function", ",", "num_devices", ")", "\n", "self", ".", "data_name", "=", "data_name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_top": [[46, 71], ["model_handler.ModelHandler._get_symbol_dict", "model_handler.ModelHandler._assert_drop_layer_valid", "model_handler.ModelHandler._assert_model_has_single_output", "range", "logging.info", "model_handler.ModelHandler.update_sym", "model_handler.ModelHandler._get_symbol_dict", "len", "model_handler.ModelHandler._get_names_of_inputs_to_layer", "model_handler.ModelHandler._assert_layer_drop_not_ambiguous", "layers_dropped.append", "network_symbol.get_internals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_model_has_single_output", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_layer_drop_not_ambiguous"], ["", "def", "drop_layer_top", "(", "self", ",", "num_layers_to_drop", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Remove layers from output of model.\n\n        :param int n: Number of layers to remove from model output.\n        \"\"\"", "\n", "network_symbol", "=", "self", ".", "symbol", "\n", "network", "=", "self", ".", "_get_symbol_dict", "(", "network_symbol", ")", "\n", "\n", "self", ".", "_assert_drop_layer_valid", "(", "num_layers_to_drop", ")", "\n", "self", ".", "_assert_model_has_single_output", "(", "self", ".", "_get_symbol_dict", "(", "network_symbol", ")", ")", "\n", "\n", "layers_dropped", "=", "[", "]", "\n", "last_layer", "=", "len", "(", "network", "[", "consts", ".", "NODES", "]", ")", "-", "1", "\n", "for", "n", "in", "range", "(", "num_layers_to_drop", ")", ":", "\n", "            ", "last_layer_inputs", "=", "self", ".", "_get_names_of_inputs_to_layer", "(", "symbol_dict", "=", "network", ",", "node_idx", "=", "last_layer", ")", "\n", "self", ".", "_assert_layer_drop_not_ambiguous", "(", "possible_layers_to_drop", "=", "last_layer_inputs", ",", "layer_drop_number", "=", "n", ")", "\n", "# There will only be one value in possible_layers_to_drop", "\n", "layers_dropped", ".", "append", "(", "network", "[", "consts", ".", "NODES", "]", "[", "last_layer", "]", "[", "consts", ".", "NAME", "]", ")", "\n", "last_layer", "=", "last_layer_inputs", "[", "0", "]", "\n", "\n", "", "network_symbol", "=", "network_symbol", ".", "get_internals", "(", ")", "[", "network", "[", "consts", ".", "NODES", "]", "[", "last_layer", "]", "[", "consts", ".", "NAME", "]", "+", "consts", ".", "OUTPUT", "]", "\n", "\n", "logging", ".", "info", "(", "'{} deleted from model top'", ".", "format", "(", "', '", ".", "join", "(", "layers_dropped", ")", ")", ")", "\n", "self", ".", "update_sym", "(", "network_symbol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.drop_layer_bottom": [[72, 105], ["model_handler.ModelHandler._get_symbol_dict", "model_handler.ModelHandler._get_output_layer_names", "model_handler.ModelHandler._assert_drop_layer_valid", "range", "model_handler.ModelHandler._shift_input_indices", "model_handler.ModelHandler._get_arg_nodes", "model_handler.ModelHandler._get_heads", "model_handler.ModelHandler._get_symbol", "logging.info", "model_handler.ModelHandler.update_sym", "model_handler.ModelHandler._get_layers_with_node_idx_as_input", "model_handler.ModelHandler._assert_layer_drop_not_ambiguous", "layers_dropped.append"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_output_layer_names", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._shift_input_indices", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layers_with_node_idx_as_input", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_layer_drop_not_ambiguous"], ["", "def", "drop_layer_bottom", "(", "self", ",", "num_layers_to_drop", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Remove layers from input of model.\n\n        :param int n: Number of layers to remove from model input.\n        \"\"\"", "\n", "network", "=", "self", ".", "_get_symbol_dict", "(", "self", ".", "symbol", ")", "\n", "output_layer_names", "=", "self", ".", "_get_output_layer_names", "(", "network", ")", "\n", "\n", "# Validate the action", "\n", "self", ".", "_assert_drop_layer_valid", "(", "num_layers_to_drop", ")", "\n", "\n", "layers_dropped", "=", "[", "]", "\n", "first_layer", "=", "0", "\n", "for", "n", "in", "range", "(", "num_layers_to_drop", ")", ":", "\n", "            ", "layers_with_first_layer_as_input", "=", "self", ".", "_get_layers_with_node_idx_as_input", "(", "first_layer", ",", "\n", "network", "[", "consts", ".", "NODES", "]", ")", "\n", "self", ".", "_assert_layer_drop_not_ambiguous", "(", "possible_layers_to_drop", "=", "layers_with_first_layer_as_input", ",", "\n", "layer_drop_number", "=", "n", ")", "\n", "# There will only be one value in possible_layers_to_drop", "\n", "layers_dropped", ".", "append", "(", "network", "[", "consts", ".", "NODES", "]", "[", "layers_with_first_layer_as_input", "[", "0", "]", "]", "[", "consts", ".", "NAME", "]", ")", "\n", "first_layer", "=", "layers_with_first_layer_as_input", "[", "0", "]", "\n", "", "shifted_input_network_nodes", "=", "self", ".", "_shift_input_indices", "(", "network", "[", "consts", ".", "NODES", "]", "[", "first_layer", "+", "1", ":", "]", ",", "\n", "shift_constant", "=", "-", "first_layer", ")", "\n", "# Concatentate input node and remaining network nodes", "\n", "network", "[", "consts", ".", "NODES", "]", "=", "[", "network", "[", "consts", ".", "NODES", "]", "[", "0", "]", "]", "+", "shifted_input_network_nodes", "\n", "# Update symbol dictionary attributes", "\n", "network", "[", "consts", ".", "ARG_NODES", "]", "=", "self", ".", "_get_arg_nodes", "(", "network", "[", "consts", ".", "NODES", "]", ")", "\n", "network", "[", "consts", ".", "HEADS", "]", "=", "self", ".", "_get_heads", "(", "nodes", "=", "network", "[", "consts", ".", "NODES", "]", ",", "output_layer_names", "=", "output_layer_names", ")", "\n", "sym", "=", "self", ".", "_get_symbol", "(", "network", ")", "\n", "\n", "logging", ".", "info", "(", "'{} deleted from model bottom'", ".", "format", "(", "', '", ".", "join", "(", "layers_dropped", ")", ")", ")", "\n", "self", ".", "update_sym", "(", "sym", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_top": [[106, 141], ["model_handler.ModelHandler._get_symbol_dict", "model_handler.ModelHandler._get_heads", "model_handler.ModelHandler._get_arg_nodes", "model_handler.ModelHandler._get_symbol", "model_handler.ModelHandler.update_sym", "logging.info", "exceptions.ModelError", "model_handler.ModelHandler._shift_input_indices", "model_handler.ModelHandler._validate_layer_name", "added_layer_names.append", "model_handler.ModelHandler.symbol.get_internals().list_outputs", "model_handler.ModelHandler._get_symbol_dict", "model_handler.ModelHandler.symbol.get_internals", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._shift_input_indices", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict"], ["", "def", "add_layer_top", "(", "self", ",", "layer_list", ")", ":", "\n", "        ", "\"\"\"\n        Add layer to output of model.\n        model layers = (layer1, layer2, layer3), layer_list = [layerA, layerB] -> model layers =\n        (layer1, layer2, layer3, layerA, layerB)\n\n        :param layer_list: List of MxNet symbol layers to be added to model output.\n        :type layer_list: list(:class:`mx.symbol`)\n        \"\"\"", "\n", "if", "'_label'", "in", "self", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "[", "consts", ".", "LABEL_IDX", "]", ":", "\n", "            ", "raise", "exceptions", ".", "ModelError", "(", "'Cannot add layer above output layer'", ")", "\n", "", "network_symbol", "=", "self", ".", "_get_symbol_dict", "(", "self", ".", "symbol", ")", "\n", "# Concatentate nodes of new layers", "\n", "added_layer_names", "=", "[", "]", "\n", "new_nodes", "=", "[", "]", "\n", "for", "layer", "in", "layer_list", ":", "\n", "            ", "layer_nodes", "=", "self", ".", "_get_symbol_dict", "(", "layer", ")", "[", "consts", ".", "NODES", "]", "\n", "# Shift input indices of layer nodes by the number of nodes in the existing network and the nodes added", "\n", "# before. -1 because input indexing begins at zero.", "\n", "layer_nodes", "=", "self", ".", "_shift_input_indices", "(", "layer_nodes", ",", "len", "(", "network_symbol", "[", "consts", ".", "NODES", "]", ")", "+", "len", "(", "new_nodes", ")", "-", "1", ")", "\n", "new_nodes", "+=", "layer_nodes", "[", "1", ":", "]", "# Excluding input node at index 0", "\n", "layer_name", "=", "layer_nodes", "[", "-", "1", "]", "[", "consts", ".", "NAME", "]", "# Last node contains layer name", "\n", "self", ".", "_validate_layer_name", "(", "layer_name", ")", "\n", "added_layer_names", ".", "append", "(", "layer_name", ")", "\n", "\n", "# Concatentate entire network nodes list with new nodes list", "\n", "", "network_symbol", "[", "consts", ".", "NODES", "]", "=", "network_symbol", "[", "consts", ".", "NODES", "]", "+", "new_nodes", "\n", "# Update attributes of new network symbol dictionary", "\n", "network_symbol", "[", "consts", ".", "HEADS", "]", "=", "self", ".", "_get_heads", "(", "nodes", "=", "network_symbol", "[", "consts", ".", "NODES", "]", ",", "\n", "output_layer_names", "=", "[", "added_layer_names", "[", "-", "1", "]", "]", ")", "\n", "network_symbol", "[", "consts", ".", "ARG_NODES", "]", "=", "self", ".", "_get_arg_nodes", "(", "network_symbol", "[", "consts", ".", "NODES", "]", ")", "\n", "\n", "sym", "=", "self", ".", "_get_symbol", "(", "network_symbol", ")", "\n", "self", ".", "update_sym", "(", "sym", ")", "\n", "logging", ".", "info", "(", "'Added {} to model top'", ".", "format", "(", "', '", ".", "join", "(", "added_layer_names", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.add_layer_bottom": [[142, 176], ["model_handler.ModelHandler._get_symbol_dict", "model_handler.ModelHandler._get_output_layer_names", "model_handler.ModelHandler._shift_input_indices", "model_handler.ModelHandler._get_heads", "model_handler.ModelHandler._get_arg_nodes", "model_handler.ModelHandler._get_symbol", "model_handler.ModelHandler.update_sym", "logging.info", "model_handler.ModelHandler._shift_input_indices", "model_handler.ModelHandler._validate_layer_name", "added_layer_names.append", "len", "model_handler.ModelHandler._get_symbol_dict", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_output_layer_names", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._shift_input_indices", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._shift_input_indices", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict"], ["", "def", "add_layer_bottom", "(", "self", ",", "layer_list", ")", ":", "\n", "        ", "\"\"\"\n        Add layer to input of model.\n        model layers = (layer1, layer2, layer3), layer_list = [layerA, layerB] -> model layers =\n        (layerA, layerB, layer1, layer2, layer3)\n\n        :param layer_list: List of MxNet symbol layers to be added to model input.\n        :type layer_list: list(:class:`mx.symbol`)\n        \"\"\"", "\n", "network_symbol", "=", "self", ".", "_get_symbol_dict", "(", "self", ".", "symbol", ")", "\n", "# Concatentate nodes of new layers", "\n", "new_nodes", "=", "[", "]", "\n", "added_layer_names", "=", "[", "]", "\n", "for", "layer", "in", "layer_list", ":", "\n", "            ", "layer_nodes", "=", "self", ".", "_get_symbol_dict", "(", "layer", ")", "[", "consts", ".", "NODES", "]", "\n", "# Shift input indices of new layer by number of nodes added before it", "\n", "layer_nodes", "=", "self", ".", "_shift_input_indices", "(", "layer_nodes", ",", "len", "(", "new_nodes", ")", ")", "\n", "new_nodes", "+=", "layer_nodes", "[", "1", ":", "]", "# adding all but input node", "\n", "layer_name", "=", "layer_nodes", "[", "-", "1", "]", "[", "consts", ".", "NAME", "]", "# Last node contains layer name", "\n", "self", ".", "_validate_layer_name", "(", "layer_name", ")", "\n", "added_layer_names", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "output_layer_names", "=", "self", ".", "_get_output_layer_names", "(", "network_symbol", ")", "\n", "# Shift input indices of existing nodes by the number of nodes being added. Exclude input node.", "\n", "shifted_input_network_nodes", "=", "self", ".", "_shift_input_indices", "(", "network_symbol", "[", "consts", ".", "NODES", "]", "[", "1", ":", "]", ",", "len", "(", "new_nodes", ")", ")", "\n", "# Concatentate data node of network, new layer nodes and remaining network nodes", "\n", "network_symbol", "[", "consts", ".", "NODES", "]", "=", "[", "network_symbol", "[", "consts", ".", "NODES", "]", "[", "0", "]", "]", "+", "new_nodes", "+", "shifted_input_network_nodes", "\n", "network_symbol", "[", "consts", ".", "HEADS", "]", "=", "self", ".", "_get_heads", "(", "network_symbol", "[", "consts", ".", "NODES", "]", ",", "\n", "output_layer_names", "=", "output_layer_names", ")", "\n", "network_symbol", "[", "consts", ".", "ARG_NODES", "]", "=", "self", ".", "_get_arg_nodes", "(", "network_symbol", "[", "consts", ".", "NODES", "]", ")", "\n", "\n", "sym", "=", "self", ".", "_get_symbol", "(", "network_symbol", ")", "\n", "self", ".", "update_sym", "(", "sym", ")", "\n", "logging", ".", "info", "(", "'Added {} to model bottom'", ".", "format", "(", "', '", ".", "join", "(", "added_layer_names", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_layer_drop_not_ambiguous": [[177, 182], ["len", "exceptions.ModelError"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_assert_layer_drop_not_ambiguous", "(", "possible_layers_to_drop", ",", "layer_drop_number", ")", ":", "\n", "        ", "if", "len", "(", "possible_layers_to_drop", ")", ">", "1", ":", "\n", "            ", "raise", "exceptions", ".", "ModelError", "(", "'ModelHandler does not support dropping layers where there is ambiguity.'", "+", "\n", "'Layer drop: {}.'", ".", "format", "(", "layer_drop_number", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._shift_input_indices": [[183, 192], ["None"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_shift_input_indices", "(", "nodes", ",", "shift_constant", ")", ":", "\n", "        ", "\"\"\"\n        Shift input indices of nodes by shift constant.\n        \"\"\"", "\n", "for", "node", "in", "nodes", ":", "\n", "            ", "for", "node_input", "in", "node", "[", "consts", ".", "INPUTS", "]", ":", "\n", "                ", "node_input", "[", "0", "]", "+=", "shift_constant", "\n", "", "", "return", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_arg_nodes": [[193, 203], ["enumerate", "arg_nodes.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_arg_nodes", "(", "nodes", ")", ":", "\n", "        ", "\"\"\"\n        Return arg_nodes given nodes list.\n        \"\"\"", "\n", "arg_nodes", "=", "[", "]", "\n", "for", "idx", ",", "node", "in", "enumerate", "(", "nodes", ")", ":", "\n", "            ", "if", "node", "[", "consts", ".", "OPERATION", "]", "==", "consts", ".", "NO_OP", ":", "\n", "                ", "arg_nodes", ".", "append", "(", "idx", ")", "\n", "", "", "return", "arg_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_heads": [[204, 214], ["enumerate", "heads.append"], "methods", ["None"], ["", "def", "_get_heads", "(", "self", ",", "nodes", ",", "output_layer_names", ")", ":", "\n", "        ", "\"\"\"\n        Return heads given the nodes list and a list of output layer names.\n        \"\"\"", "\n", "heads", "=", "[", "]", "\n", "for", "idx", ",", "node", "in", "enumerate", "(", "nodes", ")", ":", "\n", "            ", "if", "node", "[", "consts", ".", "NAME", "]", "in", "output_layer_names", ":", "\n", "# symbol.load_json expects heads in the form [i, 0] (1.3.x), or [i, 0, 0] (1.2.x+)", "\n", "                ", "heads", ".", "append", "(", "[", "idx", ",", "0", ",", "0", "]", ")", "\n", "", "", "return", "heads", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_output_layer_names": [[215, 221], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_output_layer_names", "(", "symbol_dict", ")", ":", "\n", "        ", "\"\"\"\n        Return names of output layers given symbol dictionary.\n        \"\"\"", "\n", "return", "[", "symbol_dict", "[", "consts", ".", "NODES", "]", "[", "i", "[", "0", "]", "]", "[", "consts", ".", "NAME", "]", "for", "i", "in", "symbol_dict", "[", "consts", ".", "HEADS", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_model_has_single_output": [[222, 234], ["len", "exceptions.ModelError", "output_layer_names.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_assert_model_has_single_output", "(", "symbol_dict", ")", ":", "\n", "        ", "\"\"\"\n        Raise ModelError if model has more than one output.\n        \"\"\"", "\n", "output_layer_names", "=", "[", "]", "\n", "if", "len", "(", "symbol_dict", "[", "consts", ".", "HEADS", "]", ")", ">", "1", ":", "\n", "            ", "for", "head", "in", "symbol_dict", "[", "consts", ".", "HEADS", "]", ":", "\n", "                ", "output_layer_names", ".", "append", "(", "symbol_dict", "[", "consts", ".", "NODES", "]", "[", "head", "[", "0", "]", "]", "[", "consts", ".", "NAME", "]", ")", "\n", "", "raise", "exceptions", ".", "ModelError", "(", "\n", "'ModelHandler does not support this operation for models with more than one output. ({})'", ".", "format", "(", "\n", "', '", ".", "join", "(", "output_layer_names", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_names_of_inputs_to_layer": [[235, 250], ["inputs_to_layer.append"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_get_names_of_inputs_to_layer", "(", "symbol_dict", ",", "node_idx", ")", ":", "\n", "        ", "\"\"\"\n        Get the names of the layers that are inputs to specified layer.\n        \"\"\"", "\n", "# Assert node_idx refers to an operation", "\n", "assert", "symbol_dict", "[", "consts", ".", "NODES", "]", "[", "node_idx", "]", "[", "consts", ".", "OPERATION", "]", "!=", "consts", ".", "NO_OP", ",", "'node_idx: {} does not refer to a layer'", ".", "format", "(", "node_idx", ")", "\n", "# Get list of layer inputs to layer", "\n", "inputs_to_layer", "=", "[", "]", "\n", "for", "i", "in", "symbol_dict", "[", "consts", ".", "NODES", "]", "[", "node_idx", "]", "[", "consts", ".", "INPUTS", "]", ":", "\n", "# Do not add null layers to list of inputs", "\n", "            ", "if", "symbol_dict", "[", "consts", ".", "NODES", "]", "[", "i", "[", "0", "]", "]", "[", "consts", ".", "OPERATION", "]", "!=", "consts", ".", "NO_OP", ":", "\n", "                ", "inputs_to_layer", ".", "append", "(", "i", "[", "0", "]", ")", "\n", "", "", "return", "inputs_to_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layers_with_node_idx_as_input": [[251, 266], ["enumerate", "layer_names.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_layers_with_node_idx_as_input", "(", "node_idx", ",", "nodes", ")", ":", "\n", "        ", "\"\"\"\n        Get list of ids of layers that have the node_idx-th node as an input.\n        \"\"\"", "\n", "layer_names", "=", "[", "]", "\n", "for", "idx", ",", "node", "in", "enumerate", "(", "nodes", ")", ":", "\n", "            ", "if", "node", "[", "consts", ".", "OPERATION", "]", "==", "consts", ".", "NO_OP", ":", "\n", "                ", "continue", "\n", "", "for", "input_list", "in", "node", "[", "consts", ".", "INPUTS", "]", ":", "\n", "                ", "if", "input_list", "[", "0", "]", "==", "node_idx", ":", "\n", "                    ", "layer_names", ".", "append", "(", "idx", ")", "\n", "# Avoid counting twice in the case where a node has two inputs from 0 node", "\n", "break", "\n", "", "", "", "return", "layer_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_module": [[267, 293], ["mxnet.mod.Module", "mxnet.mod.Module.bind", "mxnet.mod.Module.init_params", "model_handler.ModelHandler._prune_parameters", "model_handler.ModelHandler._remove_random_parameters", "mxnet.init.Xavier", "mxnet.mod.Module.set_params", "model_handler.ModelHandler.arg_params.copy", "model_handler.ModelHandler.aux_params.copy", "exceptions._handle_mxnet_error"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.utils.outils.init_params", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._prune_parameters", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._remove_random_parameters", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.exceptions._handle_mxnet_error"], ["", "def", "get_module", "(", "self", ",", "iterator", ",", "fixed_layer_parameters", "=", "None", ",", "random_layer_parameters", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Return MXNet Module using the model symbol and parameters.\n\n        :param iterator: MXNet iterator to be used with model.\n        :type iterator: :class:`mxnet.io.DataIter`\n        :param list(str) fixed_layer_parameters: List of layer parameters to keep fixed.\n        :param list(str) random_layer_parameters: List of layer parameters to randomise.\n        :return: MXNet module\n        :rtype: :class:`mx.module.Module`\n        \"\"\"", "\n", "if", "fixed_layer_parameters", "is", "not", "None", ":", "\n", "            ", "fixed_layer_parameters", "=", "self", ".", "_prune_parameters", "(", "fixed_layer_parameters", ")", "\n", "", "if", "random_layer_parameters", "is", "None", ":", "\n", "            ", "arg_params", ",", "aux_params", "=", "self", ".", "arg_params", ".", "copy", "(", ")", ",", "self", ".", "aux_params", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "            ", "arg_params", ",", "aux_params", "=", "self", ".", "_remove_random_parameters", "(", "random_layer_parameters", ")", "\n", "", "mod", "=", "mx", ".", "mod", ".", "Module", "(", "symbol", "=", "self", ".", "symbol", ",", "context", "=", "self", ".", "devices", ",", "fixed_param_names", "=", "fixed_layer_parameters", ",", "\n", "label_names", "=", "(", "self", ".", "layer_names", "[", "-", "1", "]", "+", "\"_label\"", ",", ")", ",", "data_names", "=", "(", "self", ".", "data_name", ",", ")", ")", "\n", "mod", ".", "bind", "(", "data_shapes", "=", "iterator", ".", "provide_data", ",", "label_shapes", "=", "iterator", ".", "provide_label", ")", "\n", "mod", ".", "init_params", "(", "mx", ".", "init", ".", "Xavier", "(", "rnd_type", "=", "'gaussian'", ",", "factor_type", "=", "'in'", ",", "magnitude", "=", "2", ")", ")", "\n", "try", ":", "\n", "            ", "mod", ".", "set_params", "(", "arg_params", ",", "aux_params", ",", "allow_missing", "=", "True", ",", "force_init", "=", "True", ")", "\n", "", "except", "mx", ".", "MXNetError", "as", "e", ":", "\n", "            ", "exceptions", ".", "_handle_mxnet_error", "(", "e", ")", "\n", "", "return", "mod", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_type": [[294, 306], ["ValueError"], "methods", ["None"], ["", "def", "get_layer_type", "(", "self", ",", "layer_name", ")", ":", "\n", "        ", "\"\"\"\n        Return type of named layer.\n\n        :param str name: Name of layer being inspected.\n        :return: Layer type\n        :rtype: str\n        \"\"\"", "\n", "try", ":", "\n", "            ", "return", "self", ".", "layer_type_dict", "[", "layer_name", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "raise", "ValueError", "(", "'{} layer does not exist in model'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_names_matching_type": [[307, 317], ["model_handler.ModelHandler.layer_type_dict.items", "l_type.lower", "layer_type.lower"], "methods", ["None"], ["", "", "def", "get_layer_names_matching_type", "(", "self", ",", "layer_type", ")", ":", "\n", "        ", "\"\"\"\n        Return names of layers of specified type.\n\n        :param str layer_type: Return list of layers of this type.\n        :return: Names of layers with specified type\n        :rtype: list(str)\n        \"\"\"", "\n", "return", "[", "layer_name", "for", "layer_name", ",", "l_type", "in", "self", ".", "layer_type_dict", ".", "items", "(", ")", "\n", "if", "l_type", ".", "lower", "(", ")", "==", "layer_type", ".", "lower", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_output": [[318, 384], ["logging.info", "collections.OrderedDict", "numpy.array", "dict", "data_iterator.reset", "mxnet.sym.Group", "mxnet.mod.Module", "mxnet.mod.Module.bind", "mxnet.mod.Module.set_params", "gc.collect", "isinstance", "TypeError", "type", "TypeError", "enumerate", "numpy.append", "mxnet.mod.Module.forward", "mxnet.mod.Module.get_outputs", "logging.info", "gc.collect", "numpy.append.astype", "model_handler.ModelHandler.symbol.get_internals", "data_iterator.next", "data_iterator.next.label[].asnumpy", "forward_output[].asnumpy().flatten().reshape", "type", "numpy.vstack", "forward_output[].asnumpy().flatten", "forward_output[].asnumpy"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.EnsembleKnowledgeTransferLoss.forward", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["", "def", "get_layer_output", "(", "self", ",", "data_iterator", ",", "layer_names", ")", ":", "\n", "        ", "\"\"\"\n        Function to extract features from data iterator with model.\n        Returns a dictionary of layer_name -> numpy array of features extracted (flattened).\n\n        :param data_iterator: Iterator containing input data.\n        :type data_iterator: :class:`mxnet.io.DataIter`\n        :param list(str) layer_names: List of names of layers to extract features from.\n        :return: Ordered Dictionary of features ({layer_name: features}), list of labels\n                 Layer names in the ordered dictionary follow the same order as input list of layer_names\n        :rtype: OrderedDict[str, :class:`numpy.array`], list(int)\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "data_iterator", ",", "mx", ".", "io", ".", "DataIter", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'Iterator should be an MXNet DataIter object'", ".", "format", "(", "type", "(", "data_iterator", ")", ")", ")", "\n", "", "if", "type", "(", "layer_names", ")", "is", "not", "list", ":", "\n", "            ", "raise", "TypeError", "(", "'Layers must be passed as list.'", ")", "\n", "", "logging", ".", "info", "(", "'Extracting features from layers: '", "+", "' '", ".", "join", "(", "layer_names", ")", ")", "\n", "\n", "features", "=", "OrderedDict", "(", ")", "\n", "labels", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "data_shape", "=", "data_iterator", ".", "provide_data", "[", "0", "]", "[", "1", "]", "\n", "batch_no", "=", "0", "\n", "id2layer", "=", "dict", "(", "enumerate", "(", "layer_names", ")", ")", "\n", "data_iterator", ".", "reset", "(", ")", "\n", "\n", "intermediate_layer_symbols", "=", "[", "self", ".", "symbol", ".", "get_internals", "(", ")", "[", "l", "+", "'_output'", "]", "for", "l", "in", "layer_names", "]", "\n", "intermediate_symbol", "=", "mx", ".", "sym", ".", "Group", "(", "intermediate_layer_symbols", ")", "\n", "\n", "module", "=", "mx", ".", "mod", ".", "Module", "(", "symbol", "=", "intermediate_symbol", ",", "context", "=", "self", ".", "devices", ",", "label_names", "=", "None", ",", "\n", "data_names", "=", "(", "self", ".", "data_name", ",", ")", ")", "\n", "module", ".", "bind", "(", "for_training", "=", "False", ",", "data_shapes", "=", "[", "(", "self", ".", "data_name", ",", "data_shape", ")", "]", ",", "label_shapes", "=", "None", ")", "\n", "module", ".", "set_params", "(", "self", ".", "arg_params", ",", "self", ".", "aux_params", ")", "\n", "\n", "# MXNet Module has issues releasing memory from GPU (https://github.com/apache/incubator-mxnet/issues/5983)so we", "\n", "# force full garbage collection before feature extraction and force a shallow garbage collection after every", "\n", "# loop to free up any memory that has been allocated during the loop and should have been released", "\n", "gc", ".", "collect", "(", "2", ")", "# Full garbage collection before begininning to extract features", "\n", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "batch", "=", "data_iterator", ".", "next", "(", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "", "batch_no", "+=", "1", "\n", "labels", "=", "np", ".", "append", "(", "labels", ",", "batch", ".", "label", "[", "0", "]", ".", "asnumpy", "(", ")", ")", "\n", "module", ".", "forward", "(", "batch", ")", "\n", "forward_output", "=", "module", ".", "get_outputs", "(", ")", "\n", "\n", "for", "lid", "in", "id2layer", ":", "\n", "                ", "feature", "=", "forward_output", "[", "lid", "]", ".", "asnumpy", "(", ")", ".", "flatten", "(", ")", ".", "reshape", "(", "data_shape", "[", "0", "]", ",", "-", "1", ")", "\n", "# Remove extra values from padding if they are present", "\n", "feature", "=", "feature", "[", ":", "feature", ".", "shape", "[", "0", "]", "-", "batch", ".", "pad", "]", "\n", "if", "id2layer", "[", "lid", "]", "in", "features", ":", "\n", "                    ", "features", "[", "id2layer", "[", "lid", "]", "]", "=", "np", ".", "vstack", "(", "(", "features", "[", "id2layer", "[", "lid", "]", "]", ",", "feature", ")", ")", "\n", "", "else", ":", "\n", "                    ", "features", "[", "id2layer", "[", "lid", "]", "]", "=", "feature", "\n", "# Remove extra values from padding if they are present", "\n", "", "", "labels", "=", "labels", "[", ":", "labels", ".", "shape", "[", "0", "]", "-", "batch", ".", "pad", "]", "\n", "\n", "logging", ".", "info", "(", "'Processed batch {0}'", ".", "format", "(", "batch_no", ")", ")", "\n", "del", "forward_output", "\n", "del", "feature", "\n", "del", "batch", "\n", "gc", ".", "collect", "(", "0", ")", "# Shallow garbage collect for objects created during loop", "\n", "\n", "", "return", "features", ",", "labels", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.get_layer_parameters": [[385, 401], ["type", "TypeError", "list", "arg_dict.keys"], "methods", ["None"], ["", "def", "get_layer_parameters", "(", "self", ",", "layer_names", ")", ":", "\n", "        ", "\"\"\"\n        Get list of layer parameters associated with the the layer names given.\n\n        :param list(str) layer_names: List of layer names.\n        :return: List of layer parameters\n        :rtype: list(str)\n        \"\"\"", "\n", "if", "type", "(", "layer_names", ")", "is", "not", "list", ":", "\n", "            ", "raise", "TypeError", "(", "'layer_names must be passed as list.'", ")", "\n", "", "params", "=", "[", "]", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "for", "arg_dict", "in", "[", "self", ".", "arg_params", ",", "self", ".", "aux_params", "]", ":", "\n", "                ", "new_params", "=", "[", "param", "for", "param", "in", "list", "(", "arg_dict", ".", "keys", "(", ")", ")", "if", "layer_name", "in", "param", "]", "\n", "params", "=", "params", "+", "new_params", "\n", "", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.visualize_net": [[402, 407], ["mxnet.viz.plot_network"], "methods", ["None"], ["", "def", "visualize_net", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Display computational graph of model.\n        \"\"\"", "\n", "return", "mx", ".", "viz", ".", "plot_network", "(", "self", ".", "symbol", ",", "node_attrs", "=", "{", "'fixedsize'", ":", "'false'", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.save_symbol": [[408, 415], ["model_handler.ModelHandler.symbol.save"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save"], ["", "def", "save_symbol", "(", "self", ",", "model_name", ")", ":", "\n", "        ", "\"\"\"\n        Serialise model symbol graph.\n\n        :param str model_name: Prefix to file name (model_name-symbol.json).\n        \"\"\"", "\n", "self", ".", "symbol", ".", "save", "(", "model_name", "+", "'-symbol.json'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._validate_layer_name": [[416, 429], ["ValueError", "model_handler.ModelHandler.symbol.list_inputs", "ValueError"], "methods", ["None"], ["", "def", "_validate_layer_name", "(", "self", ",", "layer_name", ")", ":", "\n", "        ", "\"\"\"\n        Validate name of layer.\n\n        :param str layer_name: Name to be validated.\n        \"\"\"", "\n", "# Input name is not included in layer_names so the check for conflict is done with symbol inputs and layer_names", "\n", "if", "layer_name", "in", "self", ".", "symbol", ".", "list_inputs", "(", ")", "or", "layer_name", "in", "self", ".", "layer_names", ":", "\n", "            ", "raise", "ValueError", "(", "\"Layer name '{}' conflicts with name already in model.\"", ".", "format", "(", "layer_name", ")", ")", "\n", "# MXNet uses these suffixes for specific things so we are avoiding using them in layer names", "\n", "", "for", "suffix", "in", "[", "'output'", ",", "'label'", ",", "'weight'", ",", "'bias'", ",", "'moving_mean'", ",", "'moving_var'", ",", "'gamma'", ",", "'beta'", "]", ":", "\n", "            ", "if", "'_'", "+", "suffix", "in", "layer_name", ":", "\n", "                ", "raise", "ValueError", "(", "\"Layer name cannot contain '{}'\"", ".", "format", "(", "suffix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._prune_parameters": [[430, 443], ["list", "list", "len", "logging.warning", "model_handler.ModelHandler.arg_params.keys", "model_handler.ModelHandler.aux_params.keys"], "methods", ["None"], ["", "", "", "def", "_prune_parameters", "(", "self", ",", "parameter_names", ")", ":", "\n", "        ", "\"\"\"\n        Remove parameter names from list which are not in model parameter dicts.  Logs warning for removed names.\n\n        :param list(str) parameter_names: List of parameter names.\n        :return: Parameter names that are all in the model parameter dicts\n        :rtype: list(str)\n        \"\"\"", "\n", "all_keys", "=", "list", "(", "self", ".", "arg_params", ".", "keys", "(", ")", ")", "+", "list", "(", "self", ".", "aux_params", ".", "keys", "(", ")", ")", "\n", "names_not_found", "=", "[", "parameter_name", "for", "parameter_name", "in", "parameter_names", "if", "parameter_name", "not", "in", "all_keys", "]", "\n", "if", "len", "(", "names_not_found", ")", ">", "0", ":", "\n", "            ", "logging", ".", "warning", "(", "'Could not find layer parameters: {}'", ".", "format", "(", "', '", ".", "join", "(", "names_not_found", ")", ")", ")", "\n", "", "return", "[", "parameter_name", "for", "parameter_name", "in", "parameter_names", "if", "parameter_name", "in", "all_keys", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._remove_random_parameters": [[444, 459], ["model_handler.ModelHandler._prune_parameters", "model_handler.ModelHandler.arg_params.copy", "model_handler.ModelHandler.aux_params.copy", "model_handler.ModelHandler.pop", "model_handler.ModelHandler.pop"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._prune_parameters"], ["", "def", "_remove_random_parameters", "(", "self", ",", "random_parameter_names", ")", ":", "\n", "        ", "\"\"\"\n        Return model parameter dicts with random parameters removed.\n\n        :param list(str) random_parameter_names: Names of random parameters to be removed from model parameter dicts.\n        :return: arg_params, aux_params\n        :rtype: dict, dict\n        \"\"\"", "\n", "random_parameter_names", "=", "self", ".", "_prune_parameters", "(", "random_parameter_names", ")", "\n", "arg_params", "=", "self", ".", "arg_params", ".", "copy", "(", ")", "\n", "aux_params", "=", "self", ".", "aux_params", ".", "copy", "(", ")", "\n", "for", "parameter_name", "in", "random_parameter_names", ":", "\n", "            ", "arg_params", ".", "pop", "(", "parameter_name", ",", "None", ")", "\n", "aux_params", ".", "pop", "(", "parameter_name", ",", "None", ")", "\n", "", "return", "arg_params", ",", "aux_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_devices": [[460, 471], ["context_function", "range"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_devices", "(", "context_function", "=", "mx", ".", "context", ".", "cpu", ",", "num_devices", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Return devices list.\n\n        :param function context_function: MXNet context function which returns a context.\n        :param int num_devices: Number of devices to use for processing (e.g number of cpus or gpus to use).\n        :return: List of devices\n        :rtype: list\n        \"\"\"", "\n", "return", "[", "context_function", "(", "i", ")", "for", "i", "in", "range", "(", "num_devices", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._assert_drop_layer_valid": [[472, 480], ["len", "exceptions.ModelError", "len"], "methods", ["None"], ["", "def", "_assert_drop_layer_valid", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"\n        Raise exception if the number of layers being dropped is more than or equal to the number of layers in the\n        model.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "layer_names", ")", "<", "n", "+", "1", ":", "\n", "            ", "raise", "exceptions", ".", "ModelError", "(", "'Cannot drop {} layers. Model only has {} layers'", ".", "format", "(", "n", ",", "\n", "len", "(", "self", ".", "layer_names", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layer_type_dict": [[481, 498], ["model_handler.ModelHandler._get_symbol_dict", "collections.OrderedDict", "l.replace", "model_handler.ModelHandler.symbol.get_internals().list_outputs", "model_handler.ModelHandler.symbol.get_internals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict"], ["", "", "def", "_get_layer_type_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return dictionary of layer types.\n\n        :return: Dictionary of layer names to layer types\n        :rtype: dict\n        \"\"\"", "\n", "symbol_dict", "=", "self", ".", "_get_symbol_dict", "(", "self", ".", "symbol", ")", "\n", "# Each layer in the model has one output (along with a bias or weight etc.) so we filter for all the list", "\n", "# entries containing '_output' and then we remove this substring from the list entries to leave just the layer", "\n", "# names", "\n", "layer_names", "=", "[", "l", ".", "replace", "(", "'_output'", ",", "''", ")", "for", "l", "in", "self", ".", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", "if", "'_output'", "in", "l", "]", "\n", "symbol_layers", "=", "[", "node", "for", "node", "in", "symbol_dict", "[", "consts", ".", "NODES", "]", "if", "node", "[", "consts", ".", "LAYER_NAME", "]", "in", "layer_names", "]", "\n", "layer_type_dict", "=", "OrderedDict", "(", ")", "\n", "for", "layer", "in", "symbol_layers", ":", "\n", "            ", "layer_type_dict", "[", "layer", "[", "consts", ".", "LAYER_NAME", "]", "]", "=", "layer", "[", "consts", ".", "OPERATION", "]", "\n", "", "return", "layer_type_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol_dict": [[499, 508], ["json.loads", "symbol.tojson"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_symbol_dict", "(", "symbol", ")", ":", "\n", "        ", "\"\"\"\n        Get symbol dictionary.\n\n        :return: Symbol dictionary\n        :rtype: dict\n        \"\"\"", "\n", "return", "json", ".", "loads", "(", "symbol", ".", "tojson", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_symbol": [[509, 515], ["mxnet.sym.load_json", "json.dumps"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_symbol", "(", "symbol_dict", ")", ":", "\n", "        ", "\"\"\"\n        Get MXNet symbol from its symbol dictionary.\n        \"\"\"", "\n", "return", "mx", ".", "sym", ".", "load_json", "(", "json", ".", "dumps", "(", "symbol_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.layer_names": [[516, 525], ["list", "model_handler.ModelHandler.layer_type_dict.keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "layer_names", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get list of names of model layers.\n\n        :return: List of layer names\n        :rtype: list[str]\n        \"\"\"", "\n", "return", "list", "(", "self", ".", "layer_type_dict", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._clean_params": [[526, 542], ["parameter_dict.copy.copy.copy", "set", "set", "parameter_dict.copy.copy.keys", "symbol.get_internals().list_outputs", "symbol.get_internals"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_clean_params", "(", "symbol", ",", "parameter_dict", ")", ":", "\n", "        ", "\"\"\"\n        Return a copy of parameter_dict with parameters for layers that are not in the symbol removed.\n\n        :param symbol: Symbol to give point of reference for removing parameters.\n        :type symbol: :class:`mx.symbol.Symbol`\n        :param dict parameter_dict: Dictionary of model parameters.\n        :return: Parameter dictionary with all parameters referring to layer(s) in the symbol\n        :rtype: dict\n        \"\"\"", "\n", "parameter_dict", "=", "parameter_dict", ".", "copy", "(", ")", "\n", "keys_to_delete_arg", "=", "set", "(", "parameter_dict", ".", "keys", "(", ")", ")", "-", "set", "(", "symbol", ".", "get_internals", "(", ")", ".", "list_outputs", "(", ")", ")", "\n", "for", "key", "in", "keys_to_delete_arg", ":", "\n", "            ", "del", "parameter_dict", "[", "key", "]", "\n", "", "return", "parameter_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler.update_sym": [[543, 554], ["model_handler.ModelHandler._get_layer_type_dict", "model_handler.ModelHandler._clean_params", "model_handler.ModelHandler._clean_params"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._get_layer_type_dict", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._clean_params", "home.repos.pwc.inspect_result.amzn_xfer.model_handler.model_handler.ModelHandler._clean_params"], ["", "def", "update_sym", "(", "self", ",", "new_symbol", ")", ":", "\n", "        ", "\"\"\"\n        Update symbol attribute, layer names, and layer types dict and clean parameters.\n\n        :param new_symbol: Symbol with which to update ModelHandler.\n        :type new_symbol: :class:`mx.symbol.Symbol`\n        \"\"\"", "\n", "self", ".", "symbol", "=", "new_symbol", "\n", "self", ".", "layer_type_dict", "=", "self", ".", "_get_layer_type_dict", "(", ")", "\n", "self", ".", "arg_params", "=", "self", ".", "_clean_params", "(", "self", ".", "symbol", ",", "self", ".", "arg_params", ")", "\n", "self", ".", "aux_params", "=", "self", ".", "_clean_params", "(", "self", ".", "symbol", ",", "self", ".", "aux_params", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.__init__": [[36, 53], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "networks.FeatExemplarAvgBlock", "networks.LinearDiag", "networks.dni_linear", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "nKnovel", ",", "nFeat", ",", "q_steps", ")", ":", "\n", "        ", "super", "(", "ClassifierSIB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "nKnovel", "=", "nKnovel", "\n", "self", ".", "nFeat", "=", "nFeat", "\n", "self", ".", "q_steps", "=", "q_steps", "\n", "\n", "# bias & scale of classifier p(y | x, theta)", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "0", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "scale_cls", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "10", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# init_net lambda(d_t^l)", "\n", "self", ".", "favgblock", "=", "FeatExemplarAvgBlock", "(", "self", ".", "nFeat", ")", "\n", "self", ".", "wnLayerFavg", "=", "LinearDiag", "(", "self", ".", "nFeat", ")", "\n", "\n", "# grad_net (aka decoupled network interface) phi(x_t)", "\n", "self", ".", "dni", "=", "dni_linear", "(", "self", ".", "nKnovel", ",", "dni_hidden_size", "=", "self", ".", "nKnovel", "*", "8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.apply_classification_weights": [[54, 72], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "sib.ClassifierSIB.bias.view", "torch.normalize.transpose", "torch.normalize.dim", "torch.normalize.dim"], "methods", ["None"], ["", "def", "apply_classification_weights", "(", "self", ",", "features", ",", "cls_weights", ")", ":", "\n", "        ", "\"\"\"\n        Given feature and weights, computing negative log-likelihoods of nKnovel classes\n        (B x n x nFeat, B x nKnovel x nFeat) -> B x n x nKnovel\n\n        :param features: features of query set.\n        :type features: torch.FloatTensor\n        :param cls_weights: generated weights.\n        :type cls_weights: torch.FloatTensor\n        :return: classification scores\n        :rtype: torch.FloatTensor\n        \"\"\"", "\n", "features", "=", "F", ".", "normalize", "(", "features", ",", "p", "=", "2", ",", "dim", "=", "features", ".", "dim", "(", ")", "-", "1", ",", "eps", "=", "1e-12", ")", "\n", "cls_weights", "=", "F", ".", "normalize", "(", "cls_weights", ",", "p", "=", "2", ",", "dim", "=", "cls_weights", ".", "dim", "(", ")", "-", "1", ",", "eps", "=", "1e-12", ")", "\n", "\n", "cls_scores", "=", "self", ".", "scale_cls", "*", "torch", ".", "baddbmm", "(", "1.0", ",", "self", ".", "bias", ".", "view", "(", "1", ",", "1", ",", "1", ")", ",", "1.0", ",", "\n", "features", ",", "cls_weights", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "return", "cls_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.init_theta": [[73, 88], ["sib.ClassifierSIB.favgblock", "theta.view.view.size", "theta.view.view.view", "sib.ClassifierSIB.wnLayerFavg", "theta.view.view.view"], "methods", ["None"], ["", "def", "init_theta", "(", "self", ",", "features_supp", ",", "labels_supp_1hot", ")", ":", "\n", "        ", "\"\"\"\n        Compute theta^0 from support set using classwise feature averaging.\n\n        :param features_supp: support features, B x nSupp x nFeat.\n        :type features_supp: torch.FloatTensor\n        :param labels_supp_1hot: one-hot representation of labels in support set.\n        :return: theta^0, B * nKnovel x nFeat\n        \"\"\"", "\n", "theta", "=", "self", ".", "favgblock", "(", "features_supp", ",", "labels_supp_1hot", ")", "# B x nKnovel x nFeat", "\n", "batch_size", ",", "nKnovel", ",", "num_channels", "=", "theta", ".", "size", "(", ")", "\n", "theta", "=", "theta", ".", "view", "(", "batch_size", "*", "nKnovel", ",", "num_channels", ")", "\n", "theta", "=", "self", ".", "wnLayerFavg", "(", "theta", ")", "# weight each feature differently", "\n", "theta", "=", "theta", ".", "view", "(", "-", "1", ",", "nKnovel", ",", "num_channels", ")", "\n", "return", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.refine_theta": [[89, 117], ["range", "features_query.size", "sib.ClassifierSIB.apply_classification_weights", "cls_scores.view.view.view", "sib.ClassifierSIB.dni", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.apply_classification_weights"], ["", "def", "refine_theta", "(", "self", ",", "theta", ",", "features_query", ",", "lr", "=", "1e-3", ")", ":", "\n", "        ", "\"\"\"\n        Compute theta^k using synthetic gradient descent on x_t.\n\n        :param theta: theta^0\n        :type theta: torch.FloatTensor\n        :param features_query: feat(x_t)\n        :type features_query: torch.FloatTensor\n        :param float lr: learning rate\n        :return: theta^k\n        :rtype: torch.FloatTensor\n        \"\"\"", "\n", "batch_size", ",", "num_examples", "=", "features_query", ".", "size", "(", ")", "[", ":", "2", "]", "\n", "new_batch_dim", "=", "batch_size", "*", "num_examples", "\n", "\n", "for", "t", "in", "range", "(", "self", ".", "q_steps", ")", ":", "\n", "            ", "cls_scores", "=", "self", ".", "apply_classification_weights", "(", "features_query", ",", "theta", ")", "\n", "cls_scores", "=", "cls_scores", ".", "view", "(", "new_batch_dim", ",", "-", "1", ")", "# B * n x nKnovel", "\n", "grad_logit", "=", "self", ".", "dni", "(", "cls_scores", ")", "# B * n x nKnovel", "\n", "grad", "=", "torch", ".", "autograd", ".", "grad", "(", "[", "cls_scores", "]", ",", "[", "theta", "]", ",", "\n", "grad_outputs", "=", "[", "grad_logit", "]", ",", "\n", "create_graph", "=", "True", ",", "retain_graph", "=", "True", ",", "\n", "only_inputs", "=", "True", ")", "[", "0", "]", "# B x nKnovel x nFeat", "\n", "\n", "# perform synthetic GD", "\n", "theta", "=", "theta", "-", "lr", "*", "grad", "\n", "\n", "", "return", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.get_classification_weights": [[118, 140], ["torch.normalize", "torch.normalize", "torch.normalize", "sib.ClassifierSIB.init_theta", "sib.ClassifierSIB.refine_theta", "torch.normalize.dim"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.init_theta", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.refine_theta"], ["", "def", "get_classification_weights", "(", "self", ",", "features_supp", ",", "labels_supp_1hot", ",", "features_query", ",", "lr", ")", ":", "\n", "        ", "\"\"\"\n        Obtain weights for the query set using features_supp, labels_supp and features_query.\n        features_supp, labels_supp --> self.init_theta\n        features_query --> self.refine_theta\n\n        :features_supp: feat(x_t^l)\n        :type features_supp: torch.FloatTensor\n        :labels_supp_1hot: one-hot representation of support labels\n        :type labels_supp: torch.FloatTensor\n        :features_query: feat(x_t)\n        :type features_query: torch.FloatTensor\n        :lr float: learning rate of synthetic GD\n        :return: weights for query set\n        :rtype: torch.FloatTensor\n        \"\"\"", "\n", "features_supp", "=", "F", ".", "normalize", "(", "features_supp", ",", "p", "=", "2", ",", "dim", "=", "features_supp", ".", "dim", "(", ")", "-", "1", ",", "eps", "=", "1e-12", ")", "\n", "\n", "weight_novel", "=", "self", ".", "init_theta", "(", "features_supp", ",", "labels_supp_1hot", ")", "\n", "weight_novel", "=", "self", ".", "refine_theta", "(", "weight_novel", ",", "features_query", ",", "lr", ")", "\n", "\n", "return", "weight_novel", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.forward": [[142, 162], ["networks.label_to_1hot", "sib.ClassifierSIB.get_classification_weights", "sib.ClassifierSIB.apply_classification_weights"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.label_to_1hot", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.sib.ClassifierSIB.get_classification_weights", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.apply_classification_weights"], ["", "def", "forward", "(", "self", ",", "features_supp", ",", "labels_supp", ",", "features_query", ",", "lr", ")", ":", "\n", "        ", "\"\"\"\n        Compute classification scores.\n        :labels_supp_1hot: one-hot representation of support labels\n\n        :features_supp: B x nKnovel*nExamplar x nFeat\n        :type features_supp: torch.FloatTensor\n        :labels_supp: B x nknovel*nExamplar in [0, nKnovel-1]\n        :type labels_supp: torch.FloatTensor\n        :features_query: B x nKnovel*nTest x nFeat\n        :type features_query: torch.FloatTensor\n        :lr float: learning rate of synthetic GD\n        :return: classification scores\n        :rtype: torch.FloatTensor\n        \"\"\"", "\n", "labels_supp_1hot", "=", "label_to_1hot", "(", "labels_supp", ",", "self", ".", "nKnovel", ")", "\n", "cls_weights", "=", "self", ".", "get_classification_weights", "(", "features_supp", ",", "labels_supp_1hot", ",", "features_query", ",", "lr", ")", "\n", "cls_scores", "=", "self", ".", "apply_classification_weights", "(", "features_query", ",", "cls_weights", ")", "\n", "\n", "return", "cls_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.ConvBlock.__init__": [[22, 33], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "networks.ConvBlock.layers.add_module", "networks.ConvBlock.layers.add_module", "networks.ConvBlock.layers.add_module", "networks.ConvBlock.layers.add_module", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ")", ":", "\n", "        ", "super", "(", "ConvBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "layers", ".", "add_module", "(", "'Conv'", ",", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "self", ".", "layers", ".", "add_module", "(", "'BatchNorm'", ",", "nn", ".", "BatchNorm2d", "(", "out_planes", ")", ")", "\n", "\n", "self", ".", "layers", ".", "add_module", "(", "'ReLU'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "\n", "self", ".", "layers", ".", "add_module", "(", "\n", "'MaxPool'", ",", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.ConvBlock.forward": [[34, 37], ["networks.ConvBlock.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "layers", "(", "x", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.ConvNet_4_64.__init__": [[39, 57], ["torch.Module.__init__", "conv_blocks.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "networks.ConvNet_4_64.modules", "networks.ConvBlock", "conv_blocks.append", "isinstance", "networks.ConvBlock", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inputW", "=", "80", ",", "inputH", "=", "80", ")", ":", "\n", "        ", "super", "(", "ConvNet_4_64", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "conv_blocks", "=", "[", "]", "\n", "## 4 blocks, each block conv + bn + relu + maxpool, with filter 64", "\n", "conv_blocks", ".", "append", "(", "ConvBlock", "(", "3", ",", "64", ")", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "conv_blocks", ".", "append", "(", "ConvBlock", "(", "64", ",", "64", ")", ")", "\n", "\n", "", "self", ".", "conv_blocks", "=", "nn", ".", "Sequential", "(", "*", "conv_blocks", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.ConvNet_4_64.forward": [[58, 62], ["networks.ConvNet_4_64.conv_blocks", "out.view.view.view", "out.view.view.size"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv_blocks", "(", "x", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.BasicBlock.__init__": [[65, 82], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "stride", ",", "dropRate", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "out_planes", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "out_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "droprate", "=", "dropRate", "\n", "if", "self", ".", "droprate", ">", "0", ":", "\n", "            ", "self", ".", "dropoutLayer", "=", "nn", ".", "Dropout", "(", "p", "=", "self", ".", "droprate", ")", "\n", "", "self", ".", "equalInOut", "=", "(", "in_planes", "==", "out_planes", ")", "\n", "self", ".", "convShortcut", "=", "(", "not", "self", ".", "equalInOut", ")", "and", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "bias", "=", "False", ")", "or", "None", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.BasicBlock.forward": [[82, 99], ["networks.BasicBlock.conv1", "networks.BasicBlock.conv2", "networks.BasicBlock.relu1", "networks.BasicBlock.relu1", "networks.BasicBlock.dropoutLayer", "networks.BasicBlock.relu2", "networks.BasicBlock.bn1", "networks.BasicBlock.bn1", "networks.BasicBlock.bn2", "networks.BasicBlock.convShortcut"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "not", "self", ".", "equalInOut", ":", "\n", "            ", "x", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "\n", "", "out", "=", "out", "if", "self", ".", "equalInOut", "else", "x", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "if", "self", ".", "droprate", ">", "0", ":", "\n", "            ", "out", "=", "self", ".", "dropoutLayer", "(", "out", ")", "\n", "#out = F.dropout(out, p=self.droprate, training=self.training)", "\n", "", "out", "=", "self", ".", "conv2", "(", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "\n", "if", "not", "self", ".", "equalInOut", ":", "\n", "            ", "return", "self", ".", "convShortcut", "(", "x", ")", "+", "out", "\n", "", "else", ":", "\n", "            ", "return", "x", "+", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.NetworkBlock.__init__": [[102, 105], ["torch.Module.__init__", "networks.NetworkBlock._make_layer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.GroupBlock._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "nb_layers", ",", "in_planes", ",", "out_planes", ",", "block", ",", "stride", ",", "dropRate", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "NetworkBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layer", "=", "self", ".", "_make_layer", "(", "block", ",", "in_planes", ",", "out_planes", ",", "nb_layers", ",", "stride", ",", "dropRate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.NetworkBlock._make_layer": [[106, 113], ["range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "in_planes", ",", "out_planes", ",", "nb_layers", ",", "stride", ",", "dropRate", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nb_layers", ")", ":", "\n", "            ", "in_plances_arg", "=", "i", "==", "0", "and", "in_planes", "or", "out_planes", "\n", "stride_arg", "=", "i", "==", "0", "and", "stride", "or", "1", "\n", "layers", ".", "append", "(", "block", "(", "in_plances_arg", ",", "out_planes", ",", "stride_arg", ",", "dropRate", ")", ")", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.NetworkBlock.forward": [[114, 116], ["networks.NetworkBlock.layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "layer", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.WideResNet.__init__": [[119, 149], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "networks.NetworkBlock", "networks.NetworkBlock", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "networks.WideResNet.modules", "networks.NetworkBlock", "networks.NetworkBlock", "torch.ReLU", "torch.ReLU", "torch.ReLU", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "depth", "=", "28", ",", "widen_factor", "=", "10", ",", "dropRate", "=", "0.0", ",", "userelu", "=", "True", ",", "isCifar", "=", "False", ")", ":", "\n", "        ", "super", "(", "WideResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nChannels", "=", "[", "16", ",", "16", "*", "widen_factor", ",", "32", "*", "widen_factor", ",", "64", "*", "widen_factor", "]", "\n", "assert", "(", "(", "depth", "-", "4", ")", "%", "6", "==", "0", ")", "\n", "n", "=", "(", "depth", "-", "4", ")", "//", "6", "\n", "block", "=", "BasicBlock", "\n", "# 1st conv before any network block", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "nChannels", "[", "0", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "# 1st block", "\n", "self", ".", "block1", "=", "NetworkBlock", "(", "n", ",", "nChannels", "[", "0", "]", ",", "nChannels", "[", "1", "]", ",", "block", ",", "1", ",", "dropRate", ")", "if", "isCifar", "else", "NetworkBlock", "(", "n", ",", "nChannels", "[", "0", "]", ",", "nChannels", "[", "1", "]", ",", "block", ",", "2", ",", "dropRate", ")", "\n", "# 2nd block", "\n", "\n", "self", ".", "block2", "=", "NetworkBlock", "(", "n", ",", "nChannels", "[", "1", "]", ",", "nChannels", "[", "2", "]", ",", "block", ",", "2", ",", "dropRate", ")", "\n", "# 3rd block", "\n", "self", ".", "block3", "=", "NetworkBlock", "(", "n", ",", "nChannels", "[", "2", "]", ",", "nChannels", "[", "3", "]", ",", "block", ",", "2", ",", "dropRate", ")", "\n", "\n", "# global average pooling and classifier", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "nChannels", "[", "3", "]", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "if", "userelu", "else", "None", "\n", "self", ".", "nChannels", "=", "nChannels", "[", "3", "]", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.WideResNet.forward": [[150, 164], ["networks.WideResNet.conv1", "networks.WideResNet.block1", "networks.WideResNet.block2", "networks.WideResNet.block3", "networks.WideResNet.bn1", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "networks.WideResNet.view", "networks.WideResNet.relu", "networks.WideResNet.size"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "block1", "(", "out", ")", "\n", "out", "=", "self", ".", "block2", "(", "out", ")", "\n", "out", "=", "self", ".", "block3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "\n", "if", "self", ".", "relu", "is", "not", "None", ":", "\n", "            ", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "out", ".", "size", "(", "3", ")", ")", "\n", "out", "=", "out", ".", "view", "(", "-", "1", ",", "self", ".", "nChannels", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.dni_linear.__init__": [[175, 188], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_dims", ",", "dni_hidden_size", "=", "1024", ")", ":", "\n", "        ", "super", "(", "dni_linear", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layer1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "input_dims", ",", "dni_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "dni_hidden_size", ")", "\n", ")", "\n", "self", ".", "layer2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "dni_hidden_size", ",", "dni_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "dni_hidden_size", ")", "\n", ")", "\n", "self", ".", "layer3", "=", "nn", ".", "Linear", "(", "dni_hidden_size", ",", "input_dims", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.dni_linear.forward": [[189, 194], ["networks.dni_linear.layer1", "networks.dni_linear.layer2", "networks.dni_linear.layer3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "layer1", "(", "x", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.LinearDiag.__init__": [[197, 207], ["torch.Module.__init__", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "networks.LinearDiag.register_parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_features", ",", "bias", "=", "False", ")", ":", "\n", "        ", "super", "(", "LinearDiag", ",", "self", ")", ".", "__init__", "(", ")", "\n", "weight", "=", "torch", ".", "FloatTensor", "(", "num_features", ")", ".", "fill_", "(", "1", ")", "# initialize to the identity transform", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "weight", ",", "requires_grad", "=", "True", ")", "\n", "\n", "if", "bias", ":", "\n", "            ", "bias", "=", "torch", ".", "FloatTensor", "(", "num_features", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "bias", ",", "requires_grad", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.LinearDiag.forward": [[208, 214], ["networks.LinearDiag.weight.expand_as", "X.dim", "X.size", "networks.LinearDiag.weight.size", "networks.LinearDiag.bias.expand_as"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "assert", "(", "X", ".", "dim", "(", ")", "==", "2", "and", "X", ".", "size", "(", "1", ")", "==", "self", ".", "weight", ".", "size", "(", "0", ")", ")", "\n", "out", "=", "X", "*", "self", ".", "weight", ".", "expand_as", "(", "X", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "out", "=", "out", "+", "self", ".", "bias", ".", "expand_as", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.FeatExemplarAvgBlock.__init__": [[217, 219], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nFeat", ")", ":", "\n", "        ", "super", "(", "FeatExemplarAvgBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.FeatExemplarAvgBlock.forward": [[220, 227], ["labels_train.transpose", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "weight_novel.div.div.div", "labels_train.transpose.sum().expand_as", "labels_train.transpose.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features_train", ",", "labels_train", ")", ":", "\n", "        ", "labels_train_transposed", "=", "labels_train", ".", "transpose", "(", "1", ",", "2", ")", "\n", "# B x nK x nT @ B x nT x nC = B x nK x nC", "\n", "weight_novel", "=", "torch", ".", "bmm", "(", "labels_train_transposed", ",", "features_train", ")", "\n", "weight_novel", "=", "weight_novel", ".", "div", "(", "\n", "labels_train_transposed", ".", "sum", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", ".", "expand_as", "(", "weight_novel", ")", ")", "\n", "return", "weight_novel", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.label_to_1hot": [[166, 172], ["label.size", "range", "torch.cat().float", "torch.cat().float", "torch.cat().float", "labels.append", "torch.cat", "torch.cat", "torch.cat"], "function", ["None"], ["", "", "def", "label_to_1hot", "(", "label", ",", "K", ")", ":", "\n", "    ", "B", ",", "N", "=", "label", ".", "size", "(", ")", "\n", "labels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "K", ")", ":", "\n", "        ", "labels", ".", "append", "(", "(", "label", "==", "i", ")", ".", "unsqueeze", "(", "2", ")", ")", "\n", "", "return", "torch", ".", "cat", "(", "labels", ",", "-", "1", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.get_featnet": [[229, 241], ["networks.WideResNet", "ValueError", "eval"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval"], ["", "", "def", "get_featnet", "(", "architecture", ",", "inputW", "=", "80", ",", "inputH", "=", "80", ")", ":", "\n", "# if cifar dataset, the last 2 blocks of WRN should be without stride", "\n", "    ", "isCifar", "=", "(", "inputW", "==", "32", ")", "or", "(", "inputH", "==", "32", ")", "\n", "if", "architecture", "==", "'WRN_28_10'", ":", "\n", "        ", "net", "=", "WideResNet", "(", "28", ",", "10", ",", "isCifar", "=", "isCifar", ")", "\n", "return", "net", ",", "net", ".", "nChannels", "\n", "\n", "", "elif", "architecture", "==", "'ConvNet_4_64'", ":", "\n", "        ", "return", "eval", "(", "architecture", ")", "(", "inputW", ",", "inputH", ")", ",", "64", "*", "(", "inputH", "/", "2", "**", "4", ")", "*", "(", "inputW", "/", "2", "**", "4", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'No such feature net available!'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.__init__": [[47, 56], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "nKnovel", ",", "nFeat", ")", ":", "\n", "        ", "super", "(", "ClassifierEval", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "nKnovel", "=", "nKnovel", "\n", "self", ".", "nFeat", "=", "nFeat", "\n", "\n", "# bias & scale of classifier", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "0", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "scale_cls", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "10", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.apply_classification_weights": [[57, 66], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "torch.baddbmm", "main_feat.ClassifierEval.bias.view", "torch.normalize.transpose", "torch.normalize.dim", "torch.normalize.dim"], "methods", ["None"], ["", "def", "apply_classification_weights", "(", "self", ",", "features", ",", "cls_weights", ")", ":", "\n", "        ", "'''\n        (B x n x nFeat, B x nKnovel x nFeat) -> B x n x nKnovel\n        (B x n x nFeat, B x nKnovel*nExamplar x nFeat) -> B x n x nKnovel*nExamplar if init_type is nn\n        '''", "\n", "features", "=", "F", ".", "normalize", "(", "features", ",", "p", "=", "2", ",", "dim", "=", "features", ".", "dim", "(", ")", "-", "1", ",", "eps", "=", "1e-12", ")", "\n", "cls_weights", "=", "F", ".", "normalize", "(", "cls_weights", ",", "p", "=", "2", ",", "dim", "=", "cls_weights", ".", "dim", "(", ")", "-", "1", ",", "eps", "=", "1e-12", ")", "\n", "cls_scores", "=", "self", ".", "scale_cls", "*", "torch", ".", "baddbmm", "(", "1.0", ",", "self", ".", "bias", ".", "view", "(", "1", ",", "1", ",", "1", ")", ",", "1.0", ",", "features", ",", "cls_weights", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "return", "cls_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.forward": [[67, 78], ["features_supp.size", "features_supp.view().mean", "main_feat.ClassifierEval.apply_classification_weights", "features_supp.view"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierEval.apply_classification_weights"], ["", "def", "forward", "(", "self", ",", "features_supp", ",", "features_query", ")", ":", "\n", "        ", "'''\n        features_supp: (B, nKnovel * nExamplar, nFeat)\n        features_query: (B, nKnovel * nTest, nFeat)\n        '''", "\n", "B", "=", "features_supp", ".", "size", "(", "0", ")", "\n", "\n", "weight", "=", "features_supp", ".", "view", "(", "B", ",", "self", ".", "nKnovel", ",", "-", "1", ",", "self", ".", "nFeat", ")", ".", "mean", "(", "2", ")", "\n", "cls_scores", "=", "self", ".", "apply_classification_weights", "(", "features_query", ",", "weight", ")", "\n", "\n", "return", "cls_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierTrain.__init__": [[81, 100], ["torch.Module.__init__", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.FloatTensor().normal_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "numpy.sqrt", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nCls", ",", "nFeat", "=", "640", ",", "scaleCls", "=", "10.", ")", ":", "\n", "        ", "super", "(", "ClassifierTrain", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "scaleCls", "=", "scaleCls", "\n", "self", ".", "nFeat", "=", "nFeat", "\n", "self", ".", "nCls", "=", "nCls", "\n", "\n", "# weights of base categories", "\n", "self", ".", "weight", "=", "torch", ".", "FloatTensor", "(", "nFeat", ",", "nCls", ")", ".", "normal_", "(", "0.0", ",", "np", ".", "sqrt", "(", "2.0", "/", "nFeat", ")", ")", "# Dimension nFeat * nCls", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "self", ".", "weight", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# bias", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ",", "nCls", ")", ".", "fill_", "(", "0", ")", ",", "requires_grad", "=", "True", ")", "# Dimension 1 * nCls", "\n", "\n", "# Scale of cls (Heat Parameter)", "\n", "self", ".", "scaleCls", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "scaleCls", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# Method", "\n", "self", ".", "applyWeight", "=", "self", ".", "applyWeightCosine", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierTrain.getWeight": [[101, 103], ["None"], "methods", ["None"], ["", "def", "getWeight", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "scaleCls", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierTrain.applyWeightCosine": [[104, 112], ["torch.normalize.size", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["None"], ["", "def", "applyWeightCosine", "(", "self", ",", "feature", ",", "weight", ",", "bias", ",", "scaleCls", ")", ":", "\n", "        ", "batchSize", ",", "nFeat", "=", "feature", ".", "size", "(", ")", "\n", "\n", "feature", "=", "F", ".", "normalize", "(", "feature", ",", "p", "=", "2", ",", "dim", "=", "1", ",", "eps", "=", "1e-12", ")", "## Attention: normalized along 2nd dimension!!!", "\n", "weight", "=", "F", ".", "normalize", "(", "weight", ",", "p", "=", "2", ",", "dim", "=", "0", ",", "eps", "=", "1e-12", ")", "## Attention: normalized along 1st dimension!!!", "\n", "\n", "clsScore", "=", "scaleCls", "*", "(", "torch", ".", "mm", "(", "feature", ",", "weight", ")", ")", "#+ bias)", "\n", "return", "clsScore", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierTrain.forward": [[113, 117], ["main_feat.ClassifierTrain.getWeight", "main_feat.ClassifierTrain.applyWeight"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.ClassifierTrain.getWeight"], ["", "def", "forward", "(", "self", ",", "feature", ")", ":", "\n", "        ", "weight", ",", "bias", ",", "scaleCls", "=", "self", ".", "getWeight", "(", ")", "\n", "clsScore", "=", "self", ".", "applyWeight", "(", "feature", ",", "weight", ",", "bias", ",", "scaleCls", ")", "\n", "return", "clsScore", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.BaseTrainer.__init__": [[120, 144], ["networks.get_featnet", "main_feat.ClassifierTrain", "main_feat.ClassifierEval", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "os.path.isdir", "os.mkdir", "main_feat.BaseTrainer.netFeat.cuda", "main_feat.BaseTrainer.netClassifier.cuda", "main_feat.BaseTrainer.netClassifierVal.cuda"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.networks.get_featnet", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device"], ["    ", "def", "__init__", "(", "self", ",", "trainLoader", ",", "valLoader", ",", "nbCls", ",", "nClsEpisode", ",", "nFeat", ",", "\n", "outDir", ",", "milestones", "=", "[", "50", "]", ",", "inputW", "=", "80", ",", "inputH", "=", "80", ",", "cuda", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "trainLoader", "=", "trainLoader", "\n", "self", ".", "valLoader", "=", "valLoader", "\n", "self", ".", "outDir", "=", "outDir", "\n", "self", ".", "milestones", "=", "milestones", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "outDir", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "self", ".", "outDir", ")", "\n", "\n", "# Define model", "\n", "", "self", ".", "netFeat", ",", "nFeat", "=", "get_featnet", "(", "'WRN_28_10'", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "netClassifier", "=", "ClassifierTrain", "(", "nbCls", ")", "\n", "self", ".", "netClassifierVal", "=", "ClassifierEval", "(", "nClsEpisode", ",", "nFeat", ")", "\n", "\n", "# GPU setting", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "cuda", "else", "'cpu'", ")", "\n", "if", "cuda", ":", "\n", "            ", "self", ".", "netFeat", ".", "cuda", "(", ")", "\n", "self", ".", "netClassifier", ".", "cuda", "(", ")", "\n", "self", ".", "netClassifierVal", ".", "cuda", "(", ")", "\n", "\n", "", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "bestAcc", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.BaseTrainer.LrWarmUp": [[145, 210], ["print", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "itertools.chain", "main_feat.BaseTrainer.netFeat.train", "main_feat.BaseTrainer.netClassifier.train", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "enumerate", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "main_feat.BaseTrainer.test", "itertools.chain", "utils.utils.to_device", "utils.utils.to_device", "main_feat.BaseTrainer.optimizer.zero_grad", "main_feat.BaseTrainer.netFeat", "main_feat.BaseTrainer.netClassifier", "main_feat.BaseTrainer.criterion", "main_feat.BaseTrainer.backward", "main_feat.BaseTrainer.optimizer.step", "utils.outils.accuracy", "utils.outils.AverageMeter.update", "utils.outils.AverageMeter.update", "utils.outils.AverageMeter.update", "utils.outils.progress_bar", "main_feat.BaseTrainer.item", "acc1[].item", "acc5[].item", "len", "main_feat.BaseTrainer.netFeat.parameters", "main_feat.BaseTrainer.netClassifier.parameters", "float", "utils.utils.to_device.size", "utils.utils.to_device.size", "utils.utils.to_device.size", "main_feat.BaseTrainer.netFeat.parameters", "main_feat.BaseTrainer.netClassifier.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.BaseTrainer.test", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "LrWarmUp", "(", "self", ",", "totalIter", ",", "lr", ")", ":", "\n", "        ", "msg", "=", "'\\nLearning rate warming up'", "\n", "print", "(", "msg", ")", "\n", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "itertools", ".", "chain", "(", "*", "[", "self", ".", "netFeat", ".", "parameters", "(", ")", ",", "\n", "self", ".", "netClassifier", ".", "parameters", "(", ")", "]", ")", ",", "\n", "1e-7", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "5e-4", ",", "\n", "nesterov", "=", "True", ")", "\n", "\n", "nbIter", "=", "0", "\n", "lrUpdate", "=", "lr", "\n", "valTop1", "=", "0", "\n", "\n", "while", "nbIter", "<", "totalIter", ":", "\n", "            ", "self", ".", "netFeat", ".", "train", "(", ")", "\n", "self", ".", "netClassifier", ".", "train", "(", ")", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "top5", "=", "AverageMeter", "(", ")", "\n", "\n", "for", "batchIdx", ",", "(", "inputs", ",", "targets", ")", "in", "enumerate", "(", "self", ".", "trainLoader", ")", ":", "\n", "                ", "nbIter", "+=", "1", "\n", "if", "nbIter", "==", "totalIter", ":", "\n", "                    ", "break", "\n", "\n", "", "lrUpdate", "=", "nbIter", "/", "float", "(", "totalIter", ")", "*", "lr", "\n", "for", "g", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "                    ", "g", "[", "'lr'", "]", "=", "lrUpdate", "\n", "\n", "", "inputs", "=", "to_device", "(", "inputs", ",", "self", ".", "device", ")", "\n", "targets", "=", "to_device", "(", "targets", ",", "self", ".", "device", ")", "\n", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "outputs", "=", "self", ".", "netFeat", "(", "inputs", ")", "\n", "outputs", "=", "self", ".", "netClassifier", "(", "outputs", ")", "\n", "loss", "=", "self", ".", "criterion", "(", "outputs", ",", "targets", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "acc1", ",", "acc5", "=", "accuracy", "(", "outputs", ",", "targets", ",", "topk", "=", "(", "1", ",", "5", ")", ")", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top5", ".", "update", "(", "acc5", "[", "0", "]", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "\n", "msg", "=", "'Loss: {:.3f} | Lr : {:.5f} | Top1: {:.3f}% | Top5: {:.3f}%'", ".", "format", "(", "\n", "losses", ".", "avg", ",", "lrUpdate", ",", "top1", ".", "avg", ",", "top5", ".", "avg", ")", "\n", "progress_bar", "(", "batchIdx", ",", "len", "(", "self", ".", "trainLoader", ")", ",", "msg", ")", "\n", "\n", "", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "valTop1", "=", "self", ".", "test", "(", "0", ")", "\n", "\n", "", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "itertools", ".", "chain", "(", "*", "[", "self", ".", "netFeat", ".", "parameters", "(", ")", ",", "\n", "self", ".", "netClassifier", ".", "parameters", "(", ")", "]", ")", ",", "\n", "lrUpdate", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "5e-4", ",", "\n", "nesterov", "=", "True", ")", "\n", "\n", "self", ".", "lrScheduler", "=", "MultiStepLR", "(", "self", ".", "optimizer", ",", "milestones", "=", "self", ".", "milestones", ",", "gamma", "=", "0.1", ")", "\n", "return", "valTop1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.BaseTrainer.train": [[211, 243], ["print", "main_feat.BaseTrainer.netFeat.train", "main_feat.BaseTrainer.netClassifier.train", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "enumerate", "utils.utils.to_device", "utils.utils.to_device", "main_feat.BaseTrainer.optimizer.zero_grad", "main_feat.BaseTrainer.netFeat", "main_feat.BaseTrainer.netClassifier", "main_feat.BaseTrainer.criterion", "main_feat.BaseTrainer.backward", "main_feat.BaseTrainer.optimizer.step", "utils.outils.accuracy", "utils.outils.AverageMeter.update", "utils.outils.AverageMeter.update", "utils.outils.AverageMeter.update", "utils.outils.progress_bar", "main_feat.BaseTrainer.item", "acc1[].item", "acc5[].item", "len", "utils.utils.to_device.size", "utils.utils.to_device.size", "utils.utils.to_device.size"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar"], ["", "def", "train", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "msg", "=", "'\\nTrain at Epoch: {:d}'", ".", "format", "(", "epoch", ")", "\n", "print", "(", "msg", ")", "\n", "\n", "self", ".", "netFeat", ".", "train", "(", ")", "\n", "self", ".", "netClassifier", ".", "train", "(", ")", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "top5", "=", "AverageMeter", "(", ")", "\n", "\n", "for", "batchIdx", ",", "(", "inputs", ",", "targets", ")", "in", "enumerate", "(", "self", ".", "trainLoader", ")", ":", "\n", "\n", "            ", "inputs", "=", "to_device", "(", "inputs", ",", "self", ".", "device", ")", "\n", "targets", "=", "to_device", "(", "targets", ",", "self", ".", "device", ")", "\n", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "outputs", "=", "self", ".", "netFeat", "(", "inputs", ")", "\n", "outputs", "=", "self", ".", "netClassifier", "(", "outputs", ")", "\n", "loss", "=", "self", ".", "criterion", "(", "outputs", ",", "targets", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "acc1", ",", "acc5", "=", "accuracy", "(", "outputs", ",", "targets", ",", "topk", "=", "(", "1", ",", "5", ")", ")", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "top5", ".", "update", "(", "acc5", "[", "0", "]", ".", "item", "(", ")", ",", "inputs", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "\n", "msg", "=", "'Loss: {:.3f} | Top1: {:.3f}% | Top5: {:.3f}%'", ".", "format", "(", "losses", ".", "avg", ",", "top1", ".", "avg", ",", "top5", ".", "avg", ")", "\n", "progress_bar", "(", "batchIdx", ",", "len", "(", "self", ".", "trainLoader", ")", ",", "msg", ")", "\n", "\n", "", "return", "losses", ".", "avg", ",", "top1", ".", "avg", ",", "top5", ".", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.main_feat.BaseTrainer.test": [[244, 286], ["print", "main_feat.BaseTrainer.netFeat.eval", "main_feat.BaseTrainer.netClassifierVal.eval", "utils.outils.AverageMeter", "enumerate", "print", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "utils.utils.to_device", "main_feat.BaseTrainer.netClassifierVal", "clsScore.view.view.view", "utils.outils.accuracy", "utils.outils.AverageMeter.update", "utils.outils.progress_bar", "print", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "main_feat.BaseTrainer.netFeat.state_dict", "os.path.join", "main_feat.BaseTrainer.netClassifier.state_dict", "os.path.join", "data[].squeeze", "data[].squeeze", "data[].squeeze", "data[].squeeze", "main_feat.BaseTrainer.netFeat", "main_feat.BaseTrainer.netFeat", "SupportFeat.unsqueeze", "QueryFeat.unsqueeze", "acc1[].item", "len", "main_feat.BaseTrainer.netFeat.state_dict", "os.path.join", "main_feat.BaseTrainer.netClassifier.state_dict", "os.path.join", "QueryFeat.size", "clsScore.view.view.size"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save"], ["", "def", "test", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "msg", "=", "'\\nTest at Epoch: {:d}'", ".", "format", "(", "epoch", ")", "\n", "print", "(", "msg", ")", "\n", "\n", "self", ".", "netFeat", ".", "eval", "(", ")", "\n", "self", ".", "netClassifierVal", ".", "eval", "(", ")", "\n", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "\n", "for", "batchIdx", ",", "data", "in", "enumerate", "(", "self", ".", "valLoader", ")", ":", "\n", "            ", "data", "=", "to_device", "(", "data", ",", "self", ".", "device", ")", "\n", "\n", "SupportTensor", ",", "SupportLabel", ",", "QueryTensor", ",", "QueryLabel", "=", "data", "[", "'SupportTensor'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'SupportLabel'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'QueryTensor'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'QueryLabel'", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "SupportFeat", ",", "QueryFeat", "=", "self", ".", "netFeat", "(", "SupportTensor", ")", ",", "self", ".", "netFeat", "(", "QueryTensor", ")", "\n", "SupportFeat", ",", "QueryFeat", "=", "SupportFeat", ".", "unsqueeze", "(", "0", ")", ",", "QueryFeat", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "clsScore", "=", "self", ".", "netClassifierVal", "(", "SupportFeat", ",", "QueryFeat", ")", "\n", "clsScore", "=", "clsScore", ".", "view", "(", "QueryFeat", ".", "size", "(", ")", "[", "1", "]", ",", "-", "1", ")", "\n", "\n", "acc1", "=", "accuracy", "(", "clsScore", ",", "QueryLabel", ",", "topk", "=", "(", "1", ",", ")", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ",", "clsScore", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "msg", "=", "'Top1: {:.3f}%'", ".", "format", "(", "top1", ".", "avg", ")", "\n", "progress_bar", "(", "batchIdx", ",", "len", "(", "self", ".", "valLoader", ")", ",", "msg", ")", "\n", "\n", "## Save checkpoint.", "\n", "", "acc", "=", "top1", ".", "avg", "\n", "if", "acc", ">", "self", ".", "bestAcc", ":", "\n", "            ", "print", "(", "'Saving Best'", ")", "\n", "torch", ".", "save", "(", "self", ".", "netFeat", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netFeatBest.pth'", ")", ")", "\n", "torch", ".", "save", "(", "self", ".", "netClassifier", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netClsBest.pth'", ")", ")", "\n", "self", ".", "bestAcc", "=", "acc", "\n", "\n", "", "print", "(", "'Saving Last'", ")", "\n", "torch", ".", "save", "(", "self", ".", "netFeat", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netFeatLast.pth'", ")", ")", "\n", "torch", ".", "save", "(", "self", ".", "netClassifier", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netClsLast.pth'", ")", ")", "\n", "\n", "msg", "=", "'Best Performance: {:.3f}'", ".", "format", "(", "self", ".", "bestAcc", ")", "\n", "print", "(", "msg", ")", "\n", "return", "top1", ".", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataset.dataset_setting": [[18, 78], ["torchvision.Normalize", "torchvision.Compose", "torchvision.Compose", "torchvision.Normalize", "torchvision.Compose", "torchvision.Compose", "ValueError", "torchvision.RandomCrop", "torchvision.ColorJitter", "torchvision.RandomHorizontalFlip", "torchvision.ToTensor", "torchvision.CenterCrop", "torchvision.ToTensor", "numpy.asarray", "numpy.asarray", "torchvision.RandomCrop", "torchvision.ColorJitter", "torchvision.RandomHorizontalFlip", "torchvision.ToTensor", "torchvision.ToTensor", "numpy.asarray", "numpy.asarray"], "function", ["None"], ["def", "dataset_setting", "(", "dataset", ",", "nSupport", ")", ":", "\n", "    ", "\"\"\"\n    Return dataset setting\n\n    :param string dataset: name of dataset\n    :param int nSupport: number of support examples\n    \"\"\"", "\n", "if", "dataset", "==", "'miniImageNet'", ":", "\n", "        ", "mean", "=", "[", "x", "/", "255.0", "for", "x", "in", "[", "120.39586422", ",", "115.59361427", ",", "104.54012653", "]", "]", "\n", "std", "=", "[", "x", "/", "255.0", "for", "x", "in", "[", "70.68188272", ",", "68.27635443", ",", "72.54505529", "]", "]", "\n", "normalize", "=", "transforms", ".", "Normalize", "(", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "trainTransform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "RandomCrop", "(", "80", ",", "padding", "=", "8", ")", ",", "\n", "transforms", ".", "ColorJitter", "(", "brightness", "=", "0.4", ",", "contrast", "=", "0.4", ",", "saturation", "=", "0.4", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "lambda", "x", ":", "np", ".", "asarray", "(", "x", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "normalize", "\n", "]", ")", "\n", "\n", "valTransform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "CenterCrop", "(", "80", ")", ",", "\n", "lambda", "x", ":", "np", ".", "asarray", "(", "x", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "normalize", "]", ")", "\n", "\n", "inputW", ",", "inputH", ",", "nbCls", "=", "80", ",", "80", ",", "64", "\n", "\n", "trainDir", "=", "'./data/Mini-ImageNet/train/'", "\n", "valDir", "=", "'./data/Mini-ImageNet/val/'", "\n", "testDir", "=", "'./data/Mini-ImageNet/test/'", "\n", "episodeJson", "=", "'./data/Mini-ImageNet/val1000Episode_5_way_1_shot.json'", "if", "nSupport", "==", "1", "else", "'./data/Mini-ImageNet/val1000Episode_5_way_5_shot.json'", "\n", "\n", "", "elif", "dataset", "==", "'Cifar'", ":", "\n", "        ", "mean", "=", "[", "x", "/", "255.0", "for", "x", "in", "[", "129.37731888", ",", "124.10583864", ",", "112.47758569", "]", "]", "\n", "std", "=", "[", "x", "/", "255.0", "for", "x", "in", "[", "68.20947949", ",", "65.43124043", ",", "70.45866994", "]", "]", "\n", "normalize", "=", "transforms", ".", "Normalize", "(", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "trainTransform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "RandomCrop", "(", "32", ",", "padding", "=", "4", ")", ",", "\n", "transforms", ".", "ColorJitter", "(", "brightness", "=", "0.4", ",", "contrast", "=", "0.4", ",", "saturation", "=", "0.4", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "lambda", "x", ":", "np", ".", "asarray", "(", "x", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "normalize", "\n", "]", ")", "\n", "\n", "valTransform", "=", "transforms", ".", "Compose", "(", "[", "lambda", "x", ":", "np", ".", "asarray", "(", "x", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "normalize", "]", ")", "\n", "inputW", ",", "inputH", ",", "nbCls", "=", "32", ",", "32", ",", "64", "\n", "\n", "trainDir", "=", "'./data/cifar-fs/train/'", "\n", "valDir", "=", "'./data/cifar-fs/val/'", "\n", "testDir", "=", "'./data/cifar-fs/test/'", "\n", "episodeJson", "=", "'./data/cifar-fs/val1000Episode_5_way_1_shot.json'", "if", "nSupport", "==", "1", "else", "'./data/cifar-fs/val1000Episode_5_way_5_shot.json'", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Do not support other datasets yet.'", ")", "\n", "\n", "", "return", "trainTransform", ",", "valTransform", ",", "inputW", ",", "inputH", ",", "trainDir", ",", "valDir", ",", "testDir", ",", "episodeJson", ",", "nbCls", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.EpisodeSampler.__init__": [[44, 60], ["os.listdir", "floatType", "intType", "floatType", "intType", "floatType"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "imgDir", ",", "nClsEpisode", ",", "nSupport", ",", "nQuery", ",", "transform", ",", "useGPU", ",", "inputW", ",", "inputH", ")", ":", "\n", "        ", "self", ".", "imgDir", "=", "imgDir", "\n", "self", ".", "clsList", "=", "os", ".", "listdir", "(", "imgDir", ")", "\n", "self", ".", "nClsEpisode", "=", "nClsEpisode", "\n", "self", ".", "nSupport", "=", "nSupport", "\n", "self", ".", "nQuery", "=", "nQuery", "\n", "self", ".", "transform", "=", "transform", "\n", "\n", "floatType", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "useGPU", "else", "torch", ".", "FloatTensor", "\n", "intType", "=", "torch", ".", "cuda", ".", "LongTensor", "if", "useGPU", "else", "torch", ".", "LongTensor", "\n", "\n", "self", ".", "tensorSupport", "=", "floatType", "(", "nClsEpisode", "*", "nSupport", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelSupport", "=", "intType", "(", "nClsEpisode", "*", "nSupport", ")", "\n", "self", ".", "tensorQuery", "=", "floatType", "(", "nClsEpisode", "*", "nQuery", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelQuery", "=", "intType", "(", "nClsEpisode", "*", "nQuery", ")", "\n", "self", ".", "imgTensor", "=", "floatType", "(", "3", ",", "inputW", ",", "inputH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.EpisodeSampler.getEpisode": [[61, 104], ["range", "numpy.random.choice", "enumerate", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "os.path.join", "os.listdir", "numpy.random.choice", "range", "range", "os.path.join", "dataloader.PilLoaderRGB", "dataloader.EpisodeSampler.imgTensor.copy_", "os.path.join", "dataloader.PilLoaderRGB", "dataloader.EpisodeSampler.imgTensor.copy_", "dataloader.EpisodeSampler.transform", "dataloader.EpisodeSampler.transform"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.PilLoaderRGB", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.PilLoaderRGB"], ["", "def", "getEpisode", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return an episode\n\n        :return dict: {'SupportTensor': 1 x nSupport x 3 x H x W,\n                       'SupportLabel': 1 x nSupport,\n                       'QueryTensor': 1 x nQuery x 3 x H x W,\n                       'QueryLabel': 1 x nQuery}\n        \"\"\"", "\n", "# labels {0, ..., nClsEpisode-1}", "\n", "for", "i", "in", "range", "(", "self", ".", "nClsEpisode", ")", ":", "\n", "            ", "self", ".", "labelSupport", "[", "i", "*", "self", ".", "nSupport", ":", "(", "i", "+", "1", ")", "*", "self", ".", "nSupport", "]", "=", "i", "\n", "self", ".", "labelQuery", "[", "i", "*", "self", ".", "nQuery", ":", "(", "i", "+", "1", ")", "*", "self", ".", "nQuery", "]", "=", "i", "\n", "\n", "# select nClsEpisode from clsList", "\n", "", "clsEpisode", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "clsList", ",", "self", ".", "nClsEpisode", ",", "replace", "=", "False", ")", "\n", "for", "i", ",", "cls", "in", "enumerate", "(", "clsEpisode", ")", ":", "\n", "            ", "clsPath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "imgDir", ",", "cls", ")", "\n", "imgList", "=", "os", ".", "listdir", "(", "clsPath", ")", "\n", "\n", "# in total nQuery+nSupport images from each class", "\n", "imgCls", "=", "np", ".", "random", ".", "choice", "(", "imgList", ",", "self", ".", "nQuery", "+", "self", ".", "nSupport", ",", "replace", "=", "False", ")", "\n", "\n", "for", "j", "in", "range", "(", "self", ".", "nSupport", ")", ":", "\n", "                ", "img", "=", "imgCls", "[", "j", "]", "\n", "imgPath", "=", "os", ".", "path", ".", "join", "(", "clsPath", ",", "img", ")", "\n", "I", "=", "PilLoaderRGB", "(", "imgPath", ")", "\n", "self", ".", "tensorSupport", "[", "i", "*", "self", ".", "nSupport", "+", "j", "]", "=", "self", ".", "imgTensor", ".", "copy_", "(", "self", ".", "transform", "(", "I", ")", ")", "\n", "\n", "", "for", "j", "in", "range", "(", "self", ".", "nQuery", ")", ":", "\n", "                ", "img", "=", "imgCls", "[", "j", "+", "self", ".", "nSupport", "]", "\n", "imgPath", "=", "os", ".", "path", ".", "join", "(", "clsPath", ",", "img", ")", "\n", "I", "=", "PilLoaderRGB", "(", "imgPath", ")", "\n", "self", ".", "tensorQuery", "[", "i", "*", "self", ".", "nQuery", "+", "j", "]", "=", "self", ".", "imgTensor", ".", "copy_", "(", "self", ".", "transform", "(", "I", ")", ")", "\n", "\n", "## Random permutation. Though this is not necessary in our approach", "\n", "", "", "permSupport", "=", "torch", ".", "randperm", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nSupport", ")", "\n", "permQuery", "=", "torch", ".", "randperm", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nQuery", ")", "\n", "\n", "return", "{", "'SupportTensor'", ":", "self", ".", "tensorSupport", "[", "permSupport", "]", ",", "\n", "'SupportLabel'", ":", "self", ".", "labelSupport", "[", "permSupport", "]", ",", "\n", "'QueryTensor'", ":", "self", ".", "tensorQuery", "[", "permQuery", "]", ",", "\n", "'QueryLabel'", ":", "self", ".", "labelQuery", "[", "permQuery", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.BatchSampler.__init__": [[122, 135], ["dataloader.EpisodeSampler", "floatType", "intType", "floatType", "intType"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "imgDir", ",", "nClsEpisode", ",", "nSupport", ",", "nQuery", ",", "transform", ",", "useGPU", ",", "inputW", ",", "inputH", ",", "batchSize", ")", ":", "\n", "        ", "self", ".", "episodeSampler", "=", "EpisodeSampler", "(", "imgDir", ",", "nClsEpisode", ",", "nSupport", ",", "nQuery", ",", "\n", "transform", ",", "useGPU", ",", "inputW", ",", "inputH", ")", "\n", "\n", "floatType", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "useGPU", "else", "torch", ".", "FloatTensor", "\n", "intType", "=", "torch", ".", "cuda", ".", "LongTensor", "if", "useGPU", "else", "torch", ".", "LongTensor", "\n", "\n", "self", ".", "tensorSupport", "=", "floatType", "(", "batchSize", ",", "nClsEpisode", "*", "nSupport", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelSupport", "=", "intType", "(", "batchSize", ",", "nClsEpisode", "*", "nSupport", ")", "\n", "self", ".", "tensorQuery", "=", "floatType", "(", "batchSize", ",", "nClsEpisode", "*", "nQuery", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelQuery", "=", "intType", "(", "batchSize", ",", "nClsEpisode", "*", "nQuery", ")", "\n", "\n", "self", ".", "batchSize", "=", "batchSize", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.BatchSampler.getBatch": [[136, 156], ["range", "dataloader.BatchSampler.episodeSampler.getEpisode"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.EpisodeSampler.getEpisode"], ["", "def", "getBatch", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return an episode\n\n        :return dict: {'SupportTensor': B x nSupport x 3 x H x W,\n                       'SupportLabel': B x nSupport,\n                       'QueryTensor': B x nQuery x 3 x H x W,\n                       'QueryLabel': B x nQuery}\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "self", ".", "batchSize", ")", ":", "\n", "            ", "episode", "=", "self", ".", "episodeSampler", ".", "getEpisode", "(", ")", "\n", "self", ".", "tensorSupport", "[", "i", "]", "=", "episode", "[", "'SupportTensor'", "]", "\n", "self", ".", "labelSupport", "[", "i", "]", "=", "episode", "[", "'SupportLabel'", "]", "\n", "self", ".", "tensorQuery", "[", "i", "]", "=", "episode", "[", "'QueryTensor'", "]", "\n", "self", ".", "labelQuery", "[", "i", "]", "=", "episode", "[", "'QueryLabel'", "]", "\n", "\n", "", "return", "{", "'SupportTensor'", ":", "self", ".", "tensorSupport", ",", "\n", "'SupportLabel'", ":", "self", ".", "labelSupport", ",", "\n", "'QueryTensor'", ":", "self", ".", "tensorQuery", ",", "\n", "'QueryLabel'", ":", "self", ".", "labelQuery", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.ValImageFolder.__init__": [[170, 192], ["len", "len", "len", "len", "floatType", "intType", "floatType", "intType", "floatType", "range", "open", "json.load"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["def", "__init__", "(", "self", ",", "episodeJson", ",", "imgDir", ",", "inputW", ",", "inputH", ",", "valTransform", ",", "useGPU", ")", ":", "\n", "        ", "with", "open", "(", "episodeJson", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "self", ".", "episodeInfo", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "self", ".", "imgDir", "=", "imgDir", "\n", "self", ".", "nEpisode", "=", "len", "(", "self", ".", "episodeInfo", ")", "\n", "self", ".", "nClsEpisode", "=", "len", "(", "self", ".", "episodeInfo", "[", "0", "]", "[", "'Support'", "]", ")", "\n", "self", ".", "nSupport", "=", "len", "(", "self", ".", "episodeInfo", "[", "0", "]", "[", "'Support'", "]", "[", "0", "]", ")", "\n", "self", ".", "nQuery", "=", "len", "(", "self", ".", "episodeInfo", "[", "0", "]", "[", "'Query'", "]", "[", "0", "]", ")", "\n", "self", ".", "transform", "=", "valTransform", "\n", "floatType", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "useGPU", "else", "torch", ".", "FloatTensor", "\n", "intType", "=", "torch", ".", "cuda", ".", "LongTensor", "if", "useGPU", "else", "torch", ".", "LongTensor", "\n", "\n", "self", ".", "tensorSupport", "=", "floatType", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nSupport", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelSupport", "=", "intType", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nSupport", ")", "\n", "self", ".", "tensorQuery", "=", "floatType", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nQuery", ",", "3", ",", "inputW", ",", "inputH", ")", "\n", "self", ".", "labelQuery", "=", "intType", "(", "self", ".", "nClsEpisode", "*", "self", ".", "nQuery", ")", "\n", "\n", "self", ".", "imgTensor", "=", "floatType", "(", "3", ",", "inputW", ",", "inputH", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "nClsEpisode", ")", ":", "\n", "            ", "self", ".", "labelSupport", "[", "i", "*", "self", ".", "nSupport", ":", "(", "i", "+", "1", ")", "*", "self", ".", "nSupport", "]", "=", "i", "\n", "self", ".", "labelQuery", "[", "i", "*", "self", ".", "nQuery", ":", "(", "i", "+", "1", ")", "*", "self", ".", "nQuery", "]", "=", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.ValImageFolder.__getitem__": [[194, 219], ["range", "range", "range", "os.path.join", "dataloader.PilLoaderRGB", "dataloader.ValImageFolder.imgTensor.copy_", "os.path.join", "dataloader.PilLoaderRGB", "dataloader.ValImageFolder.imgTensor.copy_", "dataloader.ValImageFolder.transform", "dataloader.ValImageFolder.transform"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.PilLoaderRGB", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.PilLoaderRGB"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Return an episode\n\n        :param int index: index of data example\n        :return dict: {'SupportTensor': 1 x nSupport x 3 x H x W,\n                       'SupportLabel': 1 x nSupport,\n                       'QueryTensor': 1 x nQuery x 3 x H x W,\n                       'QueryLabel': 1 x nQuery}\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "self", ".", "nClsEpisode", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "self", ".", "nSupport", ")", ":", "\n", "                ", "imgPath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "imgDir", ",", "self", ".", "episodeInfo", "[", "index", "]", "[", "'Support'", "]", "[", "i", "]", "[", "j", "]", ")", "\n", "I", "=", "PilLoaderRGB", "(", "imgPath", ")", "\n", "self", ".", "tensorSupport", "[", "i", "*", "self", ".", "nSupport", "+", "j", "]", "=", "self", ".", "imgTensor", ".", "copy_", "(", "self", ".", "transform", "(", "I", ")", ")", "\n", "\n", "", "for", "j", "in", "range", "(", "self", ".", "nQuery", ")", ":", "\n", "                ", "imgPath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "imgDir", ",", "self", ".", "episodeInfo", "[", "index", "]", "[", "'Query'", "]", "[", "i", "]", "[", "j", "]", ")", "\n", "I", "=", "PilLoaderRGB", "(", "imgPath", ")", "\n", "self", ".", "tensorQuery", "[", "i", "*", "self", ".", "nQuery", "+", "j", "]", "=", "self", ".", "imgTensor", ".", "copy_", "(", "self", ".", "transform", "(", "I", ")", ")", "\n", "\n", "", "", "return", "{", "'SupportTensor'", ":", "self", ".", "tensorSupport", ",", "\n", "'SupportLabel'", ":", "self", ".", "labelSupport", ",", "\n", "'QueryTensor'", ":", "self", ".", "tensorQuery", ",", "\n", "'QueryLabel'", ":", "self", ".", "labelQuery", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.ValImageFolder.__len__": [[221, 226], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Number of episodes\n        \"\"\"", "\n", "return", "self", ".", "nEpisode", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.PilLoaderRGB": [[26, 28], ["PIL.open().convert", "PIL.open"], "function", ["None"], ["def", "PilLoaderRGB", "(", "imgPath", ")", ":", "\n", "    ", "return", "Image", ".", "open", "(", "imgPath", ")", ".", "convert", "(", "'RGB'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.ValLoader": [[228, 233], ["torch.DataLoader", "dataloader.ValImageFolder"], "function", ["None"], ["", "", "def", "ValLoader", "(", "episodeJson", ",", "imgDir", ",", "inputW", ",", "inputH", ",", "valTransform", ",", "useGPU", ")", ":", "\n", "    ", "dataloader", "=", "data", ".", "DataLoader", "(", "ValImageFolder", "(", "episodeJson", ",", "imgDir", ",", "inputW", ",", "inputH", ",", "\n", "valTransform", ",", "useGPU", ")", ",", "\n", "shuffle", "=", "False", ")", "\n", "return", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.TrainLoader": [[235, 239], ["torch.DataLoader", "torchvision.datasets.ImageFolder"], "function", ["None"], ["", "def", "TrainLoader", "(", "batchSize", ",", "imgDir", ",", "trainTransform", ")", ":", "\n", "    ", "dataloader", "=", "data", ".", "DataLoader", "(", "ImageFolder", "(", "imgDir", ",", "trainTransform", ")", ",", "\n", "batch_size", "=", "batchSize", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "return", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.__init__": [[39, 69], ["torch.device", "torch.device", "torch.device", "torch.device", "algorithm.Algorithm.netFeat.load_state_dict", "algorithm.Algorithm.logger.info", "algorithm.Algorithm.load_ckpt", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.load_ckpt", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["def", "__init__", "(", "self", ",", "args", ",", "logger", ",", "netFeat", ",", "netSIB", ",", "optimizer", ",", "criterion", ")", ":", "\n", "        ", "self", ".", "netFeat", "=", "netFeat", "\n", "self", ".", "netSIB", "=", "netSIB", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "criterion", "=", "criterion", "\n", "\n", "self", ".", "nbIter", "=", "args", ".", "nbIter", "\n", "self", ".", "nStep", "=", "args", ".", "nStep", "\n", "self", ".", "outDir", "=", "args", ".", "outDir", "\n", "self", ".", "nFeat", "=", "args", ".", "nFeat", "\n", "self", ".", "batchSize", "=", "args", ".", "batchSize", "\n", "self", ".", "nEpisode", "=", "args", ".", "nEpisode", "\n", "self", ".", "momentum", "=", "args", ".", "momentum", "\n", "self", ".", "weightDecay", "=", "args", ".", "weightDecay", "\n", "\n", "self", ".", "logger", "=", "logger", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "args", ".", "cuda", "else", "'cpu'", ")", "\n", "\n", "# Load pretrained model", "\n", "if", "args", ".", "resumeFeatPth", ":", "\n", "            ", "if", "args", ".", "cuda", ":", "\n", "                ", "param", "=", "torch", ".", "load", "(", "args", ".", "resumeFeatPth", ")", "\n", "", "else", ":", "\n", "                ", "param", "=", "torch", ".", "load", "(", "args", ".", "resumeFeatPth", ",", "map_location", "=", "'cpu'", ")", "\n", "", "self", ".", "netFeat", ".", "load_state_dict", "(", "param", ")", "\n", "msg", "=", "'\\nLoading netFeat from {}'", ".", "format", "(", "args", ".", "resumeFeatPth", ")", "\n", "self", ".", "logger", ".", "info", "(", "msg", ")", "\n", "\n", "", "if", "args", ".", "test", ":", "\n", "            ", "self", ".", "load_ckpt", "(", "args", ".", "ckptPth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.load_ckpt": [[71, 89], ["torch.load", "torch.load", "torch.load", "torch.load", "algorithm.Algorithm.netFeat.load_state_dict", "algorithm.Algorithm.netSIB.load_state_dict", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "algorithm.Algorithm.logger.info", "itertools.chain", "algorithm.Algorithm.netSIB.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "", "def", "load_ckpt", "(", "self", ",", "ckptPth", ")", ":", "\n", "        ", "\"\"\"\n        Load checkpoint from ckptPth.\n\n        :param ckptPth: the path to the ckpt\n        :type ckptPth: string\n        \"\"\"", "\n", "param", "=", "torch", ".", "load", "(", "ckptPth", ")", "\n", "self", ".", "netFeat", ".", "load_state_dict", "(", "param", "[", "'netFeat'", "]", ")", "\n", "self", ".", "netSIB", ".", "load_state_dict", "(", "param", "[", "'SIB'", "]", ")", "\n", "lr", "=", "param", "[", "'lr'", "]", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "itertools", ".", "chain", "(", "*", "[", "self", ".", "netSIB", ".", "parameters", "(", ")", ",", "]", ")", ",", "\n", "lr", ",", "\n", "momentum", "=", "self", ".", "momentum", ",", "\n", "weight_decay", "=", "self", ".", "weightDecay", ",", "\n", "nesterov", "=", "True", ")", "\n", "msg", "=", "'\\nLoading networks from {}'", ".", "format", "(", "ckptPth", ")", "\n", "self", ".", "logger", ".", "info", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.compute_grad_loss": [[91, 113], ["algorithm.Algorithm.compute_grad_loss.require_nonleaf_grad"], "methods", ["None"], ["", "def", "compute_grad_loss", "(", "self", ",", "clsScore", ",", "QueryLabel", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss between true gradients and synthetic gradients.\n        \"\"\"", "\n", "# register hooks", "\n", "def", "require_nonleaf_grad", "(", "v", ")", ":", "\n", "            ", "def", "hook", "(", "g", ")", ":", "\n", "                ", "v", ".", "grad_nonleaf", "=", "g", "\n", "", "h", "=", "v", ".", "register_hook", "(", "hook", ")", "\n", "return", "h", "\n", "", "handle", "=", "require_nonleaf_grad", "(", "clsScore", ")", "\n", "\n", "loss", "=", "self", ".", "criterion", "(", "clsScore", ",", "QueryLabel", ")", "\n", "loss", ".", "backward", "(", "retain_graph", "=", "True", ")", "# need to backward again", "\n", "\n", "# remove hook", "\n", "handle", ".", "remove", "(", ")", "\n", "\n", "gradLogit", "=", "self", ".", "netSIB", ".", "dni", "(", "clsScore", ")", "# B * n x nKnovel", "\n", "gradLoss", "=", "F", ".", "mse_loss", "(", "gradLogit", ",", "clsScore", ".", "grad_nonleaf", ".", "detach", "(", ")", ")", "\n", "\n", "return", "loss", ",", "gradLoss", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.validate": [[115, 169], ["utils.outils.AverageMeter", "algorithm.Algorithm.netFeat.eval", "range", "utils.outils.getCi", "algorithm.Algorithm.logger.info", "algorithm.Algorithm.logger.info", "utils.utils.to_device", "algorithm.Algorithm.netSIB", "clsScore.view.view.view", "QueryLabel.view.view.view", "utils.outils.accuracy", "utils.outils.AverageMeter.update", "utils.outils.progress_bar", "episodeAccLog.append", "len", "algorithm.Algorithm.logger.info", "iter", "ValueError", "iter.getEpisode", "next", "data[].squeeze", "data[].squeeze", "data[].squeeze", "data[].squeeze", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "acc1[].item", "acc1[].item", "algorithm.Algorithm.netFeat", "algorithm.Algorithm.netFeat", "SupportFeat.unsqueeze", "QueryFeat.unsqueeze", "SupportLabel.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.getCi", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.EpisodeSampler.getEpisode"], ["", "def", "validate", "(", "self", ",", "valLoader", ",", "lr", "=", "None", ",", "mode", "=", "'val'", ")", ":", "\n", "        ", "\"\"\"\n        Run one epoch on val-set.\n\n        :param valLoader: the dataloader of val-set\n        :type valLoader: class `ValLoader`\n        :param float lr: learning rate for synthetic GD\n        :param string mode: 'val' or 'train'\n        \"\"\"", "\n", "if", "mode", "==", "'test'", ":", "\n", "            ", "nEpisode", "=", "self", ".", "nEpisode", "\n", "self", ".", "logger", ".", "info", "(", "'\\n\\nTest mode: randomly sample {:d} episodes...'", ".", "format", "(", "nEpisode", ")", ")", "\n", "", "elif", "mode", "==", "'val'", ":", "\n", "            ", "nEpisode", "=", "len", "(", "valLoader", ")", "\n", "self", ".", "logger", ".", "info", "(", "'\\n\\nValidation mode: pre-defined {:d} episodes...'", ".", "format", "(", "nEpisode", ")", ")", "\n", "valLoader", "=", "iter", "(", "valLoader", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'mode is wrong!'", ")", "\n", "\n", "", "episodeAccLog", "=", "[", "]", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "\n", "self", ".", "netFeat", ".", "eval", "(", ")", "\n", "\n", "if", "lr", "is", "None", ":", "\n", "            ", "lr", "=", "self", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "\n", "\n", "#for batchIdx, data in enumerate(valLoader):", "\n", "", "for", "batchIdx", "in", "range", "(", "nEpisode", ")", ":", "\n", "            ", "data", "=", "valLoader", ".", "getEpisode", "(", ")", "if", "mode", "==", "'test'", "else", "next", "(", "valLoader", ")", "\n", "data", "=", "to_device", "(", "data", ",", "self", ".", "device", ")", "\n", "\n", "SupportTensor", ",", "SupportLabel", ",", "QueryTensor", ",", "QueryLabel", "=", "data", "[", "'SupportTensor'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'SupportLabel'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'QueryTensor'", "]", ".", "squeeze", "(", "0", ")", ",", "data", "[", "'QueryLabel'", "]", ".", "squeeze", "(", "0", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "SupportFeat", ",", "QueryFeat", "=", "self", ".", "netFeat", "(", "SupportTensor", ")", ",", "self", ".", "netFeat", "(", "QueryTensor", ")", "\n", "SupportFeat", ",", "QueryFeat", ",", "SupportLabel", "=", "SupportFeat", ".", "unsqueeze", "(", "0", ")", ",", "QueryFeat", ".", "unsqueeze", "(", "0", ")", ",", "SupportLabel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "clsScore", "=", "self", ".", "netSIB", "(", "SupportFeat", ",", "SupportLabel", ",", "QueryFeat", ",", "lr", ")", "\n", "clsScore", "=", "clsScore", ".", "view", "(", "QueryFeat", ".", "shape", "[", "0", "]", "*", "QueryFeat", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "QueryLabel", "=", "QueryLabel", ".", "view", "(", "-", "1", ")", "\n", "acc1", "=", "accuracy", "(", "clsScore", ",", "QueryLabel", ",", "topk", "=", "(", "1", ",", ")", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ",", "clsScore", ".", "shape", "[", "0", "]", ")", "\n", "\n", "msg", "=", "'Top1: {:.3f}%'", ".", "format", "(", "top1", ".", "avg", ")", "\n", "progress_bar", "(", "batchIdx", ",", "nEpisode", ",", "msg", ")", "\n", "episodeAccLog", ".", "append", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "mean", ",", "ci95", "=", "getCi", "(", "episodeAccLog", ")", "\n", "self", ".", "logger", ".", "info", "(", "'Final Perf with 95% confidence intervals: {:.3f}%, {:.3f}%'", ".", "format", "(", "mean", ",", "ci95", ")", ")", "\n", "return", "mean", ",", "ci95", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train": [[171, 268], ["algorithm.Algorithm.validate", "algorithm.Algorithm.logger.info", "algorithm.Algorithm.netSIB.train", "algorithm.Algorithm.netFeat.eval", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "range", "trainLoader.getBatch", "utils.utils.to_device", "algorithm.Algorithm.optimizer.zero_grad", "algorithm.Algorithm.netSIB", "clsScore.view.view.view", "QueryLabel.view.view.view", "algorithm.Algorithm.backward", "algorithm.Algorithm.optimizer.step", "utils.outils.accuracy", "utils.outils.AverageMeter.update", "utils.outils.AverageMeter.update", "utils.outils.progress_bar", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "algorithm.Algorithm.netFeat", "SupportFeat.view.view.view", "algorithm.Algorithm.netFeat", "QueryFeat.view.view.view", "algorithm.Algorithm.compute_grad_loss", "algorithm.Algorithm.criterion", "acc1[].item", "algorithm.Algorithm.item", "algorithm.Algorithm.validate", "algorithm.Algorithm.logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "algorithm.Algorithm.logger.info", "history[].append", "history[].append", "history[].append", "utils.outils.AverageMeter", "utils.outils.AverageMeter", "SupportTensor.reshape", "QueryTensor.reshape", "algorithm.Algorithm.logger.info", "algorithm.Algorithm.logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.join", "gradLoss.item", "os.path.join", "algorithm.Algorithm.netFeat.state_dict", "algorithm.Algorithm.netSIB.state_dict", "algorithm.Algorithm.netFeat.state_dict", "algorithm.Algorithm.netSIB.state_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.validate", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.dataloader.BatchSampler.getBatch", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.compute_grad_loss", "home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.validate", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save"], ["", "def", "train", "(", "self", ",", "trainLoader", ",", "valLoader", ",", "lr", "=", "None", ",", "coeffGrad", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"\n        Run one epoch on train-set.\n\n        :param trainLoader: the dataloader of train-set\n        :type trainLoader: class `TrainLoader`\n        :param valLoader: the dataloader of val-set\n        :type valLoader: class `ValLoader`\n        :param float lr: learning rate for synthetic GD\n        :param float coeffGrad: deprecated\n        \"\"\"", "\n", "bestAcc", ",", "ci", "=", "self", ".", "validate", "(", "valLoader", ",", "lr", ")", "\n", "self", ".", "logger", ".", "info", "(", "'Acc improved over validation set from 0% ---> {:.3f} +- {:.3f}%'", ".", "format", "(", "bestAcc", ",", "ci", ")", ")", "\n", "\n", "self", ".", "netSIB", ".", "train", "(", ")", "\n", "self", ".", "netFeat", ".", "eval", "(", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "history", "=", "{", "'trainLoss'", ":", "[", "]", ",", "'trainAcc'", ":", "[", "]", ",", "'valAcc'", ":", "[", "]", "}", "\n", "\n", "for", "episode", "in", "range", "(", "self", ".", "nbIter", ")", ":", "\n", "            ", "data", "=", "trainLoader", ".", "getBatch", "(", ")", "\n", "data", "=", "to_device", "(", "data", ",", "self", ".", "device", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "SupportTensor", ",", "SupportLabel", ",", "QueryTensor", ",", "QueryLabel", "=", "data", "[", "'SupportTensor'", "]", ",", "data", "[", "'SupportLabel'", "]", ",", "data", "[", "'QueryTensor'", "]", ",", "data", "[", "'QueryLabel'", "]", "\n", "nC", ",", "nH", ",", "nW", "=", "SupportTensor", ".", "shape", "[", "2", ":", "]", "\n", "\n", "SupportFeat", "=", "self", ".", "netFeat", "(", "SupportTensor", ".", "reshape", "(", "-", "1", ",", "nC", ",", "nH", ",", "nW", ")", ")", "\n", "SupportFeat", "=", "SupportFeat", ".", "view", "(", "self", ".", "batchSize", ",", "-", "1", ",", "self", ".", "nFeat", ")", "\n", "\n", "QueryFeat", "=", "self", ".", "netFeat", "(", "QueryTensor", ".", "reshape", "(", "-", "1", ",", "nC", ",", "nH", ",", "nW", ")", ")", "\n", "QueryFeat", "=", "QueryFeat", ".", "view", "(", "self", ".", "batchSize", ",", "-", "1", ",", "self", ".", "nFeat", ")", "\n", "\n", "", "if", "lr", "is", "None", ":", "\n", "                ", "lr", "=", "self", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "clsScore", "=", "self", ".", "netSIB", "(", "SupportFeat", ",", "SupportLabel", ",", "QueryFeat", ",", "lr", ")", "\n", "clsScore", "=", "clsScore", ".", "view", "(", "QueryFeat", ".", "shape", "[", "0", "]", "*", "QueryFeat", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "QueryLabel", "=", "QueryLabel", ".", "view", "(", "-", "1", ")", "\n", "\n", "if", "coeffGrad", ">", "0", ":", "\n", "                ", "loss", ",", "gradLoss", "=", "self", ".", "compute_grad_loss", "(", "clsScore", ",", "QueryLabel", ")", "\n", "loss", "=", "loss", "+", "gradLoss", "*", "coeffGrad", "\n", "", "else", ":", "\n", "                ", "loss", "=", "self", ".", "criterion", "(", "clsScore", ",", "QueryLabel", ")", "\n", "\n", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "acc1", "=", "accuracy", "(", "clsScore", ",", "QueryLabel", ",", "topk", "=", "(", "1", ",", ")", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ".", "item", "(", ")", ",", "clsScore", ".", "shape", "[", "0", "]", ")", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "QueryFeat", ".", "shape", "[", "1", "]", ")", "\n", "msg", "=", "'Loss: {:.3f} | Top1: {:.3f}% '", ".", "format", "(", "losses", ".", "avg", ",", "top1", ".", "avg", ")", "\n", "if", "coeffGrad", ">", "0", ":", "\n", "                ", "msg", "=", "msg", "+", "'| gradLoss: {:.3f}%'", ".", "format", "(", "gradLoss", ".", "item", "(", ")", ")", "\n", "", "progress_bar", "(", "episode", ",", "self", ".", "nbIter", ",", "msg", ")", "\n", "\n", "if", "episode", "%", "1000", "==", "999", ":", "\n", "                ", "acc", ",", "_", "=", "self", ".", "validate", "(", "valLoader", ",", "lr", ")", "\n", "\n", "if", "acc", ">", "bestAcc", ":", "\n", "                    ", "msg", "=", "'Acc improved over validation set from {:.3f}% ---> {:.3f}%'", ".", "format", "(", "bestAcc", ",", "acc", ")", "\n", "self", ".", "logger", ".", "info", "(", "msg", ")", "\n", "\n", "bestAcc", "=", "acc", "\n", "self", ".", "logger", ".", "info", "(", "'Saving Best'", ")", "\n", "torch", ".", "save", "(", "{", "\n", "'lr'", ":", "lr", ",", "\n", "'netFeat'", ":", "self", ".", "netFeat", ".", "state_dict", "(", ")", ",", "\n", "'SIB'", ":", "self", ".", "netSIB", ".", "state_dict", "(", ")", ",", "\n", "'nbStep'", ":", "self", ".", "nStep", ",", "\n", "}", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netSIBBest.pth'", ")", ")", "\n", "\n", "", "self", ".", "logger", ".", "info", "(", "'Saving Last'", ")", "\n", "torch", ".", "save", "(", "{", "\n", "'lr'", ":", "lr", ",", "\n", "'netFeat'", ":", "self", ".", "netFeat", ".", "state_dict", "(", ")", ",", "\n", "'SIB'", ":", "self", ".", "netSIB", ".", "state_dict", "(", ")", ",", "\n", "'nbStep'", ":", "self", ".", "nStep", ",", "\n", "}", ",", "os", ".", "path", ".", "join", "(", "self", ".", "outDir", ",", "'netSIBLast.pth'", ")", ")", "\n", "\n", "msg", "=", "'Iter {:d}, Train Loss {:.3f}, Train Acc {:.3f}%, Val Acc {:.3f}%'", ".", "format", "(", "\n", "episode", ",", "losses", ".", "avg", ",", "top1", ".", "avg", ",", "acc", ")", "\n", "self", ".", "logger", ".", "info", "(", "msg", ")", "\n", "history", "[", "'trainLoss'", "]", ".", "append", "(", "losses", ".", "avg", ")", "\n", "history", "[", "'trainAcc'", "]", ".", "append", "(", "top1", ".", "avg", ")", "\n", "history", "[", "'valAcc'", "]", ".", "append", "(", "acc", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "top1", "=", "AverageMeter", "(", ")", "\n", "\n", "", "", "return", "bestAcc", ",", "acc", ",", "history", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.utils.config.create_dirs": [[21, 36], ["print", "exit", "os.path.exists", "os.makedirs"], "function", ["None"], ["def", "create_dirs", "(", "dirs", ")", ":", "\n", "    ", "\"\"\"\n    Create directories given by a list if these directories are not found\n\n    :param list dirs: directories\n    :return exit_code: 0:success -1:failed\n    \"\"\"", "\n", "try", ":", "\n", "        ", "for", "dir_", "in", "dirs", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "dir_", ")", "\n", "", "", "return", "0", "\n", "", "except", "Exception", "as", "err", ":", "\n", "        ", "print", "(", "\"Creating directories error: {0}\"", ".", "format", "(", "err", ")", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_config_from_json": [[38, 52], ["easydict.EasyDict", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "", "def", "get_config_from_json", "(", "json_file", ")", ":", "\n", "    ", "\"\"\"\n    Get the config from a json file\n\n    :param string json_file: json configuration file\n    :return: EasyDict config\n    \"\"\"", "\n", "# parse the configurations from the config json file provided", "\n", "with", "open", "(", "json_file", ",", "'r'", ")", "as", "config_file", ":", "\n", "        ", "config_dict", "=", "json", ".", "load", "(", "config_file", ")", "\n", "\n", "# convert the dictionary to a namespace using bunch lib", "\n", "", "config", "=", "EasyDict", "(", "config_dict", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_config_from_yaml": [[54, 67], ["easydict.EasyDict", "open", "yaml.load"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load"], ["", "def", "get_config_from_yaml", "(", "yaml_file", ")", ":", "\n", "    ", "\"\"\"\n    Get the config from a yaml file\n\n    :param string yaml_file: yaml configuration file\n    :return: EasyDict config\n    \"\"\"", "\n", "with", "open", "(", "yaml_file", ")", "as", "fp", ":", "\n", "        ", "config_dict", "=", "yaml", ".", "load", "(", "fp", ")", "\n", "\n", "# convert the dictionary to a namespace using bunch lib", "\n", "", "config", "=", "EasyDict", "(", "config_dict", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_args": [[69, 102], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "get_args", "(", ")", ":", "\n", "    ", "\"\"\"\n    Create argparser for frequent configurations.\n\n    :return: argparser object\n    \"\"\"", "\n", "argparser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "__doc__", ")", "\n", "argparser", ".", "add_argument", "(", "\n", "'-c'", ",", "'--config'", ",", "\n", "metavar", "=", "'C'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'The Configuration file'", ")", "\n", "argparser", ".", "add_argument", "(", "\n", "'-k'", ",", "'--steps'", ",", "\n", "default", "=", "3", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of SIB steps'", ")", "\n", "argparser", ".", "add_argument", "(", "\n", "'-s'", ",", "'--seed'", ",", "\n", "default", "=", "100", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The random seed'", ")", "\n", "argparser", ".", "add_argument", "(", "\n", "'--gpu'", ",", "\n", "default", "=", "0", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'GPU id'", ")", "\n", "argparser", ".", "add_argument", "(", "\n", "'--ckpt'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'The path to ckpt'", ")", "\n", "args", "=", "argparser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_config": [[104, 137], ["config.get_args", "config_file.endswith", "os.path.join", "os.path.join", "os.path.join", "config.create_dirs", "config.get_config_from_json", "config_file.endswith", "config.get_config_from_yaml", "Exception"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_args", "home.repos.pwc.inspect_result.amzn_xfer.utils.config.create_dirs", "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_config_from_json", "home.repos.pwc.inspect_result.amzn_xfer.utils.config.get_config_from_yaml"], ["", "def", "get_config", "(", ")", ":", "\n", "    ", "\"\"\"\n    Create experimental config from argparse and config file.\n\n    :return: Configuration EasyDict\n    \"\"\"", "\n", "# read manual args", "\n", "args", "=", "get_args", "(", ")", "\n", "config_file", "=", "args", ".", "config", "\n", "\n", "# load experimental configuration", "\n", "if", "config_file", ".", "endswith", "(", "'json'", ")", ":", "\n", "        ", "config", "=", "get_config_from_json", "(", "config_file", ")", "\n", "", "elif", "config_file", ".", "endswith", "(", "'yaml'", ")", ":", "\n", "        ", "config", "=", "get_config_from_yaml", "(", "config_file", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Only .json and .yaml are supported!\"", ")", "\n", "\n", "# reset config from args", "\n", "", "config", ".", "nStep", "=", "args", ".", "steps", "\n", "config", ".", "seed", "=", "args", ".", "seed", "\n", "config", ".", "gpu", "=", "args", ".", "gpu", "\n", "config", ".", "test", "=", "False", "if", "args", ".", "ckpt", "is", "None", "else", "True", "\n", "config", ".", "ckptPth", "=", "args", ".", "ckpt", "\n", "\n", "# create directories", "\n", "config", ".", "cacheDir", "=", "os", ".", "path", ".", "join", "(", "\"cache\"", ",", "'{}_{}shot_K{}_seed{}'", ".", "format", "(", "\n", "config", ".", "expName", ",", "config", ".", "nSupport", ",", "config", ".", "nStep", ",", "config", ".", "seed", ")", ")", "\n", "config", ".", "logDir", "=", "os", ".", "path", ".", "join", "(", "config", ".", "cacheDir", ",", "'logs'", ")", "\n", "config", ".", "outDir", "=", "os", ".", "path", ".", "join", "(", "config", ".", "cacheDir", ",", "'outputs'", ")", "\n", "create_dirs", "(", "[", "config", ".", "cacheDir", ",", "config", ".", "logDir", ",", "config", ".", "outDir", "]", ")", "\n", "\n", "return", "config", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.AverageMeter.__init__": [[32, 34], ["outils.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.AverageMeter.reset": [[35, 40], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.AverageMeter.update": [[41, 46], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.getCi": [[48, 55], ["numpy.mean", "numpy.std", "numpy.sqrt", "len"], "function", ["None"], ["", "", "def", "getCi", "(", "accLog", ")", ":", "\n", "\n", "    ", "mean", "=", "np", ".", "mean", "(", "accLog", ")", "\n", "std", "=", "np", ".", "std", "(", "accLog", ")", "\n", "ci95", "=", "1.96", "*", "std", "/", "np", ".", "sqrt", "(", "len", "(", "accLog", ")", ")", "\n", "\n", "return", "mean", ",", "ci95", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.accuracy": [[57, 72], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "max", "output.topk", "pred.t.t", "pred.t.eq", "target.size", "target.view().expand_as", "correct[].view().float().sum", "res.append", "correct[].view().float().sum.mul_", "target.view", "correct[].view().float", "correct[].view"], "function", ["None"], ["", "def", "accuracy", "(", "output", ",", "target", ",", "topk", "=", "(", "1", ",", ")", ")", ":", "\n", "    ", "\"\"\"Computes the accuracy over the k top predictions for the specified values of k\"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "maxk", "=", "max", "(", "topk", ")", "\n", "batch_size", "=", "target", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "_", ",", "pred", "=", "output", ".", "topk", "(", "maxk", ",", "1", ",", "True", ",", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred", ")", ")", "\n", "\n", "res", "=", "[", "]", "\n", "for", "k", "in", "topk", ":", "\n", "            ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "res", ".", "append", "(", "correct_k", ".", "mul_", "(", "100.0", "/", "batch_size", ")", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.get_mean_and_std": [[74, 87], ["torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "print", "torch.zeros.div_", "torch.zeros.div_", "range", "len", "len", "inputs[].mean", "inputs[].std"], "function", ["None"], ["", "", "def", "get_mean_and_std", "(", "dataset", ")", ":", "\n", "    ", "'''Compute the mean and std value of dataset.'''", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "2", ")", "\n", "mean", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "std", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "print", "(", "'==> Computing mean and std..'", ")", "\n", "for", "inputs", ",", "targets", "in", "dataloader", ":", "\n", "        ", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "mean", "[", "i", "]", "+=", "inputs", "[", ":", ",", "i", ",", ":", ",", ":", "]", ".", "mean", "(", ")", "\n", "std", "[", "i", "]", "+=", "inputs", "[", ":", ",", "i", ",", ":", ",", ":", "]", ".", "std", "(", ")", "\n", "", "", "mean", ".", "div_", "(", "len", "(", "dataset", ")", ")", "\n", "std", ".", "div_", "(", "len", "(", "dataset", ")", ")", "\n", "return", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.init_params": [[89, 103], ["net.modules", "isinstance", "torch.kaiming_normal", "isinstance", "torch.constant", "torch.constant", "torch.constant", "isinstance", "torch.normal", "torch.constant"], "function", ["None"], ["", "def", "init_params", "(", "net", ")", ":", "\n", "    ", "'''Init layer parameters.'''", "\n", "for", "m", "in", "net", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "            ", "init", ".", "kaiming_normal", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "if", "m", ".", "bias", ":", "\n", "                ", "init", ".", "constant", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "            ", "init", ".", "constant", "(", "m", ".", "weight", ",", "1", ")", "\n", "init", ".", "constant", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "init", ".", "normal", "(", "m", ".", "weight", ",", "std", "=", "1e-3", ")", "\n", "if", "m", ".", "bias", ":", "\n", "                ", "init", ".", "constant", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.progress_bar": [[113, 155], ["int", "sys.stdout.write", "range", "sys.stdout.write", "range", "sys.stdout.write", "time.time", "L.append", "L.append", "sys.stdout.write", "range", "range", "sys.stdout.write", "sys.stdout.flush", "time.time", "int", "sys.stdout.write", "sys.stdout.write", "L.append", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "outils.format_time", "outils.format_time", "len", "int", "int"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.utils.outils.format_time", "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.format_time"], ["def", "progress_bar", "(", "current", ",", "total", ",", "msg", "=", "None", ")", ":", "\n", "    ", "global", "last_time", ",", "begin_time", "\n", "if", "current", "==", "0", ":", "\n", "        ", "begin_time", "=", "time", ".", "time", "(", ")", "# Reset for new bar.", "\n", "\n", "", "cur_len", "=", "int", "(", "TOTAL_BAR_LENGTH", "*", "current", "/", "total", ")", "\n", "rest_len", "=", "int", "(", "TOTAL_BAR_LENGTH", "-", "cur_len", ")", "-", "1", "\n", "\n", "sys", ".", "stdout", ".", "write", "(", "' ['", ")", "\n", "for", "i", "in", "range", "(", "cur_len", ")", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'='", ")", "\n", "", "sys", ".", "stdout", ".", "write", "(", "'>'", ")", "\n", "for", "i", "in", "range", "(", "rest_len", ")", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'.'", ")", "\n", "", "sys", ".", "stdout", ".", "write", "(", "']'", ")", "\n", "\n", "cur_time", "=", "time", ".", "time", "(", ")", "\n", "step_time", "=", "cur_time", "-", "last_time", "\n", "last_time", "=", "cur_time", "\n", "tot_time", "=", "cur_time", "-", "begin_time", "\n", "\n", "L", "=", "[", "]", "\n", "L", ".", "append", "(", "'  Step: %s'", "%", "format_time", "(", "step_time", ")", ")", "\n", "L", ".", "append", "(", "' | Tot: %s'", "%", "format_time", "(", "tot_time", ")", ")", "\n", "if", "msg", ":", "\n", "        ", "L", ".", "append", "(", "' | '", "+", "msg", ")", "\n", "\n", "", "msg", "=", "''", ".", "join", "(", "L", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "msg", ")", "\n", "for", "i", "in", "range", "(", "term_width", "-", "int", "(", "TOTAL_BAR_LENGTH", ")", "-", "len", "(", "msg", ")", "-", "3", ")", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "' '", ")", "\n", "\n", "# Go back to the center of the bar.", "\n", "", "for", "i", "in", "range", "(", "term_width", "-", "int", "(", "TOTAL_BAR_LENGTH", "/", "2", ")", "+", "2", ")", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'\\b'", ")", "\n", "", "sys", ".", "stdout", ".", "write", "(", "' %d/%d '", "%", "(", "current", "+", "1", ",", "total", ")", ")", "\n", "\n", "if", "current", "<", "total", "-", "1", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "\n", "", "else", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'\\n'", ")", "\n", "", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.outils.format_time": [[157, 188], ["int", "int", "int", "int", "int", "str", "str", "str", "str", "str"], "function", ["None"], ["", "def", "format_time", "(", "seconds", ")", ":", "\n", "    ", "days", "=", "int", "(", "seconds", "/", "3600", "/", "24", ")", "\n", "seconds", "=", "seconds", "-", "days", "*", "3600", "*", "24", "\n", "hours", "=", "int", "(", "seconds", "/", "3600", ")", "\n", "seconds", "=", "seconds", "-", "hours", "*", "3600", "\n", "minutes", "=", "int", "(", "seconds", "/", "60", ")", "\n", "seconds", "=", "seconds", "-", "minutes", "*", "60", "\n", "secondsf", "=", "int", "(", "seconds", ")", "\n", "seconds", "=", "seconds", "-", "secondsf", "\n", "millis", "=", "int", "(", "seconds", "*", "1000", ")", "\n", "\n", "f", "=", "''", "\n", "i", "=", "1", "\n", "if", "days", ">", "0", ":", "\n", "        ", "f", "+=", "str", "(", "days", ")", "+", "'D'", "\n", "i", "+=", "1", "\n", "", "if", "hours", ">", "0", "and", "i", "<=", "2", ":", "\n", "        ", "f", "+=", "str", "(", "hours", ")", "+", "'h'", "\n", "i", "+=", "1", "\n", "", "if", "minutes", ">", "0", "and", "i", "<=", "2", ":", "\n", "        ", "f", "+=", "str", "(", "minutes", ")", "+", "'m'", "\n", "i", "+=", "1", "\n", "", "if", "secondsf", ">", "0", "and", "i", "<=", "2", ":", "\n", "        ", "f", "+=", "str", "(", "secondsf", ")", "+", "'s'", "\n", "i", "+=", "1", "\n", "", "if", "millis", ">", "0", "and", "i", "<=", "2", ":", "\n", "        ", "f", "+=", "str", "(", "millis", ")", "+", "'ms'", "\n", "i", "+=", "1", "\n", "", "if", "f", "==", "''", ":", "\n", "        ", "f", "=", "'0ms'", "\n", "", "return", "f", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.set_random_seed": [[26, 31], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device": [[33, 44], ["torch.is_tensor", "input.to", "isinstance", "isinstance", "isinstance", "utils.to_device", "TypeError", "input.items", "utils.to_device"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device", "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.to_device"], ["model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.fast_hist": [[46, 51], ["numpy.bincount().reshape", "numpy.bincount", "label_true[].astype"], "function", ["None"], ["            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.convert_state_dict": [[53, 65], ["collections.OrderedDict", "state_dict.items"], "function", ["None"], ["# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.utils.utils.get_logger": [[67, 84], ["logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "[].replace", "ts.replace().replace.replace().replace", "os.path.join", "logging.FileHandler", "logging.FileHandler.setFormatter", "logging.StreamHandler", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.getLogger.addHandler", "ts.replace().replace.replace", "str().split", "str", "datetime.datetime.now"], "function", ["None"], ["", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n", "\n", "", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n", "    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.data.get_cifarfs.download_file": [[24, 37], ["requests.get", "open", "tqdm.tqdm", "requests.get.iter_content", "int", "tqdm.tqdm.update", "f.write", "len"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update"], ["def", "download_file", "(", "url", ",", "filename", ")", ":", "\n", "    ", "\"\"\"\n    Helper method handling downloading large files from `url` to `filename`. Returns a pointer to `filename`.\n    \"\"\"", "\n", "chunkSize", "=", "1024", "\n", "r", "=", "requests", ".", "get", "(", "url", ",", "stream", "=", "True", ")", "\n", "with", "open", "(", "filename", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pbar", "=", "tqdm", "(", "unit", "=", "\"B\"", ",", "total", "=", "int", "(", "r", ".", "headers", "[", "'Content-Length'", "]", ")", ")", "\n", "for", "chunk", "in", "r", ".", "iter_content", "(", "chunk_size", "=", "chunkSize", ")", ":", "\n", "            ", "if", "chunk", ":", "# filter out keep-alive new chunks", "\n", "                ", "pbar", ".", "update", "(", "len", "(", "chunk", ")", ")", "\n", "f", ".", "write", "(", "chunk", ")", "\n", "", "", "", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.subsample": [[20, 32], ["numpy.random.seed", "numpy.random.permutation", "range", "len"], "function", ["None"], ["def", "subsample", "(", "train_inputs", ",", "train_targets", ",", "train_targets_var", ",", "n_samp", ",", "seed", "=", "110", ")", ":", "\n", "    ", "\"\"\"Selects n_samp random rows from training data\n    train_inputs (tensor): full input data\n    train_targets (tensor): full response data\n    train_targets_var (tensor): full response variability data\n    n_samp (int): size of response\n    seed (int): random seed (numpy)\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "idx", "=", "np", ".", "random", ".", "permutation", "(", "range", "(", "len", "(", "train_inputs", ")", ")", ")", "[", ":", "n_samp", "]", "\n", "return", "train_inputs", "[", "idx", "]", ",", "train_targets", "[", "idx", "]", ",", "train_targets_var", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.unitize": [[34, 38], ["x.min", "x1.max"], "function", ["None"], ["", "def", "unitize", "(", "x", ")", ":", "\n", "    ", "\"\"\"Puts design space on a unit cube\"\"\"", "\n", "x1", "=", "x", "-", "x", ".", "min", "(", ")", "\n", "return", "x1", "/", "x1", ".", "max", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.generate_data": [[40, 101], ["pandas.read_hdf", "torch.from_numpy", "torch.from_numpy().bool", "torch.from_numpy", "torch.from_numpy().float", "data.unitize", "data.unitize", "torch.from_numpy().float", "torch.from_numpy().pow().float", "torch.linspace", "torch.meshgrid", "torch.stack", "data.subsample", "torch.sparse.LongTensor", "all_x[].min().item", "all_x[].max().item", "all_x[].min().item", "all_x[].max().item", "ng_coords.transpose", "torch.ones().long", "torch.Size", "torch.sparse.LongTensor.to_dense().reshape", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().pow", "X.reshape", "Y.reshape", "all_x[].min", "all_x[].max", "all_x[].min", "all_x[].max", "torch.ones", "torch.sparse.LongTensor.to_dense", "torch.from_numpy", "ng_coords.size"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.unitize", "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.unitize", "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.data.subsample"], ["", "def", "generate_data", "(", "\n", "nsamples", "=", "2000", ",", "train_year", "=", "2012", ",", "test_year", "=", "2016", ",", "grid_size", "=", "200", ",", "seed", "=", "110", ",", "hdf_loc", "=", "None", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    generates subsampled dataset from the hdf_location given years, grids, etc.\n    nsamples (int): dataset size\n    train_year (int): year to use from dataset\n    test_year (int): year to test on from dataset\n    grid_size (int): size of grid\n    seed (int): random seed for subsampling\n    hdf_loc (str): location of dataset hdf5 file\n    \"\"\"", "\n", "\n", "df", "=", "pd", ".", "read_hdf", "(", "hdf_loc", ",", "\"full\"", ")", "\n", "\n", "is_train_year", "=", "torch", ".", "from_numpy", "(", "(", "df", "[", "\"year\"", "]", "==", "train_year", ")", ".", "values", ")", "\n", "is_ng", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"is_ng\"", "]", ".", "values", ")", ".", "bool", "(", ")", "\n", "is_test", "=", "torch", ".", "from_numpy", "(", "(", "df", "[", "\"year\"", "]", "==", "test_year", ")", ".", "values", ")", "\n", "\n", "all_x", "=", "torch", ".", "from_numpy", "(", "df", "[", "[", "\"longitude\"", ",", "\"latitude\"", ",", "\"year\"", "]", "]", ".", "values", ")", ".", "float", "(", ")", "\n", "lon_lims", "=", "(", "all_x", "[", ":", ",", "0", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "0", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "lat_lims", "=", "(", "all_x", "[", ":", ",", "1", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "1", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "extent", "=", "lon_lims", "+", "lat_lims", "\n", "\n", "all_x", "[", ":", ",", "0", "]", "=", "unitize", "(", "all_x", "[", ":", ",", "0", "]", ")", "\n", "all_x", "[", ":", ",", "1", "]", "=", "unitize", "(", "all_x", "[", ":", ",", "1", "]", ")", "\n", "\n", "# don't include year", "\n", "all_x", "=", "all_x", "[", ":", ",", ":", "-", "1", "]", "\n", "\n", "all_y", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"mean\"", "]", ".", "values", ")", ".", "float", "(", ")", "\n", "all_y_var", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"std_dev\"", "]", ".", "values", ")", ".", "pow", "(", "2", ")", ".", "float", "(", ")", "\n", "\n", "train_inputs", ",", "train_targets", ",", "train_targets_var", "=", "(", "\n", "all_x", "[", "is_train_year", "]", ",", "\n", "all_y", "[", "is_train_year", "]", ",", "\n", "all_y_var", "[", "is_train_year", "]", ",", "\n", ")", "\n", "test_x", ",", "test_y", ",", "test_y_var", "=", "all_x", "[", "is_test", "]", ",", "all_y", "[", "is_test", "]", ",", "all_y_var", "[", "is_test", "]", "\n", "\n", "# Generate nxn grid of test points spaced on a grid of size 1/(n-1) in [0,1]x[0,1] for evaluation", "\n", "n", "=", "grid_size", "\n", "L", "=", "torch", ".", "linspace", "(", "0", ",", "1", ",", "n", ")", "\n", "X", ",", "Y", "=", "torch", ".", "meshgrid", "(", "L", ",", "L", ")", "\n", "grid_x", "=", "torch", ".", "stack", "(", "[", "X", ".", "reshape", "(", "-", "1", ")", ",", "Y", ".", "reshape", "(", "-", "1", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# let's start with a small set of samples", "\n", "train_inputs", ",", "train_targets", ",", "train_targets_var", "=", "subsample", "(", "\n", "train_inputs", ",", "train_targets", ",", "train_targets_var", ",", "nsamples", ",", "seed", "=", "seed", "\n", ")", "\n", "\n", "# mark nigeria - not great but works reasonably well", "\n", "ng_coords", "=", "(", "n", "*", "all_x", "[", ":", ",", ":", "2", "]", ")", ".", "round", "(", ")", ".", "long", "(", ")", "[", "is_ng", "]", "\n", "sparse_ng", "=", "torch", ".", "sparse", ".", "LongTensor", "(", "\n", "ng_coords", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "torch", ".", "ones", "(", "ng_coords", ".", "size", "(", "0", ")", ")", ".", "long", "(", ")", ",", "\n", "torch", ".", "Size", "(", "[", "n", ",", "n", "]", ")", ",", "\n", ")", "\n", "inside", "=", "sparse_ng", ".", "to_dense", "(", ")", ".", "reshape", "(", "-", "1", ")", ">", "0", "\n", "\n", "return", "train_inputs", ",", "train_targets", ",", "test_x", ",", "test_y", ",", "inside", ",", "extent", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.utils.train_fullds": [[18, 61], ["torch.nn.MSELoss", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.optim.SGD", "torch.optim.lr_scheduler.StepLR", "range", "net.parameters", "torch.optim.lr_scheduler.StepLR.step", "max", "max", "torch.optim.SGD.step", "print", "int", "int", "net.zero_grad", "criterion", "criterion.backward", "max", "net", "int"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["\n", "from", ".", "constants", "import", "serialization_constants", "as", "consts", "\n", "from", ".", "constants", "import", "repurposer_keys", "as", "keys", "\n", "\n", "\n", "def", "sklearn_model_to_dict", "(", "target_model", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.utils.ablr_compute_loss": [[63, 75], ["model", "gpytorch.distributions.MultivariateNormal", "torch.nn.functional.softplus", "gpytorch.lazy.RootLazyTensor", "torch.zeros_like", "features_lt.add_diag", "gpytorch.distributions.MultivariateNormal.log_prob"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus"], ["type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.finite_ntk.utils.ablr_compute_predictions": [[77, 93], ["torch.nn.functional.softplus", "model", "features_lt.add_jitter().inv_matmul", "gpytorch.lazy.RootLazyTensor", "model.t", "model.t", "features_lt.add_jitter", "model"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus"], ["    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.simple_reg.ntk_transfer_regression.ExactGPModel.__init__": [[33, 38], ["super().__init__", "gpytorch.means.ConstantMean", "finite_ntk.lazy.NTK", "finite_ntk.lazy.NTK", "finite_ntk.lazy.NTK", "finite_ntk.lazy.NTK"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "train_x", ",", "train_y", ",", "likelihood", ",", "model", ",", "use_linearstrategy", "=", "False", ")", ":", "\n", "        ", "super", "(", "ExactGPModel", ",", "self", ")", ".", "__init__", "(", "train_x", ",", "train_y", ",", "likelihood", ")", "\n", "self", ".", "mean_module", "=", "gpytorch", ".", "means", ".", "ConstantMean", "(", ")", "\n", "self", ".", "covar_module", "=", "finite_ntk", ".", "lazy", ".", "NTK", "(", "\n", "model", "=", "model", ",", "use_linearstrategy", "=", "use_linearstrategy", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.simple_reg.ntk_transfer_regression.ExactGPModel.forward": [[40, 44], ["ntk_transfer_regression.ExactGPModel.mean_module", "ntk_transfer_regression.ExactGPModel.covar_module", "gpytorch.distributions.MultivariateNormal"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean_x", "=", "self", ".", "mean_module", "(", "x", ")", "\n", "covar_x", "=", "self", ".", "covar_module", "(", "x", ")", "\n", "return", "gpytorch", ".", "distributions", ".", "MultivariateNormal", "(", "mean_x", ",", "covar_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.simple_reg.utils.gen_reg_task": [[18, 76], ["torch.linspace", "torch.random.manual_seed", "torch.rand", "torch.linspace.unsqueeze", "train_y.unsqueeze", "torch.sort", "torch.rand", "torch.rand", "torch.sin", "torch.rand", "torch.rand", "torch.sin", "torch.randn_like", "torch.rand", "torch.rand", "torch.randn_like"], "function", ["None"], ["\n", "from", ".", "constants", "import", "serialization_constants", "as", "consts", "\n", "from", ".", "constants", "import", "repurposer_keys", "as", "keys", "\n", "\n", "\n", "def", "sklearn_model_to_dict", "(", "target_model", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n", "\n", "", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.simple_reg.utils.parse_and_generate_tasks": [[78, 122], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "torch.random.manual_seed", "range", "task_dataset.append", "utils.gen_reg_task"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.simple_reg.utils.gen_reg_task"], ["        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "\n", "\n", "", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n", "", "elif", "context_function", "==", "keys", ".", "GPU", ":", "\n", "        ", "return", "mx", ".", "gpu", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.train_linearized_classifier.main": [[37, 130], ["parser.parser", "torch.manual_seed", "torch.cuda.manual_seed", "print", "getattr", "data.generate_data", "print", "getattr.base", "model_cfg.base.cuda", "print", "torch.load", "model_cfg.base.load_state_dict", "finite_ntk.lazy.utils.flatten", "pars.detach_().view.detach_().view", "torch.optim.Adam", "model_cfg.base.eval", "range", "model_cfg.base.parameters", "torch.clone", "loss_func", "loss_func", "utils.eval", "print", "utils.train_epoch", "print", "utils.predict", "numpy.savez", "pars.detach_().view.detach_", "torch.ones_like", "ValueError", "utils.eval", "print", "pars[].detach().cpu().numpy", "pars[].detach().cpu", "pars[].detach"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.parser.parser", "home.repos.pwc.inspect_result.amzn_xfer.cifar.data.generate_data", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.train_epoch", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict", "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.detach_", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval"], ["def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parser", "(", ")", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "torch", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "\n", "######", "\n", "# prepare model and dataset", "\n", "######", "\n", "\n", "print", "(", "\"Using model %s\"", "%", "args", ".", "model", ")", "\n", "model_cfg", "=", "getattr", "(", "models", ",", "args", ".", "model", ")", "\n", "\n", "loaders", ",", "num_classes", ",", "num_data", "=", "generate_data", "(", "args", ",", "model_cfg", ")", "\n", "train_loader", "=", "loaders", "[", "\"train\"", "]", "\n", "test_loader", "=", "loaders", "[", "\"test\"", "]", "\n", "\n", "print", "(", "\"Preparing model\"", ")", "\n", "model", "=", "model_cfg", ".", "base", "(", "*", "model_cfg", ".", "args", ",", "num_classes", "=", "num_classes", ",", "**", "model_cfg", ".", "kwargs", ")", "\n", "model", ".", "cuda", "(", ")", "\n", "\n", "## please note that this code will only work if the checkpoints are saved as cuda tensors", "\n", "print", "(", "\"Loading Model\"", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "resume", ")", "\n", "start_epoch", "=", "checkpoint", "[", "\"epoch\"", "]", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "\"net\"", "]", ")", "\n", "\n", "#######", "\n", "# prepare linearized model by cloning parameters", "\n", "current_pars", "=", "finite_ntk", ".", "lazy", ".", "utils", ".", "flatten", "(", "model", ".", "parameters", "(", ")", ")", "\n", "# but dont initialize to zero so we add a little bit of noise", "\n", "eps", "=", "1e-6", "\n", "pars", "=", "torch", ".", "clone", "(", "current_pars", ".", "data", ")", "+", "eps", "\n", "pars", "=", "pars", ".", "detach_", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "pars", ".", "requires_grad", "=", "True", "\n", "\n", "if", "args", ".", "inference", "==", "\"vi\"", ":", "\n", "        ", "sigma_pars", "=", "-", "5.0", "*", "torch", ".", "ones_like", "(", "pars", ")", "\n", "\n", "pars", "=", "[", "pars", ",", "sigma_pars", "]", "\n", "", "else", ":", "\n", "        ", "pars", "=", "[", "pars", "]", "\n", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "pars", ",", "lr", "=", "args", ".", "lr_init", ",", "amsgrad", "=", "True", ")", "\n", "\n", "# set model in eval mode to freeze batch norm and dropout", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "loss_args", "=", "[", "model", ",", "num_classes", ",", "args", ".", "bias", ",", "args", ".", "wd", ",", "current_pars", ",", "num_data", "]", "\n", "loss_instances", "=", "{", "\n", "\"map\"", ":", "losses", ".", "map_crossentropy", ",", "\n", "\"laplace\"", ":", "losses", ".", "laplace_crossentropy", ",", "\n", "\"vi\"", ":", "losses", ".", "vi_crossentropy", ",", "\n", "}", "\n", "\n", "try", ":", "\n", "        ", "loss_func", "=", "loss_instances", "[", "args", ".", "inference", "]", "\n", "criterion", "=", "loss_func", "(", "*", "loss_args", ")", "\n", "eval_criterion", "=", "loss_func", "(", "*", "loss_args", ",", "eval", "=", "True", ")", "\n", "", "except", ":", "\n", "        ", "raise", "ValueError", "(", "\"Inference method not found\"", ")", "\n", "\n", "", "if", "args", ".", "epochs", "==", "0", ":", "\n", "        ", "eval_dict", "=", "eval", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "pars", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "print", "(", "\"Eval loss: {} Eval acc: {}\"", ".", "format", "(", "eval_dict", "[", "\"loss\"", "]", ",", "eval_dict", "[", "\"accuracy\"", "]", ")", ")", "\n", "\n", "", "for", "epoch", "in", "range", "(", "args", ".", "epochs", ")", ":", "\n", "        ", "train_epoch", "(", "\n", "loader", "=", "train_loader", ",", "\n", "model", "=", "pars", ",", "\n", "criterion", "=", "criterion", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "if", "epoch", "%", "args", ".", "eval_freq", "==", "0", ":", "\n", "            ", "eval_dict", "=", "eval", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "pars", ",", "criterion", "=", "eval_criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "print", "(", "\"Eval loss: {} Eval acc: {}\"", ".", "format", "(", "eval_dict", "[", "\"loss\"", "]", ",", "eval_dict", "[", "\"accuracy\"", "]", ")", ")", "\n", "\n", "", "", "if", "args", ".", "save_path", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Saving predictions to \"", ",", "args", ".", "save_path", ")", "\n", "predictions_dict", "=", "predict", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "pars", ",", "criterion", "=", "eval_criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "np", ".", "savez", "(", "\n", "args", ".", "save_path", ",", "\n", "weights", "=", "pars", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "predictions", "=", "predictions_dict", "[", "\"predictions\"", "]", ",", "\n", "targets", "=", "predictions_dict", "[", "\"targets\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.train_last_layer.main": [[35, 105], ["parser.parser", "torch.manual_seed", "torch.cuda.manual_seed", "print", "getattr", "data.generate_data", "print", "getattr.base", "model_cfg.base.cuda", "model_cfg.base.eval", "list", "enumerate", "torch.optim.Adam", "range", "print", "torch.load", "model_cfg.base.load_state_dict", "model_cfg.base.named_parameters", "utils.eval", "print", "utils.train_epoch", "utils.eval", "print", "print", "utils.predict", "numpy.savez", "pars.append", "len"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.parser.parser", "home.repos.pwc.inspect_result.amzn_xfer.cifar.data.generate_data", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.named_parameters", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.train_epoch", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict"], ["def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parser", "(", ")", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "torch", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "\n", "######", "\n", "# prepare model and dataset", "\n", "######", "\n", "\n", "print", "(", "\"Using model %s\"", "%", "args", ".", "model", ")", "\n", "model_cfg", "=", "getattr", "(", "models", ",", "args", ".", "model", ")", "\n", "\n", "loaders", ",", "num_classes", ",", "num_data", "=", "generate_data", "(", "args", ",", "model_cfg", ")", "\n", "train_loader", "=", "loaders", "[", "\"train\"", "]", "\n", "test_loader", "=", "loaders", "[", "\"test\"", "]", "\n", "\n", "print", "(", "\"Preparing model\"", ")", "\n", "model", "=", "model_cfg", ".", "base", "(", "*", "model_cfg", ".", "args", ",", "num_classes", "=", "num_classes", ",", "**", "model_cfg", ".", "kwargs", ")", "\n", "model", ".", "cuda", "(", ")", "\n", "\n", "## please note that this code will only work if the checkpoints are saved as cuda tensors", "\n", "if", "args", ".", "resume", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Loading Model\"", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "resume", ")", "\n", "start_epoch", "=", "checkpoint", "[", "\"epoch\"", "]", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "\"state_dict\"", "]", ")", "\n", "\n", "", "model", ".", "eval", "(", ")", "\n", "pars", "=", "[", "]", "\n", "param_name_list", "=", "list", "(", "model", ".", "named_parameters", "(", ")", ")", "\n", "for", "i", ",", "(", "n", ",", "p", ")", "in", "enumerate", "(", "param_name_list", ")", ":", "\n", "        ", "if", "i", "<", "len", "(", "param_name_list", ")", "-", "2", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "else", ":", "\n", "            ", "pars", ".", "append", "(", "p", ")", "\n", "\n", "", "", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "pars", ",", "lr", "=", "args", ".", "lr_init", ",", "amsgrad", "=", "True", ")", "\n", "\n", "criterion", "=", "cross_entropy", "\n", "\n", "if", "args", ".", "epochs", "==", "0", ":", "\n", "        ", "eval_dict", "=", "eval", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "model", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "print", "(", "\"Eval loss: {} Eval acc: {}\"", ".", "format", "(", "eval_dict", "[", "\"loss\"", "]", ",", "eval_dict", "[", "\"accuracy\"", "]", ")", ")", "\n", "\n", "", "for", "epoch", "in", "range", "(", "args", ".", "epochs", ")", ":", "\n", "        ", "train_epoch", "(", "\n", "loader", "=", "train_loader", ",", "\n", "model", "=", "model", ",", "\n", "criterion", "=", "criterion", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "eval_dict", "=", "eval", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "model", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "print", "(", "\"Eval loss: {} Eval acc: {}\"", ".", "format", "(", "eval_dict", "[", "\"loss\"", "]", ",", "eval_dict", "[", "\"accuracy\"", "]", ")", ")", "\n", "\n", "", "if", "args", ".", "save_path", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Saving predictions to \"", ",", "args", ".", "save_path", ")", "\n", "predictions_dict", "=", "predict", "(", "\n", "loader", "=", "test_loader", ",", "model", "=", "model", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", "\n", ")", "\n", "np", ".", "savez", "(", "\n", "args", ".", "save_path", ",", "\n", "predictions", "=", "predictions_dict", "[", "\"predictions\"", "]", ",", "\n", "targets", "=", "predictions_dict", "[", "\"targets\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.parser.parser": [[18, 120], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"fast adaptation training\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--dataset\"", ",", "type", "=", "str", ",", "default", "=", "\"CIFAR10\"", ",", "help", "=", "\"dataset name (default: CIFAR10). Other options include CIFAR100 and STL10\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--data_path\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "required", "=", "True", ",", "\n", "metavar", "=", "\"path\"", ",", "\n", "help", "=", "\"path to datasets location (default: None)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--batch_size\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "metavar", "=", "\"N\"", ",", "\n", "help", "=", "\"input batch size (default: 128)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_workers\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "4", ",", "\n", "metavar", "=", "\"N\"", ",", "\n", "help", "=", "\"number of workers (default: 4)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--model\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"PreResNet56\"", ",", "\n", "required", "=", "True", ",", "\n", "metavar", "=", "\"MODEL\"", ",", "\n", "help", "=", "\"model name (default: PreResNet56)\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--resume\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "metavar", "=", "\"CKPT\"", ",", "\n", "help", "=", "\"checkpoint to resume training from (default: None)\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--epochs\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "10", ",", "\n", "metavar", "=", "\"N\"", ",", "\n", "help", "=", "\"number of epochs to train (default: 10)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--save_freq\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "25", ",", "\n", "metavar", "=", "\"N\"", ",", "\n", "help", "=", "\"save frequency (default: 25)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--eval_freq\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5", ",", "\n", "metavar", "=", "\"N\"", ",", "\n", "help", "=", "\"evaluation frequency (default: 5)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--lr_init\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.1", ",", "\n", "metavar", "=", "\"LR\"", ",", "\n", "help", "=", "\"initial learning rate (default: 0.1)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--wd\"", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "\"weight decay (default: 1e-4)\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--seed\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "metavar", "=", "\"S\"", ",", "help", "=", "\"random seed (default: 1)\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--save_path\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "required", "=", "False", ",", "\n", "help", "=", "\"path to npz results file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--bias\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to use bias terms in the loss (default: off)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--inference\"", ",", "\n", "type", "=", "str", ",", "\n", "choices", "=", "[", "\"laplace\"", ",", "\"vi\"", ",", "\"map\"", "]", ",", "\n", "required", "=", "True", ",", "\n", "default", "=", "\"map\"", ",", "\n", "help", "=", "\"inference choice to use\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.data.generate_data": [[26, 76], ["print", "getattr", "os.path.join", "len", "print", "args.dataset.lower", "getattr.", "numpy.array", "getattr.", "getattr.", "getattr.", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "max"], "function", ["None"], ["\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "idx", "=", "np", ".", "random", ".", "permutation", "(", "range", "(", "len", "(", "train_inputs", ")", ")", ")", "[", ":", "n_samp", "]", "\n", "return", "train_inputs", "[", "idx", "]", ",", "train_targets", "[", "idx", "]", ",", "train_targets_var", "[", "idx", "]", "\n", "\n", "\n", "", "def", "unitize", "(", "x", ")", ":", "\n", "    ", "\"\"\"Puts design space on a unit cube\"\"\"", "\n", "x1", "=", "x", "-", "x", ".", "min", "(", ")", "\n", "return", "x1", "/", "x1", ".", "max", "(", ")", "\n", "\n", "\n", "", "def", "generate_data", "(", "\n", "nsamples", "=", "2000", ",", "train_year", "=", "2012", ",", "test_year", "=", "2016", ",", "grid_size", "=", "200", ",", "seed", "=", "110", ",", "hdf_loc", "=", "None", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    generates subsampled dataset from the hdf_location given years, grids, etc.\n    nsamples (int): dataset size\n    train_year (int): year to use from dataset\n    test_year (int): year to test on from dataset\n    grid_size (int): size of grid\n    seed (int): random seed for subsampling\n    hdf_loc (str): location of dataset hdf5 file\n    \"\"\"", "\n", "\n", "df", "=", "pd", ".", "read_hdf", "(", "hdf_loc", ",", "\"full\"", ")", "\n", "\n", "is_train_year", "=", "torch", ".", "from_numpy", "(", "(", "df", "[", "\"year\"", "]", "==", "train_year", ")", ".", "values", ")", "\n", "is_ng", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"is_ng\"", "]", ".", "values", ")", ".", "bool", "(", ")", "\n", "is_test", "=", "torch", ".", "from_numpy", "(", "(", "df", "[", "\"year\"", "]", "==", "test_year", ")", ".", "values", ")", "\n", "\n", "all_x", "=", "torch", ".", "from_numpy", "(", "df", "[", "[", "\"longitude\"", ",", "\"latitude\"", ",", "\"year\"", "]", "]", ".", "values", ")", ".", "float", "(", ")", "\n", "lon_lims", "=", "(", "all_x", "[", ":", ",", "0", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "0", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "lat_lims", "=", "(", "all_x", "[", ":", ",", "1", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "1", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "extent", "=", "lon_lims", "+", "lat_lims", "\n", "\n", "all_x", "[", ":", ",", "0", "]", "=", "unitize", "(", "all_x", "[", ":", ",", "0", "]", ")", "\n", "all_x", "[", ":", ",", "1", "]", "=", "unitize", "(", "all_x", "[", ":", ",", "1", "]", ")", "\n", "\n", "# don't include year", "\n", "all_x", "=", "all_x", "[", ":", ",", ":", "-", "1", "]", "\n", "\n", "all_y", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"mean\"", "]", ".", "values", ")", ".", "float", "(", ")", "\n", "all_y_var", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"std_dev\"", "]", ".", "values", ")", ".", "pow", "(", "2", ")", ".", "float", "(", ")", "\n", "\n", "train_inputs", ",", "train_targets", ",", "train_targets_var", "=", "(", "\n", "all_x", "[", "is_train_year", "]", ",", "\n", "all_y", "[", "is_train_year", "]", ",", "\n", "all_y_var", "[", "is_train_year", "]", ",", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.adjust_learning_rate": [[22, 26], ["None"], "function", ["None"], ["\n", "def", "sklearn_model_to_dict", "(", "target_model", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.save_checkpoint": [[28, 33], ["state.update", "os.path.join", "torch.save"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save"], ["for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.train_epoch": [[35, 74], ["len", "enumerate", "int", "itertools.islice", "tqdm.tqdm", "criterion", "optimizer.zero_grad", "loss.backward", "optimizer.step", "input.cuda.size", "input.cuda.cuda", "target.cuda.cuda", "loss.data.item", "input.cuda.size", "print"], "function", ["None"], ["# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval": [[77, 100], ["len", "torch.no_grad", "enumerate", "tqdm.tqdm", "criterion", "output.data.argmax", "output.data.argmax.eq().sum().item", "input.cuda.cuda", "target.cuda.cuda", "loss.item", "input.cuda.size", "output.data.argmax.eq().sum", "output.data.argmax.eq", "target.cuda.data.view_as"], "function", ["None"], ["    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "\n", "\n", "", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.predict": [[103, 120], ["list", "list", "tqdm.tqdm", "torch.no_grad", "numpy.vstack", "numpy.concatenate", "input.cuda.cuda", "target.cuda.cuda", "criterion", "torch.nn.functional.softmax", "list.append", "list.append", "torch.nn.functional.softmax.cpu().numpy", "target.cuda.cpu().numpy", "torch.nn.functional.softmax.cpu", "target.cuda.cpu"], "function", ["None"], ["", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.losses.map_crossentropy": [[22, 82], ["finite_ntk.lazy.flatten", "Warning", "model.parameters", "finite_ntk.lazy.Jacobian()._t_matmul", "Jacobian()._t_matmul.reshape", "torch.nn.functional.cross_entropy", "current_pars[].norm", "finite_ntk.lazy.flatten.view", "finite_ntk.lazy.Jacobian", "model"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._t_matmul"], ["def", "map_crossentropy", "(", "\n", "model", ",", "\n", "num_classes", "=", "10", ",", "\n", "bias", "=", "True", ",", "\n", "wd", "=", "1e-4", ",", "\n", "current_pars", "=", "None", ",", "\n", "num_data", "=", "1", ",", "\n", "eval_mode", "=", "False", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    constructor for MAP estimation, returns a function\n    model (nn.module): torch model\n    num_classes (int): number of classes\n    bias (bool): whether to include the bias parameters list in the loss.\n    current_pars (list/iterable): parameter list, only used when bias=True\n    num_data (int): number of data points\n    eval_mode (bool): whether to include the regularizer in the model definition. overloaded\n    to more generally mean if the loss function is in train (regularizer included) or eval_mode mode\n    (regularizer not included for test LL computation)\n    \"\"\"", "\n", "if", "bias", "and", "current_pars", "is", "None", ":", "\n", "        ", "Warning", "(", "\"Nothing will be returned because current_pars is none\"", ")", "\n", "\n", "", "model_pars", "=", "flatten", "(", "model", ".", "parameters", "(", ")", ")", "\n", "\n", "def", "criterion", "(", "current_pars", ",", "input_data", ",", "target", ",", "return_predictions", "=", "True", ")", ":", "\n", "        ", "r\"\"\"\n        Loss function for MAP\n\n        current_pars (list/iterable): parameter list\n        input_data (tensor): input data for model\n        target (tensor): response\n        return_predictions (bool):if predictions should be returned as well as loss\n        \"\"\"", "\n", "\n", "rhs", "=", "current_pars", "[", "0", "]", "\n", "if", "bias", ":", "\n", "            ", "rhs", "=", "current_pars", "[", "0", "]", "-", "model_pars", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "# compute J^T \\theta", "\n", "", "predictions", "=", "Jacobian", "(", "model", "=", "model", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1", ")", ".", "_t_matmul", "(", "rhs", ")", "\n", "predictions_reshaped", "=", "predictions", ".", "reshape", "(", "target", ".", "shape", "[", "0", "]", ",", "num_classes", ")", "\n", "\n", "if", "bias", ":", "\n", "            ", "predictions_reshaped", "=", "predictions_reshaped", "+", "model", "(", "input_data", ")", "\n", "\n", "", "loss", "=", "(", "\n", "torch", ".", "nn", ".", "functional", ".", "cross_entropy", "(", "predictions_reshaped", ",", "target", ")", "\n", "*", "target", ".", "shape", "[", "0", "]", "\n", ")", "\n", "regularizer", "=", "current_pars", "[", "0", "]", ".", "norm", "(", ")", "*", "wd", "\n", "\n", "if", "eval_mode", ":", "\n", "            ", "output", "=", "loss", "\n", "", "else", ":", "\n", "            ", "output", "=", "num_data", "*", "loss", "+", "regularizer", "\n", "\n", "", "return", "output", ",", "predictions_reshaped", "\n", "\n", "", "return", "criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.losses.laplace_crossentropy": [[84, 171], ["finite_ntk.lazy.flatten", "model.parameters", "finite_ntk.lazy.Jacobian()._t_matmul", "Jacobian()._t_matmul.reshape", "gpytorch.utils.lanczos.lanczos_tridiag", "torch.symeig", "torch.randn", "torch.nn.functional.cross_entropy", "current_pars[].norm", "finite_ntk.lazy.flatten.view", "finite_ntk.lazy.Jacobian", "model", "torch.sort", "torch.diag", "finite_ntk.lazy.FVP_FD", "int", "eigs[].pow"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._t_matmul", "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag"], ["", "def", "laplace_crossentropy", "(", "\n", "model", ",", "\n", "num_classes", "=", "10", ",", "\n", "bias", "=", "True", ",", "\n", "wd", "=", "1e-4", ",", "\n", "current_pars", "=", "None", ",", "\n", "num_data", "=", "1", ",", "\n", "eval_mode", "=", "False", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    constructor for Laplace approximation, returns a loss function\n    model (nn.module): torch model\n    num_classes (int): number of classes\n    bias (bool): whether to include the bias parameters list in the loss.\n    current_pars (list/iterable): parameter list, only used when bias=True\n    num_data (int): number of data points\n    eval_mode: whether to include the regularizer in the model definition. overloaded\n    to more generally mean if the loss function is in train (regularizer included) or eval_mode mode\n    (regularizer not included and we perform sampling)\n    \"\"\"", "\n", "model_pars", "=", "flatten", "(", "model", ".", "parameters", "(", ")", ")", "\n", "\n", "def", "criterion", "(", "current_pars", ",", "input_data", ",", "target", ",", "return_predictions", "=", "True", ")", ":", "\n", "        ", "r\"\"\"\n        Loss function for Laplace\n\n        current_pars (list/iterable): parameter list\n        input_data (tensor): input data for model\n        target (tensor): response\n        return_predictions (bool):if predictions should be returned as well as loss\n        \"\"\"", "\n", "if", "eval_mode", ":", "\n", "# this means prediction time", "\n", "# so do a Fisher vector product + jitter, take the tmatrix invert the cholesky decomp and sample", "\n", "# F \\approx Q T Q' => F^{-1} \\approx Q T^{-1} Q'", "\n", "# F^{-1/2} \\approx Q T^{-1/2}", "\n", "            ", "fvp", "=", "(", "(", "num_data", "/", "input_data", ".", "shape", "[", "0", "]", ")", "*", "FVP_FD", "(", "model", ",", "input_data", ")", ")", ".", "add_jitter", "(", "1.0", ")", "\n", "qmat", ",", "tmat", "=", "lanczos_tridiag", "(", "\n", "fvp", ".", "matmul", ",", "\n", "30", ",", "\n", "dtype", "=", "current_pars", "[", "0", "]", ".", "dtype", ",", "\n", "device", "=", "current_pars", "[", "0", "]", ".", "device", ",", "\n", "init_vecs", "=", "None", ",", "\n", "matrix_shape", "=", "[", "current_pars", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "current_pars", "[", "0", "]", ".", "shape", "[", "0", "]", "]", ",", "\n", ")", "\n", "\n", "eigs", ",", "evecs", "=", "torch", ".", "symeig", "(", "tmat", ",", "eigenvectors", "=", "True", ")", "\n", "\n", "# only consider the top half of the eigenvalues bc they're reliable", "\n", "eigs_gt_zero", "=", "torch", ".", "sort", "(", "eigs", ")", "[", "1", "]", "[", "-", "int", "(", "tmat", ".", "shape", "[", "0", "]", "/", "2", ")", ":", "]", "\n", "\n", "# update the eigendecomposition", "\n", "# note that @ is a matmul", "\n", "updated_evecs", "=", "(", "qmat", "@", "evecs", ")", "[", ":", ",", "eigs_gt_zero", "]", "\n", "\n", "z", "=", "torch", ".", "randn", "(", "\n", "eigs_gt_zero", ".", "shape", "[", "0", "]", ",", "1", ",", "device", "=", "tmat", ".", "device", ",", "dtype", "=", "tmat", ".", "dtype", "\n", ")", "\n", "approx_lz", "=", "updated_evecs", "@", "torch", ".", "diag", "(", "1.0", "/", "eigs", "[", "eigs_gt_zero", "]", ".", "pow", "(", "0.5", ")", ")", "@", "z", "\n", "sample", "=", "current_pars", "[", "0", "]", "+", "approx_lz", "\n", "", "else", ":", "\n", "            ", "sample", "=", "current_pars", "[", "0", "]", "\n", "\n", "", "rhs", "=", "sample", "\n", "if", "bias", ":", "\n", "            ", "rhs", "=", "sample", "-", "model_pars", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "", "predictions", "=", "Jacobian", "(", "model", "=", "model", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1", ")", ".", "_t_matmul", "(", "rhs", ")", "\n", "predictions_reshaped", "=", "predictions", ".", "reshape", "(", "target", ".", "shape", "[", "0", "]", ",", "num_classes", ")", "\n", "\n", "if", "bias", ":", "\n", "            ", "predictions_reshaped", "=", "predictions_reshaped", "+", "model", "(", "input_data", ")", "\n", "\n", "", "loss", "=", "(", "\n", "torch", ".", "nn", ".", "functional", ".", "cross_entropy", "(", "predictions_reshaped", ",", "target", ")", "\n", "*", "target", ".", "shape", "[", "0", "]", "\n", ")", "\n", "regularizer", "=", "current_pars", "[", "0", "]", ".", "norm", "(", ")", "*", "wd", "\n", "\n", "if", "eval_mode", ":", "\n", "            ", "output", "=", "loss", "\n", "", "else", ":", "\n", "            ", "output", "=", "num_data", "*", "loss", "+", "regularizer", "\n", "\n", "", "return", "output", ",", "predictions_reshaped", "\n", "\n", "", "return", "criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.cifar.losses.vi_crossentropy": [[173, 244], ["finite_ntk.lazy.flatten", "model.parameters", "torch.distributions.Normal", "torch.distributions.Normal", "finite_ntk.lazy.Jacobian()._t_matmul", "Jacobian()._t_matmul.reshape", "torch.nn.functional.softplus", "torch.zeros_like", "torch.distributions.Normal.rsample", "torch.nn.functional.cross_entropy", "torch.distributions.kl_divergence().sum", "torch.ones_like", "finite_ntk.lazy.flatten.view_as", "finite_ntk.lazy.Jacobian", "model", "torch.distributions.kl_divergence"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._t_matmul", "home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus"], ["", "def", "vi_crossentropy", "(", "\n", "model", ",", "\n", "num_classes", "=", "10", ",", "\n", "bias", "=", "True", ",", "\n", "wd", "=", "1e-4", ",", "\n", "current_pars", "=", "None", ",", "\n", "num_data", "=", "1", ",", "\n", "eval_mode", "=", "False", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    constructor for SVI approximation, returns a loss function\n    model (nn.module): torch model\n    num_classes (int): number of classes\n    bias (bool): whether to include the bias parameters list in the loss.\n    current_pars (list/iterable): parameter list, only used when bias=True\n    num_data (int): number of data points\n    eval_mode: whether to include the regularizer in the model definition. overloaded\n    to more generally mean if the loss function is in train (regularizer included) or eval_mode mode\n    (regularizer not included and we perform sampling)\n    \"\"\"", "\n", "model_pars", "=", "flatten", "(", "model", ".", "parameters", "(", ")", ")", "\n", "\n", "def", "criterion", "(", "current_pars", ",", "input_data", ",", "target", ",", "return_predictions", "=", "True", ")", ":", "\n", "        ", "r\"\"\"\n        Loss function for SVI\n\n        current_pars (list/iterable): parameter list\n        input_data (tensor): input data for model\n        target (tensor): response\n        return_predictions (bool):if predictions should be returned as well as loss\n        \"\"\"", "\n", "current_dist", "=", "torch", ".", "distributions", ".", "Normal", "(", "\n", "current_pars", "[", "0", "]", ",", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "current_pars", "[", "1", "]", ")", "\n", ")", "\n", "prior_dist", "=", "torch", ".", "distributions", ".", "Normal", "(", "\n", "torch", ".", "zeros_like", "(", "current_pars", "[", "0", "]", ")", ",", "1", "/", "wd", "*", "torch", ".", "ones_like", "(", "current_pars", "[", "1", "]", ")", "\n", ")", "\n", "\n", "if", "not", "eval_mode", ":", "\n", "            ", "sample", "=", "current_dist", ".", "rsample", "(", ")", "\n", "", "else", ":", "\n", "            ", "sample", "=", "current_pars", "[", "0", "]", "\n", "\n", "", "rhs", "=", "sample", "\n", "if", "bias", ":", "\n", "            ", "rhs", "=", "sample", "-", "model_pars", ".", "view_as", "(", "sample", ")", "\n", "\n", "# compute J^T \\theta", "\n", "", "predictions", "=", "Jacobian", "(", "model", "=", "model", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1", ")", ".", "_t_matmul", "(", "rhs", ")", "\n", "\n", "predictions_reshaped", "=", "predictions", ".", "reshape", "(", "target", ".", "shape", "[", "0", "]", ",", "num_classes", ")", "\n", "if", "bias", ":", "\n", "            ", "predictions_reshaped", "=", "predictions_reshaped", "+", "model", "(", "input_data", ")", "\n", "\n", "", "loss", "=", "(", "\n", "torch", ".", "nn", ".", "functional", ".", "cross_entropy", "(", "predictions_reshaped", ",", "target", ")", "\n", "*", "target", ".", "shape", "[", "0", "]", "\n", ")", "\n", "\n", "regularizer", "=", "(", "\n", "torch", ".", "distributions", ".", "kl_divergence", "(", "current_dist", ",", "prior_dist", ")", ".", "sum", "(", ")", "/", "num_data", "\n", ")", "\n", "\n", "if", "eval_mode", ":", "\n", "            ", "output", "=", "loss", "\n", "", "else", ":", "\n", "            ", "output", "=", "loss", "+", "regularizer", "\n", "\n", "", "return", "output", ",", "predictions_reshaped", "\n", "\n", "", "return", "criterion", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.malaria.run_ntk.NTKGP.__init__": [[103, 109], ["super().__init__", "gpytorch.means.ConstantMean", "finite_ntk.lazy.NTK"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "train_x", ",", "train_y", ",", "likelihood", ",", "model", ")", ":", "\n", "        ", "super", "(", "NTKGP", ",", "self", ")", ".", "__init__", "(", "train_x", ",", "train_y", ",", "likelihood", ")", "\n", "\n", "self", ".", "mean_module", "=", "gpytorch", ".", "means", ".", "ConstantMean", "(", ")", "\n", "self", ".", "covar_module", "=", "finite_ntk", ".", "lazy", ".", "NTK", "(", "\n", "model", "=", "model", ",", "use_linearstrategy", "=", "args", ".", "fisher", ",", "used_dims", "=", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.malaria.run_ntk.NTKGP.forward": [[111, 115], ["run_ntk.NTKGP.mean_module", "run_ntk.NTKGP.covar_module", "gpytorch.distributions.MultivariateNormal"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean", "=", "self", ".", "mean_module", "(", "x", ")", "\n", "covar", "=", "self", ".", "covar_module", "(", "x", ")", "\n", "return", "gpytorch", ".", "distributions", ".", "MultivariateNormal", "(", "mean", ",", "covar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.malaria.run_ntk.compute_mse": [[30, 32], ["actual.size", "pred.view_as"], "function", ["None"], ["def", "compute_mse", "(", "pred", ",", "actual", ")", ":", "\n", "    ", "return", "(", "pred", ".", "view_as", "(", "actual", ")", "-", "actual", ")", ".", "norm", "(", ")", ".", "pow", "(", "2", ")", "/", "actual", ".", "size", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.malaria.run_ntk.gaussian_loglikelihood": [[34, 47], ["torch.distributions.Normal", "res.mean", "torch.distributions.Normal.log_prob", "torch.nn.functional.softplus", "target.view"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.utils.softplus"], ["", "def", "gaussian_loglikelihood", "(", "input", ",", "target", ",", "eps", "=", "1e-5", ")", ":", "\n", "    ", "r\"\"\"\n    heteroscedastic Gaussian likelihood where we parameterize the variance\n    with the 1e-5 + softplus(network)\n    input: tensor (batch + two-d, presumed to be output from model)\n    target: tensor\n    eps (1e-5): a nugget style term to ensure that the variance doesnt go to 0\n    \"\"\"", "\n", "dist", "=", "torch", ".", "distributions", ".", "Normal", "(", "\n", "input", "[", ":", ",", "0", "]", ",", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "input", "[", ":", ",", "1", "]", ")", "+", "eps", "\n", ")", "\n", "res", "=", "-", "dist", ".", "log_prob", "(", "target", ".", "view", "(", "-", "1", ")", ")", "\n", "return", "res", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.__init__": [[23, 45], ["gpytorch.lazy.LazyTensor.__init__", "fvp.FVP_FD.model.parameters", "p.numel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "data", ",", "epsilon", "=", "1e-4", ")", ":", "\n", "        ", "r\"\"\"\n        FVP_FD is a class representing a Fisher matrix of a model on a set of data, given\n        that the probability model for the data is\n        p(y | model(data)) = Categorical(model(data)). Rather than\n        forming the entire Fisher information matrix, we only access the Fisher via \n        Fisher vector products found using finite differences of the KL divergence.\n        Hence the FD tag at the end of the class name.\n        model: model class\n        data: data that the Fisher information is to be calulated on\n        epsilon: hyper-parameter\n        \"\"\"", "\n", "super", "(", "FVP_FD", ",", "self", ")", ".", "__init__", "(", "model", "=", "model", ",", "data", "=", "data", ",", "epsilon", "=", "epsilon", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "\n", "# compute number of paraemters", "\n", "self", ".", "num_params", "=", "0", "\n", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "num_params", "+=", "p", ".", "numel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.dtype": [[46, 49], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.device": [[50, 53], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD._transpose_nonbatch": [[54, 56], ["None"], "methods", ["None"], ["", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD._size": [[57, 62], ["torch.Size"], "methods", ["None"], ["", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "if", "val", "==", "0", "or", "val", "==", "1", ":", "\n", "            ", "return", "self", ".", "num_params", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "Size", "(", "[", "self", ".", "num_params", ",", "self", ".", "num_params", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.KL_logits": [[63, 85], ["torch.nn.Softmax", "torch.nn.Softmax.", "torch.log", "torch.log", "torch.exp().sum", "torch.exp().sum", "torch.exp", "torch.exp"], "methods", ["None"], ["", "", "def", "KL_logits", "(", "self", ",", "p_logits", ",", "q_logits", ")", ":", "\n", "# computes KL divergence between two tensors of logits", "\n", "# KL(p || q) = \\sum p log(p/q) \\propto -\\sum p log(q)", "\n", "# when we differentiate this, we really only need the cross-entropy", "\n", "# but include the other bits for enhanced numerical stability", "\n", "\n", "# this is the standard version (float/double independent)", "\n", "        ", "SM", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "p", "=", "SM", "(", "p_logits", ")", "\n", "\n", "# \\sum_{i=1}^N \\left(\\sum_{k=1}^K p(y = k|x_i, \\theta) (logit_p(y=k| x_i, \\theta) - logit_q(y=k| x_i, \\theta))\\right)", "\n", "part1", "=", "(", "p", "*", "(", "p_logits", "-", "q_logits", ")", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", "0", ")", "\n", "# normalization constants", "\n", "\n", "# \\log{ \\sum_{k=1}^K exp{logit_p(y=k| x_i, \\theta)} }", "\n", "# apparently implementations of LogSumExp are slower?", "\n", "r1", "=", "torch", ".", "log", "(", "torch", ".", "exp", "(", "q_logits", ")", ".", "sum", "(", "1", ")", ")", "\n", "r2", "=", "torch", ".", "log", "(", "torch", ".", "exp", "(", "p_logits", ")", ".", "sum", "(", "1", ")", ")", "\n", "# mean of difference of normalization constants", "\n", "part2", "=", "(", "r1", "-", "r2", ")", ".", "mean", "(", "0", ")", "\n", "kl", "=", "part1", "+", "part2", "\n", "return", "kl", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD._matmul": [[86, 145], ["torch.norm", "torch.norm().eq().all", "copy.deepcopy", "torch.zeros", "torch.no_grad", "fvp.FVP_FD.model().detach", "fvp.FVP_FD.model.state_dict", "fvp.FVP_FD.model.parameters", "grad_list.append", "fvp.FVP_FD.model.load_state_dict", "torch.stack", "res.t", "torch.norm().eq", "rhs.size", "param_val.numel", "param_val.data.add_", "torch.autograd.enable_grad", "fvp.FVP_FD.model", "fvp.FVP_FD.KL_logits", "kl.type().to.type().to.type().to", "torch.autograd.grad", "utils.flatten", "fvp.FVP_FD.model", "fvp.FVP_FD.double", "fvp.FVP_FD.double", "fvp.FVP_FD.model.parameters", "torch.norm", "v[].view_as", "kl.type().to.type().to.type"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.KL_logits", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "_matmul", "(", "self", ",", "rhs", ")", ":", "\n", "        ", "\"\"\"\n        _matmul is the meat of the fisher vector product.\n        rhs: tensor as input\n        We loop through all dimensions of rhs and compute finite differences \n        Fisher vector products with the cross entropy loss using the KL divergence.\n        \\nabla_\\theta' KL(p(y | \\theta) || p(y | \\theta')) |\\theta' = \\theta + \\epsilon v\n        is approximately F v * \\epsilon.\n        \"\"\"", "\n", "rhs_norm", "=", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "vec", "=", "(", "rhs", "/", "rhs_norm", ")", ".", "t", "(", ")", "# transpose and normalize", "\n", "\n", "# check if all norms are zeros and return a zero matrix if so", "\n", "if", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ")", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "num_params", ",", "rhs", ".", "size", "(", "1", ")", ",", "device", "=", "rhs", ".", "device", ",", "dtype", "=", "rhs", ".", "dtype", "\n", ")", "\n", "\n", "", "grad_list", "=", "[", "]", "\n", "\n", "# forwards pass with current parameters", "\n", "# return logit(y_k | \\theta, x_i)", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "output", "=", "self", ".", "model", "(", "self", ".", "data", ")", ".", "detach", "(", ")", "\n", "\n", "# copy model state dict", "\n", "", "model_state_dict", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "\n", "for", "v", "in", "vec", ":", "\n", "# update model with \\theta + \\epsilon v", "\n", "            ", "i", "=", "0", "\n", "for", "param_val", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "                ", "n", "=", "param_val", ".", "numel", "(", ")", "\n", "param_val", ".", "data", ".", "add_", "(", "self", ".", "epsilon", "*", "v", "[", "i", ":", "i", "+", "n", "]", ".", "view_as", "(", "param_val", ")", ")", "\n", "i", "+=", "n", "\n", "\n", "", "with", "torch", ".", "autograd", ".", "enable_grad", "(", ")", ":", "\n", "# forwards pass with updated parameters", "\n", "# logit(y_k | \\theta + \\epsilon v, x_i)", "\n", "                ", "output_prime", "=", "self", ".", "model", "(", "self", ".", "data", ")", "\n", "\n", "# compute kl divergence loss", "\n", "# KL(p(y|\\theta, x_i) || p(y|\\theta + \\epsilon v, x_i))", "\n", "kl", "=", "self", ".", "KL_logits", "(", "output", ".", "double", "(", ")", ",", "output_prime", ".", "double", "(", ")", ")", "\n", "kl", "=", "kl", ".", "type", "(", "self", ".", "data", ".", "dtype", ")", ".", "to", "(", "self", ".", "data", ".", "device", ")", "\n", "\n", "# compute gradient of kl divergence loss", "\n", "kl_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "kl", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "retain_graph", "=", "True", "\n", ")", "\n", "grad_i", "=", "flatten", "(", "kl_grad", ")", "\n", "", "grad_list", ".", "append", "(", "grad_i", ")", "\n", "\n", "# restore model dict now -> model(\\theta)", "\n", "self", ".", "model", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "\n", "# stack vector and turn divide by epsilon", "\n", "", "res", "=", "torch", ".", "stack", "(", "grad_list", ")", "/", "self", ".", "epsilon", "\n", "return", "res", ".", "t", "(", ")", "*", "rhs_norm", "# de-normalize at the end", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD._approx_diag": [[146, 158], ["fvp.FVP_FD.model.parameters", "utils.flatten", "utils.flatten.pow", "lst.append", "lst.append", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["", "def", "_approx_diag", "(", "self", ")", ":", "\n", "# we use the empirical fisher for the approximate diagonal", "\n", "# empirical fisher version of F", "\n", "# diag(F) \\approx (\\nabla_\\theta \\log{p(y_i | x_i, \\theta)})^2", "\n", "        ", "lst", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "                ", "lst", ".", "append", "(", "param", ".", "grad", ")", "\n", "", "else", ":", "\n", "                ", "lst", ".", "append", "(", "torch", ".", "zeros_like", "(", "param", ")", ")", "\n", "", "", "grad_vec", "=", "flatten", "(", "lst", ")", "\n", "return", "grad_vec", ".", "pow", "(", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp.FVP_FD.__getitem__": [[159, 165], ["index[].item", "torch.zeros", "fvp.FVP_FD._matmul().squeeze", "fvp.FVP_FD.size", "fvp.FVP_FD._matmul", "list", "fvp.FVP_FD.model.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# Will not do anything except get a single row correctly", "\n", "        ", "row_id", "=", "index", "[", "0", "]", ".", "item", "(", ")", "\n", "e_i", "=", "torch", ".", "zeros", "(", "self", ".", "size", "(", "0", ")", ",", "1", ",", "device", "=", "list", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "device", ")", "\n", "e_i", "[", "row_id", "]", "=", "1", "\n", "return", "self", ".", "_matmul", "(", "e_i", ")", ".", "squeeze", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG.__init__": [[21, 40], ["gpytorch.lazy.LazyTensor.__init__", "fvp_second_order.FVP_AG.model.parameters", "p.numel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "data", ",", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"\n        FVP_AG is a class representing a Fisher matrix of a model on a set of data, given\n        that the probability model for the data is\n        p(y | model(data)) = Categorical(model(data)). Rather than\n        forming the entire Fisher information matrix, we compute it with matrix vector products\n        using second order autograd (hence the AG name).\n        model: model class\n        data: data that the Fisher information is to be calulated on\n        epsilon: hyper-parameter\n        \"\"\"", "\n", "super", "(", "FVP_AG", ",", "self", ")", ".", "__init__", "(", "data", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data", "=", "data", "\n", "\n", "# compute number of paraemters", "\n", "self", ".", "num_params", "=", "0", "\n", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "num_params", "+=", "p", ".", "numel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG._size": [[41, 46], ["None"], "methods", ["None"], ["", "", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "if", "val", "==", "0", "or", "val", "==", "1", ":", "\n", "            ", "return", "self", ".", "num_params", "\n", "", "else", ":", "\n", "            ", "return", "(", "self", ".", "num_params", ",", "self", ".", "num_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG._transpose_nonbatch": [[47, 49], ["None"], "methods", ["None"], ["", "", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG.detached_entropy": [[52, 57], ["torch.nn.LogSoftmax", "torch.nn.Softmax", "probs.detach"], "methods", ["None"], ["", "def", "detached_entropy", "(", "self", ",", "logits", ",", "y", "=", "None", ")", ":", "\n", "# -1*\\frac{1}{m}\\sum_{i,k} [f_k(x_i)] \\log f_k(x_i), where [] is detach", "\n", "        ", "log_probs", "=", "torch", ".", "nn", ".", "LogSoftmax", "(", "dim", "=", "1", ")", "(", "logits", ")", "\n", "probs", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "logits", ")", "\n", "return", "-", "1", "*", "(", "probs", ".", "detach", "(", ")", "*", "log_probs", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG._matmul": [[58, 102], ["rhs.float.float.float", "rhs.float.float.t", "torch.norm().eq().all", "torch.stack().detach", "torch.stack().detach.t().type", "torch.zeros", "torch.autograd.no_grad", "torch.autograd.enable_grad", "fvp_second_order.FVP_AG.detached_entropy", "torch.autograd.grad", "torch.norm().eq", "rhs.float.float.size", "vec_list.append", "fvp_second_order.FVP_AG.model", "fvp_second_order.FVP_AG.model.parameters", "zip", "torch.autograd.grad", "res.append", "torch.stack", "torch.stack().detach.t", "utils.unflatten_like", "torch.sum", "deriv.float", "fvp_second_order.FVP_AG.model.parameters", "utils.flatten", "torch.norm", "fvp_second_order.FVP_AG.model.parameters", "vec_part.detach().double", "grad_part.double", "vec_part.detach"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_second_order.FVP_AG.detached_entropy", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.unflatten_like", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "_matmul", "(", "self", ",", "rhs", ")", ":", "\n", "        ", "orig_dtype", "=", "rhs", ".", "dtype", "\n", "rhs", "=", "rhs", ".", "float", "(", ")", "\n", "vec", "=", "rhs", ".", "t", "(", ")", "# transpose", "\n", "\n", "# check if all norms are zeros and return a zero matrix otherwise", "\n", "if", "torch", ".", "norm", "(", "vec", ",", "dim", "=", "0", ")", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "num_params", ",", "rhs", ".", "size", "(", "1", ")", ",", "device", "=", "rhs", ".", "device", ",", "dtype", "=", "rhs", ".", "dtype", "\n", ")", "\n", "\n", "# form list of all vectors", "\n", "", "with", "torch", ".", "autograd", ".", "no_grad", "(", ")", ":", "\n", "            ", "vec_list", "=", "[", "]", "\n", "for", "v", "in", "vec", ":", "\n", "                ", "vec_list", ".", "append", "(", "unflatten_like", "(", "v", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", "\n", "\n", "", "", "with", "torch", ".", "autograd", ".", "enable_grad", "(", ")", ":", "\n", "# compute batch loss with detached entropy", "\n", "            ", "batch_loss", "=", "self", ".", "detached_entropy", "(", "self", ".", "model", "(", "self", ".", "data", ")", ")", "\n", "\n", "# first gradient wrt parameters", "\n", "grad_bl_list", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "batch_loss", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "create_graph", "=", "True", ",", "only_inputs", "=", "True", "\n", ")", "\n", "\n", "res", "=", "[", "]", "\n", "for", "vec_sublist", "in", "vec_list", ":", "\n", "                ", "deriv", "=", "0", "\n", "for", "vec_part", ",", "grad_part", "in", "zip", "(", "vec_sublist", ",", "grad_bl_list", ")", ":", "\n", "                    ", "deriv", "+=", "torch", ".", "sum", "(", "vec_part", ".", "detach", "(", ")", ".", "double", "(", ")", "*", "grad_part", ".", "double", "(", ")", ")", "\n", "\n", "# fast implicit hvp product", "\n", "", "hvp_list", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "deriv", ".", "float", "(", ")", ",", "\n", "self", ".", "model", ".", "parameters", "(", ")", ",", "\n", "only_inputs", "=", "True", ",", "\n", "retain_graph", "=", "True", ",", "\n", ")", "\n", "\n", "res", ".", "append", "(", "flatten", "(", "hvp_list", ")", ")", "\n", "\n", "", "", "res_matrix", "=", "torch", ".", "stack", "(", "res", ")", ".", "detach", "(", ")", "\n", "return", "res_matrix", ".", "t", "(", ")", ".", "type", "(", "orig_dtype", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD.__init__": [[23, 57], ["gpytorch.lazy.NonLazyTensor", "gpytorch.lazy.LazyTensor.__init__", "fvp_reg.FVPR_FD.model.parameters", "torch.tensor", "p.numel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "data", ",", "epsilon", "=", "1e-4", ",", "dummy", "=", "None", ")", ":", "\n", "        ", "r\"\"\"\n        FVPR_FD is a class representing a Fisher matrix of a model on a set of data, given\n        that the probability model for the data is\n        p(y | model(data)) = Normal(model(data), \\sigma^2). Rather than\n        forming the entire Fisher information matrix, we only access the Fisher via \n        Fisher vector products found using finite differences of the KL divergence.\n        Note that for the homoscedastic regression problem, we don't actually need \\sigma^2.\n        model: model class\n        data: data that the Fisher information is to be calulated on\n        epsilon: hyper-parameter\n        dummy: for gpytorch semantics\n        This lazy tensor should not support batch dimensions.\n        \"\"\"", "\n", "\n", "# required for gpytorch semantics to work properly", "\n", "dummy", "=", "gpytorch", ".", "lazy", ".", "NonLazyTensor", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "]", "]", ",", "device", "=", "data", ".", "device", ",", "dtype", "=", "data", ".", "dtype", ")", "\n", ")", "\n", "\n", "super", "(", "FVPR_FD", ",", "self", ")", ".", "__init__", "(", "\n", "dummy", "=", "dummy", ",", "model", "=", "model", ",", "data", "=", "data", ",", "epsilon", "=", "epsilon", "\n", ")", "\n", "\n", "self", ".", "dummy", "=", "dummy", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "\n", "# compute number of paraemters", "\n", "self", ".", "num_params", "=", "0", "\n", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "num_params", "+=", "p", ".", "numel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD.dtype": [[58, 61], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD.device": [[62, 65], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD._transpose_nonbatch": [[66, 69], ["None"], "methods", ["None"], ["", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "# Fisher matrix is symmetric so return self", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD._size": [[70, 75], ["torch.Size"], "methods", ["None"], ["", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "if", "val", "==", "0", "or", "val", "==", "1", ":", "\n", "            ", "return", "self", ".", "num_params", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "Size", "(", "[", "self", ".", "num_params", ",", "self", ".", "num_params", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD._matmul": [[76, 139], ["torch.norm", "torch.norm().eq().all", "copy.deepcopy", "torch.zeros", "torch.no_grad", "fvp_reg.FVPR_FD.model().detach", "fvp_reg.FVPR_FD.model.state_dict", "fvp_reg.FVPR_FD.model.parameters", "grad_list.append", "fvp_reg.FVPR_FD.model.load_state_dict", "torch.stack", "res.t", "torch.isnan", "torch.norm().eq", "rhs.size", "param_val.numel", "param_val.data.add_", "torch.autograd.enable_grad", "fvp_reg.FVPR_FD.model", "kl.type().to.type().to.mean", "kl.type().to.type().to.type().to", "torch.autograd.grad", "utils.flatten", "fvp_reg.FVPR_FD.model", "fvp_reg.FVPR_FD.model.parameters", "torch.norm", "v[].view_as", "kl.type().to.type().to.type", "fvp_reg.FVPR_FD.double", "fvp_reg.FVPR_FD.double"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "", "def", "_matmul", "(", "self", ",", "rhs", ")", ":", "\n", "        ", "\"\"\"\n        _matmul is the meat of the fisher vector product.\n        rhs: tensor as input\n        We loop through all dimensions of rhs and compute finite differences \n        Fisher vector products with the regression loss using the KL divergence.\n        \\nabla_\\theta' KL(p(y | \\theta) || p(y | \\theta')) |\\theta' = \\theta + \\epsilon v\n        is approximately F v * \\epsilon.\n        \"\"\"", "\n", "rhs_norm", "=", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "vec", "=", "(", "rhs", "/", "rhs_norm", ")", ".", "t", "(", ")", "# transpose and normalize", "\n", "vec", "[", "torch", ".", "isnan", "(", "vec", ")", "]", "=", "0.0", "\n", "\n", "# check if all norms are zeros and return a zero matrix if so", "\n", "if", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ")", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "num_params", ",", "rhs", ".", "size", "(", "1", ")", ",", "device", "=", "rhs", ".", "device", ",", "dtype", "=", "rhs", ".", "dtype", "\n", ")", "\n", "\n", "", "grad_list", "=", "[", "]", "\n", "\n", "# forwards pass with current parameters", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "output", "=", "self", ".", "model", "(", "self", ".", "data", ")", ".", "detach", "(", ")", "\n", "\n", "# copy model state dict", "\n", "", "model_state_dict", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "\n", "for", "v", "in", "vec", ":", "\n", "# update model with \\theta + \\epsilon v", "\n", "            ", "i", "=", "0", "\n", "for", "param_val", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "                ", "n", "=", "param_val", ".", "numel", "(", ")", "\n", "param_val", ".", "data", ".", "add_", "(", "self", ".", "epsilon", "*", "v", "[", "i", ":", "i", "+", "n", "]", ".", "view_as", "(", "param_val", ")", ")", "\n", "i", "+=", "n", "\n", "\n", "", "with", "torch", ".", "autograd", ".", "enable_grad", "(", ")", ":", "\n", "# y_i: response, x_i: data in below", "\n", "# forwards pass with updated parameters", "\n", "# N(y_i | f(x_i; \\theta + \\epsilon v), \\sigma^2)", "\n", "                ", "output_prime", "=", "self", ".", "model", "(", "self", ".", "data", ")", "\n", "\n", "# compute kl divergence loss", "\n", "# KL(p(y_i|\\theta, x_i) || p(y_i|\\theta + \\epsilon v, x_i))", "\n", "# assumes fixed sigma", "\n", "kl", "=", "0.5", "*", "(", "output", ".", "double", "(", ")", "-", "output_prime", ".", "double", "(", ")", ")", "**", "2", "\n", "kl", "=", "kl", ".", "mean", "(", "0", ")", "\n", "\n", "kl", "=", "kl", ".", "type", "(", "self", ".", "data", ".", "dtype", ")", ".", "to", "(", "self", ".", "data", ".", "device", ")", "\n", "\n", "# compute gradient of kl divergence loss", "\n", "kl_grad", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "kl", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "retain_graph", "=", "True", "\n", ")", "\n", "grad_i", "=", "flatten", "(", "kl_grad", ")", "\n", "", "grad_list", ".", "append", "(", "grad_i", ")", "\n", "\n", "# restore model dict now -> model(\\theta)", "\n", "self", ".", "model", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "\n", "# stack vector and turn divide by epsilon", "\n", "", "res", "=", "torch", ".", "stack", "(", "grad_list", ")", "/", "self", ".", "epsilon", "\n", "return", "res", ".", "t", "(", ")", "*", "rhs_norm", "# de-normalize at the end", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD._approx_diag": [[140, 148], ["fvp_reg.FVPR_FD._matmul", "grad_vec.squeeze.squeeze.squeeze", "print", "grad_vec.squeeze.squeeze.pow", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul"], ["", "def", "_approx_diag", "(", "self", ")", ":", "\n", "# approximate diagonal - useful for preconditioning", "\n", "        ", "grad_vec", "=", "self", ".", "_matmul", "(", "\n", "torch", ".", "ones", "(", "self", ".", "shape", "[", "0", "]", ",", "1", ",", "device", "=", "self", ".", "device", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", ")", "\n", "grad_vec", "=", "grad_vec", ".", "squeeze", "(", "-", "1", ")", "\n", "print", "(", "grad_vec", ".", "shape", ")", "\n", "return", "grad_vec", ".", "pow", "(", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.fvp_reg.FVPR_FD.__getitem__": [[149, 156], ["print", "index[].item", "torch.zeros", "fvp_reg.FVPR_FD._matmul().squeeze", "fvp_reg.FVPR_FD.size", "fvp_reg.FVPR_FD._matmul", "list", "fvp_reg.FVPR_FD.model.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "print", "(", "\"index in __getitem__ is: \"", ",", "index", ")", "\n", "# Will not do anything except get a single row correctly", "\n", "row_id", "=", "index", "[", "0", "]", ".", "item", "(", ")", "\n", "e_i", "=", "torch", ".", "zeros", "(", "self", ".", "size", "(", "0", ")", ",", "1", ",", "device", "=", "list", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "device", ")", "\n", "e_i", "[", "row_id", "]", "=", "1", "\n", "return", "self", ".", "_matmul", "(", "e_i", ")", ".", "squeeze", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.__init__": [[22, 90], ["gpytorch.lazy.NonLazyTensor", "gpytorch.lazy.LazyTensor.__init__", "torch.tensor", "criterion().reshape", "criterion"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ",", "\n", "data", ",", "\n", "target", "=", "None", ",", "\n", "num_outputs", "=", "1", ",", "\n", "cross_data", "=", "None", ",", "\n", "cross_target", "=", "None", ",", "\n", "dummy", "=", "None", ",", "\n", "used_dims", "=", "None", ",", "\n", "keep_outputs", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        NTK is a kernel with the Jacobian matrix defined by a neural network (model)\n        currently is only tested for single outputs.\n        \n        model (torch.nn): model with output parameters to compute Jacobians from\n        data (torch.tensor): dataset that the Jacobian of the model is evaluated on\n        target (torch.tensor): label for the data (unused - check if deprectated)\n        num_ouputs (int): number of outputs of the model (default: 1)\n        cross_data (torch.tensor): dataset if we are computing a cross product J_x'J_y\n            (default: None which implies J_x'J_x)\n        cross_target (torch.tensor): label for the cross data (unused - check if deprecated)\n        dummy (None): used solely for gpytorch semantics & initialization\n        used_dims (int): if model has multiple outputs; which dimension to use for the Jacobian\n            (default: None which implies all dimensions)\n        keep_outputs (int): whether to use batch mode or to squeeze the features (default: None)\n        \"\"\"", "\n", "# required for gpytorch semantics to work properly", "\n", "dummy", "=", "NonLazyTensor", "(", "torch", ".", "tensor", "(", "[", "[", "]", "]", ",", "device", "=", "data", ".", "device", ",", "dtype", "=", "data", ".", "dtype", ")", ")", "\n", "\n", "super", "(", "NeuralTangent", ",", "self", ")", ".", "__init__", "(", "\n", "dummy", "=", "dummy", ",", "\n", "model", "=", "model", ",", "\n", "data", "=", "data", ",", "\n", "target", "=", "target", ",", "\n", "cross_data", "=", "cross_data", ",", "\n", "cross_target", "=", "cross_target", ",", "\n", "num_outputs", "=", "num_outputs", ",", "\n", "used_dims", "=", "used_dims", ",", "\n", "**", "kwargs", "\n", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "target", "=", "target", "\n", "self", ".", "num_outputs", "=", "num_outputs", "\n", "self", ".", "used_dims", "=", "used_dims", "\n", "self", ".", "keep_outputs", "=", "keep_outputs", "\n", "\n", "# construct the criterion", "\n", "if", "used_dims", "is", "not", "None", ":", "\n", "            ", "criterion", "=", "lambda", "x", ",", "y", ":", "x", "[", ":", ",", "used_dims", "]", "\n", "", "else", ":", "\n", "            ", "criterion", "=", "lambda", "x", ",", "y", ":", "x", "\n", "\n", "", "if", "num_outputs", "==", "1", ":", "\n", "            ", "self", ".", "criterion", "=", "lambda", "x", ",", "y", ":", "criterion", "(", "x", ",", "y", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "criterion", "=", "criterion", "\n", "\n", "", "if", "cross_data", "is", "not", "None", ":", "\n", "            ", "self", ".", "cross_data", "=", "cross_data", "\n", "self", ".", "cross_target", "=", "cross_target", "\n", "self", ".", "use_cross", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "use_cross", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.dtype": [[91, 94], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.device": [[95, 98], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.detach_": [[99, 102], ["None"], "methods", ["None"], ["", "def", "detach_", "(", "self", ")", ":", "\n", "# given that ntk operates solely on derivatives, do nothing", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._transpose_nonbatch": [[103, 117], ["ntk_lazytensor.NeuralTangent"], "methods", ["None"], ["", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "use_cross", ":", "\n", "            ", "return", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "data", "=", "self", ".", "cross_data", ",", "\n", "target", "=", "self", ".", "cross_target", ",", "\n", "num_outputs", "=", "self", ".", "num_outputs", ",", "\n", "cross_data", "=", "self", ".", "data", ",", "\n", "cross_target", "=", "self", ".", "target", ",", "\n", "used_dims", "=", "self", ".", "used_dims", ",", "\n", ")", "\n", "", "else", ":", "\n", "# symmetric matrix", "\n", "            ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._size": [[118, 135], ["size_list.append", "size_list.append", "ntk_lazytensor.NeuralTangent.data.size", "size_list.append", "size_list.append", "torch.Size", "ntk_lazytensor.NeuralTangent.cross_data.size", "ntk_lazytensor.NeuralTangent.data.size"], "methods", ["None"], ["", "", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "size_list", "=", "[", "]", "\n", "\n", "if", "self", ".", "num_outputs", ">", "1", "or", "self", ".", "keep_outputs", ":", "\n", "            ", "size_list", ".", "append", "(", "self", ".", "num_outputs", ")", "\n", "\n", "", "size_list", ".", "append", "(", "self", ".", "data", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "self", ".", "use_cross", ":", "\n", "            ", "size_list", ".", "append", "(", "self", ".", "cross_data", ".", "size", "(", "0", ")", ")", "\n", "", "else", ":", "\n", "            ", "size_list", ".", "append", "(", "self", ".", "data", ".", "size", "(", "0", ")", ")", "\n", "\n", "", "if", "val", "is", "not", "None", ":", "\n", "            ", "return", "size_list", "[", "val", "]", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "Size", "(", "size_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._matmul": [[136, 208], ["torch.norm", "torch.norm.eq().all", "torch.stack", "ntk_lazytensor.NeuralTangent.model.zero_grad", "torch.stack.transpose", "output.squeeze.squeeze.squeeze", "torch.norm.eq", "torch.zeros", "torch.zeros", "len", "v.unsqueeze.unsqueeze.unsqueeze", "torch.enable_grad", "range", "prod_list.append", "torch.isnan", "ntk_lazytensor.NeuralTangent.data.size", "lhs.size", "ntk_lazytensor.NeuralTangent.data.size", "lhs.size", "ntk_lazytensor.NeuralTangent.criterion", "ntk_lazytensor.NeuralTangent.criterion", "utils.Jacvec", "curr_prod.append", "torch.stack", "ntk_lazytensor.NeuralTangent.model", "ntk_lazytensor.NeuralTangent.model", "ntk_lazytensor.NeuralTangent.model.parameters", "ntk_lazytensor.NeuralTangent.criterion", "utils.Rop", "ntk_lazytensor.NeuralTangent.model", "ntk_lazytensor.NeuralTangent.model.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Jacvec", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "", "def", "_matmul", "(", "self", ",", "lhs", ")", ":", "\n", "        ", "r\"\"\"\n        lhs: vector of shape num_output x n_2 x r\n        \"\"\"", "\n", "\n", "lhs_norm", "=", "torch", ".", "norm", "(", "lhs", ",", "dim", "=", "-", "2", ",", "keepdim", "=", "True", ")", "\n", "\n", "# check if all norms are zeros and return a zero matrix if so", "\n", "if", "lhs_norm", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "if", "self", ".", "num_outputs", "==", "1", ":", "\n", "                ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "lhs", ".", "size", "(", "-", "1", ")", ",", "device", "=", "lhs", ".", "device", ",", "dtype", "=", "lhs", ".", "dtype", "\n", ")", "\n", "", "else", ":", "\n", "                ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "num_outputs", ",", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "\n", "lhs", ".", "size", "(", "-", "1", ")", ",", "\n", "device", "=", "lhs", ".", "device", ",", "\n", "dtype", "=", "lhs", ".", "dtype", ",", "\n", ")", "\n", "\n", "# vec is now r x n_2 x num_output", "\n", "", "", "vec", "=", "(", "lhs", "/", "lhs_norm", ")", ".", "transpose", "(", "0", ",", "-", "1", ")", "# transpose and normalize", "\n", "\n", "# self.model.train()", "\n", "\n", "prod_list", "=", "[", "]", "\n", "for", "v", "in", "vec", ":", "\n", "# ensure that v has two dimensions so we can slice it below", "\n", "            ", "if", "len", "(", "v", ".", "shape", ")", "==", "1", ":", "\n", "                ", "v", "=", "v", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# zero gradients incase weirdness is occurring", "\n", "", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "\n", "with", "torch", ".", "enable_grad", "(", ")", ":", "\n", "                ", "if", "self", ".", "use_cross", ":", "\n", "                    ", "loss", "=", "self", ".", "criterion", "(", "self", ".", "model", "(", "self", ".", "cross_data", ")", ",", "self", ".", "cross_target", ")", "\n", "", "else", ":", "\n", "                    ", "loss", "=", "self", ".", "criterion", "(", "self", ".", "model", "(", "self", ".", "data", ")", ",", "self", ".", "target", ")", "\n", "\n", "", "curr_prod", "=", "[", "]", "\n", "for", "dim", "in", "range", "(", "self", ".", "num_outputs", ")", ":", "\n", "# compute jacobian vector product", "\n", "                    ", "z_current", "=", "Jacvec", "(", "\n", "loss", "[", "...", ",", "dim", "]", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "v", "[", "...", ",", "dim", "]", "\n", ")", "\n", "\n", "# compute second loss", "\n", "if", "self", ".", "use_cross", ":", "\n", "                        ", "cross_loss", "=", "self", ".", "criterion", "(", "self", ".", "model", "(", "self", ".", "data", ")", ",", "self", ".", "target", ")", "\n", "", "else", ":", "\n", "                        ", "cross_loss", "=", "loss", "\n", "\n", "# now perform r op", "\n", "", "prod_current", "=", "Rop", "(", "\n", "cross_loss", "[", "...", ",", "dim", "]", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "z_current", "\n", ")", "[", "0", "]", "\n", "curr_prod", ".", "append", "(", "prod_current", ")", "\n", "\n", "", "prod_list", ".", "append", "(", "torch", ".", "stack", "(", "curr_prod", ")", ")", "\n", "\n", "", "", "res", "=", "torch", ".", "stack", "(", "prod_list", ",", "dim", "=", "-", "2", ")", "\n", "output", "=", "res", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "*", "lhs_norm", "\n", "\n", "if", "not", "self", ".", "keep_outputs", "or", "self", ".", "num_outputs", "==", "1", ":", "\n", "            ", "output", "=", "output", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "output", "[", "torch", ".", "isnan", "(", "output", ")", "]", "=", "0.0", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._get_indices": [[209, 211], ["ntk_lazytensor.NeuralTangent._getitem"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._getitem"], ["", "def", "_get_indices", "(", "self", ",", "row_index", ",", "col_index", ",", "*", "batch_indices", ")", ":", "\n", "        ", "return", "self", ".", "_getitem", "(", "row_index", ",", "col_index", ",", "*", "batch_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._getitem": [[212, 247], ["ntk_lazytensor.NeuralTangent", "len", "ntk_lazytensor.NeuralTangent.target[].squeeze", "ntk_lazytensor.NeuralTangent.cross_target[].squeeze", "type", "len", "len", "list", "range", "used_dims.indices"], "methods", ["None"], ["", "def", "_getitem", "(", "self", ",", "row_index", ",", "col_index", ",", "*", "batch_indices", ")", ":", "\n", "# if batch indices is none, do nothing", "\n", "        ", "if", "len", "(", "batch_indices", ")", "is", "0", ":", "\n", "            ", "num_outputs", "=", "self", ".", "num_outputs", "\n", "used_dims", "=", "self", ".", "used_dims", "\n", "# if batch indices is a None slice, do nothing", "\n", "", "else", ":", "\n", "            ", "used_dims", "=", "batch_indices", "[", "0", "]", "\n", "# compute length of range derived from slicing...", "\n", "if", "type", "(", "batch_indices", "[", "0", "]", ")", "is", "slice", ":", "\n", "                ", "num_outputs", "=", "len", "(", "list", "(", "range", "(", "*", "used_dims", ".", "indices", "(", "self", ".", "num_outputs", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "num_outputs", "=", "len", "(", "batch_indices", ")", "\n", "\n", "", "", "row_data", "=", "self", ".", "data", "[", "row_index", ",", "...", "]", "\n", "col_data", "=", "self", ".", "data", "[", "col_index", ",", "...", "]", "\n", "\n", "if", "self", ".", "target", "is", "not", "None", ":", "\n", "            ", "row_target", "=", "self", ".", "target", "[", "row_index", "]", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "row_target", "=", "None", "\n", "\n", "", "if", "self", ".", "use_cross", "and", "self", ".", "cross_target", "is", "not", "None", ":", "\n", "            ", "col_target", "=", "self", ".", "cross_target", "[", "col_index", "]", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "col_target", "=", "None", "\n", "\n", "", "return", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "data", "=", "row_data", ",", "\n", "target", "=", "row_target", ",", "\n", "num_outputs", "=", "num_outputs", ",", "\n", "cross_data", "=", "col_data", ",", "\n", "cross_target", "=", "col_target", ",", "\n", "used_dims", "=", "used_dims", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.diag": [[249, 289], ["enumerate", "torch.zeros", "torch.zeros", "ntk_lazytensor.NeuralTangent.model.zero_grad", "ntk_lazytensor.NeuralTangent.model().squeeze", "ntk_lazytensor.NeuralTangent.data.size", "ntk_lazytensor.NeuralTangent.data.size", "range", "utils.flatten", "ntk_lazytensor.NeuralTangent.model", "utils.flatten", "utils.flatten.norm", "torch.autograd.grad", "utils.flatten.norm", "curr_data.unsqueeze", "torch.autograd.grad", "ntk_lazytensor.NeuralTangent.model.parameters", "ntk_lazytensor.NeuralTangent.model.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "diag", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        computes an exact diagonal\n        This method scales linearly in the data x output calls\n        \"\"\"", "\n", "if", "self", ".", "num_outputs", ">", "1", ":", "\n", "            ", "diag_vec", "=", "torch", ".", "zeros", "(", "\n", "self", ".", "num_outputs", ",", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "\n", "device", "=", "self", ".", "data", ".", "device", ",", "\n", "dtype", "=", "self", ".", "data", ".", "dtype", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "diag_vec", "=", "torch", ".", "zeros", "(", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "device", "=", "self", ".", "data", ".", "device", ",", "dtype", "=", "self", ".", "data", ".", "dtype", "\n", ")", "\n", "\n", "", "for", "i", ",", "curr_data", "in", "enumerate", "(", "self", ".", "data", ")", ":", "\n", "            ", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "model", "(", "curr_data", ".", "unsqueeze", "(", "0", ")", ")", ".", "squeeze", "(", ")", "\n", "\n", "if", "self", ".", "num_outputs", ">", "1", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "num_outputs", ")", ":", "\n", "                    ", "gradval", "=", "flatten", "(", "\n", "torch", ".", "autograd", ".", "grad", "(", "\n", "output", "[", "j", "]", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "retain_graph", "=", "True", "\n", ")", "\n", ")", "\n", "\n", "", "diag_vec", "[", "j", ",", "i", "]", "=", "gradval", ".", "norm", "(", ")", "**", "2", "\n", "", "else", ":", "\n", "                ", "gradval", "=", "flatten", "(", "\n", "torch", ".", "autograd", ".", "grad", "(", "\n", "output", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "retain_graph", "=", "True", "\n", ")", "\n", ")", "\n", "\n", "diag_vec", "[", "i", "]", "=", "gradval", ".", "norm", "(", ")", "**", "2", "\n", "\n", "", "", "return", "diag_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._approx_diag": [[290, 319], ["ntk_lazytensor.NeuralTangent.model.parameters", "jac_sum_by_point.t.t.pow", "ntk_lazytensor.NeuralTangent.size", "ntk_lazytensor.NeuralTangent.size", "NotImplementedError", "torch.set_grad_enabled", "ntk_lazytensor.NeuralTangent.criterion", "ones_list.append", "utils.Rop", "jac_sum_by_point.t.t.squeeze", "ntk_lazytensor.NeuralTangent.model", "torch.ones_like", "ntk_lazytensor.NeuralTangent.model.parameters", "len", "jac_sum_by_point.t.t.t"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "_approx_diag", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes an approximate diagonal, useful for preconditioners\n        \"\"\"", "\n", "if", "self", ".", "size", "(", "-", "2", ")", "!=", "self", ".", "size", "(", "-", "1", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"diag does not make sense when matrix is not square\"", "\n", ")", "\n", "\n", "# calling approx diag", "\n", "", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "            ", "loss", "=", "self", ".", "criterion", "(", "self", ".", "model", "(", "self", ".", "data", ")", ",", "self", ".", "target", ")", "\n", "\n", "", "ones_list", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "ones_list", ".", "append", "(", "torch", ".", "ones_like", "(", "param", ")", ")", "\n", "\n", "# this may not strictly be an upper bound because J^T 1 may not", "\n", "# be a good approximator of \\sum_p |df/d\\theta_p|", "\n", "# J^T 1 = \\sum_j J_{ij} (returns a n dimensional vector)", "\n", "", "jac_sum_by_point", "=", "Rop", "(", "loss", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "ones_list", ")", "[", "0", "]", "\n", "\n", "if", "self", ".", "num_outputs", "==", "1", ":", "\n", "            ", "jac_sum_by_point", "=", "jac_sum_by_point", ".", "squeeze", "(", "-", "1", ")", "\n", "", "elif", "len", "(", "jac_sum_by_point", ".", "shape", ")", ">", "1", ":", "\n", "            ", "jac_sum_by_point", "=", "jac_sum_by_point", ".", "t", "(", ")", "\n", "\n", "# squares the n dimensional vector", "\n", "", "return", "jac_sum_by_point", ".", "pow", "(", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.get_root": [[320, 331], ["jacobian.Jacobian", "jacobian.Jacobian"], "methods", ["None"], ["", "def", "get_root", "(", "self", ",", "dim", "=", "-", "2", ")", ":", "\n", "        ", "if", "self", ".", "use_cross", "and", "dim", "==", "-", "1", ":", "\n", "            ", "return", "Jacobian", "(", "\n", "self", ".", "model", ",", "\n", "self", ".", "cross_data", ",", "\n", "self", ".", "cross_target", ",", "\n", "num_outputs", "=", "self", ".", "num_outputs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "Jacobian", "(", "\n", "self", ".", "model", ",", "self", ".", "data", ",", "self", ".", "target", ",", "num_outputs", "=", "self", ".", "num_outputs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.get_expansion": [[333, 338], ["FVPR_FD"], "methods", ["None"], ["", "", "def", "get_expansion", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "from", ".", "fvp_reg", "import", "FVPR_FD", "\n", "\n", "# we want N * F because F is a mean over the data pts", "\n", "return", "self", ".", "data", ".", "shape", "[", "0", "]", "*", "FVPR_FD", "(", "self", ".", "model", ",", "self", ".", "data", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._unsqueeze_batch": [[339, 353], ["ntk_lazytensor.NeuralTangent", "super()._unsqueeze_batch"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._unsqueeze_batch"], ["", "def", "_unsqueeze_batch", "(", "self", ",", "dim", ")", ":", "\n", "        ", "if", "dim", "==", "0", ":", "\n", "            ", "return", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "data", "=", "self", ".", "data", ",", "\n", "target", "=", "self", ".", "target", ",", "\n", "cross_data", "=", "self", ".", "cross_data", ",", "\n", "cross_target", "=", "self", ".", "cross_target", ",", "\n", "num_outputs", "=", "self", ".", "num_outputs", ",", "\n", "used_dims", "=", "self", ".", "used_dims", ",", "\n", "keep_outputs", "=", "True", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "super", "(", ")", ".", "_unsqueeze_batch", "(", "dim", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.__init__": [[22, 47], ["gpytorch.kernels.kernel.Kernel.__init__", "ntk.NTK.model.children", "param.__setattr__", "collections.OrderedDict"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "use_linearstrategy", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"\n        NTK is a kernel with the Jacobian matrix defined by a neural network (model).\n        Formally, K(x, y) = J(x)^T J(y), where J(.) is the Jacobian matrix of a neural\n        network. To keep computation under control, we compute matrix vector products \n        iteratively, via `z = J(y)v` and then `J(x)^T z`. Noting that gpytorch can \n        handle different prediction strategies, we include an option as to perform \n        inference in parameter space via a new linear prediction strategy\n        (`use_linearstrategy=True`). This kernel can be batched by setting kwargs in\n        gpytorch style.\n        \n        model: model with output parameters to compute Jacobians from\n\n        use_linearstrategy: whether to expand into parameter space\n        \"\"\"", "\n", "super", "(", "NTK", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "model", "=", "model", "\n", "\n", "# register constraints for botorch if you want to call botorch.fit", "\n", "for", "param", "in", "self", ".", "model", ".", "children", "(", ")", ":", "\n", "            ", "param", ".", "__setattr__", "(", "\"_constraints\"", ",", "OrderedDict", "(", ")", ")", "\n", "\n", "", "self", ".", "use_linearstrategy", "=", "use_linearstrategy", "\n", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag": [[48, 51], ["ntk.NTK.evaluate", "torch.diag"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag"], ["", "def", "diag", "(", "self", ")", ":", "\n", "        ", "output", "=", "self", ".", "evaluate", "(", ")", "\n", "return", "diag", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.get_root": [[52, 57], ["ntk_lazytensor.NeuralTangent", "ntk_lazytensor.NeuralTangent.get_root"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.get_root"], ["", "def", "get_root", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "kernel", "=", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "data", "=", "x", ",", "cross_data", "=", "None", ",", "**", "self", ".", "kwargs", ",", "**", "kwargs", "\n", ")", "\n", "return", "kernel", ".", "get_root", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.prediction_strategy": [[58, 74], ["LinearPredictionStrategy", "DefaultPredictionStrategy"], "methods", ["None"], ["", "def", "prediction_strategy", "(", "\n", "self", ",", "train_inputs", ",", "train_prior_dist", ",", "train_labels", ",", "likelihood", "\n", ")", ":", "\n", "        ", "if", "self", ".", "use_linearstrategy", ":", "\n", "            ", "from", ".", ".", "strategies", "import", "LinearPredictionStrategy", "\n", "\n", "return", "LinearPredictionStrategy", "(", "\n", "train_inputs", ",", "train_prior_dist", ",", "train_labels", ",", "likelihood", "\n", ")", "\n", "", "else", ":", "\n", "            ", "from", "gpytorch", ".", "models", ".", "exact_prediction_strategies", "import", "(", "\n", "DefaultPredictionStrategy", ",", "\n", ")", "\n", "\n", "return", "DefaultPredictionStrategy", "(", "\n", "train_inputs", ",", "train_prior_dist", ",", "train_labels", ",", "likelihood", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.forward": [[76, 107], ["x1_.transpose().unsqueeze.transpose().unsqueeze.transpose().unsqueeze", "ntk_lazytensor.NeuralTangent", "ntk_lazytensor.NeuralTangent", "output.diag.diag.diag", "x2.transpose().unsqueeze", "x1_.transpose().unsqueeze.transpose().unsqueeze.transpose", "x2.transpose"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag"], ["", "", "def", "forward", "(", "self", ",", "x1", ",", "x2", "=", "None", ",", "diag", "=", "False", ",", "last_dim_is_batch", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "x1_", "=", "x1", "\n", "\n", "# the following performs standard gpytorch based reshaping and batching", "\n", "if", "last_dim_is_batch", ":", "\n", "            ", "x1_", "=", "x1_", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "if", "x2", "is", "not", "None", ":", "\n", "            ", "if", "last_dim_is_batch", ":", "\n", "                ", "x2_", "=", "x2", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "x2_", "=", "x2", "\n", "\n", "# we define a NeuralTangent lazy tensor that defines the products of the", "\n", "# Jacobians properly. Here, we include x2_.", "\n", "", "output", "=", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "data", "=", "x1_", ",", "cross_data", "=", "x2_", ",", "**", "self", ".", "kwargs", ",", "**", "kwargs", "\n", ")", "\n", "", "else", ":", "\n", "# we define a NeuralTangent lazy tensor that defines the products of the", "\n", "# Jacobians properly. We do not need to include x2_ if we are only computing", "\n", "# K(x, x).", "\n", "            ", "output", "=", "NeuralTangent", "(", "\n", "model", "=", "self", ".", "model", ",", "data", "=", "x1_", ",", "cross_data", "=", "None", ",", "**", "self", ".", "kwargs", ",", "**", "kwargs", "\n", ")", "\n", "\n", "# sadly, we currently do not support fast versions of kernel diagonals.", "\n", "", "if", "diag", ":", "\n", "            ", "output", "=", "output", ".", "diag", "(", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT.__init__": [[22, 32], ["gpytorch.lazy.LazyTensor.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "base", ",", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"\n        TransposedLT is a lazy tensor class that enables efficient transpositions.\n        Currently, only two dimensional transpositions are implemented.\n\n        base (gpytorch.lazy.LazyTensor): base lazy tensor\n        kwargs: for other lazy tensor options (e.g. batch shaping)\n        \"\"\"", "\n", "super", "(", "TransposedLT", ",", "self", ")", ".", "__init__", "(", "base", ",", "**", "kwargs", ")", "\n", "self", ".", "base", "=", "base", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT._matmul": [[33, 35], ["jacobian.TransposedLT.base._t_matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._t_matmul"], ["", "def", "_matmul", "(", "self", ",", "rhs", ")", ":", "\n", "        ", "return", "self", ".", "base", ".", "_t_matmul", "(", "rhs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT._t_matmul": [[36, 38], ["jacobian.TransposedLT.base._matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul"], ["", "def", "_t_matmul", "(", "self", ",", "lhs", ")", ":", "\n", "        ", "return", "self", ".", "base", ".", "_matmul", "(", "lhs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT._transpose_nonbatch": [[39, 41], ["None"], "methods", ["None"], ["", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT._size": [[42, 48], ["jacobian.TransposedLT.base.size", "torch.Size"], "methods", ["None"], ["", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "base_size", "=", "self", ".", "base", ".", "size", "(", ")", "\n", "if", "val", "is", "not", "None", ":", "\n", "            ", "return", "base_size", "[", "val", "==", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "Size", "(", "[", "base_size", "[", "1", "]", ",", "base_size", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.TransposedLT._get_indices": [[49, 52], ["jacobian.TransposedLT.base._get_indices"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._get_indices"], ["", "", "def", "_get_indices", "(", "self", ",", "row_index", ",", "col_index", ",", "*", "batch_indices", ")", ":", "\n", "        ", "res", "=", "self", ".", "base", ".", "_get_indices", "(", "col_index", ",", "row_index", ",", "*", "batch_indices", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.__init__": [[55, 95], ["gpytorch.lazy.NonLazyTensor", "gpytorch.lazy.LazyTensor.__init__", "jacobian.Jacobian.model.parameters", "torch.tensor", "param.numel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ",", "\n", "data", ",", "\n", "target", "=", "None", ",", "\n", "num_outputs", "=", "1", ",", "\n", "cross_data", "=", "None", ",", "\n", "cross_target", "=", "None", ",", "\n", "dummy", "=", "None", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Jacobian is a lazy tensor class to store Jacobian matrices and only access via\n        either Jacobian vector products (_matmul) or Jacobian transpose vecotr products (_t_matmul)\n        model (torch.nn): model with output parameters to compute Jacobians from\n        data (torch.tensor): dataset that the Jacobian of the model is evaluated on\n        target (torch.tensor): label for the data (unused - check if deprectated)\n        num_ouputs (int): number of outputs of the model (default: 1)\n        cross_data (torch.tensor): dataset if we are computing a cross product J_x'J_y\n            (default: None which implies J_x'J_x)\n        cross_target (torch.tensor): label for the cross data (unused - check if deprecated)\n        dummy (None): used solely for gpytorch semantics & initialization\n        used_dims (int): if model has multiple outputs; which dimension to use for the Jacobian\n            (default: None which implies all dimensions)\n        \"\"\"", "\n", "# required for gpytorch semantics to work properly", "\n", "dummy", "=", "NonLazyTensor", "(", "torch", ".", "tensor", "(", "[", "[", "]", "]", ",", "device", "=", "data", ".", "device", ",", "dtype", "=", "data", ".", "dtype", ")", ")", "\n", "\n", "super", "(", "Jacobian", ",", "self", ")", ".", "__init__", "(", "dummy", "=", "dummy", ",", "model", "=", "model", ",", "data", "=", "data", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "target", "=", "target", "\n", "self", ".", "num_outputs", "=", "num_outputs", "\n", "\n", "self", ".", "loss", "=", "None", "\n", "\n", "self", ".", "num_params", "=", "0", "\n", "for", "param", "in", "self", ".", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "num_params", "+=", "param", ".", "numel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.dtype": [[96, 99], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device": [[100, 103], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._transpose_nonbatch": [[104, 106], ["jacobian.TransposedLT"], "methods", ["None"], ["", "def", "_transpose_nonbatch", "(", "self", ")", ":", "\n", "        ", "return", "TransposedLT", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._size": [[107, 114], ["jacobian.Jacobian.data.size", "torch.Size", "jacobian.Jacobian.data.size"], "methods", ["None"], ["", "def", "_size", "(", "self", ",", "val", "=", "None", ")", ":", "\n", "        ", "if", "val", "==", "0", ":", "\n", "            ", "return", "self", ".", "num_params", "\n", "", "elif", "val", "==", "1", ":", "\n", "            ", "return", "self", ".", "data", ".", "size", "(", "0", ")", "\n", "", "elif", "val", "==", "None", ":", "\n", "            ", "return", "torch", ".", "Size", "(", "[", "self", ".", "num_params", ",", "self", ".", "data", ".", "size", "(", "0", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul": [[116, 146], ["torch.norm", "torch.norm().eq().all", "torch.stack", "torch.zeros", "jacobian.Jacobian.model.zero_grad", "utils.Jacvec", "prod_list.append", "torch.stack.t", "torch.norm().eq", "jacobian.Jacobian.data.size", "rhs.size", "jacobian.Jacobian.model.parameters", "v.view", "utils.flatten", "torch.set_grad_enabled", "jacobian.Jacobian.model", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Jacvec", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["", "", "def", "_matmul", "(", "self", ",", "rhs", ")", ":", "\n", "        ", "rhs_norm", "=", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "\n", "zero_norms", "=", "(", "rhs_norm", "==", "0", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "vec", "=", "(", "rhs", "/", "rhs_norm", ")", ".", "t", "(", ")", "\n", "\n", "vec", "[", "zero_norms", ",", "...", "]", "=", "0.0", "\n", "\n", "if", "torch", ".", "norm", "(", "rhs", ",", "dim", "=", "0", ")", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "rhs", ".", "size", "(", "1", ")", ",", "device", "=", "rhs", ".", "device", ",", "dtype", "=", "rhs", ".", "dtype", "\n", ")", "\n", "\n", "", "prod_list", "=", "[", "]", "\n", "for", "v", "in", "vec", ":", "\n", "            ", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "\n", "if", "self", ".", "loss", "is", "None", ":", "\n", "                ", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                    ", "self", ".", "loss", "=", "self", ".", "model", "(", "self", ".", "data", ")", "\n", "\n", "", "", "z_current", "=", "Jacvec", "(", "\n", "self", ".", "loss", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "v", ".", "view", "(", "-", "1", ",", "self", ".", "num_outputs", ")", "\n", ")", "\n", "\n", "prod_list", ".", "append", "(", "flatten", "(", "z_current", ")", ")", "\n", "\n", "", "res", "=", "torch", ".", "stack", "(", "prod_list", ")", "\n", "return", "res", ".", "t", "(", ")", "*", "rhs_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._t_matmul": [[148, 175], ["torch.norm", "torch.norm().eq().all", "torch.stack", "torch.zeros", "utils.unflatten_like", "jacobian.Jacobian.model.zero_grad", "prod_list.append", "torch.stack.t", "torch.norm().eq", "jacobian.Jacobian.data.size", "lhs.size", "torch.set_grad_enabled", "utils.Rop", "prod_current[].view", "list", "jacobian.Jacobian.model", "jacobian.Jacobian.model.parameters", "torch.norm", "jacobian.Jacobian.model.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.unflatten_like", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "_t_matmul", "(", "self", ",", "lhs", ")", ":", "\n", "        ", "lhs_norm", "=", "torch", ".", "norm", "(", "lhs", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "\n", "zero_norms", "=", "(", "lhs_norm", "==", "0", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "vec", "=", "(", "lhs", "/", "lhs_norm", ")", ".", "t", "(", ")", "\n", "vec", "[", "zero_norms", ",", "...", "]", "=", "0.0", "\n", "\n", "if", "torch", ".", "norm", "(", "lhs", ",", "dim", "=", "0", ")", ".", "eq", "(", "0.0", ")", ".", "all", "(", ")", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "self", ".", "data", ".", "size", "(", "0", ")", ",", "lhs", ".", "size", "(", "1", ")", ",", "device", "=", "lhs", ".", "device", ",", "dtype", "=", "lhs", ".", "dtype", "\n", ")", "\n", "\n", "# self.model.train()", "\n", "\n", "", "prod_list", "=", "[", "]", "\n", "for", "v", "in", "vec", ":", "\n", "            ", "v_list", "=", "unflatten_like", "(", "v", ",", "likeTensorList", "=", "list", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", "\n", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                ", "if", "self", ".", "loss", "is", "None", ":", "\n", "                    ", "self", ".", "loss", "=", "self", ".", "model", "(", "self", ".", "data", ")", "\n", "\n", "", "prod_current", "=", "Rop", "(", "self", ".", "loss", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "v_list", ")", "\n", "", "prod_list", ".", "append", "(", "prod_current", "[", "0", "]", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "res", "=", "torch", ".", "stack", "(", "prod_list", ")", "\n", "return", "res", ".", "t", "(", ")", "*", "lhs_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._get_cols": [[176, 179], ["jacobian.Jacobian", "col_index.view"], "methods", ["None"], ["", "def", "_get_cols", "(", "self", ",", "col_index", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "subset_data", "=", "self", ".", "data", "[", "col_index", ".", "view", "(", "-", "1", ")", ",", ":", "]", "\n", "return", "Jacobian", "(", "self", ".", "model", ",", "subset_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._get_indices": [[180, 185], ["jacobian.Jacobian._get_cols", "torch.eye", "jacobian.Jacobian.matmul().t", "jacobian.Jacobian.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._get_cols"], ["", "def", "_get_indices", "(", "self", ",", "row_index", ",", "col_index", ",", "*", "batch_indices", ")", ":", "\n", "        ", "row_jacobian", "=", "self", ".", "_get_cols", "(", "col_index", ")", "\n", "id_i", "=", "torch", ".", "eye", "(", "row_jacobian", ".", "shape", "[", "-", "1", "]", ",", "device", "=", "self", ".", "device", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "res", "=", "row_jacobian", ".", "matmul", "(", "id_i", ")", ".", "t", "(", ")", "\n", "return", "res", "[", "...", ",", "row_index", "[", "0", "]", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop": [[17, 28], ["torch.ones_like", "torch.autograd.grad", "torch.autograd.grad"], "function", ["None"], ["import", "json", "\n", "\n", "from", ".", "constants", "import", "serialization_constants", "as", "consts", "\n", "from", ".", "constants", "import", "repurposer_keys", "as", "keys", "\n", "\n", "\n", "def", "sklearn_model_to_dict", "(", "target_model", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Jacvec": [[30, 39], ["torch.autograd.grad"], "function", ["None"], ["# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten": [[41, 53], ["torch.cat().view", "i.contiguous().view", "torch.cat", "i.contiguous"], "function", ["None"], ["# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.unflatten_like": [[55, 71], ["tensor.numel", "outList.append", "vector[].view"], "function", ["None"], ["# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.SimpleConvModel.__init__": [[24, 31], ["super().__init__", "torch.nn.Conv2d", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "linear", "=", "True", ",", "nout", "=", "1", ")", ":", "\n", "        ", "super", "(", "SimpleConvModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "torch", ".", "nn", ".", "Conv2d", "(", "3", ",", "1", ",", "1", ")", "\n", "if", "linear", ":", "\n", "            ", "self", ".", "linear", "=", "torch", ".", "nn", ".", "Linear", "(", "1024", ",", "nout", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.SimpleConvModel.forward": [[32, 35], ["test_neuraltangent.SimpleConvModel.conv().view", "test_neuraltangent.SimpleConvModel.linear", "x.size", "test_neuraltangent.SimpleConvModel.conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv", "(", "x", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "return", "self", ".", "linear", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_matmul": [[38, 59], ["torch.random.manual_seed", "torch.nn.Sequential", "torch.randn", "torch.nn.Sequential.", "torch.ones", "finite_ntk.lazy.ntk_lazytensor.Jacvec", "test_neuraltangent.TestNeuralTangent.assertEqual", "finite_ntk.lazy.NeuralTangent", "finite_ntk.lazy.NeuralTangent.matmul", "test_neuraltangent.TestNeuralTangent.assertLess", "torch.nn.Linear", "torch.nn.Sequential.parameters", "finite_ntk.lazy.ntk_lazytensor.Rop", "ntk_vec.size", "torch.Size", "torch.nn.Sequential.parameters", "torch.norm", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Jacvec", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["    ", "def", "test_matmul", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "torch", ".", "random", ".", "manual_seed", "(", "seed", ")", "\n", "\n", "model", "=", "torch", ".", "nn", ".", "Sequential", "(", "torch", ".", "nn", ".", "Linear", "(", "30", ",", "1", ",", "bias", "=", "True", ")", ")", "\n", "\n", "input_data", "=", "torch", ".", "randn", "(", "50", ",", "30", ")", "\n", "\n", "output", "=", "model", "(", "input_data", ")", "\n", "\n", "rhs", "=", "torch", ".", "ones", "(", "50", ",", "1", ")", "\n", "z", "=", "Jacvec", "(", "output", ",", "model", ".", "parameters", "(", ")", ",", "rhs", ")", "\n", "\n", "ntk_vec", "=", "Rop", "(", "output", ",", "model", ".", "parameters", "(", ")", ",", "z", ")", "[", "0", "]", "\n", "\n", "# this checks the size is what we'd expect from a Jv and a J^T v", "\n", "self", ".", "assertEqual", "(", "ntk_vec", ".", "size", "(", ")", ",", "torch", ".", "Size", "(", "(", "50", ",", "1", ")", ")", ")", "\n", "\n", "ntk", "=", "NeuralTangent", "(", "model", ",", "data", "=", "input_data", ")", "\n", "kernel_output", "=", "ntk", ".", "matmul", "(", "rhs", ")", "\n", "\n", "self", ".", "assertLess", "(", "torch", ".", "norm", "(", "kernel_output", "-", "ntk_vec", ")", "/", "torch", ".", "norm", "(", "ntk_vec", ")", ",", "1e-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_get_item_2d": [[60, 73], ["torch.nn.Sequential", "torch.randn", "finite_ntk.lazy.NeuralTangent", "test_neuraltangent.TestNeuralTangent.assertEqual", "test_neuraltangent.TestNeuralTangent.assertEqual", "torch.nn.Linear", "torch.Size", "torch.Size"], "methods", ["None"], ["", "def", "test_get_item_2d", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "# first 2d setting", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "Sequential", "(", "torch", ".", "nn", ".", "Linear", "(", "30", ",", "1", ",", "bias", "=", "True", ")", ")", "\n", "\n", "input_data", "=", "torch", ".", "randn", "(", "50", ",", "30", ")", "\n", "\n", "ntk", "=", "NeuralTangent", "(", "model", ",", "data", "=", "input_data", ")", "\n", "\n", "# check shape is what we think it is", "\n", "self", ".", "assertEqual", "(", "ntk", ".", "shape", ",", "torch", ".", "Size", "(", "[", "50", ",", "50", "]", ")", ")", "\n", "\n", "# check that _getitem returns outputs as expected for a single output", "\n", "self", ".", "assertEqual", "(", "ntk", "[", "10", ":", "12", ",", "14", ":", "18", "]", ".", "shape", ",", "torch", ".", "Size", "(", "[", "2", ",", "4", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_get_item_4d": [[74, 96], ["test_neuraltangent.SimpleConvModel", "torch.randn", "finite_ntk.lazy.NeuralTangent", "test_neuraltangent.TestNeuralTangent.assertEqual", "test_neuraltangent.TestNeuralTangent.assertEqual", "test_neuraltangent.SimpleConvModel", "finite_ntk.lazy.NeuralTangent", "test_neuraltangent.TestNeuralTangent.assertEqual", "test_neuraltangent.TestNeuralTangent.assertEqual", "subset.evaluate", "test_neuraltangent.TestNeuralTangent.assertGreater", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "subset.evaluate.norm"], "methods", ["None"], ["", "def", "test_get_item_4d", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "model", "=", "SimpleConvModel", "(", ")", "\n", "input_data", "=", "torch", ".", "randn", "(", "64", ",", "3", ",", "32", ",", "32", ")", "# cifar sized image", "\n", "\n", "ntk", "=", "NeuralTangent", "(", "model", ",", "data", "=", "input_data", ")", "\n", "\n", "self", ".", "assertEqual", "(", "ntk", ".", "shape", ",", "torch", ".", "Size", "(", "[", "64", ",", "64", "]", ")", ")", "\n", "\n", "# check that _getitem returns outputs as expected for a single output", "\n", "self", ".", "assertEqual", "(", "ntk", "[", "10", ":", "12", ",", "14", ":", "18", "]", ".", "shape", ",", "torch", ".", "Size", "(", "[", "2", ",", "4", "]", ")", ")", "\n", "\n", "model_multioutput", "=", "SimpleConvModel", "(", "linear", "=", "False", ")", "\n", "ntk_mo", "=", "NeuralTangent", "(", "model_multioutput", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1024", ")", "\n", "self", ".", "assertEqual", "(", "ntk_mo", ".", "shape", ",", "torch", ".", "Size", "(", "[", "1024", ",", "64", ",", "64", "]", ")", ")", "\n", "\n", "# subset a small bit", "\n", "subset", "=", "ntk_mo", "[", "10", ":", "15", ",", "10", ":", "12", ",", "15", ":", "19", "]", "\n", "self", ".", "assertEqual", "(", "subset", ".", "shape", ",", "torch", ".", "Size", "(", "[", "5", ",", "2", ",", "4", "]", ")", ")", "\n", "\n", "# ensure that we can evaluate", "\n", "eval_subset", "=", "subset", ".", "evaluate", "(", ")", "\n", "self", ".", "assertGreater", "(", "eval_subset", ".", "norm", "(", ")", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_approx_diag_multi_output": [[97, 112], ["torch.randn", "test_neuraltangent.SimpleConvModel", "finite_ntk.lazy.NeuralTangent", "finite_ntk.lazy.NeuralTangent._approx_diag", "finite_ntk.lazy.NeuralTangent.diag", "test_neuraltangent.TestNeuralTangent.assertEqual", "test_neuraltangent.TestNeuralTangent.assertGreater", "torch.sum", "finite_ntk.lazy.NeuralTangent._approx_diag.numel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent._approx_diag", "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag"], ["", "def", "test_approx_diag_multi_output", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "input_data", "=", "torch", ".", "randn", "(", "64", ",", "3", ",", "32", ",", "32", ")", "# cifar sized image", "\n", "model_multioutput", "=", "SimpleConvModel", "(", "linear", "=", "False", ")", "\n", "ntk_mo", "=", "NeuralTangent", "(", "model_multioutput", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1024", ")", "\n", "approx_diag", "=", "ntk_mo", ".", "_approx_diag", "(", ")", "\n", "\n", "true_diag", "=", "ntk_mo", ".", "diag", "(", ")", "\n", "\n", "self", ".", "assertEqual", "(", "approx_diag", ".", "shape", ",", "true_diag", ".", "shape", ")", "\n", "\n", "# should be nearly an upper bound??", "\n", "approx_diag", "[", "approx_diag", "<", "1e-3", "]", "=", "0.0", "\n", "true_diag", "[", "true_diag", "<", "1e-3", "]", "=", "0.0", "\n", "self", ".", "assertGreater", "(", "\n", "torch", ".", "sum", "(", "approx_diag", ">=", "true_diag", ")", ",", "0.99", "*", "approx_diag", ".", "numel", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_fourd_symmetry": [[114, 123], ["torch.randn", "test_neuraltangent.SimpleConvModel", "finite_ntk.lazy.NeuralTangent", "finite_ntk.lazy.NeuralTangent.evaluate", "finite_ntk.lazy.NeuralTangent.evaluate.permute", "test_neuraltangent.TestNeuralTangent.assertLess", "torch.norm"], "methods", ["None"], ["", "def", "test_fourd_symmetry", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "input_data", "=", "torch", ".", "randn", "(", "4", ",", "3", ",", "32", ",", "32", ")", "\n", "model", "=", "SimpleConvModel", "(", "linear", "=", "True", ",", "nout", "=", "3", ")", "\n", "\n", "ntk_mo", "=", "NeuralTangent", "(", "model", ",", "data", "=", "input_data", ",", "num_outputs", "=", "3", ")", "\n", "ntk_mat", "=", "ntk_mo", ".", "evaluate", "(", ")", "\n", "\n", "ntk_mat_transposed", "=", "ntk_mat", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "self", ".", "assertLess", "(", "torch", ".", "norm", "(", "ntk_mat", "-", "ntk_mat_transposed", ")", ",", "1e-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_neuraltangent.TestNeuralTangent.test_detachment_and_squeezing": [[124, 135], ["torch.randn", "test_neuraltangent.SimpleConvModel", "finite_ntk.lazy.NeuralTangent", "test_neuraltangent.TestNeuralTangent.assertEqual", "torch.Size", "finite_ntk.lazy.NeuralTangent.detach_", "test_neuraltangent.TestNeuralTangent.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.detach_"], ["", "def", "test_detachment_and_squeezing", "(", "self", ")", ":", "\n", "        ", "input_data", "=", "torch", ".", "randn", "(", "4", ",", "3", ",", "32", ",", "32", ")", "\n", "model", "=", "SimpleConvModel", "(", "linear", "=", "True", ",", "nout", "=", "3", ")", "\n", "\n", "ntk_mo", "=", "NeuralTangent", "(", "model", ",", "data", "=", "input_data", ",", "num_outputs", "=", "1", ",", "keep_outputs", "=", "True", ")", "\n", "\n", "self", ".", "assertEqual", "(", "ntk_mo", ".", "shape", ",", "torch", ".", "Size", "(", "[", "1", ",", "4", ",", "4", "]", ")", ")", "\n", "try", ":", "\n", "            ", "ntk_mo", ".", "detach_", "(", ")", "\n", "", "except", ":", "\n", "            ", "self", ".", "assertAlmostEqual", "(", "1", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_fisherreg_fd.TestFisherRFD.test_fisher_regression_fd": [[21, 38], ["torch.nn.Sequential", "torch.randn", "torch.nn.Linear", "torch.randn.size", "finite_ntk.lazy.FVPR_FD", "finite_ntk.lazy.FVPR_FD._matmul", "test_fisherreg_fd.TestFisherRFD.assertLess", "torch.randn.t", "torch.eye", "torch.norm", "torch.norm", "rel_error.item"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian._matmul"], ["    ", "def", "test_fisher_regression_fd", "(", "self", ")", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "Sequential", "(", "torch", ".", "nn", ".", "Linear", "(", "7500", ",", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n", "data", "=", "torch", ".", "randn", "(", "50", ",", "7500", ")", "\n", "\n", "# closed form fisher information for linear regression", "\n", "fim", "=", "data", ".", "t", "(", ")", "@", "data", "/", "data", ".", "size", "(", "0", ")", "\n", "\n", "eps_list", "=", "[", "1.0", ",", "1e-1", ",", "5e-2", ",", "1e-2", ",", "1e-3", ",", "5e-3", ",", "1e-4", ",", "5e-4", ",", "1e-5", ",", "5e-6", ",", "1e-6", ",", "5e-6", "]", "\n", "\n", "for", "epsilon", "in", "eps_list", ":", "\n", "            ", "fvp", "=", "FVPR_FD", "(", "model", ",", "data", ",", "epsilon", "=", "epsilon", ")", "\n", "fvp_approx", "=", "fvp", ".", "_matmul", "(", "torch", ".", "eye", "(", "data", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "rel_error", "=", "torch", ".", "norm", "(", "fvp_approx", "-", "fim", ")", "/", "torch", ".", "norm", "(", "fim", ")", "\n", "\n", "# check to ensure that our relative error is never greater than 4%", "\n", "self", ".", "assertLess", "(", "rel_error", ".", "item", "(", ")", ",", "4e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_fisherreg_fd.TestFisherRFD.test_fisher_matrix_matrix_matmul": [[39, 70], ["torch.nn.Sequential", "torch.randn", "finite_ntk.lazy.FVPR_FD", "torch.nn.Sequential.parameters", "torch.qr", "finite_ntk.lazy.FVPR_FD.matmul", "test_fisherreg_fd.TestFisherRFD.assertLess", "test_fisherreg_fd.TestFisherRFD.assertLess", "torch.nn.Linear", "torch.nn.ELU", "torch.nn.Linear", "torch.nn.ELU", "torch.nn.Linear", "p.numel", "torch.randn", "torch.randn", "finite_ntk.lazy.FVPR_FD.matmul", "torch.norm", "torch.norm", "split_matmul.norm", "finite_ntk.lazy.FVPR_FD.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "", "def", "test_fisher_matrix_matrix_matmul", "(", "self", ")", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "1", ",", "400", ")", ",", "\n", "torch", ".", "nn", ".", "ELU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "400", ",", "400", ")", ",", "\n", "torch", ".", "nn", ".", "ELU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "400", ",", "1", ")", ",", "\n", ")", "\n", "\n", "data", "=", "torch", ".", "randn", "(", "1500", ",", "1", ")", "\n", "\n", "fvp", "=", "FVPR_FD", "(", "model", ",", "data", ")", "\n", "\n", "numpars", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "numpars", "+=", "p", ".", "numel", "(", ")", "\n", "\n", "", "orthmat", ",", "_", "=", "torch", ".", "qr", "(", "torch", ".", "randn", "(", "numpars", ",", "80", ")", ")", "\n", "emat", "=", "1e-2", "*", "torch", ".", "randn", "(", "80", ",", "2", ")", "\n", "\n", "full_matmul", "=", "fvp", ".", "matmul", "(", "orthmat", "@", "emat", ")", "\n", "split_matmul", "=", "fvp", ".", "matmul", "(", "orthmat", ")", "@", "emat", "\n", "\n", "# check that F (Vy) = FV y", "\n", "self", ".", "assertLess", "(", "\n", "torch", ".", "norm", "(", "full_matmul", "-", "split_matmul", ")", "/", "split_matmul", ".", "norm", "(", ")", ",", "1e-2", "\n", ")", "\n", "\n", "# check that matrix columns work", "\n", "self", ".", "assertLess", "(", "\n", "torch", ".", "norm", "(", "full_matmul", "[", ":", ",", "0", "]", "-", "fvp", ".", "matmul", "(", "orthmat", "@", "emat", "[", ":", ",", "0", "]", ")", ")", ",", "1e-5", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_rop.SimpleConvModel.__init__": [[24, 31], ["super().__init__", "torch.nn.Conv2d", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "linear", "=", "True", ",", "nout", "=", "1", ")", ":", "\n", "        ", "super", "(", "SimpleConvModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "torch", ".", "nn", ".", "Conv2d", "(", "3", ",", "1", ",", "1", ")", "\n", "if", "linear", ":", "\n", "            ", "self", ".", "linear", "=", "torch", ".", "nn", ".", "Linear", "(", "1024", ",", "nout", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_rop.SimpleConvModel.forward": [[32, 35], ["test_rop.SimpleConvModel.conv().view", "test_rop.SimpleConvModel.linear", "x.size", "test_rop.SimpleConvModel.conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv", "(", "x", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "return", "self", ".", "linear", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_rop.TestRop.test_jacobian_vector_product": [[38, 57], ["torch.random.manual_seed", "torch.randn", "test_rop.SimpleConvModel", "SimpleConvModel.parameters", "finite_ntk.lazy.utils.Jacvec", "print", "finite_ntk.lazy.utils.flatten().numel", "test_rop.TestRop.assertEqual", "p.numel", "SimpleConvModel.parameters", "torch.ones", "SimpleConvModel.", "torch.randn", "finite_ntk.lazy.utils.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Jacvec", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["    ", "def", "test_jacobian_vector_product", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "torch", ".", "random", ".", "manual_seed", "(", "seed", ")", "\n", "input", "=", "torch", ".", "randn", "(", "64", ",", "3", ",", "32", ",", "32", ")", "\n", "model", "=", "SimpleConvModel", "(", "nout", "=", "2", ")", "\n", "\n", "model_pars", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "model_pars", "+=", "p", ".", "numel", "(", ")", "\n", "\n", "", "loss", "=", "(", "model", "(", "input", ")", "-", "torch", ".", "randn", "(", "64", ",", "2", ")", ")", "**", "2", "\n", "# loss = loss.sum(-2)", "\n", "\n", "# Jv returns a list that should have the same number of elements", "\n", "# as the number of parameters", "\n", "result", "=", "utils", ".", "Jacvec", "(", "loss", ",", "model", ".", "parameters", "(", ")", ",", "torch", ".", "ones", "(", "64", ",", "2", ")", ")", "\n", "print", "(", "result", "[", "0", "]", ".", "shape", ")", "\n", "result_elements", "=", "utils", ".", "flatten", "(", "result", ")", ".", "numel", "(", ")", "\n", "\n", "self", ".", "assertEqual", "(", "result_elements", ",", "model_pars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.lazy.test_rop.TestRop.test_rop": [[58, 74], ["torch.random.manual_seed", "torch.randn", "test_rop.SimpleConvModel", "SimpleConvModel.parameters", "torch.randn", "finite_ntk.lazy.utils.unflatten_like", "finite_ntk.lazy.utils.Rop", "test_rop.TestRop.assertEqual", "p.numel", "SimpleConvModel.parameters", "SimpleConvModel.parameters", "SimpleConvModel.", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.unflatten_like", "home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.Rop", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "test_rop", "(", "self", ",", "seed", "=", "2019", ")", ":", "\n", "        ", "torch", ".", "random", ".", "manual_seed", "(", "seed", ")", "\n", "input", "=", "torch", ".", "randn", "(", "64", ",", "3", ",", "32", ",", "32", ")", "\n", "model", "=", "SimpleConvModel", "(", "nout", "=", "2", ")", "\n", "\n", "model_pars", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "model_pars", "+=", "p", ".", "numel", "(", ")", "\n", "\n", "", "loss", "=", "(", "model", "(", "input", ")", "-", "torch", ".", "randn", "(", "64", ",", "2", ")", ")", "**", "2", "\n", "\n", "ones", "=", "torch", ".", "randn", "(", "model_pars", ",", "1", ")", "\n", "vec", "=", "utils", ".", "unflatten_like", "(", "ones", ",", "model", ".", "parameters", "(", ")", ")", "\n", "# J^T v returns a vector", "\n", "result", "=", "utils", ".", "Rop", "(", "loss", ",", "model", ".", "parameters", "(", ")", ",", "vec", ")", "\n", "self", ".", "assertEqual", "(", "result", "[", "0", "]", ".", "shape", ",", "(", "64", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.__init__": [[26, 71], ["gpytorch.models.exact_prediction_strategies.DefaultPredictionStrategy.__init__", "linear_strategy.LinearPredictionStrategy.likelihood", "linear_strategy.LinearPredictionStrategy.lik_train_train_covar.lazy_tensors[].evaluate_kernel", "linear_strategy.LinearPredictionStrategy.kernel_class.get_expansion", "linear_strategy.LinearPredictionStrategy.lik_train_train_covar.lazy_tensors[]._diag[].item", "linear_strategy.LinearPredictionStrategy.add_jitter"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk_lazytensor.NeuralTangent.get_expansion"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "train_inputs", ",", "\n", "train_prior_dist", ",", "\n", "train_labels", ",", "\n", "likelihood", ",", "\n", "root", "=", "None", ",", "\n", "inv_root", "=", "None", ",", "\n", "epsilon", "=", "1e-3", ",", "\n", "preconditioner", "=", "None", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        LinearPredictionStrategy is a variant of gpytorch's default prediction strategy\n        that does all inference and caching in parameter space rather than in function \n        space. It will only work for kernels which have a finite number of basis functions\n        (e.g. basis function models such as the finite neural tangent kernel). \n        train_inputs: input training data\n        train_prior_dist: prior distribution created by model (e.g. by calling model(train_inputs))\n        train_labels: training response\n        likelihood: likelihood for the data (e.g. a GaussianLikelihood)\n        root: root decomposition of prior distribution (used internally)\n        inv_root: inverse root decomposition of training prior distribution (used internally)\n        epsilon: hyper-parameter for fast Fisher vector products (TODO: see if can be replaced by kwargs)\n        preconditioner: unused (TODO: see if should be deprecated)\n        \"\"\"", "\n", "# initialize in the standard manner", "\n", "super", "(", "LinearPredictionStrategy", ",", "self", ")", ".", "__init__", "(", "\n", "train_inputs", ",", "train_prior_dist", ",", "train_labels", ",", "likelihood", ",", "root", ",", "inv_root", "\n", ")", "\n", "\n", "self", ".", "preconditioner", "=", "preconditioner", "\n", "\n", "# store mean since that's not stored for some reason?", "\n", "mvn", "=", "self", ".", "likelihood", "(", "train_prior_dist", ",", "train_inputs", ")", "\n", "self", ".", "lik_train_mean", "=", "mvn", ".", "mean", "\n", "\n", "# now pre-compute the solves and eigendecompositions", "\n", "self", ".", "kernel_class", "=", "self", ".", "lik_train_train_covar", ".", "lazy_tensors", "[", "0", "]", ".", "evaluate_kernel", "(", ")", "\n", "# lazy matmul that is F v", "\n", "fvp", "=", "self", ".", "kernel_class", ".", "get_expansion", "(", "epsilon", "=", "epsilon", ")", "\n", "\n", "# also add some jitter: eq to prior inverse variance", "\n", "# store F + \\sigma^2 I", "\n", "self", ".", "noise", "=", "self", ".", "lik_train_train_covar", ".", "lazy_tensors", "[", "1", "]", ".", "_diag", "[", "0", "]", ".", "item", "(", ")", "\n", "self", ".", "lik_train_train_expansion", "=", "fvp", ".", "add_jitter", "(", "self", ".", "noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy._exact_predictive_covar_inv_quad_form_root": [[72, 97], ["gpytorch.utils.lanczos.lanczos_tridiag", "gpytorch.utils.lanczos.lanczos_tridiag_to_diag", "torch.diag", "gpytorch.settings.max_root_decomposition_size.value", "evals.pow"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.diag"], ["", "def", "_exact_predictive_covar_inv_quad_form_root", "(", "self", ",", "expanded_lt", ",", "test_train_covar", ")", ":", "\n", "        ", "\"\"\"\n        Computes :math:`K_{X^{*}X} S` given a precomputed cache\n        Where :math:`S` is a tensor such that :math:`SS^{\\\\top} = (K_{XX} + \\sigma^2 I)^{-1}`\n        Args:\n            precomputed_cache (:obj:`torch.tensor`): What was computed in _exact_predictive_covar_inv_quad_form_cache\n            test_train_covar (:obj:`torch.tensor`): The observed noise (from the likelihood)\n        Returns\n            :obj:`~gpytorch.lazy.LazyTensor`: :math:`K_{X^{*}X} S`\n        \"\"\"", "\n", "qmats", ",", "tmats", "=", "lanczos_tridiag", "(", "\n", "expanded_lt", ".", "matmul", ",", "\n", "max_iter", "=", "settings", ".", "max_root_decomposition_size", ".", "value", "(", ")", ",", "\n", "matrix_shape", "=", "expanded_lt", ".", "shape", ",", "\n", "device", "=", "expanded_lt", ".", "device", ",", "\n", "dtype", "=", "expanded_lt", ".", "dtype", ",", "\n", ")", "\n", "evals", ",", "evecs", "=", "lanczos_tridiag_to_diag", "(", "tmats", ")", "\n", "\n", "self", ".", "gram_evecs", "=", "qmats", "@", "evecs", "\n", "self", ".", "gram_evals", "=", "evals", "\n", "\n", "covar_root", "=", "self", ".", "gram_evecs", "@", "torch", ".", "diag", "(", "evals", ".", "pow", "(", "-", "0.5", ")", ")", "\n", "\n", "return", "covar_root", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.covar_cache": [[98, 104], ["gpytorch.utils.memoize.cached", "linear_strategy.LinearPredictionStrategy._exact_predictive_covar_inv_quad_form_root"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy._exact_predictive_covar_inv_quad_form_root"], ["", "@", "property", "\n", "@", "cached", "(", "name", "=", "\"covar_cache\"", ")", "\n", "def", "covar_cache", "(", "self", ")", ":", "\n", "# #TODO: THE CACHE SHOULD RETURN ONLY S OR S M", "\n", "        ", "return", "self", ".", "_exact_predictive_covar_inv_quad_form_root", "(", "\n", "self", ".", "lik_train_train_expansion", ",", "self", ".", "_last_test_train_covar", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.mean_cache": [[106, 121], ["gpytorch.utils.memoize.cached", "linear_strategy.LinearPredictionStrategy.kernel_class.get_root", "linear_strategy.LinearPredictionStrategy.matmul", "linear_strategy.LinearPredictionStrategy.lik_train_train_expansion.inv_matmul", "gpytorch.settings.detach_test_caches.on", "linear_strategy.LinearPredictionStrategy.detach"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.get_root"], ["", "@", "property", "\n", "@", "cached", "(", "name", "=", "\"mean_cache\"", ")", "\n", "def", "mean_cache", "(", "self", ")", ":", "\n", "# TODO: THE CACHE SHOULD BE THE ENTIRE SOLVE - F^+ J^T Y", "\n", "        ", "train_labels_offset", "=", "(", "self", ".", "train_labels", "-", "self", ".", "lik_train_mean", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "features_trainx", "=", "self", ".", "kernel_class", ".", "get_root", "(", ")", "\n", "response", "=", "features_trainx", ".", "matmul", "(", "train_labels_offset", ")", "\n", "\n", "# with settings.cg_tolerance(1e-4):", "\n", "mean_cache", "=", "self", ".", "lik_train_train_expansion", ".", "inv_matmul", "(", "response", ")", "\n", "if", "settings", ".", "detach_test_caches", ".", "on", "(", ")", ":", "\n", "            ", "return", "mean_cache", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "mean_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.exact_predictive_mean": [[122, 136], ["test_train_covar.evaluate_kernel().get_root", "test_train_covar.evaluate_kernel().get_root.t().matmul", "test_train_covar.evaluate_kernel().get_root.t().matmul.view_as", "test_train_covar.evaluate_kernel", "test_train_covar.evaluate_kernel().get_root.t"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.get_root"], ["", "", "def", "exact_predictive_mean", "(", "self", ",", "test_mean", ",", "test_train_covar", ")", ":", "\n", "        ", "\"\"\"\n        Computes the posterior predictive covariance of a GP\n        Args:\n            test_mean (:obj:`torch.tensor`): The test prior mean\n            test_train_covar (:obj:`gpytorch.lazy.LazyTensor`): Covariance matrix between test and train inputs\n        Returns:\n            :obj:`torch.tensor`: The predictive posterior mean of the test points\n        \"\"\"", "\n", "features_xstar", "=", "test_train_covar", ".", "evaluate_kernel", "(", ")", ".", "get_root", "(", "dim", "=", "-", "2", ")", "\n", "\n", "res", "=", "features_xstar", ".", "t", "(", ")", ".", "matmul", "(", "self", ".", "mean_cache", ")", "\n", "res", "=", "res", ".", "view_as", "(", "test_mean", ")", "+", "test_mean", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.exact_predictive_covar": [[137, 163], ["gpytorch.settings.fast_pred_var.on", "gpytorch.settings.skip_posterior_variances.on", "gpytorch.settings.fast_pred_var.off", "gpytorch.lazy.ZeroLazyTensor", "super().exact_predictive_covar", "test_train_covar.evaluate_kernel().get_root", "gpytorch.lazy.RootLazyTensor", "test_train_covar.evaluate_kernel().get_root.t", "test_test_covar.size", "test_train_covar.evaluate_kernel"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.strategies.linear_strategy.LinearPredictionStrategy.exact_predictive_covar", "home.repos.pwc.inspect_result.amzn_xfer.lazy.ntk.NTK.get_root"], ["", "def", "exact_predictive_covar", "(", "self", ",", "test_test_covar", ",", "test_train_covar", ")", ":", "\n", "        ", "\"\"\"\n        Computes the posterior predictive covariance of a GP\n        Args:\n            test_train_covar (:obj:`gpytorch.lazy.LazyTensor`): Covariance matrix between test and train inputs\n            test_test_covar (:obj:`gpytorch.lazy.LazyTensor`): Covariance matrix between test inputs\n        Returns:\n            :obj:`gpytorch.lazy.LazyTensor`: A LazyTensor representing the predictive posterior covariance of the\n                                               test points\n        \"\"\"", "\n", "if", "settings", ".", "fast_pred_var", ".", "on", "(", ")", ":", "\n", "            ", "self", ".", "_last_test_train_covar", "=", "test_train_covar", "\n", "\n", "", "if", "settings", ".", "skip_posterior_variances", ".", "on", "(", ")", ":", "\n", "            ", "return", "ZeroLazyTensor", "(", "*", "test_test_covar", ".", "size", "(", ")", ")", "\n", "\n", "", "if", "settings", ".", "fast_pred_var", ".", "off", "(", ")", ":", "\n", "            ", "super", "(", ")", ".", "exact_predictive_covar", "(", "test_test_covar", ",", "test_train_covar", ")", "\n", "", "else", ":", "\n", "            ", "features_xstar", "=", "test_train_covar", ".", "evaluate_kernel", "(", ")", ".", "get_root", "(", "dim", "=", "-", "2", ")", "\n", "\n", "# compute J^T Cache as our root tensor", "\n", "j_star_covar", "=", "features_xstar", ".", "t", "(", ")", "@", "self", ".", "covar_cache", "\n", "\n", "covar_expanded", "=", "RootLazyTensor", "(", "j_star_covar", ")", "\n", "return", "self", ".", "noise", "*", "covar_expanded", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.__init__": [[28, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "alpha_plot", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "_losses", "=", "{", "}", "\n", "self", ".", "_parameters", "=", "{", "}", "\n", "\n", "self", ".", "alpha_plot", "=", "alpha_plot", "\n", "\n", "self", ".", "EPOCH", "=", "'epoch'", "\n", "self", ".", "TASK", "=", "'task'", "\n", "self", ".", "METASTEP", "=", "'metastep'", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.reset": [[38, 41], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_losses", "=", "{", "}", "\n", "self", ".", "_parameters", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.num_tasks": [[42, 48], ["metalogger.MetaLogger._parameters.keys", "len", "all_tasks.append", "numpy.unique", "metalogger.MetaLogger._parameters[].keys", "isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_tasks", "(", "self", ")", ":", "\n", "        ", "all_tasks", "=", "[", "]", "\n", "for", "ms", "in", "self", ".", "_parameters", ".", "keys", "(", ")", ":", "\n", "            ", "all_tasks", ".", "append", "(", "[", "k", "for", "k", "in", "self", ".", "_parameters", "[", "ms", "]", ".", "keys", "(", ")", "if", "isinstance", "(", "k", ",", "int", ")", "]", ")", "\n", "", "return", "len", "(", "np", ".", "unique", "(", "all_tasks", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.report": [[49, 61], ["None"], "methods", ["None"], ["", "def", "report", "(", "self", ",", "end", ",", "hook", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Report results at end of epoch/task/metastep using hook function.\n        \"\"\"", "\n", "if", "hook", "is", "None", ":", "\n", "            ", "hook", "=", "logging", ".", "info", "\n", "\n", "", "reporter", "=", "{", "self", ".", "EPOCH", ":", "self", ".", "_report_epoch", ",", "\n", "self", ".", "TASK", ":", "self", ".", "_report_task", ",", "\n", "self", ".", "METASTEP", ":", "self", ".", "_report_metastep", "}", "\n", "\n", "reporter", "[", "end", "]", "(", "hook", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger._report_epoch": [[62, 67], ["hook", "len"], "methods", ["None"], ["", "def", "_report_epoch", "(", "self", ",", "hook", ")", ":", "\n", "        ", "hook", "(", "'\\t\\tMetastep: {}, Task: {}, Epoch: {}, Loss: {:.3f}'", ".", "format", "(", "\n", "self", ".", "latest_metastep", ",", "self", ".", "latest_task", ",", "\n", "len", "(", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", "[", "self", ".", "latest_task", "]", ")", ",", "\n", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", "[", "self", ".", "latest_task", "]", "[", "-", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger._report_task": [[68, 74], ["hook"], "methods", ["None"], ["", "def", "_report_task", "(", "self", ",", "hook", ")", ":", "\n", "        ", "initial_loss", "=", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", "[", "self", ".", "latest_task", "]", "[", "0", "]", "\n", "final_loss", "=", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", "[", "self", ".", "latest_task", "]", "[", "-", "1", "]", "\n", "hook", "(", "'\\tMetastep: {}, Task: {}, Initial Loss: {:.3f}, Final Loss: {:.3f}, Loss delta: {:.3f}'", ".", "format", "(", "\n", "self", ".", "latest_metastep", ",", "self", ".", "latest_task", ",", "\n", "initial_loss", ",", "final_loss", ",", "final_loss", "-", "initial_loss", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger._report_metastep": [[75, 82], ["metalogger.MetaLogger._losses[].values", "len", "hook", "metalogger.MetaLogger._losses[].keys"], "methods", ["None"], ["", "def", "_report_metastep", "(", "self", ",", "hook", ")", ":", "\n", "        ", "loss_total", "=", "0", "\n", "for", "task_loss", "in", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", ".", "values", "(", ")", ":", "\n", "            ", "loss_total", "+=", "task_loss", "[", "-", "1", "]", "\n", "", "num_tasks", "=", "len", "(", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", ".", "keys", "(", ")", ")", "\n", "mean_loss", "=", "loss_total", "/", "num_tasks", "\n", "hook", "(", "'Metastep: {}, Num tasks: {}, Mean Loss: {:.3f}'", ".", "format", "(", "self", ".", "latest_metastep", ",", "num_tasks", ",", "mean_loss", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.latest_metastep": [[83, 86], ["max", "metalogger.MetaLogger._losses.keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "latest_metastep", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "self", ".", "_losses", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.latest_task": [[87, 90], ["max", "metalogger.MetaLogger._losses[].keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "latest_task", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "self", ".", "_losses", "[", "self", ".", "latest_metastep", "]", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_loss": [[91, 100], ["[].append", "metalogger.MetaLogger._losses.keys", "metalogger.MetaLogger._losses[].keys"], "methods", ["None"], ["", "def", "log_loss", "(", "self", ",", "metastep", ",", "task", ",", "epoch", ",", "loss", ")", ":", "\n", "        ", "\"\"\"\n        Append loss to dictionary.\n        \"\"\"", "\n", "if", "metastep", "not", "in", "self", ".", "_losses", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_losses", "[", "metastep", "]", "=", "{", "}", "\n", "", "if", "task", "not", "in", "self", ".", "_losses", "[", "metastep", "]", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_losses", "[", "metastep", "]", "[", "task", "]", "=", "[", "]", "\n", "", "self", ".", "_losses", "[", "metastep", "]", "[", "task", "]", ".", "append", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_params": [[101, 114], ["net.params.items", "[].append", "v.data().copy().asnumpy", "metalogger.MetaLogger._parameters.keys", "metalogger.MetaLogger._parameters[].keys", "v.data().copy", "v.data"], "methods", ["None"], ["", "def", "log_params", "(", "self", ",", "metastep", ",", "task", ",", "epoch", ",", "net", ")", ":", "\n", "        ", "\"\"\"\n        Append parameters to dictionary.\n        \"\"\"", "\n", "parameters", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "net", ".", "params", ".", "items", "(", ")", ":", "\n", "            ", "parameters", "[", "k", "]", "=", "v", ".", "data", "(", ")", ".", "copy", "(", ")", ".", "asnumpy", "(", ")", "\n", "\n", "", "if", "metastep", "not", "in", "self", ".", "_parameters", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_parameters", "[", "metastep", "]", "=", "{", "}", "\n", "", "if", "task", "not", "in", "self", ".", "_parameters", "[", "metastep", "]", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_parameters", "[", "metastep", "]", "[", "task", "]", "=", "[", "]", "\n", "", "self", ".", "_parameters", "[", "metastep", "]", "[", "task", "]", ".", "append", "(", "parameters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_initial_params": [[115, 122], ["metalogger.MetaLogger.log_params", "metalogger.MetaLogger._parameters.keys"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_params"], ["", "def", "log_initial_params", "(", "self", ",", "ms", ",", "net", ")", ":", "\n", "        ", "\"\"\"\n        Log parameters before any updates made.\n        \"\"\"", "\n", "if", "ms", "in", "self", ".", "_parameters", ".", "keys", "(", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "log_params", "(", "ms", ",", "ALL", ",", "-", "1", ",", "net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.plot_losses": [[123, 142], ["matplotlib.subplots", "fig.suptitle", "range", "metalogger.MetaLogger._losses.keys", "ValueError", "axes[].set_title", "axes[].set_xlabel", "axes[].set_ylabel", "range", "metalogger.MetaLogger._losses[].keys", "axes[].plot", "axes[].text", "max", "metalogger.MetaLogger._losses.keys"], "methods", ["None"], ["", "def", "plot_losses", "(", "self", ",", "add_label", "=", "True", ",", "figsize", "=", "(", "20", ",", "4", ")", ")", ":", "\n", "        ", "\"\"\"\n        Plot the logged losses.\n        \"\"\"", "\n", "if", "self", ".", "_losses", "==", "{", "}", ":", "\n", "            ", "raise", "ValueError", "(", "'No losses logged.'", ")", "\n", "", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "ncols", "=", "self", ".", "num_tasks", ",", "figsize", "=", "figsize", ")", "\n", "fig", ".", "suptitle", "(", "'Losses'", ",", "fontsize", "=", "30", ",", "y", "=", "1.08", ")", "\n", "for", "task", "in", "range", "(", "self", ".", "num_tasks", ")", ":", "\n", "            ", "axes", "[", "task", "]", ".", "set_title", "(", "'Task {}'", ".", "format", "(", "task", ")", ")", "\n", "axes", "[", "task", "]", ".", "set_xlabel", "(", "'epoch'", ")", "\n", "axes", "[", "task", "]", ".", "set_ylabel", "(", "'loss'", ")", "\n", "", "for", "ms", "in", "self", ".", "_losses", ".", "keys", "(", ")", ":", "\n", "            ", "for", "task", "in", "range", "(", "self", ".", "num_tasks", ")", ":", "\n", "                ", "if", "task", "in", "self", ".", "_losses", "[", "ms", "]", ".", "keys", "(", ")", ":", "\n", "                    ", "alpha", "=", "1", "if", "ms", "==", "max", "(", "self", ".", "_losses", ".", "keys", "(", ")", ")", "else", "self", ".", "alpha_plot", "\n", "axes", "[", "task", "]", ".", "plot", "(", "self", ".", "_losses", "[", "ms", "]", "[", "task", "]", ",", "'o-'", ",", "alpha", "=", "alpha", ")", "\n", "if", "add_label", ":", "\n", "                        ", "axes", "[", "task", "]", ".", "text", "(", "x", "=", "0.05", ",", "y", "=", "self", ".", "_losses", "[", "ms", "]", "[", "task", "]", "[", "0", "]", ",", "s", "=", "ms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.plot_params": [[143, 181], ["matplotlib.subplots", "range", "fig.suptitle", "ValueError", "sorted", "axes[].legend", "axes[].set_title", "numpy.zeros", "enumerate", "axes[].imshow", "axes[].set_xlabel", "axes[].set_ylabel", "metalogger.MetaLogger._parameters.keys", "range", "axes[].get_xlim", "axes[].get_ylim", "numpy.linspace", "enumerate", "numpy.linspace", "loss_fn", "numpy.concatenate", "axes[].plot", "axes[].plot", "mxnet.nd.array", "metalogger.MetaLogger._parameters[].keys", "max", "metalogger.MetaLogger._parameters[].keys", "numpy.concatenate", "metalogger.MetaLogger._parameters.keys", "max", "max", "metalogger.MetaLogger._parameters.keys", "metalogger.MetaLogger._parameters.keys"], "methods", ["None"], ["", "", "", "", "", "def", "plot_params", "(", "self", ",", "param", ",", "W", ",", "loss_fn", ",", "figsize", "=", "(", "20", ",", "6", ")", ",", "gridsize", "=", "(", "100", ",", "100", ")", ",", "a", "=", "0.2", ",", "loss_samples", "=", "100", ")", ":", "\n", "        ", "\"\"\"\n        Plot the logged parameters.\n        \"\"\"", "\n", "if", "self", ".", "_parameters", "==", "{", "}", ":", "\n", "            ", "raise", "ValueError", "(", "'No parameters logged.'", ")", "\n", "", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "ncols", "=", "self", ".", "num_tasks", ",", "figsize", "=", "figsize", ")", "\n", "for", "surface", "in", "range", "(", "self", ".", "num_tasks", ")", ":", "\n", "            ", "for", "ms", "in", "sorted", "(", "self", ".", "_parameters", ".", "keys", "(", ")", ")", ":", "\n", "                ", "for", "task", "in", "range", "(", "self", ".", "num_tasks", ")", ":", "\n", "                    ", "if", "task", "in", "self", ".", "_parameters", "[", "ms", "]", ".", "keys", "(", ")", "or", "ms", "==", "max", "(", "self", ".", "_parameters", ".", "keys", "(", ")", ")", ":", "\n", "                        ", "temp_ms", "=", "ms", "\n", "while", "task", "not", "in", "self", ".", "_parameters", "[", "temp_ms", "]", ".", "keys", "(", ")", ":", "\n", "                            ", "temp_ms", "-=", "1", "\n", "", "x", "=", "np", ".", "concatenate", "(", "[", "p", "[", "param", "]", "for", "p", "in", "self", ".", "_parameters", "[", "temp_ms", "]", "[", "task", "]", "]", ")", "\n", "x", "=", "np", ".", "concatenate", "(", "[", "self", ".", "_parameters", "[", "temp_ms", "]", "[", "'all'", "]", "[", "0", "]", "[", "param", "]", ",", "x", "]", ")", ".", "T", "\n", "initial_point", "=", "self", ".", "_parameters", "[", "temp_ms", "]", "[", "'all'", "]", "[", "0", "]", "[", "param", "]", ".", "T", "\n", "\n", "assert", "x", ".", "shape", "[", "0", "]", "==", "2", ",", "'Dimension of parameter must be 2.'", "\n", "\n", "label", "=", "task", "if", "ms", "==", "max", "(", "self", ".", "_parameters", ".", "keys", "(", ")", ")", "else", "None", "\n", "alpha", "=", "1", "if", "ms", "==", "max", "(", "self", ".", "_parameters", ".", "keys", "(", ")", ")", "else", "self", ".", "alpha_plot", "\n", "color", "=", "'r'", "if", "surface", "==", "task", "else", "'k'", "\n", "axes", "[", "surface", "]", ".", "plot", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "'o-'", ",", "color", "=", "color", ",", "label", "=", "label", ",", "alpha", "=", "alpha", ")", "\n", "axes", "[", "surface", "]", ".", "plot", "(", "initial_point", "[", "0", "]", ",", "initial_point", "[", "1", "]", ",", "'o-'", ",", "color", "=", "'tab:pink'", ",", "alpha", "=", "alpha", ")", "\n", "", "", "", "axes", "[", "surface", "]", ".", "legend", "(", ")", "\n", "axes", "[", "surface", "]", ".", "set_title", "(", "'Loss surface for Task {}'", ".", "format", "(", "surface", ")", ")", "\n", "# Plot loss surface", "\n", "extent", "=", "axes", "[", "surface", "]", ".", "get_xlim", "(", ")", "+", "axes", "[", "surface", "]", ".", "get_ylim", "(", ")", "\n", "grid", "=", "np", ".", "zeros", "(", "gridsize", ")", "\n", "for", "i", ",", "w1", "in", "enumerate", "(", "np", ".", "linspace", "(", "extent", "[", "0", "]", ",", "extent", "[", "1", "]", ",", "gridsize", "[", "0", "]", ")", ")", ":", "\n", "                ", "for", "j", ",", "w2", "in", "enumerate", "(", "np", ".", "linspace", "(", "extent", "[", "2", "]", ",", "extent", "[", "3", "]", ",", "gridsize", "[", "1", "]", ")", ")", ":", "\n", "                    ", "grid", "[", "j", "]", "[", "i", "]", "=", "loss_fn", "(", "mx", ".", "nd", ".", "array", "(", "[", "w1", ",", "w2", "]", ")", ",", "W", "[", "surface", "]", ",", "loss_samples", ")", "\n", "", "", "axes", "[", "surface", "]", ".", "imshow", "(", "grid", ",", "extent", "=", "extent", ",", "origin", "=", "'lower'", ")", "\n", "# Set labels", "\n", "axes", "[", "surface", "]", ".", "set_xlabel", "(", "param", "+", "' 1'", ")", "\n", "axes", "[", "surface", "]", ".", "set_ylabel", "(", "param", "+", "' 2'", ")", "\n", "", "fig", ".", "suptitle", "(", "'Parameters'", ",", "fontsize", "=", "30", ",", "y", "=", "0.9", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.meta_repurposer.MetaRepurposer.__init__": [[28, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "input_model", ")", ":", "\n", "        ", "self", ".", "input_model", "=", "input_model", "\n", "self", ".", "output_model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.meta_repurposer.MetaRepurposer.repurpose": [[32, 41], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "repurpose", "(", "self", ",", "train_tasks", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Meta-learn parameters of the input model such that they are optimized for the provided train_tasks.\n\n        :param train_tasks: List of training tasks to use for meta-learning.\n        :type train_tasks: List of gluon data loaders #TODO: update syntax\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.__init__": [[39, 64], ["metalogger.MetaLogger", "mxnet.cpu"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "num_meta_steps", ",", "num_epochs", ",", "loss_class", "=", "gluon", ".", "loss", ".", "L2Loss", ",", "\n", "meta_optimizer", "=", "'sgd'", ",", "meta_optimizer_params", "=", "None", ",", "task_optimizer", "=", "'sgd'", ",", "task_optimizer_params", "=", "None", ",", "\n", "log_params", "=", "False", ",", "verbosity", "=", "1", ",", "context", "=", "None", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "meta_logger", "=", "MetaLogger", "(", ")", "\n", "\n", "self", ".", "num_meta_steps", "=", "num_meta_steps", "\n", "self", ".", "num_epochs", "=", "num_epochs", "\n", "\n", "self", ".", "context", "=", "context", "\n", "if", "self", ".", "context", "is", "None", ":", "\n", "            ", "self", ".", "context", "=", "mx", ".", "cpu", "(", ")", "\n", "\n", "", "self", ".", "loss_class", "=", "loss_class", "\n", "self", ".", "meta_optimizer", "=", "meta_optimizer", "\n", "self", ".", "meta_optimizer_params", "=", "meta_optimizer_params", "\n", "if", "self", ".", "meta_optimizer_params", "is", "None", ":", "\n", "            ", "self", ".", "meta_optimizer_params", "=", "DEFAULT_META_OPTIMIZER_PARAMS", "\n", "", "self", ".", "task_optimizer", "=", "task_optimizer", "\n", "self", ".", "task_optimizer_params", "=", "task_optimizer_params", "\n", "if", "self", ".", "task_optimizer_params", "is", "None", ":", "\n", "            ", "self", ".", "task_optimizer_params", "=", "DEFAULT_TASK_OPTIMIZER_PARAMS", "\n", "\n", "", "self", ".", "log_params", "=", "log_params", "\n", "self", ".", "verbosity", "=", "verbosity", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer._task_sampler": [[65, 93], ["len", "list", "range", "random.shuffle", "tasks.extend", "range", "len", "random.randint"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_task_sampler", "(", "train_tasks", ",", "meta_batch_size", ",", "with_replacement", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Tasks' meta-batch sampler\n\n        :param train_tasks: List of enumerated training tasks\n        :param meta_batch_size: Number of tasks per meta-batch\n        :param with_replacement: If True, sample tasks with replacement.\n        :return: List of sampled enumerated tasks\n        \"\"\"", "\n", "\n", "n_tasks", "=", "len", "(", "train_tasks", ")", "\n", "\n", "if", "n_tasks", "==", "1", ":", "\n", "            ", "tasks", "=", "train_tasks", "*", "meta_batch_size", "\n", "", "elif", "with_replacement", ":", "\n", "            ", "tasks", "=", "[", "train_tasks", "[", "random", ".", "randint", "(", "0", ",", "n_tasks", "-", "1", ")", "]", "for", "_", "in", "range", "(", "meta_batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "tasks", "=", "[", "]", "\n", "ix_tasks", "=", "list", "(", "range", "(", "n_tasks", ")", ")", "\n", "while", "True", ":", "\n", "                ", "random", ".", "shuffle", "(", "ix_tasks", ")", "\n", "tasks", ".", "extend", "(", "[", "train_tasks", "[", "i", "]", "for", "i", "in", "ix_tasks", "]", ")", "\n", "if", "len", "(", "tasks", ")", ">=", "meta_batch_size", ":", "\n", "                    ", "break", "\n", "", "", "tasks", "=", "tasks", "[", ":", "meta_batch_size", "]", "\n", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer.repurpose": [[94, 165], ["leap_meta_repurposer.LeapMetaRepurposer.loss_class", "leap.Leap.Leap", "mxnet.gluon.Trainer", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.reset", "list", "range", "leap.Leap.Leap.to", "list", "len", "enumerate", "leap_meta_repurposer.LeapMetaRepurposer._task_sampler", "leap.Leap.Leap.load", "mxnet.gluon.Trainer.step", "leap.Leap.Leap.zero", "leap.Leap.Leap.parameters", "leap.Leap.Leap.to", "leap.Leap.Leap.init_task", "mxnet.gluon.Trainer", "range", "leap.Leap.Leap.accumulate", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.report", "net.collect_params", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.log_initial_params", "enumerate", "loss_sequence.append", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.log_loss", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.report", "data.as_in_context.as_in_context.as_in_context", "label.as_in_context.as_in_context.as_in_context", "leap_meta_repurposer.LeapMetaRepurposer.backward", "leap.Leap.Leap.update", "mxnet.gluon.Trainer.step", "mxnet.nd.mean().asscalar", "len", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.log_params", "leap_meta_repurposer.LeapMetaRepurposer.meta_logger.report", "mxnet.autograd.record", "net", "leap_meta_repurposer.LeapMetaRepurposer.", "mxnet.nd.mean", "mxnet.nd.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap_meta_repurposer.LeapMetaRepurposer._task_sampler", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.zero", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.init_task", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.accumulate", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.report", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_initial_params", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_loss", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.report", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.log_params", "home.repos.pwc.inspect_result.amzn_xfer.leap.metalogger.MetaLogger.report"], ["", "def", "repurpose", "(", "self", ",", "train_tasks", ",", "meta_batch_size", "=", "None", ",", "with_replacement", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Meta-learn parameters of the input model such that they are optimized for the provided train_tasks.\n\n        :param train_tasks: List of all training tasks.\n        :param meta_batch_size: Number of tasks per meta-batch (size of train_tasks as default value).\n        :param with_replacement: If True, sample tasks with replacement.\n\n        \"\"\"", "\n", "\n", "loss_function", "=", "self", ".", "loss_class", "(", ")", "\n", "loss_sequence", "=", "[", "]", "\n", "\n", "net", "=", "self", ".", "model", "\n", "leap", "=", "Leap", "(", "net", ")", "\n", "meta_trainer", "=", "gluon", ".", "Trainer", "(", "list", "(", "leap", ".", "parameters", "(", ")", ")", ",", "self", ".", "meta_optimizer", ",", "self", ".", "meta_optimizer_params", ")", "\n", "\n", "self", ".", "meta_logger", ".", "reset", "(", ")", "\n", "\n", "if", "meta_batch_size", "is", "None", ":", "\n", "            ", "meta_batch_size", "=", "len", "(", "train_tasks", ")", "\n", "\n", "", "train_tasks", "=", "list", "(", "enumerate", "(", "train_tasks", ")", ")", "\n", "\n", "for", "ms", "in", "range", "(", "self", ".", "num_meta_steps", ")", ":", "\n", "\n", "            ", "batch_tasks", "=", "LeapMetaRepurposer", ".", "_task_sampler", "(", "train_tasks", ",", "meta_batch_size", ",", "with_replacement", ")", "\n", "for", "task", ",", "train_data", "in", "batch_tasks", ":", "\n", "\n", "                ", "leap", ".", "to", "(", "net", ")", "\n", "leap", ".", "init_task", "(", ")", "\n", "\n", "trainer", "=", "gluon", ".", "Trainer", "(", "net", ".", "collect_params", "(", ")", ",", "self", ".", "task_optimizer", ",", "self", ".", "task_optimizer_params", ")", "\n", "if", "self", ".", "log_params", ":", "\n", "                    ", "self", ".", "meta_logger", ".", "log_initial_params", "(", "ms", ",", "net", ")", "\n", "\n", "", "for", "e", "in", "range", "(", "self", ".", "num_epochs", ")", ":", "\n", "                    ", "num_examples", "=", "0", "\n", "cumulative_loss", "=", "0", "\n", "# Inner loop for training model for task", "\n", "for", "i", ",", "(", "data", ",", "label", ")", "in", "enumerate", "(", "train_data", ")", ":", "\n", "                        ", "if", "i", "==", "0", ":", "\n", "                            ", "batch_size", "=", "data", ".", "shape", "[", "0", "]", "\n", "", "data", "=", "data", ".", "as_in_context", "(", "self", ".", "context", ")", "\n", "label", "=", "label", ".", "as_in_context", "(", "self", ".", "context", ")", "\n", "with", "autograd", ".", "record", "(", ")", ":", "\n", "                            ", "output", "=", "net", "(", "data", ")", "\n", "loss", "=", "loss_function", "(", "output", ",", "label", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "leap", ".", "update", "(", "nd", ".", "mean", "(", "loss", ")", ",", "net", ")", "\n", "\n", "trainer", ".", "step", "(", "batch_size", ")", "\n", "cumulative_loss", "+=", "nd", ".", "mean", "(", "loss", ")", ".", "asscalar", "(", ")", "\n", "num_examples", "+=", "len", "(", "label", ")", "\n", "", "loss_sequence", ".", "append", "(", "cumulative_loss", ")", "\n", "self", ".", "meta_logger", ".", "log_loss", "(", "ms", ",", "task", ",", "e", ",", "cumulative_loss", "/", "num_examples", ")", "\n", "if", "self", ".", "log_params", ":", "\n", "                        ", "self", ".", "meta_logger", ".", "log_params", "(", "ms", ",", "task", ",", "e", ",", "net", ")", "\n", "", "if", "self", ".", "verbosity", ">", "2", ":", "\n", "                        ", "self", ".", "meta_logger", ".", "report", "(", "end", "=", "self", ".", "meta_logger", ".", "EPOCH", ",", "hook", "=", "print", ")", "\n", "", "", "leap", ".", "accumulate", "(", ")", "\n", "if", "self", ".", "verbosity", ">", "1", ":", "\n", "                    ", "self", ".", "meta_logger", ".", "report", "(", "end", "=", "self", ".", "meta_logger", ".", "TASK", ",", "hook", "=", "print", ")", "\n", "\n", "", "", "if", "self", ".", "verbosity", ">", "0", ":", "\n", "                ", "self", ".", "meta_logger", ".", "report", "(", "end", "=", "self", ".", "meta_logger", ".", "METASTEP", ",", "hook", "=", "print", ")", "\n", "", "leap", ".", "load", "(", ")", "\n", "meta_trainer", ".", "step", "(", "1", ")", "# 1 because we already normalised", "\n", "leap", ".", "zero", "(", ")", "\n", "\n", "", "leap", ".", "to", "(", "net", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.__init__": [[28, 63], ["mxnet.gluon.ParameterDict", "model.collect_params().items", "updaters.DefaultUpdater", "leap.Leap.zero", "leap.Leap.clear_acc", "leap.Leap.init_task", "mxnet.gluon.Parameter", "mxnet.gluon.Parameter.initialize", "mxnet.gluon.Parameter.set_data", "model.collect_params", "mxnet.init.Normal", "p.data", "p.data"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.zero", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.clear_acc", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.init_task", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["def", "__init__", "(", "self", ",", "model", ",", "norm", "=", "True", ",", "regularizer", "=", "True", ",", "loss", "=", "True", ")", ":", "\n", "        ", "self", ".", "norm", "=", "norm", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "regularizer", "=", "regularizer", "\n", "\n", "self", ".", "state", "=", "mx", ".", "gluon", ".", "ParameterDict", "(", ")", "\n", "for", "n", ",", "p", "in", "model", ".", "collect_params", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "q", "=", "mx", ".", "gluon", ".", "Parameter", "(", "\n", "p", ".", "name", ",", "\n", "p", ".", "grad_req", ",", "\n", "p", ".", "shape", ",", "\n", "p", ".", "dtype", ",", "\n", "p", ".", "lr_mult", ",", "\n", "p", ".", "wd_mult", ",", "\n", "p", ".", "_allow_deferred_init", ",", "\n", "p", ".", "_differentiable", ",", "\n", "p", ".", "_stype", "\n", ")", "\n", "q", ".", "initialize", "(", "mx", ".", "init", ".", "Normal", "(", "sigma", "=", "1.", ")", ",", "ctx", "=", "p", ".", "data", "(", ")", ".", "context", ")", "\n", "q", ".", "set_data", "(", "p", ".", "data", "(", ")", ")", "\n", "self", ".", "state", ".", "_params", "[", "n", "]", "=", "q", "\n", "\n", "", "self", ".", "_acc_counter", "=", "None", "\n", "self", ".", "_acc_state", "=", "None", "\n", "\n", "self", ".", "updater", "=", "DefaultUpdater", "(", "\n", "self", ".", "state", ",", "\n", "self", ".", "norm", ",", "\n", "self", ".", "regularizer", ",", "\n", "self", ".", "loss", "\n", ")", "\n", "\n", "self", ".", "zero", "(", ")", "\n", "self", ".", "clear_acc", "(", ")", "\n", "self", ".", "init_task", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.zero": [[64, 70], ["leap.Leap.parameters", "getattr", "p.data", "mxnet.nd.zeros().copyto", "p.grad", "mxnet.nd.zeros"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["", "def", "zero", "(", "self", ")", ":", "\n", "        ", "\"\"\"Zero out gradients tensors in state\"\"\"", "\n", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                ", "q", "=", "p", ".", "data", "(", ")", "\n", "mx", ".", "nd", ".", "zeros", "(", "q", ".", "shape", ",", "q", ".", "context", ",", "q", ".", "dtype", ",", "q", ".", "stype", ")", ".", "copyto", "(", "p", ".", "grad", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.clear_acc": [[71, 75], ["collections.OrderedDict", "leap.Leap.state.keys"], "methods", ["None"], ["", "", "", "def", "clear_acc", "(", "self", ")", ":", "\n", "        ", "\"\"\"Clear gradient accumulation state\"\"\"", "\n", "self", ".", "_acc_counter", "=", "0", "\n", "self", ".", "_acc_state", "=", "OrderedDict", "(", "[", "(", "n", ",", "None", ")", "for", "n", "in", "self", ".", "state", ".", "keys", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to": [[76, 89], ["collections.OrderedDict", "leap.Leap.state.items", "model.collect_params", "zip", "p.data().detach().copy", "model.collect_params.items", "collections.OrderedDict.items", "p.set_data", "getattr", "p.data().detach().copy.attach_grad", "q.detach", "p.data().detach", "p.data"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Transfer cloned state to model\"\"\"", "\n", "new_state", "=", "OrderedDict", "(", ")", "\n", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "            ", "d", "=", "p", ".", "data", "(", ")", ".", "detach", "(", ")", ".", "copy", "(", ")", "\n", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                ", "d", ".", "attach_grad", "(", ")", "\n", "", "new_state", "[", "n", "]", "=", "d", "\n", "\n", "", "mstate", "=", "model", ".", "collect_params", "(", ")", "\n", "for", "(", "n", ",", "p", ")", ",", "(", "m", ",", "q", ")", "in", "zip", "(", "mstate", ".", "items", "(", ")", ",", "new_state", ".", "items", "(", ")", ")", ":", "\n", "            ", "assert", "n", "==", "m", ",", "'incorrect parameter order: {} != {}'", ".", "format", "(", "n", ",", "m", ")", "\n", "p", ".", "set_data", "(", "q", ".", "detach", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.init_task": [[90, 93], ["leap.Leap.updater.initialize"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["", "", "def", "init_task", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize running variables\"\"\"", "\n", "self", ".", "updater", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset": [[94, 100], ["leap.Leap.updater.reset", "leap.Leap.clear_acc", "leap.Leap.init_task", "leap.Leap.zero"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.reset", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.clear_acc", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.init_task", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.zero"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reset all counters\"\"\"", "\n", "self", ".", "updater", ".", "reset", "(", ")", "\n", "self", ".", "clear_acc", "(", ")", "\n", "self", ".", "init_task", "(", ")", "\n", "self", ".", "zero", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.accumulate": [[101, 121], ["mxnet.autograd.pause", "leap.Leap.state.items", "p.data", "mxnet.nd.zeros", "getattr", "p.data().grad.detach", "p.data().detach", "leap.Leap.accumulate._acc"], "methods", ["None"], ["", "def", "accumulate", "(", "self", ")", ":", "\n", "        ", "\"\"\"Accumulate meta gradients across tasks\"\"\"", "\n", "self", ".", "_acc_counter", "+=", "1", "\n", "\n", "def", "_acc", "(", "n", ",", "p", ")", ":", "\n", "            ", "g", "=", "self", ".", "_acc_state", "[", "n", "]", "\n", "\n", "if", "g", "is", "None", ":", "\n", "                ", "q", "=", "p", ".", "data", "(", ")", "\n", "g", "=", "self", ".", "_acc_state", "[", "n", "]", "=", "mx", ".", "nd", ".", "zeros", "(", "\n", "q", ".", "shape", ",", "q", ".", "context", ",", "q", ".", "dtype", ",", "q", ".", "stype", ")", "\n", "\n", "", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                ", "g", "+=", "p", ".", "data", "(", ")", ".", "grad", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "                ", "g", "+=", "p", ".", "data", "(", ")", ".", "detach", "(", ")", "\n", "\n", "", "", "with", "mx", ".", "autograd", ".", "pause", "(", ")", ":", "\n", "            ", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "                ", "_acc", "(", "n", ",", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load": [[122, 137], ["mxnet.autograd.pause", "leap.Leap.state.items", "getattr", "g.copyto", "g.copyto", "p.data", "leap.Leap.load._load"], "methods", ["None"], ["", "", "", "def", "load", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load accumulated meta gradients and buffers into aggregate meta gradient\"\"\"", "\n", "\n", "def", "_load", "(", "n", ",", "p", ")", ":", "\n", "            ", "g", "=", "self", ".", "_acc_state", "[", "n", "]", "\n", "g", "/=", "self", ".", "_acc_counter", "\n", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                ", "g", ".", "copyto", "(", "p", ".", "data", "(", ")", ".", "grad", ")", "\n", "", "else", ":", "\n", "                ", "g", ".", "copyto", "(", "p", ".", "data", "(", ")", ")", "\n", "", "p", ".", "data", "(", ")", ".", "_fresh_grad", "=", "True", "\n", "\n", "", "with", "mx", ".", "autograd", ".", "pause", "(", ")", ":", "\n", "            ", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "                ", "_load", "(", "n", ",", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.update": [[138, 143], ["loss.detach().copy", "leap.Leap.updater", "p.data", "model.collect_params().items", "loss.detach", "model.collect_params"], "methods", ["None"], ["", "", "", "def", "update", "(", "self", ",", "loss", ",", "model", ",", "hook", "=", "None", ")", ":", "\n", "        ", "\"\"\"Increment meta gradient given current task\"\"\"", "\n", "curr_state", "=", "{", "n", ":", "p", ".", "data", "(", ")", "for", "n", ",", "p", "in", "model", ".", "collect_params", "(", ")", ".", "items", "(", ")", "}", "\n", "curr_loss", "=", "loss", ".", "detach", "(", ")", ".", "copy", "(", ")", "\n", "self", ".", "updater", "(", "curr_loss", ",", "curr_state", ",", "hook", "=", "hook", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.named_parameters": [[144, 149], ["leap.Leap.state.items", "getattr"], "methods", ["None"], ["", "def", "named_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Iterator named parameters\"\"\"", "\n", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "            ", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                ", "yield", "n", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters": [[150, 154], ["leap.Leap.named_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.named_parameters"], ["", "", "", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Iterator over parameters\"\"\"", "\n", "for", "_", ",", "p", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "yield", "p", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic.__init__": [[27, 80], ["random.seed", "synthetic_data.MetaTaskSynthetic._generate_parameters", "synthetic_data.MetaTaskSynthetic._validate_parameters", "data.MetaTaskDataContainer.__init__", "mxnet.cpu", "synthetic_data.TaskSynthetic", "synthetic_data.TaskSynthetic", "synthetic_data.TaskSynthetic", "numpy.arange", "numpy.arange", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic._generate_parameters", "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic._validate_parameters", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", "=", "None", ",", "weights", "=", "None", ",", "bias", "=", "None", ",", "seed", "=", "1", ",", "context", "=", "None", ")", ":", "\n", "\n", "        ", "\"\"\"\n        :param config: If None, DEFAULT_CONFIG_SYNTHETIC is loaded.\n        :param weights: Tasks' weights matrix. Row k corresponds to the weight parameters of task k. If None, w is\n            sampled from a N(0,1).\n        :param bias: Tasks' biases vector. Row k corresponds to the bias parameters of task k. If None, w is sampled\n            from a N(0,1).\n        :param seed: Seed for random generator.\n        \"\"\"", "\n", "\n", "if", "config", "is", "None", ":", "\n", "            ", "config", "=", "DEFAULT_CONFIG_SYNTHETIC", "\n", "\n", "", "self", ".", "config", "=", "config", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "bias", "=", "bias", "\n", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "mxnet", ".", "cpu", "(", ")", "\n", "", "self", ".", "context", "=", "context", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "num_tasks_train", "=", "config", "[", "\"num_tasks_train\"", "]", "\n", "num_tasks_test", "=", "config", "[", "\"num_tasks_test\"", "]", "\n", "num_tasks_val", "=", "config", "[", "\"num_tasks_val\"", "]", "\n", "num_tasks", "=", "num_tasks_train", "+", "num_tasks_test", "+", "num_tasks_val", "\n", "\n", "self", ".", "num_tasks", "=", "num_tasks", "\n", "\n", "self", ".", "_generate_parameters", "(", ")", "\n", "self", ".", "_validate_parameters", "(", ")", "\n", "\n", "num_examples", "=", "config", "[", "\"num_examples_per_task\"", "]", "\n", "std_x", "=", "config", "[", "\"std_x\"", "]", "\n", "hold_out", "=", "config", "[", "\"hold_out\"", "]", "\n", "noise", "=", "config", "[", "\"std_noise\"", "]", "\n", "\n", "# Generate the training/test/val dataset.", "\n", "# Each dataset is a list of TaskSynthetic objects (one per task)", "\n", "data_train", "=", "[", "TaskSynthetic", "(", "self", ".", "weights", "[", "t", ",", ":", "]", ",", "self", ".", "bias", "[", "t", "]", ",", "num_examples", ",", "std_x", ",", "noise", ",", "hold_out", ",", "\n", "context", "=", "context", ")", "\n", "for", "t", "in", "np", ".", "arange", "(", "0", ",", "num_tasks_train", ")", "]", "\n", "data_test", "=", "[", "TaskSynthetic", "(", "self", ".", "weights", "[", "t", ",", ":", "]", ",", "self", ".", "bias", "[", "t", "]", ",", "num_examples", ",", "std_x", ",", "noise", ",", "hold_out", ",", "\n", "context", "=", "context", ")", "\n", "for", "t", "in", "np", ".", "arange", "(", "num_tasks_train", ",", "num_tasks_train", "+", "num_tasks_test", ")", "]", "\n", "data_val", "=", "[", "TaskSynthetic", "(", "self", ".", "weights", "[", "t", ",", ":", "]", ",", "self", ".", "bias", "[", "t", "]", ",", "num_examples", ",", "std_x", ",", "noise", ",", "hold_out", ",", "\n", "context", "=", "context", ")", "\n", "for", "t", "in", "np", ".", "arange", "(", "num_tasks_train", "+", "num_tasks_test", ",", "num_tasks", ")", "]", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "data_train", ",", "data_test", ",", "data_val", ",", "context", "=", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic.plot_sample": [[81, 117], ["synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "ValueError", "os.path.exists", "os.makedirs", "os.path.join", "os.path.join", "os.path.join", "synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "synthetic_data.MetaTaskSynthetic._plot", "synthetic_data.MetaTaskSynthetic.savefig", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot"], ["", "def", "plot_sample", "(", "self", ",", "root", "=", "\"./sample_synth\"", ")", ":", "\n", "\n", "        ", "\"\"\"Plot N images from each alphabet and store the images in root.\"\"\"", "\n", "\n", "if", "self", ".", "weights", ".", "shape", "[", "1", "]", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only 2D datasets can be plot.\"", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "root", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "root", ")", "\n", "\n", "", "fig_train", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "train_tasks", "]", ",", "\n", "\"Training Samples for Training Tasks\"", ")", "\n", "fig_train", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_train_tasks.png\"", ")", ")", "\n", "del", "fig_train", "\n", "fig_test", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "test_tasks", "]", ",", "\n", "\"Training Samples for Test Tasks\"", ")", "\n", "fig_test", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_test_tasks.png\"", ")", ")", "\n", "del", "fig_test", "\n", "fig_val", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "val_tasks", "]", ",", "\n", "\"Training Samples for Validation Tasks\"", ")", "\n", "fig_val", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_val_tasks.png\"", ")", ")", "\n", "del", "fig_val", "\n", "\n", "if", "self", ".", "config", "[", "\"hold_out\"", "]", ">", "0", ":", "\n", "            ", "fig_train", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "train_tasks", "]", ",", "\n", "\"Validation Samples for Training Tasks\"", ")", "\n", "fig_train", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_train_tasks.png\"", ")", ")", "\n", "del", "fig_train", "\n", "fig_test", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "test_tasks", "]", ",", "\n", "\"Validation Samples for Test Tasks\"", ")", "\n", "fig_test", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_test_tasks.png\"", ")", ")", "\n", "del", "fig_test", "\n", "fig_val", "=", "self", ".", "_plot", "(", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "val_tasks", "]", ",", "\n", "\"Validation Samples for Validation Tasks\"", ")", "\n", "fig_val", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_val_tasks.png\"", ")", ")", "\n", "del", "fig_val", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic._plot": [[118, 132], ["len", "matplotlib.subplots", "fig.subplots_adjust", "range", "fig.suptitle", "X.asnumpy.asnumpy.asnumpy", "y.asnumpy.asnumpy.asnumpy", "ax[].scatter", "y.asnumpy.asnumpy.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.utils.flatten"], ["", "", "def", "_plot", "(", "self", ",", "data", ",", "title", ")", ":", "\n", "\n", "        ", "\"\"\"Helper function for plotting.\"\"\"", "\n", "\n", "num_tasks", "=", "len", "(", "data", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "num_tasks", ",", "figsize", "=", "(", "num_tasks", "*", "5", ",", "5", ")", ")", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "None", ",", "bottom", "=", "None", ",", "right", "=", "None", ",", "top", "=", "None", ",", "wspace", "=", "0.5", ",", "hspace", "=", "0.5", ")", "\n", "for", "mm", "in", "range", "(", "num_tasks", ")", ":", "\n", "            ", "X", ",", "y", "=", "data", "[", "mm", "]", "[", ":", "]", "\n", "X", "=", "X", ".", "asnumpy", "(", ")", "\n", "y", "=", "y", ".", "asnumpy", "(", ")", "\n", "ax", "[", "mm", "]", ".", "scatter", "(", "X", "[", ":", ",", "0", "]", ",", "X", "[", ":", ",", "1", "]", ",", "c", "=", "y", ".", "flatten", "(", ")", ")", "\n", "", "fig", ".", "suptitle", "(", "title", ",", "size", "=", "18", ")", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic._validate_parameters": [[133, 139], ["ValueError", "len", "ValueError"], "methods", ["None"], ["", "def", "_validate_parameters", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "weights", ".", "shape", "[", "0", "]", "!=", "self", ".", "num_tasks", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of rows in w must be equal to the total number of tasks\"", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "bias", ")", "!=", "self", ".", "num_tasks", ":", "\n", "            ", "raise", "ValueError", "(", "\"Length of b must be equal to the total number of tasks\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.MetaTaskSynthetic._generate_parameters": [[140, 151], ["mxnet.nd.random_normal", "mxnet.nd.random_normal", "mxnet.nd.zeros"], "methods", ["None"], ["", "", "def", "_generate_parameters", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "weights", "is", "None", ":", "\n", "            ", "dim", "=", "self", ".", "config", "[", "\"dim\"", "]", "\n", "self", ".", "weights", "=", "self", ".", "config", "[", "\"global_bias\"", "]", "+", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "(", "self", ".", "num_tasks", ",", "dim", ")", ",", "\n", "ctx", "=", "self", ".", "context", ")", "\n", "\n", "", "if", "self", ".", "bias", "is", "None", ":", "\n", "            ", "if", "self", ".", "config", "[", "\"task_bias\"", "]", ":", "\n", "                ", "self", ".", "bias", "=", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "self", ".", "num_tasks", ",", "ctx", "=", "self", ".", "context", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "bias", "=", "mxnet", ".", "nd", ".", "zeros", "(", "num_tasks", ",", "ctx", "=", "self", ".", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.TaskSynthetic.__init__": [[159, 194], ["data.TaskDataContainer.__init__", "mxnet.cpu", "random.seed", "synthetic_data.TaskSynthetic._real_fn", "mxnet.gluon.data.ArrayDataset", "synthetic_data.TaskSynthetic._real_fn", "mxnet.gluon.data.ArrayDataset", "synthetic_data.TaskSynthetic._real_fn", "mxnet.gluon.data.ArrayDataset", "mxnet.nd.random_normal", "mxnet.nd.random_normal", "mxnet.nd.random_normal", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.TaskSynthetic._real_fn", "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.TaskSynthetic._real_fn", "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.TaskSynthetic._real_fn"], ["def", "__init__", "(", "self", ",", "w", ",", "b", ",", "num_examples", ",", "std_x", ",", "noise", ",", "hold_out", "=", "None", ",", "seed", "=", "None", ",", "context", "=", "None", ")", ":", "\n", "\n", "        ", "\"\"\"\n        :param w: Task's weights vector.\n        :param b: Task's bias.\n        :param num_examples: Total number of examples per task.\n        :param std_x: The covariates are sampled from a zero mean normal distribution with\n            standard deviation equal to std_x.\n        :param hold_out: Number of examples to hold out for validation\n        :param seed: seed for the random generator\n        \"\"\"", "\n", "\n", "self", ".", "w", "=", "w", "\n", "self", ".", "b", "=", "b", "\n", "self", ".", "num_examples", "=", "num_examples", "\n", "self", ".", "seed", "=", "seed", "\n", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "mxnet", ".", "cpu", "(", ")", "\n", "", "self", ".", "context", "=", "context", "\n", "\n", "if", "seed", ":", "\n", "            ", "random", ".", "seed", "(", "seed", ")", "\n", "", "if", "hold_out", "and", "hold_out", "<", "num_examples", ":", "\n", "            ", "Xtr", ",", "Ytr", "=", "self", ".", "_real_fn", "(", "std_x", "*", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "(", "num_examples", "-", "hold_out", ",", "len", "(", "w", ")", ")", ",", "\n", "ctx", "=", "context", ")", ",", "noise", ")", "\n", "train_dataset", "=", "ArrayDataset", "(", "Xtr", ",", "Ytr", ")", "\n", "Xval", ",", "Yval", "=", "self", ".", "_real_fn", "(", "std_x", "*", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "(", "hold_out", ",", "len", "(", "w", ")", ")", ",", "ctx", "=", "context", ")", ",", "noise", ")", "\n", "val_dataset", "=", "ArrayDataset", "(", "Xval", ",", "Yval", ")", "\n", "", "else", ":", "\n", "            ", "Xtr", ",", "Ytr", "=", "self", ".", "_real_fn", "(", "std_x", "*", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "(", "num_examples", ",", "len", "(", "w", ")", ")", ",", "ctx", "=", "context", ")", ",", "noise", ")", "\n", "train_dataset", "=", "ArrayDataset", "(", "Xtr", ",", "Ytr", ")", "\n", "val_dataset", "=", "None", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "train_dataset", ",", "val_dataset", ",", "context", "=", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.synthetic_data.TaskSynthetic._real_fn": [[195, 200], ["mxnet.nd.dot", "mxnet.nd.expand_dims", "mxnet.nd.expand_dims", "mxnet.nd.random_normal"], "methods", ["None"], ["", "def", "_real_fn", "(", "self", ",", "X", ",", "noise", ")", ":", "\n", "        ", "y", "=", "mxnet", ".", "nd", ".", "dot", "(", "X", ",", "mxnet", ".", "nd", ".", "expand_dims", "(", "self", ".", "w", ",", "axis", "=", "1", ")", ")", "+", "self", ".", "b", "\n", "if", "noise", ">", "0.0", ":", "\n", "            ", "y", "+=", "mxnet", ".", "nd", ".", "expand_dims", "(", "noise", "*", "mxnet", ".", "nd", ".", "random_normal", "(", "shape", "=", "(", "X", ".", "shape", "[", "0", "]", ",", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer.__init__": [[22, 27], ["mxnet.cpu"], "methods", ["None"], ["\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer.get_train_tasks_iterators": [[28, 30], ["data.MetaTaskDataContainer._get_tasks_iterators"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer._get_tasks_iterators"], ["np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "idx", "=", "np", ".", "random", ".", "permutation", "(", "range", "(", "len", "(", "train_inputs", ")", ")", ")", "[", ":", "n_samp", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer.get_val_tasks_iterators": [[31, 33], ["data.MetaTaskDataContainer._get_tasks_iterators"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer._get_tasks_iterators"], ["return", "train_inputs", "[", "idx", "]", ",", "train_targets", "[", "idx", "]", ",", "train_targets_var", "[", "idx", "]", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer.get_test_tasks_iterators": [[34, 36], ["data.MetaTaskDataContainer._get_tasks_iterators"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer._get_tasks_iterators"], ["", "def", "unitize", "(", "x", ")", ":", "\n", "    ", "\"\"\"Puts design space on a unit cube\"\"\"", "\n", "x1", "=", "x", "-", "x", ".", "min", "(", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.MetaTaskDataContainer._get_tasks_iterators": [[37, 42], ["tt.get_train_iterator", "tt.get_val_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_train_iterator", "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_val_iterator"], ["return", "x1", "/", "x1", ".", "max", "(", ")", "\n", "\n", "\n", "", "def", "generate_data", "(", "\n", "nsamples", "=", "2000", ",", "train_year", "=", "2012", ",", "test_year", "=", "2016", ",", "grid_size", "=", "200", ",", "seed", "=", "110", ",", "hdf_loc", "=", "None", "\n", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.__init__": [[45, 49], ["mxnet.cpu"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_train_val_iterators": [[50, 54], ["data.TaskDataContainer.get_train_iterator", "data.TaskDataContainer.get_val_iterator"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_train_iterator", "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_val_iterator"], ["\n", "\n", "df", "=", "pd", ".", "read_hdf", "(", "hdf_loc", ",", "\"full\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_train_iterator": [[56, 58], ["mxnet.gluon.data.DataLoader"], "methods", ["None"], ["is_ng", "=", "torch", ".", "from_numpy", "(", "df", "[", "\"is_ng\"", "]", ".", "values", ")", ".", "bool", "(", ")", "\n", "is_test", "=", "torch", ".", "from_numpy", "(", "(", "df", "[", "\"year\"", "]", "==", "test_year", ")", ".", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.data.TaskDataContainer.get_val_iterator": [[59, 64], ["mxnet.gluon.data.DataLoader"], "methods", ["None"], ["all_x", "=", "torch", ".", "from_numpy", "(", "df", "[", "[", "\"longitude\"", ",", "\"latitude\"", ",", "\"year\"", "]", "]", ".", "values", ")", ".", "float", "(", ")", "\n", "lon_lims", "=", "(", "all_x", "[", ":", ",", "0", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "0", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "lat_lims", "=", "(", "all_x", "[", ":", ",", "1", "]", ".", "min", "(", ")", ".", "item", "(", ")", ",", "all_x", "[", ":", ",", "1", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "extent", "=", "lon_lims", "+", "lat_lims", "\n", "\n", "all_x", "[", ":", ",", "0", "]", "=", "unitize", "(", "all_x", "[", ":", ",", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot.__init__": [[31, 91], ["onmiglot.MetaTaskOmniglot.download_dataset", "random.seed", "os.path.join", "onmiglot.MetaTaskOmniglot._init_train_test_val_alphabets", "data.MetaTaskDataContainer.__init__", "mxnet.cpu", "os.path.join", "os.path.join", "onmiglot.TaskOmniglot", "onmiglot.TaskOmniglot", "onmiglot.TaskOmniglot"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot.download_dataset", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._init_train_test_val_alphabets", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", "=", "\"./data\"", ",", "num_classes", "=", "None", ",", "\n", "config", "=", "None", ",", "seed", "=", "1", ",", "context", "=", "None", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Onmiglot Data Container for Meta-Learning\n\n        :param root: path containing the onmiglot dataset (if it does not exists, it\n            download the data into this directory.\n        :param num_classes: If not None, only those alphabet with at least num_classes\n            are taken into consideration.\n        :param config: If None, DEFAULT_CONFIG is loaded.\n        :param seed: seed for random generator.\n        \"\"\"", "\n", "\n", "if", "config", "is", "None", ":", "\n", "            ", "self", ".", "config", "=", "DEFAULT_CONFIG_OMNIGLOT", "\n", "\n", "", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "mxnet", ".", "cpu", "(", ")", "\n", "", "self", ".", "context", "=", "context", "\n", "\n", "self", ".", "url_dir", "=", "'https://github.com/brendenlake/omniglot/raw/master/python/'", "\n", "self", ".", "urls", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "url_dir", ",", "\"images_background.zip\"", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "url_dir", ",", "\"images_evaluation.zip\"", ")", "\n", "]", "\n", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "target_folder", "=", "\"images_resized\"", "\n", "\n", "self", ".", "download_dataset", "(", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "self", ".", "alphabets", "=", "[", "]", "\n", "self", ".", "alphabets_train", "=", "[", "]", "\n", "self", ".", "alphabets_test", "=", "[", "]", "\n", "self", ".", "alphabets_val", "=", "[", "]", "\n", "\n", "self", ".", "target_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "target_folder", ")", "\n", "\n", "self", ".", "_init_train_test_val_alphabets", "(", ")", "\n", "\n", "hold", "=", "self", ".", "config", "[", "\"hold_out\"", "]", "\n", "transform_image", "=", "self", ".", "config", "[", "\"transform_image\"", "]", "\n", "transform_mxnet", "=", "self", ".", "config", "[", "\"transform_mxnet\"", "]", "\n", "\n", "# Generate the training/test/val dataset.", "\n", "# Each dataset is a list of SubOmniglot objects (one per task)", "\n", "data_train", "=", "[", "TaskOmniglot", "(", "self", ".", "target_path", ",", "[", "a", "]", ",", "num_classes", ",", "hold", ",", "transform_image", "=", "transform_image", ",", "\n", "transform_mxnet", "=", "transform_mxnet", ",", "context", "=", "context", ")", "for", "a", "in", "self", ".", "alphabets_train", "]", "\n", "data_test", "=", "[", "TaskOmniglot", "(", "self", ".", "target_path", ",", "[", "a", "]", ",", "num_classes", ",", "hold", ",", "transform_image", "=", "transform_image", ",", "\n", "transform_mxnet", "=", "transform_mxnet", ",", "context", "=", "context", ")", "for", "a", "in", "self", ".", "alphabets_test", "]", "\n", "data_val", "=", "[", "TaskOmniglot", "(", "self", ".", "target_path", ",", "[", "a", "]", ",", "num_classes", ",", "hold", ",", "transform_image", "=", "transform_image", ",", "\n", "transform_mxnet", "=", "transform_mxnet", ",", "context", "=", "context", ")", "for", "a", "in", "self", ".", "alphabets_val", "]", "\n", "\n", "super", "(", "MetaTaskOmniglot", ",", "self", ")", ".", "__init__", "(", "data_train", ",", "data_test", ",", "data_val", ",", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._init_train_test_val_alphabets": [[92, 115], ["list", "random.shuffle", "utils.list_dirs", "len", "len", "onmiglot.MetaTaskOmniglot.alphabets.append", "list", "utils.list_dirs", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_dirs", "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_dirs"], ["", "def", "_init_train_test_val_alphabets", "(", "self", ")", ":", "\n", "\n", "        ", "trs", "=", "self", ".", "config", "[", "\"num_tasks_train\"", "]", "\n", "tes", "=", "self", ".", "config", "[", "\"num_tasks_test\"", "]", "\n", "val", "=", "self", ".", "config", "[", "\"num_tasks_val\"", "]", "\n", "\n", "# Filter out alphabet with less than num_classes, and shuffle", "\n", "self", ".", "alphabets", "=", "list", "(", "list_dirs", "(", "self", ".", "target_path", ")", ")", "\n", "if", "self", ".", "num_classes", ":", "\n", "            ", "self", ".", "alphabets", "=", "[", "]", "\n", "for", "a", "in", "self", ".", "alphabets", ":", "\n", "                ", "if", "len", "(", "list", "(", "list_dirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "target_path", ",", "a", ")", ")", ")", ")", ">=", "self", ".", "num_classes", ":", "\n", "                    ", "self", ".", "alphabets", ".", "append", "(", "a", ")", "\n", "", "", "assert", "trs", "+", "tes", "<", "len", "(", "self", ".", "alphabets", ")", ",", "'cannot create test set'", "\n", "", "random", ".", "shuffle", "(", "self", ".", "alphabets", ")", "\n", "\n", "# init train/test/val alphabets", "\n", "self", ".", "alphabets_train", "=", "self", ".", "alphabets", "[", ":", "trs", "]", "\n", "self", ".", "alphabets_test", "=", "self", ".", "alphabets", "[", "trs", ":", "trs", "+", "tes", "]", "\n", "if", "val", "is", "not", "None", ":", "\n", "            ", "self", ".", "alphabets_val", "=", "self", ".", "alphabets", "[", "trs", "+", "tes", ":", "trs", "+", "tes", "+", "val", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "alphabets_val", "=", "self", ".", "alphabets", "[", "trs", "+", "tes", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._copy_to_target": [[116, 120], ["os.path.abspath", "os.listdir", "os.path.join", "utils.copy_dir", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.copy_dir"], ["", "", "def", "_copy_to_target", "(", "self", ",", "path_origin", ")", ":", "\n", "        ", "out_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "target_folder", ")", ")", "\n", "for", "alphabet", "in", "os", ".", "listdir", "(", "path_origin", ")", ":", "\n", "            ", "copy_dir", "(", "os", ".", "path", ".", "join", "(", "path_origin", ",", "alphabet", ")", ",", "os", ".", "path", ".", "join", "(", "out_path", ",", "alphabet", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._resize": [[121, 123], ["utils.resize_imgs", "os.path.abspath", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.resize_imgs"], ["", "", "def", "_resize", "(", "self", ")", ":", "\n", "        ", "resize_imgs", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "target_folder", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot.download_dataset": [[124, 146], ["os.path.exists", "os.makedirs", "os.path.join", "url.split", "os.path.exists", "utils.download_url", "onmiglot.MetaTaskOmniglot._copy_to_target", "onmiglot.MetaTaskOmniglot._resize", "zipfile.ZipFile", "zip_file.extractall", "os.path.abspath().split", "os.path.dirname", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.download_url", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._copy_to_target", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._resize"], ["", "def", "download_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Helper function to download Onmiglot\n\n        It download  both files, images_background.zip and images_evaluation, extract and extract\n        them in self.target_path. It finally resizes all the image to 28X28 px.\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "root", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "root", ")", "\n", "\n", "", "for", "url", "in", "self", ".", "urls", ":", "\n", "            ", "file_name", "=", "url", ".", "split", "(", "os", ".", "sep", ")", "[", "-", "1", "]", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "file_name", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_file", ")", ":", "\n", "                ", "out_file", "=", "download_url", "(", "url", ",", "out_file", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "out_file", ",", "\"r\"", ")", "as", "zip_file", ":", "\n", "                    ", "zip_file", ".", "extractall", "(", "os", ".", "path", ".", "dirname", "(", "out_file", ")", ")", "\n", "\n", "", "dir_images", "=", "os", ".", "path", ".", "abspath", "(", "out_file", ")", ".", "split", "(", "\".\"", ")", "[", "-", "2", "]", "\n", "self", ".", "_copy_to_target", "(", "dir_images", ")", "\n", "self", ".", "_resize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot.plot_sample": [[147, 178], ["onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "onmiglot.MetaTaskOmniglot._plot", "onmiglot.MetaTaskOmniglot.savefig", "os.path.exists", "os.makedirs", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot", "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot"], ["", "", "", "def", "plot_sample", "(", "self", ",", "num_samples", ",", "root", "=", "\"./sample_onmiglot\"", ")", ":", "\n", "\n", "        ", "\"\"\"Plot N images from each alphabet and store the images in root.\"\"\"", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "root", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "root", ")", "\n", "\n", "", "fig_train", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "train_tasks", "]", ",", "\n", "\"Training Samples for Training Tasks\"", ")", "\n", "fig_train", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_train_tasks.png\"", ")", ")", "\n", "del", "fig_train", "\n", "fig_test", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "test_tasks", "]", ",", "\n", "\"Training Samples for Test Tasks\"", ")", "\n", "fig_test", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_test_tasks.png\"", ")", ")", "\n", "del", "fig_test", "\n", "fig_val", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_train_dataset", "for", "dd", "in", "self", ".", "val_tasks", "]", ",", "\n", "\"Training Samples for Validation Tasks\"", ")", "\n", "fig_val", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_train_val_tasks.png\"", ")", ")", "\n", "del", "fig_val", "\n", "fig_train", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "train_tasks", "]", ",", "\n", "\"Validation Samples for Training Tasks\"", ")", "\n", "fig_train", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_train_tasks.png\"", ")", ")", "\n", "del", "fig_train", "\n", "fig_test", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "test_tasks", "]", ",", "\n", "\"Validation Samples for Test Tasks\"", ")", "\n", "fig_test", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_test_tasks.png\"", ")", ")", "\n", "del", "fig_test", "\n", "fig_val", "=", "self", ".", "_plot", "(", "num_samples", ",", "[", "dd", ".", "_val_dataset", "for", "dd", "in", "self", ".", "val_tasks", "]", ",", "\n", "\"Validation Samples for Validation Tasks\"", ")", "\n", "fig_val", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root", ",", "\"sample_val_val_tasks.png\"", ")", ")", "\n", "del", "fig_val", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.MetaTaskOmniglot._plot": [[179, 195], ["len", "matplotlib.subplots", "fig.subplots_adjust", "range", "fig.suptitle", "numpy.random.permutation", "range", "len", "ax[].imshow", "ax[].set_title", "ax[].axis", "im.asnumpy", "[].split"], "methods", ["None"], ["", "def", "_plot", "(", "self", ",", "num_samples", ",", "data", ",", "title", ")", ":", "\n", "\n", "        ", "\"\"\"Helper function for plotting.\"\"\"", "\n", "\n", "num_alphabets", "=", "len", "(", "data", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "num_alphabets", ",", "num_samples", ",", "figsize", "=", "(", "2", "*", "num_samples", ",", "2", "*", "num_alphabets", ")", ")", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "None", ",", "bottom", "=", "None", ",", "right", "=", "None", ",", "top", "=", "None", ",", "wspace", "=", "0.5", ",", "hspace", "=", "0.5", ")", "\n", "for", "mm", "in", "range", "(", "num_alphabets", ")", ":", "\n", "            ", "ix_perm", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "data", "[", "mm", "]", ")", ")", "\n", "for", "nn", "in", "range", "(", "num_samples", ")", ":", "\n", "                ", "im", ",", "label", "=", "data", "[", "mm", "]", "[", "ix_perm", "[", "nn", "]", "]", "\n", "ax", "[", "mm", ",", "nn", "]", ".", "imshow", "(", "im", ".", "asnumpy", "(", ")", ")", "\n", "ax", "[", "mm", ",", "nn", "]", ".", "set_title", "(", "\"Label: {} \\n ({})\"", ".", "format", "(", "label", ",", "data", "[", "mm", "]", ".", "items", "[", "nn", "]", "[", "0", "]", ".", "split", "(", "\"/\"", ")", "[", "-", "3", "]", "[", "0", ":", "5", "]", ")", ")", "\n", "ax", "[", "mm", ",", "nn", "]", ".", "axis", "(", "\"off\"", ")", "\n", "", "", "fig", ".", "suptitle", "(", "title", ",", "size", "=", "18", ")", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.TaskOmniglot.__init__": [[204, 272], ["sum", "random.shuffle", "enumerate", "sum", "sum", "onmiglot.ImageListDataset", "data.TaskDataContainer.__init__", "mxnet.cpu", "random.seed", "enumerate", "onmiglot.TaskOmniglot._train_character_images.append", "onmiglot.TaskOmniglot._val_character_images.append", "len", "onmiglot.ImageListDataset", "utils.list_dirs", "utils.list_files", "os.path.join", "os.path.join", "val_characters.append", "train_characters.append", "utils.list_dirs", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_dirs", "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_files", "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_dirs"], ["def", "__init__", "(", "self", ",", "path", ",", "alphabets", ",", "num_classes", "=", "None", ",", "hold_out", "=", "None", ",", "\n", "transform_image", "=", "None", ",", "transform_mxnet", "=", "None", ",", "seed", "=", "None", ",", "context", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param path: Root path\n        :param alphabets: Alphabet to be considered for the task\n        :param num_classes: Number of classes/characters per alphabet\n        :param hold_out: Number of images to hold out for validation\n        :param transform_image: Applied to the PIL image (before loading it in an mx.ndarray)\n        :param transform_mxnet: Applied to the mx.ndarray when loading a character\n        :param seed: seed for the random generator\n        \"\"\"", "\n", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "mxnet", ".", "cpu", "(", ")", "\n", "", "self", ".", "context", "=", "context", "\n", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "alphabets", "=", "alphabets", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "hold_out", "=", "hold_out", "\n", "self", ".", "transform_image", "=", "transform_image", "\n", "self", ".", "transform_mxnet", "=", "transform_mxnet", "\n", "self", ".", "target_transform", "=", "None", "\n", "self", ".", "seed", "=", "seed", "\n", "\n", "# Generate a list of alphabets and characters", "\n", "self", ".", "_alphabets", "=", "[", "a", "for", "a", "in", "list_dirs", "(", "self", ".", "path", ")", "if", "a", "in", "self", ".", "alphabets", "]", "\n", "self", ".", "_characters", "=", "sum", "(", "[", "[", "os", ".", "path", ".", "join", "(", "a", ",", "c", ")", "for", "c", "in", "list_dirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "a", ")", ")", "]", "\n", "for", "a", "in", "self", ".", "_alphabets", "]", ",", "[", "]", ")", "\n", "\n", "if", "seed", ":", "\n", "            ", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "random", ".", "shuffle", "(", "self", ".", "_characters", ")", "\n", "\n", "if", "self", ".", "num_classes", ":", "\n", "            ", "self", ".", "_characters", "=", "self", ".", "_characters", "[", ":", "num_classes", "]", "\n", "\n", "", "self", ".", "_train_character_images", "=", "[", "]", "\n", "self", ".", "_val_character_images", "=", "[", "]", "\n", "for", "idx", ",", "character", "in", "enumerate", "(", "self", ".", "_characters", ")", ":", "\n", "            ", "train_characters", "=", "[", "]", "\n", "val_characters", "=", "[", "]", "\n", "\n", "for", "img_count", ",", "image", "in", "enumerate", "(", "list_files", "(", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "character", ")", ",", "'png'", ")", ")", ":", "\n", "                ", "if", "hold_out", "and", "img_count", "<", "hold_out", ":", "\n", "                    ", "val_characters", ".", "append", "(", "(", "image", ",", "idx", ")", ")", "\n", "", "else", ":", "\n", "                    ", "train_characters", ".", "append", "(", "(", "image", ",", "idx", ")", ")", "\n", "", "", "self", ".", "_train_character_images", ".", "append", "(", "train_characters", ")", "\n", "self", ".", "_val_character_images", ".", "append", "(", "val_characters", ")", "\n", "\n", "", "self", ".", "_flat_train_character_images", "=", "sum", "(", "self", ".", "_train_character_images", ",", "[", "]", ")", "\n", "self", ".", "_flat_val_character_images", "=", "sum", "(", "self", ".", "_val_character_images", ",", "[", "]", ")", "\n", "\n", "train_dataset", "=", "ImageListDataset", "(", "self", ".", "_flat_train_character_images", ",", "\n", "flag", "=", "0", ",", "transform_image", "=", "transform_image", ",", "\n", "transform_mxnet", "=", "transform_mxnet", ",", "context", "=", "context", ")", "\n", "\n", "if", "len", "(", "self", ".", "_flat_val_character_images", ")", ">", "0", ":", "\n", "            ", "val_dataset", "=", "ImageListDataset", "(", "self", ".", "_flat_val_character_images", ",", "flag", "=", "0", ",", "\n", "transform_image", "=", "transform_image", ",", "\n", "transform_mxnet", "=", "transform_mxnet", ",", "context", "=", "context", ")", "\n", "", "else", ":", "\n", "            ", "val_dataset", "=", "None", "\n", "\n", "", "super", "(", "TaskOmniglot", ",", "self", ")", ".", "__init__", "(", "train_dataset", ",", "val_dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.ImageListDataset.__init__": [[276, 285], ["mxnet.cpu"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "items", ",", "flag", "=", "1", ",", "transform_image", "=", "None", ",", "transform_mxnet", "=", "None", ",", "context", "=", "None", ")", ":", "\n", "        ", "self", ".", "items", "=", "items", "\n", "self", ".", "_flag", "=", "flag", "\n", "self", ".", "_transform_image", "=", "transform_image", "\n", "self", ".", "_transform_mxnet", "=", "transform_mxnet", "\n", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "mxnet", ".", "cpu", "(", ")", "\n", "", "self", ".", "context", "=", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.ImageListDataset.__getitem__": [[286, 295], ["PIL.Image.open().convert", "mxnet.nd.array", "utils.random_affine_matrix", "onmiglot.ImageListDataset._transform_mxnet", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.random_affine_matrix"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "Image", ".", "open", "(", "self", ".", "items", "[", "idx", "]", "[", "0", "]", ",", "mode", "=", "'r'", ")", ".", "convert", "(", "'L'", ")", "\n", "if", "self", ".", "_transform_image", "is", "not", "None", ":", "\n", "            ", "img", "=", "random_affine_matrix", "(", "img", ")", "\n", "", "img", "=", "mxnet", ".", "nd", ".", "array", "(", "img", ",", "ctx", "=", "self", ".", "context", ")", "\n", "label", "=", "self", ".", "items", "[", "idx", "]", "[", "1", "]", "\n", "if", "self", ".", "_transform_mxnet", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "_transform_mxnet", "(", "img", ",", "label", ")", "\n", "", "return", "img", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.onmiglot.ImageListDataset.__len__": [[296, 298], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.download_url": [[24, 31], ["urllib.request.urlretrieve", "IOError"], "function", ["None"], ["    ", "output_dict", "=", "{", "}", "\n", "import", "copy", "\n", "# model_dict contains all attributes of model", "\n", "model_dict", "=", "copy", ".", "deepcopy", "(", "target_model", ".", "__dict__", ")", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Replace any numpy array with [data_type_as_str, array_as_list]", "\n", "# e.g np.array([1,2]) -> ['int', [1,2]]", "\n", "        ", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "np", ".", "ndarray", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_files": [[33, 48], ["os.path.join", "os.listdir", "os.path.isfile", "os.listdir", "os.path.join", "os.path.isfile", "os.path.join", "file.split"], "function", ["None"], ["model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.list_dirs": [[50, 53], ["os.listdir", "os.path.isfile", "os.path.join"], "function", ["None"], ["", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.copy_dir": [[55, 63], ["shutil.copytree", "shutil.copy", "print"], "function", ["None"], ["# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "type_data", "=", "'np.'", "+", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "\n", "type_data", "=", "eval", "(", "type_data", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.resize_imgs": [[65, 72], ["os.path.join", "glob.glob", "PIL.Image.open", "im.resize.resize", "im.resize.save"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save"], ["", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils._get_inverse_affine_matrix": [[74, 100], ["numpy.array", "numpy.array", "np.array.dot().dot", "numpy.array", "np.array.dot", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.cos"], "function", ["None"], ["\n", "\n", "", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n", "    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "\n", "\n", "", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.affine_transform": [[102, 107], ["utils._get_inverse_affine_matrix", "img.transform"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils._get_inverse_affine_matrix"], ["        ", "return", "mx", ".", "gpu", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.leap.utils.random_affine_matrix": [[109, 117], ["numpy.random.uniform", "random.uniform", "utils.affine_transform", "numpy.round", "numpy.round", "random.uniform", "random.uniform"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.utils.affine_transform"], []], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.__init__": [[25, 31], ["updaters.BaseUpdater.initialize"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize"], ["def", "__init__", "(", "self", ",", "state", ")", ":", "\n", "        ", "self", ".", "state", "=", "state", "\n", "self", ".", "prev_loss", "=", "None", "\n", "self", ".", "prev_state", "=", "None", "\n", "self", ".", "train_counter", "=", "0", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.__call__": [[32, 37], ["mxnet.autograd.pause", "updaters.BaseUpdater.update", "updaters.BaseUpdater.memorize"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update", "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.memorize"], ["", "def", "__call__", "(", "self", ",", "curr_loss", ",", "curr_state", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "mx", ".", "autograd", ".", "pause", "(", ")", ":", "\n", "            ", "self", ".", "update", "(", "curr_loss", ",", "curr_state", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "memorize", "(", "curr_loss", ",", "curr_state", ")", "\n", "self", ".", "train_counter", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.memorize": [[38, 51], ["curr_state.items", "hasattr", "p.copy", "getattr", "p.grad.copyto", "updaters.BaseUpdater.prev_state[].attach_grad"], "methods", ["None"], ["", "", "def", "memorize", "(", "self", ",", "curr_loss", ",", "curr_state", ")", ":", "\n", "        ", "\"\"\"Update memory buffer\"\"\"", "\n", "self", ".", "prev_loss", "=", "curr_loss", "\n", "\n", "for", "n", ",", "p", "in", "curr_state", ".", "items", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "p", ",", "'copy'", ")", ":", "\n", "                ", "self", ".", "prev_state", "[", "n", "]", "=", "p", ".", "copy", "(", ")", "\n", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "not", "None", ":", "\n", "                    ", "if", "self", ".", "prev_state", "[", "n", "]", ".", "grad", "is", "None", ":", "\n", "                        ", "self", ".", "prev_state", "[", "n", "]", ".", "attach_grad", "(", ")", "\n", "", "p", ".", "grad", ".", "copyto", "(", "self", ".", "prev_state", "[", "n", "]", ".", "grad", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "prev_state", "[", "n", "]", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.initialize": [[52, 57], ["collections.OrderedDict", "updaters.BaseUpdater.state.keys"], "methods", ["None"], ["", "", "", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize counters for new task\"\"\"", "\n", "self", ".", "train_counter", "=", "0", "\n", "self", ".", "prev_loss", "=", "None", "\n", "self", ".", "prev_state", "=", "OrderedDict", "(", "[", "(", "n", ",", "None", ")", "for", "n", "in", "self", ".", "state", ".", "keys", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.BaseUpdater.update": [[58, 61], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "curr_loss", ",", "curr_state", ")", ":", "\n", "        ", "\"\"\"Add unconstrained gradient term\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.__init__": [[67, 72], ["updaters.BaseUpdater.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "state", ",", "norm", "=", "True", ",", "regularizer", "=", "None", ",", "loss", "=", "True", ")", ":", "\n", "        ", "super", "(", "DefaultUpdater", ",", "self", ")", ".", "__init__", "(", "state", ")", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "regularizer", "=", "regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.leap.updaters.DefaultUpdater.update": [[73, 120], ["updaters.DefaultUpdater.state.items", "updaters.DefaultUpdater.state.items", "norm.sqrt", "curr_state[].detach", "prev_state[].detach", "prev_state[].grad.detach", "mxnet.nd.elemwise_add", "curr_state[].detach", "prev_state[].detach", "mxnet.nd.dot", "getattr", "hook", "getattr", "curr_state[].detach.reshape", "prev_state[].detach.reshape", "p.data", "p.data"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "curr_loss", ",", "curr_state", ",", "hook", "=", "None", ")", ":", "\n", "        ", "\"\"\"Accumulate gradients in a state dictionary\"\"\"", "\n", "prev_loss", "=", "self", ".", "prev_loss", "\n", "prev_state", "=", "self", ".", "prev_state", "\n", "\n", "if", "prev_loss", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "d_loss", "=", "curr_loss", "-", "prev_loss", "\n", "\n", "if", "self", ".", "regularizer", "and", "d_loss", ">", "0", ":", "\n", "            ", "d_loss", "=", "-", "d_loss", "\n", "\n", "", "if", "self", ".", "norm", ":", "\n", "            ", "norm", "=", "d_loss", "*", "d_loss", "if", "self", ".", "loss", "else", "0", "\n", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "                ", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "cp", "=", "curr_state", "[", "n", "]", ".", "detach", "(", ")", "\n", "pp", "=", "prev_state", "[", "n", "]", ".", "detach", "(", ")", "\n", "d", "=", "cp", ".", "reshape", "(", "(", "-", "1", ",", ")", ")", "-", "pp", ".", "reshape", "(", "(", "-", "1", ",", ")", ")", "\n", "norm", "+=", "mx", ".", "nd", ".", "dot", "(", "d", ",", "d", ")", "\n", "", "norm", ".", "sqrt", "(", "out", "=", "norm", ")", "\n", "\n", "", "for", "n", ",", "p", "in", "self", ".", "state", ".", "items", "(", ")", ":", "\n", "            ", "if", "getattr", "(", "p", ",", "'grad'", ",", "None", ")", "is", "None", ":", "\n", "                ", "continue", "\n", "\n", "", "cp", "=", "curr_state", "[", "n", "]", ".", "detach", "(", ")", "\n", "pp", "=", "prev_state", "[", "n", "]", ".", "detach", "(", ")", "\n", "pg", "=", "prev_state", "[", "n", "]", ".", "grad", ".", "detach", "(", ")", "\n", "\n", "if", "self", ".", "loss", ":", "\n", "                ", "add", "=", "-", "d_loss", "*", "pg", "+", "pp", "-", "cp", "\n", "", "elif", "self", ".", "regularizer", "and", "curr_loss", ">", "prev_loss", ":", "\n", "                ", "add", "=", "cp", "-", "pp", "\n", "", "else", ":", "\n", "                ", "add", "=", "pp", "-", "cp", "\n", "\n", "", "if", "self", ".", "norm", ":", "\n", "                ", "add", "/=", "norm", "\n", "\n", "", "if", "hook", "is", "not", "None", ":", "\n", "                ", "hook", "(", "add", ")", "\n", "\n", "", "mx", ".", "nd", ".", "elemwise_add", "(", "p", ".", "data", "(", ")", ".", "grad", ",", "add", ",", "out", "=", "p", ".", "data", "(", ")", ".", "grad", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.demos.mxnet_test.synthetic_task_data": [[31, 46], ["range", "mxnet.nd.random_normal", "tasks.append", "len", "len", "real_fn", "mxnet.nd.random_normal"], "function", ["None"], ["def", "synthetic_task_data", "(", "N_tasks", ",", "num_examples", ",", "W", ",", "apply_noise", "=", "True", ",", "real_fn", "=", "None", ")", ":", "\n", "    ", "def", "fn", "(", "X", ",", "W", ")", ":", "\n", "        ", "assert", "len", "(", "W", ")", ">=", "3", ",", "'3 weights required. Only {} given.'", ".", "format", "(", "len", "(", "W", ")", ")", "\n", "return", "W", "[", "1", "]", "*", "X", "[", ":", ",", "0", "]", "-", "W", "[", "2", "]", "*", "X", "[", ":", ",", "1", "]", "+", "W", "[", "0", "]", "\n", "\n", "", "if", "real_fn", "is", "None", ":", "\n", "        ", "real_fn", "=", "fn", "\n", "\n", "", "tasks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "N_tasks", ")", ":", "\n", "        ", "X", "=", "nd", ".", "random_normal", "(", "shape", "=", "(", "num_examples", ",", "num_inputs", ")", ")", "\n", "noise", "=", "0.01", "*", "nd", ".", "random_normal", "(", "shape", "=", "(", "num_examples", ",", ")", ")", "if", "apply_noise", "else", "0", "\n", "y", "=", "real_fn", "(", "X", ",", "W", "[", "i", "]", ")", "+", "noise", "\n", "tasks", ".", "append", "(", "(", "X", ",", "y", ")", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.BasicBlock.__init__": [[48, 66], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "wide_residual_network.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "wide_residual_network.conv3x3", "wide_residual_network.conv1x1"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv3x3", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv3x3", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "stride", ",", "drop_rate", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_channels", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "out_channels", ",", "out_channels", ",", "1", ")", "\n", "\n", "# If the number of channels corresponding to the input and the output is different, we use an additional 1x1", "\n", "# convolutional layer as a residual connection between the input and the output.", "\n", "self", ".", "is_equal_in_out", "=", "in_channels", "==", "out_channels", "\n", "if", "not", "self", ".", "is_equal_in_out", ":", "\n", "            ", "self", ".", "conv_shortcut", "=", "conv1x1", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "", "self", ".", "drop_rate", "=", "drop_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.BasicBlock.forward": [[67, 88], ["wide_residual_network.BasicBlock.conv1", "wide_residual_network.BasicBlock.relu2", "wide_residual_network.BasicBlock.conv2", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "wide_residual_network.BasicBlock.relu1", "wide_residual_network.BasicBlock.conv1", "wide_residual_network.BasicBlock.relu2", "wide_residual_network.BasicBlock.conv2", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "wide_residual_network.BasicBlock.relu1", "wide_residual_network.BasicBlock.bn2", "torch.dropout", "torch.dropout", "torch.dropout", "wide_residual_network.BasicBlock.bn1", "wide_residual_network.BasicBlock.bn2", "torch.dropout", "torch.dropout", "torch.dropout", "wide_residual_network.BasicBlock.conv_shortcut", "wide_residual_network.BasicBlock.bn1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "is_equal_in_out", ":", "\n", "            ", "out", "=", "self", ".", "conv1", "(", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "out", ")", ")", "\n", "if", "self", ".", "drop_rate", ">", "0", ":", "\n", "                ", "out", "=", "F", ".", "dropout", "(", "out", ",", "p", "=", "self", ".", "drop_rate", ",", "training", "=", "self", ".", "training", ")", "\n", "\n", "", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "torch", ".", "add", "(", "out", ",", "x", ")", "\n", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "out", ")", ")", "\n", "if", "self", ".", "drop_rate", ">", "0", ":", "\n", "                ", "out", "=", "F", ".", "dropout", "(", "out", ",", "p", "=", "self", ".", "drop_rate", ",", "training", "=", "self", ".", "training", ")", "\n", "\n", "", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "torch", ".", "add", "(", "out", ",", "self", ".", "conv_shortcut", "(", "x", ")", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.GroupBlock.__init__": [[93, 97], ["torch.Module.__init__", "wide_residual_network.GroupBlock._make_layer"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.GroupBlock._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "num_blocks", ",", "in_channels", ",", "out_channels", ",", "stride", ",", "drop_rate", ")", ":", "\n", "        ", "super", "(", "GroupBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "layer", "=", "self", ".", "_make_layer", "(", "in_channels", ",", "out_channels", ",", "num_blocks", ",", "stride", ",", "drop_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.GroupBlock._make_layer": [[98, 109], ["range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "int", "layers.append", "wide_residual_network.BasicBlock"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "in_channels", ",", "out_channels", ",", "num_blocks", ",", "stride", ",", "drop_rate", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "int", "(", "num_blocks", ")", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "_in_channels", ",", "_out_channels", ",", "_stride", "=", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "", "else", ":", "\n", "                ", "_in_channels", ",", "_out_channels", ",", "_stride", "=", "(", "out_channels", ",", "out_channels", ",", "1", ")", "\n", "\n", "", "layers", ".", "append", "(", "BasicBlock", "(", "_in_channels", ",", "_out_channels", ",", "_stride", ",", "drop_rate", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.GroupBlock.forward": [[110, 112], ["wide_residual_network.GroupBlock.layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "layer", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.WideResidualNetwork.__init__": [[124, 185], ["torch.Module.__init__", "wide_residual_network.conv3x3", "wide_residual_network.GroupBlock", "wide_residual_network.GroupBlock", "wide_residual_network.GroupBlock", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "wide_residual_network.WideResidualNetwork.modules", "int", "int", "int", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv3x3"], ["def", "__init__", "(", "self", ",", "depth", ",", "width", ",", "num_classes", "=", "10", ",", "drop_rate", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "WideResidualNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "layerwise_num_channels", "=", "[", "int", "(", "16", "*", "width", ")", ",", "int", "(", "32", "*", "width", ")", ",", "int", "(", "64", "*", "width", ")", "]", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "drop_rate", "=", "drop_rate", "\n", "# The wide residual network assigns 4 modules outside the GroupBlock modules.", "\n", "# There exist three GroupBlock modules and each one has depth of twice the number of its blocks.", "\n", "# Hence, the number of blocks per group can be inversely calculated from the depth factor.", "\n", "self", ".", "num_blocks_per_group", "=", "(", "self", ".", "depth", "-", "4", ")", "/", "6", "\n", "\n", "# Convolutional layer before any GroupBlock module with fixed number of channels.", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "3", ",", "16", ",", "1", ")", "\n", "\n", "# 1st GroupBlock", "\n", "self", ".", "layer1", "=", "GroupBlock", "(", "\n", "num_blocks", "=", "self", ".", "num_blocks_per_group", ",", "\n", "in_channels", "=", "16", ",", "\n", "out_channels", "=", "self", ".", "layerwise_num_channels", "[", "0", "]", ",", "\n", "stride", "=", "1", ",", "\n", "drop_rate", "=", "self", ".", "drop_rate", ",", "\n", ")", "\n", "\n", "# 2nd GroupBlock", "\n", "self", ".", "layer2", "=", "GroupBlock", "(", "\n", "num_blocks", "=", "self", ".", "num_blocks_per_group", ",", "\n", "in_channels", "=", "self", ".", "layerwise_num_channels", "[", "0", "]", ",", "\n", "out_channels", "=", "self", ".", "layerwise_num_channels", "[", "1", "]", ",", "\n", "stride", "=", "2", ",", "\n", "drop_rate", "=", "self", ".", "drop_rate", ",", "\n", ")", "\n", "\n", "# 3rd GroupBlock", "\n", "self", ".", "layer3", "=", "GroupBlock", "(", "\n", "num_blocks", "=", "self", ".", "num_blocks_per_group", ",", "\n", "in_channels", "=", "self", ".", "layerwise_num_channels", "[", "1", "]", ",", "\n", "out_channels", "=", "self", ".", "layerwise_num_channels", "[", "2", "]", ",", "\n", "stride", "=", "2", ",", "\n", "drop_rate", "=", "self", ".", "drop_rate", ",", "\n", ")", "\n", "\n", "# global average pooling and classifier", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "self", ".", "layerwise_num_channels", "[", "2", "]", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "avg_pool2d", "=", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "8", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "self", ".", "layerwise_num_channels", "[", "2", "]", ",", "self", ".", "num_classes", ")", "\n", "self", ".", "view_dim", "=", "self", ".", "layerwise_num_channels", "[", "2", "]", "\n", "\n", "# Initialize weights", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.0", "/", "n", ")", ")", "\n", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.WideResidualNetwork.forward": [[186, 197], ["wide_residual_network.WideResidualNetwork.conv1", "wide_residual_network.WideResidualNetwork.layer1", "wide_residual_network.WideResidualNetwork.layer2", "wide_residual_network.WideResidualNetwork.layer3", "wide_residual_network.WideResidualNetwork.relu", "wide_residual_network.WideResidualNetwork.avg_pool2d", "wide_residual_network.WideResidualNetwork.view", "wide_residual_network.WideResidualNetwork.fc", "wide_residual_network.WideResidualNetwork.bn1"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "avg_pool2d", "(", "out", ")", "\n", "out", "=", "out", ".", "view", "(", "-", "1", ",", "self", ".", "view_dim", ")", "\n", "out", "=", "self", ".", "fc", "(", "out", ")", "\n", "\n", "return", "(", "out", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.TeacherWideResidualNetwork.__init__": [[206, 212], ["wide_residual_network.WideResidualNetwork.__init__", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "wide_residual_network.TeacherWideResidualNetwork.load_state_dict", "next", "wide_residual_network.TeacherWideResidualNetwork.parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.load", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["def", "__init__", "(", "self", ",", "depth", ",", "width", ",", "num_classes", "=", "10", ",", "drop_rate", "=", "0.0", ",", "load_path", "=", "None", ")", ":", "\n", "        ", "super", "(", "TeacherWideResidualNetwork", ",", "self", ")", ".", "__init__", "(", "depth", ",", "width", ",", "num_classes", ",", "drop_rate", ")", "\n", "# Load the pre-trained weights for the teacher model when the path is provided.", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "            ", "state_dict", "=", "torch", ".", "load", "(", "load_path", ",", "map_location", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", ")", "\n", "self", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.TeacherWideResidualNetwork.forward": [[213, 228], ["wide_residual_network.TeacherWideResidualNetwork.conv1", "wide_residual_network.TeacherWideResidualNetwork.layer1", "wide_residual_network.TeacherWideResidualNetwork.layer2", "wide_residual_network.TeacherWideResidualNetwork.layer3", "wide_residual_network.TeacherWideResidualNetwork.relu", "wide_residual_network.TeacherWideResidualNetwork.avg_pool2d", "wide_residual_network.TeacherWideResidualNetwork.view", "wide_residual_network.TeacherWideResidualNetwork.fc", "wide_residual_network.TeacherWideResidualNetwork.bn1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "\n", "# teacher network provides its intermediate representation (z1, z2, z3) as the knowledge to \"teach\" for a ", "\n", "# student network.", "\n", "z1", "=", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "z2", "=", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "z3", "=", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "avg_pool2d", "(", "out", ")", "\n", "out", "=", "out", ".", "view", "(", "-", "1", ",", "self", ".", "view_dim", ")", "\n", "out", "=", "self", ".", "fc", "(", "out", ")", "\n", "\n", "return", "out", ",", "(", "z1", ",", "z2", ",", "z3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork.__init__": [[243, 274], ["wide_residual_network.WideResidualNetwork.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "int", "int", "int", "wide_residual_network.conv1x1", "wide_residual_network.conv1x1", "wide_residual_network.conv1x1", "wide_residual_network.conv1x1", "wide_residual_network.conv1x1", "wide_residual_network.conv1x1", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1"], ["def", "__init__", "(", "self", ",", "depth", ",", "width", ",", "teacher_width", ",", "num_classes", "=", "10", ",", "drop_rate", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "StudentWideResidualNetwork", ",", "self", ")", ".", "__init__", "(", "depth", ",", "width", ",", "num_classes", ",", "drop_rate", ")", "\n", "self", ".", "teacher_layerwise_num_channels", "=", "[", "\n", "int", "(", "16", "*", "teacher_width", ")", ",", "\n", "int", "(", "32", "*", "teacher_width", ")", ",", "\n", "int", "(", "64", "*", "teacher_width", ")", ",", "\n", "]", "\n", "\n", "self", ".", "branch1", "=", "nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "layerwise_num_channels", "[", "0", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "0", "]", ")", ",", "\n", "conv1x1", "(", "self", ".", "teacher_layerwise_num_channels", "[", "0", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "0", "]", ")", ",", "\n", ")", "\n", "self", ".", "branch2", "=", "nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "layerwise_num_channels", "[", "1", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "1", "]", ")", ",", "\n", "conv1x1", "(", "self", ".", "teacher_layerwise_num_channels", "[", "1", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "1", "]", ")", ",", "\n", ")", "\n", "self", ".", "branch3", "=", "nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "layerwise_num_channels", "[", "2", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "2", "]", ")", ",", "\n", "conv1x1", "(", "self", ".", "teacher_layerwise_num_channels", "[", "2", "]", ",", "self", ".", "teacher_layerwise_num_channels", "[", "2", "]", ")", ",", "\n", ")", "\n", "\n", "# variance are represented as a softplus function applied to \"variance parameters\".", "\n", "init_variance_param_value", "=", "self", ".", "_variance_param_to_variance", "(", "torch", ".", "tensor", "(", "5.0", ")", ")", "\n", "self", ".", "variance_param1", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "full", "(", "(", "self", ".", "teacher_layerwise_num_channels", "[", "0", "]", ",", "1", ",", "1", ")", ",", "init_variance_param_value", ")", "\n", ")", "\n", "self", ".", "variance_param2", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "full", "(", "(", "self", ".", "teacher_layerwise_num_channels", "[", "1", "]", ",", "1", ",", "1", ")", ",", "init_variance_param_value", ")", "\n", ")", "\n", "self", ".", "variance_param3", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "full", "(", "(", "self", ".", "teacher_layerwise_num_channels", "[", "2", "]", ",", "1", ",", "1", ")", ",", "init_variance_param_value", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_to_variance_param": [[276, 283], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "_variance_to_variance_param", "(", "self", ",", "variance", ")", ":", "\n", "        ", "\"\"\"\n        Convert variance to corresponding variance parameter by inverse of the softplus function.\n\n        :param torch.FloatTensor variance: the target variance for obtaining the variance parameter\n        \"\"\"", "\n", "return", "torch", ".", "log", "(", "torch", ".", "exp", "(", "variance", ")", "-", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance": [[284, 291], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "_variance_param_to_variance", "(", "self", ",", "variance_param", ")", ":", "\n", "        ", "\"\"\"\n        Convert the variance parameter to corresponding variance by the softplus function.\n\n        :param torch.FloatTensor variance_param: the target variance parameter for obtaining the variance\n        \"\"\"", "\n", "return", "torch", ".", "log", "(", "torch", ".", "exp", "(", "variance_param", ")", "+", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork.forward": [[292, 317], ["wide_residual_network.StudentWideResidualNetwork.conv1", "wide_residual_network.StudentWideResidualNetwork.layer1", "wide_residual_network.StudentWideResidualNetwork.layer2", "wide_residual_network.StudentWideResidualNetwork.layer3", "wide_residual_network.StudentWideResidualNetwork.relu", "wide_residual_network.StudentWideResidualNetwork.avg_pool2d", "wide_residual_network.StudentWideResidualNetwork.view", "wide_residual_network.StudentWideResidualNetwork.fc", "wide_residual_network.StudentWideResidualNetwork.branch1", "wide_residual_network.StudentWideResidualNetwork.branch2", "wide_residual_network.StudentWideResidualNetwork.branch3", "wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "wide_residual_network.StudentWideResidualNetwork.bn1", "x.dim", "variance1.unsqueeze.unsqueeze.unsqueeze", "variance2.unsqueeze.unsqueeze.unsqueeze", "variance3.unsqueeze.unsqueeze.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.StudentWideResidualNetwork._variance_param_to_variance"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "z1", "=", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "z2", "=", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "z3", "=", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "avg_pool2d", "(", "out", ")", "\n", "out", "=", "out", ".", "view", "(", "-", "1", ",", "self", ".", "view_dim", ")", "\n", "out", "=", "self", ".", "fc", "(", "out", ")", "\n", "\n", "branch1_out", "=", "self", ".", "branch1", "(", "z1", ")", "\n", "branch2_out", "=", "self", ".", "branch2", "(", "z2", ")", "\n", "branch3_out", "=", "self", ".", "branch3", "(", "z3", ")", "\n", "\n", "variance1", "=", "self", ".", "_variance_param_to_variance", "(", "self", ".", "variance_param1", ")", "\n", "variance2", "=", "self", ".", "_variance_param_to_variance", "(", "self", ".", "variance_param2", ")", "\n", "variance3", "=", "self", ".", "_variance_param_to_variance", "(", "self", ".", "variance_param3", ")", "\n", "\n", "# If the input has an additional dimension for mini-batch, resize the variance to match its dimension", "\n", "if", "x", ".", "dim", "(", ")", "==", "4", ":", "\n", "            ", "variance1", "=", "variance1", ".", "unsqueeze", "(", "0", ")", "\n", "variance2", "=", "variance2", ".", "unsqueeze", "(", "0", ")", "\n", "variance3", "=", "variance3", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "return", "out", ",", "(", "(", "branch1_out", ",", "variance1", ")", ",", "(", "branch2_out", ",", "variance2", ")", ",", "(", "branch3_out", ",", "variance3", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv1x1": [[35, 38], ["torch.Conv2d"], "function", ["None"], ["def", "conv1x1", "(", "in_channels", ",", "out_channels", ",", "stride", "=", "1", ")", ":", "\n", "# convenient shortcuts for constructing the network", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ",", "stride", "=", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.wide_residual_network.conv3x3": [[40, 43], ["torch.Conv2d"], "function", ["None"], ["", "def", "conv3x3", "(", "in_channels", ",", "out_channels", ",", "stride", "=", "1", ")", ":", "\n", "# convenient shortcuts for constructing the network", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ",", "stride", "=", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.train_with_transfer.main": [[50, 148], ["torch.device", "cifar10.get_cifar10_loaders", "wide_residual_network.StudentWideResidualNetwork", "model.to.to", "wide_residual_network.TeacherWideResidualNetwork", "teacher_model.to.to", "torch.optim.SGD", "torch.optim.lr_scheduler.MultiStepLR", "torch.nn.CrossEntropyLoss", "loss.TemperatureScaledKLDivLoss", "loss.GaussianLoss", "loss.EnsembleKnowledgeTransferLoss", "util.BatchUpdaterWithTransfer", "util.BatchEvaluator", "ignite.engine.Engine", "ignite.engine.Engine", "util.attach_pbar_and_metrics", "util.LearningRateUpdater", "util.MetricLogger", "ignite.engine.Engine.run", "model.to.cpu", "os.makedirs", "torch.save", "model.to.parameters", "ignite.engine.Engine.on", "ignite.engine.Engine.on", "model.to.state_dict", "ignite.engine.Events.EPOCH_COMPLETED", "ignite.engine.Events.EPOCH_COMPLETED", "state_dict_path.split"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.cifar10.get_cifar10_loaders", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.attach_pbar_and_metrics", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["def", "main", "(", "\n", "student_depth", ",", "\n", "student_width", ",", "\n", "teacher_depth", ",", "\n", "teacher_width", ",", "\n", "max_epochs", ",", "\n", "variational_information_distillation_factor", ",", "\n", "knowledge_distillation_factor", ",", "\n", "knowledge_distillation_temperature", ",", "\n", "state_dict_path", ",", "\n", "teacher_state_dict_path", ",", "\n", "device", ",", "\n", "data_dir", ",", "\n", "num_workers", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    This function constructs and trains a student model with knowledge transfer from the pretrained teacher model. \n    \n    :param int student_depth: factor for controlling the depth of the student model.\n    :param int student_width: factor for controlling the width of the student model.\n    :param int teacher_depth: factor for controlling the depth of the teacher model. \n    :param int teacher_width: factor for controlling the width of the teacher model.\n    :param int max_epochs: maximum number of epochs for training the student model.\n    :param float variational_information_distillation_factor: scaling factor for variational information distillation.\n    :param float knowledge_distillation_factor: scaling factor for knowledge distillation.\n    :param float knowledge_distillation_temperature: degree of smoothing on distributions for computing the Kuback-Leibler \n    divergence for knowledge distillation. \n    :param string state_dict_path: path to save the student model.\n    :param string teacher_state_dict_path: path to load the teacher model from.\n    :param int device: device to use for training the model\n    :param string data_dir: directory to save and load the dataset.\n    :param int num_workers: number of workers to use for loading the dataset.\n    \"\"\"", "\n", "\n", "# Define the device for training the model.", "\n", "device", "=", "torch", ".", "device", "(", "device", ")", "\n", "\n", "# Get data loaders for the CIFAR-10 dataset.", "\n", "train_loader", ",", "validation_loader", ",", "test_loader", "=", "get_cifar10_loaders", "(", "\n", "data_dir", ",", "batch_size", "=", "BATCH_SIZE", ",", "num_workers", "=", "num_workers", "\n", ")", "\n", "\n", "# Construct the student model to be trained.", "\n", "model", "=", "StudentWideResidualNetwork", "(", "depth", "=", "student_depth", ",", "width", "=", "student_width", ",", "teacher_width", "=", "teacher_width", ")", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "# Construct and load the teacher model for guiding the student model.", "\n", "teacher_model", "=", "TeacherWideResidualNetwork", "(", "\n", "depth", "=", "teacher_depth", ",", "width", "=", "teacher_width", ",", "load_path", "=", "teacher_state_dict_path", "\n", ")", "\n", "teacher_model", "=", "teacher_model", ".", "to", "(", "device", ")", "\n", "\n", "# Define optimizer and learning rate scheduler", "\n", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "LEARNING_RATE", ",", "momentum", "=", "MOMENTUM", ",", "weight_decay", "=", "WEIGHT_DECAY", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "\n", "optimizer", ",", "milestones", "=", "LEARNING_RATE_DECAY_MILESTONES", ",", "gamma", "=", "LEARNING_RATE_DECAY_FACTOR", "\n", ")", "\n", "\n", "# Construct the loss function to be used for training.", "\n", "label_criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "teacher_logit_criterion", "=", "TemperatureScaledKLDivLoss", "(", "temperature", "=", "knowledge_distillation_temperature", ")", "\n", "teacher_feature_criterion", "=", "GaussianLoss", "(", ")", "\n", "criterion", "=", "EnsembleKnowledgeTransferLoss", "(", "\n", "label_criterion", "=", "label_criterion", ",", "\n", "teacher_logit_criterion", "=", "teacher_logit_criterion", ",", "\n", "teacher_feature_criterion", "=", "teacher_feature_criterion", ",", "\n", "teacher_logit_factor", "=", "knowledge_distillation_factor", ",", "\n", "teacher_feature_factor", "=", "variational_information_distillation_factor", ",", "\n", ")", "\n", "\n", "# Define the ignite engines for training and evaluation.", "\n", "batch_updater", "=", "BatchUpdaterWithTransfer", "(", "\n", "model", "=", "model", ",", "teacher_model", "=", "teacher_model", ",", "optimizer", "=", "optimizer", ",", "criterion", "=", "criterion", ",", "device", "=", "device", "\n", ")", "\n", "batch_evaluator", "=", "BatchEvaluator", "(", "model", "=", "model", ",", "device", "=", "device", ")", "\n", "trainer", "=", "Engine", "(", "batch_updater", ")", "\n", "evaluator", "=", "Engine", "(", "batch_evaluator", ")", "\n", "\n", "# Define and attach the progress bar, loss metric, and the accuracy metrics.", "\n", "attach_pbar_and_metrics", "(", "trainer", ",", "evaluator", ")", "\n", "\n", "# The training engine updates the learning rate schedule at end of each epoch.", "\n", "lr_updater", "=", "LearningRateUpdater", "(", "lr_scheduler", "=", "lr_scheduler", ")", "\n", "trainer", ".", "on", "(", "Events", ".", "EPOCH_COMPLETED", "(", "every", "=", "1", ")", ")", "(", "lr_updater", ")", "\n", "\n", "# The training engine logs the training and the evaluation metrics at end of each epoch.", "\n", "metric_logger", "=", "MetricLogger", "(", "evaluator", "=", "evaluator", ",", "eval_loader", "=", "validation_loader", ")", "\n", "trainer", ".", "on", "(", "Events", ".", "EPOCH_COMPLETED", "(", "every", "=", "1", ")", ")", "(", "metric_logger", ")", "\n", "\n", "# Train the model", "\n", "trainer", ".", "run", "(", "train_loader", ",", "max_epochs", "=", "max_epochs", ")", "\n", "\n", "# Save the model to pre-defined path. We move the model to CPU which is desirable as the default device", "\n", "# for loading the model.", "\n", "model", ".", "cpu", "(", ")", "\n", "state_dict_dir", "=", "\"/\"", ".", "join", "(", "state_dict_path", ".", "split", "(", "\"/\"", ")", "[", ":", "-", "1", "]", ")", "\n", "os", ".", "makedirs", "(", "state_dict_dir", ",", "exist_ok", "=", "True", ")", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "state_dict_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.train_without_transfer.main": [[47, 107], ["torch.device", "cifar10.get_cifar10_loaders", "wide_residual_network.WideResidualNetwork", "model.to.to", "torch.optim.SGD", "torch.optim.lr_scheduler.MultiStepLR", "torch.nn.CrossEntropyLoss", "util.BatchUpdaterWithoutTransfer", "util.BatchEvaluator", "ignite.engine.Engine", "ignite.engine.Engine", "util.attach_pbar_and_metrics", "util.LearningRateUpdater", "util.MetricLogger", "ignite.engine.Engine.run", "model.to.cpu", "os.makedirs", "torch.save", "model.to.parameters", "ignite.engine.Engine.on", "ignite.engine.Engine.on", "model.to.state_dict", "ignite.engine.Events.EPOCH_COMPLETED", "ignite.engine.Events.EPOCH_COMPLETED", "state_dict_path.split"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.lazy.jacobian.Jacobian.device", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.cifar10.get_cifar10_loaders", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.attach_pbar_and_metrics", "home.repos.pwc.inspect_result.amzn_xfer.prob.var.GaussianVariationalPosterior.save", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.parameters"], ["def", "main", "(", "width", ",", "depth", ",", "max_epochs", ",", "state_dict_path", ",", "device", ",", "data_dir", ",", "num_workers", ")", ":", "\n", "    ", "\"\"\"\n    This function constructs and trains a model from scratch, without any knowledge transfer method applied. \n\n    :param int depth: factor for controlling the depth of the model.\n    :param int width: factor for controlling the width of the model.\n    :param int max_epochs: maximum number of epochs for training the student model.\n    :param string state_dict_path: path to save the trained model.\n    :param int device: device to use for training the model.\n    :param string data_dir: directory to save and load the dataset.\n    :param int num_workers: number of workers to use for loading the dataset.\n    \"\"\"", "\n", "\n", "# Define the device for training the model.", "\n", "device", "=", "torch", ".", "device", "(", "device", ")", "\n", "\n", "# Get data loaders for the CIFAR-10 dataset.", "\n", "train_loader", ",", "validation_loader", ",", "test_loader", "=", "get_cifar10_loaders", "(", "\n", "data_dir", ",", "batch_size", "=", "BATCH_SIZE", ",", "num_workers", "=", "num_workers", "\n", ")", "\n", "\n", "# Construct the model to be trained.", "\n", "model", "=", "WideResidualNetwork", "(", "depth", "=", "depth", ",", "width", "=", "width", ")", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "# Define optimizer and learning rate scheduler.", "\n", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "LEARNING_RATE", ",", "momentum", "=", "MOMENTUM", ",", "weight_decay", "=", "WEIGHT_DECAY", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "\n", "optimizer", ",", "milestones", "=", "LEARNING_RATE_DECAY_MILESTONES", ",", "gamma", "=", "LEARNING_RATE_DECAY_FACTOR", "\n", ")", "\n", "\n", "# Construct the loss function to be used for training.", "\n", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "# Define the ignite engines for training and evaluation.", "\n", "batch_updater", "=", "BatchUpdaterWithoutTransfer", "(", "model", "=", "model", ",", "optimizer", "=", "optimizer", ",", "criterion", "=", "criterion", ",", "device", "=", "device", ")", "\n", "batch_evaluator", "=", "BatchEvaluator", "(", "model", "=", "model", ",", "device", "=", "device", ")", "\n", "trainer", "=", "Engine", "(", "batch_updater", ")", "\n", "evaluator", "=", "Engine", "(", "batch_evaluator", ")", "\n", "\n", "# Define and attach the progress bar, loss metric, and the accuracy metrics.", "\n", "attach_pbar_and_metrics", "(", "trainer", ",", "evaluator", ")", "\n", "\n", "# The training engine updates the learning rate schedule at end of each epoch.", "\n", "lr_updater", "=", "LearningRateUpdater", "(", "lr_scheduler", "=", "lr_scheduler", ")", "\n", "trainer", ".", "on", "(", "Events", ".", "EPOCH_COMPLETED", "(", "every", "=", "1", ")", ")", "(", "lr_updater", ")", "\n", "\n", "# The training engine logs the training and the evaluation metrics at end of each epoch.", "\n", "metric_logger", "=", "MetricLogger", "(", "evaluator", "=", "evaluator", ",", "eval_loader", "=", "validation_loader", ")", "\n", "trainer", ".", "on", "(", "Events", ".", "EPOCH_COMPLETED", "(", "every", "=", "1", ")", ")", "(", "metric_logger", ")", "\n", "\n", "# Train the model", "\n", "trainer", ".", "run", "(", "train_loader", ",", "max_epochs", "=", "max_epochs", ")", "\n", "\n", "# Save the model to pre-defined path. We move the model to CPU which is desirable as the default device", "\n", "# for loading the model.", "\n", "model", ".", "cpu", "(", ")", "\n", "state_dict_dir", "=", "\"/\"", ".", "join", "(", "state_dict_path", ".", "split", "(", "\"/\"", ")", "[", ":", "-", "1", "]", ")", "\n", "os", ".", "makedirs", "(", "state_dict_dir", ",", "exist_ok", "=", "True", ")", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "state_dict_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.TemperatureScaledKLDivLoss.__init__": [[26, 30], ["torch.Module.__init__", "torch.KLDivLoss", "torch.KLDivLoss"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "self", ",", "temperature", ")", ":", "\n", "        ", "super", "(", "TemperatureScaledKLDivLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "kullback_leibler_divergence", "=", "nn", ".", "KLDivLoss", "(", "reduction", "=", "\"batchmean\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.TemperatureScaledKLDivLoss.forward": [[31, 43], ["torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "loss.TemperatureScaledKLDivLoss.kullback_leibler_divergence"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "y_pred", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Output the temperature scaled Kullback-Leibler divergence loss for given the prediction and the target.\n        :param torch.Tensor y_pred: unnormalized prediction for logarithm of the target.\n        :param torch.Tensor y: probabilities representing the target.\n        \"\"\"", "\n", "log_p", "=", "torch", ".", "log_softmax", "(", "y_pred", "/", "self", ".", "temperature", ",", "dim", "=", "1", ")", "\n", "q", "=", "torch", ".", "softmax", "(", "y", "/", "self", ".", "temperature", ",", "dim", "=", "1", ")", "\n", "\n", "# Note that the Kullback-Leibler divergence is re-scaled by the squared temperature parameter.", "\n", "loss", "=", "(", "self", ".", "temperature", "**", "2", ")", "*", "self", ".", "kullback_leibler_divergence", "(", "log_p", ",", "q", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.GaussianLoss.forward": [[50, 60], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["None"], ["def", "forward", "(", "self", ",", "y_pred", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Output the Gaussian loss given the prediction and the target.\n        :param tuple(torch.Tensor, torch.Tensor) y_pred: predicted mean and variance for the Gaussian \n        distribution.\n        :param torch.Tensor y: target for the Gaussian distribution.\n        \"\"\"", "\n", "y_pred_mean", ",", "y_pred_var", "=", "y_pred", "\n", "loss", "=", "torch", ".", "mean", "(", "0.5", "*", "(", "(", "y_pred_mean", "-", "y", ")", "**", "2", "/", "y_pred_var", "+", "torch", ".", "log", "(", "y_pred_var", ")", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.EnsembleKnowledgeTransferLoss.__init__": [[74, 89], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "label_criterion", ",", "\n", "teacher_logit_criterion", ",", "\n", "teacher_feature_criterion", ",", "\n", "teacher_logit_factor", ",", "\n", "teacher_feature_factor", ",", "\n", ")", ":", "\n", "        ", "super", "(", "EnsembleKnowledgeTransferLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "label_criterion", "=", "label_criterion", "\n", "self", ".", "teacher_logit_criterion", "=", "teacher_logit_criterion", "\n", "self", ".", "teacher_feature_criterion", "=", "teacher_feature_criterion", "\n", "\n", "self", ".", "teacher_logit_factor", "=", "teacher_logit_factor", "\n", "self", ".", "teacher_feature_factor", "=", "teacher_feature_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.loss.EnsembleKnowledgeTransferLoss.forward": [[90, 112], ["loss.EnsembleKnowledgeTransferLoss.label_criterion", "loss.EnsembleKnowledgeTransferLoss.teacher_logit_criterion", "loss.EnsembleKnowledgeTransferLoss.teacher_feature_criterion", "zip", "sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logit", ",", "label", ",", "teacher_feature_preds", ",", "teacher_logit", ",", "teacher_features", ")", ":", "\n", "        ", "\"\"\"\n        Output the ensemble of knowledge transfer losses given the predictions and the targets.\n        :param torch.Tensor logit: logit of the student model for predicting the label and logit of the teacher model. \n        :param torch.Tensor label: target label of the image.\n        :param tuple(tuple(torch.Tensor)) teacher_feature_preds: predictions of the student model made on features of \n        the teacher model.\n        :param torch.Tensor teacher_logit: logit of the teacher model to predict from the the student model.\n        :param tuple(torch.Tensor) teacher_features: features of the teacher model to predict from the student model.\n        \"\"\"", "\n", "label_loss", "=", "self", ".", "label_criterion", "(", "logit", ",", "label", ")", "\n", "teacher_logit_loss", "=", "self", ".", "teacher_logit_criterion", "(", "logit", ",", "teacher_logit", ")", "\n", "teacher_feature_losses", "=", "[", "\n", "self", ".", "teacher_feature_criterion", "(", "pred", ",", "feature", ")", "for", "pred", ",", "feature", "in", "zip", "(", "teacher_feature_preds", ",", "teacher_features", ")", "\n", "]", "\n", "loss", "=", "(", "\n", "label_loss", "\n", "+", "self", ".", "teacher_logit_factor", "*", "teacher_logit_loss", "\n", "+", "self", ".", "teacher_feature_factor", "*", "sum", "(", "teacher_feature_losses", ")", "\n", ")", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.cifar10.get_cifar10_loaders": [[26, 88], ["torchvision.Compose", "torchvision.Compose", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torch.randperm", "torch.utils.data.Subset", "torch.utils.data.Subset", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "len", "torchvision.ToTensor", "torchvision.Normalize", "torchvision.Pad", "torchvision.RandomHorizontalFlip", "torchvision.RandomCrop", "numpy.array", "numpy.array"], "function", ["None"], ["def", "get_cifar10_loaders", "(", "root", ",", "batch_size", ",", "num_workers", ")", ":", "\n", "    ", "\"\"\"\n    This function prepares the DataLoader class for training, validation and testing of the CIFAR-10 dataset. The data \n    loaders will prepare the mini-batch of images and labels when training the neural networks. Especially, whenever the\n    images are selected for the mini-batch, they are randomly transformed on-line by the pre-defined operations. \n    Specifically, data loaders are equipped with the image augmentation schemes, i.e., normalization, padding, random \n    flipping, and random cropping, that were used by Zagoruyko et al. (https://arxiv.org/abs/1605.07146) when \n    training the wide residual networks for the CIFAR-10 dataset. \n    \n    :param string root: the root directory for saving and loading the CIFAR-10 dataset.\n    :param int batch_size: the size of mini-batchs to sample from the data loaders when training the neural network.\n    :param int num_workers: number of parallel CPU workers to use for loading the CIFAR-10 dataset.\n    \"\"\"", "\n", "# For evaluation, we normalize the mean and the variance of the dataset to be 0 and 1, respectively.", "\n", "# Specifically, (0.4914, 0.4822, 0.4465) and (0.247, 0.243, 0.261) are the mean and the standard deviation computed", "\n", "# from the raw CIFAR-10 dataset.", "\n", "eval_transform", "=", "T", ".", "Compose", "(", "[", "T", ".", "ToTensor", "(", ")", ",", "T", ".", "Normalize", "(", "np", ".", "array", "(", "CIFAR10_MEAN", ")", ",", "np", ".", "array", "(", "CIFAR10_AVERAGE", ")", ")", "]", ")", "\n", "# For training, we (a) pad the images with four pixels on each side, (b) randomly flip the image in horizontal way,", "\n", "# (c) randomly crop the image to have size of 32x32 and (d) normalize images as in evaluation.", "\n", "train_transform", "=", "T", ".", "Compose", "(", "\n", "[", "\n", "T", ".", "Pad", "(", "CIFAR10_PAD_SIZE", ",", "padding_mode", "=", "\"reflect\"", ")", ",", "\n", "T", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "T", ".", "RandomCrop", "(", "CIFAR10_CROP_SIZE", ")", ",", "\n", "eval_transform", ",", "\n", "]", "\n", ")", "\n", "\n", "# Make training dataset (for updating weight of neural networks) and validation dataset (for choosing the", "\n", "# hyper-parameters of training). To this end, we need to split the \"train\" dataset (pre-defined in torchvision)", "\n", "# into two parts, with sizes of CIFAR10_TRAIN_SIZE and CIFAR10_VALIDATION_SIZE for training and validataion dataset,", "\n", "# respectively.", "\n", "\n", "train_and_validation_dataset_with_train_transform", "=", "torchvision", ".", "datasets", ".", "CIFAR10", "(", "\n", "root", "=", "root", ",", "train", "=", "True", ",", "download", "=", "True", ",", "transform", "=", "train_transform", "\n", ")", "\n", "train_and_validation_dataset_with_eval_transform", "=", "torchvision", ".", "datasets", ".", "CIFAR10", "(", "\n", "root", "=", "root", ",", "train", "=", "True", ",", "download", "=", "False", ",", "transform", "=", "eval_transform", "\n", ")", "\n", "\n", "train_and_validation_indices", "=", "torch", ".", "randperm", "(", "len", "(", "train_and_validation_dataset_with_train_transform", ")", ")", "\n", "train_indices", "=", "train_and_validation_indices", "[", ":", "CIFAR10_TRAIN_SIZE", "]", "\n", "validation_indices", "=", "train_and_validation_indices", "[", "CIFAR10_TRAIN_SIZE", ":", "CIFAR10_TRAIN_SIZE", "+", "CIFAR10_VALIDATION_SIZE", "]", "\n", "\n", "train_dataset", "=", "torch", ".", "utils", ".", "data", ".", "Subset", "(", "train_and_validation_dataset_with_train_transform", ",", "train_indices", ")", "\n", "validation_dataset", "=", "torch", ".", "utils", ".", "data", ".", "Subset", "(", "train_and_validation_dataset_with_eval_transform", ",", "validation_indices", ")", "\n", "\n", "# Make test dataset", "\n", "test_dataset", "=", "torchvision", ".", "datasets", ".", "CIFAR10", "(", "root", "=", "root", ",", "train", "=", "False", ",", "download", "=", "False", ",", "transform", "=", "eval_transform", ")", "\n", "\n", "# Make data loaders", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "train_dataset", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "num_workers", "\n", ")", "\n", "validation_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "validation_dataset", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "num_workers", "\n", ")", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "test_dataset", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "num_workers", "\n", ")", "\n", "\n", "return", "train_loader", ",", "validation_loader", ",", "test_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.LearningRateUpdater.__init__": [[29, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lr_scheduler", ")", ":", "\n", "        ", "self", ".", "lr_scheduler", "=", "lr_scheduler", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.LearningRateUpdater.__call__": [[32, 34], ["util.LearningRateUpdater.lr_scheduler.step"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "engine", ")", ":", "\n", "        ", "self", ".", "lr_scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.MetricLogger.__init__": [[41, 44], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "evaluator", ",", "eval_loader", ")", ":", "\n", "        ", "self", ".", "evaluator", "=", "evaluator", "\n", "self", ".", "eval_loader", "=", "eval_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.MetricLogger.__call__": [[45, 57], ["print", "print", "util.MetricLogger.evaluator.run", "print"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "engine", ")", ":", "\n", "        ", "epoch", "=", "engine", ".", "state", ".", "epoch", "\n", "max_epochs", "=", "engine", ".", "state", ".", "max_epochs", "\n", "loss", "=", "engine", ".", "state", ".", "metrics", "[", "\"loss\"", "]", "\n", "accuracy", "=", "engine", ".", "state", ".", "metrics", "[", "\"accuracy\"", "]", "\n", "\n", "print", "(", "f\"Epoch {epoch}/{max_epochs}\"", ")", "\n", "print", "(", "f\"Train statistics: loss: {loss:.4f}, accuracy: {accuracy:3.4f}\"", ")", "\n", "\n", "self", ".", "evaluator", ".", "run", "(", "self", ".", "eval_loader", ")", "\n", "eval_accuracy", "=", "self", ".", "evaluator", ".", "state", ".", "metrics", "[", "\"accuracy\"", "]", "\n", "print", "(", "f\"Evaluation statistics: accuracy: {eval_accuracy:3.4f}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchEvaluator.__init__": [[68, 71], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchEvaluator.__call__": [[72, 78], ["util.BatchEvaluator.model.eval", "util.prepare_batch", "torch.no_grad", "util.BatchEvaluator.model"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.prepare_batch"], ["", "def", "__call__", "(", "self", ",", "evaluator", ",", "batch", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "image", ",", "label", "=", "prepare_batch", "(", "batch", ",", "self", ".", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "logit", "=", "self", ".", "model", "(", "image", ")", "[", "0", "]", "\n", "", "return", "{", "\"logit\"", ":", "logit", ",", "\"label\"", ":", "label", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchUpdaterWithoutTransfer.__init__": [[90, 95], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "optimizer", ",", "criterion", ",", "device", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "criterion", "=", "criterion", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchUpdaterWithoutTransfer.__call__": [[96, 107], ["util.BatchUpdaterWithoutTransfer.model.train", "util.BatchUpdaterWithoutTransfer.optimizer.zero_grad", "util.prepare_batch", "util.BatchUpdaterWithoutTransfer.criterion", "util.BatchUpdaterWithoutTransfer.backward", "util.BatchUpdaterWithoutTransfer.optimizer.step", "util.BatchUpdaterWithoutTransfer.model", "util.BatchUpdaterWithoutTransfer.item"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.prepare_batch"], ["", "def", "__call__", "(", "self", ",", "trainer", ",", "batch", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "image", ",", "label", "=", "prepare_batch", "(", "batch", ",", "self", ".", "device", ")", "\n", "logit", "=", "self", ".", "model", "(", "image", ")", "[", "0", "]", "\n", "loss", "=", "self", ".", "criterion", "(", "logit", ",", "label", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "output", "=", "{", "\"logit\"", ":", "logit", ",", "\"label\"", ":", "label", ",", "\"loss\"", ":", "loss", ".", "item", "(", ")", "}", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchUpdaterWithTransfer.__init__": [[122, 128], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "teacher_model", ",", "optimizer", ",", "criterion", ",", "device", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "teacher_model", "=", "teacher_model", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "criterion", "=", "criterion", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.BatchUpdaterWithTransfer.__call__": [[129, 153], ["util.BatchUpdaterWithTransfer.model.train", "util.BatchUpdaterWithTransfer.optimizer.zero_grad", "util.prepare_batch", "util.BatchUpdaterWithTransfer.model", "util.BatchUpdaterWithTransfer.criterion", "util.BatchUpdaterWithTransfer.backward", "util.BatchUpdaterWithTransfer.optimizer.step", "torch.no_grad", "util.BatchUpdaterWithTransfer.teacher_model", "util.BatchUpdaterWithTransfer.item"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.synthetic_info_bottleneck.algorithm.Algorithm.train", "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.prepare_batch"], ["", "def", "__call__", "(", "self", ",", "trainer", ",", "batch", ")", ":", "\n", "        ", "\"\"\"\n        :param ignite.engine.Engine trainer: Ignite engine class for training the model.\n        :param tuple(torch.Tensor) batch: tuple of samples for training the model.\n        \"\"\"", "\n", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "image", ",", "label", "=", "prepare_batch", "(", "batch", ",", "self", ".", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "teacher_logit", ",", "teacher_features", "=", "self", ".", "teacher_model", "(", "image", ")", "\n", "\n", "", "logit", ",", "teacher_feature_preds", "=", "self", ".", "model", "(", "image", ")", "\n", "loss", "=", "self", ".", "criterion", "(", "\n", "logit", "=", "logit", ",", "\n", "label", "=", "label", ",", "\n", "teacher_feature_preds", "=", "teacher_feature_preds", ",", "\n", "teacher_logit", "=", "teacher_logit", ",", "\n", "teacher_features", "=", "teacher_features", ",", "\n", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "return", "{", "\"logit\"", ":", "logit", ",", "\"label\"", ":", "label", ",", "\"loss\"", ":", "loss", ".", "item", "(", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.prepare_batch": [[7, 12], ["image.to.to", "label.to.to"], "function", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to"], ["def", "prepare_batch", "(", "batch", ",", "device", ")", ":", "\n", "    ", "image", ",", "label", "=", "batch", "\n", "image", "=", "image", ".", "to", "(", "device", ")", "\n", "label", "=", "label", ".", "to", "(", "device", ")", "\n", "return", "image", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.var_info_distil.util.attach_pbar_and_metrics": [[14, 22], ["ignite.metrics.Average", "ignite.metrics.Accuracy", "ignite.contrib.handlers.tqdm_logger.ProgressBar", "ignite.metrics.Average.attach", "ignite.metrics.Accuracy.attach", "ignite.metrics.Accuracy.attach", "ignite.contrib.handlers.tqdm_logger.ProgressBar.attach"], "function", ["None"], ["", "def", "attach_pbar_and_metrics", "(", "trainer", ",", "evaluator", ")", ":", "\n", "    ", "loss_metric", "=", "Average", "(", "output_transform", "=", "lambda", "output", ":", "output", "[", "\"loss\"", "]", ")", "\n", "accuracy_metric", "=", "Accuracy", "(", "output_transform", "=", "lambda", "output", ":", "(", "output", "[", "\"logit\"", "]", ",", "output", "[", "\"label\"", "]", ")", ")", "\n", "pbar", "=", "ProgressBar", "(", ")", "\n", "loss_metric", ".", "attach", "(", "trainer", ",", "\"loss\"", ")", "\n", "accuracy_metric", ".", "attach", "(", "trainer", ",", "\"accuracy\"", ")", "\n", "accuracy_metric", ".", "attach", "(", "evaluator", ",", "\"accuracy\"", ")", "\n", "pbar", ".", "attach", "(", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.__init__": [[30, 52], ["sketched_kernels.SketchedKernels.allocate_memory"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.allocate_memory"], ["def", "__init__", "(", "self", ",", "model", ",", "loader", ",", "imgsize", ",", "device", ",", "M", ",", "T", ",", "freq_print", ",", "beta", "=", "0.5", ")", ":", "\n", "\n", "        ", "r\"\"\"\n        Initialise variables\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "loader", "=", "loader", "\n", "self", ".", "imgsize", "=", "imgsize", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "M", "=", "M", "\n", "self", ".", "T", "=", "T", "\n", "self", ".", "freq_print", "=", "freq_print", "\n", "self", ".", "beta", "=", "beta", "\n", "\n", "\n", "self", ".", "n_samples", "=", "0", "# number of data samples in the given dataset", "\n", "self", ".", "sketched_matrices", "=", "{", "}", "\n", "self", ".", "kernel_matrices", "=", "{", "}", "\n", "\n", "# allocate CPU memory for storing sketched feature matrices", "\n", "# and sketched gradient matrices", "\n", "self", ".", "allocate_memory", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.allocate_memory": [[54, 88], ["torch.randn().to", "torch.randn().to", "torch.randn().to", "torch.randn().to", "sketched_kernels.SketchedKernels.forward_with_gradient_hooks", "range", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "len", "numpy.prod", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "rand_feats[].data.zero_", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "rand_feats[].size"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.forward_with_gradient_hooks"], ["", "def", "allocate_memory", "(", "self", ")", ":", "\n", "\n", "        ", "r\"\"\"\n\n        Forward a random input to the given neural network to compute the size of the output at each residual block,\n        and allocate memory for storing sketched feature matrices and sketched gradient matrices.\n\n        Parameters\n        --------\n        None\n\n        Returns\n        --------\n        None\n\n        \"\"\"", "\n", "\n", "# create a random input with the same size of the data samples", "\n", "# for ImageNet models in PyTorch, the input size is 3 x 224 x 224", "\n", "rand_inputs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "self", ".", "imgsize", ",", "self", ".", "imgsize", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "rand_inputs", ".", "requires_grad", "=", "True", "\n", "_", ",", "rand_feats", "=", "self", ".", "forward_with_gradient_hooks", "(", "rand_inputs", ")", "\n", "\n", "# allocate CPU memory for the sketched feature matrix and the gradient matrix for each layer", "\n", "# the size of the required memory for each layer is 2 x n_buckets x d_output,", "\n", "# since each of the sketched feature and gradient matrix requires n_buckets x d_output", "\n", "for", "i", "in", "range", "(", "len", "(", "rand_feats", ")", ")", ":", "\n", "            ", "layer_sizes", "=", "np", ".", "prod", "(", "rand_feats", "[", "i", "]", ".", "size", "(", ")", ")", "\n", "self", ".", "sketched_matrices", "[", "i", "]", "=", "torch", ".", "zeros", "(", "2", ",", "self", ".", "M", ",", "layer_sizes", ")", "\n", "rand_feats", "[", "i", "]", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "# remove random features produced from the generated random input", "\n", "", "del", "rand_feats", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.forward_with_gradient_hooks": [[90, 141], ["sketched_kernels.SketchedKernels.model.conv1", "feats.append", "sketched_kernels.SketchedKernels.model.bn1", "sketched_kernels.SketchedKernels.model.relu", "sketched_kernels.SketchedKernels.model.maxpool", "feats.append", "mod.mean", "feats.append", "sketched_kernels.SketchedKernels.model.fc", "feat.retain_grad", "mod", "feats.append"], "methods", ["None"], ["", "def", "forward_with_gradient_hooks", "(", "self", ",", "input_features", ")", ":", "\n", "\n", "        ", "r\"\"\"\n\n        Compute feature vectors by forwarding the data x into a given neural network model,\n        also register feature vectors to retain the gradient vectors w.r.t. individual ones.\n\n        The function is adapted from the model definition file provided by PyTorch:\n        https://pytorch.org/docs/stable/_modules/torchvision/models/resnet.html\n\n        Parameters\n        ---------\n        model : PyTorch model instance\n            the given neural network model\n        input_features : (n_samples, n_channels, height, width) PyTorch tensor\n            the input data\n\n\n        Returns\n        --------\n        out   : (n_samples, d_output) PyTorch tensor\n            the output of the top layer\n        feats : (n_ResBlocks) list\n            a dictionary that contains the feature vectors produced from individual Residual Blocks\n\n\n        \"\"\"", "\n", "feats", "=", "[", "input_features", "]", "\n", "out", "=", "self", ".", "model", ".", "conv1", "(", "input_features", ")", "\n", "feats", ".", "append", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "model", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "model", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "model", ".", "maxpool", "(", "out", ")", "\n", "\n", "feats", ".", "append", "(", "out", ")", "\n", "\n", "# The residual blocks in a ResNet model are grouped into four stages", "\n", "for", "layer", "in", "[", "self", ".", "model", ".", "layer1", ",", "self", ".", "model", ".", "layer2", ",", "self", ".", "model", ".", "layer3", ",", "self", ".", "model", ".", "layer4", "]", ":", "\n", "            ", "for", "mod", "in", "layer", ":", "\n", "                ", "out", "=", "mod", "(", "out", ")", "\n", "feats", ".", "append", "(", "out", ")", "\n", "\n", "", "", "out", "=", "out", ".", "mean", "(", "dim", "=", "(", "2", ",", "3", ")", ")", "\n", "feats", ".", "append", "(", "out", ")", "\n", "out", "=", "self", ".", "model", ".", "fc", "(", "out", ")", "\n", "\n", "for", "feat", "in", "feats", ":", "\n", "            ", "feat", ".", "retain_grad", "(", ")", "\n", "\n", "", "return", "out", ",", "feats", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.cwt_matrix": [[143, 199], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "int", "int", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.randn().sign().float", "torch.randn().sign().float", "torch.randn().sign().float", "torch.randn().sign().float", "all_rows.append", "all_cols.append", "all_signs.append", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.randint.long", "torch.randint.long", "torch.arange().view.long", "torch.arange().view.long", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.randn().sign", "torch.randn().sign", "torch.randn().sign", "torch.randn().sign", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["None"], ["", "def", "cwt_matrix", "(", "self", ",", "n_rows", ",", "n_cols", ",", "T", ")", ":", "\n", "\n", "        ", "r\"\"\"\n\n        Generate a matrix S which represents a Clarkson-Woodruff transform in PyTorch according the following reference.\n\n        Clarkson, Kenneth L., and David P. Woodruff. \"Low-rank approximation and regression in input sparsity time.\" Journal of the ACM (JACM) 63.6 (2017): 1-45.\n\n\n        Parameters\n        --------\n        n_rows : int\n            Number of rows of S\n        n_cols : int\n            Number of columns of S\n        T : int\n            Number of nonzeros elements per column\n\n\n        Returns\n        --------\n        S : (n_rows, n_cols) PyTorch sparse matrix\n            The returned matrix has ``n_cols x T'' nonzeros entries.\n\n\n        Notes\n        --------\n        The current version only generates the sparse matrix S with the CPU backend.\n\n\n        \"\"\"", "\n", "\n", "\n", "all_rows", "=", "[", "]", "\n", "all_cols", "=", "[", "]", "\n", "all_signs", "=", "[", "]", "\n", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "\n", "            ", "chunk", "=", "int", "(", "n_rows", "/", "T", ")", "\n", "shift", "=", "int", "(", "t", "*", "chunk", ")", "\n", "\n", "rows", "=", "torch", ".", "randint", "(", "shift", ",", "shift", "+", "chunk", ",", "(", "1", ",", "n_cols", ")", ")", "\n", "cols", "=", "torch", ".", "arange", "(", "n_cols", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "signs", "=", "torch", ".", "randn", "(", "n_cols", ")", ".", "sign", "(", ")", ".", "float", "(", ")", "\n", "\n", "all_rows", ".", "append", "(", "rows", ")", "\n", "all_cols", ".", "append", "(", "cols", ")", "\n", "all_signs", ".", "append", "(", "signs", ")", "\n", "\n", "", "rows", "=", "torch", ".", "cat", "(", "all_rows", ",", "dim", "=", "1", ")", "\n", "cols", "=", "torch", ".", "cat", "(", "all_cols", ",", "dim", "=", "1", ")", "\n", "pos", "=", "torch", ".", "cat", "(", "[", "rows", ".", "long", "(", ")", ",", "cols", ".", "long", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "signs", "=", "torch", ".", "cat", "(", "all_signs", ",", "dim", "=", "0", ")", "\n", "cwt", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "pos", ",", "signs", ",", "torch", ".", "Size", "(", "[", "n_rows", ",", "n_cols", "]", ")", ")", "\n", "return", "cwt", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.cwt_sketching": [[201, 227], ["torch.sparse.mm", "torch.sparse.mm", "torch.sparse.mm", "torch.sparse.mm"], "methods", ["None"], ["", "def", "cwt_sketching", "(", "self", ",", "X", ",", "S", ")", ":", "\n", "\n", "        ", "r\"\"\"\n\n        Sketch the input matrix X with the sparse random matrix S\n\n        Parameters\n        --------\n        X : (n_samples, n_dim) dense matrix\n            matrix to be sketched\n        S : (n_sketches, n_samples) PyTorch sparse matrix\n            sparse random matrix\n\n        Returns\n        --------\n        sketched : (n_sketches, n_dim) dense matrix\n            The returned matrix is the sketched matrix which is a summary of the input matrix X\n\n\n        Notes\n        --------\n        The current version is only with the CPU backend.\n\n        \"\"\"", "\n", "sketched", "=", "torch", ".", "sparse", ".", "mm", "(", "S", ",", "X", ")", "\n", "return", "sketched", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.compute_sketched_mat": [[229, 312], ["sketched_kernels.SketchedKernels.model.eval", "enumerate", "sketched_kernels.SketchedKernels.forward_with_gradient_hooks", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "sketched_kernels.SketchedKernels.model.zero_grad", "torch.autograd.backward", "torch.autograd.backward", "torch.autograd.backward", "torch.autograd.backward", "data.size", "data.to", "target.to", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "sketched_kernels.SketchedKernels.cwt_matrix().to", "range", "print", "len", "feats[].data.view", "feats[].grad.data.view", "sketched_feats.cpu", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "sketched_grads.cpu", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "feats[].data.zero_", "feats[].grad.data.zero_", "sketched_kernels.SketchedKernels.cwt_matrix", "sketched_kernels.SketchedKernels.cwt_sketching", "sketched_kernels.SketchedKernels.cwt_sketching", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.cifar.utils.eval", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.forward_with_gradient_hooks", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.leap.leap.Leap.to", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.cwt_matrix", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.cwt_sketching", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.cwt_sketching"], ["", "def", "compute_sketched_mat", "(", "self", ")", ":", "\n", "\n", "        ", "r\"\"\"\n\n        Given a PreActResNet model and a dataset, the module computes the sketched matrices\n        for feature and gradient vectors respectively generated from individual residual blocks.\n\n        Parameters\n        --------\n        model : PyTorch model\n            A PreActResNet model\n        loader : DataLoader\n            A iterable DataLoader instance in PyTorch\n\n        Returns\n        --------\n        No returns\n\n        Notes\n        --------\n        The module runs efficiently with GPU backend, also runs with CPU backend.\n\n        \"\"\"", "\n", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "total", "=", "0", "\n", "\n", "# Iterate through the data loader in batches:", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "self", ".", "loader", ")", ":", "\n", "\n", "# load a batch of data samples", "\n", "            ", "data", ",", "target", "=", "data", ".", "to", "(", "self", ".", "device", ")", ",", "target", ".", "to", "(", "self", ".", "device", ")", "\n", "data", ".", "requires_grad", "=", "True", "\n", "output", ",", "feats", "=", "self", ".", "forward_with_gradient_hooks", "(", "data", ")", "\n", "\n", "# calculate the log-likelihood and the predicted distribution over labels", "\n", "logp", "=", "torch", ".", "log_softmax", "(", "output", ",", "dim", "=", "-", "1", ")", "\n", "prob", "=", "torch", ".", "softmax", "(", "output", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# calculate the q distribution which is a smoothed predicted distribution", "\n", "q_dist", "=", "(", "prob", "**", "self", ".", "beta", ")", "/", "(", "prob", "**", "self", ".", "beta", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "# zero gradients in the models and calculate the gradients w.r.t. feature maps", "\n", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "torch", ".", "autograd", ".", "backward", "(", "logp", ",", "grad_tensors", "=", "q_dist", ")", "\n", "\n", "batchsize", "=", "data", ".", "size", "(", "dim", "=", "0", ")", "\n", "self", ".", "n_samples", "+=", "batchsize", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "# generate a CWT matrix", "\n", "                ", "s", "=", "self", ".", "cwt_matrix", "(", "self", ".", "M", ",", "batchsize", ",", "self", ".", "T", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# calculate the sketched feature vectors and gradient vectors for individual layers", "\n", "for", "layer_id", "in", "range", "(", "len", "(", "feats", ")", ")", ":", "\n", "\n", "# number of data points x dimension", "\n", "                    ", "batched_feats", "=", "feats", "[", "layer_id", "]", ".", "data", ".", "view", "(", "batchsize", ",", "-", "1", ")", "\n", "batched_grads", "=", "feats", "[", "layer_id", "]", ".", "grad", ".", "data", ".", "view", "(", "batchsize", ",", "-", "1", ")", "\n", "\n", "# sketch the feature vectors into buckets", "\n", "# accumulate buckets on CPU backend", "\n", "sketched_feats", "=", "self", ".", "cwt_sketching", "(", "batched_feats", ",", "s", ")", "/", "(", "self", ".", "T", "**", "0.5", ")", "\n", "self", ".", "sketched_matrices", "[", "layer_id", "]", "[", "0", "]", "+=", "sketched_feats", ".", "cpu", "(", ")", "\n", "\n", "# delete intermediate variables to create memory for the following matrix multiplication", "\n", "del", "batched_feats", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "# sketch the gradient vectors into buckets", "\n", "sketched_grads", "=", "self", ".", "cwt_sketching", "(", "batched_grads", ",", "s", ")", "/", "(", "self", ".", "T", "**", "0.5", ")", "\n", "self", ".", "sketched_matrices", "[", "layer_id", "]", "[", "1", "]", "+=", "sketched_grads", ".", "cpu", "(", ")", "\n", "\n", "# delete intermediate variables to create memory for the following matrix multiplication", "\n", "del", "batched_grads", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "feats", "[", "layer_id", "]", ".", "data", ".", "zero_", "(", ")", "\n", "feats", "[", "layer_id", "]", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "if", "batch_idx", "%", "self", ".", "freq_print", "==", "0", ":", "\n", "                ", "print", "(", "\"finished {:d}/{:d}\"", ".", "format", "(", "batch_idx", ",", "len", "(", "self", ".", "loader", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.compute_sketched_kernels": [[314, 337], ["sketched_kernels.SketchedKernels.compute_sketched_mat", "range", "len", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "sketched_kernels.SketchedKernels.sketched_matrices[].transpose"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sketched_kernels.SketchedKernels.compute_sketched_mat"], ["", "", "", "def", "compute_sketched_kernels", "(", "self", ")", ":", "\n", "\n", "        ", "r\"\"\"\n        Compute the sketched feature matrices and sketched gradient matrices first,\n        and then calculate the kernel matrices for individual layers.\n\n        Parameters\n        --------\n        None\n\n        Returns\n        --------\n        No returns\n\n        \"\"\"", "\n", "\n", "self", ".", "compute_sketched_mat", "(", ")", "\n", "\n", "for", "layer_id", "in", "range", "(", "len", "(", "self", ".", "sketched_matrices", ")", ")", ":", "\n", "            ", "temp", "=", "torch", ".", "bmm", "(", "self", ".", "sketched_matrices", "[", "layer_id", "]", ",", "self", ".", "sketched_matrices", "[", "layer_id", "]", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "self", ".", "kernel_matrices", "[", "layer_id", "]", "=", "(", "temp", "[", "0", "]", "*", "temp", "[", "1", "]", ")", ".", "numpy", "(", ")", "\n", "del", "self", ".", "sketched_matrices", "[", "layer_id", "]", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.__init__": [[34, 36], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "...", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.centering": [[37, 42], ["kmat.mean", "kmat.mean", "kmat.mean"], "methods", ["None"], ["", "def", "centering", "(", "self", ",", "kmat", ")", ":", "\n", "        ", "r\"\"\"\n        Centering the kernel matrix\n        \"\"\"", "\n", "return", "kmat", "-", "kmat", ".", "mean", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "-", "kmat", ".", "mean", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "kmat", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.euclidean": [[43, 48], ["numpy.linalg.norm"], "methods", ["None"], ["", "def", "euclidean", "(", "self", ",", "kmat_1", ",", "kmat_2", ")", ":", "\n", "        ", "r\"\"\"\n        Compute the Euclidean distance between two kernel matrices\n        \"\"\"", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "kmat_1", "-", "kmat_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.cka": [[49, 57], ["sim_indices.SimIndex.centering", "sim_indices.SimIndex.centering", "numpy.linalg.norm", "numpy.trace", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.centering", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.centering"], ["", "def", "cka", "(", "self", ",", "kmat_1", ",", "kmat_2", ")", ":", "\n", "        ", "r\"\"\"\n        Compute the Centred Kernel Alignment between two kernel matrices.\n        \\rho(K_1, K_2) = \\Tr (K_1 @ K_2) / ||K_1||_F / ||K_2||_F\n        \"\"\"", "\n", "kmat_1", "=", "self", ".", "centering", "(", "kmat_1", ")", "\n", "kmat_2", "=", "self", ".", "centering", "(", "kmat_2", ")", "\n", "return", "np", ".", "trace", "(", "kmat_1", "@", "kmat_2", ")", "/", "np", ".", "linalg", ".", "norm", "(", "kmat_1", ")", "/", "np", ".", "linalg", ".", "norm", "(", "kmat_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.nbs": [[58, 66], ["sim_indices.SimIndex.centering", "sim_indices.SimIndex.centering", "sum", "numpy.real().clip", "numpy.trace", "numpy.trace", "numpy.real", "numpy.linalg.eigvals"], "methods", ["home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.centering", "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.sim_indices.SimIndex.centering"], ["", "def", "nbs", "(", "self", ",", "kmat_1", ",", "kmat_2", ")", ":", "\n", "        ", "r\"\"\"\n        Compute the Normalised Bures Similarity between two kernel matrices.\n        \\rho(K_1, K_2) = \\Tr( (K_1^{1/2} @ K_2 @ K_1^{1/2})^{1/2} ) / \\Tr(K_1) /  \\Tr(K_2)\n        \"\"\"", "\n", "kmat_1", "=", "self", ".", "centering", "(", "kmat_1", ")", "\n", "kmat_2", "=", "self", ".", "centering", "(", "kmat_2", ")", "\n", "return", "sum", "(", "np", ".", "real", "(", "np", ".", "linalg", ".", "eigvals", "(", "kmat_1", "@", "kmat_2", ")", ")", ".", "clip", "(", "0.", ")", "**", "0.5", ")", "/", "(", "(", "np", ".", "trace", "(", "kmat_1", ")", "*", "np", ".", "trace", "(", "kmat_2", ")", ")", "**", "0.5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.utils.load_model": [[32, 61], ["getattr"], "function", ["None"], ["            ", "type_data", "=", "str", "(", "model_dict", "[", "k", "]", ".", "dtype", ")", "\n", "model_dict", "[", "k", "]", "=", "[", "type_data", ",", "model_dict", "[", "k", "]", ".", "tolist", "(", ")", "]", "\n", "# Replace any tuple with ['tuple', tuple_as_list]", "\n", "# e.g (1,2) -> ['tuple', [1,2]]", "\n", "", "if", "isinstance", "(", "model_dict", "[", "k", "]", ",", "tuple", ")", ":", "\n", "            ", "model_dict", "[", "k", "]", "=", "[", "keys", ".", "TUPLE", ",", "list", "(", "model_dict", "[", "k", "]", ")", "]", "\n", "", "", "output_dict", "[", "keys", ".", "MODEL", "]", "=", "{", "}", "\n", "# Model params are public attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", "=", "target_model", ".", "get_params", "(", ")", "\n", "# Serialise all private attributes", "\n", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "=", "{", "}", "\n", "for", "k", "in", "model_dict", ":", "\n", "# Serialize private parameters as attributes", "\n", "        ", "if", "k", "[", "-", "1", "]", "==", "'_'", "or", "k", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "output_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "=", "model_dict", "[", "k", "]", "\n", "", "", "return", "output_dict", "\n", "\n", "\n", "", "def", "sklearn_model_from_dict", "(", "model_class", ",", "input_dict", ")", ":", "\n", "# Initialize model with serialized model parameters", "\n", "    ", "model", "=", "model_class", "(", "**", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "PARAMS", "]", ")", "\n", "# Set model attributes", "\n", "for", "k", "in", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", ":", "\n", "# Unpack tuples and np.arrays that were serialised as lists", "\n", "        ", "if", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ",", "list", ")", "and", "isinstance", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", ",", "str", ")", "and", "type", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", "==", "list", ":", "\n", "            ", "if", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "0", "]", "==", "keys", ".", "TUPLE", ":", "\n", "                ", "setattr", "(", "model", ",", "k", ",", "tuple", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_xfer.nn_similarity_index.utils.load_dataset": [[63, 127], ["torchvision.Normalize", "torchvision.Compose", "torchvision.Compose", "getattr", "getattr.", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "name.upper", "torchvision.RandomResizedCrop", "torchvision.RandomHorizontalFlip", "torchvision.ToTensor", "torchvision.Resize", "torchvision.ToTensor", "getattr"], "function", ["None"], ["type_data", "=", "eval", "(", "type_data", ")", "\n", "setattr", "(", "model", ",", "k", ",", "np", ".", "array", "(", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", "[", "1", "]", ",", "dtype", "=", "type_data", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "setattr", "(", "model", ",", "k", ",", "input_dict", "[", "keys", ".", "MODEL", "]", "[", "keys", ".", "ATTRS", "]", "[", "k", "]", ")", "\n", "", "", "return", "model", "\n", "\n", "\n", "", "def", "_assert_repurposer_file_exists", "(", "repurposer_file_list", ")", ":", "\n", "    ", "for", "file_name", "in", "repurposer_file_list", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "file_name", ")", ":", "\n", "            ", "raise", "NameError", "(", "'Cannot find repurposer file ({})'", ".", "format", "(", "file_name", ")", ")", "\n", "\n", "\n", "", "", "", "def", "save_mxnet_model", "(", "model", ",", "file_path_prefix", ",", "epoch", ",", "provide_data", "=", "None", ",", "provide_label", "=", "None", ")", ":", "\n", "    ", "if", "not", "model", ".", "binded", ":", "\n", "        ", "if", "provide_data", "is", "None", "or", "provide_label", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"provide_data and provide_label are required because mxnet module is not binded\"", ")", "\n", "", "model", ".", "bind", "(", "data_shapes", "=", "provide_data", ",", "label_shapes", "=", "provide_label", ")", "\n", "", "model", ".", "save_checkpoint", "(", "file_path_prefix", ",", "epoch", ")", "\n", "\n", "\n", "", "def", "save_json", "(", "file_prefix", ",", "output_dict", ")", ":", "\n", "    ", "with", "open", "(", "file_prefix", "+", "consts", ".", "JSON_SUFFIX", ",", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "obj", "=", "output_dict", ",", "fp", "=", "fp", ")", "\n", "\n", "\n", "", "", "def", "serialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "mx", ".", "cpu", ":", "\n", "        ", "return", "keys", ".", "CPU", "\n", "", "elif", "context_function", "==", "mx", ".", "gpu", ":", "\n", "        ", "return", "keys", ".", "GPU", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "\n", "\n", "", "", "def", "deserialize_ctx_fn", "(", "context_function", ")", ":", "\n", "    ", "if", "context_function", "==", "keys", ".", "CPU", ":", "\n", "        ", "return", "mx", ".", "cpu", "\n", "", "elif", "context_function", "==", "keys", ".", "GPU", ":", "\n", "        ", "return", "mx", ".", "gpu", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unexpected context function {}'", ".", "format", "(", "context_function", ")", ")", "\n", "", "", ""]]}