{"home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.temporal_nms.compute_temporal_iou": [[6, 23], ["max", "max", "min", "min", "max"], "function", ["None"], ["def", "compute_temporal_iou", "(", "pred", ",", "gt", ")", ":", "\n", "    ", "\"\"\" deprecated due to performance concerns\n    compute intersection-over-union along temporal axis\n    Args:\n        pred: [st (float), ed (float)]\n        gt: [st (float), ed (float)]\n    Returns:\n        iou (float):\n\n    Ref: https://github.com/LisaAnne/LocalizingMoments/blob/master/utils/eval.py\n    \"\"\"", "\n", "intersection", "=", "max", "(", "0", ",", "min", "(", "pred", "[", "1", "]", ",", "gt", "[", "1", "]", ")", "-", "max", "(", "pred", "[", "0", "]", ",", "gt", "[", "0", "]", ")", ")", "\n", "union", "=", "max", "(", "pred", "[", "1", "]", ",", "gt", "[", "1", "]", ")", "-", "min", "(", "pred", "[", "0", "]", ",", "gt", "[", "0", "]", ")", "# not the correct union though", "\n", "if", "union", "==", "0", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "return", "1.0", "*", "intersection", "/", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.temporal_nms.temporal_nms": [[25, 75], ["sorted", "len", "rstart.append", "rend.append", "rscore.append", "rstart.append", "rend.append", "rscore.append", "len", "len", "len", "tstart.pop", "tend.pop", "tscore.pop", "len", "len", "tstart.pop", "tend.pop", "tscore.pop", "zip", "temporal_nms.compute_temporal_iou", "tstart.pop", "tend.pop", "tscore.pop"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.temporal_nms.compute_temporal_iou"], ["", "", "def", "temporal_nms", "(", "predictions", ",", "nms_thd", ",", "max_after_nms", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        predictions: list(sublist), each sublist is [st (float), ed(float), score (float)],\n            note larger scores are better and are preserved. For metrics that are better when smaller,\n            please convert to its negative, e.g., convert distance to negative distance.\n        nms_thd: float in [0, 1]\n        max_after_nms:\n    Returns:\n        predictions_after_nms: list(sublist), each sublist is [st (float), ed(float), score (float)]\n    References:\n        https://github.com/wzmsltw/BSN-boundary-sensitive-network/blob/7b101fc5978802aa3c95ba5779eb54151c6173c6/Post_processing.py#L42\n    \"\"\"", "\n", "if", "len", "(", "predictions", ")", "==", "1", ":", "# only has one prediction, no need for nms", "\n", "        ", "return", "predictions", "\n", "\n", "", "predictions", "=", "sorted", "(", "predictions", ",", "key", "=", "lambda", "x", ":", "x", "[", "2", "]", ",", "reverse", "=", "True", ")", "# descending order", "\n", "\n", "tstart", "=", "[", "e", "[", "0", "]", "for", "e", "in", "predictions", "]", "\n", "tend", "=", "[", "e", "[", "1", "]", "for", "e", "in", "predictions", "]", "\n", "tscore", "=", "[", "e", "[", "2", "]", "for", "e", "in", "predictions", "]", "\n", "rstart", "=", "[", "]", "\n", "rend", "=", "[", "]", "\n", "rscore", "=", "[", "]", "\n", "while", "len", "(", "tstart", ")", ">", "1", "and", "len", "(", "rscore", ")", "<", "max_after_nms", ":", "# max 100 after nms", "\n", "        ", "idx", "=", "1", "\n", "while", "idx", "<", "len", "(", "tstart", ")", ":", "# compare with every prediction in the list.", "\n", "            ", "if", "compute_temporal_iou", "(", "[", "tstart", "[", "0", "]", ",", "tend", "[", "0", "]", "]", ",", "[", "tstart", "[", "idx", "]", ",", "tend", "[", "idx", "]", "]", ")", ">", "nms_thd", ":", "\n", "# rm highly overlapped lower score entries.", "\n", "                ", "tstart", ".", "pop", "(", "idx", ")", "\n", "tend", ".", "pop", "(", "idx", ")", "\n", "tscore", ".", "pop", "(", "idx", ")", "\n", "# print(\"--------------------------------\")", "\n", "# print(compute_temporal_iou([tstart[0], tend[0]], [tstart[idx], tend[idx]]))", "\n", "# print([tstart[0], tend[0]], [tstart[idx], tend[idx]])", "\n", "# print(tstart.pop(idx), tend.pop(idx), tscore.pop(idx))", "\n", "", "else", ":", "\n", "# move to next", "\n", "                ", "idx", "+=", "1", "\n", "", "", "rstart", ".", "append", "(", "tstart", ".", "pop", "(", "0", ")", ")", "\n", "rend", ".", "append", "(", "tend", ".", "pop", "(", "0", ")", ")", "\n", "rscore", ".", "append", "(", "tscore", ".", "pop", "(", "0", ")", ")", "\n", "\n", "", "if", "len", "(", "rscore", ")", "<", "max_after_nms", "and", "len", "(", "tstart", ")", ">=", "1", ":", "# add the last, possibly empty.", "\n", "        ", "rstart", ".", "append", "(", "tstart", ".", "pop", "(", "0", ")", ")", "\n", "rend", ".", "append", "(", "tend", ".", "pop", "(", "0", ")", ")", "\n", "rscore", ".", "append", "(", "tscore", ".", "pop", "(", "0", ")", ")", "\n", "\n", "", "predictions_after_nms", "=", "[", "[", "st", ",", "ed", ",", "s", "]", "for", "s", ",", "st", ",", "ed", "in", "zip", "(", "rscore", ",", "rstart", ",", "rend", ")", "]", "\n", "return", "predictions_after_nms", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.model_utils.count_parameters": [[1, 15], ["sum", "sum", "print", "p.numel", "p.numel", "model.parameters", "model.parameters"], "function", ["None"], ["def", "count_parameters", "(", "model", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"Count number of parameters in PyTorch model,\n    References: https://discuss.pytorch.org/t/how-do-i-check-the-number-of-parameters-of-a-model/4325/7.\n\n    from utils.utils import count_parameters\n    count_parameters(model)\n    import sys\n    sys.exit(1)\n    \"\"\"", "\n", "n_all", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "\n", "n_trainable", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Parameter Count: all {:,d}; trainable {:,d}\"", ".", "format", "(", "n_all", ",", "n_trainable", ")", ")", "\n", "", "return", "n_all", ",", "n_trainable", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.__init__": [[122, 130], ["basic_utils.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "self", ".", "max", "=", "-", "1e10", "\n", "self", ".", "min", "=", "1e10", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.reset": [[131, 138], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "self", ".", "max", "=", "-", "1e10", "\n", "self", ".", "min", "=", "1e10", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update": [[139, 146], ["max", "min"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "max", "=", "max", "(", "val", ",", "self", ".", "max", ")", "\n", "self", ".", "min", "=", "min", "(", "val", ",", "self", ".", "min", ")", "\n", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.load_pickle": [[10, 13], ["open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["def", "load_pickle", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_pickle": [[15, 18], ["open", "pickle.dump"], "function", ["None"], ["", "", "def", "save_pickle", "(", "data", ",", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"wb\"", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "data", ",", "f", ",", "protocol", "=", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.load_json": [[20, 23], ["open", "json.load"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["", "", "def", "load_json", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "return", "json", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_json": [[25, 31], ["open", "f.write", "json.dump", "json.dumps"], "function", ["None"], ["", "", "def", "save_json", "(", "data", ",", "filename", ",", "save_pretty", "=", "False", ",", "sort_keys", "=", "False", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "if", "save_pretty", ":", "\n", "            ", "f", ".", "write", "(", "json", ".", "dumps", "(", "data", ",", "indent", "=", "4", ",", "sort_keys", "=", "sort_keys", ")", ")", "\n", "", "else", ":", "\n", "            ", "json", ".", "dump", "(", "data", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.load_jsonl": [[33, 36], ["open", "json.loads", "l.strip", "f.readlines"], "function", ["None"], ["", "", "", "def", "load_jsonl", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "return", "[", "json", ".", "loads", "(", "l", ".", "strip", "(", "\"\\n\"", ")", ")", "for", "l", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_jsonl": [[38, 42], ["open", "f.write", "json.dumps"], "function", ["None"], ["", "", "def", "save_jsonl", "(", "data", ",", "filename", ")", ":", "\n", "    ", "\"\"\"data is a list\"\"\"", "\n", "with", "open", "(", "filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "json", ".", "dumps", "(", "e", ")", "for", "e", "in", "data", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_lines": [[44, 47], ["open", "f.write"], "function", ["None"], ["", "", "def", "save_lines", "(", "list_of_str", ",", "filepath", ")", ":", "\n", "    ", "with", "open", "(", "filepath", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "list_of_str", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.read_lines": [[49, 52], ["open", "e.strip", "f.readlines"], "function", ["None"], ["", "", "def", "read_lines", "(", "filepath", ")", ":", "\n", "    ", "with", "open", "(", "filepath", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "return", "[", "e", ".", "strip", "(", "\"\\n\"", ")", "for", "e", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.mkdirp": [[54, 57], ["os.path.exists", "os.makedirs"], "function", ["None"], ["", "", "def", "mkdirp", "(", "p", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "p", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.flat_list_of_lists": [[59, 62], ["None"], "function", ["None"], ["", "", "def", "flat_list_of_lists", "(", "l", ")", ":", "\n", "    ", "\"\"\"flatten a list of lists [[1,2], [3,4]] to [1,2,3,4]\"\"\"", "\n", "return", "[", "item", "for", "sublist", "in", "l", "for", "item", "in", "sublist", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.convert_to_seconds": [[64, 71], ["float", "hms_time.split"], "function", ["None"], ["", "def", "convert_to_seconds", "(", "hms_time", ")", ":", "\n", "    ", "\"\"\" convert '00:01:12' to 72 seconds.\n    :hms_time (str): time in comma separated string, e.g. '00:01:12'\n    :return (int): time in seconds, e.g. 72\n    \"\"\"", "\n", "times", "=", "[", "float", "(", "t", ")", "for", "t", "in", "hms_time", ".", "split", "(", "\":\"", ")", "]", "\n", "return", "times", "[", "0", "]", "*", "3600", "+", "times", "[", "1", "]", "*", "60", "+", "times", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_video_name_from_url": [[73, 75], ["url.split"], "function", ["None"], ["", "def", "get_video_name_from_url", "(", "url", ")", ":", "\n", "    ", "return", "url", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "[", ":", "-", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.merge_dicts": [[77, 82], ["list_dicts[].copy", "range", "len", "list_dicts[].copy.update"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["", "def", "merge_dicts", "(", "list_dicts", ")", ":", "\n", "    ", "merged_dict", "=", "list_dicts", "[", "0", "]", ".", "copy", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "list_dicts", ")", ")", ":", "\n", "        ", "merged_dict", ".", "update", "(", "list_dicts", "[", "i", "]", ")", "\n", "", "return", "merged_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.l2_normalize_np_array": [[84, 87], ["numpy.linalg.norm"], "function", ["None"], ["", "def", "l2_normalize_np_array", "(", "np_array", ",", "eps", "=", "1e-5", ")", ":", "\n", "    ", "\"\"\"np_array: np.ndarray, (*, D), where the last dim will be normalized\"\"\"", "\n", "return", "np_array", "/", "(", "np", ".", "linalg", ".", "norm", "(", "np_array", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.make_zipfile": [[89, 118], ["os.path.abspath", "zipfile.ZipFile", "os.walk", "os.path.join", "zf.write", "os.path.join", "os.path.join", "zf.write", "subdirs.remove", "subdirs.remove", "to_rm.append", "len", "os.path.splitext", "len"], "function", ["None"], ["", "def", "make_zipfile", "(", "src_dir", ",", "save_path", ",", "enclosing_dir", "=", "\"\"", ",", "exclude_dirs", "=", "None", ",", "exclude_extensions", "=", "None", ",", "\n", "exclude_dirs_substring", "=", "None", ")", ":", "\n", "    ", "\"\"\"make a zip file of root_dir, save it to save_path.\n    exclude_paths will be excluded if it is a subdir of root_dir.\n    An enclosing_dir is added is specified.\n    \"\"\"", "\n", "abs_src", "=", "os", ".", "path", ".", "abspath", "(", "src_dir", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "save_path", ",", "\"w\"", ")", "as", "zf", ":", "\n", "        ", "for", "dirname", ",", "subdirs", ",", "files", "in", "os", ".", "walk", "(", "src_dir", ")", ":", "\n", "            ", "if", "exclude_dirs", "is", "not", "None", ":", "\n", "                ", "for", "e_p", "in", "exclude_dirs", ":", "\n", "                    ", "if", "e_p", "in", "subdirs", ":", "\n", "                        ", "subdirs", ".", "remove", "(", "e_p", ")", "\n", "", "", "", "if", "exclude_dirs_substring", "is", "not", "None", ":", "\n", "                ", "to_rm", "=", "[", "]", "\n", "for", "d", "in", "subdirs", ":", "\n", "                    ", "if", "exclude_dirs_substring", "in", "d", ":", "\n", "                        ", "to_rm", ".", "append", "(", "d", ")", "\n", "", "", "for", "e", "in", "to_rm", ":", "\n", "                    ", "subdirs", ".", "remove", "(", "e", ")", "\n", "", "", "arcname", "=", "os", ".", "path", ".", "join", "(", "enclosing_dir", ",", "dirname", "[", "len", "(", "abs_src", ")", "+", "1", ":", "]", ")", "\n", "zf", ".", "write", "(", "dirname", ",", "arcname", ")", "\n", "for", "filename", "in", "files", ":", "\n", "                ", "if", "exclude_extensions", "is", "not", "None", ":", "\n", "                    ", "if", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "in", "exclude_extensions", ":", "\n", "                        ", "continue", "# do not zip it", "\n", "", "", "absname", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "filename", ")", "\n", "arcname", "=", "os", ".", "path", ".", "join", "(", "enclosing_dir", ",", "absname", "[", "len", "(", "abs_src", ")", "+", "1", ":", "]", ")", "\n", "zf", ".", "write", "(", "absname", ",", "arcname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.dissect_by_lengths": [[148, 165], ["range", "len", "length_indices.append", "len", "sum", "range", "len", "range", "len", "range", "len"], "function", ["None"], ["", "", "def", "dissect_by_lengths", "(", "np_array", ",", "lengths", ",", "dim", "=", "0", ",", "assert_equal", "=", "True", ")", ":", "\n", "    ", "\"\"\"Dissect an array (N, D) into a list a sub-array,\n    np_array.shape[0] == sum(lengths), Output is a list of nd arrays, singlton dimention is kept\"\"\"", "\n", "if", "assert_equal", ":", "\n", "        ", "assert", "len", "(", "np_array", ")", "==", "sum", "(", "lengths", ")", "\n", "", "length_indices", "=", "[", "0", ",", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "lengths", ")", ")", ":", "\n", "        ", "length_indices", ".", "append", "(", "length_indices", "[", "i", "]", "+", "lengths", "[", "i", "]", ")", "\n", "", "if", "dim", "==", "0", ":", "\n", "        ", "array_list", "=", "[", "np_array", "[", "length_indices", "[", "i", "]", ":", "length_indices", "[", "i", "+", "1", "]", "]", "for", "i", "in", "range", "(", "len", "(", "lengths", ")", ")", "]", "\n", "", "elif", "dim", "==", "1", ":", "\n", "        ", "array_list", "=", "[", "np_array", "[", ":", ",", "length_indices", "[", "i", "]", ":", "length_indices", "[", "i", "+", "1", "]", "]", "for", "i", "in", "range", "(", "len", "(", "lengths", ")", ")", "]", "\n", "", "elif", "dim", "==", "2", ":", "\n", "        ", "array_list", "=", "[", "np_array", "[", ":", ",", ":", ",", "length_indices", "[", "i", "]", ":", "length_indices", "[", "i", "+", "1", "]", "]", "for", "i", "in", "range", "(", "len", "(", "lengths", ")", ")", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "array_list", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_ratio_from_counter": [[167, 172], ["counter_obj.keys", "counter_obj.values", "float", "sum", "sum"], "function", ["None"], ["", "def", "get_ratio_from_counter", "(", "counter_obj", ",", "threshold", "=", "200", ")", ":", "\n", "    ", "keys", "=", "counter_obj", ".", "keys", "(", ")", "\n", "values", "=", "counter_obj", ".", "values", "(", ")", "\n", "filtered_values", "=", "[", "counter_obj", "[", "k", "]", "for", "k", "in", "keys", "if", "k", ">", "threshold", "]", "\n", "return", "float", "(", "sum", "(", "filtered_values", ")", ")", "/", "sum", "(", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_counter_dist": [[174, 180], ["sum", "counter_object.values", "float", "collections.OrderedDict", "counter_object.items", "sorted", "collections.OrderedDict.items"], "function", ["None"], ["", "def", "get_counter_dist", "(", "counter_object", ",", "sort_type", "=", "\"none\"", ")", ":", "\n", "    ", "_sum", "=", "sum", "(", "counter_object", ".", "values", "(", ")", ")", "\n", "dist", "=", "{", "k", ":", "float", "(", "f\"{100 * v / _sum:.2f}\"", ")", "for", "k", ",", "v", "in", "counter_object", ".", "items", "(", ")", "}", "\n", "if", "sort_type", "==", "\"value\"", ":", "\n", "        ", "dist", "=", "OrderedDict", "(", "sorted", "(", "dist", ".", "items", "(", ")", ",", "reverse", "=", "True", ")", ")", "\n", "", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_show_name": [[182, 192], ["vid_name.split"], "function", ["None"], ["", "def", "get_show_name", "(", "vid_name", ")", ":", "\n", "    ", "\"\"\"\n    get tvshow name from vid_name\n    :param vid_name: video clip name\n    :return: tvshow name\n    \"\"\"", "\n", "show_list", "=", "[", "\"friends\"", ",", "\"met\"", ",", "\"castle\"", ",", "\"house\"", ",", "\"grey\"", "]", "\n", "vid_name_prefix", "=", "vid_name", ".", "split", "(", "\"_\"", ")", "[", "0", "]", "\n", "show_name", "=", "vid_name_prefix", "if", "vid_name_prefix", "in", "show_list", "else", "\"bbt\"", "\n", "return", "show_name", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_abspaths_by_ext": [[194, 207], ["isinstance", "isinstance", "tuple", "tuple", "os.path.join", "os.walk", "name.endswith", "tuple"], "function", ["None"], ["", "def", "get_abspaths_by_ext", "(", "dir_path", ",", "ext", "=", "(", "\".jpg\"", ",", ")", ")", ":", "\n", "    ", "\"\"\"Get absolute paths to files in dir_path with extensions specified by ext.\n    Note this function does work recursively.\n    \"\"\"", "\n", "if", "isinstance", "(", "ext", ",", "list", ")", ":", "\n", "        ", "ext", "=", "tuple", "(", "ext", ")", "\n", "", "if", "isinstance", "(", "ext", ",", "str", ")", ":", "\n", "        ", "ext", "=", "tuple", "(", "[", "ext", ",", "]", ")", "\n", "", "filepaths", "=", "[", "os", ".", "path", ".", "join", "(", "root", ",", "name", ")", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "dir_path", ")", "\n", "for", "name", "in", "files", "\n", "if", "name", ".", "endswith", "(", "tuple", "(", "ext", ")", ")", "]", "\n", "return", "filepaths", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.get_basename_no_ext": [[209, 212], ["os.path.splitext", "os.path.split"], "function", ["None"], ["", "def", "get_basename_no_ext", "(", "path", ")", ":", "\n", "    ", "\"\"\" '/data/movienet/240p_keyframe_feats/tt7672188.npz' --> 'tt7672188' \"\"\"", "\n", "return", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "split", "(", "path", ")", "[", "1", "]", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.dict_to_markdown": [[214, 221], ["pandas.DataFrame().transpose().to_markdown", "isinstance", "v.__repr__", "d.items", "pandas.DataFrame().transpose", "isinstance", "d.items", "pandas.DataFrame"], "function", ["None"], ["", "def", "dict_to_markdown", "(", "d", ",", "max_str_len", "=", "120", ")", ":", "\n", "# convert list into its str representation", "\n", "    ", "d", "=", "{", "k", ":", "v", ".", "__repr__", "(", ")", "if", "isinstance", "(", "v", ",", "list", ")", "else", "v", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "}", "\n", "# truncate string that is longer than max_str_len", "\n", "if", "max_str_len", "is", "not", "None", ":", "\n", "        ", "d", "=", "{", "k", ":", "v", "[", "-", "max_str_len", ":", "]", "if", "isinstance", "(", "v", ",", "str", ")", "else", "v", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "}", "\n", "", "return", "pd", ".", "DataFrame", "(", "d", ",", "index", "=", "[", "0", "]", ")", ".", "transpose", "(", ")", ".", "to_markdown", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.windows_utils.convert_clip_ids_to_windows": [[12, 37], ["windows.append", "windows.append"], "function", ["None"], ["def", "convert_clip_ids_to_windows", "(", "clip_ids", ")", ":", "\n", "    ", "\"\"\" Inverse function of convert_windows_to_clip_ids\n    Args:\n        clip_ids: list(int), each is a index of a clip, starting from 0\n\n    Returns:\n        list(list(int)), each sublist contains two integers which are clip indices.\n            [10, 19] meaning a 9 clip window [20, 40] (seconds), if each clip is 2 seconds.\n\n    >>> test_clip_ids = [56, 57, 58, 59, 60, 61, 62] + [64, ] + [67, 68, 69, 70, 71]\n    >>> convert_clip_ids_to_windows(test_clip_ids)\n    [[56, 62], [64, 64], [67, 71]]\n    \"\"\"", "\n", "windows", "=", "[", "]", "\n", "_window", "=", "[", "clip_ids", "[", "0", "]", ",", "None", "]", "\n", "last_clip_id", "=", "clip_ids", "[", "0", "]", "\n", "for", "clip_id", "in", "clip_ids", ":", "\n", "        ", "if", "clip_id", "-", "last_clip_id", ">", "1", ":", "# find gap", "\n", "            ", "_window", "[", "1", "]", "=", "last_clip_id", "\n", "windows", ".", "append", "(", "_window", ")", "\n", "_window", "=", "[", "clip_id", ",", "None", "]", "\n", "", "last_clip_id", "=", "clip_id", "\n", "", "_window", "[", "1", "]", "=", "last_clip_id", "\n", "windows", ".", "append", "(", "_window", ")", "\n", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.windows_utils.convert_windows_to_clip_ids": [[39, 56], ["list", "range"], "function", ["None"], ["", "def", "convert_windows_to_clip_ids", "(", "windows", ")", ":", "\n", "    ", "\"\"\" Inverse function of convert_clip_ids_to_windows\n    Args:\n        windows: list(list(int)), each sublist contains two integers which are clip indices.\n            [10, 11] meaning a 9 clip window [20, 40] (seconds), if each clip is 2 seconds.\n\n    Returns:\n        clip_ids: list(int)\n        \n    >>> test_windows =[[56, 62], [64, 64], [67, 71]]\n    >>> convert_windows_to_clip_ids(test_windows)\n     [56, 57, 58, 59, 60, 61, 62] + [64, ] + [67, 68, 69, 70, 71]\n    \"\"\"", "\n", "clip_ids", "=", "[", "]", "\n", "for", "w", "in", "windows", ":", "\n", "        ", "clip_ids", "+=", "list", "(", "range", "(", "w", "[", "0", "]", ",", "w", "[", "1", "]", "+", "1", ")", ")", "\n", "", "return", "clip_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.windows_utils.convert_clip_window_to_seconds": [[58, 60], ["None"], "function", ["None"], ["", "def", "convert_clip_window_to_seconds", "(", "window", ",", "clip_len", "=", "2", ")", ":", "\n", "    ", "return", "[", "window", "[", "0", "]", "*", "clip_len", ",", "(", "window", "[", "1", "]", "+", "1", ")", "*", "clip_len", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.tensor_utils.pad_sequences_1d": [[5, 54], ["torch.device", "isinstance", "isinstance", "enumerate", "len", "max", "torch.zeros", "torch.zeros", "numpy.zeros", "numpy.zeros", "str", "str", "str", "torch.tensor", "numpy.asarray", "len", "len", "len", "len"], "function", ["None"], ["def", "pad_sequences_1d", "(", "sequences", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ",", "fixed_length", "=", "None", ")", ":", "\n", "    ", "\"\"\" Pad a single-nested list or a sequence of n-d array (torch.tensor or np.ndarray)\n    into a (n+1)-d array, only allow the first dim has variable lengths.\n    Args:\n        sequences: list(n-d tensor or list)\n        dtype: np.dtype or torch.dtype\n        device:\n        fixed_length: pad all seq in sequences to fixed length. All seq should have a length <= fixed_length.\n            return will be of shape [len(sequences), fixed_length, ...]\n    Returns:\n        padded_seqs: ((n+1)-d tensor) padded with zeros\n        mask: (2d tensor) of the same shape as the first two dims of padded_seqs,\n              1 indicate valid, 0 otherwise\n    Examples:\n        >>> test_data_list = [[1,2,3], [1,2], [3,4,7,9]]\n        >>> pad_sequences_1d(test_data_list, dtype=torch.long)\n        >>> test_data_3d = [torch.randn(2,3,4), torch.randn(4,3,4), torch.randn(1,3,4)]\n        >>> pad_sequences_1d(test_data_3d, dtype=torch.float)\n        >>> test_data_list = [[1,2,3], [1,2], [3,4,7,9]]\n        >>> pad_sequences_1d(test_data_list, dtype=np.float32)\n        >>> test_data_3d = [np.random.randn(2,3,4), np.random.randn(4,3,4), np.random.randn(1,3,4)]\n        >>> pad_sequences_1d(test_data_3d, dtype=np.float32)\n    \"\"\"", "\n", "if", "isinstance", "(", "sequences", "[", "0", "]", ",", "list", ")", ":", "\n", "        ", "if", "\"torch\"", "in", "str", "(", "dtype", ")", ":", "\n", "            ", "sequences", "=", "[", "torch", ".", "tensor", "(", "s", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "for", "s", "in", "sequences", "]", "\n", "", "else", ":", "\n", "            ", "sequences", "=", "[", "np", ".", "asarray", "(", "s", ",", "dtype", "=", "dtype", ")", "for", "s", "in", "sequences", "]", "\n", "\n", "", "", "extra_dims", "=", "sequences", "[", "0", "]", ".", "shape", "[", "1", ":", "]", "# the extra dims should be the same for all elements", "\n", "lengths", "=", "[", "len", "(", "seq", ")", "for", "seq", "in", "sequences", "]", "\n", "if", "fixed_length", "is", "not", "None", ":", "\n", "        ", "max_length", "=", "fixed_length", "\n", "", "else", ":", "\n", "        ", "max_length", "=", "max", "(", "lengths", ")", "\n", "", "if", "isinstance", "(", "sequences", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "assert", "\"torch\"", "in", "str", "(", "dtype", ")", ",", "\"dtype and input type does not match\"", "\n", "padded_seqs", "=", "torch", ".", "zeros", "(", "(", "len", "(", "sequences", ")", ",", "max_length", ")", "+", "extra_dims", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "mask", "=", "torch", ".", "zeros", "(", "(", "len", "(", "sequences", ")", ",", "max_length", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "else", ":", "# np", "\n", "        ", "assert", "\"numpy\"", "in", "str", "(", "dtype", ")", ",", "\"dtype and input type does not match\"", "\n", "padded_seqs", "=", "np", ".", "zeros", "(", "(", "len", "(", "sequences", ")", ",", "max_length", ")", "+", "extra_dims", ",", "dtype", "=", "dtype", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "sequences", ")", ",", "max_length", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "for", "idx", ",", "seq", "in", "enumerate", "(", "sequences", ")", ":", "\n", "        ", "end", "=", "lengths", "[", "idx", "]", "\n", "padded_seqs", "[", "idx", ",", ":", "end", "]", "=", "seq", "\n", "mask", "[", "idx", ",", ":", "end", "]", "=", "1", "\n", "", "return", "padded_seqs", ",", "mask", "# , lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.tensor_utils.pad_sequences_2d": [[56, 94], ["len", "max", "max", "isinstance", "torch.zeros", "torch.zeros().float", "range", "len", "isinstance", "enumerate", "len", "max", "torch.zeros", "torch.Tensor"], "function", ["None"], ["", "def", "pad_sequences_2d", "(", "sequences", ",", "dtype", "=", "torch", ".", "long", ")", ":", "\n", "    ", "\"\"\" Pad a double-nested list or a sequence of n-d torch tensor into a (n+1)-d tensor,\n        only allow the first two dims has variable lengths\n    Args:\n        sequences: list(n-d tensor or list)\n        dtype: torch.long for word indices / torch.float (float32) for other cases\n    Returns:\n    Examples:\n        >>> test_data_list = [[[1, 3, 5], [3, 7, 4, 1]], [[98, 34, 11, 89, 90], [22], [34, 56]],]\n        >>> pad_sequences_2d(test_data_list, dtype=torch.long)  # torch.Size([2, 3, 5])\n        >>> test_data_3d = [torch.randn(2,2,4), torch.randn(4,3,4), torch.randn(1,5,4)]\n        >>> pad_sequences_2d(test_data_3d, dtype=torch.float)  # torch.Size([2, 3, 5])\n        >>> test_data_3d2 = [[torch.randn(2,4), ], [torch.randn(3,4), torch.randn(5,4)]]\n        >>> pad_sequences_2d(test_data_3d2, dtype=torch.float)  # torch.Size([2, 3, 5])\n    # TODO add support for numpy array\n    \"\"\"", "\n", "bsz", "=", "len", "(", "sequences", ")", "\n", "para_lengths", "=", "[", "len", "(", "seq", ")", "for", "seq", "in", "sequences", "]", "\n", "max_para_len", "=", "max", "(", "para_lengths", ")", "\n", "sen_lengths", "=", "[", "[", "len", "(", "word_seq", ")", "for", "word_seq", "in", "seq", "]", "for", "seq", "in", "sequences", "]", "\n", "max_sen_len", "=", "max", "(", "[", "max", "(", "e", ")", "for", "e", "in", "sen_lengths", "]", ")", "\n", "\n", "if", "isinstance", "(", "sequences", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "extra_dims", "=", "sequences", "[", "0", "]", ".", "shape", "[", "2", ":", "]", "\n", "", "elif", "isinstance", "(", "sequences", "[", "0", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "extra_dims", "=", "sequences", "[", "0", "]", "[", "0", "]", ".", "shape", "[", "1", ":", "]", "\n", "", "else", ":", "\n", "        ", "sequences", "=", "[", "[", "torch", ".", "Tensor", "(", "word_seq", ",", "dtype", "=", "dtype", ")", "for", "word_seq", "in", "seq", "]", "for", "seq", "in", "sequences", "]", "\n", "extra_dims", "=", "(", ")", "\n", "\n", "", "padded_seqs", "=", "torch", ".", "zeros", "(", "(", "bsz", ",", "max_para_len", ",", "max_sen_len", ")", "+", "extra_dims", ",", "dtype", "=", "dtype", ")", "\n", "mask", "=", "torch", ".", "zeros", "(", "bsz", ",", "max_para_len", ",", "max_sen_len", ")", ".", "float", "(", ")", "\n", "\n", "for", "b_i", "in", "range", "(", "bsz", ")", ":", "\n", "        ", "for", "sen_i", ",", "sen_l", "in", "enumerate", "(", "sen_lengths", "[", "b_i", "]", ")", ":", "\n", "            ", "padded_seqs", "[", "b_i", ",", "sen_i", ",", ":", "sen_l", "]", "=", "sequences", "[", "b_i", "]", "[", "sen_i", "]", "\n", "mask", "[", "b_i", ",", "sen_i", ",", ":", "sen_l", "]", "=", "1", "\n", "", "", "return", "padded_seqs", ",", "mask", "# , sen_lengths", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.model_utils.build_inference_model": [[5, 31], ["torch.load", "moment_detr.model.build_transformer", "moment_detr.model.build_position_encoding", "moment_detr.model.MomentDETR", "moment_detr.model.MomentDETR.load_state_dict", "len", "args.update"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.build_transformer", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.build_position_encoding", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["\n", "n_all", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "\n", "n_trainable", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Parameter Count: all {:,d}; trainable {:,d}\"", ".", "format", "(", "n_all", ",", "n_trainable", ")", ")", "\n", "", "return", "n_all", ",", "n_trainable", "\n", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.ClipFeatureExtractor.__init__": [[10, 17], ["data_utils.VideoLoader", "print", "run_on_video.clip.load", "data_utils.Preprocessing"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["    ", "def", "__init__", "(", "self", ",", "framerate", "=", "1", "/", "2", ",", "size", "=", "224", ",", "centercrop", "=", "True", ",", "model_name_or_path", "=", "\"ViT-B/32\"", ",", "device", "=", "\"cuda\"", ")", ":", "\n", "        ", "self", ".", "video_loader", "=", "VideoLoader", "(", "framerate", "=", "framerate", ",", "size", "=", "size", ",", "centercrop", "=", "centercrop", ")", "\n", "print", "(", "\"Loading CLIP models\"", ")", "\n", "self", ".", "clip_extractor", ",", "_", "=", "clip", ".", "load", "(", "model_name_or_path", ",", "device", "=", "device", ",", "jit", "=", "False", ")", "\n", "self", ".", "tokenizer", "=", "clip", ".", "tokenize", "\n", "self", ".", "video_preprocessor", "=", "Preprocessing", "(", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.ClipFeatureExtractor.encode_video": [[18, 33], ["torch.no_grad", "data_utils.ClipFeatureExtractor.video_loader.read_video_from_file", "data_utils.ClipFeatureExtractor.video_preprocessor", "len", "int", "range", "torch.cat", "math.ceil", "video_frames[].to", "data_utils.ClipFeatureExtractor.clip_extractor.encode_image", "torch.cat.append"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader.read_video_from_file", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_image"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "encode_video", "(", "self", ",", "video_path", ":", "str", ",", "bsz", "=", "60", ")", ":", "\n", "        ", "video_frames", "=", "self", ".", "video_loader", ".", "read_video_from_file", "(", "video_path", ")", "# (T, H, W, 3)", "\n", "video_frames", "=", "self", ".", "video_preprocessor", "(", "video_frames", ")", "\n", "n_frames", "=", "len", "(", "video_frames", ")", "\n", "n_batch", "=", "int", "(", "math", ".", "ceil", "(", "n_frames", "/", "bsz", ")", ")", "\n", "video_features", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_batch", ")", ":", "\n", "            ", "st_idx", "=", "i", "*", "bsz", "\n", "ed_idx", "=", "(", "i", "+", "1", ")", "*", "bsz", "\n", "_video_frames", "=", "video_frames", "[", "st_idx", ":", "ed_idx", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "_video_features", "=", "self", ".", "clip_extractor", ".", "encode_image", "(", "_video_frames", ")", "\n", "video_features", ".", "append", "(", "_video_features", ")", "\n", "", "video_features", "=", "torch", ".", "cat", "(", "video_features", ",", "dim", "=", "0", ")", "\n", "return", "video_features", "# (T=#frames, d) torch tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.ClipFeatureExtractor.encode_text": [[34, 49], ["torch.no_grad", "len", "int", "range", "math.ceil", "data_utils.ClipFeatureExtractor.tokenizer().to", "data_utils.ClipFeatureExtractor.clip_extractor.encode_text", "enumerate", "text_features.append", "data_utils.ClipFeatureExtractor.tokenizer"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_text"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "encode_text", "(", "self", ",", "text_list", ",", "bsz", "=", "60", ")", ":", "\n", "        ", "n_text", "=", "len", "(", "text_list", ")", "\n", "n_batch", "=", "int", "(", "math", ".", "ceil", "(", "n_text", "/", "bsz", ")", ")", "\n", "text_features", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_batch", ")", ":", "\n", "            ", "st_idx", "=", "i", "*", "bsz", "\n", "ed_idx", "=", "(", "i", "+", "1", ")", "*", "bsz", "\n", "encoded_texts", "=", "self", ".", "tokenizer", "(", "text_list", "[", "st_idx", ":", "ed_idx", "]", ",", "context_length", "=", "77", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "output", "=", "self", ".", "clip_extractor", ".", "encode_text", "(", "encoded_texts", ")", "\n", "valid_lengths", "=", "(", "encoded_texts", "!=", "0", ")", ".", "sum", "(", "1", ")", ".", "tolist", "(", ")", "\n", "batch_last_hidden_states", "=", "output", "[", "\"last_hidden_state\"", "]", "\n", "for", "j", ",", "valid_len", "in", "enumerate", "(", "valid_lengths", ")", ":", "\n", "                ", "text_features", ".", "append", "(", "batch_last_hidden_states", "[", "j", ",", ":", "valid_len", "]", ")", "\n", "", "", "return", "text_features", "# List([L_j, d]) torch tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.Normalize.__init__": [[72, 75], ["torch.FloatTensor().view", "torch.FloatTensor().view", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "mean", "=", "torch", ".", "FloatTensor", "(", "mean", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "std", "=", "torch", ".", "FloatTensor", "(", "std", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.Normalize.__call__": [[76, 79], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "tensor", "=", "(", "tensor", "-", "self", ".", "mean", ")", "/", "(", "self", ".", "std", "+", "1e-8", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.Preprocessing.__init__": [[83, 87], ["data_utils.Normalize"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "norm", "=", "Normalize", "(", "\n", "mean", "=", "[", "0.48145466", ",", "0.4578275", ",", "0.40821073", "]", ",", "\n", "std", "=", "[", "0.26862954", ",", "0.26130258", ",", "0.27577711", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.Preprocessing.__call__": [[88, 92], ["data_utils.Preprocessing.norm"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "tensor", "=", "tensor", "/", "255.0", "\n", "tensor", "=", "self", ".", "norm", "(", "tensor", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader.__init__": [[99, 108], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "framerate", "=", "1", "/", "2", ",", "\n", "size", "=", "224", ",", "\n", "centercrop", "=", "True", ",", "\n", ")", ":", "\n", "        ", "self", ".", "centercrop", "=", "centercrop", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "framerate", "=", "framerate", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader._get_video_info": [[109, 124], ["ffmpeg.probe", "next", "int", "int", "math.floor", "data_utils.convert_to_float", "int", "float"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.convert_to_float"], ["", "def", "_get_video_info", "(", "self", ",", "video_path", ")", ":", "\n", "        ", "probe", "=", "ffmpeg", ".", "probe", "(", "video_path", ")", "\n", "video_stream", "=", "next", "(", "(", "stream", "for", "stream", "in", "probe", "[", "'streams'", "]", "\n", "if", "stream", "[", "'codec_type'", "]", "==", "'video'", ")", ",", "None", ")", "\n", "width", "=", "int", "(", "video_stream", "[", "'width'", "]", ")", "\n", "height", "=", "int", "(", "video_stream", "[", "'height'", "]", ")", "\n", "fps", "=", "math", ".", "floor", "(", "convert_to_float", "(", "video_stream", "[", "'avg_frame_rate'", "]", ")", ")", "\n", "try", ":", "\n", "            ", "frames_length", "=", "int", "(", "video_stream", "[", "'nb_frames'", "]", ")", "\n", "duration", "=", "float", "(", "video_stream", "[", "'duration'", "]", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "frames_length", ",", "duration", "=", "-", "1", ",", "-", "1", "\n", "", "info", "=", "{", "\"duration\"", ":", "duration", ",", "\"frames_length\"", ":", "frames_length", ",", "\n", "\"fps\"", ":", "fps", ",", "\"height\"", ":", "height", ",", "\"width\"", ":", "width", "}", "\n", "return", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader._get_output_dim": [[125, 132], ["isinstance", "len", "int", "int"], "methods", ["None"], ["", "def", "_get_output_dim", "(", "self", ",", "h", ",", "w", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "size", ",", "tuple", ")", "and", "len", "(", "self", ".", "size", ")", "==", "2", ":", "\n", "            ", "return", "self", ".", "size", "\n", "", "elif", "h", ">=", "w", ":", "\n", "            ", "return", "int", "(", "h", "*", "self", ".", "size", "/", "w", ")", ",", "self", ".", "size", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "size", ",", "int", "(", "w", "*", "self", ".", "size", "/", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader.read_video_from_file": [[133, 171], ["data_utils.VideoLoader._get_output_dim", "ffmpeg.input().filter().filter", "cmd.crop.crop.output().run", "numpy.frombuffer().reshape", "torch.from_numpy", "video.permute.permute.permute", "data_utils.VideoLoader._get_video_info", "int", "int", "cmd.crop.crop.crop", "isinstance", "video.permute.permute.astype", "print", "print", "ffmpeg.input().filter", "cmd.crop.crop.output", "numpy.frombuffer", "torch.zeros", "max", "int", "ffmpeg.input"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader._get_output_dim", "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.VideoLoader._get_video_info"], ["", "", "def", "read_video_from_file", "(", "self", ",", "video_path", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "info", "=", "self", ".", "_get_video_info", "(", "video_path", ")", "\n", "h", ",", "w", "=", "info", "[", "\"height\"", "]", ",", "info", "[", "\"width\"", "]", "\n", "", "except", "Exception", ":", "\n", "            ", "print", "(", "'ffprobe failed at: {}'", ".", "format", "(", "video_path", ")", ")", "\n", "return", "{", "'video'", ":", "torch", ".", "zeros", "(", "1", ")", ",", "'input'", ":", "video_path", ",", "\n", "'info'", ":", "{", "}", "}", "\n", "", "height", ",", "width", "=", "self", ".", "_get_output_dim", "(", "h", ",", "w", ")", "\n", "try", ":", "\n", "            ", "duration", "=", "info", "[", "\"duration\"", "]", "\n", "fps", "=", "self", ".", "framerate", "\n", "if", "duration", ">", "0", "and", "duration", "<", "1", "/", "fps", "+", "0.1", ":", "\n", "                ", "fps", "=", "2", "/", "max", "(", "int", "(", "duration", ")", ",", "1", ")", "\n", "print", "(", "duration", ",", "fps", ")", "\n", "", "", "except", "Exception", ":", "\n", "            ", "fps", "=", "self", ".", "framerate", "\n", "", "cmd", "=", "(", "\n", "ffmpeg", "\n", ".", "input", "(", "video_path", ")", "\n", ".", "filter", "(", "'fps'", ",", "fps", "=", "fps", ")", "\n", ".", "filter", "(", "'scale'", ",", "width", ",", "height", ")", "\n", ")", "\n", "if", "self", ".", "centercrop", ":", "\n", "            ", "x", "=", "int", "(", "(", "width", "-", "self", ".", "size", ")", "/", "2.0", ")", "\n", "y", "=", "int", "(", "(", "height", "-", "self", ".", "size", ")", "/", "2.0", ")", "\n", "cmd", "=", "cmd", ".", "crop", "(", "x", ",", "y", ",", "self", ".", "size", ",", "self", ".", "size", ")", "\n", "", "out", ",", "_", "=", "(", "\n", "cmd", ".", "output", "(", "'pipe:'", ",", "format", "=", "'rawvideo'", ",", "pix_fmt", "=", "'rgb24'", ")", "\n", ".", "run", "(", "capture_stdout", "=", "True", ",", "quiet", "=", "True", ")", "\n", ")", "\n", "if", "self", ".", "centercrop", "and", "isinstance", "(", "self", ".", "size", ",", "int", ")", ":", "\n", "            ", "height", ",", "width", "=", "self", ".", "size", ",", "self", ".", "size", "\n", "", "video", "=", "np", ".", "frombuffer", "(", "out", ",", "np", ".", "uint8", ")", ".", "reshape", "(", "\n", "[", "-", "1", ",", "height", ",", "width", ",", "3", "]", ")", "\n", "video", "=", "torch", ".", "from_numpy", "(", "video", ".", "astype", "(", "'float32'", ")", ")", "\n", "video", "=", "video", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "return", "video", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.convert_to_float": [[51, 68], ["float", "frac_str.split", "num.split", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["", "", "def", "convert_to_float", "(", "frac_str", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "return", "float", "(", "frac_str", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "try", ":", "\n", "            ", "num", ",", "denom", "=", "frac_str", ".", "split", "(", "'/'", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "return", "None", "\n", "", "try", ":", "\n", "            ", "leading", ",", "num", "=", "num", ".", "split", "(", "' '", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "return", "float", "(", "num", ")", "/", "float", "(", "denom", ")", "\n", "", "if", "float", "(", "leading", ")", "<", "0", ":", "\n", "            ", "sign_mult", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "sign_mult", "=", "1", "\n", "", "return", "float", "(", "leading", ")", "+", "sign_mult", "*", "(", "float", "(", "num", ")", "/", "float", "(", "denom", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.run.MomentDETRPredictor.__init__": [[13, 23], ["print", "run_on_video.data_utils.ClipFeatureExtractor", "print", "run_on_video.model_utils.build_inference_model().to", "run_on_video.model_utils.build_inference_model"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.model_utils.build_inference_model"], ["    ", "def", "__init__", "(", "self", ",", "ckpt_path", ",", "clip_model_name_or_path", "=", "\"ViT-B/32\"", ",", "device", "=", "\"cuda\"", ")", ":", "\n", "        ", "self", ".", "clip_len", "=", "2", "# seconds", "\n", "self", ".", "device", "=", "device", "\n", "print", "(", "\"Loading feature extractors...\"", ")", "\n", "self", ".", "feature_extractor", "=", "ClipFeatureExtractor", "(", "\n", "framerate", "=", "1", "/", "self", ".", "clip_len", ",", "size", "=", "224", ",", "centercrop", "=", "True", ",", "\n", "model_name_or_path", "=", "clip_model_name_or_path", ",", "device", "=", "device", "\n", ")", "\n", "print", "(", "\"Loading trained Moment-DETR model...\"", ")", "\n", "self", ".", "model", "=", "build_inference_model", "(", "ckpt_path", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.run.MomentDETRPredictor.localize_moment": [[24, 88], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "len", "run.MomentDETRPredictor.feature_extractor.encode_video", "torch.normalize", "torch.normalize", "len", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "video_feats.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "run.MomentDETRPredictor.feature_extractor.encode_text", "utils.tensor_utils.pad_sequences_1d", "torch.normalize", "torch.normalize", "dict", "run.MomentDETRPredictor.model", "torch.softmax", "torch.softmax", "outputs[].half", "model_inputs[].sum().cpu().tolist", "range", "enumerate", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "len", "_saliency_scores[].tolist", "saliency_scores.append", "zip", "torch.cat().tolist", "torch.cat().tolist", "torch.cat().tolist", "torch.cat().tolist", "sorted", "dict", "predictions.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "video_feats.unsqueeze().repeat.unsqueeze().repeat.unsqueeze", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "model_inputs[].sum().cpu", "round", "pred_spans.cpu", "scores.cpu", "moment_detr.span_utils.span_cxw_to_xx", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "float", "model_inputs[].sum", "int"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.data_utils.ClipFeatureExtractor.encode_video", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_text", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.tensor_utils.pad_sequences_1d", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "localize_moment", "(", "self", ",", "video_path", ",", "query_list", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            video_path: str, path to the video file\n            query_list: List[str], each str is a query for this video\n        \"\"\"", "\n", "# construct model inputs", "\n", "n_query", "=", "len", "(", "query_list", ")", "\n", "video_feats", "=", "self", ".", "feature_extractor", ".", "encode_video", "(", "video_path", ")", "\n", "video_feats", "=", "F", ".", "normalize", "(", "video_feats", ",", "dim", "=", "-", "1", ",", "eps", "=", "1e-5", ")", "\n", "n_frames", "=", "len", "(", "video_feats", ")", "\n", "# add tef", "\n", "tef_st", "=", "torch", ".", "arange", "(", "0", ",", "n_frames", ",", "1.0", ")", "/", "n_frames", "\n", "tef_ed", "=", "tef_st", "+", "1.0", "/", "n_frames", "\n", "tef", "=", "torch", ".", "stack", "(", "[", "tef_st", ",", "tef_ed", "]", ",", "dim", "=", "1", ")", ".", "to", "(", "self", ".", "device", ")", "# (n_frames, 2)", "\n", "video_feats", "=", "torch", ".", "cat", "(", "[", "video_feats", ",", "tef", "]", ",", "dim", "=", "1", ")", "\n", "assert", "n_frames", "<=", "75", ",", "\"The positional embedding of this pretrained MomentDETR only support video up \"", "\"to 150 secs (i.e., 75 2-sec clips) in length\"", "\n", "video_feats", "=", "video_feats", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "n_query", ",", "1", ",", "1", ")", "# (#text, T, d)", "\n", "video_mask", "=", "torch", ".", "ones", "(", "n_query", ",", "n_frames", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "query_feats", "=", "self", ".", "feature_extractor", ".", "encode_text", "(", "query_list", ")", "# #text * (L, d)", "\n", "query_feats", ",", "query_mask", "=", "pad_sequences_1d", "(", "\n", "query_feats", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ",", "fixed_length", "=", "None", ")", "\n", "query_feats", "=", "F", ".", "normalize", "(", "query_feats", ",", "dim", "=", "-", "1", ",", "eps", "=", "1e-5", ")", "\n", "model_inputs", "=", "dict", "(", "\n", "src_vid", "=", "video_feats", ",", "\n", "src_vid_mask", "=", "video_mask", ",", "\n", "src_txt", "=", "query_feats", ",", "\n", "src_txt_mask", "=", "query_mask", "\n", ")", "\n", "\n", "# decode outputs", "\n", "outputs", "=", "self", ".", "model", "(", "**", "model_inputs", ")", "\n", "# #moment_queries refers to the positional embeddings in MomentDETR's decoder, not the input text query", "\n", "prob", "=", "F", ".", "softmax", "(", "outputs", "[", "\"pred_logits\"", "]", ",", "-", "1", ")", "# (batch_size, #moment_queries=10, #classes=2)", "\n", "scores", "=", "prob", "[", "...", ",", "0", "]", "# * (batch_size, #moment_queries)  foreground label is 0, we directly take it", "\n", "pred_spans", "=", "outputs", "[", "\"pred_spans\"", "]", "# (bsz, #moment_queries, 2)", "\n", "_saliency_scores", "=", "outputs", "[", "\"saliency_scores\"", "]", ".", "half", "(", ")", "# (bsz, L)", "\n", "saliency_scores", "=", "[", "]", "\n", "valid_vid_lengths", "=", "model_inputs", "[", "\"src_vid_mask\"", "]", ".", "sum", "(", "1", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "valid_vid_lengths", ")", ")", ":", "\n", "            ", "_score", "=", "_saliency_scores", "[", "j", ",", ":", "int", "(", "valid_vid_lengths", "[", "j", "]", ")", "]", ".", "tolist", "(", ")", "\n", "_score", "=", "[", "round", "(", "e", ",", "4", ")", "for", "e", "in", "_score", "]", "\n", "saliency_scores", ".", "append", "(", "_score", ")", "\n", "\n", "# compose predictions", "\n", "", "predictions", "=", "[", "]", "\n", "video_duration", "=", "n_frames", "*", "self", ".", "clip_len", "\n", "for", "idx", ",", "(", "spans", ",", "score", ")", "in", "enumerate", "(", "zip", "(", "pred_spans", ".", "cpu", "(", ")", ",", "scores", ".", "cpu", "(", ")", ")", ")", ":", "\n", "            ", "spans", "=", "span_cxw_to_xx", "(", "spans", ")", "*", "video_duration", "\n", "# # (#queries, 3), [st(float), ed(float), score(float)]", "\n", "cur_ranked_preds", "=", "torch", ".", "cat", "(", "[", "spans", ",", "score", "[", ":", ",", "None", "]", "]", ",", "dim", "=", "1", ")", ".", "tolist", "(", ")", "\n", "cur_ranked_preds", "=", "sorted", "(", "cur_ranked_preds", ",", "key", "=", "lambda", "x", ":", "x", "[", "2", "]", ",", "reverse", "=", "True", ")", "\n", "cur_ranked_preds", "=", "[", "[", "float", "(", "f\"{e:.4f}\"", ")", "for", "e", "in", "row", "]", "for", "row", "in", "cur_ranked_preds", "]", "\n", "cur_query_pred", "=", "dict", "(", "\n", "query", "=", "query_list", "[", "idx", "]", ",", "# str", "\n", "vid", "=", "video_path", ",", "\n", "pred_relevant_windows", "=", "cur_ranked_preds", ",", "# List([st(float), ed(float), score(float)])", "\n", "pred_saliency_scores", "=", "saliency_scores", "[", "idx", "]", "# List(float), len==n_frames, scores for each frame", "\n", ")", "\n", "predictions", ".", "append", "(", "cur_query_pred", ")", "\n", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.run.run_example": [[90, 122], ["load_jsonl", "print", "run.MomentDETRPredictor", "print", "run.MomentDETRPredictor.localize_moment", "enumerate", "print", "print", "print", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.load_jsonl", "home.repos.pwc.inspect_result.jayleicn_moment_detr.run_on_video.run.MomentDETRPredictor.localize_moment"], ["", "", "def", "run_example", "(", ")", ":", "\n", "# load example data", "\n", "    ", "from", "utils", ".", "basic_utils", "import", "load_jsonl", "\n", "video_path", "=", "\"run_on_video/example/RoripwjYFp8_60.0_210.0.mp4\"", "\n", "query_path", "=", "\"run_on_video/example/queries.jsonl\"", "\n", "queries", "=", "load_jsonl", "(", "query_path", ")", "\n", "query_text_list", "=", "[", "e", "[", "\"query\"", "]", "for", "e", "in", "queries", "]", "\n", "ckpt_path", "=", "\"run_on_video/moment_detr_ckpt/model_best.ckpt\"", "\n", "\n", "# run predictions", "\n", "print", "(", "\"Build models...\"", ")", "\n", "clip_model_name_or_path", "=", "\"ViT-B/32\"", "\n", "# clip_model_name_or_path = \"tmp/ViT-B-32.pt\"", "\n", "moment_detr_predictor", "=", "MomentDETRPredictor", "(", "\n", "ckpt_path", "=", "ckpt_path", ",", "\n", "clip_model_name_or_path", "=", "clip_model_name_or_path", ",", "\n", "device", "=", "\"cuda\"", "\n", ")", "\n", "print", "(", "\"Run prediction...\"", ")", "\n", "predictions", "=", "moment_detr_predictor", ".", "localize_moment", "(", "\n", "video_path", "=", "video_path", ",", "query_list", "=", "query_text_list", ")", "\n", "\n", "# print data", "\n", "for", "idx", ",", "query_data", "in", "enumerate", "(", "queries", ")", ":", "\n", "        ", "print", "(", "\"-\"", "*", "30", "+", "f\"idx{idx}\"", ")", "\n", "print", "(", "f\">> query: {query_data['query']}\"", ")", "\n", "print", "(", "f\">> video_path: {video_path}\"", ")", "\n", "print", "(", "f\">> GT moments: {query_data['relevant_windows']}\"", ")", "\n", "print", "(", "f\">> Predicted moments ([start_in_seconds, end_in_seconds, score]): \"", "\n", "f\"{predictions[idx]['pred_relevant_windows']}\"", ")", "\n", "print", "(", "f\">> GT saliency scores (only localized 2-sec clips): {query_data['saliency_scores']}\"", ")", "\n", "print", "(", "f\">> Predicted saliency scores (for all 2-sec clip): \"", "\n", "f\"{predictions[idx]['pred_saliency_scores']}\"", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.__init__": [[63, 79], ["simple_tokenizer.default_bpe", "simple_tokenizer.bytes_to_unicode", "gzip.open().read().decode().split", "list", "list.extend", "dict", "dict", "regex.compile", "tuple", "bytes_to_unicode().values", "list.append", "zip", "zip", "simple_tokenizer.SimpleTokenizer.byte_encoder.items", "gzip.open().read().decode", "merge.split", "range", "simple_tokenizer.SimpleTokenizer.encoder.items", "range", "simple_tokenizer.bytes_to_unicode", "len", "len", "gzip.open().read", "gzip.open"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.default_bpe", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.bytes_to_unicode", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.decode", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.bytes_to_unicode"], ["    ", "def", "__init__", "(", "self", ",", "bpe_path", ":", "str", "=", "default_bpe", "(", ")", ")", ":", "\n", "        ", "self", ".", "byte_encoder", "=", "bytes_to_unicode", "(", ")", "\n", "self", ".", "byte_decoder", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "byte_encoder", ".", "items", "(", ")", "}", "\n", "merges", "=", "gzip", ".", "open", "(", "bpe_path", ")", ".", "read", "(", ")", ".", "decode", "(", "\"utf-8\"", ")", ".", "split", "(", "'\\n'", ")", "\n", "merges", "=", "merges", "[", "1", ":", "49152", "-", "256", "-", "2", "+", "1", "]", "\n", "merges", "=", "[", "tuple", "(", "merge", ".", "split", "(", ")", ")", "for", "merge", "in", "merges", "]", "\n", "vocab", "=", "list", "(", "bytes_to_unicode", "(", ")", ".", "values", "(", ")", ")", "\n", "vocab", "=", "vocab", "+", "[", "v", "+", "'</w>'", "for", "v", "in", "vocab", "]", "\n", "for", "merge", "in", "merges", ":", "\n", "            ", "vocab", ".", "append", "(", "''", ".", "join", "(", "merge", ")", ")", "\n", "", "vocab", ".", "extend", "(", "[", "'<|startoftext|>'", ",", "'<|endoftext|>'", "]", ")", "\n", "self", ".", "encoder", "=", "dict", "(", "zip", "(", "vocab", ",", "range", "(", "len", "(", "vocab", ")", ")", ")", ")", "\n", "self", ".", "decoder", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "encoder", ".", "items", "(", ")", "}", "\n", "self", ".", "bpe_ranks", "=", "dict", "(", "zip", "(", "merges", ",", "range", "(", "len", "(", "merges", ")", ")", ")", ")", "\n", "self", ".", "cache", "=", "{", "'<|startoftext|>'", ":", "'<|startoftext|>'", ",", "'<|endoftext|>'", ":", "'<|endoftext|>'", "}", "\n", "self", ".", "pat", "=", "re", ".", "compile", "(", "r\"\"\"<\\|startoftext\\|>|<\\|endoftext\\|>|'s|'t|'re|'ve|'m|'ll|'d|[\\p{L}]+|[\\p{N}]|[^\\s\\p{L}\\p{N}]+\"\"\"", ",", "re", ".", "IGNORECASE", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.bpe": [[80, 120], ["simple_tokenizer.get_pairs", "tuple", "min", "tuple", "len", "len", "simple_tokenizer.get_pairs", "word.index", "tuple.extend", "tuple.append", "tuple.append", "simple_tokenizer.SimpleTokenizer.bpe_ranks.get", "tuple.extend", "float", "len"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.get_pairs", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.get_pairs"], ["", "def", "bpe", "(", "self", ",", "token", ")", ":", "\n", "        ", "if", "token", "in", "self", ".", "cache", ":", "\n", "            ", "return", "self", ".", "cache", "[", "token", "]", "\n", "", "word", "=", "tuple", "(", "token", "[", ":", "-", "1", "]", ")", "+", "(", "token", "[", "-", "1", "]", "+", "'</w>'", ",", ")", "\n", "pairs", "=", "get_pairs", "(", "word", ")", "\n", "\n", "if", "not", "pairs", ":", "\n", "            ", "return", "token", "+", "'</w>'", "\n", "\n", "", "while", "True", ":", "\n", "            ", "bigram", "=", "min", "(", "pairs", ",", "key", "=", "lambda", "pair", ":", "self", ".", "bpe_ranks", ".", "get", "(", "pair", ",", "float", "(", "'inf'", ")", ")", ")", "\n", "if", "bigram", "not", "in", "self", ".", "bpe_ranks", ":", "\n", "                ", "break", "\n", "", "first", ",", "second", "=", "bigram", "\n", "new_word", "=", "[", "]", "\n", "i", "=", "0", "\n", "while", "i", "<", "len", "(", "word", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "j", "=", "word", ".", "index", "(", "first", ",", "i", ")", "\n", "new_word", ".", "extend", "(", "word", "[", "i", ":", "j", "]", ")", "\n", "i", "=", "j", "\n", "", "except", ":", "\n", "                    ", "new_word", ".", "extend", "(", "word", "[", "i", ":", "]", ")", "\n", "break", "\n", "\n", "", "if", "word", "[", "i", "]", "==", "first", "and", "i", "<", "len", "(", "word", ")", "-", "1", "and", "word", "[", "i", "+", "1", "]", "==", "second", ":", "\n", "                    ", "new_word", ".", "append", "(", "first", "+", "second", ")", "\n", "i", "+=", "2", "\n", "", "else", ":", "\n", "                    ", "new_word", ".", "append", "(", "word", "[", "i", "]", ")", "\n", "i", "+=", "1", "\n", "", "", "new_word", "=", "tuple", "(", "new_word", ")", "\n", "word", "=", "new_word", "\n", "if", "len", "(", "word", ")", "==", "1", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "pairs", "=", "get_pairs", "(", "word", ")", "\n", "", "", "word", "=", "' '", ".", "join", "(", "word", ")", "\n", "self", ".", "cache", "[", "token", "]", "=", "word", "\n", "return", "word", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.encode": [[121, 128], ["whitespace_clean().lower", "regex.findall", "bpe_tokens.extend", "simple_tokenizer.whitespace_clean", "simple_tokenizer.basic_clean", "token.encode", "simple_tokenizer.SimpleTokenizer.bpe().split", "simple_tokenizer.SimpleTokenizer.bpe"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.whitespace_clean", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.basic_clean", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.encode", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.bpe"], ["", "def", "encode", "(", "self", ",", "text", ")", ":", "\n", "        ", "bpe_tokens", "=", "[", "]", "\n", "text", "=", "whitespace_clean", "(", "basic_clean", "(", "text", ")", ")", ".", "lower", "(", ")", "\n", "for", "token", "in", "re", ".", "findall", "(", "self", ".", "pat", ",", "text", ")", ":", "\n", "            ", "token", "=", "''", ".", "join", "(", "self", ".", "byte_encoder", "[", "b", "]", "for", "b", "in", "token", ".", "encode", "(", "'utf-8'", ")", ")", "\n", "bpe_tokens", ".", "extend", "(", "self", ".", "encoder", "[", "bpe_token", "]", "for", "bpe_token", "in", "self", ".", "bpe", "(", "token", ")", ".", "split", "(", "' '", ")", ")", "\n", "", "return", "bpe_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.decode": [[129, 133], ["bytearray().decode().replace", "bytearray().decode", "bytearray"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.decode"], ["", "def", "decode", "(", "self", ",", "tokens", ")", ":", "\n", "        ", "text", "=", "''", ".", "join", "(", "[", "self", ".", "decoder", "[", "token", "]", "for", "token", "in", "tokens", "]", ")", "\n", "text", "=", "bytearray", "(", "[", "self", ".", "byte_decoder", "[", "c", "]", "for", "c", "in", "text", "]", ")", ".", "decode", "(", "'utf-8'", ",", "errors", "=", "\"replace\"", ")", ".", "replace", "(", "'</w>'", ",", "' '", ")", "\n", "return", "text", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.default_bpe": [[10, 13], ["functools.lru_cache", "os.path.join", "os.path.dirname", "os.path.abspath"], "function", ["None"], ["@", "lru_cache", "(", ")", "\n", "def", "default_bpe", "(", ")", ":", "\n", "    ", "return", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\"bpe_simple_vocab_16e6.txt.gz\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.bytes_to_unicode": [[15, 36], ["functools.lru_cache", "range", "dict", "list", "chr", "zip", "list", "list", "range", "bs.append", "cs.append", "range", "range", "ord", "ord", "ord", "ord", "ord", "ord"], "function", ["None"], ["", "@", "lru_cache", "(", ")", "\n", "def", "bytes_to_unicode", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns list of utf-8 byte and a corresponding list of unicode strings.\n    The reversible bpe codes work on unicode strings.\n    This means you need a large # of unicode characters in your vocab if you want to avoid UNKs.\n    When you're at something like a 10B token dataset you end up needing around 5K for decent coverage.\n    This is a signficant percentage of your normal, say, 32K bpe vocab.\n    To avoid that, we want lookup tables between utf-8 bytes and unicode strings.\n    And avoids mapping to whitespace/control characters the bpe code barfs on.\n    \"\"\"", "\n", "bs", "=", "list", "(", "range", "(", "ord", "(", "\"!\"", ")", ",", "ord", "(", "\"~\"", ")", "+", "1", ")", ")", "+", "list", "(", "range", "(", "ord", "(", "\"\u00a1\"", ")", ",", "ord", "(", "\"\u00ac\"", ")", "+", "1", ")", ")", "+", "list", "(", "range", "(", "ord", "(", "\"\u00ae\"", ")", ",", "ord", "(", "\"\u00ff\"", ")", "+", "1", ")", ")", "\n", "cs", "=", "bs", "[", ":", "]", "\n", "n", "=", "0", "\n", "for", "b", "in", "range", "(", "2", "**", "8", ")", ":", "\n", "        ", "if", "b", "not", "in", "bs", ":", "\n", "            ", "bs", ".", "append", "(", "b", ")", "\n", "cs", ".", "append", "(", "2", "**", "8", "+", "n", ")", "\n", "n", "+=", "1", "\n", "", "", "cs", "=", "[", "chr", "(", "n", ")", "for", "n", "in", "cs", "]", "\n", "return", "dict", "(", "zip", "(", "bs", ",", "cs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.get_pairs": [[38, 48], ["set", "set.add"], "function", ["None"], ["", "def", "get_pairs", "(", "word", ")", ":", "\n", "    ", "\"\"\"Return set of symbol pairs in a word.\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    \"\"\"", "\n", "pairs", "=", "set", "(", ")", "\n", "prev_char", "=", "word", "[", "0", "]", "\n", "for", "char", "in", "word", "[", "1", ":", "]", ":", "\n", "        ", "pairs", ".", "add", "(", "(", "prev_char", ",", "char", ")", ")", "\n", "prev_char", "=", "char", "\n", "", "return", "pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.basic_clean": [[50, 54], ["ftfy.fix_text", "html.unescape", "html.unescape.strip", "html.unescape"], "function", ["None"], ["", "def", "basic_clean", "(", "text", ")", ":", "\n", "    ", "text", "=", "ftfy", ".", "fix_text", "(", "text", ")", "\n", "text", "=", "html", ".", "unescape", "(", "html", ".", "unescape", "(", "text", ")", ")", "\n", "return", "text", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.whitespace_clean": [[56, 60], ["regex.sub", "text.strip.strip"], "function", ["None"], ["", "def", "whitespace_clean", "(", "text", ")", ":", "\n", "    ", "text", "=", "re", ".", "sub", "(", "r'\\s+'", ",", "' '", ",", "text", ")", "\n", "text", "=", "text", ".", "strip", "(", ")", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip._download": [[26, 56], ["os.path.expanduser", "os.makedirs", "os.path.basename", "os.path.join", "os.path.isfile", "url.split", "os.path.exists", "RuntimeError", "urllib.request.urlopen", "open", "hashlib.sha256().hexdigest", "RuntimeError", "os.path.isfile", "hashlib.sha256().hexdigest", "warnings.warn", "tqdm.tqdm", "source.read", "output.write", "loop.update", "hashlib.sha256", "hashlib.sha256", "int", "len", "open().read", "open().read", "source.info().get", "open", "open", "source.info"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["def", "_download", "(", "url", ":", "str", ",", "root", ":", "str", "=", "os", ".", "path", ".", "expanduser", "(", "\"~/.cache/clip\"", ")", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "root", ",", "exist_ok", "=", "True", ")", "\n", "filename", "=", "os", ".", "path", ".", "basename", "(", "url", ")", "\n", "\n", "expected_sha256", "=", "url", ".", "split", "(", "\"/\"", ")", "[", "-", "2", "]", "\n", "download_target", "=", "os", ".", "path", ".", "join", "(", "root", ",", "filename", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "download_target", ")", "and", "not", "os", ".", "path", ".", "isfile", "(", "download_target", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"{download_target} exists and is not a regular file\"", ")", "\n", "\n", "", "if", "os", ".", "path", ".", "isfile", "(", "download_target", ")", ":", "\n", "        ", "if", "hashlib", ".", "sha256", "(", "open", "(", "download_target", ",", "\"rb\"", ")", ".", "read", "(", ")", ")", ".", "hexdigest", "(", ")", "==", "expected_sha256", ":", "\n", "            ", "return", "download_target", "\n", "", "else", ":", "\n", "            ", "warnings", ".", "warn", "(", "f\"{download_target} exists, but the SHA256 checksum does not match; re-downloading the file\"", ")", "\n", "\n", "", "", "with", "urllib", ".", "request", ".", "urlopen", "(", "url", ")", "as", "source", ",", "open", "(", "download_target", ",", "\"wb\"", ")", "as", "output", ":", "\n", "        ", "with", "tqdm", "(", "total", "=", "int", "(", "source", ".", "info", "(", ")", ".", "get", "(", "\"Content-Length\"", ")", ")", ",", "ncols", "=", "80", ",", "unit", "=", "'iB'", ",", "unit_scale", "=", "True", ")", "as", "loop", ":", "\n", "            ", "while", "True", ":", "\n", "                ", "buffer", "=", "source", ".", "read", "(", "8192", ")", "\n", "if", "not", "buffer", ":", "\n", "                    ", "break", "\n", "\n", "", "output", ".", "write", "(", "buffer", ")", "\n", "loop", ".", "update", "(", "len", "(", "buffer", ")", ")", "\n", "\n", "", "", "", "if", "hashlib", ".", "sha256", "(", "open", "(", "download_target", ",", "\"rb\"", ")", ".", "read", "(", ")", ")", ".", "hexdigest", "(", ")", "!=", "expected_sha256", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"Model has been downloaded but the SHA256 checksum does not not match\"", ")", "\n", "\n", "", "return", "download_target", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip._transform": [[58, 65], ["torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.CenterCrop", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "image.convert"], "function", ["None"], ["", "def", "_transform", "(", "n_px", ")", ":", "\n", "    ", "return", "Compose", "(", "[", "\n", "Resize", "(", "n_px", ",", "interpolation", "=", "Image", ".", "BICUBIC", ")", ",", "\n", "CenterCrop", "(", "n_px", ")", ",", "\n", "lambda", "image", ":", "image", ".", "convert", "(", "\"RGB\"", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "Normalize", "(", "(", "0.48145466", ",", "0.4578275", ",", "0.40821073", ")", ",", "(", "0.26862954", ",", "0.26130258", ",", "0.27577711", ")", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.available_models": [[68, 71], ["list", "_MODELS.keys"], "function", ["None"], ["", "def", "available_models", "(", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"Returns the names of available CLIP models\"\"\"", "\n", "return", "list", "(", "_MODELS", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load": [[73, 162], ["torch.jit.trace", "build_model().to.apply", "clip.load.patch_device"], "function", ["None"], ["", "def", "load", "(", "name", ":", "str", ",", "device", ":", "Union", "[", "str", ",", "torch", ".", "device", "]", "=", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ",", "jit", "=", "True", ")", ":", "\n", "    ", "\"\"\"Load a CLIP model\n\n    Parameters\n    ----------\n    name : str\n        A model name listed by `clip.available_models()`, or the path to a model checkpoint containing the state_dict\n\n    device : Union[str, torch.device]\n        The device to put the loaded model\n\n    jit : bool\n        Whether to load the optimized JIT model (default) or more hackable non-JIT model.\n\n    Returns\n    -------\n    model : torch.nn.Module\n        The CLIP model\n\n    preprocess : Callable[[PIL.Image], torch.Tensor]\n        A torchvision transform that converts a PIL image into a tensor that the returned model can take as its input\n    \"\"\"", "\n", "if", "name", "in", "_MODELS", ":", "\n", "        ", "model_path", "=", "_download", "(", "_MODELS", "[", "name", "]", ")", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "name", ")", ":", "\n", "        ", "model_path", "=", "name", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"Model {name} not found; available models = {available_models()}\"", ")", "\n", "\n", "", "try", ":", "\n", "# loading JIT archive", "\n", "        ", "model", "=", "torch", ".", "jit", ".", "load", "(", "model_path", ",", "map_location", "=", "device", "if", "jit", "else", "\"cpu\"", ")", ".", "eval", "(", ")", "\n", "state_dict", "=", "None", "\n", "", "except", "RuntimeError", ":", "\n", "# loading saved state dict", "\n", "        ", "if", "jit", ":", "\n", "            ", "warnings", ".", "warn", "(", "f\"File {model_path} is not a JIT archive. Loading as a state dict instead\"", ")", "\n", "jit", "=", "False", "\n", "", "state_dict", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "\"cpu\"", ")", "\n", "\n", "", "if", "not", "jit", ":", "\n", "        ", "model", "=", "build_model", "(", "state_dict", "or", "model", ".", "state_dict", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "if", "str", "(", "device", ")", "==", "\"cpu\"", ":", "\n", "            ", "model", ".", "float", "(", ")", "\n", "", "return", "model", ",", "_transform", "(", "model", ".", "visual", ".", "input_resolution", ")", "\n", "\n", "# patch the device names", "\n", "", "device_holder", "=", "torch", ".", "jit", ".", "trace", "(", "lambda", ":", "torch", ".", "ones", "(", "[", "]", ")", ".", "to", "(", "torch", ".", "device", "(", "device", ")", ")", ",", "example_inputs", "=", "[", "]", ")", "\n", "device_node", "=", "[", "n", "for", "n", "in", "device_holder", ".", "graph", ".", "findAllNodes", "(", "\"prim::Constant\"", ")", "if", "\"Device\"", "in", "repr", "(", "n", ")", "]", "[", "-", "1", "]", "\n", "\n", "def", "patch_device", "(", "module", ")", ":", "\n", "        ", "graphs", "=", "[", "module", ".", "graph", "]", "if", "hasattr", "(", "module", ",", "\"graph\"", ")", "else", "[", "]", "\n", "if", "hasattr", "(", "module", ",", "\"forward1\"", ")", ":", "\n", "            ", "graphs", ".", "append", "(", "module", ".", "forward1", ".", "graph", ")", "\n", "\n", "", "for", "graph", "in", "graphs", ":", "\n", "            ", "for", "node", "in", "graph", ".", "findAllNodes", "(", "\"prim::Constant\"", ")", ":", "\n", "                ", "if", "\"value\"", "in", "node", ".", "attributeNames", "(", ")", "and", "str", "(", "node", "[", "\"value\"", "]", ")", ".", "startswith", "(", "\"cuda\"", ")", ":", "\n", "                    ", "node", ".", "copyAttributes", "(", "device_node", ")", "\n", "\n", "", "", "", "", "model", ".", "apply", "(", "patch_device", ")", "\n", "patch_device", "(", "model", ".", "encode_image", ")", "\n", "patch_device", "(", "model", ".", "encode_text", ")", "\n", "\n", "# patch dtype to float32 on CPU", "\n", "if", "str", "(", "device", ")", "==", "\"cpu\"", ":", "\n", "        ", "float_holder", "=", "torch", ".", "jit", ".", "trace", "(", "lambda", ":", "torch", ".", "ones", "(", "[", "]", ")", ".", "float", "(", ")", ",", "example_inputs", "=", "[", "]", ")", "\n", "float_input", "=", "list", "(", "float_holder", ".", "graph", ".", "findNode", "(", "\"aten::to\"", ")", ".", "inputs", "(", ")", ")", "[", "1", "]", "\n", "float_node", "=", "float_input", ".", "node", "(", ")", "\n", "\n", "def", "patch_float", "(", "module", ")", ":", "\n", "            ", "graphs", "=", "[", "module", ".", "graph", "]", "if", "hasattr", "(", "module", ",", "\"graph\"", ")", "else", "[", "]", "\n", "if", "hasattr", "(", "module", ",", "\"forward1\"", ")", ":", "\n", "                ", "graphs", ".", "append", "(", "module", ".", "forward1", ".", "graph", ")", "\n", "\n", "", "for", "graph", "in", "graphs", ":", "\n", "                ", "for", "node", "in", "graph", ".", "findAllNodes", "(", "\"aten::to\"", ")", ":", "\n", "                    ", "inputs", "=", "list", "(", "node", ".", "inputs", "(", ")", ")", "\n", "for", "i", "in", "[", "1", ",", "2", "]", ":", "# dtype can be the second or third argument to aten::to()", "\n", "                        ", "if", "inputs", "[", "i", "]", ".", "node", "(", ")", "[", "\"value\"", "]", "==", "5", ":", "\n", "                            ", "inputs", "[", "i", "]", ".", "node", "(", ")", ".", "copyAttributes", "(", "float_node", ")", "\n", "\n", "", "", "", "", "", "model", ".", "apply", "(", "patch_float", ")", "\n", "patch_float", "(", "model", ".", "encode_image", ")", "\n", "patch_float", "(", "model", ".", "encode_text", ")", "\n", "\n", "model", ".", "float", "(", ")", "\n", "\n", "", "return", "model", ",", "_transform", "(", "model", ".", "input_resolution", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.tokenize": [[164, 196], ["isinstance", "torch.zeros", "enumerate", "len", "torch.tensor", "len", "RuntimeError", "_tokenizer.encode", "len"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.simple_tokenizer.SimpleTokenizer.encode"], ["", "def", "tokenize", "(", "texts", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "context_length", ":", "int", "=", "77", ",", "max_valid_length", ":", "int", "=", "32", ")", "->", "torch", ".", "LongTensor", ":", "\n", "    ", "\"\"\"\n    Returns the tokenized representation of given input string(s)\n\n    Parameters\n    ----------\n    texts : Union[str, List[str]]\n        An input string or a list of input strings to tokenize\n\n    context_length : int\n        The context length to use; all CLIP models use 77 as the context length\n\n    max_valid_length:\n\n    Returns\n    -------\n    A two-dimensional tensor containing the resulting tokens, shape = [number of input strings, context_length]\n    \"\"\"", "\n", "if", "isinstance", "(", "texts", ",", "str", ")", ":", "\n", "        ", "texts", "=", "[", "texts", "]", "\n", "\n", "", "sot_token", "=", "_tokenizer", ".", "encoder", "[", "\"<|startoftext|>\"", "]", "\n", "eot_token", "=", "_tokenizer", ".", "encoder", "[", "\"<|endoftext|>\"", "]", "\n", "all_tokens", "=", "[", "[", "sot_token", "]", "+", "_tokenizer", ".", "encode", "(", "text", ")", "[", ":", "max_valid_length", "-", "2", "]", "+", "[", "eot_token", "]", "for", "text", "in", "texts", "]", "\n", "result", "=", "torch", ".", "zeros", "(", "len", "(", "all_tokens", ")", ",", "context_length", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "for", "i", ",", "tokens", "in", "enumerate", "(", "all_tokens", ")", ":", "\n", "        ", "if", "len", "(", "tokens", ")", ">", "context_length", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Input {texts[i]} is too long for context length {context_length}\"", ")", "\n", "", "result", "[", "i", ",", ":", "len", "(", "tokens", ")", "]", "=", "torch", ".", "tensor", "(", "tokens", ")", "\n", "\n", "", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.Bottleneck.__init__": [[13, 38], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "torch.nn.Identity", "torch.nn.Identity", "torch.nn.Sequential", "torch.nn.Sequential", "collections.OrderedDict", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# all conv layers have stride 1. an avgpool is performed after the second convolution when stride > 1", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "stride", ")", "if", "stride", ">", "1", "else", "nn", ".", "Identity", "(", ")", "\n", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "None", "\n", "self", ".", "stride", "=", "stride", "\n", "\n", "if", "stride", ">", "1", "or", "inplanes", "!=", "planes", "*", "Bottleneck", ".", "expansion", ":", "\n", "# downsampling layer is prepended with an avgpool, and the subsequent convolution has stride 1", "\n", "            ", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"-1\"", ",", "nn", ".", "AvgPool2d", "(", "stride", ")", ")", ",", "\n", "(", "\"0\"", ",", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", "*", "self", ".", "expansion", ",", "1", ",", "stride", "=", "1", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "\"1\"", ",", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", ")", "\n", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.Bottleneck.forward": [[40, 54], ["model.Bottleneck.relu", "model.Bottleneck.relu", "model.Bottleneck.avgpool", "model.Bottleneck.bn3", "model.Bottleneck.relu", "model.Bottleneck.bn1", "model.Bottleneck.bn2", "model.Bottleneck.conv3", "model.Bottleneck.downsample", "model.Bottleneck.conv1", "model.Bottleneck.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "avgpool", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "out", ")", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.AttentionPool2d.__init__": [[57, 65], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spacial_dim", ":", "int", ",", "embed_dim", ":", "int", ",", "num_heads", ":", "int", ",", "output_dim", ":", "int", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "spacial_dim", "**", "2", "+", "1", ",", "embed_dim", ")", "/", "embed_dim", "**", "0.5", ")", "\n", "self", ".", "k_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "q_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "v_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "c_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "output_dim", "or", "embed_dim", ")", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.AttentionPool2d.forward": [[66, 91], ["torch.cat.reshape().permute", "torch.cat.reshape().permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.multi_head_attention_forward", "torch.multi_head_attention_forward", "model.AttentionPool2d.positional_embedding[].to", "torch.cat.reshape", "torch.cat.reshape", "torch.cat.mean", "torch.cat.mean", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# NCHW -> (HW)NC", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ".", "mean", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ",", "x", "]", ",", "dim", "=", "0", ")", "# (HW+1)NC", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", "[", ":", ",", "None", ",", ":", "]", ".", "to", "(", "x", ".", "dtype", ")", "# (HW+1)NC", "\n", "x", ",", "_", "=", "F", ".", "multi_head_attention_forward", "(", "\n", "query", "=", "x", ",", "key", "=", "x", ",", "value", "=", "x", ",", "\n", "embed_dim_to_check", "=", "x", ".", "shape", "[", "-", "1", "]", ",", "\n", "num_heads", "=", "self", ".", "num_heads", ",", "\n", "q_proj_weight", "=", "self", ".", "q_proj", ".", "weight", ",", "\n", "k_proj_weight", "=", "self", ".", "k_proj", ".", "weight", ",", "\n", "v_proj_weight", "=", "self", ".", "v_proj", ".", "weight", ",", "\n", "in_proj_weight", "=", "None", ",", "\n", "in_proj_bias", "=", "torch", ".", "cat", "(", "[", "self", ".", "q_proj", ".", "bias", ",", "self", ".", "k_proj", ".", "bias", ",", "self", ".", "v_proj", ".", "bias", "]", ")", ",", "\n", "bias_k", "=", "None", ",", "\n", "bias_v", "=", "None", ",", "\n", "add_zero_attn", "=", "False", ",", "\n", "dropout_p", "=", "0", ",", "\n", "out_proj_weight", "=", "self", ".", "c_proj", ".", "weight", ",", "\n", "out_proj_bias", "=", "self", ".", "c_proj", ".", "bias", ",", "\n", "use_separate_proj_weight", "=", "True", ",", "\n", "training", "=", "self", ".", "training", ",", "\n", "need_weights", "=", "False", "\n", ")", "\n", "\n", "return", "x", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet.__init__": [[101, 125], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "torch.nn.ReLU", "torch.nn.ReLU", "model.ModifiedResNet._make_layer", "model.ModifiedResNet._make_layer", "model.ModifiedResNet._make_layer", "model.ModifiedResNet._make_layer", "model.AttentionPool2d"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet._make_layer", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet._make_layer", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet._make_layer", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet._make_layer"], ["def", "__init__", "(", "self", ",", "layers", ",", "output_dim", ",", "heads", ",", "input_resolution", "=", "224", ",", "width", "=", "64", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "\n", "# the 3-layer stem", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "width", "//", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "width", "//", "2", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "width", "//", "2", ",", "width", "//", "2", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "width", "//", "2", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "width", "//", "2", ",", "width", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "width", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "2", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# residual layers", "\n", "self", ".", "_inplanes", "=", "width", "# this is a *mutable* variable used during construction", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "width", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "width", "*", "2", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "width", "*", "4", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "width", "*", "8", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "\n", "embed_dim", "=", "width", "*", "32", "# the ResNet feature dimension", "\n", "self", ".", "attnpool", "=", "AttentionPool2d", "(", "input_resolution", "//", "32", ",", "embed_dim", ",", "heads", ",", "output_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet._make_layer": [[126, 134], ["range", "torch.nn.Sequential", "torch.nn.Sequential", "model.Bottleneck", "layers.append", "model.Bottleneck"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "Bottleneck", "(", "self", ".", "_inplanes", ",", "planes", ",", "stride", ")", "]", "\n", "\n", "self", ".", "_inplanes", "=", "planes", "*", "Bottleneck", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "Bottleneck", "(", "self", ".", "_inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ModifiedResNet.forward": [[135, 151], ["model.ModifiedResNet.type", "model.ModifiedResNet.forward.stem"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "def", "stem", "(", "x", ")", ":", "\n", "            ", "for", "conv", ",", "bn", "in", "[", "(", "self", ".", "conv1", ",", "self", ".", "bn1", ")", ",", "(", "self", ".", "conv2", ",", "self", ".", "bn2", ")", ",", "(", "self", ".", "conv3", ",", "self", ".", "bn3", ")", "]", ":", "\n", "                ", "x", "=", "self", ".", "relu", "(", "bn", "(", "conv", "(", "x", ")", ")", ")", "\n", "", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "x", "=", "x", ".", "type", "(", "self", ".", "conv1", ".", "weight", ".", "dtype", ")", "\n", "x", "=", "stem", "(", "x", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "x", "=", "self", ".", "attnpool", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.LayerNorm.forward": [[156, 160], ["super().forward", "super().forward.type", "x.type"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.forward"], ["def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "orig_type", "=", "x", ".", "dtype", "\n", "ret", "=", "super", "(", ")", ".", "forward", "(", "x", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "return", "ret", ".", "type", "(", "orig_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.QuickGELU.forward": [[163, 165], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "x", "*", "torch", ".", "sigmoid", "(", "1.702", "*", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ResidualAttentionBlock.__init__": [[168, 180], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "model.LayerNorm", "torch.nn.Sequential", "torch.nn.Sequential", "model.LayerNorm", "collections.OrderedDict", "torch.nn.Linear", "torch.nn.Linear", "model.QuickGELU", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ":", "int", ",", "n_head", ":", "int", ",", "attn_mask", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "n_head", ")", "\n", "self", ".", "ln_1", "=", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"c_fc\"", ",", "nn", ".", "Linear", "(", "d_model", ",", "d_model", "*", "4", ")", ")", ",", "\n", "(", "\"gelu\"", ",", "QuickGELU", "(", ")", ")", ",", "\n", "(", "\"c_proj\"", ",", "nn", ".", "Linear", "(", "d_model", "*", "4", ",", "d_model", ")", ")", "\n", "]", ")", ")", "\n", "self", ".", "ln_2", "=", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "attn_mask", "=", "attn_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ResidualAttentionBlock.attention": [[181, 184], ["model.ResidualAttentionBlock.attn_mask.to", "model.ResidualAttentionBlock.attn"], "methods", ["None"], ["", "def", "attention", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "self", ".", "attn_mask", "=", "self", ".", "attn_mask", ".", "to", "(", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "if", "self", ".", "attn_mask", "is", "not", "None", "else", "None", "\n", "return", "self", ".", "attn", "(", "x", ",", "x", ",", "x", ",", "need_weights", "=", "False", ",", "attn_mask", "=", "self", ".", "attn_mask", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ResidualAttentionBlock.forward": [[185, 189], ["model.ResidualAttentionBlock.attention", "model.ResidualAttentionBlock.mlp", "model.ResidualAttentionBlock.ln_1", "model.ResidualAttentionBlock.ln_2"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.ResidualAttentionBlock.attention"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "x", "=", "x", "+", "self", ".", "attention", "(", "self", ".", "ln_1", "(", "x", ")", ")", "\n", "x", "=", "x", "+", "self", ".", "mlp", "(", "self", ".", "ln_2", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.Transformer.__init__": [[192, 197], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "model.ResidualAttentionBlock", "range"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "width", ":", "int", ",", "layers", ":", "int", ",", "heads", ":", "int", ",", "attn_mask", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "resblocks", "=", "nn", ".", "Sequential", "(", "*", "[", "ResidualAttentionBlock", "(", "width", ",", "heads", ",", "attn_mask", ")", "for", "_", "in", "range", "(", "layers", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.Transformer.forward": [[198, 200], ["model.Transformer.resblocks"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "self", ".", "resblocks", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.VisualTransformer.__init__": [[203, 218], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "model.LayerNorm", "model.Transformer", "model.LayerNorm", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_resolution", ":", "int", ",", "patch_size", ":", "int", ",", "width", ":", "int", ",", "layers", ":", "int", ",", "heads", ":", "int", ",", "output_dim", ":", "int", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "3", ",", "out_channels", "=", "width", ",", "kernel_size", "=", "patch_size", ",", "stride", "=", "patch_size", ",", "bias", "=", "False", ")", "\n", "\n", "scale", "=", "width", "**", "-", "0.5", "\n", "self", ".", "class_embedding", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "width", ")", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "(", "input_resolution", "//", "patch_size", ")", "**", "2", "+", "1", ",", "width", ")", ")", "\n", "self", ".", "ln_pre", "=", "LayerNorm", "(", "width", ")", "\n", "\n", "self", ".", "transformer", "=", "Transformer", "(", "width", ",", "layers", ",", "heads", ")", "\n", "\n", "self", ".", "ln_post", "=", "LayerNorm", "(", "width", ")", "\n", "self", ".", "proj", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "width", ",", "output_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.VisualTransformer.forward": [[219, 237], ["model.VisualTransformer.conv1", "model.VisualTransformer.reshape", "model.VisualTransformer.permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.VisualTransformer.ln_pre", "model.VisualTransformer.permute", "model.VisualTransformer.transformer", "model.VisualTransformer.permute", "model.VisualTransformer.ln_post", "model.VisualTransformer.positional_embedding.to", "model.VisualTransformer.class_embedding.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "# shape = [*, width, grid, grid]", "\n", "x", "=", "x", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "# shape = [*, width, grid ** 2]", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# shape = [*, grid ** 2, width]", "\n", "x", "=", "torch", ".", "cat", "(", "[", "self", ".", "class_embedding", ".", "to", "(", "x", ".", "dtype", ")", "+", "torch", ".", "zeros", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "x", ".", "shape", "[", "-", "1", "]", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", ",", "x", "]", ",", "dim", "=", "1", ")", "# shape = [*, grid ** 2 + 1, width]", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", ".", "to", "(", "x", ".", "dtype", ")", "\n", "x", "=", "self", ".", "ln_pre", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# NLD -> LND", "\n", "x", "=", "self", ".", "transformer", "(", "x", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# LND -> NLD", "\n", "\n", "x", "=", "self", ".", "ln_post", "(", "x", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "\n", "if", "self", ".", "proj", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", "@", "self", ".", "proj", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.__init__": [[240, 294], ["torch.nn.Module.__init__", "isinstance", "model.Transformer", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Parameter", "torch.nn.Parameter", "model.LayerNorm", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "model.CLIP.initialize_parameters", "model.ModifiedResNet", "model.VisualTransformer", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "model.CLIP.build_attention_mask", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.initialize_parameters", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.build_attention_mask"], ["    ", "def", "__init__", "(", "self", ",", "\n", "embed_dim", ":", "int", ",", "\n", "# vision", "\n", "image_resolution", ":", "int", ",", "\n", "vision_layers", ":", "Union", "[", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", "]", ",", "int", "]", ",", "\n", "vision_width", ":", "int", ",", "\n", "vision_patch_size", ":", "int", ",", "\n", "# text", "\n", "context_length", ":", "int", ",", "\n", "vocab_size", ":", "int", ",", "\n", "transformer_width", ":", "int", ",", "\n", "transformer_heads", ":", "int", ",", "\n", "transformer_layers", ":", "int", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "context_length", "=", "context_length", "\n", "\n", "if", "isinstance", "(", "vision_layers", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "vision_heads", "=", "vision_width", "*", "32", "//", "64", "\n", "self", ".", "visual", "=", "ModifiedResNet", "(", "\n", "layers", "=", "vision_layers", ",", "\n", "output_dim", "=", "embed_dim", ",", "\n", "heads", "=", "vision_heads", ",", "\n", "input_resolution", "=", "image_resolution", ",", "\n", "width", "=", "vision_width", "\n", ")", "\n", "", "else", ":", "\n", "            ", "vision_heads", "=", "vision_width", "//", "64", "\n", "self", ".", "visual", "=", "VisualTransformer", "(", "\n", "input_resolution", "=", "image_resolution", ",", "\n", "patch_size", "=", "vision_patch_size", ",", "\n", "width", "=", "vision_width", ",", "\n", "layers", "=", "vision_layers", ",", "\n", "heads", "=", "vision_heads", ",", "\n", "output_dim", "=", "embed_dim", "\n", ")", "\n", "\n", "", "self", ".", "transformer", "=", "Transformer", "(", "\n", "width", "=", "transformer_width", ",", "\n", "layers", "=", "transformer_layers", ",", "\n", "heads", "=", "transformer_heads", ",", "\n", "attn_mask", "=", "self", ".", "build_attention_mask", "(", ")", "\n", ")", "\n", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "token_embedding", "=", "nn", ".", "Embedding", "(", "vocab_size", ",", "transformer_width", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "self", ".", "context_length", ",", "transformer_width", ")", ")", "\n", "self", ".", "ln_final", "=", "LayerNorm", "(", "transformer_width", ")", "\n", "\n", "self", ".", "text_projection", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "transformer_width", ",", "embed_dim", ")", ")", "\n", "self", ".", "logit_scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "[", "]", ")", "*", "np", ".", "log", "(", "1", "/", "0.07", ")", ")", "\n", "\n", "self", ".", "initialize_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.initialize_parameters": [[295, 323], ["torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "isinstance", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "resnet_block.named_parameters", "name.endswith", "torch.nn.init.zeros_", "torch.nn.init.zeros_"], "methods", ["None"], ["", "def", "initialize_parameters", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "token_embedding", ".", "weight", ",", "std", "=", "0.02", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "positional_embedding", ",", "std", "=", "0.01", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "visual", ",", "ModifiedResNet", ")", ":", "\n", "            ", "if", "self", ".", "visual", ".", "attnpool", "is", "not", "None", ":", "\n", "                ", "std", "=", "self", ".", "visual", ".", "attnpool", ".", "c_proj", ".", "in_features", "**", "-", "0.5", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "q_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "k_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "v_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "c_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "\n", "", "for", "resnet_block", "in", "[", "self", ".", "visual", ".", "layer1", ",", "self", ".", "visual", ".", "layer2", ",", "self", ".", "visual", ".", "layer3", ",", "self", ".", "visual", ".", "layer4", "]", ":", "\n", "                ", "for", "name", ",", "param", "in", "resnet_block", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "name", ".", "endswith", "(", "\"bn3.weight\"", ")", ":", "\n", "                        ", "nn", ".", "init", ".", "zeros_", "(", "param", ")", "\n", "\n", "", "", "", "", "proj_std", "=", "(", "self", ".", "transformer", ".", "width", "**", "-", "0.5", ")", "*", "(", "(", "2", "*", "self", ".", "transformer", ".", "layers", ")", "**", "-", "0.5", ")", "\n", "attn_std", "=", "self", ".", "transformer", ".", "width", "**", "-", "0.5", "\n", "fc_std", "=", "(", "2", "*", "self", ".", "transformer", ".", "width", ")", "**", "-", "0.5", "\n", "for", "block", "in", "self", ".", "transformer", ".", "resblocks", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "block", ".", "attn", ".", "in_proj_weight", ",", "std", "=", "attn_std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "block", ".", "attn", ".", "out_proj", ".", "weight", ",", "std", "=", "proj_std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "block", ".", "mlp", ".", "c_fc", ".", "weight", ",", "std", "=", "fc_std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "block", ".", "mlp", ".", "c_proj", ".", "weight", ",", "std", "=", "proj_std", ")", "\n", "\n", "", "if", "self", ".", "text_projection", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "text_projection", ",", "std", "=", "self", ".", "transformer", ".", "width", "**", "-", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.build_attention_mask": [[324, 331], ["torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty.fill_", "torch.empty.fill_", "torch.empty.triu_", "torch.empty.triu_", "float"], "methods", ["None"], ["", "", "def", "build_attention_mask", "(", "self", ")", ":", "\n", "# lazily create causal attention mask, with full attention between the vision tokens", "\n", "# pytorch uses additive attention mask; fill with -inf", "\n", "        ", "mask", "=", "torch", ".", "empty", "(", "self", ".", "context_length", ",", "self", ".", "context_length", ")", "\n", "mask", ".", "fill_", "(", "float", "(", "\"-inf\"", ")", ")", "\n", "mask", ".", "triu_", "(", "1", ")", "# zero out the lower diagonal", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.dtype": [[332, 335], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "visual", ".", "conv1", ".", "weight", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_image": [[336, 338], ["model.CLIP.visual", "image.type"], "methods", ["None"], ["", "def", "encode_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "return", "self", ".", "visual", "(", "image", ".", "type", "(", "self", ".", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_text": [[339, 353], ["model.CLIP.token_embedding().type", "model.CLIP.permute", "model.CLIP.transformer", "model.CLIP.permute", "model.CLIP.ln_final().type", "dict", "model.CLIP.positional_embedding.type", "model.CLIP.token_embedding", "model.CLIP.ln_final", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "text.argmax"], "methods", ["None"], ["", "def", "encode_text", "(", "self", ",", "text", ")", ":", "\n", "        ", "x", "=", "self", ".", "token_embedding", "(", "text", ")", ".", "type", "(", "self", ".", "dtype", ")", "# [batch_size, n_ctx, d_model]", "\n", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", ".", "type", "(", "self", ".", "dtype", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# NLD -> LND", "\n", "x", "=", "self", ".", "transformer", "(", "x", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# LND -> NLD", "\n", "x", "=", "self", ".", "ln_final", "(", "x", ")", ".", "type", "(", "self", ".", "dtype", ")", "\n", "\n", "# x.shape = [batch_size, n_ctx, transformer.width]", "\n", "# take features from the eot embedding (eot_token is the highest number in each sequence)", "\n", "eos_x", "=", "x", "[", "torch", ".", "arange", "(", "x", ".", "shape", "[", "0", "]", ")", ",", "text", ".", "argmax", "(", "dim", "=", "-", "1", ")", "]", "@", "self", ".", "text_projection", "\n", "\n", "return", "dict", "(", "last_hidden_state", "=", "x", ",", "pooler_output", "=", "eos_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.forward": [[354, 369], ["model.CLIP.encode_image", "model.CLIP.encode_text", "model.CLIP.logit_scale.exp", "model.CLIP.norm", "model.CLIP.norm", "model.CLIP.t", "model.CLIP.t"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_image", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.CLIP.encode_text"], ["", "def", "forward", "(", "self", ",", "image", ",", "text", ")", ":", "\n", "        ", "image_features", "=", "self", ".", "encode_image", "(", "image", ")", "\n", "text_features", "=", "self", ".", "encode_text", "(", "text", ")", "\n", "\n", "# normalized features", "\n", "image_features", "=", "image_features", "/", "image_features", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "text_features", "=", "text_features", "/", "text_features", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "# cosine similarity as logits", "\n", "logit_scale", "=", "self", ".", "logit_scale", ".", "exp", "(", ")", "\n", "logits_per_image", "=", "logit_scale", "*", "image_features", "@", "text_features", ".", "t", "(", ")", "\n", "logits_per_text", "=", "logit_scale", "*", "text_features", "@", "image_features", ".", "t", "(", ")", "\n", "\n", "# shape = [global_batch_size, global_batch_size]", "\n", "return", "logits_per_image", ",", "logits_per_text", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.convert_weights": [[371, 393], ["model.apply", "isinstance", "isinstance", "l.weight.data.half", "hasattr", "l.bias.data.half", "getattr", "getattr", "getattr.data.half", "getattr.data.half"], "function", ["None"], ["", "", "def", "convert_weights", "(", "model", ":", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"Convert applicable model parameters to fp16\"\"\"", "\n", "\n", "def", "_convert_weights_to_fp16", "(", "l", ")", ":", "\n", "        ", "if", "isinstance", "(", "l", ",", "(", "nn", ".", "Conv1d", ",", "nn", ".", "Conv2d", ",", "nn", ".", "Linear", ")", ")", ":", "\n", "            ", "l", ".", "weight", ".", "data", "=", "l", ".", "weight", ".", "data", ".", "half", "(", ")", "\n", "if", "l", ".", "bias", "is", "not", "None", ":", "\n", "                ", "l", ".", "bias", ".", "data", "=", "l", ".", "bias", ".", "data", ".", "half", "(", ")", "\n", "\n", "", "", "if", "isinstance", "(", "l", ",", "nn", ".", "MultiheadAttention", ")", ":", "\n", "            ", "for", "attr", "in", "[", "*", "[", "f\"{s}_proj_weight\"", "for", "s", "in", "[", "\"in\"", ",", "\"q\"", ",", "\"k\"", ",", "\"v\"", "]", "]", ",", "\"in_proj_bias\"", ",", "\"bias_k\"", ",", "\"bias_v\"", "]", ":", "\n", "                ", "tensor", "=", "getattr", "(", "l", ",", "attr", ")", "\n", "if", "tensor", "is", "not", "None", ":", "\n", "                    ", "tensor", ".", "data", "=", "tensor", ".", "data", ".", "half", "(", ")", "\n", "\n", "", "", "", "for", "name", "in", "[", "\"text_projection\"", ",", "\"proj\"", "]", ":", "\n", "            ", "if", "hasattr", "(", "l", ",", "name", ")", ":", "\n", "                ", "attr", "=", "getattr", "(", "l", ",", "name", ")", "\n", "if", "attr", "is", "not", "None", ":", "\n", "                    ", "attr", ".", "data", "=", "attr", ".", "data", ".", "half", "(", ")", "\n", "\n", "", "", "", "", "model", ".", "apply", "(", "_convert_weights_to_fp16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.build_model": [[395, 433], ["len", "model.CLIP", "model.convert_weights", "CLIP.load_state_dict", "CLIP.eval", "len", "round", "tuple", "round", "set", "len", "set", "state_dict.keys", "k.split", "k.startswith", "k.startswith", "k.endswith", "k.split", "k.startswith"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.model.convert_weights"], ["", "def", "build_model", "(", "state_dict", ":", "dict", ")", ":", "\n", "    ", "vit", "=", "\"visual.proj\"", "in", "state_dict", "\n", "\n", "if", "vit", ":", "\n", "        ", "vision_width", "=", "state_dict", "[", "\"visual.conv1.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "vision_layers", "=", "len", "(", "[", "k", "for", "k", "in", "state_dict", ".", "keys", "(", ")", "if", "k", ".", "startswith", "(", "\"visual.\"", ")", "and", "k", ".", "endswith", "(", "\".attn.in_proj_weight\"", ")", "]", ")", "\n", "vision_patch_size", "=", "state_dict", "[", "\"visual.conv1.weight\"", "]", ".", "shape", "[", "-", "1", "]", "\n", "grid_size", "=", "round", "(", "(", "state_dict", "[", "\"visual.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "**", "0.5", ")", "\n", "image_resolution", "=", "vision_patch_size", "*", "grid_size", "\n", "", "else", ":", "\n", "        ", "counts", ":", "list", "=", "[", "len", "(", "set", "(", "k", ".", "split", "(", "\".\"", ")", "[", "2", "]", "for", "k", "in", "state_dict", "if", "k", ".", "startswith", "(", "f\"visual.layer{b}\"", ")", ")", ")", "for", "b", "in", "[", "1", ",", "2", ",", "3", ",", "4", "]", "]", "\n", "vision_layers", "=", "tuple", "(", "counts", ")", "\n", "vision_width", "=", "state_dict", "[", "\"visual.layer1.0.conv1.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "output_width", "=", "round", "(", "(", "state_dict", "[", "\"visual.attnpool.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "**", "0.5", ")", "\n", "vision_patch_size", "=", "None", "\n", "assert", "output_width", "**", "2", "+", "1", "==", "state_dict", "[", "\"visual.attnpool.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "\n", "image_resolution", "=", "output_width", "*", "32", "\n", "\n", "", "embed_dim", "=", "state_dict", "[", "\"text_projection\"", "]", ".", "shape", "[", "1", "]", "\n", "context_length", "=", "state_dict", "[", "\"positional_embedding\"", "]", ".", "shape", "[", "0", "]", "\n", "vocab_size", "=", "state_dict", "[", "\"token_embedding.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "transformer_width", "=", "state_dict", "[", "\"ln_final.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "transformer_heads", "=", "transformer_width", "//", "64", "\n", "transformer_layers", "=", "len", "(", "set", "(", "k", ".", "split", "(", "\".\"", ")", "[", "2", "]", "for", "k", "in", "state_dict", "if", "k", ".", "startswith", "(", "f\"transformer.resblocks\"", ")", ")", ")", "\n", "\n", "model", "=", "CLIP", "(", "\n", "embed_dim", ",", "\n", "image_resolution", ",", "vision_layers", ",", "vision_width", ",", "vision_patch_size", ",", "\n", "context_length", ",", "vocab_size", ",", "transformer_width", ",", "transformer_heads", ",", "transformer_layers", "\n", ")", "\n", "\n", "for", "key", "in", "[", "\"input_resolution\"", ",", "\"context_length\"", ",", "\"vocab_size\"", "]", ":", "\n", "        ", "if", "key", "in", "state_dict", ":", "\n", "            ", "del", "state_dict", "[", "key", "]", "\n", "\n", "", "", "convert_weights", "(", "model", ")", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "model", ".", "eval", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_average_precision_detection_wrapper": [[11, 17], ["numpy.linspace", "standalone_eval.utils.compute_average_precision_detection"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_average_precision_detection"], ["def", "compute_average_precision_detection_wrapper", "(", "\n", "input_triple", ",", "tiou_thresholds", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "10", ")", ")", ":", "\n", "    ", "qid", ",", "ground_truth", ",", "prediction", "=", "input_triple", "\n", "scores", "=", "compute_average_precision_detection", "(", "\n", "ground_truth", ",", "prediction", ",", "tiou_thresholds", "=", "tiou_thresholds", ")", "\n", "return", "qid", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_mr_ap": [[19, 70], ["numpy.linspace", "collections.defaultdict", "collections.defaultdict", "partial", "numpy.array", "np.array.mean", "dict", "numpy.mean", "float", "list", "zip", "float", "pred_qid2data[].append", "gt_qid2data[].append", "multiprocessing.Pool", "pool.imap_unordered", "partial.", "qid2ap_list.values", "dict.items", "str"], "function", ["None"], ["", "def", "compute_mr_ap", "(", "submission", ",", "ground_truth", ",", "iou_thds", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "10", ")", ",", "\n", "max_gt_windows", "=", "None", ",", "max_pred_windows", "=", "10", ",", "num_workers", "=", "8", ",", "chunksize", "=", "50", ")", ":", "\n", "    ", "iou_thds", "=", "[", "float", "(", "f\"{e:.2f}\"", ")", "for", "e", "in", "iou_thds", "]", "\n", "pred_qid2data", "=", "defaultdict", "(", "list", ")", "\n", "for", "d", "in", "submission", ":", "\n", "        ", "pred_windows", "=", "d", "[", "\"pred_relevant_windows\"", "]", "[", ":", "max_pred_windows", "]", "if", "max_pred_windows", "is", "not", "None", "else", "d", "[", "\"pred_relevant_windows\"", "]", "\n", "qid", "=", "d", "[", "\"qid\"", "]", "\n", "for", "w", "in", "pred_windows", ":", "\n", "            ", "pred_qid2data", "[", "qid", "]", ".", "append", "(", "{", "\n", "\"video-id\"", ":", "d", "[", "\"qid\"", "]", ",", "# in order to use the API", "\n", "\"t-start\"", ":", "w", "[", "0", "]", ",", "\n", "\"t-end\"", ":", "w", "[", "1", "]", ",", "\n", "\"score\"", ":", "w", "[", "2", "]", "\n", "}", ")", "\n", "\n", "", "", "gt_qid2data", "=", "defaultdict", "(", "list", ")", "\n", "for", "d", "in", "ground_truth", ":", "\n", "        ", "gt_windows", "=", "d", "[", "\"relevant_windows\"", "]", "[", ":", "max_gt_windows", "]", "if", "max_gt_windows", "is", "not", "None", "else", "d", "[", "\"relevant_windows\"", "]", "\n", "qid", "=", "d", "[", "\"qid\"", "]", "\n", "for", "w", "in", "gt_windows", ":", "\n", "            ", "gt_qid2data", "[", "qid", "]", ".", "append", "(", "{", "\n", "\"video-id\"", ":", "d", "[", "\"qid\"", "]", ",", "\n", "\"t-start\"", ":", "w", "[", "0", "]", ",", "\n", "\"t-end\"", ":", "w", "[", "1", "]", "\n", "}", ")", "\n", "", "", "qid2ap_list", "=", "{", "}", "\n", "# start_time = time.time()", "\n", "data_triples", "=", "[", "[", "qid", ",", "gt_qid2data", "[", "qid", "]", ",", "pred_qid2data", "[", "qid", "]", "]", "for", "qid", "in", "pred_qid2data", "]", "\n", "from", "functools", "import", "partial", "\n", "compute_ap_from_triple", "=", "partial", "(", "\n", "compute_average_precision_detection_wrapper", ",", "tiou_thresholds", "=", "iou_thds", ")", "\n", "\n", "if", "num_workers", ">", "1", ":", "\n", "        ", "with", "mp", ".", "Pool", "(", "num_workers", ")", "as", "pool", ":", "\n", "            ", "for", "qid", ",", "scores", "in", "pool", ".", "imap_unordered", "(", "compute_ap_from_triple", ",", "data_triples", ",", "chunksize", "=", "chunksize", ")", ":", "\n", "                ", "qid2ap_list", "[", "qid", "]", "=", "scores", "\n", "", "", "", "else", ":", "\n", "        ", "for", "data_triple", "in", "data_triples", ":", "\n", "            ", "qid", ",", "scores", "=", "compute_ap_from_triple", "(", "data_triple", ")", "\n", "qid2ap_list", "[", "qid", "]", "=", "scores", "\n", "\n", "# print(f\"compute_average_precision_detection {time.time() - start_time:.2f} seconds.\")", "\n", "", "", "ap_array", "=", "np", ".", "array", "(", "list", "(", "qid2ap_list", ".", "values", "(", ")", ")", ")", "# (#queries, #thd)", "\n", "ap_thds", "=", "ap_array", ".", "mean", "(", "0", ")", "# mAP at different IoU thresholds.", "\n", "iou_thd2ap", "=", "dict", "(", "zip", "(", "[", "str", "(", "e", ")", "for", "e", "in", "iou_thds", "]", ",", "ap_thds", ")", ")", "\n", "iou_thd2ap", "[", "\"average\"", "]", "=", "np", ".", "mean", "(", "ap_thds", ")", "\n", "# formatting", "\n", "iou_thd2ap", "=", "{", "k", ":", "float", "(", "f\"{100 * v:.2f}\"", ")", "for", "k", ",", "v", "in", "iou_thd2ap", ".", "items", "(", ")", "}", "\n", "return", "iou_thd2ap", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_mr_r1": [[72, 97], ["numpy.linspace", "list", "numpy.array().astype", "numpy.array().astype", "standalone_eval.utils.compute_temporal_iou_batch_paired", "float", "pred_qid2window.keys", "float", "len", "numpy.argmax", "numpy.array", "numpy.array", "standalone_eval.utils.compute_temporal_iou_batch_cross", "str", "numpy.array", "numpy.array", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_temporal_iou_batch_paired", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_temporal_iou_batch_cross"], ["", "def", "compute_mr_r1", "(", "submission", ",", "ground_truth", ",", "iou_thds", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "10", ")", ")", ":", "\n", "    ", "\"\"\"If a predicted segment has IoU >= iou_thd with one of the 1st GT segment, we define it positive\"\"\"", "\n", "iou_thds", "=", "[", "float", "(", "f\"{e:.2f}\"", ")", "for", "e", "in", "iou_thds", "]", "\n", "pred_qid2window", "=", "{", "d", "[", "\"qid\"", "]", ":", "d", "[", "\"pred_relevant_windows\"", "]", "[", "0", "]", "[", ":", "2", "]", "for", "d", "in", "submission", "}", "# :2 rm scores", "\n", "# gt_qid2window = {d[\"qid\"]: d[\"relevant_windows\"][0] for d in ground_truth}", "\n", "gt_qid2window", "=", "{", "}", "\n", "for", "d", "in", "ground_truth", ":", "\n", "        ", "cur_gt_windows", "=", "d", "[", "\"relevant_windows\"", "]", "\n", "cur_qid", "=", "d", "[", "\"qid\"", "]", "\n", "cur_max_iou_idx", "=", "0", "\n", "if", "len", "(", "cur_gt_windows", ")", ">", "0", ":", "# select the GT window that has the highest IoU", "\n", "            ", "cur_ious", "=", "compute_temporal_iou_batch_cross", "(", "\n", "np", ".", "array", "(", "[", "pred_qid2window", "[", "cur_qid", "]", "]", ")", ",", "np", ".", "array", "(", "d", "[", "\"relevant_windows\"", "]", ")", "\n", ")", "[", "0", "]", "\n", "cur_max_iou_idx", "=", "np", ".", "argmax", "(", "cur_ious", ")", "\n", "", "gt_qid2window", "[", "cur_qid", "]", "=", "cur_gt_windows", "[", "cur_max_iou_idx", "]", "\n", "\n", "", "qids", "=", "list", "(", "pred_qid2window", ".", "keys", "(", ")", ")", "\n", "pred_windows", "=", "np", ".", "array", "(", "[", "pred_qid2window", "[", "k", "]", "for", "k", "in", "qids", "]", ")", ".", "astype", "(", "float", ")", "\n", "gt_windows", "=", "np", ".", "array", "(", "[", "gt_qid2window", "[", "k", "]", "for", "k", "in", "qids", "]", ")", ".", "astype", "(", "float", ")", "\n", "pred_gt_iou", "=", "compute_temporal_iou_batch_paired", "(", "pred_windows", ",", "gt_windows", ")", "\n", "iou_thd2recall_at_one", "=", "{", "}", "\n", "for", "thd", "in", "iou_thds", ":", "\n", "        ", "iou_thd2recall_at_one", "[", "str", "(", "thd", ")", "]", "=", "float", "(", "f\"{np.mean(pred_gt_iou >= thd) * 100:.2f}\"", ")", "\n", "", "return", "iou_thd2recall_at_one", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.get_window_len": [[99, 101], ["None"], "function", ["None"], ["", "def", "get_window_len", "(", "window", ")", ":", "\n", "    ", "return", "window", "[", "1", "]", "-", "window", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.get_data_by_range": [[103, 134], ["set", "len", "copy.deepcopy", "ground_truth_in_range.append", "set.add", "submission_in_range.append", "copy.deepcopy", "eval.get_window_len"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.get_window_len"], ["", "def", "get_data_by_range", "(", "submission", ",", "ground_truth", ",", "len_range", ")", ":", "\n", "    ", "\"\"\" keep queries with ground truth window length in the specified length range.\n    Args:\n        submission:\n        ground_truth:\n        len_range: [min_l (int), max_l (int)]. the range is (min_l, max_l], i.e., min_l < l <= max_l\n    \"\"\"", "\n", "min_l", ",", "max_l", "=", "len_range", "\n", "if", "min_l", "==", "0", "and", "max_l", "==", "150", ":", "# min and max l in dataset", "\n", "        ", "return", "submission", ",", "ground_truth", "\n", "\n", "# only keep ground truth with windows in the specified length range", "\n", "# if multiple GT windows exists, we only keep the ones in the range", "\n", "", "ground_truth_in_range", "=", "[", "]", "\n", "gt_qids_in_range", "=", "set", "(", ")", "\n", "for", "d", "in", "ground_truth", ":", "\n", "        ", "rel_windows_in_range", "=", "[", "\n", "w", "for", "w", "in", "d", "[", "\"relevant_windows\"", "]", "if", "min_l", "<", "get_window_len", "(", "w", ")", "<=", "max_l", "]", "\n", "if", "len", "(", "rel_windows_in_range", ")", ">", "0", ":", "\n", "            ", "d", "=", "copy", ".", "deepcopy", "(", "d", ")", "\n", "d", "[", "\"relevant_windows\"", "]", "=", "rel_windows_in_range", "\n", "ground_truth_in_range", ".", "append", "(", "d", ")", "\n", "gt_qids_in_range", ".", "add", "(", "d", "[", "\"qid\"", "]", ")", "\n", "\n", "# keep only submissions for ground_truth_in_range", "\n", "", "", "submission_in_range", "=", "[", "]", "\n", "for", "d", "in", "submission", ":", "\n", "        ", "if", "d", "[", "\"qid\"", "]", "in", "gt_qids_in_range", ":", "\n", "            ", "submission_in_range", ".", "append", "(", "copy", ".", "deepcopy", "(", "d", ")", ")", "\n", "\n", "", "", "return", "submission_in_range", ",", "ground_truth_in_range", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_moment_retrieval": [[136, 153], ["zip", "eval.get_data_by_range", "print", "eval.compute_mr_ap", "eval.compute_mr_r1", "time.time", "print", "len", "len", "len", "len", "time.time"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.get_data_by_range", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_mr_ap", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_mr_r1"], ["", "def", "eval_moment_retrieval", "(", "submission", ",", "ground_truth", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "length_ranges", "=", "[", "[", "0", ",", "10", "]", ",", "[", "10", ",", "30", "]", ",", "[", "30", ",", "150", "]", ",", "[", "0", ",", "150", "]", ",", "]", "#", "\n", "range_names", "=", "[", "\"short\"", ",", "\"middle\"", ",", "\"long\"", ",", "\"full\"", "]", "\n", "\n", "ret_metrics", "=", "{", "}", "\n", "for", "l_range", ",", "name", "in", "zip", "(", "length_ranges", ",", "range_names", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "", "_submission", ",", "_ground_truth", "=", "get_data_by_range", "(", "submission", ",", "ground_truth", ",", "l_range", ")", "\n", "print", "(", "f\"{name}: {l_range}, {len(_ground_truth)}/{len(ground_truth)}=\"", "\n", "f\"{100*len(_ground_truth)/len(ground_truth):.2f} examples.\"", ")", "\n", "iou_thd2average_precision", "=", "compute_mr_ap", "(", "_submission", ",", "_ground_truth", ",", "num_workers", "=", "8", ",", "chunksize", "=", "50", ")", "\n", "iou_thd2recall_at_one", "=", "compute_mr_r1", "(", "_submission", ",", "_ground_truth", ")", "\n", "ret_metrics", "[", "name", "]", "=", "{", "\"MR-mAP\"", ":", "iou_thd2average_precision", ",", "\"MR-R1\"", ":", "iou_thd2recall_at_one", "}", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "f\"[eval_moment_retrieval] [{name}] {time.time() - start_time:.2f} seconds\"", ")", "\n", "", "", "return", "ret_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_hl_hit1": [[155, 168], ["numpy.zeros", "list", "enumerate", "float", "numpy.argmax", "qid2preds.keys", "qid2preds.items", "len", "len", "numpy.mean", "numpy.max"], "function", ["None"], ["", "def", "compute_hl_hit1", "(", "qid2preds", ",", "qid2gt_scores_binary", ")", ":", "\n", "    ", "qid2max_scored_clip_idx", "=", "{", "k", ":", "np", ".", "argmax", "(", "v", "[", "\"pred_saliency_scores\"", "]", ")", "for", "k", ",", "v", "in", "qid2preds", ".", "items", "(", ")", "}", "\n", "hit_scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "qid2preds", ")", ",", "3", ")", ")", "\n", "qids", "=", "list", "(", "qid2preds", ".", "keys", "(", ")", ")", "\n", "for", "idx", ",", "qid", "in", "enumerate", "(", "qids", ")", ":", "\n", "        ", "pred_clip_idx", "=", "qid2max_scored_clip_idx", "[", "qid", "]", "\n", "gt_scores_binary", "=", "qid2gt_scores_binary", "[", "qid", "]", "# (#clips, 3)", "\n", "if", "pred_clip_idx", "<", "len", "(", "gt_scores_binary", ")", ":", "\n", "            ", "hit_scores", "[", "idx", "]", "=", "gt_scores_binary", "[", "pred_clip_idx", "]", "\n", "# aggregate scores from 3 separate annotations (3 workers) by taking the max.", "\n", "# then average scores from all queries.", "\n", "", "", "hit_at_one", "=", "float", "(", "f\"{100 * np.mean(np.max(hit_scores, 1)):.2f}\"", ")", "\n", "return", "hit_at_one", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_hl_ap": [[170, 195], ["numpy.zeros", "list", "enumerate", "float", "qid2preds.keys", "range", "qid2preds.items", "len", "numpy.array", "input_tuples.append", "multiprocessing.Pool", "pool.imap_unordered", "eval.compute_ap_from_tuple", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_ap_from_tuple"], ["", "def", "compute_hl_ap", "(", "qid2preds", ",", "qid2gt_scores_binary", ",", "num_workers", "=", "8", ",", "chunksize", "=", "50", ")", ":", "\n", "    ", "qid2pred_scores", "=", "{", "k", ":", "v", "[", "\"pred_saliency_scores\"", "]", "for", "k", ",", "v", "in", "qid2preds", ".", "items", "(", ")", "}", "\n", "ap_scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "qid2preds", ")", ",", "3", ")", ")", "# (#preds, 3)", "\n", "qids", "=", "list", "(", "qid2preds", ".", "keys", "(", ")", ")", "\n", "input_tuples", "=", "[", "]", "\n", "for", "idx", ",", "qid", "in", "enumerate", "(", "qids", ")", ":", "\n", "        ", "for", "w_idx", "in", "range", "(", "3", ")", ":", "# annotation score idx", "\n", "            ", "y_true", "=", "qid2gt_scores_binary", "[", "qid", "]", "[", ":", ",", "w_idx", "]", "\n", "y_predict", "=", "np", ".", "array", "(", "qid2pred_scores", "[", "qid", "]", ")", "\n", "input_tuples", ".", "append", "(", "(", "idx", ",", "w_idx", ",", "y_true", ",", "y_predict", ")", ")", "\n", "\n", "", "", "if", "num_workers", ">", "1", ":", "\n", "        ", "with", "mp", ".", "Pool", "(", "num_workers", ")", "as", "pool", ":", "\n", "            ", "for", "idx", ",", "w_idx", ",", "score", "in", "pool", ".", "imap_unordered", "(", "\n", "compute_ap_from_tuple", ",", "input_tuples", ",", "chunksize", "=", "chunksize", ")", ":", "\n", "                ", "ap_scores", "[", "idx", ",", "w_idx", "]", "=", "score", "\n", "", "", "", "else", ":", "\n", "        ", "for", "input_tuple", "in", "input_tuples", ":", "\n", "            ", "idx", ",", "w_idx", ",", "score", "=", "compute_ap_from_tuple", "(", "input_tuple", ")", "\n", "ap_scores", "[", "idx", ",", "w_idx", "]", "=", "score", "\n", "\n", "# it's the same if we first average across different annotations, then average across queries", "\n", "# since all queries have the same #annotations.", "\n", "", "", "mean_ap", "=", "float", "(", "f\"{100 * np.mean(ap_scores):.2f}\"", ")", "\n", "return", "mean_ap", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_ap_from_tuple": [[197, 210], ["standalone_eval.utils.get_ap", "len", "len", "len", "len", "numpy.zeros", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.get_ap"], ["", "def", "compute_ap_from_tuple", "(", "input_tuple", ")", ":", "\n", "    ", "idx", ",", "w_idx", ",", "y_true", ",", "y_predict", "=", "input_tuple", "\n", "if", "len", "(", "y_true", ")", "<", "len", "(", "y_predict", ")", ":", "\n", "# print(f\"len(y_true) < len(y_predict) {len(y_true), len(y_predict)}\")", "\n", "        ", "y_predict", "=", "y_predict", "[", ":", "len", "(", "y_true", ")", "]", "\n", "", "elif", "len", "(", "y_true", ")", ">", "len", "(", "y_predict", ")", ":", "\n", "# print(f\"len(y_true) > len(y_predict) {len(y_true), len(y_predict)}\")", "\n", "        ", "_y_predict", "=", "np", ".", "zeros", "(", "len", "(", "y_true", ")", ")", "\n", "_y_predict", "[", ":", "len", "(", "y_predict", ")", "]", "=", "y_predict", "\n", "y_predict", "=", "_y_predict", "\n", "\n", "", "score", "=", "get_ap", "(", "y_true", ",", "y_predict", ")", "\n", "return", "idx", ",", "w_idx", ",", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.mk_gt_scores": [[212, 220], ["int", "numpy.zeros", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "mk_gt_scores", "(", "gt_data", ",", "clip_length", "=", "2", ")", ":", "\n", "    ", "\"\"\"gt_data, dict, \"\"\"", "\n", "num_clips", "=", "int", "(", "gt_data", "[", "\"duration\"", "]", "/", "clip_length", ")", "\n", "saliency_scores_full_video", "=", "np", ".", "zeros", "(", "(", "num_clips", ",", "3", ")", ")", "\n", "relevant_clip_ids", "=", "np", ".", "array", "(", "gt_data", "[", "\"relevant_clip_ids\"", "]", ")", "# (#relevant_clip_ids, )", "\n", "saliency_scores_relevant_clips", "=", "np", ".", "array", "(", "gt_data", "[", "\"saliency_scores\"", "]", ")", "# (#relevant_clip_ids, 3)", "\n", "saliency_scores_full_video", "[", "relevant_clip_ids", "]", "=", "saliency_scores_relevant_clips", "\n", "return", "saliency_scores_full_video", "# (#clips_in_video, 3)  the scores are in range [0, 4]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_highlight": [[222, 247], ["zip", "eval.mk_gt_scores", "time.time", "eval.compute_hl_hit1", "eval.compute_hl_ap", "print", "print", "qid2gt_scores_full_range.items", "time.time"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.mk_gt_scores", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_hl_hit1", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.compute_hl_ap"], ["", "def", "eval_highlight", "(", "submission", ",", "ground_truth", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        submission:\n        ground_truth:\n        verbose:\n    \"\"\"", "\n", "qid2preds", "=", "{", "d", "[", "\"qid\"", "]", ":", "d", "for", "d", "in", "submission", "}", "\n", "qid2gt_scores_full_range", "=", "{", "d", "[", "\"qid\"", "]", ":", "mk_gt_scores", "(", "d", ")", "for", "d", "in", "ground_truth", "}", "# scores in range [0, 4]", "\n", "# gt_saliency_score_min: int, in [0, 1, 2, 3, 4]. The minimum score for a positive clip.", "\n", "gt_saliency_score_min_list", "=", "[", "2", ",", "3", ",", "4", "]", "\n", "saliency_score_names", "=", "[", "\"Fair\"", ",", "\"Good\"", ",", "\"VeryGood\"", "]", "\n", "highlight_det_metrics", "=", "{", "}", "\n", "for", "gt_saliency_score_min", ",", "score_name", "in", "zip", "(", "gt_saliency_score_min_list", ",", "saliency_score_names", ")", ":", "\n", "        ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "qid2gt_scores_binary", "=", "{", "\n", "k", ":", "(", "v", ">=", "gt_saliency_score_min", ")", ".", "astype", "(", "float", ")", "\n", "for", "k", ",", "v", "in", "qid2gt_scores_full_range", ".", "items", "(", ")", "}", "# scores in [0, 1]", "\n", "hit_at_one", "=", "compute_hl_hit1", "(", "qid2preds", ",", "qid2gt_scores_binary", ")", "\n", "mean_ap", "=", "compute_hl_ap", "(", "qid2preds", ",", "qid2gt_scores_binary", ")", "\n", "highlight_det_metrics", "[", "f\"HL-min-{score_name}\"", "]", "=", "{", "\"HL-mAP\"", ":", "mean_ap", ",", "\"HL-Hit1\"", ":", "hit_at_one", "}", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "f\"Calculating highlight scores with min score {gt_saliency_score_min} ({score_name})\"", ")", "\n", "print", "(", "f\"Time cost {time.time() - start_time:.2f} seconds\"", ")", "\n", "", "", "return", "highlight_det_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_submission": [[249, 321], ["set", "set", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict.update", "set.intersection", "eval.eval_moment_retrieval", "eval_metrics.update", "collections.OrderedDict.update", "eval.eval_highlight", "eval_metrics.update", "dict", "collections.OrderedDict.update", "sorted", "sorted", "eval_highlight.items", "eval_metrics.items", "moment_ret_scores_brief.items", "sub_k.split"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_moment_retrieval", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_highlight", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["", "def", "eval_submission", "(", "submission", ",", "ground_truth", ",", "verbose", "=", "True", ",", "match_number", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        submission: list(dict), each dict is {\n            qid: str,\n            query: str,\n            vid: str,\n            pred_relevant_windows: list([st, ed]),\n            pred_saliency_scores: list(float), len == #clips in video.\n                i.e., each clip in the video will have a saliency score.\n        }\n        ground_truth: list(dict), each dict is     {\n          \"qid\": 7803,\n          \"query\": \"Man in gray top walks from outside to inside.\",\n          \"duration\": 150,\n          \"vid\": \"RoripwjYFp8_360.0_510.0\",\n          \"relevant_clip_ids\": [13, 14, 15, 16, 17]\n          \"saliency_scores\": [[4, 4, 2], [3, 4, 2], [2, 2, 3], [2, 2, 2], [0, 1, 3]]\n               each sublist corresponds to one clip in relevant_clip_ids.\n               The 3 elements in the sublist are scores from 3 different workers. The\n               scores are in [0, 1, 2, 3, 4], meaning [Very Bad, ..., Good, Very Good]\n        }\n        verbose:\n        match_number:\n\n    Returns:\n\n    \"\"\"", "\n", "pred_qids", "=", "set", "(", "[", "e", "[", "\"qid\"", "]", "for", "e", "in", "submission", "]", ")", "\n", "gt_qids", "=", "set", "(", "[", "e", "[", "\"qid\"", "]", "for", "e", "in", "ground_truth", "]", ")", "\n", "if", "match_number", ":", "\n", "        ", "assert", "pred_qids", "==", "gt_qids", ",", "f\"qids in ground_truth and submission must match. \"", "f\"use `match_number=False` if you wish to disable this check\"", "\n", "", "else", ":", "# only leave the items that exists in both submission and ground_truth", "\n", "        ", "shared_qids", "=", "pred_qids", ".", "intersection", "(", "gt_qids", ")", "\n", "submission", "=", "[", "e", "for", "e", "in", "submission", "if", "e", "[", "\"qid\"", "]", "in", "shared_qids", "]", "\n", "ground_truth", "=", "[", "e", "for", "e", "in", "ground_truth", "if", "e", "[", "\"qid\"", "]", "in", "shared_qids", "]", "\n", "\n", "", "eval_metrics", "=", "{", "}", "\n", "eval_metrics_brief", "=", "OrderedDict", "(", ")", "\n", "if", "\"pred_relevant_windows\"", "in", "submission", "[", "0", "]", ":", "\n", "        ", "moment_ret_scores", "=", "eval_moment_retrieval", "(", "\n", "submission", ",", "ground_truth", ",", "verbose", "=", "verbose", ")", "\n", "eval_metrics", ".", "update", "(", "moment_ret_scores", ")", "\n", "moment_ret_scores_brief", "=", "{", "\n", "\"MR-full-mAP\"", ":", "moment_ret_scores", "[", "\"full\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"average\"", "]", ",", "\n", "\"MR-full-mAP@0.5\"", ":", "moment_ret_scores", "[", "\"full\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"0.5\"", "]", ",", "\n", "\"MR-full-mAP@0.75\"", ":", "moment_ret_scores", "[", "\"full\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"0.75\"", "]", ",", "\n", "\"MR-short-mAP\"", ":", "moment_ret_scores", "[", "\"short\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"average\"", "]", ",", "\n", "\"MR-middle-mAP\"", ":", "moment_ret_scores", "[", "\"middle\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"average\"", "]", ",", "\n", "\"MR-long-mAP\"", ":", "moment_ret_scores", "[", "\"long\"", "]", "[", "\"MR-mAP\"", "]", "[", "\"average\"", "]", ",", "\n", "\"MR-full-R1@0.5\"", ":", "moment_ret_scores", "[", "\"full\"", "]", "[", "\"MR-R1\"", "]", "[", "\"0.5\"", "]", ",", "\n", "\"MR-full-R1@0.7\"", ":", "moment_ret_scores", "[", "\"full\"", "]", "[", "\"MR-R1\"", "]", "[", "\"0.7\"", "]", ",", "\n", "}", "\n", "eval_metrics_brief", ".", "update", "(", "\n", "sorted", "(", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "moment_ret_scores_brief", ".", "items", "(", ")", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "\"pred_saliency_scores\"", "in", "submission", "[", "0", "]", ":", "\n", "        ", "highlight_det_scores", "=", "eval_highlight", "(", "\n", "submission", ",", "ground_truth", ",", "verbose", "=", "verbose", ")", "\n", "eval_metrics", ".", "update", "(", "highlight_det_scores", ")", "\n", "highlight_det_scores_brief", "=", "dict", "(", "[", "\n", "(", "f\"{k}-{sub_k.split('-')[1]}\"", ",", "v", "[", "sub_k", "]", ")", "\n", "for", "k", ",", "v", "in", "highlight_det_scores", ".", "items", "(", ")", "for", "sub_k", "in", "v", "]", ")", "\n", "eval_metrics_brief", ".", "update", "(", "highlight_det_scores_brief", ")", "\n", "\n", "# sort by keys", "\n", "", "final_eval_metrics", "=", "OrderedDict", "(", ")", "\n", "final_eval_metrics", "[", "\"brief\"", "]", "=", "eval_metrics_brief", "\n", "final_eval_metrics", ".", "update", "(", "sorted", "(", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "eval_metrics", ".", "items", "(", ")", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", ")", "\n", "return", "final_eval_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_main": [[323, 341], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "standalone_eval.utils.load_jsonl", "standalone_eval.utils.load_jsonl", "eval.eval_submission", "print", "open", "f.write", "json.dumps", "json.dumps"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.load_jsonl", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.load_jsonl", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_submission"], ["", "def", "eval_main", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Moments and Highlights Evaluation Script\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--submission_path\"", ",", "type", "=", "str", ",", "help", "=", "\"path to generated prediction file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--gt_path\"", ",", "type", "=", "str", ",", "help", "=", "\"path to GT file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--save_path\"", ",", "type", "=", "str", ",", "help", "=", "\"path to save the results\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--not_verbose\"", ",", "action", "=", "\"store_true\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "verbose", "=", "not", "args", ".", "not_verbose", "\n", "submission", "=", "load_jsonl", "(", "args", ".", "submission_path", ")", "\n", "gt", "=", "load_jsonl", "(", "args", ".", "gt_path", ")", "\n", "results", "=", "eval_submission", "(", "submission", ",", "gt", ",", "verbose", "=", "verbose", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "json", ".", "dumps", "(", "results", ",", "indent", "=", "4", ")", ")", "\n", "\n", "", "with", "open", "(", "args", ".", "save_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "json", ".", "dumps", "(", "results", ",", "indent", "=", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.load_jsonl": [[10, 13], ["open", "json.loads", "l.strip", "f.readlines"], "function", ["None"], ["def", "load_jsonl", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "return", "[", "json", ".", "loads", "(", "l", ".", "strip", "(", "\"\\n\"", ")", ")", "for", "l", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_temporal_iou_batch_paired": [[15, 32], ["numpy.maximum", "numpy.divide", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.zeros_like"], "function", ["None"], ["", "", "def", "compute_temporal_iou_batch_paired", "(", "pred_windows", ",", "gt_windows", ")", ":", "\n", "    ", "\"\"\" compute intersection-over-union along temporal axis for each pair of windows in pred_windows and gt_windows.\n    Args:\n        pred_windows: np.ndarray, (N, 2), [st (float), ed (float)] * N\n        gt_windows: np.ndarray, (N, 2), [st (float), ed (float)] * N\n    Returns:\n        iou (float): np.ndarray, (N, )\n\n    References:\n        for np.divide with zeros, see https://stackoverflow.com/a/37977222\n    \"\"\"", "\n", "intersection", "=", "np", ".", "maximum", "(", "\n", "0", ",", "np", ".", "minimum", "(", "pred_windows", "[", ":", ",", "1", "]", ",", "gt_windows", "[", ":", ",", "1", "]", ")", "-", "np", ".", "maximum", "(", "pred_windows", "[", ":", ",", "0", "]", ",", "gt_windows", "[", ":", ",", "0", "]", ")", "\n", ")", "\n", "union", "=", "np", ".", "maximum", "(", "pred_windows", "[", ":", ",", "1", "]", ",", "gt_windows", "[", ":", ",", "1", "]", ")", "-", "np", ".", "minimum", "(", "pred_windows", "[", ":", ",", "0", "]", ",", "gt_windows", "[", ":", ",", "0", "]", ")", "# not the correct union though", "\n", "return", "np", ".", "divide", "(", "intersection", ",", "union", ",", "out", "=", "np", ".", "zeros_like", "(", "intersection", ")", ",", "where", "=", "union", "!=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_temporal_iou_batch_cross": [[34, 62], ["numpy.maximum", "numpy.minimum", "numpy.clip"], "function", ["None"], ["", "def", "compute_temporal_iou_batch_cross", "(", "spans1", ",", "spans2", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        spans1: (N, 2) np.ndarray, each row defines a span [st, ed]\n        spans2: (M, 2) np.ndarray, ...\n\n    Returns:\n        iou: (N, M) np.ndarray\n        union: (N, M) np.ndarray\n    >>> spans1 = np.array([[0, 0.2, 0.9], [0.5, 1.0, 0.2]])\n    >>> spans2 = np.array([[0, 0.3], [0., 1.0]])\n    >>> compute_temporal_iou_batch_cross(spans1, spans2)\n    (tensor([[0.6667, 0.2000],\n         [0.0000, 0.5000]]),\n     tensor([[0.3000, 1.0000],\n             [0.8000, 1.0000]]))\n    \"\"\"", "\n", "areas1", "=", "spans1", "[", ":", ",", "1", "]", "-", "spans1", "[", ":", ",", "0", "]", "# (N, )", "\n", "areas2", "=", "spans2", "[", ":", ",", "1", "]", "-", "spans2", "[", ":", ",", "0", "]", "# (M, )", "\n", "\n", "left", "=", "np", ".", "maximum", "(", "spans1", "[", ":", ",", "None", ",", "0", "]", ",", "spans2", "[", "None", ",", ":", ",", "0", "]", ")", "# (N, M)", "\n", "right", "=", "np", ".", "minimum", "(", "spans1", "[", ":", ",", "None", ",", "1", "]", ",", "spans2", "[", "None", ",", ":", ",", "1", "]", ")", "# (N, M)", "\n", "\n", "inter", "=", "np", ".", "clip", "(", "right", "-", "left", ",", "0", ",", "None", ")", "# (N, M)", "\n", "union", "=", "areas1", "[", ":", ",", "None", "]", "+", "areas2", "[", "None", ",", ":", "]", "-", "inter", "# (N, M)", "\n", "\n", "iou", "=", "inter", "/", "union", "\n", "return", "iou", ",", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.interpolated_precision_recall": [[64, 81], ["numpy.hstack", "numpy.hstack", "numpy.sum", "range", "max", "numpy.where", "len"], "function", ["None"], ["", "def", "interpolated_precision_recall", "(", "precision", ",", "recall", ")", ":", "\n", "    ", "\"\"\"Interpolated AP - VOCdevkit from VOC 2011.\n\n    Args:\n        precision (np.ndarray): The precision of different thresholds.\n        recall (np.ndarray): The recall of different thresholds.\n\n    Returns\uff1a\n        float: Average precision score.\n    \"\"\"", "\n", "mprecision", "=", "np", ".", "hstack", "(", "[", "[", "0", "]", ",", "precision", ",", "[", "0", "]", "]", ")", "\n", "mrecall", "=", "np", ".", "hstack", "(", "[", "[", "0", "]", ",", "recall", ",", "[", "1", "]", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "mprecision", ")", "-", "1", ")", "[", ":", ":", "-", "1", "]", ":", "\n", "        ", "mprecision", "[", "i", "]", "=", "max", "(", "mprecision", "[", "i", "]", ",", "mprecision", "[", "i", "+", "1", "]", ")", "\n", "", "idx", "=", "np", ".", "where", "(", "mrecall", "[", "1", ":", ":", "]", "!=", "mrecall", "[", "0", ":", "-", "1", "]", ")", "[", "0", "]", "+", "1", "\n", "ap", "=", "np", ".", "sum", "(", "(", "mrecall", "[", "idx", "]", "-", "mrecall", "[", "idx", "-", "1", "]", ")", "*", "mprecision", "[", "idx", "]", ")", "\n", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_average_precision_detection": [[83, 167], ["numpy.linspace", "len", "len", "len", "numpy.zeros", "float", "prediction.sort", "numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "numpy.cumsum().astype", "numpy.cumsum().astype", "range", "len", "numpy.ones", "ground_truth_by_videoid.setdefault().append", "numpy.array", "numpy.array", "tiou_arr.reshape.reshape", "enumerate", "len", "utils.interpolated_precision_recall", "utils.compute_temporal_iou_batch_cross", "tiou_arr.reshape.argsort", "numpy.cumsum", "numpy.cumsum", "ground_truth_by_videoid.setdefault"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.interpolated_precision_recall", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.compute_temporal_iou_batch_cross"], ["", "def", "compute_average_precision_detection", "(", "ground_truth", ",", "\n", "prediction", ",", "\n", "tiou_thresholds", "=", "np", ".", "linspace", "(", "\n", "0.5", ",", "0.95", ",", "10", ")", ")", ":", "\n", "    ", "\"\"\"Compute average precision (detection task) between ground truth and\n    predictions data frames. If multiple predictions occurs for the same\n    predicted segment, only the one with highest score is matches as true\n    positive. This code is greatly inspired by Pascal VOC devkit.\n\n    Args:\n        ground_truth (list[dict]): List containing the ground truth instances\n            (dictionaries). Required keys are 'video-id', 't-start' and\n            't-end'.\n        prediction (list[dict]): List containing the prediction instances\n            (dictionaries). Required keys are: 'video-id', 't-start', 't-end'\n            and 'score'.\n        tiou_thresholds (np.ndarray): A 1darray indicates the temporal\n            intersection over union threshold, which is optional.\n            Default: ``np.linspace(0.5, 0.95, 10)``.\n\n    Returns:\n        Float: ap, Average precision score.\n    \"\"\"", "\n", "num_thresholds", "=", "len", "(", "tiou_thresholds", ")", "\n", "num_gts", "=", "len", "(", "ground_truth", ")", "\n", "num_preds", "=", "len", "(", "prediction", ")", "\n", "ap", "=", "np", ".", "zeros", "(", "num_thresholds", ")", "\n", "if", "len", "(", "prediction", ")", "==", "0", ":", "\n", "        ", "return", "ap", "\n", "\n", "", "num_positive", "=", "float", "(", "num_gts", ")", "\n", "lock_gt", "=", "np", ".", "ones", "(", "(", "num_thresholds", ",", "num_gts", ")", ")", "*", "-", "1", "\n", "# Sort predictions by decreasing score order.", "\n", "prediction", ".", "sort", "(", "key", "=", "lambda", "x", ":", "-", "x", "[", "'score'", "]", ")", "\n", "# Initialize true positive and false positive vectors.", "\n", "tp", "=", "np", ".", "zeros", "(", "(", "num_thresholds", ",", "num_preds", ")", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "(", "num_thresholds", ",", "num_preds", ")", ")", "\n", "\n", "# Adaptation to query faster", "\n", "ground_truth_by_videoid", "=", "{", "}", "\n", "for", "i", ",", "item", "in", "enumerate", "(", "ground_truth", ")", ":", "\n", "        ", "item", "[", "'index'", "]", "=", "i", "\n", "ground_truth_by_videoid", ".", "setdefault", "(", "item", "[", "'video-id'", "]", ",", "[", "]", ")", ".", "append", "(", "item", ")", "\n", "\n", "# Assigning true positive to truly grount truth instances.", "\n", "", "for", "idx", ",", "pred", "in", "enumerate", "(", "prediction", ")", ":", "\n", "        ", "if", "pred", "[", "'video-id'", "]", "in", "ground_truth_by_videoid", ":", "\n", "            ", "gts", "=", "ground_truth_by_videoid", "[", "pred", "[", "'video-id'", "]", "]", "\n", "", "else", ":", "\n", "            ", "fp", "[", ":", ",", "idx", "]", "=", "1", "\n", "continue", "\n", "\n", "", "_pred", "=", "np", ".", "array", "(", "[", "[", "pred", "[", "'t-start'", "]", ",", "pred", "[", "'t-end'", "]", "]", ",", "]", ")", "\n", "_gt", "=", "np", ".", "array", "(", "[", "[", "gt", "[", "'t-start'", "]", ",", "gt", "[", "'t-end'", "]", "]", "for", "gt", "in", "gts", "]", ")", "\n", "tiou_arr", "=", "compute_temporal_iou_batch_cross", "(", "_pred", ",", "_gt", ")", "[", "0", "]", "\n", "\n", "tiou_arr", "=", "tiou_arr", ".", "reshape", "(", "-", "1", ")", "\n", "# We would like to retrieve the predictions with highest tiou score.", "\n", "tiou_sorted_idx", "=", "tiou_arr", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "for", "t_idx", ",", "tiou_threshold", "in", "enumerate", "(", "tiou_thresholds", ")", ":", "\n", "            ", "for", "j_idx", "in", "tiou_sorted_idx", ":", "\n", "                ", "if", "tiou_arr", "[", "j_idx", "]", "<", "tiou_threshold", ":", "\n", "                    ", "fp", "[", "t_idx", ",", "idx", "]", "=", "1", "\n", "break", "\n", "", "if", "lock_gt", "[", "t_idx", ",", "gts", "[", "j_idx", "]", "[", "'index'", "]", "]", ">=", "0", ":", "\n", "                    ", "continue", "\n", "# Assign as true positive after the filters above.", "\n", "", "tp", "[", "t_idx", ",", "idx", "]", "=", "1", "\n", "lock_gt", "[", "t_idx", ",", "gts", "[", "j_idx", "]", "[", "'index'", "]", "]", "=", "idx", "\n", "break", "\n", "\n", "", "if", "fp", "[", "t_idx", ",", "idx", "]", "==", "0", "and", "tp", "[", "t_idx", ",", "idx", "]", "==", "0", ":", "\n", "                ", "fp", "[", "t_idx", ",", "idx", "]", "=", "1", "\n", "\n", "", "", "", "tp_cumsum", "=", "np", ".", "cumsum", "(", "tp", ",", "axis", "=", "1", ")", ".", "astype", "(", "float", ")", "\n", "fp_cumsum", "=", "np", ".", "cumsum", "(", "fp", ",", "axis", "=", "1", ")", ".", "astype", "(", "float", ")", "\n", "recall_cumsum", "=", "tp_cumsum", "/", "num_positive", "\n", "\n", "precision_cumsum", "=", "tp_cumsum", "/", "(", "tp_cumsum", "+", "fp_cumsum", ")", "\n", "\n", "for", "t_idx", "in", "range", "(", "len", "(", "tiou_thresholds", ")", ")", ":", "\n", "        ", "ap", "[", "t_idx", "]", "=", "interpolated_precision_recall", "(", "precision_cumsum", "[", "t_idx", ",", ":", "]", ",", "\n", "recall_cumsum", "[", "t_idx", ",", ":", "]", ")", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.get_ap": [[169, 210], ["sklearn.metrics.precision_recall_curve", "recall.astype.astype", "len", "len", "len", "range", "numpy.mean", "numpy.where", "numpy.mean", "set", "sorted", "len", "max", "numpy.diff", "set", "numpy.arange", "numpy.where"], "function", ["None"], ["", "def", "get_ap", "(", "y_true", ",", "y_predict", ",", "interpolate", "=", "True", ",", "point_11", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Average precision in different formats: (non-) interpolated and/or 11-point approximated\n    point_11=True and interpolate=True corresponds to the 11-point interpolated AP used in\n    the PASCAL VOC challenge up to the 2008 edition and has been verfied against the vlfeat implementation\n    The exact average precision (interpolate=False, point_11=False) corresponds to the one of vl_feat\n\n    :param y_true: list/ numpy vector of true labels in {0,1} for each element\n    :param y_predict: predicted score for each element\n    :param interpolate: Use interpolation?\n    :param point_11: Use 11-point approximation to average precision?\n    :return: average precision\n\n    ref: https://github.com/gyglim/video2gif_dataset/blob/master/v2g_evaluation/__init__.py\n\n    \"\"\"", "\n", "# Check inputs", "\n", "assert", "len", "(", "y_true", ")", "==", "len", "(", "y_predict", ")", ",", "\"Prediction and ground truth need to be of the same length\"", "\n", "if", "len", "(", "set", "(", "y_true", ")", ")", "==", "1", ":", "\n", "        ", "if", "y_true", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "0", "# True labels are all zeros", "\n", "# raise ValueError('True labels cannot all be zero')", "\n", "", "else", ":", "\n", "            ", "return", "1", "\n", "", "", "else", ":", "\n", "        ", "assert", "sorted", "(", "set", "(", "y_true", ")", ")", "==", "[", "0", ",", "1", "]", ",", "\"Ground truth can only contain elements {0,1}\"", "\n", "\n", "# Compute precision and recall", "\n", "", "precision", ",", "recall", ",", "_", "=", "precision_recall_curve", "(", "y_true", ",", "y_predict", ")", "\n", "recall", "=", "recall", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "if", "interpolate", ":", "# Compute the interpolated precision", "\n", "        ", "for", "i", "in", "range", "(", "1", ",", "len", "(", "precision", ")", ")", ":", "\n", "            ", "precision", "[", "i", "]", "=", "max", "(", "precision", "[", "i", "-", "1", "]", ",", "precision", "[", "i", "]", ")", "\n", "\n", "", "", "if", "point_11", ":", "# Compute the 11-point approximated AP", "\n", "        ", "precision_11", "=", "[", "precision", "[", "np", ".", "where", "(", "recall", ">=", "t", ")", "[", "0", "]", "[", "-", "1", "]", "]", "for", "t", "in", "np", ".", "arange", "(", "0", ",", "1.01", ",", "0.1", ")", "]", "\n", "return", "np", ".", "mean", "(", "precision_11", ")", "\n", "", "else", ":", "# Compute the AP using precision at every additionally recalled sample", "\n", "        ", "indices", "=", "np", ".", "where", "(", "np", ".", "diff", "(", "recall", ")", ")", "\n", "return", "np", ".", "mean", "(", "precision", "[", "indices", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.__init__": [[16, 20], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "parser", "=", "None", "\n", "self", ".", "initialized", "=", "False", "\n", "self", ".", "opt", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.initialize": [[21, 146], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "self", ".", "initialized", "=", "True", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--dset_name\"", ",", "type", "=", "str", ",", "choices", "=", "[", "\"hl\"", "]", ")", "\n", "parser", ".", "add_argument", "(", "\"--eval_split_name\"", ",", "type", "=", "str", ",", "default", "=", "\"val\"", ",", "\n", "help", "=", "\"should match keys in video_duration_idx_path, must set for VCMR\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--debug\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"debug (fast) mode, break all loops, do not load all data into memory.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--data_ratio\"", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "\"how many training and eval data to use. 1.0: use all, 0.1: use 10%.\"", "\n", "\"Use small portion for debug purposes. Note this is different from --debug, \"", "\n", "\"which works by breaking the loops, typically they are not used together.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--results_root\"", ",", "type", "=", "str", ",", "default", "=", "\"results\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--exp_id\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "\"id of this run, required at training\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--seed\"", ",", "type", "=", "int", ",", "default", "=", "2018", ",", "help", "=", "\"random seed\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--device\"", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "\"0 cuda, -1 cpu\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--num_workers\"", ",", "type", "=", "int", ",", "default", "=", "4", ",", "\n", "help", "=", "\"num subprocesses used to load the data, 0: use main process\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_pin_memory\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Don't use pin_memory=True for dataloader. \"", "\n", "\"ref: https://discuss.pytorch.org/t/should-we-set-non-blocking-to-true/38234/4\"", ")", "\n", "\n", "# training config", "\n", "parser", ".", "add_argument", "(", "\"--lr\"", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "\"learning rate\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lr_drop\"", ",", "type", "=", "int", ",", "default", "=", "400", ",", "help", "=", "\"drop learning rate to 1/10 every lr_drop epochs\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--wd\"", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "\"weight decay\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_epoch\"", ",", "type", "=", "int", ",", "default", "=", "200", ",", "help", "=", "\"number of epochs to run\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_es_cnt\"", ",", "type", "=", "int", ",", "default", "=", "200", ",", "\n", "help", "=", "\"number of epochs to early stop, use -1 to disable early stop\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--bsz\"", ",", "type", "=", "int", ",", "default", "=", "32", ",", "help", "=", "\"mini-batch size\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--eval_bsz\"", ",", "type", "=", "int", ",", "default", "=", "100", ",", "\n", "help", "=", "\"mini-batch size at inference, for query\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--grad_clip\"", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "help", "=", "\"perform gradient clip, -1: disable\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--eval_untrained\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Evaluate on un-trained model\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--resume\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"checkpoint path to resume or evaluate, without --resume_all this only load weights\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--resume_all\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"if --resume_all, load optimizer/scheduler/epoch as well\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--start_epoch\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"if None, will be set automatically when using --resume_all\"", ")", "\n", "\n", "# Data config", "\n", "parser", ".", "add_argument", "(", "\"--max_q_l\"", ",", "type", "=", "int", ",", "default", "=", "32", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_v_l\"", ",", "type", "=", "int", ",", "default", "=", "75", ")", "\n", "parser", ".", "add_argument", "(", "\"--clip_length\"", ",", "type", "=", "int", ",", "default", "=", "2", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_windows\"", ",", "type", "=", "int", ",", "default", "=", "5", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--train_path\"", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "\"--eval_path\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Evaluating during training, for Dev set. If None, will only do training, \"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_norm_vfeat\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Do not do normalize video feat\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_norm_tfeat\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Do not do normalize text feat\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--v_feat_dirs\"", ",", "type", "=", "str", ",", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"video feature dirs. If more than one, will concat their features. \"", "\n", "\"Note that sub ctx features are also accepted here.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--t_feat_dir\"", ",", "type", "=", "str", ",", "help", "=", "\"text/query feature dir\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--v_feat_dim\"", ",", "type", "=", "int", ",", "help", "=", "\"video feature dim\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--t_feat_dim\"", ",", "type", "=", "int", ",", "help", "=", "\"text/query feature dim\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--ctx_mode\"", ",", "type", "=", "str", ",", "default", "=", "\"video_tef\"", ")", "\n", "\n", "# Model config", "\n", "parser", ".", "add_argument", "(", "'--position_embedding'", ",", "default", "=", "'sine'", ",", "type", "=", "str", ",", "choices", "=", "(", "'sine'", ",", "'learned'", ")", ",", "\n", "help", "=", "\"Type of positional embedding to use on top of the image features\"", ")", "\n", "# * Transformer", "\n", "parser", ".", "add_argument", "(", "'--enc_layers'", ",", "default", "=", "2", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Number of encoding layers in the transformer\"", ")", "\n", "parser", ".", "add_argument", "(", "'--dec_layers'", ",", "default", "=", "2", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Number of decoding layers in the transformer\"", ")", "\n", "parser", ".", "add_argument", "(", "'--dim_feedforward'", ",", "default", "=", "1024", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Intermediate size of the feedforward layers in the transformer blocks\"", ")", "\n", "parser", ".", "add_argument", "(", "'--hidden_dim'", ",", "default", "=", "256", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Size of the embeddings (dimension of the transformer)\"", ")", "\n", "parser", ".", "add_argument", "(", "'--input_dropout'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Dropout applied in input\"", ")", "\n", "parser", ".", "add_argument", "(", "'--dropout'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Dropout applied in the transformer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--txt_drop_ratio\"", ",", "default", "=", "0", ",", "type", "=", "float", ",", "\n", "help", "=", "\"drop txt_drop_ratio tokens from text input. 0.1=10%\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--use_txt_pos\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use position_embedding for text as well.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--nheads'", ",", "default", "=", "8", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Number of attention heads inside the transformer's attentions\"", ")", "\n", "parser", ".", "add_argument", "(", "'--num_queries'", ",", "default", "=", "10", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Number of query slots\"", ")", "\n", "parser", ".", "add_argument", "(", "'--pre_norm'", ",", "action", "=", "'store_true'", ")", "\n", "# other model configs", "\n", "parser", ".", "add_argument", "(", "\"--n_input_proj\"", ",", "type", "=", "int", ",", "default", "=", "2", ",", "help", "=", "\"#layers to encoder input\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--contrastive_hdim\"", ",", "type", "=", "int", ",", "default", "=", "64", ",", "help", "=", "\"dim for contrastive embeddings\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--temperature\"", ",", "type", "=", "float", ",", "default", "=", "0.07", ",", "help", "=", "\"temperature nce contrastive_align_loss\"", ")", "\n", "# Loss", "\n", "parser", ".", "add_argument", "(", "\"--lw_saliency\"", ",", "type", "=", "float", ",", "default", "=", "1.", ",", "\n", "help", "=", "\"weight for saliency loss, set to 0 will ignore\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--saliency_margin\"", ",", "type", "=", "float", ",", "default", "=", "0.2", ")", "\n", "parser", ".", "add_argument", "(", "'--no_aux_loss'", ",", "dest", "=", "'aux_loss'", ",", "action", "=", "'store_false'", ",", "\n", "help", "=", "\"Disables auxiliary decoding losses (loss at each layer)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--span_loss_type\"", ",", "default", "=", "\"l1\"", ",", "type", "=", "str", ",", "choices", "=", "[", "'l1'", ",", "'ce'", "]", ",", "\n", "help", "=", "\"l1: (center-x, width) regression. ce: (st_idx, ed_idx) classification.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--contrastive_align_loss\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Disable contrastive_align_loss between matched query spans and the text.\"", ")", "\n", "# * Matcher", "\n", "parser", ".", "add_argument", "(", "'--set_cost_span'", ",", "default", "=", "10", ",", "type", "=", "float", ",", "\n", "help", "=", "\"L1 span coefficient in the matching cost\"", ")", "\n", "parser", ".", "add_argument", "(", "'--set_cost_giou'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "\n", "help", "=", "\"giou span coefficient in the matching cost\"", ")", "\n", "parser", ".", "add_argument", "(", "'--set_cost_class'", ",", "default", "=", "4", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Class coefficient in the matching cost\"", ")", "\n", "\n", "# * Loss coefficients", "\n", "parser", ".", "add_argument", "(", "'--span_loss_coef'", ",", "default", "=", "10", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--giou_loss_coef'", ",", "default", "=", "1", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--label_loss_coef'", ",", "default", "=", "4", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--eos_coef'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Relative classification weight of the no-object class\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--contrastive_align_loss_coef\"", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--no_sort_results\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"do not sort results, use this for moment query visualization\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_before_nms\"", ",", "type", "=", "int", ",", "default", "=", "10", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_after_nms\"", ",", "type", "=", "int", ",", "default", "=", "10", ")", "\n", "parser", ".", "add_argument", "(", "\"--conf_thd\"", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "\"only keep windows with conf >= conf_thd\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--nms_thd\"", ",", "type", "=", "float", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"additionally use non-maximum suppression \"", "\n", "\"(or non-minimum suppression for distance)\"", "\n", "\"to post-processing the predictions. \"", "\n", "\"-1: do not use nms. [0, 1]\"", ")", "\n", "self", ".", "parser", "=", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.display_save": [[147, 155], ["vars", "print", "utils.basic_utils.dict_to_markdown", "isinstance", "os.path.join", "utils.basic_utils.save_json", "vars"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.dict_to_markdown", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_json"], ["", "def", "display_save", "(", "self", ",", "opt", ")", ":", "\n", "        ", "args", "=", "vars", "(", "opt", ")", "\n", "# Display settings", "\n", "print", "(", "dict_to_markdown", "(", "vars", "(", "opt", ")", ",", "max_str_len", "=", "120", ")", ")", "\n", "# Save settings", "\n", "if", "not", "isinstance", "(", "self", ",", "TestOptions", ")", ":", "\n", "            ", "option_file_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "self", ".", "saved_option_filename", ")", "# not yaml file indeed", "\n", "save_json", "(", "args", ",", "option_file_path", ",", "save_pretty", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.parse": [[156, 214], ["config.BaseOptions.parser.parse_args", "isinstance", "config.BaseOptions.display_save", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "torch.device", "config.BaseOptions.initialize", "os.path.sep.join", "os.path.dirname", "utils.basic_utils.load_json", "os.path.join", "utils.basic_utils.mkdirp", "os.path.dirname", "os.path.join", "utils.basic_utils.make_zipfile", "os.path.join", "ValueError", "any", "os.path.realpath", "setattr", "config.BaseOptions.results_root.split", "time.strftime"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.display_save", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.TestOptions.initialize", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.load_json", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.mkdirp", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.make_zipfile"], ["", "", "def", "parse", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "", "opt", "=", "self", ".", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "opt", ".", "debug", ":", "\n", "            ", "opt", ".", "results_root", "=", "os", ".", "path", ".", "sep", ".", "join", "(", "opt", ".", "results_root", ".", "split", "(", "os", ".", "path", ".", "sep", ")", "[", ":", "-", "1", "]", "+", "[", "\"debug_results\"", ",", "]", ")", "\n", "opt", ".", "num_workers", "=", "0", "\n", "\n", "", "if", "isinstance", "(", "self", ",", "TestOptions", ")", ":", "\n", "# modify model_dir to absolute path", "\n", "# opt.model_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"results\", opt.model_dir)", "\n", "            ", "opt", ".", "model_dir", "=", "os", ".", "path", ".", "dirname", "(", "opt", ".", "resume", ")", "\n", "saved_options", "=", "load_json", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "model_dir", ",", "self", ".", "saved_option_filename", ")", ")", "\n", "for", "arg", "in", "saved_options", ":", "# use saved options to overwrite all BaseOptions args.", "\n", "                ", "if", "arg", "not", "in", "[", "\"results_root\"", ",", "\"num_workers\"", ",", "\"nms_thd\"", ",", "\"debug\"", ",", "# \"max_before_nms\", \"max_after_nms\"", "\n", "\"max_pred_l\"", ",", "\"min_pred_l\"", ",", "\n", "\"resume\"", ",", "\"resume_all\"", ",", "\"no_sort_results\"", "]", ":", "\n", "                    ", "setattr", "(", "opt", ",", "arg", ",", "saved_options", "[", "arg", "]", ")", "\n", "# opt.no_core_driver = True", "\n", "", "", "if", "opt", ".", "eval_results_dir", "is", "not", "None", ":", "\n", "                ", "opt", ".", "results_dir", "=", "opt", ".", "eval_results_dir", "\n", "", "", "else", ":", "\n", "            ", "if", "opt", ".", "exp_id", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"--exp_id is required for at a training option!\"", ")", "\n", "\n", "", "ctx_str", "=", "opt", ".", "ctx_mode", "+", "\"_sub\"", "if", "any", "(", "[", "\"sub_ctx\"", "in", "p", "for", "p", "in", "opt", ".", "v_feat_dirs", "]", ")", "else", "opt", ".", "ctx_mode", "\n", "opt", ".", "results_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_root", ",", "\n", "\"-\"", ".", "join", "(", "[", "opt", ".", "dset_name", ",", "ctx_str", ",", "opt", ".", "exp_id", ",", "\n", "time", ".", "strftime", "(", "\"%Y_%m_%d_%H_%M_%S\"", ")", "]", ")", ")", "\n", "mkdirp", "(", "opt", ".", "results_dir", ")", "\n", "# save a copy of current code", "\n", "code_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", "\n", "code_zip_filename", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "\"code.zip\"", ")", "\n", "make_zipfile", "(", "code_dir", ",", "code_zip_filename", ",", "\n", "enclosing_dir", "=", "\"code\"", ",", "\n", "exclude_dirs_substring", "=", "\"results\"", ",", "\n", "exclude_dirs", "=", "[", "\"results\"", ",", "\"debug_results\"", ",", "\"__pycache__\"", "]", ",", "\n", "exclude_extensions", "=", "[", "\".pyc\"", ",", "\".ipynb\"", ",", "\".swap\"", "]", ",", ")", "\n", "\n", "", "self", ".", "display_save", "(", "opt", ")", "\n", "\n", "opt", ".", "ckpt_filepath", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "self", ".", "ckpt_filename", ")", "\n", "opt", ".", "train_log_filepath", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "self", ".", "train_log_filename", ")", "\n", "opt", ".", "eval_log_filepath", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "self", ".", "eval_log_filename", ")", "\n", "opt", ".", "tensorboard_log_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "self", ".", "tensorboard_log_dir", ")", "\n", "opt", ".", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "opt", ".", "device", ">=", "0", "else", "\"cpu\"", ")", "\n", "opt", ".", "pin_memory", "=", "not", "opt", ".", "no_pin_memory", "\n", "\n", "opt", ".", "use_tef", "=", "\"tef\"", "in", "opt", ".", "ctx_mode", "\n", "opt", ".", "use_video", "=", "\"video\"", "in", "opt", ".", "ctx_mode", "\n", "if", "not", "opt", ".", "use_video", ":", "\n", "            ", "opt", ".", "v_feat_dim", "=", "0", "\n", "", "if", "opt", ".", "use_tef", ":", "\n", "            ", "opt", ".", "v_feat_dim", "+=", "2", "\n", "\n", "", "self", ".", "opt", "=", "opt", "\n", "return", "opt", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.TestOptions.initialize": [[219, 227], ["config.BaseOptions.initialize", "config.TestOptions.parser.add_argument", "config.TestOptions.parser.add_argument", "config.TestOptions.parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.TestOptions.initialize"], ["def", "initialize", "(", "self", ")", ":", "\n", "        ", "BaseOptions", ".", "initialize", "(", "self", ")", "\n", "# also need to specify --eval_split_name", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--eval_id\"", ",", "type", "=", "str", ",", "help", "=", "\"evaluation id\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--eval_results_dir\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"dir to save results, if not set, fall back to training results_dir\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--model_dir\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"dir contains the model file, will be converted to absolute path afterwards\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_xx_to_cxw": [[4, 23], ["torch.stack", "xx_spans.sum"], "function", ["None"], ["def", "span_xx_to_cxw", "(", "xx_spans", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        xx_spans: tensor, (#windows, 2) or (..., 2), each row is a window of format (st, ed)\n\n    Returns:\n        cxw_spans: tensor, (#windows, 2), each row is a window of format (center=(st+ed)/2, width=(ed-st))\n    >>> spans = torch.Tensor([[0, 1], [0.2, 0.4]])\n    >>> span_xx_to_cxw(spans)\n    tensor([[0.5000, 1.0000],\n        [0.3000, 0.2000]])\n    >>> spans = torch.Tensor([[[0, 1], [0.2, 0.4]]])\n    >>> span_xx_to_cxw(spans)\n    tensor([[[0.5000, 1.0000],\n         [0.3000, 0.2000]]])\n    \"\"\"", "\n", "center", "=", "xx_spans", ".", "sum", "(", "-", "1", ")", "*", "0.5", "\n", "width", "=", "xx_spans", "[", "...", ",", "1", "]", "-", "xx_spans", "[", "...", ",", "0", "]", "\n", "return", "torch", ".", "stack", "(", "[", "center", ",", "width", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx": [[25, 42], ["torch.stack"], "function", ["None"], ["", "def", "span_cxw_to_xx", "(", "cxw_spans", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cxw_spans: tensor, (#windows, 2) or (..., 2), the last dim is a row denoting a window of format (center, width)\n\n    >>> spans = torch.Tensor([[0.5000, 1.0000], [0.3000, 0.2000]])\n    >>> span_cxw_to_xx(spans)\n    tensor([[0.0000, 1.0000],\n        [0.2000, 0.4000]])\n    >>> spans = torch.Tensor([[[0.5000, 1.0000], [0.3000, 0.2000]]])\n    >>> span_cxw_to_xx(spans)\n    tensor([[[0.0000, 1.0000],\n        [0.2000, 0.4000]]])\n    \"\"\"", "\n", "x1", "=", "cxw_spans", "[", "...", ",", "0", "]", "-", "0.5", "*", "cxw_spans", "[", "...", ",", "1", "]", "\n", "x2", "=", "cxw_spans", "[", "...", ",", "0", "]", "+", "0.5", "*", "cxw_spans", "[", "...", ",", "1", "]", "\n", "return", "torch", ".", "stack", "(", "[", "x1", ",", "x2", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.temporal_iou": [[44, 72], ["torch.max", "torch.min"], "function", ["None"], ["", "def", "temporal_iou", "(", "spans1", ",", "spans2", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        spans1: (N, 2) torch.Tensor, each row defines a span [st, ed]\n        spans2: (M, 2) torch.Tensor, ...\n\n    Returns:\n        iou: (N, M) torch.Tensor\n        union: (N, M) torch.Tensor\n    >>> test_spans1 = torch.Tensor([[0, 0.2], [0.5, 1.0]])\n    >>> test_spans2 = torch.Tensor([[0, 0.3], [0., 1.0]])\n    >>> temporal_iou(test_spans1, test_spans2)\n    (tensor([[0.6667, 0.2000],\n         [0.0000, 0.5000]]),\n     tensor([[0.3000, 1.0000],\n             [0.8000, 1.0000]]))\n    \"\"\"", "\n", "areas1", "=", "spans1", "[", ":", ",", "1", "]", "-", "spans1", "[", ":", ",", "0", "]", "# (N, )", "\n", "areas2", "=", "spans2", "[", ":", ",", "1", "]", "-", "spans2", "[", ":", ",", "0", "]", "# (M, )", "\n", "\n", "left", "=", "torch", ".", "max", "(", "spans1", "[", ":", ",", "None", ",", "0", "]", ",", "spans2", "[", ":", ",", "0", "]", ")", "# (N, M)", "\n", "right", "=", "torch", ".", "min", "(", "spans1", "[", ":", ",", "None", ",", "1", "]", ",", "spans2", "[", ":", ",", "1", "]", ")", "# (N, M)", "\n", "\n", "inter", "=", "(", "right", "-", "left", ")", ".", "clamp", "(", "min", "=", "0", ")", "# (N, M)", "\n", "union", "=", "areas1", "[", ":", ",", "None", "]", "+", "areas2", "-", "inter", "# (N, M)", "\n", "\n", "iou", "=", "inter", "/", "union", "\n", "return", "iou", ",", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.temporal_intersection_over_pred": [[74, 89], ["torch.max", "torch.min"], "function", ["None"], ["", "def", "temporal_intersection_over_pred", "(", "gt_spans", ",", "pred_spans", ")", ":", "\n", "    ", "\"\"\" intersection over the second input spans\n    Args:\n        gt_spans: (N, 2),\n        pred_spans: (M, 2)\n\n    Returns:\n\n    \"\"\"", "\n", "left", "=", "torch", ".", "max", "(", "gt_spans", "[", ":", ",", "None", ",", "0", "]", ",", "pred_spans", "[", ":", ",", "0", "]", ")", "\n", "right", "=", "torch", ".", "min", "(", "gt_spans", "[", ":", ",", "None", ",", "1", "]", ",", "pred_spans", "[", ":", ",", "1", "]", ")", "\n", "\n", "inter", "=", "(", "right", "-", "left", ")", ".", "clamp", "(", "min", "=", "0", ")", "# (N, M)", "\n", "inter_over_pred", "=", "inter", "/", "(", "pred_spans", "[", ":", ",", "1", "]", "-", "pred_spans", "[", ":", ",", "0", "]", ")", "\n", "return", "inter_over_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.generalized_temporal_iou": [[91, 121], ["spans1.float.float", "spans2.float.float", "span_utils.temporal_iou", "torch.min", "torch.max"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.temporal_iou"], ["", "def", "generalized_temporal_iou", "(", "spans1", ",", "spans2", ")", ":", "\n", "    ", "\"\"\"\n    Generalized IoU from https://giou.stanford.edu/\n    Also reference to DETR implementation of generalized_box_iou\n    https://github.com/facebookresearch/detr/blob/master/util/box_ops.py#L40\n\n    Args:\n        spans1: (N, 2) torch.Tensor, each row defines a span in xx format [st, ed]\n        spans2: (M, 2) torch.Tensor, ...\n\n    Returns:\n        giou: (N, M) torch.Tensor\n\n    >>> test_spans1 = torch.Tensor([[0, 0.2], [0.5, 1.0]])\n    >>> test_spans2 = torch.Tensor([[0, 0.3], [0., 1.0]])\n    >>> generalized_temporal_iou(test_spans1, test_spans2)\n    tensor([[ 0.6667,  0.2000],\n        [-0.2000,  0.5000]])\n    \"\"\"", "\n", "spans1", "=", "spans1", ".", "float", "(", ")", "\n", "spans2", "=", "spans2", ".", "float", "(", ")", "\n", "assert", "(", "spans1", "[", ":", ",", "1", "]", ">=", "spans1", "[", ":", ",", "0", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "spans2", "[", ":", ",", "1", "]", ">=", "spans2", "[", ":", ",", "0", "]", ")", ".", "all", "(", ")", "\n", "iou", ",", "union", "=", "temporal_iou", "(", "spans1", ",", "spans2", ")", "\n", "\n", "left", "=", "torch", ".", "min", "(", "spans1", "[", ":", ",", "None", ",", "0", "]", ",", "spans2", "[", ":", ",", "0", "]", ")", "# (N, M)", "\n", "right", "=", "torch", ".", "max", "(", "spans1", "[", ":", ",", "None", ",", "1", "]", ",", "spans2", "[", ":", ",", "1", "]", ")", "# (N, M)", "\n", "enclosing_area", "=", "(", "right", "-", "left", ")", ".", "clamp", "(", "min", "=", "0", ")", "# (N, M)", "\n", "\n", "return", "iou", "-", "(", "enclosing_area", "-", "union", ")", "/", "enclosing_area", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.matcher.HungarianMatcher.__init__": [[19, 35], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["def", "__init__", "(", "self", ",", "cost_class", ":", "float", "=", "1", ",", "cost_span", ":", "float", "=", "1", ",", "cost_giou", ":", "float", "=", "1", ",", "\n", "span_loss_type", ":", "str", "=", "\"l1\"", ",", "max_v_l", ":", "int", "=", "75", ")", ":", "\n", "        ", "\"\"\"Creates the matcher\n\n        Params:\n            cost_span: This is the relative weight of the L1 error of the span coordinates in the matching cost\n            cost_giou: This is the relative weight of the giou loss of the spans in the matching cost\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cost_class", "=", "cost_class", "\n", "self", ".", "cost_span", "=", "cost_span", "\n", "self", ".", "cost_giou", "=", "cost_giou", "\n", "self", ".", "span_loss_type", "=", "span_loss_type", "\n", "self", ".", "max_v_l", "=", "max_v_l", "\n", "self", ".", "foreground_label", "=", "0", "\n", "assert", "cost_class", "!=", "0", "or", "cost_span", "!=", "0", "or", "cost_giou", "!=", "0", ",", "\"all costs cant be 0\"", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.matcher.HungarianMatcher.forward": [[36, 101], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "outputs[].flatten().softmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full", "torch.full", "torch.full", "torch.full", "C.view().cpu.view().cpu.view().cpu", "outputs[].flatten", "torch.cdist", "torch.cdist", "torch.cdist", "torch.cdist", "pred_spans.view().softmax.view().softmax.view().softmax", "len", "scipy.optimize.linear_sum_assignment", "outputs[].flatten", "len", "moment_detr.span_utils.generalized_temporal_iou", "C.view().cpu.view().cpu.view", "enumerate", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "moment_detr.span_utils.span_cxw_to_xx", "moment_detr.span_utils.span_cxw_to_xx", "pred_spans.view().softmax.view().softmax.view", "C.view().cpu.view().cpu.split"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.generalized_temporal_iou", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "forward", "(", "self", ",", "outputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\" Performs the matching\n\n        Params:\n            outputs: This is a dict that contains at least these entries:\n                 \"pred_spans\": Tensor of dim [batch_size, num_queries, 2] with the predicted span coordinates,\n                    in normalized (cx, w) format\n                 \"\"pred_logits\": Tensor of dim [batch_size, num_queries, num_classes] with the classification logits\n\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a dict containing:\n                 \"spans\": Tensor of dim [num_target_spans, 2] containing the target span coordinates. The spans are\n                    in normalized (cx, w) format\n\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_spans)\n        \"\"\"", "\n", "bs", ",", "num_queries", "=", "outputs", "[", "\"pred_spans\"", "]", ".", "shape", "[", ":", "2", "]", "\n", "targets", "=", "targets", "[", "\"span_labels\"", "]", "\n", "\n", "# Also concat the target labels and spans", "\n", "out_prob", "=", "outputs", "[", "\"pred_logits\"", "]", ".", "flatten", "(", "0", ",", "1", ")", ".", "softmax", "(", "-", "1", ")", "# [batch_size * num_queries, num_classes]", "\n", "tgt_spans", "=", "torch", ".", "cat", "(", "[", "v", "[", "\"spans\"", "]", "for", "v", "in", "targets", "]", ")", "# [num_target_spans in batch, 2]", "\n", "tgt_ids", "=", "torch", ".", "full", "(", "[", "len", "(", "tgt_spans", ")", "]", ",", "self", ".", "foreground_label", ")", "# [total #spans in the batch]", "\n", "\n", "# Compute the classification cost. Contrary to the loss, we don't use the NLL,", "\n", "# but approximate it in 1 - prob[target class].", "\n", "# The 1 is a constant that doesn't change the matching, it can be omitted.", "\n", "cost_class", "=", "-", "out_prob", "[", ":", ",", "tgt_ids", "]", "# [batch_size * num_queries, total #spans in the batch]", "\n", "\n", "if", "self", ".", "span_loss_type", "==", "\"l1\"", ":", "\n", "# We flatten to compute the cost matrices in a batch", "\n", "            ", "out_spans", "=", "outputs", "[", "\"pred_spans\"", "]", ".", "flatten", "(", "0", ",", "1", ")", "# [batch_size * num_queries, 2]", "\n", "\n", "# Compute the L1 cost between spans", "\n", "cost_span", "=", "torch", ".", "cdist", "(", "out_spans", ",", "tgt_spans", ",", "p", "=", "1", ")", "# [batch_size * num_queries, total #spans in the batch]", "\n", "\n", "# Compute the giou cost between spans", "\n", "# [batch_size * num_queries, total #spans in the batch]", "\n", "cost_giou", "=", "-", "generalized_temporal_iou", "(", "span_cxw_to_xx", "(", "out_spans", ")", ",", "span_cxw_to_xx", "(", "tgt_spans", ")", ")", "\n", "", "else", ":", "\n", "            ", "pred_spans", "=", "outputs", "[", "\"pred_spans\"", "]", "# (bsz, #queries, max_v_l * 2)", "\n", "pred_spans", "=", "pred_spans", ".", "view", "(", "bs", "*", "num_queries", ",", "2", ",", "self", ".", "max_v_l", ")", ".", "softmax", "(", "-", "1", ")", "# (bsz * #queries, 2, max_v_l)", "\n", "cost_span", "=", "-", "pred_spans", "[", ":", ",", "0", "]", "[", ":", ",", "tgt_spans", "[", ":", ",", "0", "]", "]", "-", "pred_spans", "[", ":", ",", "1", "]", "[", ":", ",", "tgt_spans", "[", ":", ",", "1", "]", "]", "# (bsz * #queries, #spans)", "\n", "# pred_spans = pred_spans.repeat(1, n_spans, 1, 1).flatten(0, 1)  # (bsz * #queries * #spans, max_v_l, 2)", "\n", "# tgt_spans = tgt_spans.view(1, n_spans, 2).repeat(bs * num_queries, 1, 1).flatten(0, 1)  # (bsz * #queries * #spans, 2)", "\n", "# cost_span = pred_spans[tgt_spans]", "\n", "# cost_span = cost_span.view(bs * num_queries, n_spans)", "\n", "\n", "# giou", "\n", "cost_giou", "=", "0", "\n", "\n", "# Final cost matrix", "\n", "# import ipdb; ipdb.set_trace()", "\n", "", "C", "=", "self", ".", "cost_span", "*", "cost_span", "+", "self", ".", "cost_giou", "*", "cost_giou", "+", "self", ".", "cost_class", "*", "cost_class", "\n", "C", "=", "C", ".", "view", "(", "bs", ",", "num_queries", ",", "-", "1", ")", ".", "cpu", "(", ")", "\n", "\n", "sizes", "=", "[", "len", "(", "v", "[", "\"spans\"", "]", ")", "for", "v", "in", "targets", "]", "\n", "indices", "=", "[", "linear_sum_assignment", "(", "c", "[", "i", "]", ")", "for", "i", ",", "c", "in", "enumerate", "(", "C", ".", "split", "(", "sizes", ",", "-", "1", ")", ")", "]", "\n", "return", "[", "(", "torch", ".", "as_tensor", "(", "i", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "torch", ".", "as_tensor", "(", "j", ",", "dtype", "=", "torch", ".", "int64", ")", ")", "for", "i", ",", "j", "in", "indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.matcher.build_matcher": [[103, 107], ["matcher.HungarianMatcher"], "function", ["None"], ["", "", "def", "build_matcher", "(", "args", ")", ":", "\n", "    ", "return", "HungarianMatcher", "(", "\n", "cost_span", "=", "args", ".", "set_cost_span", ",", "cost_giou", "=", "args", ".", "set_cost_giou", ",", "\n", "cost_class", "=", "args", ".", "set_cost_class", ",", "span_loss_type", "=", "args", ".", "span_loss_type", ",", "max_v_l", "=", "args", ".", "max_v_l", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.text_encoder.TextEncoder.__init__": [[9, 24], ["torch.Module.__init__", "xml.model_components.BertAttention", "xml.model_components.TrainablePositionalEncoding", "torch.Linear", "torch.Linear", "torch.Linear", "easydict.EasyDict"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ",", "drop", ",", "input_drop", ",", "nheads", ",", "max_position_embeddings", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "transformer_encoder", "=", "BertAttention", "(", "edict", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "intermediate_size", "=", "hidden_size", ",", "\n", "hidden_dropout_prob", "=", "drop", ",", "\n", "attention_probs_dropout_prob", "=", "drop", ",", "\n", "num_attention_heads", "=", "nheads", ",", "\n", ")", ")", "\n", "self", ".", "pos_embed", "=", "TrainablePositionalEncoding", "(", "\n", "max_position_embeddings", "=", "max_position_embeddings", ",", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "dropout", "=", "input_drop", ",", "\n", ")", "\n", "self", ".", "modular_vector_mapping", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.text_encoder.TextEncoder.forward": [[25, 40], ["text_encoder.TextEncoder.pos_embed", "text_encoder.TextEncoder.transformer_encoder", "text_encoder.TextEncoder.modular_vector_mapping", "torch.softmax", "torch.softmax", "torch.softmax", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum.squeeze", "torch.einsum.squeeze", "torch.einsum.squeeze", "mask.unsqueeze", "text_encoder.mask_logits", "mask.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.text_encoder.mask_logits"], ["", "def", "forward", "(", "self", ",", "feat", ",", "mask", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat: (N, L, D=hidden_size)\n            mask: (N, L) with 1 indicates valid\n\n        Returns:\n            (N, D)\n        \"\"\"", "\n", "feat", "=", "self", ".", "pos_embed", "(", "feat", ")", "# (N, L, D)", "\n", "feat", "=", "self", ".", "transformer_encoder", "(", "feat", ",", "mask", ".", "unsqueeze", "(", "1", ")", ")", "\n", "att_scores", "=", "self", ".", "modular_vector_mapping", "(", "feat", ")", "# (N, L, 1)", "\n", "att_scores", "=", "F", ".", "softmax", "(", "mask_logits", "(", "att_scores", ",", "mask", ".", "unsqueeze", "(", "2", ")", ")", ",", "dim", "=", "1", ")", "\n", "pooled_feat", "=", "torch", ".", "einsum", "(", "\"blm,bld->bmd\"", ",", "att_scores", ",", "feat", ")", "# (N, 2 or 1, D)", "\n", "return", "pooled_feat", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.text_encoder.mask_logits": [[42, 44], ["None"], "function", ["None"], ["", "", "def", "mask_logits", "(", "target", ",", "mask", ")", ":", "\n", "    ", "return", "target", "*", "mask", "+", "(", "1", "-", "mask", ")", "*", "(", "-", "1e10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.text_encoder.build_text_encoder": [[46, 53], ["text_encoder.TextEncoder"], "function", ["None"], ["", "def", "build_text_encoder", "(", "args", ")", ":", "\n", "    ", "return", "TextEncoder", "(", "\n", "hidden_size", "=", "args", ".", "hidden_dim", ",", "\n", "drop", "=", "args", ".", "dropout", ",", "\n", "input_drop", "=", "args", ".", "input_dropout", ",", "\n", "nheads", "=", "args", ".", "nheads", ",", "\n", "max_position_embeddings", "=", "args", ".", "max_q_l", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.post_processing_mr_nms": [[30, 40], ["utils.temporal_nms.temporal_nms", "mr_res_after_nms.append"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.temporal_nms.temporal_nms"], ["def", "post_processing_mr_nms", "(", "mr_res", ",", "nms_thd", ",", "max_before_nms", ",", "max_after_nms", ")", ":", "\n", "    ", "mr_res_after_nms", "=", "[", "]", "\n", "for", "e", "in", "mr_res", ":", "\n", "        ", "e", "[", "\"pred_relevant_windows\"", "]", "=", "temporal_nms", "(", "\n", "e", "[", "\"pred_relevant_windows\"", "]", "[", ":", "max_before_nms", "]", ",", "\n", "nms_thd", "=", "nms_thd", ",", "\n", "max_after_nms", "=", "max_after_nms", "\n", ")", "\n", "mr_res_after_nms", ".", "append", "(", "e", ")", "\n", "", "return", "mr_res_after_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.eval_epoch_post_processing": [[42, 84], ["logger.info", "os.path.join", "utils.basic_utils.save_jsonl", "standalone_eval.eval.eval_submission", "os.path.join.replace", "utils.basic_utils.save_json", "logger.info", "inference.post_processing_mr_nms", "logger.info", "os.path.join.replace", "utils.basic_utils.save_jsonl", "standalone_eval.eval.eval_submission", "submission_path.replace.replace", "utils.basic_utils.save_json"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_jsonl", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_submission", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_json", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.post_processing_mr_nms", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_jsonl", "home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.eval.eval_submission", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.save_json"], ["", "def", "eval_epoch_post_processing", "(", "submission", ",", "opt", ",", "gt_data", ",", "save_submission_filename", ")", ":", "\n", "# IOU_THDS = (0.5, 0.7)", "\n", "    ", "logger", ".", "info", "(", "\"Saving/Evaluating before nms results\"", ")", "\n", "submission_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "results_dir", ",", "save_submission_filename", ")", "\n", "save_jsonl", "(", "submission", ",", "submission_path", ")", "\n", "\n", "if", "opt", ".", "eval_split_name", "in", "[", "\"val\"", ",", "\"test\"", "]", ":", "# since test_public has no GT", "\n", "        ", "metrics", "=", "eval_submission", "(", "\n", "submission", ",", "gt_data", ",", "\n", "verbose", "=", "opt", ".", "debug", ",", "match_number", "=", "not", "opt", ".", "debug", "\n", ")", "\n", "save_metrics_path", "=", "submission_path", ".", "replace", "(", "\".jsonl\"", ",", "\"_metrics.json\"", ")", "\n", "save_json", "(", "metrics", ",", "save_metrics_path", ",", "save_pretty", "=", "True", ",", "sort_keys", "=", "False", ")", "\n", "latest_file_paths", "=", "[", "submission_path", ",", "save_metrics_path", "]", "\n", "", "else", ":", "\n", "        ", "metrics", "=", "None", "\n", "latest_file_paths", "=", "[", "submission_path", ",", "]", "\n", "\n", "", "if", "opt", ".", "nms_thd", "!=", "-", "1", ":", "\n", "        ", "logger", ".", "info", "(", "\"[MR] Performing nms with nms_thd {}\"", ".", "format", "(", "opt", ".", "nms_thd", ")", ")", "\n", "submission_after_nms", "=", "post_processing_mr_nms", "(", "\n", "submission", ",", "nms_thd", "=", "opt", ".", "nms_thd", ",", "\n", "max_before_nms", "=", "opt", ".", "max_before_nms", ",", "max_after_nms", "=", "opt", ".", "max_after_nms", "\n", ")", "\n", "\n", "logger", ".", "info", "(", "\"Saving/Evaluating nms results\"", ")", "\n", "submission_nms_path", "=", "submission_path", ".", "replace", "(", "\".jsonl\"", ",", "\"_nms_thd_{}.jsonl\"", ".", "format", "(", "opt", ".", "nms_thd", ")", ")", "\n", "save_jsonl", "(", "submission_after_nms", ",", "submission_nms_path", ")", "\n", "if", "opt", ".", "eval_split_name", "==", "\"val\"", ":", "\n", "            ", "metrics_nms", "=", "eval_submission", "(", "\n", "submission_after_nms", ",", "gt_data", ",", "\n", "verbose", "=", "opt", ".", "debug", ",", "match_number", "=", "not", "opt", ".", "debug", "\n", ")", "\n", "save_metrics_nms_path", "=", "submission_nms_path", ".", "replace", "(", "\".jsonl\"", ",", "\"_metrics.json\"", ")", "\n", "save_json", "(", "metrics_nms", ",", "save_metrics_nms_path", ",", "save_pretty", "=", "True", ",", "sort_keys", "=", "False", ")", "\n", "latest_file_paths", "+=", "[", "submission_nms_path", ",", "save_metrics_nms_path", "]", "\n", "", "else", ":", "\n", "            ", "metrics_nms", "=", "None", "\n", "latest_file_paths", "=", "[", "submission_nms_path", ",", "]", "\n", "", "", "else", ":", "\n", "        ", "metrics_nms", "=", "None", "\n", "", "return", "metrics", ",", "metrics_nms", ",", "latest_file_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.compute_mr_results": [[86, 159], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "collections.defaultdict", "tqdm.tqdm", "moment_detr.postprocessing_moment_detr.PostProcessorDETR", "moment_detr.postprocessing_moment_detr.PostProcessorDETR.", "criterion.eval", "moment_detr.start_end_dataset.prepare_batch_inputs", "model", "torch.softmax", "enumerate", "collections.defaultdict.items", "outputs[].half", "model_inputs[].sum().cpu().tolist", "range", "outputs[].view", "torch.softmax().max", "torch.prod", "torch.prod", "torch.prod", "zip", "torch.cat().tolist", "torch.cat().tolist", "torch.cat().tolist", "dict", "post_processor.append", "criterion", "sum", "float", "criterion.items", "tb_writer.add_scalar", "len", "saliency_scores.append", "pred_spans.cpu", "torch.prod.cpu", "sorted", "loss_meters[].update", "model_inputs[].sum().cpu", "_saliency_scores[].tolist", "torch.softmax", "moment_detr.span_utils.span_cxw_to_xx", "torch.cat", "torch.cat", "torch.cat", "float", "criterion.keys", "float", "model_inputs[].sum", "float", "int"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.prepare_batch_inputs", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "compute_mr_results", "(", "model", ",", "eval_loader", ",", "opt", ",", "epoch_i", "=", "None", ",", "criterion", "=", "None", ",", "tb_writer", "=", "None", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "if", "criterion", ":", "\n", "        ", "assert", "eval_loader", ".", "dataset", ".", "load_labels", "\n", "criterion", ".", "eval", "(", ")", "\n", "\n", "", "loss_meters", "=", "defaultdict", "(", "AverageMeter", ")", "\n", "write_tb", "=", "tb_writer", "is", "not", "None", "and", "epoch_i", "is", "not", "None", "\n", "\n", "mr_res", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "eval_loader", ",", "desc", "=", "\"compute st ed scores\"", ")", ":", "\n", "        ", "query_meta", "=", "batch", "[", "0", "]", "\n", "model_inputs", ",", "targets", "=", "prepare_batch_inputs", "(", "batch", "[", "1", "]", ",", "opt", ".", "device", ",", "non_blocking", "=", "opt", ".", "pin_memory", ")", "\n", "outputs", "=", "model", "(", "**", "model_inputs", ")", "\n", "prob", "=", "F", ".", "softmax", "(", "outputs", "[", "\"pred_logits\"", "]", ",", "-", "1", ")", "# (batch_size, #queries, #classes=2)", "\n", "if", "opt", ".", "span_loss_type", "==", "\"l1\"", ":", "\n", "            ", "scores", "=", "prob", "[", "...", ",", "0", "]", "# * (batch_size, #queries)  foreground label is 0, we directly take it", "\n", "pred_spans", "=", "outputs", "[", "\"pred_spans\"", "]", "# (bsz, #queries, 2)", "\n", "_saliency_scores", "=", "outputs", "[", "\"saliency_scores\"", "]", ".", "half", "(", ")", "# (bsz, L)", "\n", "saliency_scores", "=", "[", "]", "\n", "valid_vid_lengths", "=", "model_inputs", "[", "\"src_vid_mask\"", "]", ".", "sum", "(", "1", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "valid_vid_lengths", ")", ")", ":", "\n", "                ", "saliency_scores", ".", "append", "(", "_saliency_scores", "[", "j", ",", ":", "int", "(", "valid_vid_lengths", "[", "j", "]", ")", "]", ".", "tolist", "(", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "bsz", ",", "n_queries", "=", "outputs", "[", "\"pred_spans\"", "]", ".", "shape", "[", ":", "2", "]", "# # (bsz, #queries, max_v_l *2)", "\n", "pred_spans_logits", "=", "outputs", "[", "\"pred_spans\"", "]", ".", "view", "(", "bsz", ",", "n_queries", ",", "2", ",", "opt", ".", "max_v_l", ")", "\n", "# TODO use more advanced decoding method with st_ed product", "\n", "pred_span_scores", ",", "pred_spans", "=", "F", ".", "softmax", "(", "pred_spans_logits", ",", "dim", "=", "-", "1", ")", ".", "max", "(", "-", "1", ")", "# 2 * (bsz, #queries, 2)", "\n", "scores", "=", "torch", ".", "prod", "(", "pred_span_scores", ",", "2", ")", "# (bsz, #queries)", "\n", "pred_spans", "[", ":", ",", "1", "]", "+=", "1", "\n", "pred_spans", "*=", "opt", ".", "clip_length", "\n", "\n", "# compose predictions", "\n", "", "for", "idx", ",", "(", "meta", ",", "spans", ",", "score", ")", "in", "enumerate", "(", "zip", "(", "query_meta", ",", "pred_spans", ".", "cpu", "(", ")", ",", "scores", ".", "cpu", "(", ")", ")", ")", ":", "\n", "            ", "if", "opt", ".", "span_loss_type", "==", "\"l1\"", ":", "\n", "                ", "spans", "=", "span_cxw_to_xx", "(", "spans", ")", "*", "meta", "[", "\"duration\"", "]", "\n", "# # (#queries, 3), [st(float), ed(float), score(float)]", "\n", "", "cur_ranked_preds", "=", "torch", ".", "cat", "(", "[", "spans", ",", "score", "[", ":", ",", "None", "]", "]", ",", "dim", "=", "1", ")", ".", "tolist", "(", ")", "\n", "if", "not", "opt", ".", "no_sort_results", ":", "\n", "                ", "cur_ranked_preds", "=", "sorted", "(", "cur_ranked_preds", ",", "key", "=", "lambda", "x", ":", "x", "[", "2", "]", ",", "reverse", "=", "True", ")", "\n", "", "cur_ranked_preds", "=", "[", "[", "float", "(", "f\"{e:.4f}\"", ")", "for", "e", "in", "row", "]", "for", "row", "in", "cur_ranked_preds", "]", "\n", "cur_query_pred", "=", "dict", "(", "\n", "qid", "=", "meta", "[", "\"qid\"", "]", ",", "\n", "query", "=", "meta", "[", "\"query\"", "]", ",", "\n", "vid", "=", "meta", "[", "\"vid\"", "]", ",", "\n", "pred_relevant_windows", "=", "cur_ranked_preds", ",", "\n", "pred_saliency_scores", "=", "saliency_scores", "[", "idx", "]", "\n", ")", "\n", "mr_res", ".", "append", "(", "cur_query_pred", ")", "\n", "\n", "", "if", "criterion", ":", "\n", "            ", "loss_dict", "=", "criterion", "(", "outputs", ",", "targets", ")", "\n", "weight_dict", "=", "criterion", ".", "weight_dict", "\n", "losses", "=", "sum", "(", "loss_dict", "[", "k", "]", "*", "weight_dict", "[", "k", "]", "for", "k", "in", "loss_dict", ".", "keys", "(", ")", "if", "k", "in", "weight_dict", ")", "\n", "loss_dict", "[", "\"loss_overall\"", "]", "=", "float", "(", "losses", ")", "# for logging only", "\n", "for", "k", ",", "v", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "                ", "loss_meters", "[", "k", "]", ".", "update", "(", "float", "(", "v", ")", "*", "weight_dict", "[", "k", "]", "if", "k", "in", "weight_dict", "else", "float", "(", "v", ")", ")", "\n", "\n", "", "", "if", "opt", ".", "debug", ":", "\n", "            ", "break", "\n", "\n", "", "", "if", "write_tb", "and", "criterion", ":", "\n", "        ", "for", "k", ",", "v", "in", "loss_meters", ".", "items", "(", ")", ":", "\n", "            ", "tb_writer", ".", "add_scalar", "(", "\"Eval/{}\"", ".", "format", "(", "k", ")", ",", "v", ".", "avg", ",", "epoch_i", "+", "1", ")", "\n", "\n", "", "", "post_processor", "=", "PostProcessorDETR", "(", "\n", "clip_length", "=", "2", ",", "min_ts_val", "=", "0", ",", "max_ts_val", "=", "150", ",", "\n", "min_w_l", "=", "2", ",", "max_w_l", "=", "150", ",", "move_window_method", "=", "\"left\"", ",", "\n", "process_func_names", "=", "(", "\"clip_ts\"", ",", "\"round_multiple\"", ")", "\n", ")", "\n", "mr_res", "=", "post_processor", "(", "mr_res", ")", "\n", "return", "mr_res", ",", "loss_meters", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.get_eval_res": [[161, 165], ["inference.compute_mr_results"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.compute_mr_results"], ["", "def", "get_eval_res", "(", "model", ",", "eval_loader", ",", "opt", ",", "epoch_i", ",", "criterion", ",", "tb_writer", ")", ":", "\n", "    ", "\"\"\"compute and save query and video proposal embeddings\"\"\"", "\n", "eval_res", ",", "eval_loss_meters", "=", "compute_mr_results", "(", "model", ",", "eval_loader", ",", "opt", ",", "epoch_i", ",", "criterion", ",", "tb_writer", ")", "# list(dict)", "\n", "return", "eval_res", ",", "eval_loss_meters", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.eval_epoch": [[167, 190], ["logger.info", "model.eval", "torch.utils.data.DataLoader", "inference.get_eval_res", "inference.eval_epoch_post_processing", "criterion.eval", "save_submission_filename.replace.replace"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.get_eval_res", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.eval_epoch_post_processing"], ["", "def", "eval_epoch", "(", "model", ",", "eval_dataset", ",", "opt", ",", "save_submission_filename", ",", "epoch_i", "=", "None", ",", "criterion", "=", "None", ",", "tb_writer", "=", "None", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Generate submissions\"", ")", "\n", "model", ".", "eval", "(", ")", "\n", "if", "criterion", "is", "not", "None", "and", "eval_dataset", ".", "load_labels", ":", "\n", "        ", "criterion", ".", "eval", "(", ")", "\n", "", "else", ":", "\n", "        ", "criterion", "=", "None", "\n", "\n", "", "eval_loader", "=", "DataLoader", "(", "\n", "eval_dataset", ",", "\n", "collate_fn", "=", "start_end_collate", ",", "\n", "batch_size", "=", "opt", ".", "eval_bsz", ",", "\n", "num_workers", "=", "opt", ".", "num_workers", ",", "\n", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "opt", ".", "pin_memory", "\n", ")", "\n", "\n", "submission", ",", "eval_loss_meters", "=", "get_eval_res", "(", "model", ",", "eval_loader", ",", "opt", ",", "epoch_i", ",", "criterion", ",", "tb_writer", ")", "\n", "if", "opt", ".", "no_sort_results", ":", "\n", "        ", "save_submission_filename", "=", "save_submission_filename", ".", "replace", "(", "\".jsonl\"", ",", "\"_unsorted.jsonl\"", ")", "\n", "", "metrics", ",", "metrics_nms", ",", "latest_file_paths", "=", "eval_epoch_post_processing", "(", "\n", "submission", ",", "opt", ",", "eval_dataset", ".", "data", ",", "save_submission_filename", ")", "\n", "return", "metrics", ",", "metrics_nms", ",", "eval_loss_meters", ",", "latest_file_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.setup_model": [[192, 218], ["logger.info", "moment_detr.model.build_model", "torch.optim.AdamW", "torch.optim.AdamW", "torch.optim.AdamW", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "logger.info", "model.to", "criterion.to", "logger.info", "torch.load", "torch.load", "torch.load", "model.load_state_dict", "logger.info", "logger.warning", "torch.optim.AdamW.load_state_dict", "torch.optim.lr_scheduler.StepLR.load_state_dict", "model.named_parameters"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.build_model", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["", "def", "setup_model", "(", "opt", ")", ":", "\n", "    ", "\"\"\"setup model/optimizer/scheduler and load checkpoints when needed\"\"\"", "\n", "logger", ".", "info", "(", "\"setup model/optimizer/scheduler\"", ")", "\n", "model", ",", "criterion", "=", "build_model", "(", "opt", ")", "\n", "if", "opt", ".", "device", ".", "type", "==", "\"cuda\"", ":", "\n", "        ", "logger", ".", "info", "(", "\"CUDA enabled.\"", ")", "\n", "model", ".", "to", "(", "opt", ".", "device", ")", "\n", "criterion", ".", "to", "(", "opt", ".", "device", ")", "\n", "\n", "", "param_dicts", "=", "[", "{", "\"params\"", ":", "[", "p", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", "if", "p", ".", "requires_grad", "]", "}", "]", "\n", "optimizer", "=", "torch", ".", "optim", ".", "AdamW", "(", "param_dicts", ",", "lr", "=", "opt", ".", "lr", ",", "weight_decay", "=", "opt", ".", "wd", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "opt", ".", "lr_drop", ")", "\n", "\n", "if", "opt", ".", "resume", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Load checkpoint from {opt.resume}\"", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "opt", ".", "resume", ",", "map_location", "=", "\"cpu\"", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "\"model\"", "]", ")", "\n", "if", "opt", ".", "resume_all", ":", "\n", "            ", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "lr_scheduler", ".", "load_state_dict", "(", "checkpoint", "[", "'lr_scheduler'", "]", ")", "\n", "opt", ".", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "+", "1", "\n", "", "logger", ".", "info", "(", "f\"Loaded model saved at epoch {checkpoint['epoch']} from checkpoint: {opt.resume}\"", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "warning", "(", "\"If you intend to evaluate the model, please specify --resume with ckpt path\"", ")", "\n", "\n", "", "return", "model", ",", "criterion", ",", "optimizer", ",", "lr_scheduler", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.start_inference": [[220, 256], ["logger.info", "moment_detr.config.TestOptions().parse", "moment_detr.start_end_dataset.StartEndDataset", "inference.setup_model", "logger.info", "logger.info", "torch.no_grad", "torch.no_grad", "torch.no_grad", "inference.eval_epoch", "logger.info", "moment_detr.config.TestOptions", "pprint.pformat", "pprint.pformat"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.parse", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.setup_model", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.eval_epoch"], ["", "def", "start_inference", "(", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Setup config, data and model...\"", ")", "\n", "opt", "=", "TestOptions", "(", ")", ".", "parse", "(", ")", "\n", "cudnn", ".", "benchmark", "=", "True", "\n", "cudnn", ".", "deterministic", "=", "False", "\n", "\n", "assert", "opt", ".", "eval_path", "is", "not", "None", "\n", "eval_dataset", "=", "StartEndDataset", "(", "\n", "dset_name", "=", "opt", ".", "dset_name", ",", "\n", "data_path", "=", "opt", ".", "eval_path", ",", "\n", "v_feat_dirs", "=", "opt", ".", "v_feat_dirs", ",", "\n", "q_feat_dir", "=", "opt", ".", "t_feat_dir", ",", "\n", "q_feat_type", "=", "\"last_hidden_state\"", ",", "\n", "max_q_l", "=", "opt", ".", "max_q_l", ",", "\n", "max_v_l", "=", "opt", ".", "max_v_l", ",", "\n", "ctx_mode", "=", "opt", ".", "ctx_mode", ",", "\n", "data_ratio", "=", "opt", ".", "data_ratio", ",", "\n", "normalize_v", "=", "not", "opt", ".", "no_norm_vfeat", ",", "\n", "normalize_t", "=", "not", "opt", ".", "no_norm_tfeat", ",", "\n", "clip_len", "=", "opt", ".", "clip_length", ",", "\n", "max_windows", "=", "opt", ".", "max_windows", ",", "\n", "load_labels", "=", "True", ",", "# opt.eval_split_name == \"val\",", "\n", "span_loss_type", "=", "opt", ".", "span_loss_type", ",", "\n", "txt_drop_ratio", "=", "0", "\n", ")", "\n", "\n", "model", ",", "criterion", ",", "_", ",", "_", "=", "setup_model", "(", "opt", ")", "\n", "save_submission_filename", "=", "\"inference_{}_{}_{}_preds.jsonl\"", ".", "format", "(", "\n", "opt", ".", "dset_name", ",", "opt", ".", "eval_split_name", ",", "opt", ".", "eval_id", ")", "\n", "logger", ".", "info", "(", "\"Starting inference...\"", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "metrics_no_nms", ",", "metrics_nms", ",", "eval_loss_meters", ",", "latest_file_paths", "=", "eval_epoch", "(", "model", ",", "eval_dataset", ",", "opt", ",", "save_submission_filename", ",", "criterion", "=", "criterion", ")", "\n", "", "logger", ".", "info", "(", "\"metrics_no_nms {}\"", ".", "format", "(", "pprint", ".", "pformat", "(", "metrics_no_nms", "[", "\"brief\"", "]", ",", "indent", "=", "4", ")", ")", ")", "\n", "if", "metrics_nms", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "\"metrics_nms {}\"", ".", "format", "(", "pprint", ".", "pformat", "(", "metrics_nms", "[", "\"brief\"", "]", ",", "indent", "=", "4", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.set_seed": [[31, 37], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_seed", "(", "seed", ",", "use_cuda", "=", "True", ")", ":", "\n", "    ", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "if", "use_cuda", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train_epoch": [[39, 98], ["logger.info", "model.train", "criterion.train", "collections.defaultdict", "collections.defaultdict", "len", "time.time", "tqdm.tqdm", "tb_writer.add_scalar", "collections.defaultdict.items", "opt.train_log_txt_formatter.format", "logger.info", "collections.defaultdict.items", "enumerate", "time_meters[].update", "time.time", "moment_detr.start_end_dataset.prepare_batch_inputs", "time_meters[].update", "time.time", "model", "criterion", "sum", "time_meters[].update", "time.time", "optimizer.zero_grad", "sum.backward", "optimizer.step", "time_meters[].update", "float", "criterion.items", "time.time", "float", "tb_writer.add_scalar", "open", "f.write", "logger.info", "torch.utils.clip_grad_norm_", "loss_meters[].update", "time.strftime", "time.time", "time.time", "time.time", "model.parameters", "time.time", "criterion.keys", "float", "getattr", "float", "collections.defaultdict.items"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.prepare_batch_inputs", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["", "", "def", "train_epoch", "(", "model", ",", "criterion", ",", "train_loader", ",", "optimizer", ",", "opt", ",", "epoch_i", ",", "tb_writer", ")", ":", "\n", "    ", "logger", ".", "info", "(", "f\"[Epoch {epoch_i+1}]\"", ")", "\n", "model", ".", "train", "(", ")", "\n", "criterion", ".", "train", "(", ")", "\n", "\n", "# init meters", "\n", "time_meters", "=", "defaultdict", "(", "AverageMeter", ")", "\n", "loss_meters", "=", "defaultdict", "(", "AverageMeter", ")", "\n", "\n", "num_training_examples", "=", "len", "(", "train_loader", ")", "\n", "timer_dataloading", "=", "time", ".", "time", "(", ")", "\n", "for", "batch_idx", ",", "batch", "in", "tqdm", "(", "enumerate", "(", "train_loader", ")", ",", "\n", "desc", "=", "\"Training Iteration\"", ",", "\n", "total", "=", "num_training_examples", ")", ":", "\n", "        ", "time_meters", "[", "\"dataloading_time\"", "]", ".", "update", "(", "time", ".", "time", "(", ")", "-", "timer_dataloading", ")", "\n", "\n", "timer_start", "=", "time", ".", "time", "(", ")", "\n", "model_inputs", ",", "targets", "=", "prepare_batch_inputs", "(", "batch", "[", "1", "]", ",", "opt", ".", "device", ",", "non_blocking", "=", "opt", ".", "pin_memory", ")", "\n", "time_meters", "[", "\"prepare_inputs_time\"", "]", ".", "update", "(", "time", ".", "time", "(", ")", "-", "timer_start", ")", "\n", "\n", "timer_start", "=", "time", ".", "time", "(", ")", "\n", "outputs", "=", "model", "(", "**", "model_inputs", ")", "\n", "loss_dict", "=", "criterion", "(", "outputs", ",", "targets", ")", "\n", "weight_dict", "=", "criterion", ".", "weight_dict", "\n", "losses", "=", "sum", "(", "loss_dict", "[", "k", "]", "*", "weight_dict", "[", "k", "]", "for", "k", "in", "loss_dict", ".", "keys", "(", ")", "if", "k", "in", "weight_dict", ")", "\n", "time_meters", "[", "\"model_forward_time\"", "]", ".", "update", "(", "time", ".", "time", "(", ")", "-", "timer_start", ")", "\n", "\n", "timer_start", "=", "time", ".", "time", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "if", "opt", ".", "grad_clip", ">", "0", ":", "\n", "            ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "opt", ".", "grad_clip", ")", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "time_meters", "[", "\"model_backward_time\"", "]", ".", "update", "(", "time", ".", "time", "(", ")", "-", "timer_start", ")", "\n", "\n", "loss_dict", "[", "\"loss_overall\"", "]", "=", "float", "(", "losses", ")", "# for logging only", "\n", "for", "k", ",", "v", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "            ", "loss_meters", "[", "k", "]", ".", "update", "(", "float", "(", "v", ")", "*", "weight_dict", "[", "k", "]", "if", "k", "in", "weight_dict", "else", "float", "(", "v", ")", ")", "\n", "\n", "", "timer_dataloading", "=", "time", ".", "time", "(", ")", "\n", "if", "opt", ".", "debug", "and", "batch_idx", "==", "3", ":", "\n", "            ", "break", "\n", "\n", "# print/add logs", "\n", "", "", "tb_writer", ".", "add_scalar", "(", "\"Train/lr\"", ",", "float", "(", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ")", ",", "epoch_i", "+", "1", ")", "\n", "for", "k", ",", "v", "in", "loss_meters", ".", "items", "(", ")", ":", "\n", "        ", "tb_writer", ".", "add_scalar", "(", "\"Train/{}\"", ".", "format", "(", "k", ")", ",", "v", ".", "avg", ",", "epoch_i", "+", "1", ")", "\n", "\n", "", "to_write", "=", "opt", ".", "train_log_txt_formatter", ".", "format", "(", "\n", "time_str", "=", "time", ".", "strftime", "(", "\"%Y_%m_%d_%H_%M_%S\"", ")", ",", "\n", "epoch", "=", "epoch_i", "+", "1", ",", "\n", "loss_str", "=", "\" \"", ".", "join", "(", "[", "\"{} {:.4f}\"", ".", "format", "(", "k", ",", "v", ".", "avg", ")", "for", "k", ",", "v", "in", "loss_meters", ".", "items", "(", ")", "]", ")", ")", "\n", "with", "open", "(", "opt", ".", "train_log_filepath", ",", "\"a\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "to_write", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Epoch time stats:\"", ")", "\n", "for", "name", ",", "meter", "in", "time_meters", ".", "items", "(", ")", ":", "\n", "        ", "d", "=", "{", "k", ":", "f\"{getattr(meter, k):.4f}\"", "for", "k", "in", "[", "\"max\"", ",", "\"min\"", ",", "\"avg\"", "]", "}", "\n", "logger", ".", "info", "(", "f\"{name} ==> {d}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train": [[100, 204], ["torch.utils.tensorboard.SummaryWriter", "torch.utils.tensorboard.SummaryWriter.add_text", "torch.utils.data.DataLoader", "tqdm.trange", "torch.utils.tensorboard.SummaryWriter.close", "logger.info", "model.to", "utils.basic_utils.dict_to_markdown", "vars", "train.train_epoch", "lr_scheduler.step", "opt.eval_log_txt_formatter.format", "logger.info", "metrics[].items", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.no_grad", "torch.no_grad", "torch.no_grad", "moment_detr.inference.eval_epoch", "open", "f.write", "logger.info", "torch.utils.tensorboard.SummaryWriter.add_scalar", "torch.save", "torch.save", "torch.save", "zip", "logger.info", "model.state_dict", "optimizer.state_dict", "lr_scheduler.state_dict", "opt.ckpt_filepath.replace", "model.state_dict", "optimizer.state_dict", "opt.ckpt_filepath.replace", "time.strftime", "json.dumps", "pprint.pformat", "float", "model.state_dict", "optimizer.state_dict", "lr_scheduler.state_dict", "opt.ckpt_filepath.replace", "e.replace", "os.renames", "logger.info", "pprint.pformat", "open", "f.write", "eval_loss_meters.items"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.dict_to_markdown", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train_epoch", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.eval_epoch"], ["", "", "def", "train", "(", "model", ",", "criterion", ",", "optimizer", ",", "lr_scheduler", ",", "train_dataset", ",", "val_dataset", ",", "opt", ")", ":", "\n", "    ", "if", "opt", ".", "device", ".", "type", "==", "\"cuda\"", ":", "\n", "        ", "logger", ".", "info", "(", "\"CUDA enabled.\"", ")", "\n", "model", ".", "to", "(", "opt", ".", "device", ")", "\n", "\n", "", "tb_writer", "=", "SummaryWriter", "(", "opt", ".", "tensorboard_log_dir", ")", "\n", "tb_writer", ".", "add_text", "(", "\"hyperparameters\"", ",", "dict_to_markdown", "(", "vars", "(", "opt", ")", ",", "max_str_len", "=", "None", ")", ")", "\n", "opt", ".", "train_log_txt_formatter", "=", "\"{time_str} [Epoch] {epoch:03d} [Loss] {loss_str}\\n\"", "\n", "opt", ".", "eval_log_txt_formatter", "=", "\"{time_str} [Epoch] {epoch:03d} [Loss] {loss_str} [Metrics] {eval_metrics_str}\\n\"", "\n", "\n", "train_loader", "=", "DataLoader", "(", "\n", "train_dataset", ",", "\n", "collate_fn", "=", "start_end_collate", ",", "\n", "batch_size", "=", "opt", ".", "bsz", ",", "\n", "num_workers", "=", "opt", ".", "num_workers", ",", "\n", "shuffle", "=", "True", ",", "\n", "pin_memory", "=", "opt", ".", "pin_memory", "\n", ")", "\n", "\n", "prev_best_score", "=", "0.", "\n", "es_cnt", "=", "0", "\n", "# start_epoch = 0", "\n", "if", "opt", ".", "start_epoch", "is", "None", ":", "\n", "        ", "start_epoch", "=", "-", "1", "if", "opt", ".", "eval_untrained", "else", "0", "\n", "", "else", ":", "\n", "        ", "start_epoch", "=", "opt", ".", "start_epoch", "\n", "", "save_submission_filename", "=", "\"latest_{}_{}_preds.jsonl\"", ".", "format", "(", "opt", ".", "dset_name", ",", "opt", ".", "eval_split_name", ")", "\n", "for", "epoch_i", "in", "trange", "(", "start_epoch", ",", "opt", ".", "n_epoch", ",", "desc", "=", "\"Epoch\"", ")", ":", "\n", "        ", "if", "epoch_i", ">", "-", "1", ":", "\n", "            ", "train_epoch", "(", "model", ",", "criterion", ",", "train_loader", ",", "optimizer", ",", "opt", ",", "epoch_i", ",", "tb_writer", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "", "eval_epoch_interval", "=", "5", "\n", "if", "opt", ".", "eval_path", "is", "not", "None", "and", "(", "epoch_i", "+", "1", ")", "%", "eval_epoch_interval", "==", "0", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "metrics_no_nms", ",", "metrics_nms", ",", "eval_loss_meters", ",", "latest_file_paths", "=", "eval_epoch", "(", "model", ",", "val_dataset", ",", "opt", ",", "save_submission_filename", ",", "epoch_i", ",", "criterion", ",", "tb_writer", ")", "\n", "\n", "# log", "\n", "", "to_write", "=", "opt", ".", "eval_log_txt_formatter", ".", "format", "(", "\n", "time_str", "=", "time", ".", "strftime", "(", "\"%Y_%m_%d_%H_%M_%S\"", ")", ",", "\n", "epoch", "=", "epoch_i", ",", "\n", "loss_str", "=", "\" \"", ".", "join", "(", "[", "\"{} {:.4f}\"", ".", "format", "(", "k", ",", "v", ".", "avg", ")", "for", "k", ",", "v", "in", "eval_loss_meters", ".", "items", "(", ")", "]", ")", ",", "\n", "eval_metrics_str", "=", "json", ".", "dumps", "(", "metrics_no_nms", ")", ")", "\n", "\n", "with", "open", "(", "opt", ".", "eval_log_filepath", ",", "\"a\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "to_write", ")", "\n", "", "logger", ".", "info", "(", "\"metrics_no_nms {}\"", ".", "format", "(", "pprint", ".", "pformat", "(", "metrics_no_nms", "[", "\"brief\"", "]", ",", "indent", "=", "4", ")", ")", ")", "\n", "if", "metrics_nms", "is", "not", "None", ":", "\n", "                ", "logger", ".", "info", "(", "\"metrics_nms {}\"", ".", "format", "(", "pprint", ".", "pformat", "(", "metrics_nms", "[", "\"brief\"", "]", ",", "indent", "=", "4", ")", ")", ")", "\n", "\n", "", "metrics", "=", "metrics_no_nms", "\n", "for", "k", ",", "v", "in", "metrics", "[", "\"brief\"", "]", ".", "items", "(", ")", ":", "\n", "                ", "tb_writer", ".", "add_scalar", "(", "f\"Eval/{k}\"", ",", "float", "(", "v", ")", ",", "epoch_i", "+", "1", ")", "\n", "\n", "", "stop_score", "=", "metrics", "[", "\"brief\"", "]", "[", "\"MR-full-mAP\"", "]", "\n", "if", "stop_score", ">", "prev_best_score", ":", "\n", "                ", "es_cnt", "=", "0", "\n", "prev_best_score", "=", "stop_score", "\n", "\n", "checkpoint", "=", "{", "\n", "\"model\"", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "\"optimizer\"", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "\"lr_scheduler\"", ":", "lr_scheduler", ".", "state_dict", "(", ")", ",", "\n", "\"epoch\"", ":", "epoch_i", ",", "\n", "\"opt\"", ":", "opt", "\n", "}", "\n", "torch", ".", "save", "(", "checkpoint", ",", "opt", ".", "ckpt_filepath", ".", "replace", "(", "\".ckpt\"", ",", "\"_best.ckpt\"", ")", ")", "\n", "\n", "best_file_paths", "=", "[", "e", ".", "replace", "(", "\"latest\"", ",", "\"best\"", ")", "for", "e", "in", "latest_file_paths", "]", "\n", "for", "src", ",", "tgt", "in", "zip", "(", "latest_file_paths", ",", "best_file_paths", ")", ":", "\n", "                    ", "os", ".", "renames", "(", "src", ",", "tgt", ")", "\n", "", "logger", ".", "info", "(", "\"The checkpoint file has been updated.\"", ")", "\n", "", "else", ":", "\n", "                ", "es_cnt", "+=", "1", "\n", "if", "opt", ".", "max_es_cnt", "!=", "-", "1", "and", "es_cnt", ">", "opt", ".", "max_es_cnt", ":", "# early stop", "\n", "                    ", "with", "open", "(", "opt", ".", "train_log_filepath", ",", "\"a\"", ")", "as", "f", ":", "\n", "                        ", "f", ".", "write", "(", "f\"Early Stop at epoch {epoch_i}\"", ")", "\n", "", "logger", ".", "info", "(", "f\"\\n>>>>> Early stop at epoch {epoch_i}  {prev_best_score}\\n\"", ")", "\n", "break", "\n", "\n", "# save ckpt", "\n", "", "", "checkpoint", "=", "{", "\n", "\"model\"", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "\"optimizer\"", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "\"lr_scheduler\"", ":", "lr_scheduler", ".", "state_dict", "(", ")", ",", "\n", "\"epoch\"", ":", "epoch_i", ",", "\n", "\"opt\"", ":", "opt", "\n", "}", "\n", "torch", ".", "save", "(", "checkpoint", ",", "opt", ".", "ckpt_filepath", ".", "replace", "(", "\".ckpt\"", ",", "\"_latest.ckpt\"", ")", ")", "\n", "\n", "", "save_interval", "=", "10", "if", "\"subs_train\"", "in", "opt", ".", "train_path", "else", "50", "# smaller for pretrain", "\n", "if", "(", "epoch_i", "+", "1", ")", "%", "save_interval", "==", "0", "or", "(", "epoch_i", "+", "1", ")", "%", "opt", ".", "lr_drop", "==", "0", ":", "# additional copies", "\n", "            ", "checkpoint", "=", "{", "\n", "\"model\"", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "\"optimizer\"", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "\"epoch\"", ":", "epoch_i", ",", "\n", "\"opt\"", ":", "opt", "\n", "}", "\n", "torch", ".", "save", "(", "checkpoint", ",", "opt", ".", "ckpt_filepath", ".", "replace", "(", "\".ckpt\"", ",", "f\"_e{epoch_i:04d}.ckpt\"", ")", ")", "\n", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "break", "\n", "\n", "", "", "tb_writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.start_training": [[206, 252], ["logger.info", "moment_detr.config.BaseOptions().parse", "train.set_seed", "dict", "moment_detr.start_end_dataset.StartEndDataset", "moment_detr.inference.setup_model", "logger.info", "utils.model_utils.count_parameters", "logger.info", "train.train", "BaseOptions().parse.t_feat_dir.replace", "moment_detr.start_end_dataset.StartEndDataset", "BaseOptions().parse.ckpt_filepath.replace", "moment_detr.config.BaseOptions"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.config.BaseOptions.parse", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.set_seed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.inference.setup_model", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.model_utils.count_parameters", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.train.train"], ["", "def", "start_training", "(", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Setup config, data and model...\"", ")", "\n", "opt", "=", "BaseOptions", "(", ")", ".", "parse", "(", ")", "\n", "set_seed", "(", "opt", ".", "seed", ")", "\n", "if", "opt", ".", "debug", ":", "# keep the model run deterministically", "\n", "# 'cudnn.benchmark = True' enabled auto finding the best algorithm for a specific input/net config.", "\n", "# Enable this only when input size is fixed.", "\n", "        ", "cudnn", ".", "benchmark", "=", "False", "\n", "cudnn", ".", "deterministic", "=", "True", "\n", "\n", "", "dataset_config", "=", "dict", "(", "\n", "dset_name", "=", "opt", ".", "dset_name", ",", "\n", "data_path", "=", "opt", ".", "train_path", ",", "\n", "v_feat_dirs", "=", "opt", ".", "v_feat_dirs", ",", "\n", "q_feat_dir", "=", "opt", ".", "t_feat_dir", ",", "\n", "q_feat_type", "=", "\"last_hidden_state\"", ",", "\n", "max_q_l", "=", "opt", ".", "max_q_l", ",", "\n", "max_v_l", "=", "opt", ".", "max_v_l", ",", "\n", "ctx_mode", "=", "opt", ".", "ctx_mode", ",", "\n", "data_ratio", "=", "opt", ".", "data_ratio", ",", "\n", "normalize_v", "=", "not", "opt", ".", "no_norm_vfeat", ",", "\n", "normalize_t", "=", "not", "opt", ".", "no_norm_tfeat", ",", "\n", "clip_len", "=", "opt", ".", "clip_length", ",", "\n", "max_windows", "=", "opt", ".", "max_windows", ",", "\n", "span_loss_type", "=", "opt", ".", "span_loss_type", ",", "\n", "txt_drop_ratio", "=", "opt", ".", "txt_drop_ratio", "\n", ")", "\n", "\n", "dataset_config", "[", "\"data_path\"", "]", "=", "opt", ".", "train_path", "\n", "train_dataset", "=", "StartEndDataset", "(", "**", "dataset_config", ")", "\n", "\n", "if", "opt", ".", "eval_path", "is", "not", "None", ":", "\n", "        ", "dataset_config", "[", "\"data_path\"", "]", "=", "opt", ".", "eval_path", "\n", "dataset_config", "[", "\"txt_drop_ratio\"", "]", "=", "0", "\n", "dataset_config", "[", "\"q_feat_dir\"", "]", "=", "opt", ".", "t_feat_dir", ".", "replace", "(", "\"sub_features\"", ",", "\"text_features\"", ")", "# for pretraining", "\n", "# dataset_config[\"load_labels\"] = False  # uncomment to calculate eval loss", "\n", "eval_dataset", "=", "StartEndDataset", "(", "**", "dataset_config", ")", "\n", "", "else", ":", "\n", "        ", "eval_dataset", "=", "None", "\n", "\n", "", "model", ",", "criterion", ",", "optimizer", ",", "lr_scheduler", "=", "setup_model", "(", "opt", ")", "\n", "logger", ".", "info", "(", "f\"Model {model}\"", ")", "\n", "count_parameters", "(", "model", ")", "\n", "logger", ".", "info", "(", "\"Start Training...\"", ")", "\n", "train", "(", "model", ",", "criterion", ",", "optimizer", ",", "lr_scheduler", ",", "train_dataset", ",", "eval_dataset", ",", "opt", ")", "\n", "return", "opt", ".", "ckpt_filepath", ".", "replace", "(", "\".ckpt\"", ",", "\"_best.ckpt\"", ")", ",", "opt", ".", "eval_split_name", ",", "opt", ".", "eval_path", ",", "opt", ".", "debug", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.MomentDETR.__init__": [[20, 79], ["torch.nn.Module.__init__", "model.MLP", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "model.LinearLayer", "model.LinearLayer", "model.LinearLayer", "model.LinearLayer", "model.LinearLayer", "model.LinearLayer"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "stride", ")", "if", "stride", ">", "1", "else", "nn", ".", "Identity", "(", ")", "\n", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "None", "\n", "self", ".", "stride", "=", "stride", "\n", "\n", "if", "stride", ">", "1", "or", "inplanes", "!=", "planes", "*", "Bottleneck", ".", "expansion", ":", "\n", "# downsampling layer is prepended with an avgpool, and the subsequent convolution has stride 1", "\n", "            ", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"-1\"", ",", "nn", ".", "AvgPool2d", "(", "stride", ")", ")", ",", "\n", "(", "\"0\"", ",", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", "*", "self", ".", "expansion", ",", "1", ",", "stride", "=", "1", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "\"1\"", ",", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", ")", "\n", "]", ")", ")", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "avgpool", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "out", ")", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "AttentionPool2d", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "spacial_dim", ":", "int", ",", "embed_dim", ":", "int", ",", "num_heads", ":", "int", ",", "output_dim", ":", "int", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "spacial_dim", "**", "2", "+", "1", ",", "embed_dim", ")", "/", "embed_dim", "**", "0.5", ")", "\n", "self", ".", "k_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "q_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "v_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", "self", ".", "c_proj", "=", "nn", ".", "Linear", "(", "embed_dim", ",", "output_dim", "or", "embed_dim", ")", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# NCHW -> (HW)NC", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ".", "mean", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ",", "x", "]", ",", "dim", "=", "0", ")", "# (HW+1)NC", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", "[", ":", ",", "None", ",", ":", "]", ".", "to", "(", "x", ".", "dtype", ")", "# (HW+1)NC", "\n", "x", ",", "_", "=", "F", ".", "multi_head_attention_forward", "(", "\n", "query", "=", "x", ",", "key", "=", "x", ",", "value", "=", "x", ",", "\n", "embed_dim_to_check", "=", "x", ".", "shape", "[", "-", "1", "]", ",", "\n", "num_heads", "=", "self", ".", "num_heads", ",", "\n", "q_proj_weight", "=", "self", ".", "q_proj", ".", "weight", ",", "\n", "k_proj_weight", "=", "self", ".", "k_proj", ".", "weight", ",", "\n", "v_proj_weight", "=", "self", ".", "v_proj", ".", "weight", ",", "\n", "in_proj_weight", "=", "None", ",", "\n", "in_proj_bias", "=", "torch", ".", "cat", "(", "[", "self", ".", "q_proj", ".", "bias", ",", "self", ".", "k_proj", ".", "bias", ",", "self", ".", "v_proj", ".", "bias", "]", ")", ",", "\n", "bias_k", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.MomentDETR.forward": [[80, 138], ["model.MomentDETR.input_vid_proj", "model.MomentDETR.input_txt_proj", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().bool", "torch.cat().bool", "torch.cat().bool", "torch.cat().bool", "model.MomentDETR.position_embed", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.MomentDETR.transformer", "model.MomentDETR.class_embed", "model.MomentDETR.span_embed", "model.MomentDETR.saliency_proj().squeeze", "model.MomentDETR.txt_position_embed", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "outputs_coord.sigmoid.sigmoid.sigmoid", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "out.update", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.MomentDETR.contrastive_align_projection_query", "model.MomentDETR.contrastive_align_projection_txt", "model.MomentDETR.contrastive_align_projection_vid", "dict", "model.MomentDETR.saliency_proj", "enumerate", "zip", "[].update", "dict"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["bias_v", "=", "None", ",", "\n", "add_zero_attn", "=", "False", ",", "\n", "dropout_p", "=", "0", ",", "\n", "out_proj_weight", "=", "self", ".", "c_proj", ".", "weight", ",", "\n", "out_proj_bias", "=", "self", ".", "c_proj", ".", "bias", ",", "\n", "use_separate_proj_weight", "=", "True", ",", "\n", "training", "=", "self", ".", "training", ",", "\n", "need_weights", "=", "False", "\n", ")", "\n", "\n", "return", "x", "[", "0", "]", "\n", "\n", "\n", "", "", "class", "ModifiedResNet", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A ResNet class that is similar to torchvision's but contains the following changes:\n    - There are now 3 \"stem\" convolutions as opposed to 1, with an average pool instead of a max pool.\n    - Performs anti-aliasing strided convolutions, where an avgpool is prepended to convolutions with stride > 1\n    - The final pooling layer is a QKV attention instead of an average pool\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "layers", ",", "output_dim", ",", "heads", ",", "input_resolution", "=", "224", ",", "width", "=", "64", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "\n", "# the 3-layer stem", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "width", "//", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "width", "//", "2", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "width", "//", "2", ",", "width", "//", "2", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "width", "//", "2", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "width", "//", "2", ",", "width", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "width", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "2", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# residual layers", "\n", "self", ".", "_inplanes", "=", "width", "# this is a *mutable* variable used during construction", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "width", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "width", "*", "2", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "width", "*", "4", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "width", "*", "8", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "\n", "embed_dim", "=", "width", "*", "32", "# the ResNet feature dimension", "\n", "self", ".", "attnpool", "=", "AttentionPool2d", "(", "input_resolution", "//", "32", ",", "embed_dim", ",", "heads", ",", "output_dim", ")", "\n", "\n", "", "def", "_make_layer", "(", "self", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "Bottleneck", "(", "self", ".", "_inplanes", ",", "planes", ",", "stride", ")", "]", "\n", "\n", "self", ".", "_inplanes", "=", "planes", "*", "Bottleneck", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "Bottleneck", "(", "self", ".", "_inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "def", "stem", "(", "x", ")", ":", "\n", "            ", "for", "conv", ",", "bn", "in", "[", "(", "self", ".", "conv1", ",", "self", ".", "bn1", ")", ",", "(", "self", ".", "conv2", ",", "self", ".", "bn2", ")", ",", "(", "self", ".", "conv3", ",", "self", ".", "bn3", ")", "]", ":", "\n", "                ", "x", "=", "self", ".", "relu", "(", "bn", "(", "conv", "(", "x", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.__init__": [[155, 184], ["torch.nn.Module.__init__", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "model.SetCriterion.register_buffer"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["\n", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "orig_type", "=", "x", ".", "dtype", "\n", "ret", "=", "super", "(", ")", ".", "forward", "(", "x", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "return", "ret", ".", "type", "(", "orig_type", ")", "\n", "\n", "\n", "", "", "class", "QuickGELU", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "x", "*", "torch", ".", "sigmoid", "(", "1.702", "*", "x", ")", "\n", "\n", "\n", "", "", "class", "ResidualAttentionBlock", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "d_model", ":", "int", ",", "n_head", ":", "int", ",", "attn_mask", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "n_head", ")", "\n", "self", ".", "ln_1", "=", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"c_fc\"", ",", "nn", ".", "Linear", "(", "d_model", ",", "d_model", "*", "4", ")", ")", ",", "\n", "(", "\"gelu\"", ",", "QuickGELU", "(", ")", ")", ",", "\n", "(", "\"c_proj\"", ",", "nn", ".", "Linear", "(", "d_model", "*", "4", ",", "d_model", ")", ")", "\n", "]", ")", ")", "\n", "self", ".", "ln_2", "=", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "attn_mask", "=", "attn_mask", "\n", "\n", "", "def", "attention", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "self", ".", "attn_mask", "=", "self", ".", "attn_mask", ".", "to", "(", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "if", "self", ".", "attn_mask", "is", "not", "None", "else", "None", "\n", "return", "self", ".", "attn", "(", "x", ",", "x", ",", "x", ",", "need_weights", "=", "False", ",", "attn_mask", "=", "self", ".", "attn_mask", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.loss_spans": [[185, 216], ["model.SetCriterion._get_src_permutation_idx", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cross_entropy.mean", "F.cross_entropy.new_zeros.mean", "torch.l1_loss", "torch.l1_loss", "src_spans.view().transpose.view().transpose.view().transpose", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy.new_zeros", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "zip", "moment_detr.span_utils.generalized_temporal_iou", "src_spans.view().transpose.view().transpose.view", "moment_detr.span_utils.span_cxw_to_xx", "moment_detr.span_utils.span_cxw_to_xx"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_src_permutation_idx", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.generalized_temporal_iou", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_cxw_to_xx"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "x", "=", "x", "+", "self", ".", "attention", "(", "self", ".", "ln_1", "(", "x", ")", ")", "\n", "x", "=", "x", "+", "self", ".", "mlp", "(", "self", ".", "ln_2", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n", "\n", "", "", "class", "Transformer", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "width", ":", "int", ",", "layers", ":", "int", ",", "heads", ":", "int", ",", "attn_mask", ":", "torch", ".", "Tensor", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "resblocks", "=", "nn", ".", "Sequential", "(", "*", "[", "ResidualAttentionBlock", "(", "width", ",", "heads", ",", "attn_mask", ")", "for", "_", "in", "range", "(", "layers", ")", "]", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "self", ".", "resblocks", "(", "x", ")", "\n", "\n", "\n", "", "", "class", "VisualTransformer", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "input_resolution", ":", "int", ",", "patch_size", ":", "int", ",", "width", ":", "int", ",", "layers", ":", "int", ",", "heads", ":", "int", ",", "output_dim", ":", "int", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "3", ",", "out_channels", "=", "width", ",", "kernel_size", "=", "patch_size", ",", "stride", "=", "patch_size", ",", "bias", "=", "False", ")", "\n", "\n", "scale", "=", "width", "**", "-", "0.5", "\n", "self", ".", "class_embedding", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "width", ")", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "(", "input_resolution", "//", "patch_size", ")", "**", "2", "+", "1", ",", "width", ")", ")", "\n", "self", ".", "ln_pre", "=", "LayerNorm", "(", "width", ")", "\n", "\n", "self", ".", "transformer", "=", "Transformer", "(", "width", ",", "layers", ",", "heads", ")", "\n", "\n", "self", ".", "ln_post", "=", "LayerNorm", "(", "width", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.loss_labels": [[217, 237], ["model.SetCriterion._get_src_permutation_idx", "torch.full", "torch.full", "torch.full", "torch.full", "torch.cross_entropy", "torch.cross_entropy", "src_logits.transpose", "torch.cross_entropy.mean", "moment_detr.misc.accuracy"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_src_permutation_idx", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.misc.accuracy"], ["self", ".", "proj", "=", "nn", ".", "Parameter", "(", "scale", "*", "torch", ".", "randn", "(", "width", ",", "output_dim", ")", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "# shape = [*, width, grid, grid]", "\n", "x", "=", "x", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "# shape = [*, width, grid ** 2]", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# shape = [*, grid ** 2, width]", "\n", "x", "=", "torch", ".", "cat", "(", "[", "self", ".", "class_embedding", ".", "to", "(", "x", ".", "dtype", ")", "+", "torch", ".", "zeros", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "x", ".", "shape", "[", "-", "1", "]", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", ",", "x", "]", ",", "dim", "=", "1", ")", "# shape = [*, grid ** 2 + 1, width]", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", ".", "to", "(", "x", ".", "dtype", ")", "\n", "x", "=", "self", ".", "ln_pre", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# NLD -> LND", "\n", "x", "=", "self", ".", "transformer", "(", "x", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# LND -> NLD", "\n", "\n", "x", "=", "self", ".", "ln_post", "(", "x", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "\n", "if", "self", ".", "proj", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", "@", "self", ".", "proj", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.loss_saliency": [[238, 254], ["torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.arange().to", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.clamp().sum", "torch.clamp().sum", "torch.clamp().sum", "torch.clamp().sum", "len", "range", "range", "len", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["None"], ["\n", "", "", "class", "CLIP", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "\n", "embed_dim", ":", "int", ",", "\n", "# vision", "\n", "image_resolution", ":", "int", ",", "\n", "vision_layers", ":", "Union", "[", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", "]", ",", "int", "]", ",", "\n", "vision_width", ":", "int", ",", "\n", "vision_patch_size", ":", "int", ",", "\n", "# text", "\n", "context_length", ":", "int", ",", "\n", "vocab_size", ":", "int", ",", "\n", "transformer_width", ":", "int", ",", "\n", "transformer_heads", ":", "int", ",", "\n", "transformer_layers", ":", "int", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.loss_contrastive_align": [[255, 273], ["torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "model.SetCriterion._get_src_permutation_idx", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.einsum.masked_fill", "torch.einsum.masked_fill", "torch.einsum.masked_fill.sum", "torch.zeros_like.sum", "torch.zeros_like.sum", "torch.einsum.logsumexp", "torch.einsum.logsumexp", "torch.einsum.sum", "torch.einsum.sum", "loss_nce.mean"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_src_permutation_idx"], ["\n", "self", ".", "context_length", "=", "context_length", "\n", "\n", "if", "isinstance", "(", "vision_layers", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "vision_heads", "=", "vision_width", "*", "32", "//", "64", "\n", "self", ".", "visual", "=", "ModifiedResNet", "(", "\n", "layers", "=", "vision_layers", ",", "\n", "output_dim", "=", "embed_dim", ",", "\n", "heads", "=", "vision_heads", ",", "\n", "input_resolution", "=", "image_resolution", ",", "\n", "width", "=", "vision_width", "\n", ")", "\n", "", "else", ":", "\n", "            ", "vision_heads", "=", "vision_width", "//", "64", "\n", "self", ".", "visual", "=", "VisualTransformer", "(", "\n", "input_resolution", "=", "image_resolution", ",", "\n", "patch_size", "=", "vision_patch_size", ",", "\n", "width", "=", "vision_width", ",", "\n", "layers", "=", "vision_layers", ",", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.loss_contrastive_align_vid_txt": [[274, 294], ["torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "model.SetCriterion._get_src_permutation_idx", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.einsum.masked_fill", "torch.einsum.masked_fill", "torch.einsum.masked_fill.sum", "torch.zeros_like.sum", "torch.zeros_like.sum", "torch.einsum.logsumexp", "torch.einsum.logsumexp", "torch.einsum.sum", "torch.einsum.sum", "loss_nce.mean"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_src_permutation_idx"], ["heads", "=", "vision_heads", ",", "\n", "output_dim", "=", "embed_dim", "\n", ")", "\n", "\n", "", "self", ".", "transformer", "=", "Transformer", "(", "\n", "width", "=", "transformer_width", ",", "\n", "layers", "=", "transformer_layers", ",", "\n", "heads", "=", "transformer_heads", ",", "\n", "attn_mask", "=", "self", ".", "build_attention_mask", "(", ")", "\n", ")", "\n", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "token_embedding", "=", "nn", ".", "Embedding", "(", "vocab_size", ",", "transformer_width", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "self", ".", "context_length", ",", "transformer_width", ")", ")", "\n", "self", ".", "ln_final", "=", "LayerNorm", "(", "transformer_width", ")", "\n", "\n", "self", ".", "text_projection", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "transformer_width", ",", "embed_dim", ")", ")", "\n", "self", ".", "logit_scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "[", "]", ")", "*", "np", ".", "log", "(", "1", "/", "0.07", ")", ")", "\n", "\n", "self", ".", "initialize_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_src_permutation_idx": [[295, 300], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["", "def", "initialize_parameters", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "token_embedding", ".", "weight", ",", "std", "=", "0.02", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "positional_embedding", ",", "std", "=", "0.01", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "visual", ",", "ModifiedResNet", ")", ":", "\n", "            ", "if", "self", ".", "visual", ".", "attnpool", "is", "not", "None", ":", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion._get_tgt_permutation_idx": [[301, 306], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["                ", "std", "=", "self", ".", "visual", ".", "attnpool", ".", "c_proj", ".", "in_features", "**", "-", "0.5", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "q_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "k_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "v_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "visual", ".", "attnpool", ".", "c_proj", ".", "weight", ",", "std", "=", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.get_loss": [[307, 316], ["None"], "methods", ["None"], ["", "for", "resnet_block", "in", "[", "self", ".", "visual", ".", "layer1", ",", "self", ".", "visual", ".", "layer2", ",", "self", ".", "visual", ".", "layer3", ",", "self", ".", "visual", ".", "layer4", "]", ":", "\n", "                ", "for", "name", ",", "param", "in", "resnet_block", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "name", ".", "endswith", "(", "\"bn3.weight\"", ")", ":", "\n", "                        ", "nn", ".", "init", ".", "zeros_", "(", "param", ")", "\n", "\n", "", "", "", "", "proj_std", "=", "(", "self", ".", "transformer", ".", "width", "**", "-", "0.5", ")", "*", "(", "(", "2", "*", "self", ".", "transformer", ".", "layers", ")", "**", "-", "0.5", ")", "\n", "attn_std", "=", "self", ".", "transformer", ".", "width", "**", "-", "0.5", "\n", "fc_std", "=", "(", "2", "*", "self", ".", "transformer", ".", "width", ")", "**", "-", "0.5", "\n", "for", "block", "in", "self", ".", "transformer", ".", "resblocks", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "block", ".", "attn", ".", "in_proj_weight", ",", "std", "=", "attn_std", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.forward": [[317, 348], ["model.SetCriterion.matcher", "losses.update", "enumerate", "outputs.items", "model.SetCriterion.get_loss", "model.SetCriterion.matcher", "model.SetCriterion.get_loss", "losses.update", "model.SetCriterion.items"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.get_loss", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.SetCriterion.get_loss", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["nn", ".", "init", ".", "normal_", "(", "block", ".", "attn", ".", "out_proj", ".", "weight", ",", "std", "=", "proj_std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "block", ".", "mlp", ".", "c_fc", ".", "weight", ",", "std", "=", "fc_std", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "block", ".", "mlp", ".", "c_proj", ".", "weight", ",", "std", "=", "proj_std", ")", "\n", "\n", "", "if", "self", ".", "text_projection", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "text_projection", ",", "std", "=", "self", ".", "transformer", ".", "width", "**", "-", "0.5", ")", "\n", "\n", "", "", "def", "build_attention_mask", "(", "self", ")", ":", "\n", "# lazily create causal attention mask, with full attention between the vision tokens", "\n", "# pytorch uses additive attention mask; fill with -inf", "\n", "        ", "mask", "=", "torch", ".", "empty", "(", "self", ".", "context_length", ",", "self", ".", "context_length", ")", "\n", "mask", ".", "fill_", "(", "float", "(", "\"-inf\"", ")", ")", "\n", "mask", ".", "triu_", "(", "1", ")", "# zero out the lower diagonal", "\n", "return", "mask", "\n", "\n", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "visual", ".", "conv1", ".", "weight", ".", "dtype", "\n", "\n", "", "def", "encode_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "return", "self", ".", "visual", "(", "image", ".", "type", "(", "self", ".", "dtype", ")", ")", "\n", "\n", "", "def", "encode_text", "(", "self", ",", "text", ")", ":", "\n", "        ", "x", "=", "self", ".", "token_embedding", "(", "text", ")", ".", "type", "(", "self", ".", "dtype", ")", "# [batch_size, n_ctx, d_model]", "\n", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", ".", "type", "(", "self", ".", "dtype", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# NLD -> LND", "\n", "x", "=", "self", ".", "transformer", "(", "x", ")", "\n", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# LND -> NLD", "\n", "x", "=", "self", ".", "ln_final", "(", "x", ")", ".", "type", "(", "self", ".", "dtype", ")", "\n", "\n", "# x.shape = [batch_size, n_ctx, transformer.width]", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.MLP.__init__": [[353, 358], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "zip"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["\n", "", "def", "forward", "(", "self", ",", "image", ",", "text", ")", ":", "\n", "        ", "image_features", "=", "self", ".", "encode_image", "(", "image", ")", "\n", "text_features", "=", "self", ".", "encode_text", "(", "text", ")", "\n", "\n", "# normalized features", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.MLP.forward": [[359, 363], ["enumerate", "torch.relu", "torch.relu", "layer", "layer"], "methods", ["None"], ["image_features", "=", "image_features", "/", "image_features", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "text_features", "=", "text_features", "/", "text_features", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "# cosine similarity as logits", "\n", "logit_scale", "=", "self", ".", "logit_scale", ".", "exp", "(", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.LinearLayer.__init__": [[368, 379], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["return", "logits_per_image", ",", "logits_per_text", "\n", "\n", "\n", "", "", "def", "convert_weights", "(", "model", ":", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"Convert applicable model parameters to fp16\"\"\"", "\n", "\n", "def", "_convert_weights_to_fp16", "(", "l", ")", ":", "\n", "        ", "if", "isinstance", "(", "l", ",", "(", "nn", ".", "Conv1d", ",", "nn", ".", "Conv2d", ",", "nn", ".", "Linear", ")", ")", ":", "\n", "            ", "l", ".", "weight", ".", "data", "=", "l", ".", "weight", ".", "data", ".", "half", "(", ")", "\n", "if", "l", ".", "bias", "is", "not", "None", ":", "\n", "                ", "l", ".", "bias", ".", "data", "=", "l", ".", "bias", ".", "data", ".", "half", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.LinearLayer.forward": [[380, 388], ["model.LinearLayer.net", "model.LinearLayer.LayerNorm", "torch.relu", "torch.relu"], "methods", ["None"], ["", "", "if", "isinstance", "(", "l", ",", "nn", ".", "MultiheadAttention", ")", ":", "\n", "            ", "for", "attr", "in", "[", "*", "[", "f\"{s}_proj_weight\"", "for", "s", "in", "[", "\"in\"", ",", "\"q\"", ",", "\"k\"", ",", "\"v\"", "]", "]", ",", "\"in_proj_bias\"", ",", "\"bias_k\"", ",", "\"bias_v\"", "]", ":", "\n", "                ", "tensor", "=", "getattr", "(", "l", ",", "attr", ")", "\n", "if", "tensor", "is", "not", "None", ":", "\n", "                    ", "tensor", ".", "data", "=", "tensor", ".", "data", ".", "half", "(", ")", "\n", "\n", "", "", "", "for", "name", "in", "[", "\"text_projection\"", ",", "\"proj\"", "]", ":", "\n", "            ", "if", "hasattr", "(", "l", ",", "name", ")", ":", "\n", "                ", "attr", "=", "getattr", "(", "l", ",", "name", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.model.build_model": [[390, 445], ["torch.device", "torch.device", "moment_detr.transformer.build_transformer", "moment_detr.position_encoding.build_position_encoding", "model.MomentDETR", "moment_detr.matcher.build_matcher", "model.SetCriterion", "SetCriterion.to", "range", "weight_dict.update", "aux_weight_dict.update", "weight_dict.items"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.build_transformer", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.build_position_encoding", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.matcher.build_matcher", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.AverageMeter.update"], ["                    ", "attr", ".", "data", "=", "attr", ".", "data", ".", "half", "(", ")", "\n", "\n", "", "", "", "", "model", ".", "apply", "(", "_convert_weights_to_fp16", ")", "\n", "\n", "\n", "", "def", "build_model", "(", "state_dict", ":", "dict", ")", ":", "\n", "    ", "vit", "=", "\"visual.proj\"", "in", "state_dict", "\n", "\n", "if", "vit", ":", "\n", "        ", "vision_width", "=", "state_dict", "[", "\"visual.conv1.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "vision_layers", "=", "len", "(", "[", "k", "for", "k", "in", "state_dict", ".", "keys", "(", ")", "if", "k", ".", "startswith", "(", "\"visual.\"", ")", "and", "k", ".", "endswith", "(", "\".attn.in_proj_weight\"", ")", "]", ")", "\n", "vision_patch_size", "=", "state_dict", "[", "\"visual.conv1.weight\"", "]", ".", "shape", "[", "-", "1", "]", "\n", "grid_size", "=", "round", "(", "(", "state_dict", "[", "\"visual.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "**", "0.5", ")", "\n", "image_resolution", "=", "vision_patch_size", "*", "grid_size", "\n", "", "else", ":", "\n", "        ", "counts", ":", "list", "=", "[", "len", "(", "set", "(", "k", ".", "split", "(", "\".\"", ")", "[", "2", "]", "for", "k", "in", "state_dict", "if", "k", ".", "startswith", "(", "f\"visual.layer{b}\"", ")", ")", ")", "for", "b", "in", "[", "1", ",", "2", ",", "3", ",", "4", "]", "]", "\n", "vision_layers", "=", "tuple", "(", "counts", ")", "\n", "vision_width", "=", "state_dict", "[", "\"visual.layer1.0.conv1.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "output_width", "=", "round", "(", "(", "state_dict", "[", "\"visual.attnpool.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "**", "0.5", ")", "\n", "vision_patch_size", "=", "None", "\n", "assert", "output_width", "**", "2", "+", "1", "==", "state_dict", "[", "\"visual.attnpool.positional_embedding\"", "]", ".", "shape", "[", "0", "]", "\n", "image_resolution", "=", "output_width", "*", "32", "\n", "\n", "", "embed_dim", "=", "state_dict", "[", "\"text_projection\"", "]", ".", "shape", "[", "1", "]", "\n", "context_length", "=", "state_dict", "[", "\"positional_embedding\"", "]", ".", "shape", "[", "0", "]", "\n", "vocab_size", "=", "state_dict", "[", "\"token_embedding.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "transformer_width", "=", "state_dict", "[", "\"ln_final.weight\"", "]", ".", "shape", "[", "0", "]", "\n", "transformer_heads", "=", "transformer_width", "//", "64", "\n", "transformer_layers", "=", "len", "(", "set", "(", "k", ".", "split", "(", "\".\"", ")", "[", "2", "]", "for", "k", "in", "state_dict", "if", "k", ".", "startswith", "(", "f\"transformer.resblocks\"", ")", ")", ")", "\n", "\n", "model", "=", "CLIP", "(", "\n", "embed_dim", ",", "\n", "image_resolution", ",", "vision_layers", ",", "vision_width", ",", "vision_patch_size", ",", "\n", "context_length", ",", "vocab_size", ",", "transformer_width", ",", "transformer_heads", ",", "transformer_layers", "\n", ")", "\n", "\n", "for", "key", "in", "[", "\"input_resolution\"", ",", "\"context_length\"", ",", "\"vocab_size\"", "]", ":", "\n", "        ", "if", "key", "in", "state_dict", ":", "\n", "            ", "del", "state_dict", "[", "key", "]", "\n", "\n", "", "", "convert_weights", "(", "model", ")", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "model", ".", "eval", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.misc.accuracy": [[4, 22], ["torch.no_grad", "max", "output.size", "output.topk", "pred.t.t", "pred.t.eq", "correct[].view().float().sum", "res.append", "correct[].view().float().sum.mul_", "correct[].view().float", "correct[].view"], "function", ["None"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "accuracy", "(", "output", ",", "target", ",", "topk", "=", "(", "1", ",", ")", ")", ":", "\n", "    ", "\"\"\"Computes the precision@k for the specified values of k\n    output: (#items, #classes)\n    target: int,\n    \"\"\"", "\n", "maxk", "=", "max", "(", "topk", ")", "\n", "num_items", "=", "output", ".", "size", "(", "0", ")", "\n", "\n", "_", ",", "pred", "=", "output", ".", "topk", "(", "maxk", ",", "1", ",", "True", ",", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ")", "\n", "\n", "res", "=", "[", "]", "\n", "for", "k", "in", "topk", ":", "\n", "        ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ")", "\n", "res", ".", "append", "(", "correct_k", ".", "mul_", "(", "100.0", "/", "num_items", ")", ")", "\n", "", "return", "res", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.__init__": [[10, 24], ["dict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "clip_length", "=", "2", ",", "min_ts_val", "=", "0", ",", "max_ts_val", "=", "150", ",", "\n", "min_w_l", "=", "2", ",", "max_w_l", "=", "70", ",", "move_window_method", "=", "\"center\"", ",", "\n", "process_func_names", "=", "(", "\"clip_window_l\"", ",", "\"clip_ts\"", ",", "\"round_multiple\"", ")", ")", ":", "\n", "        ", "self", ".", "clip_length", "=", "clip_length", "\n", "self", ".", "min_ts_val", "=", "min_ts_val", "\n", "self", ".", "max_ts_val", "=", "max_ts_val", "\n", "self", ".", "min_w_l", "=", "min_w_l", "\n", "self", ".", "max_w_l", "=", "max_w_l", "\n", "self", ".", "move_window_method", "=", "move_window_method", "\n", "self", ".", "process_func_names", "=", "process_func_names", "\n", "self", ".", "name2func", "=", "dict", "(", "\n", "clip_ts", "=", "self", ".", "clip_min_max_timestamps", ",", "\n", "round_multiple", "=", "self", ".", "round_to_multiple_clip_lengths", ",", "\n", "clip_window_l", "=", "self", ".", "clip_window_lengths", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.__call__": [[26, 38], ["tqdm.tqdm.tqdm", "torch.tensor", "torch.cat().tolist", "processed_lines.append", "torch.cat", "float"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "lines", ")", ":", "\n", "        ", "processed_lines", "=", "[", "]", "\n", "for", "line", "in", "tqdm", "(", "lines", ",", "desc", "=", "f\"convert to multiples of clip_length={self.clip_length}\"", ")", ":", "\n", "            ", "windows_and_scores", "=", "torch", ".", "tensor", "(", "line", "[", "\"pred_relevant_windows\"", "]", ")", "\n", "windows", "=", "windows_and_scores", "[", ":", ",", ":", "2", "]", "\n", "for", "func_name", "in", "self", ".", "process_func_names", ":", "\n", "                ", "windows", "=", "self", ".", "name2func", "[", "func_name", "]", "(", "windows", ")", "\n", "", "line", "[", "\"pred_relevant_windows\"", "]", "=", "torch", ".", "cat", "(", "\n", "[", "windows", ",", "windows_and_scores", "[", ":", ",", "2", ":", "3", "]", "]", ",", "dim", "=", "1", ")", ".", "tolist", "(", ")", "\n", "line", "[", "\"pred_relevant_windows\"", "]", "=", "[", "e", "[", ":", "2", "]", "+", "[", "float", "(", "f\"{e[2]:.4f}\"", ")", "]", "for", "e", "in", "line", "[", "\"pred_relevant_windows\"", "]", "]", "\n", "processed_lines", ".", "append", "(", "line", ")", "\n", "", "return", "processed_lines", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.clip_min_max_timestamps": [[39, 45], ["torch.clamp"], "methods", ["None"], ["", "def", "clip_min_max_timestamps", "(", "self", ",", "windows", ")", ":", "\n", "        ", "\"\"\"\n        windows: (#windows, 2)  torch.Tensor\n        ensure timestamps for all windows is within [min_val, max_val], clip is out of boundaries.\n        \"\"\"", "\n", "return", "torch", ".", "clamp", "(", "windows", ",", "min", "=", "self", ".", "min_ts_val", ",", "max", "=", "self", ".", "max_ts_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.round_to_multiple_clip_lengths": [[46, 52], ["torch.round"], "methods", ["None"], ["", "def", "round_to_multiple_clip_lengths", "(", "self", ",", "windows", ")", ":", "\n", "        ", "\"\"\"\n        windows: (#windows, 2)  torch.Tensor\n        ensure the final window timestamps are multiples of `clip_length`\n        \"\"\"", "\n", "return", "torch", ".", "round", "(", "windows", "/", "self", ".", "clip_length", ")", "*", "self", ".", "clip_length", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.clip_window_lengths": [[53, 68], ["torch.sum", "postprocessing_moment_detr.PostProcessorDETR.move_windows", "torch.sum", "postprocessing_moment_detr.PostProcessorDETR.move_windows"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.move_windows", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.move_windows"], ["", "def", "clip_window_lengths", "(", "self", ",", "windows", ")", ":", "\n", "        ", "\"\"\"\n        windows: (#windows, 2)  np.ndarray\n        ensure the final window duration are within [self.min_w_l, self.max_w_l]\n        \"\"\"", "\n", "window_lengths", "=", "windows", "[", ":", ",", "1", "]", "-", "windows", "[", ":", ",", "0", "]", "\n", "small_rows", "=", "window_lengths", "<", "self", ".", "min_w_l", "\n", "if", "torch", ".", "sum", "(", "small_rows", ")", ">", "0", ":", "\n", "            ", "windows", "=", "self", ".", "move_windows", "(", "\n", "windows", ",", "small_rows", ",", "self", ".", "min_w_l", ",", "move_method", "=", "self", ".", "move_window_method", ")", "\n", "", "large_rows", "=", "window_lengths", ">", "self", ".", "max_w_l", "\n", "if", "torch", ".", "sum", "(", "large_rows", ")", ">", "0", ":", "\n", "            ", "windows", "=", "self", ".", "move_windows", "(", "\n", "windows", ",", "large_rows", ",", "self", ".", "max_w_l", ",", "move_method", "=", "self", ".", "move_window_method", ")", "\n", "", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.postprocessing_moment_detr.PostProcessorDETR.move_windows": [[69, 95], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "move_windows", "(", "cls", ",", "windows", ",", "row_selector", ",", "new_length", ",", "move_method", "=", "\"left\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            windows:\n            row_selector:\n            new_length:\n            move_method: str,\n                left: keep left unchanged\n                center: keep center unchanged\n                right: keep right unchanged\n\n        Returns:\n\n        \"\"\"", "\n", "# import ipdb;", "\n", "# ipdb.set_trace()", "\n", "if", "move_method", "==", "\"left\"", ":", "\n", "            ", "windows", "[", "row_selector", ",", "1", "]", "=", "windows", "[", "row_selector", ",", "0", "]", "+", "new_length", "\n", "", "elif", "move_method", "==", "\"right\"", ":", "\n", "            ", "windows", "[", "row_selector", ",", "0", "]", "=", "windows", "[", "row_selector", ",", "1", "]", "-", "new_length", "\n", "", "elif", "move_method", "==", "\"center\"", ":", "\n", "            ", "center", "=", "(", "windows", "[", "row_selector", ",", "1", "]", "+", "windows", "[", "row_selector", ",", "0", "]", ")", "/", "2.", "\n", "windows", "[", "row_selector", ",", "0", "]", "=", "center", "-", "new_length", "/", "2.", "\n", "windows", "[", "row_selector", ",", "1", "]", "=", "center", "+", "new_length", "/", "2.", "\n", "", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.Transformer.__init__": [[20, 43], ["torch.nn.Module.__init__", "transformer.TransformerEncoderLayer", "transformer.TransformerEncoder", "transformer.TransformerDecoderLayer", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "transformer.TransformerDecoder", "transformer.Transformer._reset_parameters", "torch.nn.LayerNorm", "torch.nn.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.Transformer._reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "d_model", "=", "512", ",", "nhead", "=", "8", ",", "num_encoder_layers", "=", "6", ",", "\n", "num_decoder_layers", "=", "6", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ",", "\n", "return_intermediate_dec", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# TransformerEncoderLayerThin", "\n", "encoder_layer", "=", "TransformerEncoderLayer", "(", "d_model", ",", "nhead", ",", "dim_feedforward", ",", "\n", "dropout", ",", "activation", ",", "normalize_before", ")", "\n", "encoder_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "if", "normalize_before", "else", "None", "\n", "self", ".", "encoder", "=", "TransformerEncoder", "(", "encoder_layer", ",", "num_encoder_layers", ",", "encoder_norm", ")", "\n", "\n", "# TransformerDecoderLayerThin", "\n", "decoder_layer", "=", "TransformerDecoderLayer", "(", "d_model", ",", "nhead", ",", "dim_feedforward", ",", "\n", "dropout", ",", "activation", ",", "normalize_before", ")", "\n", "decoder_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "decoder", "=", "TransformerDecoder", "(", "decoder_layer", ",", "num_decoder_layers", ",", "decoder_norm", ",", "\n", "return_intermediate", "=", "return_intermediate_dec", ")", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "nhead", "=", "nhead", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.Transformer._reset_parameters": [[44, 48], ["transformer.Transformer.parameters", "p.dim", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.Transformer.forward": [[49, 74], ["src.permute.permute.permute", "pos_embed.permute.permute.permute", "query_embed.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "transformer.Transformer.encoder", "transformer.Transformer.decoder", "hs.transpose.transpose.transpose", "memory.transpose.transpose.transpose", "query_embed.unsqueeze().repeat.unsqueeze().repeat.unsqueeze"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "src", ",", "mask", ",", "query_embed", ",", "pos_embed", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            src: (batch_size, L, d)\n            mask: (batch_size, L)\n            query_embed: (#queries, d)\n            pos_embed: (batch_size, L, d) the same as src\n\n        Returns:\n\n        \"\"\"", "\n", "# flatten NxCxHxW to HWxNxC", "\n", "bs", ",", "l", ",", "d", "=", "src", ".", "shape", "\n", "src", "=", "src", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# (L, batch_size, d)", "\n", "pos_embed", "=", "pos_embed", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# (L, batch_size, d)", "\n", "query_embed", "=", "query_embed", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "bs", ",", "1", ")", "# (#queries, batch_size, d)", "\n", "\n", "tgt", "=", "torch", ".", "zeros_like", "(", "query_embed", ")", "\n", "memory", "=", "self", ".", "encoder", "(", "src", ",", "src_key_padding_mask", "=", "mask", ",", "pos", "=", "pos_embed", ")", "# (L, batch_size, d)", "\n", "hs", "=", "self", ".", "decoder", "(", "tgt", ",", "memory", ",", "memory_key_padding_mask", "=", "mask", ",", "\n", "pos", "=", "pos_embed", ",", "query_pos", "=", "query_embed", ")", "# (#layers, #queries, batch_size, d)", "\n", "hs", "=", "hs", ".", "transpose", "(", "1", ",", "2", ")", "# (#layers, batch_size, #qeries, d)", "\n", "# memory = memory.permute(1, 2, 0)  # (batch_size, d, L)", "\n", "memory", "=", "memory", ".", "transpose", "(", "0", ",", "1", ")", "# (batch_size, L, d)", "\n", "return", "hs", ",", "memory", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoder.__init__": [[78, 84], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "encoder_layer", ",", "num_layers", ",", "norm", "=", "None", ",", "return_intermediate", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "encoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "return_intermediate", "=", "return_intermediate", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoder.forward": [[85, 106], ["layer", "transformer.TransformerEncoder.norm", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "intermediate.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "src", ",", "\n", "mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "output", "=", "src", "\n", "\n", "intermediate", "=", "[", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "output", ",", "src_mask", "=", "mask", ",", "\n", "src_key_padding_mask", "=", "src_key_padding_mask", ",", "pos", "=", "pos", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "append", "(", "output", ")", "\n", "\n", "", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "\n", "", "if", "self", ".", "return_intermediate", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "intermediate", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoder.__init__": [[110, 116], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "decoder_layer", ",", "num_layers", ",", "norm", "=", "None", ",", "return_intermediate", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "decoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "return_intermediate", "=", "return_intermediate", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoder.forward": [[117, 147], ["transformer.TransformerDecoder.unsqueeze", "layer", "transformer.TransformerDecoder.norm", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "intermediate.append", "intermediate.pop", "intermediate.append", "transformer.TransformerDecoder.norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "output", "=", "tgt", "\n", "\n", "intermediate", "=", "[", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "output", ",", "memory", ",", "tgt_mask", "=", "tgt_mask", ",", "\n", "memory_mask", "=", "memory_mask", ",", "\n", "tgt_key_padding_mask", "=", "tgt_key_padding_mask", ",", "\n", "memory_key_padding_mask", "=", "memory_key_padding_mask", ",", "\n", "pos", "=", "pos", ",", "query_pos", "=", "query_pos", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "append", "(", "self", ".", "norm", "(", "output", ")", ")", "\n", "\n", "", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "pop", "(", ")", "\n", "intermediate", ".", "append", "(", "output", ")", "\n", "\n", "", "", "if", "self", ".", "return_intermediate", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "intermediate", ")", "\n", "\n", "", "return", "output", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayerThin.__init__": [[151, 165], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "# self.linear1 = nn.Linear(d_model, dim_feedforward)", "\n", "# self.dropout = nn.Dropout(dropout)", "\n", "# self.linear2 = nn.Linear(dim_feedforward, d_model)", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_model", ")", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "# self.activation = _get_activation_fn(activation)", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayerThin.with_pos_embed": [[166, 168], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayerThin.forward_post": [[169, 186], ["transformer.TransformerEncoderLayerThin.with_pos_embed", "transformer.TransformerEncoderLayerThin.linear", "transformer.TransformerEncoderLayerThin.norm", "transformer.TransformerEncoderLayerThin.self_attn", "transformer.TransformerEncoderLayerThin.dropout"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src2", "=", "self", ".", "linear", "(", "src2", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm", "(", "src", ")", "\n", "# src = src + self.dropout1(src2)", "\n", "# src = self.norm1(src)", "\n", "# src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))", "\n", "# src = src + self.dropout2(src2)", "\n", "# src = self.norm2(src)", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayerThin.forward_pre": [[187, 201], ["transformer.TransformerEncoderLayerThin.norm1", "transformer.TransformerEncoderLayerThin.with_pos_embed", "transformer.TransformerEncoderLayerThin.norm2", "transformer.TransformerEncoderLayerThin.linear2", "transformer.TransformerEncoderLayerThin.self_attn", "transformer.TransformerEncoderLayerThin.dropout1", "transformer.TransformerEncoderLayerThin.dropout", "transformer.TransformerEncoderLayerThin.dropout2", "transformer.TransformerEncoderLayerThin.activation", "transformer.TransformerEncoderLayerThin.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"not used\"\"\"", "\n", "src2", "=", "self", ".", "norm1", "(", "src", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src2", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src2", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src2", "=", "self", ".", "norm2", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src2", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayerThin.forward": [[202, 209], ["transformer.TransformerEncoderLayerThin.forward_post", "transformer.TransformerEncoderLayerThin.forward_pre"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_post", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_pre"], ["", "def", "forward", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayer.__init__": [[213, 229], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayer.with_pos_embed": [[230, 232], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayer.forward_post": [[233, 247], ["transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm1", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm2", "(", "src", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayer.forward_pre": [[248, 261], ["transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "src2", "=", "self", ".", "norm1", "(", "src", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src2", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src2", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src2", "=", "self", ".", "norm2", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src2", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerEncoderLayer.forward": [[262, 269], ["transformer.TransformerEncoderLayer.forward_post", "transformer.TransformerEncoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_post", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_pre"], ["", "def", "forward", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayer.__init__": [[273, 292], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm3", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout3", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayer.with_pos_embed": [[293, 295], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayer.forward_post": [[296, 318], ["transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayer.forward_pre": [[319, 341], ["transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayer.forward": [[342, 354], ["transformer.TransformerDecoderLayer.forward_post", "transformer.TransformerDecoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_post", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.__init__": [[358, 378], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_model", ")", "\n", "# self.linear1 = nn.Linear(d_model, dim_feedforward)", "\n", "# self.dropout = nn.Dropout(dropout)", "\n", "# self.linear2 = nn.Linear(dim_feedforward, d_model)", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "# self.norm3 = nn.LayerNorm(d_model)", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "# self.dropout3 = nn.Dropout(dropout)", "\n", "\n", "# self.activation = _get_activation_fn(activation)", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed": [[379, 381], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_post": [[382, 407], ["transformer.TransformerDecoderLayerThin.with_pos_embed", "transformer.TransformerDecoderLayerThin.norm1", "transformer.TransformerDecoderLayerThin.linear1", "transformer.TransformerDecoderLayerThin.norm2", "transformer.TransformerDecoderLayerThin.self_attn", "transformer.TransformerDecoderLayerThin.dropout1", "transformer.TransformerDecoderLayerThin.multihead_attn", "transformer.TransformerDecoderLayerThin.dropout2", "transformer.TransformerDecoderLayerThin.with_pos_embed", "transformer.TransformerDecoderLayerThin.with_pos_embed"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt2", "=", "self", ".", "linear1", "(", "tgt2", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "# tgt = tgt + self.dropout2(tgt2)", "\n", "# tgt = self.norm2(tgt)", "\n", "# tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt))))", "\n", "# tgt = tgt + self.dropout3(tgt2)", "\n", "# tgt = self.norm3(tgt)", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_pre": [[408, 430], ["transformer.TransformerDecoderLayerThin.norm1", "transformer.TransformerDecoderLayerThin.with_pos_embed", "transformer.TransformerDecoderLayerThin.norm2", "transformer.TransformerDecoderLayerThin.norm3", "transformer.TransformerDecoderLayerThin.linear2", "transformer.TransformerDecoderLayerThin.self_attn", "transformer.TransformerDecoderLayerThin.dropout1", "transformer.TransformerDecoderLayerThin.multihead_attn", "transformer.TransformerDecoderLayerThin.dropout2", "transformer.TransformerDecoderLayerThin.dropout", "transformer.TransformerDecoderLayerThin.dropout3", "transformer.TransformerDecoderLayerThin.activation", "transformer.TransformerDecoderLayerThin.with_pos_embed", "transformer.TransformerDecoderLayerThin.with_pos_embed", "transformer.TransformerDecoderLayerThin.linear1"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward": [[431, 443], ["transformer.TransformerDecoderLayerThin.forward_post", "transformer.TransformerDecoderLayerThin.forward_pre"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_post", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.TransformerDecoderLayerThin.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_clones": [[446, 448], ["torch.nn.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["", "", "def", "_get_clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "return", "nn", ".", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "i", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer.build_transformer": [[450, 460], ["transformer.Transformer"], "function", ["None"], ["", "def", "build_transformer", "(", "args", ")", ":", "\n", "    ", "return", "Transformer", "(", "\n", "d_model", "=", "args", ".", "hidden_dim", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "nhead", "=", "args", ".", "nheads", ",", "\n", "dim_feedforward", "=", "args", ".", "dim_feedforward", ",", "\n", "num_encoder_layers", "=", "args", ".", "enc_layers", ",", "\n", "num_decoder_layers", "=", "args", ".", "dec_layers", ",", "\n", "normalize_before", "=", "args", ".", "pre_norm", ",", "\n", "return_intermediate_dec", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.transformer._get_activation_fn": [[463, 472], ["RuntimeError"], "function", ["None"], ["", "def", "_get_activation_fn", "(", "activation", ")", ":", "\n", "    ", "\"\"\"Return an activation function given a string\"\"\"", "\n", "if", "activation", "==", "\"relu\"", ":", "\n", "        ", "return", "F", ".", "relu", "\n", "", "if", "activation", "==", "\"gelu\"", ":", "\n", "        ", "return", "F", ".", "gelu", "\n", "", "if", "activation", "==", "\"glu\"", ":", "\n", "        ", "return", "F", ".", "glu", "\n", "", "raise", "RuntimeError", "(", "F\"activation should be relu/gelu, not {activation}.\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.__init__": [[28, 60], ["start_end_dataset.StartEndDataset.load_data", "isinstance"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.load_data"], ["def", "__init__", "(", "self", ",", "dset_name", ",", "data_path", ",", "v_feat_dirs", ",", "q_feat_dir", ",", "\n", "q_feat_type", "=", "\"last_hidden_state\"", ",", "\n", "max_q_l", "=", "32", ",", "max_v_l", "=", "75", ",", "data_ratio", "=", "1.0", ",", "ctx_mode", "=", "\"video\"", ",", "\n", "normalize_v", "=", "True", ",", "normalize_t", "=", "True", ",", "load_labels", "=", "True", ",", "\n", "clip_len", "=", "2", ",", "max_windows", "=", "5", ",", "span_loss_type", "=", "\"l1\"", ",", "txt_drop_ratio", "=", "0", ")", ":", "\n", "        ", "self", ".", "dset_name", "=", "dset_name", "\n", "self", ".", "data_path", "=", "data_path", "\n", "self", ".", "data_ratio", "=", "data_ratio", "\n", "self", ".", "v_feat_dirs", "=", "v_feat_dirs", "if", "isinstance", "(", "v_feat_dirs", ",", "list", ")", "else", "[", "v_feat_dirs", "]", "\n", "self", ".", "q_feat_dir", "=", "q_feat_dir", "\n", "self", ".", "q_feat_type", "=", "q_feat_type", "\n", "self", ".", "max_q_l", "=", "max_q_l", "\n", "self", ".", "max_v_l", "=", "max_v_l", "\n", "self", ".", "ctx_mode", "=", "ctx_mode", "\n", "self", ".", "use_tef", "=", "\"tef\"", "in", "ctx_mode", "\n", "self", ".", "use_video", "=", "\"video\"", "in", "ctx_mode", "\n", "self", ".", "normalize_t", "=", "normalize_t", "\n", "self", ".", "normalize_v", "=", "normalize_v", "\n", "self", ".", "load_labels", "=", "load_labels", "\n", "self", ".", "clip_len", "=", "clip_len", "\n", "self", ".", "max_windows", "=", "max_windows", "# maximum number of windows to use as labels", "\n", "self", ".", "span_loss_type", "=", "span_loss_type", "\n", "self", ".", "txt_drop_ratio", "=", "txt_drop_ratio", "\n", "if", "\"val\"", "in", "data_path", "or", "\"test\"", "in", "data_path", ":", "\n", "            ", "assert", "txt_drop_ratio", "==", "0", "\n", "\n", "# checks", "\n", "", "assert", "q_feat_type", "in", "self", ".", "Q_FEAT_TYPES", "\n", "\n", "# data", "\n", "self", ".", "data", "=", "self", ".", "load_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.load_data": [[61, 69], ["utils.basic_utils.load_jsonl", "int", "logger.info", "len"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.standalone_eval.utils.load_jsonl"], ["", "def", "load_data", "(", "self", ")", ":", "\n", "        ", "datalist", "=", "load_jsonl", "(", "self", ".", "data_path", ")", "\n", "if", "self", ".", "data_ratio", "!=", "1", ":", "\n", "            ", "n_examples", "=", "int", "(", "len", "(", "datalist", ")", "*", "self", ".", "data_ratio", ")", "\n", "datalist", "=", "datalist", "[", ":", "n_examples", "]", "\n", "logger", ".", "info", "(", "\"Using {}% of the data: {} examples\"", "\n", ".", "format", "(", "self", ".", "data_ratio", "*", "100", ",", "n_examples", ")", ")", "\n", "", "return", "datalist", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.__len__": [[70, 72], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.__getitem__": [[73, 103], ["dict", "start_end_dataset.StartEndDataset._get_query_feat_by_qid", "dict", "start_end_dataset.StartEndDataset._get_video_feat_by_vid", "len", "torch.stack", "start_end_dataset.StartEndDataset.get_span_labels", "torch.arange", "torch.cat", "start_end_dataset.StartEndDataset.get_saliency_labels", "start_end_dataset.StartEndDataset.get_saliency_labels_sub_as_query"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset._get_query_feat_by_qid", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset._get_video_feat_by_vid", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_span_labels", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_saliency_labels", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_saliency_labels_sub_as_query"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "meta", "=", "self", ".", "data", "[", "index", "]", "\n", "\n", "model_inputs", "=", "dict", "(", ")", "\n", "model_inputs", "[", "\"query_feat\"", "]", "=", "self", ".", "_get_query_feat_by_qid", "(", "meta", "[", "\"qid\"", "]", ")", "# (Dq, ) or (Lq, Dq)", "\n", "if", "self", ".", "use_video", ":", "\n", "            ", "model_inputs", "[", "\"video_feat\"", "]", "=", "self", ".", "_get_video_feat_by_vid", "(", "meta", "[", "\"vid\"", "]", ")", "# (Lv, Dv)", "\n", "ctx_l", "=", "len", "(", "model_inputs", "[", "\"video_feat\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "ctx_l", "=", "self", ".", "max_v_l", "\n", "\n", "", "if", "self", ".", "use_tef", ":", "\n", "            ", "tef_st", "=", "torch", ".", "arange", "(", "0", ",", "ctx_l", ",", "1.0", ")", "/", "ctx_l", "\n", "tef_ed", "=", "tef_st", "+", "1.0", "/", "ctx_l", "\n", "tef", "=", "torch", ".", "stack", "(", "[", "tef_st", ",", "tef_ed", "]", ",", "dim", "=", "1", ")", "# (Lv, 2)", "\n", "if", "self", ".", "use_video", ":", "\n", "                ", "model_inputs", "[", "\"video_feat\"", "]", "=", "torch", ".", "cat", "(", "\n", "[", "model_inputs", "[", "\"video_feat\"", "]", ",", "tef", "]", ",", "dim", "=", "1", ")", "# (Lv, Dv+2)", "\n", "", "else", ":", "\n", "                ", "model_inputs", "[", "\"video_feat\"", "]", "=", "tef", "\n", "\n", "", "", "if", "self", ".", "load_labels", ":", "\n", "            ", "model_inputs", "[", "\"span_labels\"", "]", "=", "self", ".", "get_span_labels", "(", "meta", "[", "\"relevant_windows\"", "]", ",", "ctx_l", ")", "# (#windows, 2)", "\n", "if", "\"subs_train\"", "not", "in", "self", ".", "data_path", ":", "\n", "                ", "model_inputs", "[", "\"saliency_pos_labels\"", "]", ",", "model_inputs", "[", "\"saliency_neg_labels\"", "]", "=", "self", ".", "get_saliency_labels", "(", "meta", "[", "\"relevant_clip_ids\"", "]", ",", "meta", "[", "\"saliency_scores\"", "]", ",", "ctx_l", ")", "\n", "", "else", ":", "\n", "                ", "model_inputs", "[", "\"saliency_pos_labels\"", "]", ",", "model_inputs", "[", "\"saliency_neg_labels\"", "]", "=", "self", ".", "get_saliency_labels_sub_as_query", "(", "meta", "[", "\"relevant_windows\"", "]", "[", "0", "]", ",", "ctx_l", ")", "# only one gt", "\n", "", "", "return", "dict", "(", "meta", "=", "meta", ",", "model_inputs", "=", "model_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_saliency_labels_sub_as_query": [[104, 118], ["int", "max", "random.sample", "random.sample", "list", "list", "min", "range", "range", "range", "int"], "methods", ["None"], ["", "def", "get_saliency_labels_sub_as_query", "(", "self", ",", "gt_window", ",", "ctx_l", ",", "max_n", "=", "2", ")", ":", "\n", "        ", "gt_st", "=", "int", "(", "gt_window", "[", "0", "]", "/", "self", ".", "clip_len", ")", "\n", "gt_ed", "=", "max", "(", "0", ",", "min", "(", "int", "(", "gt_window", "[", "1", "]", "/", "self", ".", "clip_len", ")", ",", "ctx_l", ")", "-", "1", ")", "\n", "if", "gt_st", ">", "gt_ed", ":", "\n", "            ", "gt_st", "=", "gt_ed", "\n", "\n", "", "if", "gt_st", "!=", "gt_ed", ":", "\n", "            ", "pos_clip_indices", "=", "random", ".", "sample", "(", "range", "(", "gt_st", ",", "gt_ed", "+", "1", ")", ",", "k", "=", "max_n", ")", "\n", "", "else", ":", "\n", "            ", "pos_clip_indices", "=", "[", "gt_st", ",", "gt_st", "]", "\n", "\n", "", "neg_pool", "=", "list", "(", "range", "(", "0", ",", "gt_st", ")", ")", "+", "list", "(", "range", "(", "gt_ed", "+", "1", ",", "ctx_l", ")", ")", "\n", "neg_clip_indices", "=", "random", ".", "sample", "(", "neg_pool", ",", "k", "=", "max_n", ")", "\n", "return", "pos_clip_indices", ",", "neg_clip_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_saliency_labels": [[119, 153], ["numpy.array", "numpy.sum", "numpy.argsort", "min", "min", "list", "len", "random.sample", "random.sample", "set", "set", "range"], "methods", ["None"], ["", "def", "get_saliency_labels", "(", "self", ",", "rel_clip_ids", ",", "scores", ",", "ctx_l", ",", "max_n", "=", "1", ",", "add_easy_negative", "=", "True", ")", ":", "\n", "        ", "\"\"\"Sum the scores from the three annotations, then take the two clips with the\n        maximum scores as positive, and two with the minimum scores as negative.\n        Args:\n            rel_clip_ids: list(int), list of relevant clip ids\n            scores: list([anno1_score, anno2_score, anno3_score]),\n            ctx_l: int\n            max_n: int, #clips to use as positive and negative, for easy and hard negative, respectively.\n            add_easy_negative: bool, if True, sample eay negative outside the relevant_clip_ids.\n        \"\"\"", "\n", "# indices inside rel_clip_ids", "\n", "scores", "=", "np", ".", "array", "(", "scores", ")", "# (#rel_clips, 3)", "\n", "agg_scores", "=", "np", ".", "sum", "(", "scores", ",", "1", ")", "# (#rel_clips, )", "\n", "sort_indices", "=", "np", ".", "argsort", "(", "agg_scores", ")", "# increasing", "\n", "\n", "# indices in the whole video", "\n", "# the min(_, ctx_l-1) here is incorrect, but should not cause", "\n", "# much troubles since this should be rarely used.", "\n", "hard_pos_clip_indices", "=", "[", "min", "(", "rel_clip_ids", "[", "idx", "]", ",", "ctx_l", "-", "1", ")", "for", "idx", "in", "sort_indices", "[", "-", "max_n", ":", "]", "]", "\n", "hard_neg_clip_indices", "=", "[", "min", "(", "rel_clip_ids", "[", "idx", "]", ",", "ctx_l", "-", "1", ")", "for", "idx", "in", "sort_indices", "[", ":", "max_n", "]", "]", "\n", "easy_pos_clip_indices", "=", "[", "]", "\n", "easy_neg_clip_indices", "=", "[", "]", "\n", "if", "add_easy_negative", ":", "\n", "            ", "easy_neg_pool", "=", "list", "(", "set", "(", "range", "(", "ctx_l", ")", ")", "-", "set", "(", "rel_clip_ids", ")", ")", "\n", "if", "len", "(", "easy_neg_pool", ")", ">=", "max_n", ":", "\n", "                ", "easy_pos_clip_indices", "=", "random", ".", "sample", "(", "rel_clip_ids", ",", "k", "=", "max_n", ")", "\n", "easy_neg_clip_indices", "=", "random", ".", "sample", "(", "easy_neg_pool", ",", "k", "=", "max_n", ")", "\n", "", "else", ":", "# copy the hard ones", "\n", "                ", "easy_pos_clip_indices", "=", "hard_pos_clip_indices", "\n", "easy_neg_clip_indices", "=", "hard_neg_clip_indices", "\n", "\n", "", "", "pos_clip_indices", "=", "hard_pos_clip_indices", "+", "easy_pos_clip_indices", "\n", "neg_clip_indices", "=", "hard_neg_clip_indices", "+", "easy_neg_clip_indices", "\n", "return", "pos_clip_indices", ",", "neg_clip_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.get_span_labels": [[154, 173], ["len", "random.shuffle", "moment_detr.span_utils.span_xx_to_cxw", "torch.Tensor", "torch.Tensor().long", "torch.Tensor", "int", "min", "int"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.span_utils.span_xx_to_cxw"], ["", "def", "get_span_labels", "(", "self", ",", "windows", ",", "ctx_l", ")", ":", "\n", "        ", "\"\"\"\n        windows: list([st, ed]) in seconds. E.g. [[26, 36]], corresponding st_ed clip_indices [[13, 17]] (inclusive)\n            Note a maximum of `self.max_windows` windows are used.\n        returns Tensor of shape (#windows, 2), each row is [center, width] normalized by video length\n        \"\"\"", "\n", "if", "len", "(", "windows", ")", ">", "self", ".", "max_windows", ":", "\n", "            ", "random", ".", "shuffle", "(", "windows", ")", "\n", "windows", "=", "windows", "[", ":", "self", ".", "max_windows", "]", "\n", "", "if", "self", ".", "span_loss_type", "==", "\"l1\"", ":", "\n", "            ", "windows", "=", "torch", ".", "Tensor", "(", "windows", ")", "/", "(", "ctx_l", "*", "self", ".", "clip_len", ")", "# normalized windows in xx", "\n", "windows", "=", "span_xx_to_cxw", "(", "windows", ")", "# normalized windows in cxw", "\n", "", "elif", "self", ".", "span_loss_type", "==", "\"ce\"", ":", "\n", "            ", "windows", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "int", "(", "w", "[", "0", "]", "/", "self", ".", "clip_len", ")", ",", "min", "(", "int", "(", "w", "[", "1", "]", "/", "self", ".", "clip_len", ")", ",", "ctx_l", ")", "-", "1", "]", "\n", "for", "w", "in", "windows", "]", ")", ".", "long", "(", ")", "# inclusive", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset._get_query_feat_by_qid": [[174, 184], ["os.path.join", "[].astype", "torch.from_numpy", "utils.basic_utils.l2_normalize_np_array", "start_end_dataset.StartEndDataset.random_drop_rows", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.l2_normalize_np_array", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.random_drop_rows", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["", "def", "_get_query_feat_by_qid", "(", "self", ",", "qid", ")", ":", "\n", "        ", "q_feat_path", "=", "join", "(", "self", ".", "q_feat_dir", ",", "f\"qid{qid}.npz\"", ")", "\n", "q_feat", "=", "np", ".", "load", "(", "q_feat_path", ")", "[", "self", ".", "q_feat_type", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "self", ".", "q_feat_type", "==", "\"last_hidden_state\"", ":", "\n", "            ", "q_feat", "=", "q_feat", "[", ":", "self", ".", "max_q_l", "]", "\n", "", "if", "self", ".", "normalize_t", ":", "\n", "            ", "q_feat", "=", "l2_normalize_np_array", "(", "q_feat", ")", "\n", "", "if", "self", ".", "txt_drop_ratio", ">", "0", ":", "\n", "            ", "q_feat", "=", "self", ".", "random_drop_rows", "(", "q_feat", ")", "\n", "", "return", "torch", ".", "from_numpy", "(", "q_feat", ")", "# (D, ) or (Lq, D)", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset.random_drop_rows": [[185, 196], ["round", "numpy.random.choice", "len", "len"], "methods", ["None"], ["", "def", "random_drop_rows", "(", "self", ",", "embeddings", ")", ":", "\n", "        ", "\"\"\"randomly mask num_drop rows in embeddings to be zero.\n        Args:\n            embeddings: np.ndarray (L, D)\n        \"\"\"", "\n", "num_drop_rows", "=", "round", "(", "len", "(", "embeddings", ")", "*", "self", ".", "txt_drop_ratio", ")", "\n", "if", "num_drop_rows", ">", "0", ":", "\n", "            ", "row_indices", "=", "np", ".", "random", ".", "choice", "(", "\n", "len", "(", "embeddings", ")", ",", "size", "=", "num_drop_rows", ",", "replace", "=", "False", ")", "\n", "embeddings", "[", "row_indices", "]", "=", "0", "\n", "", "return", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.StartEndDataset._get_video_feat_by_vid": [[197, 210], ["min", "numpy.concatenate", "torch.from_numpy", "os.path.join", "[].astype", "v_feat_list.append", "utils.basic_utils.l2_normalize_np_array", "len", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.basic_utils.l2_normalize_np_array", "home.repos.pwc.inspect_result.jayleicn_moment_detr.clip.clip.load"], ["", "def", "_get_video_feat_by_vid", "(", "self", ",", "vid", ")", ":", "\n", "        ", "v_feat_list", "=", "[", "]", "\n", "for", "_feat_dir", "in", "self", ".", "v_feat_dirs", ":", "\n", "            ", "_feat_path", "=", "join", "(", "_feat_dir", ",", "f\"{vid}.npz\"", ")", "\n", "_feat", "=", "np", ".", "load", "(", "_feat_path", ")", "[", "\"features\"", "]", "[", ":", "self", ".", "max_v_l", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "self", ".", "normalize_v", ":", "\n", "                ", "_feat", "=", "l2_normalize_np_array", "(", "_feat", ")", "\n", "", "v_feat_list", ".", "append", "(", "_feat", ")", "\n", "# some features are slightly longer than the others", "\n", "", "min_len", "=", "min", "(", "[", "len", "(", "e", ")", "for", "e", "in", "v_feat_list", "]", ")", "\n", "v_feat_list", "=", "[", "e", "[", ":", "min_len", "]", "for", "e", "in", "v_feat_list", "]", "\n", "v_feat", "=", "np", ".", "concatenate", "(", "v_feat_list", ",", "axis", "=", "1", ")", "\n", "return", "torch", ".", "from_numpy", "(", "v_feat", ")", "# (Lv, D)", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.start_end_collate": [[212, 227], ["[].keys", "dict", "utils.tensor_utils.pad_sequences_1d", "torch.LongTensor", "dict"], "function", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.utils.tensor_utils.pad_sequences_1d"], ["", "", "def", "start_end_collate", "(", "batch", ")", ":", "\n", "    ", "batch_meta", "=", "[", "e", "[", "\"meta\"", "]", "for", "e", "in", "batch", "]", "# seems no need to collate ?", "\n", "\n", "model_inputs_keys", "=", "batch", "[", "0", "]", "[", "\"model_inputs\"", "]", ".", "keys", "(", ")", "\n", "batched_data", "=", "dict", "(", ")", "\n", "for", "k", "in", "model_inputs_keys", ":", "\n", "        ", "if", "k", "==", "\"span_labels\"", ":", "\n", "            ", "batched_data", "[", "k", "]", "=", "[", "dict", "(", "spans", "=", "e", "[", "\"model_inputs\"", "]", "[", "\"span_labels\"", "]", ")", "for", "e", "in", "batch", "]", "\n", "continue", "\n", "", "if", "k", "in", "[", "\"saliency_pos_labels\"", ",", "\"saliency_neg_labels\"", "]", ":", "\n", "            ", "batched_data", "[", "k", "]", "=", "torch", ".", "LongTensor", "(", "[", "e", "[", "\"model_inputs\"", "]", "[", "k", "]", "for", "e", "in", "batch", "]", ")", "\n", "continue", "\n", "", "batched_data", "[", "k", "]", "=", "pad_sequences_1d", "(", "\n", "[", "e", "[", "\"model_inputs\"", "]", "[", "k", "]", "for", "e", "in", "batch", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "fixed_length", "=", "None", ")", "\n", "", "return", "batch_meta", ",", "batched_data", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.start_end_dataset.prepare_batch_inputs": [[229, 248], ["dict", "[].to", "[].to", "[].to", "[].to", "dict", "batched_model_inputs[].to", "len", "e[].to"], "function", ["None"], ["", "def", "prepare_batch_inputs", "(", "batched_model_inputs", ",", "device", ",", "non_blocking", "=", "False", ")", ":", "\n", "    ", "model_inputs", "=", "dict", "(", "\n", "src_txt", "=", "batched_model_inputs", "[", "\"query_feat\"", "]", "[", "0", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", ",", "\n", "src_txt_mask", "=", "batched_model_inputs", "[", "\"query_feat\"", "]", "[", "1", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", ",", "\n", "src_vid", "=", "batched_model_inputs", "[", "\"video_feat\"", "]", "[", "0", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", ",", "\n", "src_vid_mask", "=", "batched_model_inputs", "[", "\"video_feat\"", "]", "[", "1", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", ",", "\n", ")", "\n", "targets", "=", "{", "}", "\n", "if", "\"span_labels\"", "in", "batched_model_inputs", ":", "\n", "        ", "targets", "[", "\"span_labels\"", "]", "=", "[", "\n", "dict", "(", "spans", "=", "e", "[", "\"spans\"", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", ")", "\n", "for", "e", "in", "batched_model_inputs", "[", "\"span_labels\"", "]", "\n", "]", "\n", "", "if", "\"saliency_pos_labels\"", "in", "batched_model_inputs", ":", "\n", "        ", "for", "name", "in", "[", "\"saliency_pos_labels\"", ",", "\"saliency_neg_labels\"", "]", ":", "\n", "            ", "targets", "[", "name", "]", "=", "batched_model_inputs", "[", "name", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "non_blocking", ")", "\n", "\n", "", "", "targets", "=", "None", "if", "len", "(", "targets", ")", "==", "0", "else", "targets", "\n", "return", "model_inputs", ",", "targets", "\n", "", ""]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.TrainablePositionalEncoding.__init__": [[13, 18], ["torch.nn.Module.__init__", "torch.nn.Embedding", "torch.nn.LayerNorm", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["def", "__init__", "(", "self", ",", "max_position_embeddings", ",", "hidden_size", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "TrainablePositionalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "position_embeddings", "=", "nn", ".", "Embedding", "(", "max_position_embeddings", ",", "hidden_size", ")", "\n", "self", ".", "LayerNorm", "=", "nn", ".", "LayerNorm", "(", "hidden_size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.TrainablePositionalEncoding.forward": [[19, 33], ["torch.arange", "position_ids.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "position_encoding.TrainablePositionalEncoding.position_embeddings", "position_encoding.TrainablePositionalEncoding.LayerNorm", "position_encoding.TrainablePositionalEncoding.dropout", "position_ids.unsqueeze().repeat.unsqueeze().repeat.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_feat", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input_feat: (N, L, D)\n        \"\"\"", "\n", "bsz", ",", "seq_length", "=", "input_feat", ".", "shape", "[", ":", "2", "]", "\n", "position_ids", "=", "torch", ".", "arange", "(", "seq_length", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "input_feat", ".", "device", ")", "\n", "position_ids", "=", "position_ids", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "bsz", ",", "1", ")", "# (N, L)", "\n", "\n", "position_embeddings", "=", "self", ".", "position_embeddings", "(", "position_ids", ")", "\n", "\n", "embeddings", "=", "self", ".", "LayerNorm", "(", "input_feat", "+", "position_embeddings", ")", "\n", "embeddings", "=", "self", ".", "dropout", "(", "embeddings", ")", "\n", "return", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingSine.__init__": [[40, 50], ["torch.nn.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__"], ["def", "__init__", "(", "self", ",", "num_pos_feats", "=", "64", ",", "temperature", "=", "10000", ",", "normalize", "=", "False", ",", "scale", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_pos_feats", "=", "num_pos_feats", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "normalize", "=", "normalize", "\n", "if", "scale", "is", "not", "None", "and", "normalize", "is", "False", ":", "\n", "            ", "raise", "ValueError", "(", "\"normalize should be True if scale is passed\"", ")", "\n", "", "if", "scale", "is", "None", ":", "\n", "            ", "scale", "=", "2", "*", "math", ".", "pi", "\n", "", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingSine.forward": [[51, 73], ["mask.cumsum", "torch.arange", "torch.stack().flatten", "torch.stack", "pos_x[].sin", "pos_x[].cos"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: torch.tensor, (batch_size, L, d)\n            mask: torch.tensor, (batch_size, L), with 1 as valid\n\n        Returns:\n\n        \"\"\"", "\n", "assert", "mask", "is", "not", "None", "\n", "x_embed", "=", "mask", ".", "cumsum", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "# (bsz, L)", "\n", "if", "self", ".", "normalize", ":", "\n", "            ", "eps", "=", "1e-6", "\n", "x_embed", "=", "x_embed", "/", "(", "x_embed", "[", ":", ",", "-", "1", ":", "]", "+", "eps", ")", "*", "self", ".", "scale", "\n", "\n", "", "dim_t", "=", "torch", ".", "arange", "(", "self", ".", "num_pos_feats", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "x", ".", "device", ")", "\n", "dim_t", "=", "self", ".", "temperature", "**", "(", "2", "*", "(", "dim_t", "//", "2", ")", "/", "self", ".", "num_pos_feats", ")", "\n", "\n", "pos_x", "=", "x_embed", "[", ":", ",", ":", ",", "None", "]", "/", "dim_t", "# (bsz, L, num_pos_feats)", "\n", "pos_x", "=", "torch", ".", "stack", "(", "(", "pos_x", "[", ":", ",", ":", ",", "0", ":", ":", "2", "]", ".", "sin", "(", ")", ",", "pos_x", "[", ":", ",", ":", ",", "1", ":", ":", "2", "]", ".", "cos", "(", ")", ")", ",", "dim", "=", "3", ")", ".", "flatten", "(", "2", ")", "# (bsz, L, num_pos_feats*2)", "\n", "# import ipdb; ipdb.set_trace()", "\n", "return", "pos_x", "# .permute(0, 2, 1)  # (bsz, num_pos_feats*2, L)", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__": [[79, 84], ["torch.nn.Module.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "position_encoding.PositionEmbeddingLearned.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.__init__", "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.reset_parameters"], ["def", "__init__", "(", "self", ",", "num_pos_feats", "=", "256", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "row_embed", "=", "nn", ".", "Embedding", "(", "50", ",", "num_pos_feats", ")", "\n", "self", ".", "col_embed", "=", "nn", ".", "Embedding", "(", "50", ",", "num_pos_feats", ")", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.reset_parameters": [[85, 88], ["torch.nn.init.uniform_", "torch.nn.init.uniform_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "row_embed", ".", "weight", ")", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "col_embed", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.PositionEmbeddingLearned.forward": [[89, 100], ["torch.arange", "torch.arange", "position_encoding.PositionEmbeddingLearned.col_embed", "position_encoding.PositionEmbeddingLearned.row_embed", "torch.cat().permute().unsqueeze().repeat", "torch.cat().permute().unsqueeze", "torch.cat().permute", "torch.cat", "position_encoding.PositionEmbeddingLearned.unsqueeze().repeat", "position_encoding.PositionEmbeddingLearned.unsqueeze().repeat", "position_encoding.PositionEmbeddingLearned.unsqueeze", "position_encoding.PositionEmbeddingLearned.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "h", ",", "w", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "i", "=", "torch", ".", "arange", "(", "w", ",", "device", "=", "x", ".", "device", ")", "\n", "j", "=", "torch", ".", "arange", "(", "h", ",", "device", "=", "x", ".", "device", ")", "\n", "x_emb", "=", "self", ".", "col_embed", "(", "i", ")", "\n", "y_emb", "=", "self", ".", "row_embed", "(", "j", ")", "\n", "pos", "=", "torch", ".", "cat", "(", "[", "\n", "x_emb", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "h", ",", "1", ",", "1", ")", ",", "\n", "y_emb", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "w", ",", "1", ")", ",", "\n", "]", ",", "dim", "=", "-", "1", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", "\n", "return", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.jayleicn_moment_detr.moment_detr.position_encoding.build_position_encoding": [[102, 116], ["position_encoding.TrainablePositionalEncoding", "position_encoding.PositionEmbeddingSine", "ValueError"], "function", ["None"], ["", "", "def", "build_position_encoding", "(", "args", ")", ":", "\n", "    ", "N_steps", "=", "args", ".", "hidden_dim", "\n", "if", "args", ".", "position_embedding", "in", "(", "'v2'", ",", "'sine'", ")", ":", "\n", "# TODO find a better way of exposing other arguments", "\n", "        ", "position_embedding", "=", "PositionEmbeddingSine", "(", "N_steps", ",", "normalize", "=", "True", ")", "\n", "# elif args.position_embedding in ('v3', 'learned'):", "\n", "#     position_embedding = PositionEmbeddingLearned(N_steps)", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"not supported {args.position_embedding}\"", ")", "\n", "\n", "", "txt_pos_embed", "=", "TrainablePositionalEncoding", "(", "\n", "max_position_embeddings", "=", "args", ".", "max_q_l", ",", "\n", "hidden_size", "=", "args", ".", "hidden_dim", ",", "dropout", "=", "args", ".", "input_dropout", ")", "\n", "return", "position_embedding", ",", "txt_pos_embed", "\n", "", ""]]}