{"home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.cross_translate.main": [[22, 53], ["torch.load", "transformers.XLMRobertaTokenizer.from_pretrained", "transformers.XLMRobertaModel.from_pretrained", "onmt.build_embeddings_2", "onmt.parser_model.ParserModel", "onmt.parser_model.ParserModel.load_state_dict", "onmt.cross_translator.build_translator", "codecs.open", "inputters.data_loader.InferenceDataLoader().batch", "onmt.cross_translator.build_translator.translate", "codecs.open.close", "inputters.dataset.make_text_iterator_from_file", "inputters.data_loader.InferenceDataLoader", "opt.translate_template.format"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings_2", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.build_translator", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batch", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.translate", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.make_text_iterator_from_file"], ["def", "main", "(", "opt", ")", ":", "\n", "\n", "  ", "batch_size", "=", "opt", ".", "batch_size", "\n", "\n", "state", "=", "torch", ".", "load", "(", "opt", ".", "model_path", ")", "\n", "\n", "tknzr", "=", "XLMRobertaTokenizer", ".", "from_pretrained", "(", "opt", ".", "xlmr_path", ")", "\n", "xlm_model", "=", "XLMRobertaModel", ".", "from_pretrained", "(", "opt", ".", "xlmr_path", ")", "\n", "\n", "model_opt", "=", "state", "[", "\"model_opt\"", "]", "\n", "\n", "embeddings", "=", "nmt_model", ".", "build_embeddings_2", "(", "model_opt", ".", "src_word_vec_size", ",", "tknzr", ".", "pad_token_id", ",", "tknzr", ".", "vocab_size", ",", "model_opt", ")", "\n", "\n", "\n", "model", "=", "ParserModel", "(", "embeddings", ",", "model_opt", ",", "state", "[", "'fields'", "]", ",", "tknzr", ",", "1", ",", "contextual_embeddings", "=", "xlm_model", ")", "\n", "model", ".", "load_state_dict", "(", "state", "[", "'student_model'", "]", ")", "\n", "\n", "translator", "=", "build_translator", "(", "model", ",", "state", "[", "'fields'", "]", ",", "opt", ")", "\n", "out_file", "=", "codecs", ".", "open", "(", "opt", ".", "output", ",", "'w+'", ",", "'utf-8'", ")", "\n", "\n", "src_iter", "=", "InferenceDataLoader", "(", "[", "opt", ".", "translate_template", ".", "format", "(", "opt", ".", "language", ")", ",", "opt", ".", "src", "]", ",", "\n", "batch_size", ",", "tknzr", ",", "state", "[", "'fields'", "]", "[", "'src'", "]", ".", "vocab", ")", ".", "batch", "(", ")", "\n", "if", "opt", ".", "tgt", "is", "not", "None", ":", "\n", "    ", "tgt_iter", "=", "make_text_iterator_from_file", "(", "opt", ".", "tgt", ")", "\n", "", "else", ":", "\n", "    ", "tgt_iter", "=", "None", "\n", "", "translator", ".", "translate", "(", "src_data_iter", "=", "src_iter", ",", "\n", "tgt_data_iter", "=", "tgt_iter", ",", "\n", "batch_size", "=", "opt", ".", "batch_size", ",", "\n", "out_file", "=", "out_file", ")", "\n", "out_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.cross_translate.eval_opts": [[55, 59], ["parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "eval_opts", "(", "parser", ")", ":", "\n", "  ", "parser", ".", "add_argument", "(", "'--translate_template'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyt/s2s_amr_parsing/translate_{}.txt.split.bpe\"", ")", "\n", "parser", ".", "add_argument", "(", "'--model_path'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyt/s2s_amr_parsing/s2s_amr_parser/model_multi/full_model_xlmr_dec.ckpt\"", ")", "\n", "parser", ".", "add_argument", "(", "'--xlmr_path'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyt/s2s_amr_parsing/xlm_test/xlm_roberta/\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.update_lr": [[20, 28], ["enumerate", "min"], "function", ["None"], ["def", "update_lr", "(", "step", ",", "d_model", ",", "base_lr", ",", "warmup", ",", "optim", ")", ":", "\n", "    ", "lr", "=", "base_lr", "*", "d_model", "**", "(", "-", "0.5", ")", "*", "min", "(", "step", "**", "(", "-", "0.5", ")", ",", "step", "*", "warmup", "**", "(", "-", "1.5", ")", ")", "\n", "for", "idx", ",", "param_group", "in", "enumerate", "(", "optim", ".", "param_groups", ")", ":", "\n", "        ", "if", "idx", "==", "0", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "", "else", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "=", "lr", "*", "0.5", "\n", "", "", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.main": [[29, 165], ["print", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all", "random.seed", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "transformers.XLMRobertaTokenizer.from_pretrained", "onmt.load_test_model", "inputters.data_loader.DataLoader", "inputters.data_loader.DataLoader", "torch.device", "torch.device", "torch.device", "onmt.build_embeddings_2", "onmt.ParserModel", "torch.nn.parallel.DistributedDataParallel.to", "torch.nn.parallel.DistributedDataParallel.train", "torch.nn.parallel.DistributedDataParallel.named_parameters", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam.zero_grad", "range", "len", "transformers.XLMRobertaModel.from_pretrained", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DistributedDataParallel", "time.time", "inputters.data_loader.DataLoader.batch", "time.time", "print", "train.validation", "k.find", "other_params.append", "xlm_test.to.to", "xlm_attn_mask.to.to", "src_test.to.to", "tgt_test.to.to", "torch.nn.parallel.DistributedDataParallel.", "loss.backward", "k.find", "enc_params.append", "loss.item", "train.update_lr", "torch.optim.Adam.step", "torch.optim.Adam.zero_grad", "train.save", "print", "src_test.to.permute", "time.time", "print", "train.save", "print"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.load_test_model", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings_2", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batch", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.validation", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.update_lr", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save"], ["", "def", "main", "(", "rank", ",", "opt", ",", "dummy_opt", ")", ":", "\n", "\n", "    ", "print", "(", "\"process begin, rank:\"", ",", "rank", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "opt", ".", "torch_seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "opt", ".", "torch_seed", ")", "\n", "random", ".", "seed", "(", "opt", ".", "seed", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "rank", ")", "\n", "\n", "max_epoch", "=", "opt", ".", "max_epoch", "# 250", "\n", "max_step", "=", "opt", ".", "max_step", "# 120000", "\n", "warmup", "=", "opt", ".", "warmup", "\n", "base_lr", "=", "opt", ".", "base_lr", "\n", "grad_accu", "=", "opt", ".", "grad_accu", "\n", "batch_size", "=", "opt", ".", "batch_size", "\n", "d_model", "=", "512", "\n", "flatten", "=", "2", "\n", "\n", "translate", "=", "(", "opt", ".", "use_translate", "==", "1", ")", "\n", "use_xlm", "=", "(", "opt", ".", "use_xlm", "==", "1", ")", "\n", "init", "=", "(", "opt", ".", "use_dec", "!=", "1", ")", "\n", "\n", "# for OOM error", "\n", "if", "translate", ":", "\n", "        ", "batch_size", "=", "2500", "\n", "grad_accu", "=", "3", "\n", "\n", "", "if", "use_xlm", ":", "\n", "        ", "batch_size", "=", "2048", "\n", "grad_accu", "=", "2", "\n", "\n", "", "prefix", "=", "opt", ".", "prefix", "\n", "prefix_dev", "=", "opt", ".", "prefix_dev", "\n", "train_ls", "=", "[", "\"train.txt.split.bpe\"", ",", "\"de_train.txt\"", ",", "\"es_train.txt\"", ",", "\"it_train.txt\"", ",", "\"zh_train.txt\"", "]", "\n", "src_filename_train_ls", "=", "[", "prefix", "+", "ele", "for", "ele", "in", "train_ls", "]", "\n", "tgt_filename", "=", "prefix", "+", "\"train.txt.ground.truth.bpe\"", "\n", "dev_ls", "=", "[", "'dev.txt.split.bpe'", ",", "'de_dev.txt'", ",", "'es_dev.txt'", ",", "'it_dev.txt'", ",", "'zh_dev.txt'", "]", "\n", "src_filename_dev_ls", "=", "[", "prefix_dev", "+", "ele", "for", "ele", "in", "dev_ls", "]", "\n", "tgt_filename_dev", "=", "prefix_dev", "+", "\"dev.txt.ground.truth.bpe\"", "\n", "\n", "lang_num", "=", "len", "(", "train_ls", ")", "if", "flatten", "==", "0", "else", "1", "\n", "\n", "save_prefix", "=", "opt", ".", "save_prefix", "\n", "\n", "tknzr", "=", "XLMRobertaTokenizer", ".", "from_pretrained", "(", "opt", ".", "xlm_r_path", ")", "\n", "if", "use_xlm", ":", "\n", "        ", "xlm_model", "=", "XLMRobertaModel", ".", "from_pretrained", "(", "opt", ".", "xlm_r_path", ")", "\n", "", "else", ":", "\n", "        ", "xlm_model", "=", "None", "\n", "\n", "", "fields", ",", "teacher_model", ",", "model_opt", "=", "nmt_model", ".", "load_test_model", "(", "opt", ",", "dummy_opt", ".", "__dict__", ",", "use_softmax", "=", "False", ",", "get_model_opt", "=", "True", ",", "init", "=", "init", ")", "\n", "\n", "train_data_loader", "=", "DataLoader", "(", "src_filename_train_ls", ",", "tgt_filename", ",", "batch_size", "=", "batch_size", ",", "tknzr", "=", "tknzr", ",", "src_vocab", "=", "fields", "[", "'src'", "]", ".", "vocab", ",", "tgt_vocab", "=", "fields", "[", "'tgt2'", "]", ".", "vocab", ",", "\n", "train", "=", "True", ",", "world_size", "=", "opt", ".", "world_size", ",", "rank", "=", "rank", ",", "flatten", "=", "flatten", ",", "mask_rate", "=", "0.0", ")", "\n", "dev_data_loader", "=", "DataLoader", "(", "src_filename_dev_ls", ",", "tgt_filename_dev", ",", "batch_size", "=", "batch_size", ",", "tknzr", "=", "tknzr", ",", "src_vocab", "=", "fields", "[", "'src'", "]", ".", "vocab", ",", "tgt_vocab", "=", "fields", "[", "'tgt2'", "]", ".", "vocab", ",", "\n", "train", "=", "False", ",", "world_size", "=", "1", ",", "rank", "=", "0", ",", "flatten", "=", "flatten", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "\n", "embeddings", "=", "nmt_model", ".", "build_embeddings_2", "(", "model_opt", ".", "src_word_vec_size", ",", "tknzr", ".", "pad_token_id", ",", "tknzr", ".", "vocab_size", ",", "model_opt", ")", "\n", "\n", "student_model", "=", "parser_model", ".", "ParserModel", "(", "embeddings", ",", "model_opt", ",", "fields", ",", "tknzr", ",", "lang_num", ",", "decoder", "=", "teacher_model", ".", "decoder", ",", "\n", "generator", "=", "teacher_model", ".", "generator", ",", "contextual_embeddings", "=", "xlm_model", ")", "\n", "joint_model", "=", "student_model", "\n", "joint_model", ".", "to", "(", "device", ")", "\n", "if", "opt", ".", "world_size", ">", "1", ":", "\n", "        ", "joint_model", "=", "torch", ".", "nn", ".", "parallel", ".", "DistributedDataParallel", "(", "joint_model", ",", "find_unused_parameters", "=", "True", ",", "device_ids", "=", "[", "rank", "]", ",", "output_device", "=", "[", "rank", "]", ")", "\n", "", "joint_model", ".", "train", "(", ")", "\n", "\n", "other_params", "=", "[", "]", "\n", "enc_params", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "joint_model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "k", ".", "find", "(", "'encoder'", ")", "==", "-", "1", ":", "\n", "            ", "other_params", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "            ", "if", "k", ".", "find", "(", "'contextual_embeddings'", ")", "==", "-", "1", ":", "\n", "                ", "enc_params", ".", "append", "(", "v", ")", "\n", "", "", "", "params", "=", "[", "\n", "{", "'params'", ":", "enc_params", "}", ",", "\n", "{", "'params'", ":", "other_params", "}", "\n", "]", "\n", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "params", ",", "lr", "=", "0.0001", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "max_acc", "=", "0.", "\n", "step", "=", "0", "\n", "backward_step", "=", "0", "\n", "lr", "=", "0", "\n", "\n", "for", "epoch", "in", "range", "(", "max_epoch", ")", ":", "\n", "        ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "avg_loss", "=", "0.", "\n", "batch_num", "=", "0", "\n", "samples_num", "=", "0", "\n", "for", "data_iter", "in", "train_data_loader", ".", "batch", "(", ")", ":", "\n", "            ", "step", "+=", "1", "\n", "xlm_test", ",", "xlm_attn_mask", ",", "src_test", ",", "tgt_test", "=", "data_iter", "\n", "xlm_test", "=", "xlm_test", ".", "to", "(", "device", ")", "\n", "xlm_attn_mask", "=", "xlm_attn_mask", ".", "to", "(", "device", ")", "\n", "src_test", "=", "src_test", ".", "to", "(", "device", ")", "\n", "tgt_test", "=", "tgt_test", ".", "to", "(", "device", ")", "\n", "\n", "samples_num", "+=", "xlm_test", ".", "shape", "[", "0", "]", "\n", "batch_num", "+=", "xlm_test", ".", "shape", "[", "0", "]", "\n", "\n", "loss", ",", "_", ",", "_", "=", "joint_model", "(", "x", "=", "xlm_test", ",", "x_attn", "=", "xlm_attn_mask", ",", "\n", "tgt", "=", "tgt_test", ",", "cal_loss", "=", "True", ",", "src", "=", "src_test", ".", "permute", "(", "1", ",", "0", ")", ",", "translate", "=", "translate", ",", "beta", "=", "0.5", ")", "\n", "\n", "avg_loss", "+=", "loss", ".", "item", "(", ")", "*", "xlm_test", ".", "shape", "[", "0", "]", "\n", "loss", ".", "backward", "(", ")", "\n", "del", "loss", "\n", "if", "step", "%", "grad_accu", "==", "0", ":", "\n", "                ", "backward_step", "+=", "1", "\n", "lr", "=", "update_lr", "(", "backward_step", ",", "d_model", ",", "base_lr", ",", "warmup", ",", "optimizer", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "if", "backward_step", "%", "600", "==", "0", ":", "\n", "                    ", "end_time", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"600 step, time:\"", ",", "end_time", "-", "start_time", ")", "\n", "start_time", "=", "end_time", "\n", "", "", "", "end_time", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Epoch {0}, step {4}, train loss:{1}, lr:{2}, time:{3}\"", ".", "format", "(", "epoch", ",", "avg_loss", "/", "batch_num", ",", "lr", ",", "end_time", "-", "start_time", ",", "backward_step", ")", ")", "\n", "acc", "=", "validation", "(", "joint_model", ",", "dev_data_loader", ",", "device", ",", "epoch", ")", "\n", "if", "max_acc", "<", "acc", ":", "\n", "            ", "max_acc", "=", "acc", "\n", "if", "rank", "==", "0", ":", "\n", "                ", "save", "(", "joint_model", ",", "save_prefix", "+", "\"{0}.pth\"", ".", "format", "(", "epoch", ")", ",", "model_opt", ",", "fields", ",", "opt", ".", "world_size", ")", "\n", "print", "(", "\"save\"", ")", "\n", "", "", "elif", "epoch", "%", "4", "==", "0", ":", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "                ", "save", "(", "joint_model", ",", "save_prefix", "+", "\"{0}.pth\"", ".", "format", "(", "epoch", ")", ",", "model_opt", ",", "fields", ",", "opt", ".", "world_size", ")", "\n", "print", "(", "\"save every 4 epoch\"", ")", "\n", "", "", "if", "backward_step", ">", "max_step", ":", "\n", "            ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.validation": [[166, 190], ["model.eval", "time.time", "dev_data_loader.batch", "print", "model.train", "xlm_x.to.to", "xlm_attn_mask.to.to", "tgt.to.to", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model", "torch.mean().item", "torch.mean().item", "torch.mean().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "time.time", "torch.mean", "torch.mean", "torch.mean", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batch"], ["", "", "", "def", "validation", "(", "model", ",", "dev_data_loader", ",", "device", ",", "epoch", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "loss", "=", "0", "\n", "correct", "=", "0", "\n", "num", "=", "0", "\n", "token_num", "=", "0", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "for", "data_iter", "in", "dev_data_loader", ".", "batch", "(", ")", ":", "\n", "        ", "xlm_x", ",", "xlm_attn_mask", ",", "src", ",", "tgt", "=", "data_iter", "\n", "xlm_x", "=", "xlm_x", ".", "to", "(", "device", ")", "\n", "xlm_attn_mask", "=", "xlm_attn_mask", ".", "to", "(", "device", ")", "\n", "tgt", "=", "tgt", ".", "to", "(", "device", ")", "\n", "\n", "num", "+=", "tgt", ".", "shape", "[", "0", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "tmp_loss", ",", "tmp_correct", ",", "tmp_token_num", "=", "model", "(", "xlm_x", ",", "xlm_attn_mask", ",", "tgt", ",", "cal_loss", "=", "True", ")", "\n", "\n", "loss", "+=", "torch", ".", "mean", "(", "tmp_loss", ")", ".", "item", "(", ")", "\n", "correct", "+=", "torch", ".", "sum", "(", "tmp_correct", ")", ".", "item", "(", ")", "\n", "token_num", "+=", "torch", ".", "sum", "(", "tmp_token_num", ")", ".", "item", "(", ")", "\n", "del", "tmp_loss", ",", "tmp_correct", ",", "tmp_token_num", "\n", "", "", "print", "(", "\"Epoch {0}, dev loss: {1}, dev acc: {2}:, time: {3}\"", ".", "format", "(", "epoch", ",", "loss", "/", "num", ",", "correct", "/", "token_num", ",", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "model", ".", "train", "(", ")", "\n", "return", "correct", "/", "token_num", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load": [[191, 194], ["torch.load", "torch.load", "torch.load", "model.student_model.load_state_dict"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "def", "load", "(", "model", ",", "load_path", ")", ":", "\n", "    ", "state", "=", "torch", ".", "load", "(", "load_path", ")", "\n", "model", ".", "student_model", ".", "load_state_dict", "(", "state", "[", "'student_model'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save": [[195, 206], ["torch.save", "torch.save", "torch.save", "model.module.state_dict", "model.state_dict"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.save"], ["", "def", "save", "(", "model", ",", "save_path", ",", "model_opt", ",", "fields", ",", "world_size", ")", ":", "\n", "    ", "if", "world_size", ">", "1", ":", "\n", "        ", "t1", "=", "model", ".", "module", ".", "state_dict", "(", ")", "\n", "", "else", ":", "\n", "        ", "t1", "=", "model", ".", "state_dict", "(", ")", "\n", "", "state", "=", "{", "\n", "'student_model'", ":", "t1", ",", "\n", "'model_opt'", ":", "model_opt", ",", "\n", "'fields'", ":", "fields", "\n", "}", "\n", "torch", ".", "save", "(", "state", ",", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.init_processes": [[207, 212], ["torch.init_process_group", "train.main"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.main"], ["", "def", "init_processes", "(", "local_rank", ",", "opt", ",", "dummy_opt", ",", "backend", "=", "'nccl'", ")", ":", "\n", "    ", "os", ".", "environ", "[", "'MASTER_ADDR'", "]", "=", "opt", ".", "MASTER_ADDR", "\n", "os", ".", "environ", "[", "'MASTER_PORT'", "]", "=", "opt", ".", "MASTER_PORT", "\n", "dist", ".", "init_process_group", "(", "backend", ",", "rank", "=", "local_rank", ",", "world_size", "=", "opt", ".", "world_size", ")", "\n", "main", "(", "local_rank", ",", "opt", ",", "dummy_opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.training_opts": [[213, 238], ["parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "training_opts", "(", "parser", ")", ":", "\n", "    ", "group", "=", "parser", ".", "add_argument_group", "(", "'Model'", ")", "\n", "group", ".", "add", "(", "'--model'", ",", "'-model'", ",", "dest", "=", "'models'", ",", "metavar", "=", "'MODEL'", ",", "\n", "nargs", "=", "'+'", ",", "type", "=", "str", ",", "default", "=", "[", "]", ",", "required", "=", "True", ",", "\n", "help", "=", "'Path to model .pt file(s). '", "\n", "'Multiple models can be specified, '", "\n", "'for ensemble decoding.'", ")", "\n", "parser", ".", "add_argument", "(", "'--MASTER_ADDR'", ",", "type", "=", "str", ",", "default", "=", "'localhost'", ")", "\n", "parser", ".", "add_argument", "(", "'--MASTER_PORT'", ",", "type", "=", "str", ",", "default", "=", "'23457'", ")", "\n", "parser", ".", "add_argument", "(", "'--world_size'", ",", "type", "=", "int", ",", "default", "=", "4", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--max_epoch'", ",", "type", "=", "int", ",", "default", "=", "500", ")", "\n", "parser", ".", "add_argument", "(", "'--max_step'", ",", "type", "=", "int", ",", "default", "=", "300000", ")", "\n", "parser", ".", "add_argument", "(", "'--warmup'", ",", "type", "=", "int", ",", "default", "=", "4000", ")", "\n", "parser", ".", "add_argument", "(", "'--base_lr'", ",", "type", "=", "float", ",", "defalut", "=", "1.0", ")", "\n", "parser", ".", "add_argument", "(", "'--grad_accu'", ",", "type", "=", "int", ",", "default", "=", "2", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "4096", ")", "# token batch size", "\n", "parser", ".", "add_argument", "(", "'--use_xlm'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'--use_dec'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'--use_translate'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--prefix'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyitao/s2s_amr_parsing/translate_data/\"", ")", "\n", "parser", ".", "add_argument", "(", "'--prefix_dev'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyitao/s2s_amr_parsing/translate_data/\"", ")", "\n", "parser", ".", "add_argument", "(", "'--save_prefix'", ",", "type", "=", "str", ",", "defalut", "=", "\"/home/caiyitao/s2s_amr_parsing/s2s_amr_parser/model_multi/\"", ")", "\n", "parser", ".", "add_argument", "(", "'--xlm_r_path'", ",", "type", "=", "str", ",", "default", "=", "\"/home/caiyitao/s2s_amr_parsing/xlm_test/xlm_roberta/\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoderLayer.__init__": [[10, 21], ["torch.Module.__init__", "onmt.sublayer.MultiHeadedAttention", "onmt.sublayer.PositionwiseFeedForward", "torch.LayerNorm", "torch.LayerNorm", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ")", ":", "\n", "    ", "super", "(", "TransformerEncoderLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "self_attn", "=", "onmt", ".", "sublayer", ".", "MultiHeadedAttention", "(", "\n", "heads", ",", "d_model", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "feed_forward", "=", "PositionwiseFeedForward", "(", "d_model", ",", "d_ff", ",", "dropout", ")", "\n", "\n", "self", ".", "att_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "ffn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoderLayer.forward": [[22, 32], ["transformer_encoder.TransformerEncoderLayer.att_layer_norm", "transformer_encoder.TransformerEncoderLayer.self_attn", "transformer_encoder.TransformerEncoderLayer.ffn_layer_norm", "transformer_encoder.TransformerEncoderLayer.feed_forward", "transformer_encoder.TransformerEncoderLayer.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "mask", ")", ":", "\n", "    ", "input_norm", "=", "self", ".", "att_layer_norm", "(", "inputs", ")", "\n", "outputs", ",", "_", "=", "self", ".", "self_attn", "(", "input_norm", ",", "input_norm", ",", "input_norm", ",", "\n", "mask", "=", "mask", ")", "\n", "inputs", "=", "self", ".", "dropout", "(", "outputs", ")", "+", "inputs", "\n", "\n", "input_norm", "=", "self", ".", "ffn_layer_norm", "(", "inputs", ")", "\n", "outputs", "=", "self", ".", "feed_forward", "(", "input_norm", ")", "\n", "inputs", "=", "outputs", "+", "inputs", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoder.__init__": [[36, 46], ["torch.Module.__init__", "torch.ModuleList", "torch.LayerNorm", "transformer_encoder.TransformerEncoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "num_layers", ",", "d_model", ",", "heads", ",", "d_ff", ",", "\n", "dropout", ",", "embeddings", ")", ":", "\n", "    ", "super", "(", "TransformerEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "embeddings", "=", "embeddings", "\n", "self", ".", "transformer", "=", "nn", ".", "ModuleList", "(", "\n", "[", "TransformerEncoderLayer", "(", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ")", "\n", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoder._check_args": [[47, 52], ["src.size", "lengths.size", "utils.misc.aeq"], "methods", ["None"], ["", "def", "_check_args", "(", "self", ",", "src", ",", "lengths", "=", "None", ")", ":", "\n", "    ", "_", ",", "n_batch", "=", "src", ".", "size", "(", ")", "\n", "if", "lengths", "is", "not", "None", ":", "\n", "      ", "n_batch_", ",", "=", "lengths", ".", "size", "(", ")", "\n", "aeq", "(", "n_batch", ",", "n_batch_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoder.forward": [[53, 69], ["transformer_encoder.TransformerEncoder._check_args", "transformer_encoder.TransformerEncoder.embeddings", "transformer_encoder.TransformerEncoder.transpose().contiguous", "src.transpose", "src.transpose.data.eq().unsqueeze", "range", "transformer_encoder.TransformerEncoder.layer_norm", "transformer_encoder.TransformerEncoder.transpose().contiguous", "transformer_encoder.TransformerEncoder.transpose", "src.transpose.data.eq", "transformer_encoder.TransformerEncoder.transpose"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_encoder.TransformerEncoder._check_args"], ["", "", "def", "forward", "(", "self", ",", "src", ",", "lengths", "=", "None", ",", "attn_mask", "=", "None", ")", ":", "\n", "    ", "\"\"\" See :obj:`EncoderBase.forward()`\"\"\"", "\n", "self", ".", "_check_args", "(", "src", ",", "lengths", ")", "\n", "\n", "emb", "=", "self", ".", "embeddings", "(", "src", ")", "\n", "\n", "out", "=", "emb", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "words", "=", "src", ".", "transpose", "(", "0", ",", "1", ")", "\n", "padding_idx", "=", "self", ".", "embeddings", ".", "word_padding_idx", "\n", "mask", "=", "words", ".", "data", ".", "eq", "(", "padding_idx", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, T]", "\n", "# Run the forward pass of every layer of the tranformer.", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "      ", "out", "=", "self", ".", "transformer", "[", "i", "]", "(", "out", ",", "mask", ")", "\n", "", "out", "=", "self", ".", "layer_norm", "(", "out", ")", "\n", "\n", "return", "emb", ",", "out", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", ",", "lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.opts.config_opts": [[8, 14], ["parser.add", "parser.add"], "function", ["None"], ["def", "config_opts", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "add", "(", "'-config'", ",", "'--config'", ",", "required", "=", "False", ",", "\n", "is_config_file_arg", "=", "True", ",", "help", "=", "'config file path'", ")", "\n", "parser", ".", "add", "(", "'-save_config'", ",", "'--save_config'", ",", "required", "=", "False", ",", "\n", "is_write_out_config_file_arg", "=", "True", ",", "\n", "help", "=", "'config file save path'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.opts.model_opts": [[16, 69], ["parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add"], "function", ["None"], ["", "def", "model_opts", "(", "parser", ")", ":", "\n", "    ", "\"\"\"\n    These options are passed to the construction of the model.\n    Be careful with these as they will be used during translation.\n    \"\"\"", "\n", "\n", "# Embedding Options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Model-Embeddings'", ")", "\n", "group", ".", "add", "(", "'--src_word_vec_size'", ",", "'-src_word_vec_size'", ",", "\n", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'Word embedding size for src.'", ")", "\n", "group", ".", "add", "(", "'--tgt_word_vec_size'", ",", "'-tgt_word_vec_size'", ",", "\n", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'Word embedding size for tgt.'", ")", "\n", "\n", "group", ".", "add", "(", "'--share_decoder_embeddings'", ",", "'-share_decoder_embeddings'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Use a shared weight matrix for the input and\n                       output word  embeddings in the decoder.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--share_embeddings'", ",", "'-share_embeddings'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Share the word embeddings between encoder\n                       and decoder. Need to use shared dictionary for this\n                       option.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--position_encoding'", ",", "'-position_encoding'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Use a sin to mark relative words positions.\n                       Necessary for non-RNN style models.\n                       \"\"\"", ")", "\n", "\n", "# Encoder-Decoder Options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Model- Encoder-Decoder'", ")", "\n", "group", ".", "add", "(", "'--enc_layers'", ",", "'-enc_layers'", ",", "type", "=", "int", ",", "default", "=", "6", ",", "\n", "help", "=", "'Number of layers in the encoder'", ")", "\n", "group", ".", "add", "(", "'--dec_layers'", ",", "'-dec_layers'", ",", "type", "=", "int", ",", "default", "=", "6", ",", "\n", "help", "=", "'Number of layers in the decoder'", ")", "\n", "group", ".", "add", "(", "'--enc_rnn_size'", ",", "'-enc_rnn_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "\"\"\"Size of encoder rnn hidden states.\n                       Must be equal to dec_rnn_size except for\n                       speech-to-text.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--dec_rnn_size'", ",", "'-dec_rnn_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "\"\"\"Size of decoder rnn hidden states.\n                       Must be equal to enc_rnn_size except for\n                       speech-to-text.\"\"\"", ")", "\n", "\n", "# Attention options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Model- Attention'", ")", "\n", "group", ".", "add", "(", "'--self_attn_type'", ",", "'-self_attn_type'", ",", "\n", "type", "=", "str", ",", "default", "=", "\"scaled-dot\"", ",", "\n", "help", "=", "\"\"\"Self attention type in Transformer decoder\n                       layer -- currently \"scaled-dot\" or \"average\" \"\"\"", ")", "\n", "group", ".", "add", "(", "'--heads'", ",", "'-heads'", ",", "type", "=", "int", ",", "default", "=", "8", ",", "\n", "help", "=", "'Number of heads for transformer self-attention'", ")", "\n", "group", ".", "add", "(", "'--transformer_ff'", ",", "'-transformer_ff'", ",", "type", "=", "int", ",", "default", "=", "2048", ",", "\n", "help", "=", "'Size of hidden transformer feed-forward'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.opts.preprocess_opts": [[71, 156], ["parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add"], "function", ["None"], ["", "def", "preprocess_opts", "(", "parser", ")", ":", "\n", "  ", "\"\"\" Pre-procesing options \"\"\"", "\n", "# Data options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Data'", ")", "\n", "group", ".", "add", "(", "'--vocab_file'", ",", "'-vocab_file'", ",", "required", "=", "False", ",", "default", "=", "\"\"", ",", "help", "=", "\"if share vocab and need out_vocab\"", ")", "\n", "\n", "group", ".", "add", "(", "'--train_src'", ",", "'-train_src'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the training source data\"", ")", "\n", "group", ".", "add", "(", "'--train_tgt'", ",", "'-train_tgt'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the training target data\"", ")", "\n", "group", ".", "add", "(", "'--valid_src'", ",", "'-valid_src'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the validation source data\"", ")", "\n", "group", ".", "add", "(", "'--valid_tgt'", ",", "'-valid_tgt'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the validation target data\"", ")", "\n", "\n", "group", ".", "add", "(", "'--train_src2'", ",", "'-train_src2'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the training source data\"", ")", "\n", "group", ".", "add", "(", "'--train_tgt2'", ",", "'-train_tgt2'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the training target data\"", ")", "\n", "group", ".", "add", "(", "'--valid_src2'", ",", "'-valid_src2'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the validation source data\"", ")", "\n", "group", ".", "add", "(", "'--valid_tgt2'", ",", "'-valid_tgt2'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to the validation target data\"", ")", "\n", "\n", "\n", "group", ".", "add", "(", "'--save_data'", ",", "'-save_data'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Output file for the prepared data\"", ")", "\n", "\n", "group", ".", "add", "(", "'--shard_size'", ",", "'-shard_size'", ",", "type", "=", "int", ",", "default", "=", "1000000", ",", "\n", "help", "=", "\"\"\"Divide src_corpus and tgt_corpus into\n                     smaller multiple src_copus and tgt corpus files, then\n                     build shards, each shard will have\n                     opt.shard_size samples except last shard.\n                     shard_size=0 means no segmentation\n                     shard_size>0 means segment dataset into multiple shards,\n                     each shard has shard_size samples\"\"\"", ")", "\n", "\n", "# Dictionary options, for text corpus", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Vocab'", ")", "\n", "group", ".", "add", "(", "'--src_vocab_size'", ",", "'-src_vocab_size'", ",", "type", "=", "int", ",", "default", "=", "50000", ",", "\n", "help", "=", "\"Size of the source vocabulary\"", ")", "\n", "group", ".", "add", "(", "'--tgt_vocab_size'", ",", "'-tgt_vocab_size'", ",", "type", "=", "int", ",", "default", "=", "50000", ",", "\n", "help", "=", "\"Size of the target vocabulary\"", ")", "\n", "group", ".", "add", "(", "'--tgt2_vocab_size'", ",", "'-tgt2_vocab_size'", ",", "type", "=", "int", ",", "default", "=", "50000", ",", "\n", "help", "=", "\"Size of the target2 vocabulary\"", ")", "\n", "\n", "\n", "group", ".", "add", "(", "'--src_words_min_frequency'", ",", "\n", "'-src_words_min_frequency'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "group", ".", "add", "(", "'--tgt_words_min_frequency'", ",", "\n", "'-tgt_words_min_frequency'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "group", ".", "add", "(", "'--tgt2_words_min_frequency'", ",", "\n", "'-tgt2_words_min_frequency'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "group", ".", "add", "(", "'--share_vocab'", ",", "'-share_vocab'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Share source and target vocabulary\"", ")", "\n", "\n", "# Truncation options, for text corpus", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Pruning'", ")", "\n", "group", ".", "add", "(", "'--src_seq_length'", ",", "'-src_seq_length'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "\n", "help", "=", "\"Maximum source sequence length\"", ")", "\n", "group", ".", "add", "(", "'--src_seq_length_trunc'", ",", "'-src_seq_length_trunc'", ",", "\n", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "\"Truncate source sequence length.\"", ")", "\n", "group", ".", "add", "(", "'--tgt_seq_length'", ",", "'-tgt_seq_length'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "\n", "help", "=", "\"Maximum target sequence length to keep.\"", ")", "\n", "group", ".", "add", "(", "'--tgt_seq_length_trunc'", ",", "'-tgt_seq_length_trunc'", ",", "\n", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "\"Truncate target sequence length.\"", ")", "\n", "group", ".", "add", "(", "'--lower'", ",", "'-lower'", ",", "action", "=", "'store_true'", ",", "help", "=", "'lowercase data'", ")", "\n", "\n", "# Data processing options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Random'", ")", "\n", "group", ".", "add", "(", "'--shuffle'", ",", "'-shuffle'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "\"Shuffle data\"", ")", "\n", "group", ".", "add", "(", "'--seed'", ",", "'-seed'", ",", "type", "=", "int", ",", "default", "=", "3435", ",", "\n", "help", "=", "\"Random seed\"", ")", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Logging'", ")", "\n", "group", ".", "add", "(", "'--report_every'", ",", "'-report_every'", ",", "type", "=", "int", ",", "default", "=", "100000", ",", "\n", "help", "=", "\"Report status every this many sentences\"", ")", "\n", "group", ".", "add", "(", "'--log_file'", ",", "'-log_file'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"Output logs to a file under this path.\"", ")", "\n", "group", ".", "add", "(", "'--log_file_level'", ",", "'-log_file_level'", ",", "type", "=", "str", ",", "\n", "default", "=", "\"0\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.opts.train_opts": [[157, 356], ["parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add_argument"], "function", ["None"], ["", "def", "train_opts", "(", "parser", ")", ":", "\n", "    ", "\"\"\" Training and saving options \"\"\"", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'General'", ")", "\n", "group", ".", "add", "(", "'--data'", ",", "'-data'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"\"\"Path prefix to the \".train.pt\" and\n                       \".valid.pt\" file path from preprocess.py\"\"\"", ")", "\n", "\n", "group", ".", "add", "(", "'--save_model'", ",", "'-save_model'", ",", "default", "=", "'model'", ",", "\n", "help", "=", "\"\"\"Model filename (the model will be saved as\n                       <save_model>_N.pt where N is the number\n                       of steps\"\"\"", ")", "\n", "\n", "group", ".", "add", "(", "'--save_checkpoint_steps'", ",", "'-save_checkpoint_steps'", ",", "\n", "type", "=", "int", ",", "default", "=", "5000", ",", "\n", "help", "=", "\"\"\"Save a checkpoint every X steps\"\"\"", ")", "\n", "group", ".", "add", "(", "'--keep_checkpoint'", ",", "'-keep_checkpoint'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"\"\"Keep X checkpoints (negative: keep all)\"\"\"", ")", "\n", "\n", "# GPU", "\n", "group", ".", "add", "(", "'--gpuid'", ",", "'-gpuid'", ",", "default", "=", "[", "]", ",", "nargs", "=", "'*'", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Deprecated see world_size and gpu_ranks.\"", ")", "\n", "group", ".", "add", "(", "'--gpu_ranks'", ",", "'-gpu_ranks'", ",", "default", "=", "[", "]", ",", "nargs", "=", "'*'", ",", "type", "=", "int", ",", "\n", "help", "=", "\"list of ranks of each process.\"", ")", "\n", "group", ".", "add", "(", "'--world_size'", ",", "'-world_size'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"total number of distributed processes.\"", ")", "\n", "group", ".", "add", "(", "'--gpu_backend'", ",", "'-gpu_backend'", ",", "\n", "default", "=", "\"nccl\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Type of torch distributed backend\"", ")", "\n", "group", ".", "add", "(", "'--gpu_verbose_level'", ",", "'-gpu_verbose_level'", ",", "default", "=", "0", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Gives more info on each process per GPU.\"", ")", "\n", "group", ".", "add", "(", "'--master_ip'", ",", "'-master_ip'", ",", "default", "=", "\"localhost\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"IP of master for torch.distributed training.\"", ")", "\n", "group", ".", "add", "(", "'--master_port'", ",", "'-master_port'", ",", "default", "=", "10000", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Port of master for torch.distributed training.\"", ")", "\n", "\n", "group", ".", "add", "(", "'--seed'", ",", "'-seed'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"\"\"Random seed used for the experiments\n                       reproducibility.\"\"\"", ")", "\n", "\n", "# Init options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Initialization'", ")", "\n", "group", ".", "add", "(", "'--param_init'", ",", "'-param_init'", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "\n", "help", "=", "\"\"\"Parameters are initialized over uniform distribution\n                       with support (-param_init, param_init).\n                       Use 0 to not use initialization\"\"\"", ")", "\n", "group", ".", "add", "(", "'--param_init_glorot'", ",", "'-param_init_glorot'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Init parameters with xavier_uniform.\n                       Required for transfomer.\"\"\"", ")", "\n", "\n", "group", ".", "add", "(", "'--train_from'", ",", "'-train_from'", ",", "default", "=", "''", ",", "type", "=", "str", ",", "\n", "help", "=", "\"\"\"If training from a checkpoint then this is the\n                       path to the pretrained model's state_dict.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--reset_optim'", ",", "'-reset_optim'", ",", "default", "=", "'none'", ",", "\n", "choices", "=", "[", "'none'", ",", "'all'", ",", "'states'", ",", "'keep_states'", "]", ",", "\n", "help", "=", "\"\"\"Optimization resetter when train_from.\"\"\"", ")", "\n", "\n", "# Pretrained word vectors", "\n", "group", ".", "add", "(", "'--pre_word_vecs_enc'", ",", "'-pre_word_vecs_enc'", ",", "\n", "help", "=", "\"\"\"If a valid path is specified, then this will load\n                       pretrained word embeddings on the encoder side.\n                       See README for specific formatting instructions.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--pre_word_vecs_dec'", ",", "'-pre_word_vecs_dec'", ",", "\n", "help", "=", "\"\"\"If a valid path is specified, then this will load\n                       pretrained word embeddings on the decoder side.\n                       See README for specific formatting instructions.\"\"\"", ")", "\n", "# Fixed word vectors", "\n", "group", ".", "add", "(", "'--fix_word_vecs_enc'", ",", "'-fix_word_vecs_enc'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Fix word embeddings on the encoder side.\"", ")", "\n", "group", ".", "add", "(", "'--fix_word_vecs_dec'", ",", "'-fix_word_vecs_dec'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Fix word embeddings on the decoder side.\"", ")", "\n", "\n", "# Optimization options", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Optimization- Type'", ")", "\n", "group", ".", "add", "(", "'--batch_size'", ",", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "64", ",", "\n", "help", "=", "'Maximum batch size for training task'", ")", "\n", "group", ".", "add", "(", "'--batch_size2'", ",", "'-batch_size2'", ",", "type", "=", "int", ",", "default", "=", "64", ",", "\n", "help", "=", "'Maximum batch size for training task2'", ")", "\n", "group", ".", "add", "(", "'--batch_type'", ",", "'-batch_type'", ",", "default", "=", "'sents'", ",", "\n", "choices", "=", "[", "\"sents\"", ",", "\"tokens\"", "]", ",", "\n", "help", "=", "\"\"\"Batch grouping for batch_size. Standard\n                               is sents. Tokens will do dynamic batching\"\"\"", ")", "\n", "group", ".", "add", "(", "'--normalization'", ",", "'-normalization'", ",", "default", "=", "'sents'", ",", "\n", "choices", "=", "[", "\"sents\"", ",", "\"tokens\"", "]", ",", "\n", "help", "=", "'Normalization method of the gradient.'", ")", "\n", "group", ".", "add", "(", "'--accum_count'", ",", "'-accum_count'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "\"\"\"Accumulate gradient this many times.\n                       Approximately equivalent to updating\n                       batch_size * accum_count batches at once.\n                       Recommended for Transformer.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--valid_steps'", ",", "'-valid_steps'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "\n", "help", "=", "'Perfom validation every X steps'", ")", "\n", "group", ".", "add", "(", "'--valid_batch_size'", ",", "'-valid_batch_size'", ",", "type", "=", "int", ",", "default", "=", "32", ",", "\n", "help", "=", "'Maximum batch size for validation'", ")", "\n", "group", ".", "add", "(", "'--max_generator_batches'", ",", "'-max_generator_batches'", ",", "\n", "type", "=", "int", ",", "default", "=", "32", ",", "\n", "help", "=", "\"\"\"Maximum batches of words in a sequence to run\n                        the generator on in parallel. Higher is faster, but\n                        uses more memory.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--train_steps'", ",", "'-train_steps'", ",", "type", "=", "int", ",", "default", "=", "100000", ",", "\n", "help", "=", "'Number of training steps'", ")", "\n", "group", ".", "add", "(", "'--train_steps2'", ",", "'-train_steps2'", ",", "type", "=", "int", ",", "default", "=", "100000", ",", "\n", "help", "=", "'Number of training steps'", ")", "\n", "group", ".", "add", "(", "'--epochs'", ",", "'-epochs'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Deprecated epochs see train_steps'", ")", "\n", "group", ".", "add", "(", "'--optim'", ",", "'-optim'", ",", "default", "=", "'sgd'", ",", "\n", "choices", "=", "[", "'sgd'", ",", "'adagrad'", ",", "'adadelta'", ",", "'adam'", ",", "\n", "'sparseadam'", "]", ",", "\n", "help", "=", "\"\"\"Optimization method.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--adagrad_accumulator_init'", ",", "'-adagrad_accumulator_init'", ",", "\n", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "\"\"\"Initializes the accumulator values in adagrad.\n                       Mirrors the initial_accumulator_value option\n                       in the tensorflow adagrad (use 0.1 for their default).\n                       \"\"\"", ")", "\n", "group", ".", "add", "(", "'--max_grad_norm'", ",", "'-max_grad_norm'", ",", "type", "=", "float", ",", "default", "=", "5", ",", "\n", "help", "=", "\"\"\"If the norm of the gradient vector exceeds this,\n                       renormalize it to have the norm equal to\n                       max_grad_norm\"\"\"", ")", "\n", "group", ".", "add", "(", "'--dropout'", ",", "'-dropout'", ",", "type", "=", "float", ",", "default", "=", "0.3", ",", "\n", "help", "=", "\"Dropout probability; applied in LSTM stacks.\"", ")", "\n", "group", ".", "add", "(", "'--truncated_decoder'", ",", "'-truncated_decoder'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "\"\"\"Truncated bptt.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--adam_beta1'", ",", "'-adam_beta1'", ",", "type", "=", "float", ",", "default", "=", "0.9", ",", "\n", "help", "=", "\"\"\"The beta1 parameter used by Adam.\n                       Almost without exception a value of 0.9 is used in\n                       the literature, seemingly giving good results,\n                       so we would discourage changing this value from\n                       the default without due consideration.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--adam_beta2'", ",", "'-adam_beta2'", ",", "type", "=", "float", ",", "default", "=", "0.999", ",", "\n", "help", "=", "\"\"\"The beta2 parameter used by Adam.\n                       Typically a value of 0.999 is recommended, as this is\n                       the value suggested by the original paper describing\n                       Adam, and is also the value adopted in other frameworks\n                       such as Tensorflow and Kerras, i.e. see:\n                       https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer\n                       https://keras.io/optimizers/ .\n                       Whereas recently the paper \"Attention is All You Need\"\n                       suggested a value of 0.98 for beta2, this parameter may\n                       not work well for normal models / default\n                       baselines.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--label_smoothing'", ",", "'-label_smoothing'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "\n", "help", "=", "\"\"\"Label smoothing value epsilon.\n                       Probabilities of all non-true labels\n                       will be smoothed by epsilon / (vocab_size - 1).\n                       Set to zero to turn off label smoothing.\n                       For more detailed information, see:\n                       https://arxiv.org/abs/1512.00567\"\"\"", ")", "\n", "# learning rate", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Optimization- Rate'", ")", "\n", "group", ".", "add", "(", "'--learning_rate'", ",", "'-learning_rate'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "\"\"\"Starting learning rate.\n                       Recommended settings: sgd = 1, adagrad = 0.1,\n                       adadelta = 1, adam = 0.001\"\"\"", ")", "\n", "group", ".", "add", "(", "'--learning_rate2'", ",", "'-learning_rate2'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "\"\"\"Starting learning rate.\n                       Recommended settings: sgd = 1, adagrad = 0.1,\n                       adadelta = 1, adam = 0.001\"\"\"", ")", "\n", "group", ".", "add", "(", "'--learning_rate_decay'", ",", "'-learning_rate_decay'", ",", "\n", "type", "=", "float", ",", "default", "=", "0.5", ",", "\n", "help", "=", "\"\"\"If update_learning_rate, decay learning rate by\n                       this much if (i) perplexity does not decrease on the\n                       validation set or (ii) steps have gone past\n                       start_decay_steps\"\"\"", ")", "\n", "group", ".", "add", "(", "'--start_decay_steps'", ",", "'-start_decay_steps'", ",", "\n", "type", "=", "int", ",", "default", "=", "50000", ",", "\n", "help", "=", "\"\"\"Start decaying every decay_steps after\n                       start_decay_steps\"\"\"", ")", "\n", "group", ".", "add", "(", "'--decay_steps'", ",", "'-decay_steps'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "\n", "help", "=", "\"\"\"Decay every decay_steps\"\"\"", ")", "\n", "\n", "group", ".", "add", "(", "'--decay_method'", ",", "'-decay_method'", ",", "type", "=", "str", ",", "default", "=", "\"none\"", ",", "\n", "choices", "=", "[", "'noam'", ",", "'none'", "]", ",", "help", "=", "\"Use a custom decay rate.\"", ")", "\n", "group", ".", "add", "(", "'--warmup_steps'", ",", "'-warmup_steps'", ",", "type", "=", "int", ",", "default", "=", "4000", ",", "\n", "help", "=", "\"\"\"Number of warmup steps for custom decay.\"\"\"", ")", "\n", "group", ".", "add", "(", "'--warmup_steps2'", ",", "'-warmup_steps2'", ",", "type", "=", "int", ",", "default", "=", "4000", ",", "\n", "help", "=", "\"\"\"Number of warmup steps for custom decay.\"\"\"", ")", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Logging'", ")", "\n", "group", ".", "add", "(", "'--report_every'", ",", "'-report_every'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "\n", "help", "=", "\"Print stats at this interval.\"", ")", "\n", "group", ".", "add", "(", "'--log_file'", ",", "'-log_file'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"Output logs to a file under this path.\"", ")", "\n", "group", ".", "add", "(", "'--log_file_level'", ",", "'-log_file_level'", ",", "type", "=", "str", ",", "\n", "default", "=", "\"0\"", ")", "\n", "group", ".", "add", "(", "'--exp_host'", ",", "'-exp_host'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"Send logs to this crayon server.\"", ")", "\n", "group", ".", "add", "(", "'--exp'", ",", "'-exp'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"Name of the experiment for logging.\"", ")", "\n", "# Use TensorboardX for visualization during training", "\n", "group", ".", "add", "(", "'--tensorboard'", ",", "'-tensorboard'", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"\"\"Use tensorboardX for visualization during training.\n                       Must have the library tensorboardX.\"\"\"", ")", "\n", "group", ".", "add_argument", "(", "\"-tensorboard_log_dir\"", ",", "type", "=", "str", ",", "\n", "default", "=", "\"runs/onmt\"", ",", "\n", "help", "=", "\"\"\"Log directory for Tensorboard.\n                       This is also the name of the run.\n                       \"\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.opts.translate_opts": [[357, 422], ["parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group.add", "parser.add_argument_group", "parser.add_argument_group.add", "parser.add_argument_group.add"], "function", ["None"], ["", "def", "translate_opts", "(", "parser", ")", ":", "\n", "    ", "\"\"\" Translation / inference options \"\"\"", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Model'", ")", "\n", "group", ".", "add", "(", "'--model'", ",", "'-model'", ",", "dest", "=", "'models'", ",", "metavar", "=", "'MODEL'", ",", "\n", "nargs", "=", "'+'", ",", "type", "=", "str", ",", "default", "=", "[", "]", ",", "\n", "help", "=", "'Path to model .pt file(s). '", "\n", "'Multiple models can be specified, '", "\n", "'for ensemble decoding.'", ")", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Data'", ")", "\n", "\n", "group", ".", "add", "(", "'--src'", ",", "'-src'", ",", "required", "=", "True", ",", "\n", "help", "=", "\"\"\"Source sequence to decode (one line per\n                       sequence)\"\"\"", ")", "\n", "group", ".", "add", "(", "'--task_type'", ",", "'-task_type'", ",", "default", "=", "'task2'", ",", "\n", "help", "=", "\"\"\"Use Decoder of task or task2\"\"\"", ")", "\n", "group", ".", "add", "(", "'--tgt'", ",", "'-tgt'", ",", "\n", "help", "=", "'True target sequence (optional)'", ")", "\n", "group", ".", "add", "(", "'--output'", ",", "'-output'", ",", "default", "=", "'pred.txt'", ",", "\n", "help", "=", "\"\"\"Path to output the predictions (each line will\n                       be the decoded sequence\"\"\"", ")", "\n", "\n", "group", ".", "add", "(", "'--share_vocab'", ",", "'-share_vocab'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Share source and target vocabulary\"", ")", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Beam'", ")", "\n", "group", ".", "add", "(", "'--beam_size'", ",", "'-beam_size'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'Beam size'", ")", "\n", "group", ".", "add", "(", "'--min_length'", ",", "'-min_length'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Minimum prediction length'", ")", "\n", "group", ".", "add", "(", "'--max_length'", ",", "'-max_length'", ",", "type", "=", "int", ",", "default", "=", "100", ",", "\n", "help", "=", "'Maximum prediction length.'", ")", "\n", "group", ".", "add", "(", "'--decode_extra_length'", ",", "'-decode_extra_length'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "\n", "help", "=", "'Maximum extra prediction length.'", ")", "\n", "group", ".", "add", "(", "'--decode_min_length'", ",", "'-decode_min_length'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"\"\"Minimum extra prediction length. \n                    -1: no miximum limitation on the prediction length;\n                    0: minimum length is the source length\n                    otherwise minimum length is source length - this many\"\"\"", ")", "\n", "group", ".", "add", "(", "'--minimal_relative_prob'", ",", "'-minimal_relative_prob'", ",", "type", "=", "float", ",", "default", "=", "0.", ",", "\n", "help", "=", "\"\"\"Minimum relative probability [0, 1). \n                    0: switch this off\n                    otherwise only predicted words with probability larger than the maximum word probability multiplying this many are allowed\"\"\"", ")", "\n", "\n", "# Alpha value for Google Length penalty", "\n", "# Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7", "\n", "group", ".", "add", "(", "'--alpha'", ",", "'-alpha'", ",", "type", "=", "float", ",", "default", "=", "0.6", ",", "\n", "help", "=", "\"\"\"Google NMT length penalty parameter\n                        (higher = longer generation)\"\"\"", ")", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Logging'", ")", "\n", "group", ".", "add", "(", "'--verbose'", ",", "'-verbose'", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "'Print scores and predictions for each sentence'", ")", "\n", "group", ".", "add", "(", "'--log_file'", ",", "'-log_file'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"Output logs to a file under this path.\"", ")", "\n", "group", ".", "add", "(", "'--log_file_level'", ",", "'-log_file_level'", ",", "type", "=", "str", ",", "\n", "default", "=", "\"0\"", ")", "\n", "group", ".", "add", "(", "'--dump_beam'", ",", "'-dump_beam'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "'File to dump beam information to.'", ")", "\n", "\n", "group", "=", "parser", ".", "add_argument_group", "(", "'Efficiency'", ")", "\n", "group", ".", "add", "(", "'--batch_size'", ",", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "4444", ",", "\n", "help", "=", "'Batch size'", ")", "\n", "group", ".", "add", "(", "'--gpu'", ",", "'-gpu'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"Device to run on\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.__init__": [[14, 38], ["torch.zeros", "torch.zeros", "math.log", "torch.zeros", "torch.ones", "beam.Beam.alive_seq.size"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ",", "decode_length", ",", "bos_id", ",", "eos_id", ",", "minimal_length", "=", "0", ",", "alpha", "=", "0.6", ",", "minimal_relative_prob", "=", "0.0", ",", "stop_early", "=", "True", ",", "device", "=", "False", ")", ":", "\n", "    ", "self", ".", "size", "=", "size", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "stop_early", "=", "stop_early", "\n", "self", ".", "decode_length", "=", "decode_length", "\n", "self", ".", "minimal_length", "=", "minimal_length", "\n", "self", ".", "_done", "=", "False", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "minimal_score", "=", "-", "1", "*", "Constants", ".", "INF", "\n", "self", ".", "eos_id", "=", "eos_id", "\n", "self", ".", "minimal_relative_log_prob", "=", "math", ".", "log", "(", "minimal_relative_prob", ")", "if", "minimal_relative_prob", ">", "0", "else", "0.0", "\n", "\n", "self", ".", "alive_seq", "=", "torch", ".", "zeros", "(", "(", "size", ",", "1", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "device", ")", "\n", "self", ".", "alive_seq", "[", "0", "]", "[", "0", "]", "=", "bos_id", "\n", "# alive_seq: (size, 1)", "\n", "self", ".", "alive_log_prob", "=", "torch", ".", "zeros", "(", "(", "size", ",", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "# alive_log_prob: (size, )", "\n", "\n", "# The score for each finished translation on the beam", "\n", "self", ".", "finished_seq", "=", "torch", ".", "zeros", "(", "self", ".", "alive_seq", ".", "size", "(", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "device", ")", "+", "self", ".", "eos_id", "\n", "# finished_seq: (size, 1)", "\n", "self", ".", "finished_scores", "=", "torch", ".", "ones", "(", "(", "size", ",", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "*", "self", ".", "minimal_score", "\n", "# finished_scores: (size, 1)", "\n", "self", ".", "finished_flags", "=", "self", ".", "finished_scores", ">", "0", "\n", "# finished_flags: (size, 1)", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.is_finished": [[40, 58], ["math.pow", "torch.min", "torch.lt", "torch.sum", "beam.Beam.alive_seq.size", "beam.Beam.finished_flags.type", "at_least_one_finished.type"], "methods", ["None"], ["", "def", "is_finished", "(", "self", ")", ":", "\n", "    ", "if", "not", "self", ".", "stop_early", ":", "\n", "      ", "return", "self", ".", "alive_seq", ".", "size", "(", "1", ")", "<", "self", ".", "decode_length", "\n", "\n", "", "max_length_penalty", "=", "math", ".", "pow", "(", "(", "5.", "+", "self", ".", "decode_length", ")", "/", "6.", ",", "self", ".", "alpha", ")", "\n", "lower_bound_alive_scores", "=", "self", ".", "alive_log_prob", "[", "0", "]", "/", "max_length_penalty", "\n", "# lower_bound_alive_scores: scalar", "\n", "lowest_score_of_fininshed_in_finished", "=", "torch", ".", "min", "(", "self", ".", "finished_scores", "*", "self", ".", "finished_flags", ".", "type", "(", "torch", ".", "float", ")", ")", "\n", "# non-zero value (must be less than 0) if at least one hypothesis is finished, ", "\n", "# 0 if all hypothesis are not finished", "\n", "at_least_one_finished", "=", "torch", ".", "sum", "(", "self", ".", "finished_flags", ")", ">", "0", "\n", "lowest_score_of_fininshed_in_finished", "+=", "(", "\n", "(", "1.", "-", "at_least_one_finished", ".", "type", "(", "torch", ".", "float", ")", ")", "*", "self", ".", "minimal_score", ")", "\n", "\n", "# non-zero value (must be less than 0) if at least one hypothesis is finished,", "\n", "# -inf if all hypothesis are not finished", "\n", "self", ".", "_done", "=", "torch", ".", "lt", "(", "lower_bound_alive_scores", ",", "lowest_score_of_fininshed_in_finished", ")", "\n", "return", "self", ".", "done", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam._compute_topk_scores_and_seq": [[59, 70], ["scores.topk", "torch.index_select", "torch.index_select", "torch.index_select"], "methods", ["None"], ["", "def", "_compute_topk_scores_and_seq", "(", "self", ",", "sequences", ",", "scores", ",", "scores_to_gather", ",", "flags", ")", ":", "\n", "# sequences: (size * 2, ? + 1)", "\n", "# scores: (size * 2,)", "\n", "# scores_to_gather(size * 2,)", "\n", "# flags(size * 2,)", "\n", "    ", "_", ",", "topk_ids", "=", "scores", ".", "topk", "(", "self", ".", "size", ",", "0", ",", "True", ",", "True", ")", "\n", "# topk_ids: (size,)", "\n", "topk_seq", "=", "torch", ".", "index_select", "(", "sequences", ",", "0", ",", "topk_ids", ")", "\n", "top_log_prob", "=", "torch", ".", "index_select", "(", "scores_to_gather", ",", "0", ",", "topk_ids", ")", "\n", "top_flags", "=", "torch", ".", "index_select", "(", "flags", ",", "0", ",", "topk_ids", ")", "\n", "return", "topk_seq", ",", "top_log_prob", ",", "top_flags", ",", "topk_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.grow_alive": [[72, 81], ["beam.Beam._compute_topk_scores_and_seq", "curr_finished.type"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam._compute_topk_scores_and_seq"], ["", "def", "grow_alive", "(", "self", ",", "curr_seq", ",", "curr_scores", ",", "curr_log_prob", ",", "curr_finished", ")", ":", "\n", "# curr_seq: (size * 2, ? + 1)", "\n", "# curr_sores: (size * 2, ? + 1)", "\n", "# curr_log_prob: (size * 2, ? + 1)", "\n", "# finished_flag: (size * 2,) 1 for finished and 0 for not finished", "\n", "    ", "masked_curr_scores", "=", "curr_scores", "+", "curr_finished", ".", "type", "(", "torch", ".", "float", ")", "*", "self", ".", "minimal_score", "\n", "# curr_sores: (size * 2,) -inf for finished hypothesis, 0 for not finished", "\n", "\n", "return", "self", ".", "_compute_topk_scores_and_seq", "(", "curr_seq", ",", "masked_curr_scores", ",", "curr_log_prob", ",", "curr_finished", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.grow_finished": [[82, 102], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.size", "beam.Beam._compute_topk_scores_and_seq", "curr_finished.type", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam._compute_topk_scores_and_seq"], ["", "def", "grow_finished", "(", "self", ",", "curr_seq", ",", "curr_scores", ",", "curr_finished", ")", ":", "\n", "# curr_seq: (size * 2, ? + 1)", "\n", "# curr_sores: (size * 2, ? + 1)", "\n", "# finished_flag: (size * 2,) 1 for finished and 0 for not finished", "\n", "    ", "masked_curr_scores", "=", "curr_scores", "+", "(", "1.", "-", "curr_finished", ".", "type", "(", "torch", ".", "float", ")", ")", "*", "self", ".", "minimal_score", "\n", "# curr_sores: (size * 2,) 0 for finished hypothesis, -inf for not finished ", "\n", "\n", "finished_seq", "=", "torch", ".", "cat", "(", "(", "self", ".", "finished_seq", ",", "torch", ".", "zeros", "(", "(", "self", ".", "size", ",", "1", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "self", ".", "device", ")", "+", "self", ".", "eos_id", ")", ",", "dim", "=", "1", ")", "\n", "# finished_seq: (size, ? + 1)", "\n", "curr_finished_seq", "=", "torch", ".", "cat", "(", "(", "finished_seq", ",", "curr_seq", ")", ",", "dim", "=", "0", ")", "\n", "# curr_finished_seq: (size * 2, ? + 1) error: should be (size * 3, ? + 1), below are the same", "\n", "curr_finished_scores", "=", "torch", ".", "cat", "(", "(", "self", ".", "finished_scores", ",", "masked_curr_scores", ")", ",", "dim", "=", "0", ")", "\n", "# curr_finished_scores: (size * 2, ? + 1)", "\n", "curr_finished_flags", "=", "torch", ".", "cat", "(", "(", "self", ".", "finished_flags", ",", "curr_finished", ")", ",", "dim", "=", "0", ")", "\n", "# curr_finished_flags: (size * 2, ? + 1)", "\n", "\n", "if", "(", "curr_finished_seq", ".", "size", "(", "1", ")", "<", "self", ".", "minimal_length", ")", ":", "\n", "      ", "return", "finished_seq", ",", "self", ".", "finished_scores", ",", "self", ".", "finished_flags", ",", "None", "\n", "", "else", ":", "\n", "      ", "return", "self", ".", "_compute_topk_scores_and_seq", "(", "curr_finished_seq", ",", "curr_finished_scores", ",", "curr_finished_scores", ",", "curr_finished_flags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.advance": [[103, 157], ["word_prob.size", "math.pow", "curr_scores.view", "curr_scores.view.topk", "torch.index_select", "torch.cat", "topk_ids.eq", "beam.Beam.grow_alive", "beam.Beam.grow_finished", "torch.index_select", "beam.Beam.is_finished", "word_prob.topk", "word_prob.topk", "top_2probs.exp", "beam.Beam.alive_seq.size", "beam.Beam.alive_log_prob.view", "topk_ids.view", "torch.lt().type", "beam.Beam.alive_seq.size", "torch.lt"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.grow_alive", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.grow_finished", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.is_finished"], ["", "", "def", "advance", "(", "self", ",", "word_prob", ")", ":", "\n", "    ", "\"Update beam status and check if finished or not.\"", "\n", "\n", "if", "(", "self", ".", "minimal_relative_log_prob", "!=", "0.0", ")", ":", "\n", "      ", "top_probs", ",", "_", "=", "word_prob", ".", "topk", "(", "1", ",", "1", ",", "True", ",", "True", ")", "\n", "top_2probs", ",", "_", "=", "word_prob", ".", "topk", "(", "2", ",", "1", ",", "True", ",", "True", ")", "\n", "probs", "=", "top_2probs", ".", "exp", "(", ")", "\n", "word_prob", "=", "word_prob", "+", "torch", ".", "lt", "(", "word_prob", ",", "top_probs", "+", "self", ".", "minimal_relative_log_prob", ")", ".", "type", "(", "torch", ".", "float", ")", "*", "self", ".", "minimal_score", "\n", "\n", "# word_prob: (size, vocab_size)", "\n", "", "if", "self", ".", "alive_seq", ".", "size", "(", ")", "[", "1", "]", "==", "1", ":", "\n", "# predict the first word", "\n", "      ", "log_probs", "=", "word_prob", "[", "0", "]", "\n", "", "else", ":", "\n", "      ", "log_probs", "=", "word_prob", "+", "self", ".", "alive_log_prob", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "# log_probs: (size, vocab_size)", "\n", "\n", "", "num_words", "=", "word_prob", ".", "size", "(", "1", ")", "\n", "\n", "length_penalty", "=", "math", ".", "pow", "(", "(", "5.", "+", "self", ".", "alive_seq", ".", "size", "(", "1", ")", "/", "6.", ")", ",", "self", ".", "alpha", ")", "\n", "curr_scores", "=", "log_probs", "/", "length_penalty", "\n", "# curr_scores: (size, vocab_size)", "\n", "flat_curr_scores", "=", "curr_scores", ".", "view", "(", "-", "1", ")", "\n", "\n", "topk_scores", ",", "topk_ids", "=", "flat_curr_scores", ".", "topk", "(", "self", ".", "size", "*", "2", ",", "0", ",", "True", ",", "True", ")", "\n", "#topk_scores, topk_ids = flat_curr_scores.topk(self.size, 0, True, True)", "\n", "# TODO: replace this code and set beam-size=1, makes the beam search -> greedy search", "\n", "\n", "# topk_scores: (size * 2,)", "\n", "# topk_ids: (size * 2, )", "\n", "\n", "topk_log_probs", "=", "topk_scores", "*", "length_penalty", "\n", "# topk_log_probs: (size * 2,)", "\n", "\n", "topk_beam_index", "=", "topk_ids", "//", "num_words", "\n", "topk_ids", "%=", "num_words", "\n", "# topk_beam_index: (size * 2,)", "\n", "# topk_ids: (size * 2,)", "\n", "\n", "topk_seq", "=", "torch", ".", "index_select", "(", "self", ".", "alive_seq", ",", "0", ",", "topk_beam_index", ")", "\n", "# topk_seq: (size * 2, ?)", "\n", "topk_seq", "=", "torch", ".", "cat", "(", "(", "topk_seq", ",", "topk_ids", ".", "view", "(", "-", "1", ",", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "# topk_seq: (size * 2, ? + 1)", "\n", "\n", "topk_finished", "=", "topk_ids", ".", "eq", "(", "self", ".", "eos_id", ")", "\n", "# topk_finished: (size * 2,)", "\n", "\n", "self", ".", "alive_seq", ",", "self", ".", "alive_log_prob", ",", "_", ",", "top_topk_beam_index", "=", "self", ".", "grow_alive", "(", "topk_seq", ",", "topk_scores", ",", "topk_log_probs", ",", "topk_finished", ")", "\n", "self", ".", "finished_seq", ",", "self", ".", "finished_scores", ",", "self", ".", "finished_flags", ",", "_", "=", "self", ".", "grow_finished", "(", "topk_seq", ",", "topk_scores", ",", "topk_finished", ")", "\n", "\n", "self", ".", "prev_ks", "=", "torch", ".", "index_select", "(", "topk_beam_index", ",", "0", ",", "top_topk_beam_index", ")", "\n", "# self.prev_ks: (size,)", "\n", "\n", "return", "self", ".", "is_finished", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.get_current_state": [[158, 161], ["None"], "methods", ["None"], ["", "def", "get_current_state", "(", "self", ")", ":", "\n", "    ", "\"Get the outputs for the current timestep.\"", "\n", "return", "self", ".", "alive_seq", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.get_current_origin": [[162, 165], ["None"], "methods", ["None"], ["", "def", "get_current_origin", "(", "self", ")", ":", "\n", "    ", "\"Get the backpointers for the current timestep.\"", "\n", "return", "self", ".", "prev_ks", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.get_last_target_word": [[166, 168], ["None"], "methods", ["None"], ["", "def", "get_last_target_word", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "alive_seq", "[", ":", ",", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.done": [[169, 172], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "done", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_done", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.beam.Beam.get_best_hypothesis": [[173, 178], ["torch.sum", "beam.Beam.finished_seq[].data.cpu().numpy", "beam.Beam.finished_scores[].item", "beam.Beam.alive_seq[].data.cpu().numpy", "beam.Beam.alive_log_prob[].item", "beam.Beam.finished_seq[].data.cpu", "beam.Beam.alive_seq[].data.cpu"], "methods", ["None"], ["", "def", "get_best_hypothesis", "(", "self", ")", ":", "\n", "    ", "if", "torch", ".", "sum", "(", "self", ".", "finished_flags", ")", ">", "0", ":", "\n", "      ", "return", "self", ".", "finished_seq", "[", "0", ",", "1", ":", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "finished_scores", "[", "0", "]", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "      ", "return", "self", ".", "alive_seq", "[", "0", ",", "1", ":", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "alive_log_prob", "[", "0", "]", ".", "item", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoderLayer.__init__": [[16, 37], ["torch.Module.__init__", "onmt.sublayer.MultiHeadedAttention", "onmt.sublayer.MultiHeadedAttention", "onmt.sublayer.PositionwiseFeedForward", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.Dropout", "torch.Dropout", "transformer_decoder.TransformerDecoderLayer._get_attn_subsequent_mask", "transformer_decoder.TransformerDecoderLayer.register_buffer"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoderLayer._get_attn_subsequent_mask"], ["  ", "def", "__init__", "(", "self", ",", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ")", ":", "\n", "    ", "super", "(", "TransformerDecoderLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "self_attn", "=", "onmt", ".", "sublayer", ".", "MultiHeadedAttention", "(", "\n", "heads", ",", "d_model", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "context_attn", "=", "onmt", ".", "sublayer", ".", "MultiHeadedAttention", "(", "\n", "heads", ",", "d_model", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "feed_forward", "=", "PositionwiseFeedForward", "(", "d_model", ",", "d_ff", ",", "dropout", ")", "\n", "\n", "self", ".", "self_att_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "enc_att_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "ffn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "mask", "=", "self", ".", "_get_attn_subsequent_mask", "(", "MAX_SIZE", ")", "\n", "# Register self.mask as a buffer in TransformerDecoderLayer, so", "\n", "# it gets TransformerDecoderLayer's cuda behavior automatically.", "\n", "self", ".", "register_buffer", "(", "'mask'", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoderLayer.forward": [[38, 68], ["transformer_decoder.TransformerDecoderLayer.self_att_layer_norm", "transformer_decoder.TransformerDecoderLayer.self_attn", "transformer_decoder.TransformerDecoderLayer.enc_att_layer_norm", "transformer_decoder.TransformerDecoderLayer.context_attn", "transformer_decoder.TransformerDecoderLayer.ffn_layer_norm", "transformer_decoder.TransformerDecoderLayer.feed_forward", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "transformer_decoder.TransformerDecoderLayer.drop", "transformer_decoder.TransformerDecoderLayer.drop", "transformer_decoder.TransformerDecoderLayer.drop", "tgt_pad_mask.size", "tgt_pad_mask.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "memory_bank", ",", "src_pad_mask", ",", "tgt_pad_mask", ",", "\n", "layer_cache", "=", "None", ",", "step", "=", "None", ")", ":", "\n", "    ", "dec_mask", "=", "None", "\n", "if", "step", "is", "None", ":", "\n", "      ", "dec_mask", "=", "torch", ".", "gt", "(", "tgt_pad_mask", "+", "\n", "self", ".", "mask", "[", ":", ",", ":", "tgt_pad_mask", ".", "size", "(", "-", "1", ")", ",", "\n", ":", "tgt_pad_mask", ".", "size", "(", "-", "1", ")", "]", ",", "0", ")", "\n", "\n", "# do self attention", "\n", "", "input_norm", "=", "self", ".", "self_att_layer_norm", "(", "inputs", ")", "\n", "query", ",", "attn", "=", "self", ".", "self_attn", "(", "input_norm", ",", "input_norm", ",", "input_norm", ",", "\n", "mask", "=", "dec_mask", ",", "\n", "layer_cache", "=", "layer_cache", ",", "\n", "type", "=", "\"self\"", ")", "\n", "query", "=", "self", ".", "drop", "(", "query", ")", "+", "inputs", "\n", "\n", "# do encoding output attention", "\n", "query_norm", "=", "self", ".", "enc_att_layer_norm", "(", "query", ")", "\n", "mid", ",", "attn", "=", "self", ".", "context_attn", "(", "memory_bank", ",", "memory_bank", ",", "query_norm", ",", "\n", "mask", "=", "src_pad_mask", ",", "\n", "layer_cache", "=", "layer_cache", ",", "\n", "type", "=", "\"context\"", ")", "\n", "mid", "=", "self", ".", "drop", "(", "mid", ")", "+", "query", "\n", "\n", "# do ffn", "\n", "mid_norm", "=", "self", ".", "ffn_layer_norm", "(", "mid", ")", "\n", "output", "=", "self", ".", "feed_forward", "(", "mid_norm", ")", "\n", "output", "=", "self", ".", "drop", "(", "output", ")", "+", "mid", "\n", "\n", "return", "output", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoderLayer._get_attn_subsequent_mask": [[69, 74], ["numpy.triu().astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.triu", "numpy.ones"], "methods", ["None"], ["", "def", "_get_attn_subsequent_mask", "(", "self", ",", "size", ")", ":", "\n", "    ", "attn_shape", "=", "(", "1", ",", "size", ",", "size", ")", "\n", "subsequent_mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "attn_shape", ")", ",", "k", "=", "1", ")", ".", "astype", "(", "'uint8'", ")", "\n", "subsequent_mask", "=", "torch", ".", "from_numpy", "(", "subsequent_mask", ")", "\n", "return", "subsequent_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.__init__": [[77, 95], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.LayerNorm", "torch.LayerNorm", "transformer_decoder.TransformerDecoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "num_layers", ",", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ",", "embeddings", ",", "src_pad_id", "=", "None", ")", ":", "\n", "    ", "super", "(", "TransformerDecoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Basic attributes.", "\n", "self", ".", "decoder_type", "=", "'transformer'", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "embeddings", "=", "embeddings", "\n", "\n", "# Decoder State", "\n", "self", ".", "state", "=", "{", "}", "\n", "\n", "# Build TransformerDecoder.", "\n", "self", ".", "transformer_layers", "=", "nn", ".", "ModuleList", "(", "\n", "[", "TransformerDecoderLayer", "(", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ")", "\n", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "src_pad_id", "=", "src_pad_id", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.init_state": [[96, 101], ["None"], "methods", ["None"], ["", "def", "init_state", "(", "self", ",", "src", ",", "src_enc", ")", ":", "\n", "    ", "\"\"\" Init decoder state \"\"\"", "\n", "self", ".", "state", "[", "\"src\"", "]", "=", "src", "\n", "self", ".", "state", "[", "\"src_enc\"", "]", "=", "src_enc", "\n", "self", ".", "state", "[", "\"cache\"", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.map_state": [[102, 115], ["fn", "fn", "struct.items", "transformer_decoder.TransformerDecoder.map_state._recursive_map"], "methods", ["None"], ["", "def", "map_state", "(", "self", ",", "fn", ")", ":", "\n", "    ", "def", "_recursive_map", "(", "struct", ",", "batch_dim", "=", "0", ")", ":", "\n", "      ", "for", "k", ",", "v", "in", "struct", ".", "items", "(", ")", ":", "\n", "        ", "if", "v", "is", "not", "None", ":", "\n", "          ", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "_recursive_map", "(", "v", ")", "\n", "", "else", ":", "\n", "            ", "struct", "[", "k", "]", "=", "fn", "(", "v", ",", "batch_dim", ")", "\n", "\n", "", "", "", "", "self", ".", "state", "[", "\"src\"", "]", "=", "fn", "(", "self", ".", "state", "[", "\"src\"", "]", ",", "1", ")", "\n", "self", ".", "state", "[", "\"src_enc\"", "]", "=", "fn", "(", "self", ".", "state", "[", "\"src_enc\"", "]", ",", "1", ")", "\n", "if", "self", ".", "state", "[", "\"cache\"", "]", "is", "not", "None", ":", "\n", "      ", "_recursive_map", "(", "self", ".", "state", "[", "\"cache\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.detach_state": [[116, 121], ["transformer_decoder.TransformerDecoder.state[].detach"], "methods", ["None"], ["", "", "def", "detach_state", "(", "self", ")", ":", "\n", "    ", "try", ":", "\n", "      ", "self", ".", "state", "[", "\"src\"", "]", "=", "self", ".", "state", "[", "\"src\"", "]", ".", "detach", "(", ")", "\n", "", "except", "Exception", ":", "\n", "      ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.forward": [[122, 172], ["src.transpose", "tgt.transpose", "transformer_decoder.TransformerDecoder.embeddings", "transformer_decoder.TransformerDecoder.transpose().contiguous", "memory_bank.transpose().contiguous", "tgt.transpose.data.eq().unsqueeze", "range", "transformer_decoder.TransformerDecoder.layer_norm", "transformer_decoder.TransformerDecoder.transpose().contiguous", "attn.transpose().contiguous.transpose().contiguous.transpose().contiguous", "transformer_decoder.TransformerDecoder._init_cache", "transformer_decoder.TransformerDecoder.dim", "src.transpose.data.eq().unsqueeze", "src.transpose.data.eq().unsqueeze", "transformer_decoder.TransformerDecoder.transpose", "memory_bank.transpose", "tgt.transpose.data.eq", "transformer_decoder.TransformerDecoder.transpose", "attn.transpose().contiguous.transpose().contiguous.transpose", "src.transpose.data.eq", "src.transpose.data.eq"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder._init_cache"], ["", "", "def", "forward", "(", "self", ",", "tgt", ",", "step", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    See :obj:`onmt.modules.RNNDecoderBase.forward()`\n    \"\"\"", "\n", "if", "step", "==", "0", ":", "\n", "      ", "self", ".", "_init_cache", "(", "self", ".", "num_layers", ")", "\n", "\n", "", "src", "=", "self", ".", "state", "[", "\"src\"", "]", "\n", "memory_bank", "=", "self", ".", "state", "[", "\"src_enc\"", "]", "\n", "src_words", "=", "src", ".", "transpose", "(", "0", ",", "1", ")", "\n", "tgt_words", "=", "tgt", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n", "# Initialize return variables.", "\n", "attns", "=", "{", "\"std\"", ":", "[", "]", "}", "\n", "\n", "# Run the forward pass of the TransformerDecoder.", "\n", "emb", "=", "self", ".", "embeddings", "(", "tgt", ",", "step", "=", "step", ")", "\n", "assert", "emb", ".", "dim", "(", ")", "==", "3", "# len x batch x embedding_dim", "\n", "\n", "output", "=", "emb", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "src_memory_bank", "=", "memory_bank", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "pad_idx", "=", "self", ".", "embeddings", ".", "word_padding_idx", "\n", "tgt_pad_mask", "=", "tgt_words", ".", "data", ".", "eq", "(", "pad_idx", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, T_tgt]", "\n", "if", "self", ".", "src_pad_id", "is", "None", ":", "\n", "      ", "src_pad_mask", "=", "src_words", ".", "data", ".", "eq", "(", "pad_idx", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, T_src]", "\n", "", "else", ":", "\n", "      ", "src_pad_mask", "=", "src_words", ".", "data", ".", "eq", "(", "self", ".", "src_pad_id", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "      ", "output", ",", "attn", "=", "self", ".", "transformer_layers", "[", "i", "]", "(", "\n", "output", ",", "\n", "src_memory_bank", ",", "\n", "src_pad_mask", ",", "\n", "tgt_pad_mask", ",", "\n", "layer_cache", "=", "(", "\n", "self", ".", "state", "[", "\"cache\"", "]", "[", "\"layer_{}\"", ".", "format", "(", "i", ")", "]", "\n", "if", "step", "is", "not", "None", "else", "None", ")", ",", "\n", "step", "=", "step", ")", "\n", "\n", "", "output", "=", "self", ".", "layer_norm", "(", "output", ")", "\n", "\n", "# Process the result and update the attentions.", "\n", "dec_outs", "=", "output", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "attn", "=", "attn", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "attns", "[", "\"std\"", "]", "=", "attn", "\n", "\n", "# TODO change the way attns is returned dict => list or tuple (onnx)", "\n", "return", "dec_outs", ",", "attns", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder._init_cache": [[173, 184], ["range"], "methods", ["None"], ["", "def", "_init_cache", "(", "self", ",", "num_layers", ")", ":", "\n", "    ", "self", ".", "state", "[", "\"cache\"", "]", "=", "{", "}", "\n", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "      ", "layer_cache", "=", "{", "\n", "\"memory_keys\"", ":", "None", ",", "\n", "\"memory_values\"", ":", "None", "\n", "}", "\n", "layer_cache", "[", "\"self_keys\"", "]", "=", "None", "\n", "layer_cache", "[", "\"self_values\"", "]", "=", "None", "\n", "self", ".", "state", "[", "\"cache\"", "]", "[", "\"layer_{}\"", ".", "format", "(", "l", ")", "]", "=", "layer_cache", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.__init__": [[22, 42], ["torch.device", "torch.device", "torch.device", "torch.device", "cross_translator.Translator.model.to"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "model", ",", "fields", ",", "opt", ",", "out_file", "=", "None", ")", ":", "\n", "    ", "self", ".", "model", "=", "model", "\n", "self", ".", "fields", "=", "fields", "\n", "self", ".", "gpu", "=", "opt", ".", "gpu", "\n", "self", ".", "cuda", "=", "opt", ".", "gpu", ">", "-", "1", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "self", ".", "cuda", "else", "'cpu'", ")", "\n", "self", ".", "decode_extra_length", "=", "opt", ".", "decode_extra_length", "\n", "self", ".", "decode_min_length", "=", "opt", ".", "decode_min_length", "\n", "self", ".", "beam_size", "=", "opt", ".", "beam_size", "\n", "self", ".", "min_length", "=", "opt", ".", "min_length", "\n", "self", ".", "minimal_relative_prob", "=", "opt", ".", "minimal_relative_prob", "\n", "self", ".", "out_file", "=", "out_file", "\n", "self", ".", "tgt_eos_id", "=", "fields", "[", "\"tgt\"", "]", ".", "vocab", ".", "stoi", "[", "Constants", ".", "EOS_WORD", "]", "\n", "self", ".", "tgt_bos_id", "=", "fields", "[", "\"tgt\"", "]", ".", "vocab", ".", "stoi", "[", "Constants", ".", "BOS_WORD", "]", "\n", "self", ".", "tgt2_eos_id", "=", "fields", "[", "\"tgt2\"", "]", ".", "vocab", ".", "stoi", "[", "Constants", ".", "EOS_WORD", "]", "\n", "self", ".", "tgt2_bos_id", "=", "fields", "[", "\"tgt2\"", "]", ".", "vocab", ".", "stoi", "[", "Constants", ".", "BOS_WORD2", "]", "\n", "self", ".", "src_eos_id", "=", "fields", "[", "\"src\"", "]", ".", "vocab", ".", "stoi", "[", "Constants", ".", "EOS_WORD", "]", "\n", "self", ".", "task_type", "=", "opt", ".", "task_type", "\n", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.build_tokens": [[43, 63], ["len", "tokens.append", "vocab.itos[].replace"], "methods", ["None"], ["", "def", "build_tokens", "(", "self", ",", "idx", ",", "side", "=", "\"tgt\"", ")", ":", "\n", "    ", "assert", "side", "in", "[", "\"src\"", ",", "\"tgt\"", ",", "\"tgt2\"", "]", ",", "\"side should be either src or tgt\"", "\n", "vocab", "=", "self", ".", "fields", "[", "side", "]", ".", "vocab", "\n", "if", "side", "==", "\"tgt\"", ":", "\n", "      ", "eos_id", "=", "self", ".", "tgt_eos_id", "\n", "", "if", "side", "==", "\"tgt2\"", ":", "\n", "      ", "eos_id", "=", "self", ".", "tgt2_eos_id", "\n", "", "else", ":", "\n", "      ", "eos_id", "=", "self", ".", "src_eos_id", "\n", "", "tokens", "=", "[", "]", "\n", "for", "tok", "in", "idx", ":", "\n", "      ", "if", "tok", "==", "eos_id", ":", "\n", "        ", "break", "\n", "", "if", "tok", "<", "len", "(", "vocab", ")", ":", "\n", "# if self.task_type == 'task':", "\n", "#   tokens.append(vocab.itos[tok])", "\n", "# else:", "\n", "#   tokens.append(vocab.itos[tok].replace(\"~\", \"_\"))", "\n", "        ", "tokens", ".", "append", "(", "vocab", ".", "itos", "[", "tok", "]", ".", "replace", "(", "\"~\"", ",", "\"_\"", ")", ")", "\n", "", "", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.translate": [[64, 108], ["time.time", "print", "cross_translator.Translator.model.eval", "print", "enumerate", "cross_translator.Translator.translate_batch", "zip", "out_file.flush", "print", "len", "print", "cross_translator.Translator.build_tokens", "cross_translator.Translator.build_tokens", "out_file.write", "float", "str", "time.time"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.translate_batch", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.build_tokens", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.build_tokens"], ["", "def", "translate", "(", "self", ",", "src_data_iter", ",", "tgt_data_iter", ",", "batch_size", ",", "out_file", "=", "None", ")", ":", "\n", "\n", "    ", "def", "sort_translation", "(", "indices", ",", "translation", ")", ":", "\n", "      ", "ordered_transalation", "=", "[", "None", "]", "*", "len", "(", "translation", ")", "\n", "for", "i", ",", "index", "in", "enumerate", "(", "indices", ")", ":", "\n", "        ", "ordered_transalation", "[", "index", "]", "=", "translation", "[", "i", "]", "\n", "", "return", "ordered_transalation", "\n", "\n", "", "if", "self", ".", "cuda", ":", "\n", "        ", "cur_device", "=", "\"cuda\"", "\n", "", "else", ":", "\n", "        ", "cur_device", "=", "\"cpu\"", "\n", "\n", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Begin decoding ...\"", ")", "\n", "batch_count", "=", "0", "\n", "all_translation", "=", "[", "]", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "for", "batch", "in", "src_data_iter", ":", "\n", "# batch: [xlm_x, xlm_attn_mask]", "\n", "      ", "hyps", ",", "scores", "=", "self", ".", "translate_batch", "(", "batch", ")", "\n", "#assert len(batch) == len(hyps)", "\n", "batch_transtaltion", "=", "[", "]", "\n", "for", "src", ",", "tran_idx_seq", ",", "score", "in", "zip", "(", "batch", "[", "2", "]", ",", "hyps", ",", "scores", ")", ":", "\n", "#src_words = self.build_tokens(src_idx_seq, side='src')", "\n", "#src = ' '.join(src_words)", "\n", "        ", "if", "self", ".", "task_type", "==", "'task'", ":", "\n", "          ", "tran_words", "=", "self", ".", "build_tokens", "(", "tran_idx_seq", ",", "side", "=", "'tgt'", ")", "\n", "", "else", ":", "\n", "          ", "tran_words", "=", "self", ".", "build_tokens", "(", "tran_idx_seq", ",", "side", "=", "'tgt2'", ")", "\n", "", "tran", "=", "' '", ".", "join", "(", "tran_words", ")", "\n", "#batch_transtaltion.append(tran)", "\n", "#all_translation.append(tran)", "\n", "if", "out_file", "is", "not", "None", ":", "\n", "          ", "out_file", ".", "write", "(", "tran", "+", "'\\n'", ")", "\n", "", "print", "(", "\"SOURCE: \"", "+", "src", "+", "\"\\nOUTPUT: \"", "+", "tran", "+", "\"\\n\"", ")", "\n", "", "out_file", ".", "flush", "(", ")", "\n", "batch_count", "+=", "1", "\n", "print", "(", "\"batch: \"", "+", "str", "(", "batch_count", ")", "+", "\"...\"", ")", "\n", "\n", "#if out_file is not None:", "\n", "#for tran in all_translation:", "\n", "#out_file.write(tran + '\\n')", "\n", "", "print", "(", "'Decoding took %.1f minutes ...'", "%", "(", "float", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "/", "60.", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.Translator.translate_batch": [[109, 258], ["cross_translator.Translator.translate_batch.collect_best_hypothesis_and_score"], "methods", ["None"], ["", "def", "translate_batch", "(", "self", ",", "batch", ")", ":", "\n", "    ", "def", "get_inst_idx_to_tensor_position_map", "(", "inst_idx_list", ")", ":", "\n", "      ", "''' Indicate the position of an instance in a tensor. '''", "\n", "return", "{", "inst_idx", ":", "tensor_position", "for", "tensor_position", ",", "inst_idx", "in", "enumerate", "(", "inst_idx_list", ")", "}", "\n", "\n", "", "def", "collect_active_part", "(", "beamed_tensor", ",", "curr_active_inst_idx", ",", "n_prev_active_inst", ",", "n_bm", ")", ":", "\n", "      ", "''' Collect tensor parts associated to active instances. '''", "\n", "\n", "_", ",", "*", "d_hs", "=", "beamed_tensor", ".", "size", "(", ")", "\n", "n_curr_active_inst", "=", "len", "(", "curr_active_inst_idx", ")", "\n", "new_shape", "=", "(", "n_curr_active_inst", "*", "n_bm", ",", "*", "d_hs", ")", "\n", "\n", "beamed_tensor", "=", "beamed_tensor", ".", "view", "(", "n_prev_active_inst", ",", "-", "1", ")", "\n", "beamed_tensor", "=", "beamed_tensor", ".", "index_select", "(", "0", ",", "curr_active_inst_idx", ")", "\n", "beamed_tensor", "=", "beamed_tensor", ".", "view", "(", "*", "new_shape", ")", "\n", "\n", "return", "beamed_tensor", "\n", "\n", "", "def", "beam_decode_step", "(", "\n", "inst_dec_beams", ",", "len_dec_seq", ",", "inst_idx_to_position_map", ",", "n_bm", ")", ":", "\n", "      ", "''' Decode and update beam status, and then return active beam idx '''", "\n", "# len_dec_seq: i (starting from 0)", "\n", "\n", "def", "prepare_beam_dec_seq", "(", "inst_dec_beams", ")", ":", "\n", "        ", "dec_seq", "=", "[", "b", ".", "get_last_target_word", "(", ")", "for", "b", "in", "inst_dec_beams", "if", "not", "b", ".", "done", "]", "\n", "# dec_seq: [(beam_size)] * batch_size", "\n", "dec_seq", "=", "torch", ".", "stack", "(", "dec_seq", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# dec_seq: (batch_size, beam_size)", "\n", "dec_seq", "=", "dec_seq", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "# dec_seq: (1, batch_size * beam_size)", "\n", "return", "dec_seq", "\n", "\n", "", "def", "predict_word", "(", "dec_seq", ",", "n_active_inst", ",", "n_bm", ",", "len_dec_seq", ")", ":", "\n", "# dec_seq: (1, batch_size * beam_size)", "\n", "        ", "dec_output", ",", "*", "_", "=", "self", ".", "model", ".", "decoder", "(", "dec_seq", ",", "step", "=", "len_dec_seq", ")", "\n", "# dec_output: (1, batch_size * beam_size, hid_size)", "\n", "word_prob", "=", "self", ".", "model", ".", "generator", "(", "dec_output", ".", "squeeze", "(", "0", ")", ")", "\n", "# word_prob: (batch_size * beam_size, vocab_size)", "\n", "\n", "word_prob", "=", "F", ".", "log_softmax", "(", "word_prob", ",", "dim", "=", "1", ")", "\n", "\n", "word_prob", "=", "word_prob", ".", "view", "(", "n_active_inst", ",", "n_bm", ",", "-", "1", ")", "\n", "# word_prob: (batch_size, beam_size, vocab_size)", "\n", "\n", "return", "word_prob", "\n", "\n", "", "def", "collect_active_inst_idx_list", "(", "inst_beams", ",", "word_prob", ",", "inst_idx_to_position_map", ")", ":", "\n", "        ", "active_inst_idx_list", "=", "[", "]", "\n", "select_indices_array", "=", "[", "]", "\n", "for", "inst_idx", ",", "inst_position", "in", "inst_idx_to_position_map", ".", "items", "(", ")", ":", "\n", "          ", "is_inst_complete", "=", "inst_beams", "[", "inst_idx", "]", ".", "advance", "(", "word_prob", "[", "inst_position", "]", ")", "\n", "if", "not", "is_inst_complete", ":", "\n", "            ", "active_inst_idx_list", "+=", "[", "inst_idx", "]", "\n", "select_indices_array", ".", "append", "(", "inst_beams", "[", "inst_idx", "]", ".", "get_current_origin", "(", ")", "+", "inst_position", "*", "n_bm", ")", "\n", "", "", "if", "len", "(", "select_indices_array", ")", ">", "0", ":", "\n", "          ", "select_indices", "=", "torch", ".", "cat", "(", "select_indices_array", ")", "\n", "", "else", ":", "\n", "          ", "select_indices", "=", "None", "\n", "", "return", "active_inst_idx_list", ",", "select_indices", "\n", "\n", "", "n_active_inst", "=", "len", "(", "inst_idx_to_position_map", ")", "\n", "\n", "dec_seq", "=", "prepare_beam_dec_seq", "(", "inst_dec_beams", ")", "\n", "# dec_seq: (1, batch_size * beam_size)", "\n", "word_prob", "=", "predict_word", "(", "dec_seq", ",", "n_active_inst", ",", "n_bm", ",", "len_dec_seq", ")", "\n", "\n", "# Update the beam with predicted word prob information and collect incomplete instances", "\n", "active_inst_idx_list", ",", "select_indices", "=", "collect_active_inst_idx_list", "(", "\n", "inst_dec_beams", ",", "word_prob", ",", "inst_idx_to_position_map", ")", "\n", "\n", "if", "select_indices", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "active_inst_idx_list", ")", ">", "0", "\n", "self", ".", "model", ".", "decoder", ".", "map_state", "(", "\n", "lambda", "state", ",", "dim", ":", "state", ".", "index_select", "(", "dim", ",", "select_indices", ")", ")", "\n", "", "return", "active_inst_idx_list", "\n", "\n", "", "def", "collate_active_info", "(", "\n", "src_seq", ",", "src_enc", ",", "inst_idx_to_position_map", ",", "active_inst_idx_list", ")", ":", "\n", "# Sentences which are still active are collected,", "\n", "# so the decoder will not run on completed sentences.", "\n", "      ", "n_prev_active_inst", "=", "len", "(", "inst_idx_to_position_map", ")", "\n", "active_inst_idx", "=", "[", "inst_idx_to_position_map", "[", "k", "]", "for", "k", "in", "active_inst_idx_list", "]", "\n", "active_inst_idx", "=", "torch", ".", "LongTensor", "(", "active_inst_idx", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "active_src_seq", "=", "collect_active_part", "(", "src_seq", ",", "active_inst_idx", ",", "n_prev_active_inst", ",", "n_bm", ")", "\n", "active_src_enc", "=", "collect_active_part", "(", "src_enc", ",", "active_inst_idx", ",", "n_prev_active_inst", ",", "n_bm", ")", "\n", "active_inst_idx_to_position_map", "=", "get_inst_idx_to_tensor_position_map", "(", "active_inst_idx_list", ")", "\n", "\n", "return", "active_src_seq", ",", "active_src_enc", ",", "active_inst_idx_to_position_map", "\n", "\n", "", "def", "collect_best_hypothesis_and_score", "(", "inst_dec_beams", ")", ":", "\n", "      ", "hyps", ",", "scores", "=", "[", "]", ",", "[", "]", "\n", "for", "inst_idx", "in", "range", "(", "len", "(", "inst_dec_beams", ")", ")", ":", "\n", "        ", "hyp", ",", "score", "=", "inst_dec_beams", "[", "inst_idx", "]", ".", "get_best_hypothesis", "(", ")", "\n", "hyps", ".", "append", "(", "hyp", ")", "\n", "scores", ".", "append", "(", "score", ")", "\n", "\n", "", "return", "hyps", ",", "scores", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "#-- Encode", "\n", "#src_seq = make_features(batch, 'src')", "\n", "      ", "src_seq", ",", "src_seq_attn_mask", "=", "batch", "[", ":", "2", "]", "\n", "src_seq", "=", "src_seq", ".", "to", "(", "self", ".", "device", ")", "\n", "src_seq_attn_mask", "=", "src_seq_attn_mask", ".", "to", "(", "self", ".", "device", ")", "\n", "# src: (batch_size, seq_len_src)", "\n", "_", ",", "src_enc", ",", "_", "=", "self", ".", "model", ".", "encoder", "(", "src_seq", ".", "permute", "(", "1", ",", "0", ")", ".", "contiguous", "(", ")", ",", "src_seq_attn_mask", ")", "\n", "#_, src_enc, _ = self.model.encoder(src_seq.permute(1, 0).contiguous())", "\n", "# src_enc: (batch_size, seq_len_src, hid_size)", "\n", "#src_enc = self.model.linear_map(src_enc)", "\n", "src_seq", "=", "src_seq", ".", "permute", "(", "1", ",", "0", ")", "\n", "#src_enc = src_enc.permute(1, 0, 2)", "\n", "\n", "\n", "self", ".", "model", ".", "decoder", ".", "init_state", "(", "src_seq", ",", "src_enc", ")", "\n", "src_len", "=", "src_seq", ".", "size", "(", "0", ")", "\n", "\n", "#-- Repeat data for beam search", "\n", "n_bm", "=", "self", ".", "beam_size", "\n", "n_inst", "=", "src_seq", ".", "size", "(", "1", ")", "\n", "self", ".", "model", ".", "decoder", ".", "map_state", "(", "lambda", "state", ",", "dim", ":", "tile", "(", "state", ",", "n_bm", ",", "dim", "=", "dim", ")", ")", "\n", "# src_enc: (seq_len_src, batch_size * beam_size, hid_size)", "\n", "\n", "#-- Prepare beams", "\n", "decode_length", "=", "src_len", "+", "self", ".", "decode_extra_length", "\n", "decode_min_length", "=", "0", "\n", "if", "self", ".", "decode_min_length", ">=", "0", ":", "\n", "        ", "decode_min_length", "=", "src_len", "-", "self", ".", "decode_min_length", "\n", "", "if", "self", ".", "task_type", "==", "'task'", ":", "\n", "        ", "inst_dec_beams", "=", "[", "Beam", "(", "n_bm", ",", "decode_length", "=", "decode_length", ",", "minimal_length", "=", "decode_min_length", ",", "minimal_relative_prob", "=", "self", ".", "minimal_relative_prob", ",", "bos_id", "=", "self", ".", "tgt_bos_id", ",", "eos_id", "=", "self", ".", "tgt_eos_id", ",", "device", "=", "self", ".", "device", ")", "for", "_", "in", "range", "(", "n_inst", ")", "]", "\n", "", "else", ":", "\n", "        ", "inst_dec_beams", "=", "[", "Beam", "(", "n_bm", ",", "decode_length", "=", "decode_length", ",", "minimal_length", "=", "decode_min_length", ",", "minimal_relative_prob", "=", "self", ".", "minimal_relative_prob", ",", "bos_id", "=", "self", ".", "tgt2_bos_id", ",", "eos_id", "=", "self", ".", "tgt2_eos_id", ",", "device", "=", "self", ".", "device", ")", "for", "_", "in", "range", "(", "n_inst", ")", "]", "\n", "\n", "#-- Bookkeeping for active or not", "\n", "", "active_inst_idx_list", "=", "list", "(", "range", "(", "n_inst", ")", ")", "\n", "inst_idx_to_position_map", "=", "get_inst_idx_to_tensor_position_map", "(", "active_inst_idx_list", ")", "\n", "\n", "#-- Decode", "\n", "for", "len_dec_seq", "in", "range", "(", "0", ",", "decode_length", ")", ":", "\n", "        ", "active_inst_idx_list", "=", "beam_decode_step", "(", "\n", "inst_dec_beams", ",", "len_dec_seq", ",", "inst_idx_to_position_map", ",", "n_bm", ")", "\n", "\n", "if", "not", "active_inst_idx_list", ":", "\n", "          ", "break", "# all instances have finished their path to <EOS>", "\n", "\n", "", "inst_idx_to_position_map", "=", "get_inst_idx_to_tensor_position_map", "(", "active_inst_idx_list", ")", "\n", "\n", "", "", "batch_hyps", ",", "batch_scores", "=", "collect_best_hypothesis_and_score", "(", "inst_dec_beams", ")", "\n", "return", "batch_hyps", ",", "batch_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.cross_translator.build_translator": [[15, 20], ["cross_translator.Translator"], "function", ["None"], ["def", "build_translator", "(", "model", ",", "fields", ",", "opt", ")", ":", "\n", "\n", "  ", "translator", "=", "Translator", "(", "model", ",", "fields", ",", "opt", ")", "\n", "\n", "return", "translator", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.MyTransformerEncoderLayer.__init__": [[14, 25], ["torch.Module.__init__", "onmt.sublayer.MultiHeadedAttention", "onmt.sublayer.PositionwiseFeedForward", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", "=", "768", ",", "heads", "=", "8", ",", "d_ff", "=", "2048", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "MyTransformerEncoderLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "self_attn", "=", "onmt", ".", "sublayer", ".", "MultiHeadedAttention", "(", "\n", "heads", ",", "d_model", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "feed_forward", "=", "PositionwiseFeedForward", "(", "d_model", ",", "d_ff", ",", "dropout", ")", "\n", "\n", "self", ".", "att_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "ffn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.MyTransformerEncoderLayer.forward": [[26, 36], ["parser_model.MyTransformerEncoderLayer.att_layer_norm", "parser_model.MyTransformerEncoderLayer.self_attn", "parser_model.MyTransformerEncoderLayer.ffn_layer_norm", "parser_model.MyTransformerEncoderLayer.feed_forward", "parser_model.MyTransformerEncoderLayer.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "mask", ")", ":", "\n", "        ", "input_norm", "=", "self", ".", "att_layer_norm", "(", "inputs", ")", "\n", "outputs", ",", "_", "=", "self", ".", "self_attn", "(", "input_norm", ",", "input_norm", ",", "input_norm", ",", "\n", "mask", "=", "mask", ")", "\n", "inputs", "=", "self", ".", "dropout", "(", "outputs", ")", "+", "inputs", "\n", "\n", "input_norm", "=", "self", ".", "ffn_layer_norm", "(", "inputs", ")", "\n", "outputs", "=", "self", ".", "feed_forward", "(", "input_norm", ")", "\n", "inputs", "=", "outputs", "+", "inputs", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.MyTransformerEncoder.__init__": [[39, 52], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.Linear", "torch.Linear", "torch.Linear", "parser_model.MyTransformerEncoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_layers", "=", "6", ",", "d_model", "=", "512", ",", "heads", "=", "8", ",", "d_ff", "=", "2048", ",", "\n", "dropout", "=", "0.1", ",", "embeddings", "=", "None", ",", "tknzr", "=", "None", ",", "contextual_embeddings", "=", "None", ")", ":", "\n", "        ", "super", "(", "MyTransformerEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "padding_idx", "=", "tknzr", ".", "pad_token_id", "\n", "self", ".", "embeddings", "=", "embeddings", "\n", "self", ".", "transformer", "=", "nn", ".", "ModuleList", "(", "[", "MyTransformerEncoderLayer", "(", "d_model", ",", "heads", ",", "d_ff", ",", "dropout", ")", "\n", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "self", ".", "contextual_embeddings", "=", "contextual_embeddings", "\n", "if", "self", ".", "contextual_embeddings", "is", "not", "None", ":", "\n", "            ", "self", ".", "linear_map", "=", "nn", ".", "Linear", "(", "768", "+", "512", ",", "512", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.MyTransformerEncoder.forward": [[53, 80], ["parser_model.MyTransformerEncoder.transpose().contiguous", "src.transpose", "src.transpose.data.eq().unsqueeze", "range", "parser_model.MyTransformerEncoder.layer_norm", "parser_model.MyTransformerEncoder.embeddings", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "parser_model.MyTransformerEncoder.linear_map", "parser_model.MyTransformerEncoder.embeddings", "parser_model.MyTransformerEncoder.permute().contiguous", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "parser_model.MyTransformerEncoder.contextual_embeddings", "contextual_emb.detach.detach.detach", "parser_model.MyTransformerEncoder.transpose", "src.transpose.data.eq", "src.permute", "contextual_emb.detach.detach.permute", "parser_model.MyTransformerEncoder.permute"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "src", ",", "attn_mask", "=", "None", ")", ":", "\n", "# src: seq_len, batch", "\n", "# NOTE: positional encoding requires the src shape: [seq_len, batch], do not transpose before embeddings", "\n", "# out: seq_len, batch, dim", "\n", "\n", "        ", "if", "self", ".", "contextual_embeddings", "is", "not", "None", ":", "\n", "            ", "emb", "=", "self", ".", "embeddings", "(", "src", ")", "\n", "#assert attn_mask is not None", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "contextual_emb", ",", "_", "=", "self", ".", "contextual_embeddings", "(", "src", ".", "permute", "(", "1", ",", "0", ")", ",", "attn_mask", ")", "\n", "contextual_emb", "=", "contextual_emb", ".", "detach", "(", ")", "\n", "", "tmp_emb", "=", "torch", ".", "cat", "(", "[", "emb", ",", "contextual_emb", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "emb", "=", "self", ".", "linear_map", "(", "tmp_emb", ")", "\n", "\n", "", "else", ":", "\n", "            ", "emb", "=", "self", ".", "embeddings", "(", "src", ")", "\n", "\n", "", "out", "=", "emb", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "words", "=", "src", ".", "transpose", "(", "0", ",", "1", ")", "\n", "padding_idx", "=", "self", ".", "padding_idx", "\n", "mask", "=", "words", ".", "data", ".", "eq", "(", "padding_idx", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, T]", "\n", "# Run the forward pass of every layer of the tranformer.", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "out", "=", "self", ".", "transformer", "[", "i", "]", "(", "out", ",", "mask", ")", "\n", "", "out", "=", "self", ".", "layer_norm", "(", "out", ")", "\n", "\n", "return", "None", ",", "out", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "contiguous", "(", ")", ",", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.__init__": [[83, 110], ["torch.Module.__init__", "parser_model.MyTransformerEncoder", "utils.loss.LabelSmoothingLoss", "parser_model.ParserModel.init", "parser_model.ParserModel.build_base_decoder", "parser_model.ParserModel.init", "len"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.init", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.build_base_decoder", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.init"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "model_opt", ",", "fields", ",", "tknzr", ",", "lang_num", ",", "decoder", "=", "None", ",", "generator", "=", "None", ",", "contextual_embeddings", "=", "None", ")", ":", "\n", "        ", "super", "(", "ParserModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "#self.encoder = encoder", "\n", "self", ".", "lang_num", "=", "lang_num", "\n", "self", ".", "encoder", "=", "MyTransformerEncoder", "(", "embeddings", "=", "encoder", ",", "tknzr", "=", "tknzr", ",", "contextual_embeddings", "=", "contextual_embeddings", ")", "\n", "if", "decoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "init", "(", "model_opt", ")", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "generator", "=", "generator", "\n", "", "else", ":", "\n", "            ", "self", ".", "decoder", ",", "self", ".", "generator", "=", "self", ".", "build_base_decoder", "(", "model_opt", ",", "fields", ")", "\n", "#self.linear_map = nn.Linear(768, model_opt.dec_rnn_size)", "\n", "self", ".", "init", "(", "model_opt", ")", "\n", "", "self", ".", "decoder", ".", "src_pad_id", "=", "tknzr", ".", "pad_token_id", "\n", "#self.linear_map = nn.Linear(model_opt.enc_rnn_size, model_opt.enc_rnn_size) # for kd_type=1", "\n", "#self.gt_criterion = nn.CrossEntropyLoss(reduction='none', ignore_index=1)", "\n", "self", ".", "gt_criterion", "=", "LabelSmoothingLoss", "(", "0.1", ",", "len", "(", "fields", "[", "'tgt2'", "]", ".", "vocab", ")", ",", "ignore_index", "=", "1", ")", "\n", "self", ".", "translate_bos_id", "=", "fields", "[", "'tgt2'", "]", ".", "vocab", ".", "stoi", "[", "'<s>'", "]", "\n", "self", ".", "tgt_pad_id", "=", "fields", "[", "'tgt2'", "]", ".", "vocab", ".", "stoi", "[", "'<blank>'", "]", "\n", "self", ".", "src_pad_id", "=", "fields", "[", "'src'", "]", ".", "vocab", ".", "stoi", "[", "'<blank>'", "]", "\n", "assert", "self", ".", "tgt_pad_id", "==", "self", ".", "src_pad_id", "\n", "assert", "self", ".", "tgt_pad_id", "==", "1", "\n", "'''\n        for p in self.linear_map.parameters():\n            if p.dim() > 1:\n                xavier_uniform_(p)\n                '''", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.build_base_decoder": [[111, 121], ["onmt.transformer.build_embeddings", "onmt.transformer.build_decoder", "torch.Linear", "torch.Linear", "torch.Linear", "len"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_decoder"], ["", "def", "build_base_decoder", "(", "self", ",", "model_opt", ",", "fields", ")", ":", "\n", "        ", "tgt_dict", "=", "fields", "[", "'tgt2'", "]", ".", "vocab", "\n", "tgt_embeddings", "=", "build_embeddings", "(", "model_opt", ",", "tgt_dict", ",", "for_encoder", "=", "False", ")", "\n", "#model_opt.dec_layers = 4", "\n", "decoder", "=", "build_decoder", "(", "model_opt", ",", "tgt_embeddings", ")", "\n", "generator", "=", "nn", ".", "Linear", "(", "model_opt", ".", "dec_rnn_size", ",", "len", "(", "fields", "[", "\"tgt2\"", "]", ".", "vocab", ")", ",", "bias", "=", "False", ")", "\n", "\n", "if", "model_opt", ".", "share_decoder_embeddings", ":", "\n", "            ", "generator", ".", "weight", "=", "decoder", ".", "embeddings", ".", "word_lut", ".", "weight", "\n", "", "return", "decoder", ",", "generator", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.init": [[122, 134], ["decoder.parameters", "generator.parameters", "parser_model.ParserModel.named_parameters", "p.data.uniform_", "p.data.uniform_", "n.find", "p.dim", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "init", "(", "self", ",", "model_opt", ")", ":", "\n", "        ", "if", "model_opt", ".", "param_init", "!=", "0.0", ":", "\n", "            ", "for", "p", "in", "decoder", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "data", ".", "uniform_", "(", "-", "model_opt", ".", "param_init", ",", "model_opt", ".", "param_init", ")", "\n", "", "for", "p", "in", "generator", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "data", ".", "uniform_", "(", "-", "model_opt", ".", "param_init", ",", "model_opt", ".", "param_init", ")", "\n", "", "", "if", "model_opt", ".", "param_init_glorot", ":", "\n", "            ", "for", "n", ",", "p", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "n", ".", "find", "(", "\"contextual_embeddings\"", ")", "!=", "-", "1", ":", "\n", "                    ", "continue", "\n", "", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                    ", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.parser_model.ParserModel.forward": [[136, 189], ["x.permute.permute.permute", "tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.permute", "parser_model.ParserModel.encoder", "parser_model.ParserModel.decoder.init_state", "tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze().repeat().view", "ground_truth_tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze().repeat().view", "parser_model.ParserModel.decoder", "parser_model.ParserModel.generator", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "parser_model.ParserModel.decoder", "parser_model.ParserModel.generator", "parser_model.ParserModel.gt_criterion", "gt_loss.masked_fill.masked_fill.view", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "gt_loss.masked_fill.masked_fill.masked_fill", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "parser_model.ParserModel.argmax", "correct.masked_fill.masked_fill.masked_fill", "tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze().repeat", "ground_truth_tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze().repeat", "src.new_ones", "parser_model.ParserModel.view", "ground_truth_tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.view", "parser_model.ParserModel.gt_criterion", "src_loss.masked_fill.masked_fill.view", "src_loss.masked_fill.masked_fill.masked_fill", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "parser_model.ParserModel.view", "src.contiguous().view", "tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze", "ground_truth_tgt.unsqueeze().repeat().view.unsqueeze().repeat().view.unsqueeze", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "src.contiguous"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.init_state"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ",", "x_attn", ",", "tgt", ",", "translate", "=", "False", ",", "src", "=", "None", ",", "cal_loss", "=", "False", ",", "beta", "=", "1.0", ")", ":", "\n", "# x: batch, seq_len", "\n", "# x_attn: batch, seq_len", "\n", "# tgt: batch, seq_len", "\n", "#memory_bank, pooled_output = self.encoder(x, x_attn)", "\n", "        ", "x", "=", "x", ".", "permute", "(", "1", ",", "0", ")", "\n", "tgt", "=", "tgt", ".", "permute", "(", "1", ",", "0", ")", "\n", "_", ",", "memory_bank", ",", "_", "=", "self", ".", "encoder", "(", "x", ",", "x_attn", ")", "\n", "#memory_bank = self.linear_map(memory_bank)", "\n", "self", ".", "decoder", ".", "init_state", "(", "x", ",", "memory_bank", ")", "\n", "ground_truth_tgt", "=", "tgt", "[", "1", ":", "]", "\n", "tgt", "=", "tgt", "[", ":", "-", "1", "]", "\n", "seq_len", ",", "batch", "=", "tgt", ".", "shape", "\n", "tgt", "=", "tgt", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "lang_num", ")", ".", "view", "(", "seq_len", ",", "batch", "*", "self", ".", "lang_num", ")", "\n", "ground_truth_tgt", "=", "ground_truth_tgt", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "lang_num", ")", ".", "view", "(", "seq_len", ",", "batch", "*", "self", ".", "lang_num", ")", "\n", "dec_out", ",", "attns", "=", "self", ".", "decoder", "(", "tgt", ")", "\n", "dec_final", "=", "self", ".", "generator", "(", "dec_out", ")", "\n", "\n", "translate_dec_out", "=", "None", "\n", "if", "translate", ":", "\n", "            ", "bos", "=", "src", ".", "new_ones", "(", "[", "1", ",", "batch", "]", ")", "*", "self", ".", "translate_bos_id", "\n", "translate_tgt", "=", "torch", ".", "cat", "(", "[", "bos", ",", "src", "]", ",", "dim", "=", "0", ")", "\n", "translate_tgt", "=", "translate_tgt", "[", ":", "-", "1", "]", "\n", "translate_dec_out", ",", "_", "=", "self", ".", "decoder", "(", "translate_tgt", ")", "\n", "translate_dec_out", "=", "self", ".", "generator", "(", "translate_dec_out", ")", "\n", "\n", "", "if", "cal_loss", ":", "\n", "            ", "vocab_size", "=", "dec_final", ".", "shape", "[", "-", "1", "]", "\n", "gt_loss", "=", "self", ".", "gt_criterion", "(", "dec_final", ".", "view", "(", "-", "1", ",", "vocab_size", ")", ",", "ground_truth_tgt", ".", "view", "(", "-", "1", ")", ")", "\n", "gt_loss", "=", "gt_loss", ".", "view", "(", "seq_len", ",", "batch", "*", "self", ".", "lang_num", ")", "\n", "mask", "=", "(", "ground_truth_tgt", "==", "self", ".", "tgt_pad_id", ")", "\n", "token_num", "=", "torch", ".", "sum", "(", "1", "-", "mask", ",", "dim", "=", "0", ")", ".", "float", "(", ")", "\n", "gt_loss", "=", "gt_loss", ".", "masked_fill", "(", "mask", ",", "0", ")", "\n", "gt_loss_per_token", "=", "torch", ".", "mean", "(", "torch", ".", "sum", "(", "gt_loss", ",", "dim", "=", "0", ")", "/", "token_num", ")", "\n", "#gt_loss_per_token = torch.mean(torch.sum(gt_loss, dim=0))", "\n", "pred", "=", "dec_final", ".", "argmax", "(", "dim", "=", "2", ")", "\n", "correct", "=", "(", "pred", "==", "ground_truth_tgt", ")", ".", "view", "(", "seq_len", ",", "batch", "*", "self", ".", "lang_num", ")", "\n", "correct", "=", "correct", ".", "masked_fill", "(", "mask", ",", "0", ")", "\n", "\n", "if", "translate", ":", "\n", "                ", "src_len", ",", "src_batch", "=", "src", ".", "shape", "\n", "src_mask", "=", "(", "src", "==", "self", ".", "src_pad_id", ")", "\n", "src_loss", "=", "self", ".", "gt_criterion", "(", "translate_dec_out", ".", "view", "(", "-", "1", ",", "vocab_size", ")", ",", "src", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "src_loss", "=", "src_loss", ".", "view", "(", "src_len", ",", "src_batch", ")", "\n", "src_loss", "=", "src_loss", ".", "masked_fill", "(", "src_mask", ",", "0", ")", "\n", "src_token_num", "=", "torch", ".", "sum", "(", "1", "-", "src_mask", ",", "dim", "=", "0", ")", ".", "float", "(", ")", "\n", "src_loss_per_token", "=", "torch", ".", "mean", "(", "torch", ".", "sum", "(", "src_loss", ",", "dim", "=", "0", ")", "/", "src_token_num", ")", "\n", "#src_loss_per_token = torch.mean(torch.sum(src_loss, dim=0))", "\n", "gt_loss_per_token", "=", "gt_loss_per_token", "+", "beta", "*", "src_loss_per_token", "\n", "\n", "", "return", "gt_loss_per_token", ",", "torch", ".", "sum", "(", "correct", ")", ",", "torch", ".", "sum", "(", "token_num", ")", "\n", "\n", "", "return", "dec_final", ",", "attns", ",", "memory_bank", ",", "translate_dec_out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.PositionalEncoding.__init__": [[9, 21], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "pe.unsqueeze.unsqueeze.unsqueeze", "torch.Module.__init__", "embeddings.PositionalEncoding.register_buffer", "torch.Dropout", "torch.Dropout", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange().unsqueeze.float", "torch.arange().unsqueeze.float", "torch.arange().unsqueeze.float", "torch.arange().unsqueeze.float", "math.log"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "dropout", ",", "dim", ",", "max_len", "=", "5000", ")", ":", "\n", "    ", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "dim", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "(", "torch", ".", "arange", "(", "0", ",", "dim", ",", "2", ",", "dtype", "=", "torch", ".", "float", ")", "*", "\n", "-", "(", "math", ".", "log", "(", "10000.0", ")", "/", "dim", ")", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", ".", "float", "(", ")", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", ".", "float", "(", ")", "*", "div_term", ")", "\n", "pe", "=", "pe", ".", "unsqueeze", "(", "1", ")", "\n", "super", "(", "PositionalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "register_buffer", "(", "'pe'", ",", "pe", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.PositionalEncoding.forward": [[22, 30], ["embeddings.PositionalEncoding.dropout", "math.sqrt", "embeddings.PositionalEncoding.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "emb", ",", "step", "=", "None", ")", ":", "\n", "    ", "emb", "=", "emb", "*", "math", ".", "sqrt", "(", "self", ".", "dim", ")", "\n", "if", "step", "is", "None", ":", "\n", "      ", "emb", "=", "emb", "+", "self", ".", "pe", "[", ":", "emb", ".", "size", "(", "0", ")", "]", "\n", "", "else", ":", "\n", "      ", "emb", "=", "emb", "+", "self", ".", "pe", "[", "step", "]", "\n", "", "emb", "=", "self", ".", "dropout", "(", "emb", ")", "\n", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.Embeddings.__init__": [[33, 57], ["torch.Embedding", "torch.Embedding", "torch.Module.__init__", "torch.Sequential", "torch.Sequential", "embeddings.Embeddings.make_embedding.add_module", "embeddings.PositionalEncoding", "embeddings.Embeddings.make_embedding.add_module"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "word_vec_size", ",", "\n", "word_vocab_size", ",", "\n", "word_padding_idx", ",", "\n", "position_encoding", "=", "False", ",", "\n", "dropout", "=", "0", ",", "\n", "sparse", "=", "False", ")", ":", "\n", "\n", "    ", "self", ".", "word_padding_idx", "=", "word_padding_idx", "\n", "\n", "self", ".", "word_vec_size", "=", "word_vec_size", "\n", "\n", "embedding", "=", "nn", ".", "Embedding", "(", "word_vocab_size", ",", "word_vec_size", ",", "padding_idx", "=", "word_padding_idx", ",", "sparse", "=", "sparse", ")", "\n", "\n", "self", ".", "embedding_size", "=", "word_vec_size", "\n", "\n", "super", "(", "Embeddings", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "make_embedding", "=", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "make_embedding", ".", "add_module", "(", "'word'", ",", "embedding", ")", "\n", "\n", "self", ".", "position_encoding", "=", "position_encoding", "\n", "\n", "if", "self", ".", "position_encoding", ":", "\n", "      ", "pe", "=", "PositionalEncoding", "(", "dropout", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "make_embedding", ".", "add_module", "(", "'pe'", ",", "pe", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.Embeddings.word_lut": [[58, 62], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "word_lut", "(", "self", ")", ":", "\n", "    ", "\"\"\" word look-up table \"\"\"", "\n", "return", "self", ".", "make_embedding", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.Embeddings.load_pretrained_vectors": [[63, 82], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load.size", "torch.load.size", "embeddings.Embeddings.word_lut.weight.data.copy_", "embeddings.Embeddings.word_lut.weight.data.copy_"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "def", "load_pretrained_vectors", "(", "self", ",", "emb_file", ",", "fixed", ")", ":", "\n", "    ", "\"\"\"Load in pretrained embeddings.\n\n    Args:\n      emb_file (str) : path to torch serialized embeddings\n      fixed (bool) : if true, embeddings are not updated\n    \"\"\"", "\n", "if", "emb_file", ":", "\n", "      ", "pretrained", "=", "torch", ".", "load", "(", "emb_file", ")", "\n", "pretrained_vec_size", "=", "pretrained", ".", "size", "(", "1", ")", "\n", "if", "self", ".", "word_vec_size", ">", "pretrained_vec_size", ":", "\n", "        ", "self", ".", "word_lut", ".", "weight", ".", "data", "[", ":", ",", ":", "pretrained_vec_size", "]", "=", "pretrained", "\n", "", "elif", "self", ".", "word_vec_size", "<", "pretrained_vec_size", ":", "\n", "        ", "self", ".", "word_lut", ".", "weight", ".", "data", ".", "copy_", "(", "pretrained", "[", ":", ",", ":", "self", ".", "word_vec_size", "]", ")", "\n", "", "else", ":", "\n", "        ", "self", ".", "word_lut", ".", "weight", ".", "data", ".", "copy_", "(", "pretrained", ")", "\n", "", "if", "fixed", ":", "\n", "        ", "self", ".", "word_lut", ".", "weight", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.embeddings.Embeddings.forward": [[83, 102], ["enumerate", "embeddings.Embeddings.make_embedding", "embeddings.Embeddings.make_embedding._modules.values", "module", "module", "len", "embeddings.Embeddings.make_embedding._modules.values"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "source", ",", "step", "=", "None", ",", "use_position_encoding", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Computes the embeddings for words and features.\n\n    Args:\n        source (`LongTensor`): index tensor `[len x batch]`\n    Return:\n        `FloatTensor`: word embeddings `[len x batch x embedding_size]`\n    \"\"\"", "\n", "if", "self", ".", "position_encoding", "and", "use_position_encoding", ":", "\n", "      ", "for", "i", ",", "module", "in", "enumerate", "(", "self", ".", "make_embedding", ".", "_modules", ".", "values", "(", ")", ")", ":", "\n", "        ", "if", "i", "==", "len", "(", "self", ".", "make_embedding", ".", "_modules", ".", "values", "(", ")", ")", "-", "1", ":", "\n", "          ", "source", "=", "module", "(", "source", ",", "step", "=", "step", ")", "\n", "", "else", ":", "\n", "          ", "source", "=", "module", "(", "source", ")", "\n", "", "", "", "else", ":", "\n", "      ", "source", "=", "self", ".", "make_embedding", "(", "source", ")", "\n", "\n", "", "return", "source", "\n", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.sublayer.MultiHeadedAttention.__init__": [[26, 43], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["def", "__init__", "(", "self", ",", "head_count", ",", "model_dim", ",", "dropout", "=", "0.1", ")", ":", "\n", "    ", "assert", "model_dim", "%", "head_count", "==", "0", "\n", "self", ".", "dim_per_head", "=", "model_dim", "//", "head_count", "\n", "self", ".", "model_dim", "=", "model_dim", "\n", "\n", "super", "(", "MultiHeadedAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "head_count", "=", "head_count", "\n", "\n", "self", ".", "linear_keys", "=", "nn", ".", "Linear", "(", "model_dim", ",", "\n", "head_count", "*", "self", ".", "dim_per_head", ")", "\n", "self", ".", "linear_values", "=", "nn", ".", "Linear", "(", "model_dim", ",", "\n", "head_count", "*", "self", ".", "dim_per_head", ")", "\n", "self", ".", "linear_query", "=", "nn", ".", "Linear", "(", "model_dim", ",", "\n", "head_count", "*", "self", ".", "dim_per_head", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "final_linear", "=", "nn", ".", "Linear", "(", "model_dim", ",", "model_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.sublayer.MultiHeadedAttention.forward": [[44, 155], ["shape.size", "shape.size", "sublayer.MultiHeadedAttention.size", "sublayer.MultiHeadedAttention.forward.shape"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "key", ",", "value", ",", "query", ",", "mask", "=", "None", ",", "\n", "layer_cache", "=", "None", ",", "type", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute the context vector and the attention vectors.\n\n    Args:\n       key (`FloatTensor`): set of `key_len`\n            key vectors `[batch, key_len, dim]`\n       value (`FloatTensor`): set of `key_len`\n            value vectors `[batch, key_len, dim]`\n       query (`FloatTensor`): set of `query_len`\n             query vectors  `[batch, query_len, dim]`\n       mask: binary mask indicating which keys have\n             non-zero attention `[batch, query_len, key_len]`\n    Returns:\n       (`FloatTensor`, `FloatTensor`) :\n\n       * output context vectors `[batch, query_len, dim]`\n       * one of the attention vectors `[batch, query_len, key_len]`\n    \"\"\"", "\n", "\n", "batch_size", "=", "key", ".", "size", "(", "0", ")", "\n", "dim_per_head", "=", "self", ".", "dim_per_head", "\n", "head_count", "=", "self", ".", "head_count", "\n", "key_len", "=", "key", ".", "size", "(", "1", ")", "\n", "query_len", "=", "query", ".", "size", "(", "1", ")", "\n", "\n", "def", "shape", "(", "x", ")", ":", "\n", "      ", "\"\"\"  projection \"\"\"", "\n", "return", "x", ".", "view", "(", "batch_size", ",", "-", "1", ",", "head_count", ",", "dim_per_head", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "", "def", "unshape", "(", "x", ")", ":", "\n", "      ", "\"\"\"  compute context \"\"\"", "\n", "return", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "batch_size", ",", "-", "1", ",", "head_count", "*", "dim_per_head", ")", "\n", "\n", "# 1) Project key, value, and query.", "\n", "", "if", "layer_cache", "is", "not", "None", ":", "\n", "      ", "if", "type", "==", "\"self\"", ":", "\n", "          ", "query", ",", "key", ",", "value", "=", "self", ".", "linear_query", "(", "query", ")", ",", "self", ".", "linear_keys", "(", "query", ")", ",", "self", ".", "linear_values", "(", "query", ")", "\n", "\n", "key", "=", "shape", "(", "key", ")", "\n", "value", "=", "shape", "(", "value", ")", "\n", "\n", "if", "layer_cache", "is", "not", "None", ":", "\n", "              ", "device", "=", "key", ".", "device", "\n", "if", "layer_cache", "[", "\"self_keys\"", "]", "is", "not", "None", ":", "\n", "                  ", "key", "=", "torch", ".", "cat", "(", "\n", "(", "layer_cache", "[", "\"self_keys\"", "]", ".", "to", "(", "device", ")", ",", "key", ")", ",", "\n", "dim", "=", "2", ")", "\n", "", "if", "layer_cache", "[", "\"self_values\"", "]", "is", "not", "None", ":", "\n", "                  ", "value", "=", "torch", ".", "cat", "(", "\n", "(", "layer_cache", "[", "\"self_values\"", "]", ".", "to", "(", "device", ")", ",", "value", ")", ",", "\n", "dim", "=", "2", ")", "\n", "", "layer_cache", "[", "\"self_keys\"", "]", "=", "key", "\n", "layer_cache", "[", "\"self_values\"", "]", "=", "value", "\n", "", "", "elif", "type", "==", "\"context\"", ":", "\n", "        ", "query", "=", "self", ".", "linear_query", "(", "query", ")", "\n", "if", "layer_cache", "is", "not", "None", ":", "\n", "          ", "if", "layer_cache", "[", "\"memory_keys\"", "]", "is", "None", ":", "\n", "            ", "key", ",", "value", "=", "self", ".", "linear_keys", "(", "key", ")", ",", "self", ".", "linear_values", "(", "value", ")", "\n", "key", "=", "shape", "(", "key", ")", "\n", "value", "=", "shape", "(", "value", ")", "\n", "", "else", ":", "\n", "            ", "key", ",", "value", "=", "layer_cache", "[", "\"memory_keys\"", "]", ",", "layer_cache", "[", "\"memory_values\"", "]", "\n", "", "layer_cache", "[", "\"memory_keys\"", "]", "=", "key", "\n", "layer_cache", "[", "\"memory_values\"", "]", "=", "value", "\n", "", "else", ":", "\n", "          ", "key", ",", "value", "=", "self", ".", "linear_keys", "(", "key", ")", ",", "self", ".", "linear_values", "(", "value", ")", "\n", "key", "=", "shape", "(", "key", ")", "\n", "value", "=", "shape", "(", "value", ")", "\n", "", "", "", "else", ":", "\n", "      ", "key", "=", "self", ".", "linear_keys", "(", "key", ")", "\n", "value", "=", "self", ".", "linear_values", "(", "value", ")", "\n", "query", "=", "self", ".", "linear_query", "(", "query", ")", "\n", "key", "=", "shape", "(", "key", ")", "\n", "value", "=", "shape", "(", "value", ")", "\n", "\n", "", "query", "=", "shape", "(", "query", ")", "\n", "\n", "key_len", "=", "key", ".", "size", "(", "2", ")", "\n", "query_len", "=", "query", ".", "size", "(", "2", ")", "\n", "\n", "# 2) Calculate and scale scores.", "\n", "query", "=", "query", "/", "math", ".", "sqrt", "(", "dim_per_head", ")", "\n", "scores", "=", "torch", ".", "matmul", "(", "query", ",", "key", ".", "transpose", "(", "2", ",", "3", ")", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "# [B, 1, 1, T_values]", "\n", "scores", "=", "scores", ".", "masked_fill", "(", "mask", ",", "-", "1e18", ")", "\n", "\n", "# 3) Apply attention dropout and compute context vectors.", "\n", "", "attn", "=", "self", ".", "softmax", "(", "scores", ")", "\n", "drop_attn", "=", "self", ".", "dropout", "(", "attn", ")", "\n", "context", "=", "unshape", "(", "torch", ".", "matmul", "(", "drop_attn", ",", "value", ")", ")", "\n", "\n", "output", "=", "self", ".", "final_linear", "(", "context", ")", "\n", "\n", "# Return one attn", "\n", "top_attn", "=", "attn", ".", "view", "(", "batch_size", ",", "head_count", ",", "\n", "query_len", ",", "key_len", ")", "[", ":", ",", "0", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", "\n", "\n", "return", "output", ",", "top_attn", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.sublayer.PositionwiseFeedForward.__init__": [[166, 172], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "d_ff", ",", "dropout", "=", "0.1", ")", ":", "\n", "    ", "super", "(", "PositionwiseFeedForward", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "w_1", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_ff", ")", "\n", "self", ".", "w_2", "=", "nn", ".", "Linear", "(", "d_ff", ",", "d_model", ")", "\n", "self", ".", "dropout_1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.sublayer.PositionwiseFeedForward.forward": [[173, 187], ["sublayer.PositionwiseFeedForward.dropout_1", "sublayer.PositionwiseFeedForward.w_2", "sublayer.PositionwiseFeedForward.relu", "sublayer.PositionwiseFeedForward.w_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    Layer definition.\n\n    Args:\n        input: [ batch_size, input_len, model_dim ]\n\n\n    Returns:\n        output: [ batch_size, input_len, model_dim ]\n    \"\"\"", "\n", "inter", "=", "self", ".", "dropout_1", "(", "self", ".", "relu", "(", "self", ".", "w_1", "(", "x", ")", ")", ")", "\n", "output", "=", "self", ".", "w_2", "(", "inter", ")", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.JointModel.__init__": [[21, 26], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ")", ":", "\n", "    ", "super", "(", "JointModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "generator", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.JointModel.forward": [[27, 39], ["transformer.JointModel.encoder", "transformer.JointModel.decoder.init_state", "transformer.JointModel.decoder", "transformer.JointModel.generator"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.init_state"], ["", "def", "forward", "(", "self", ",", "src", ",", "tgt", ",", "lengths", ",", "task_type", ")", ":", "\n", "    ", "tgt", "=", "tgt", "[", ":", "-", "1", "]", "# exclude last target from inputs", "\n", "\n", "_", ",", "memory_bank", ",", "lengths", "=", "self", ".", "encoder", "(", "src", ",", "lengths", ")", "\n", "\n", "self", ".", "decoder", ".", "init_state", "(", "src", ",", "memory_bank", ")", "\n", "dec_out", ",", "attns", "=", "self", ".", "decoder", "(", "tgt", ")", "\n", "\n", "if", "self", ".", "generator", "is", "not", "None", ":", "\n", "      ", "dec_out", "=", "self", ".", "generator", "(", "dec_out", ")", "\n", "\n", "", "return", "dec_out", ",", "attns", ",", "memory_bank", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.NMTModel.__init__": [[41, 45], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ")", ":", "\n", "    ", "super", "(", "NMTModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.NMTModel.forward": [[46, 54], ["transformer.NMTModel.encoder", "transformer.NMTModel.decoder.init_state", "transformer.NMTModel.decoder"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer_decoder.TransformerDecoder.init_state"], ["", "def", "forward", "(", "self", ",", "src", ",", "tgt", ",", "lengths", ")", ":", "\n", "    ", "tgt", "=", "tgt", "[", ":", "-", "1", "]", "# exclude last target from inputs", "\n", "\n", "_", ",", "memory_bank", ",", "lengths", "=", "self", ".", "encoder", "(", "src", ",", "lengths", ")", "\n", "self", ".", "decoder", ".", "init_state", "(", "src", ",", "memory_bank", ")", "\n", "dec_out", ",", "attns", "=", "self", ".", "decoder", "(", "tgt", ")", "\n", "\n", "return", "dec_out", ",", "attns", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings_2": [[55, 59], ["onmt.embeddings.Embeddings"], "function", ["None"], ["", "", "def", "build_embeddings_2", "(", "emb_dim", ",", "padding_idx", ",", "num_word", ",", "opt", ")", ":", "\n", "  ", "return", "Embeddings", "(", "word_vec_size", "=", "emb_dim", ",", "\n", "position_encoding", "=", "True", ",", "dropout", "=", "opt", ".", "dropout", ",", "word_padding_idx", "=", "padding_idx", ",", "\n", "word_vocab_size", "=", "num_word", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings": [[61, 84], ["len", "onmt.embeddings.Embeddings"], "function", ["None"], ["", "def", "build_embeddings", "(", "opt", ",", "word_dict", ",", "for_encoder", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  Build an Embeddings instance.\n  Args:\n      opt: the option in current environment.\n      word_dict(Vocab): words dictionary.\n      feature_dicts([Vocab], optional): a list of feature dictionary.\n      for_encoder(bool): build Embeddings for encoder or decoder?\n  \"\"\"", "\n", "if", "for_encoder", ":", "\n", "    ", "embedding_dim", "=", "opt", ".", "src_word_vec_size", "\n", "", "else", ":", "\n", "    ", "embedding_dim", "=", "opt", ".", "tgt_word_vec_size", "\n", "\n", "", "word_padding_idx", "=", "word_dict", ".", "stoi", "[", "Constants", ".", "PAD_WORD", "]", "\n", "num_word_embeddings", "=", "len", "(", "word_dict", ")", "\n", "\n", "return", "Embeddings", "(", "word_vec_size", "=", "embedding_dim", ",", "\n", "position_encoding", "=", "opt", ".", "position_encoding", ",", "\n", "dropout", "=", "opt", ".", "dropout", ",", "\n", "word_padding_idx", "=", "word_padding_idx", ",", "\n", "word_vocab_size", "=", "num_word_embeddings", ",", "\n", "sparse", "=", "opt", ".", "optim", "==", "\"sparseadam\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_encoder": [[86, 96], ["onmt.transformer_encoder.TransformerEncoder"], "function", ["None"], ["", "def", "build_encoder", "(", "opt", ",", "embeddings", ")", ":", "\n", "  ", "\"\"\"\n  Various encoder dispatcher function.\n  Args:\n      opt: the option in current environment.\n      embeddings (Embeddings): vocab embeddings for this encoder.\n  \"\"\"", "\n", "return", "TransformerEncoder", "(", "opt", ".", "enc_layers", ",", "opt", ".", "enc_rnn_size", ",", "\n", "opt", ".", "heads", ",", "opt", ".", "transformer_ff", ",", "\n", "opt", ".", "dropout", ",", "embeddings", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_decoder": [[97, 107], ["onmt.transformer_decoder.TransformerDecoder"], "function", ["None"], ["", "def", "build_decoder", "(", "opt", ",", "embeddings", ")", ":", "\n", "  ", "\"\"\"\n  Various decoder dispatcher function.\n  Args:\n      opt: the option in current environment.\n      embeddings (Embeddings): vocab embeddings for this decoder.\n  \"\"\"", "\n", "return", "TransformerDecoder", "(", "opt", ".", "dec_layers", ",", "opt", ".", "dec_rnn_size", ",", "\n", "opt", ".", "heads", ",", "opt", ".", "transformer_ff", ",", "\n", "opt", ".", "dropout", ",", "embeddings", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.load_test_model": [[108, 129], ["torch.load", "torch.load", "inputters.dataset.load_fields_from_vocab", "transformer.build_base_model", "build_base_model.eval", "build_base_model.generator.eval", "utils.misc.use_gpu"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_fields_from_vocab", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_base_model"], ["", "def", "load_test_model", "(", "opt", ",", "dummy_opt", ",", "model_path", "=", "None", ",", "use_softmax", "=", "True", ",", "get_model_opt", "=", "False", ",", "init", "=", "False", ")", ":", "\n", "  ", "if", "model_path", "is", "None", ":", "\n", "    ", "model_path", "=", "opt", ".", "models", "[", "0", "]", "\n", "", "checkpoint", "=", "torch", ".", "load", "(", "model_path", ",", "\n", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "\n", "fields", "=", "load_fields_from_vocab", "(", "checkpoint", "[", "'vocab'", "]", ")", "\n", "\n", "model_opt", "=", "checkpoint", "[", "'opt'", "]", "\n", "\n", "for", "arg", "in", "dummy_opt", ":", "\n", "    ", "if", "arg", "not", "in", "model_opt", ":", "\n", "      ", "model_opt", ".", "__dict__", "[", "arg", "]", "=", "dummy_opt", "[", "arg", "]", "\n", "", "", "if", "init", ":", "\n", "    ", "checkpoint", "=", "None", "\n", "", "model", "=", "build_base_model", "(", "model_opt", ",", "fields", ",", "use_gpu", "(", "opt", ")", ",", "checkpoint", ",", "use_softmax", "=", "use_softmax", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "generator", ".", "eval", "(", ")", "\n", "if", "get_model_opt", ":", "\n", "    ", "return", "fields", ",", "model", ",", "model_opt", "\n", "", "return", "fields", ",", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_base_model": [[130, 229], ["transformer.build_embeddings", "transformer.build_encoder", "transformer.build_embeddings", "transformer.build_decoder", "torch.device", "torch.device", "transformer.JointModel", "torch.LogSoftmax", "JointModel.to", "AssertionError", "torch.Sequential", "torch.Linear", "JointModel.load_state_dict", "nn.Linear.load_state_dict", "hasattr", "hasattr", "AssertionError", "torch.Linear", "len", "re.sub", "re.sub", "transformer.build_base_model.fix_key"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_encoder", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_embeddings", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_decoder"], ["", "def", "build_base_model", "(", "model_opt", ",", "fields", ",", "gpu", ",", "checkpoint", "=", "None", ",", "use_softmax", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  Args:\n      model_opt: the option loaded from checkpoint.\n      fields: `Field` objects for the model.\n      gpu(bool): whether to use gpu.\n      checkpoint: the model gnerated by train phase, or a resumed snapshot\n                  model from a stopped training.\n  Returns:\n      the NMTModel.\n  \"\"\"", "\n", "\n", "# for backward compatibility", "\n", "if", "model_opt", ".", "enc_rnn_size", "!=", "model_opt", ".", "dec_rnn_size", ":", "\n", "    ", "raise", "AssertionError", "(", "\"\"\"We do not support different encoder and\n                         decoder rnn sizes for translation now.\"\"\"", ")", "\n", "\n", "# Build encoder.", "\n", "", "src_dict", "=", "fields", "[", "\"src\"", "]", ".", "vocab", "\n", "src_embeddings", "=", "build_embeddings", "(", "model_opt", ",", "src_dict", ")", "\n", "encoder", "=", "build_encoder", "(", "model_opt", ",", "src_embeddings", ")", "\n", "\n", "# Build decoder.", "\n", "tgt_dict", "=", "fields", "[", "\"tgt\"", "]", ".", "vocab", "\n", "tgt_embeddings", "=", "build_embeddings", "(", "model_opt", ",", "tgt_dict", ",", "\n", "for_encoder", "=", "False", ")", "\n", "\n", "# Share the embedding matrix - preprocess with share_vocab required.", "\n", "if", "model_opt", ".", "share_embeddings", ":", "\n", "# src/tgt vocab should be the same if `-share_vocab` is specified.", "\n", "    ", "if", "src_dict", "!=", "tgt_dict", ":", "\n", "      ", "raise", "AssertionError", "(", "'The `-share_vocab` should be set during '", "\n", "'preprocess if you use share_embeddings!'", ")", "\n", "", "tgt_embeddings", ".", "word_lut", ".", "weight", "=", "src_embeddings", ".", "word_lut", ".", "weight", "\n", "\n", "", "decoder", "=", "build_decoder", "(", "model_opt", ",", "tgt_embeddings", ")", "\n", "\n", "# Build NMTModel(= encoder + decoder).", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "gpu", "else", "\"cpu\"", ")", "\n", "# model = NMTModel(encoder, decoder)", "\n", "model", "=", "JointModel", "(", "encoder", ",", "decoder", ")", "\n", "\n", "# Build Generator.", "\n", "gen_func", "=", "nn", ".", "LogSoftmax", "(", "dim", "=", "-", "1", ")", "\n", "if", "use_softmax", ":", "\n", "    ", "generator", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "model_opt", ".", "dec_rnn_size", ",", "len", "(", "fields", "[", "\"tgt\"", "]", ".", "vocab", ")", ",", "bias", "=", "False", ")", ",", "\n", "gen_func", "\n", ")", "\n", "", "else", ":", "\n", "    ", "generator", "=", "nn", ".", "Linear", "(", "model_opt", ".", "dec_rnn_size", ",", "len", "(", "fields", "[", "\"tgt\"", "]", ".", "vocab", ")", ",", "bias", "=", "False", ")", "\n", "\n", "", "if", "model_opt", ".", "share_decoder_embeddings", "and", "use_softmax", ":", "\n", "    ", "generator", "[", "0", "]", ".", "weight", "=", "decoder", ".", "embeddings", ".", "word_lut", ".", "weight", "\n", "", "elif", "model_opt", ".", "share_decoder_embeddings", ":", "\n", "    ", "generator", ".", "weight", "=", "decoder", ".", "embeddings", ".", "word_lut", ".", "weight", "\n", "\n", "# Load the model states from checkpoint or initialize them.", "\n", "", "if", "checkpoint", "is", "not", "None", ":", "\n", "# This preserves backward-compat for models using customed layernorm", "\n", "    ", "def", "fix_key", "(", "s", ")", ":", "\n", "      ", "s", "=", "re", ".", "sub", "(", "r'(.*)\\.layer_norm((_\\d+)?)\\.b_2'", ",", "\n", "r'\\1.layer_norm\\2.bias'", ",", "s", ")", "\n", "s", "=", "re", ".", "sub", "(", "r'(.*)\\.layer_norm((_\\d+)?)\\.a_2'", ",", "\n", "r'\\1.layer_norm\\2.weight'", ",", "s", ")", "\n", "return", "s", "\n", "\n", "", "checkpoint", "[", "'model'", "]", "=", "{", "fix_key", "(", "k", ")", ":", "v", "for", "(", "k", ",", "v", ")", "in", "checkpoint", "[", "'model'", "]", ".", "items", "(", ")", "}", "\n", "# end of patch for backward compatibility", "\n", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model'", "]", ",", "strict", "=", "False", ")", "\n", "generator", ".", "load_state_dict", "(", "checkpoint", "[", "'generator'", "]", ",", "strict", "=", "False", ")", "\n", "", "else", ":", "\n", "    ", "if", "model_opt", ".", "param_init", "!=", "0.0", ":", "\n", "      ", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "data", ".", "uniform_", "(", "-", "model_opt", ".", "param_init", ",", "model_opt", ".", "param_init", ")", "\n", "", "for", "p", "in", "generator", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "data", ".", "uniform_", "(", "-", "model_opt", ".", "param_init", ",", "model_opt", ".", "param_init", ")", "\n", "", "", "if", "model_opt", ".", "param_init_glorot", ":", "\n", "      ", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "          ", "xavier_uniform_", "(", "p", ")", "\n", "", "", "for", "n", ",", "p", "in", "generator", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "          ", "xavier_uniform_", "(", "p", ")", "\n", "\n", "", "", "", "if", "hasattr", "(", "model", ".", "encoder", ",", "'embeddings'", ")", ":", "\n", "      ", "model", ".", "encoder", ".", "embeddings", ".", "load_pretrained_vectors", "(", "\n", "model_opt", ".", "pre_word_vecs_enc", ",", "model_opt", ".", "fix_word_vecs_enc", ")", "\n", "", "if", "hasattr", "(", "model", ".", "decoder", ",", "'embeddings'", ")", ":", "\n", "      ", "model", ".", "decoder", ".", "embeddings", ".", "load_pretrained_vectors", "(", "\n", "model_opt", ".", "pre_word_vecs_dec", ",", "model_opt", ".", "fix_word_vecs_dec", ")", "\n", "#pdb.set_trace()", "\n", "# Add generator to model (this registers it as parameter of model).", "\n", "", "", "model", ".", "generator", "=", "generator", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_model": [[231, 238], ["utils.logging.logger.info", "transformer.build_base_model", "utils.logging.logger.info", "utils.misc.use_gpu"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.onmt.transformer.build_base_model"], ["", "def", "build_model", "(", "model_opt", ",", "opt", ",", "fields", ",", "checkpoint", ")", ":", "\n", "  ", "\"\"\" Build the Model \"\"\"", "\n", "logger", ".", "info", "(", "'Building model...'", ")", "\n", "model", "=", "build_base_model", "(", "model_opt", ",", "fields", ",", "\n", "use_gpu", "(", "opt", ")", ",", "checkpoint", ")", "\n", "logger", ".", "info", "(", "model", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.SrcSent.__init__": [[12, 21], ["tknzr", "len", "snt.split", "snt.split", "data_loader.tokenize", "snt.replace"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.tokenize"], ["    ", "def", "__init__", "(", "self", ",", "snt", ",", "tknzr", ",", "src_vocab", ")", ":", "\n", "        ", "self", ".", "str_snt", "=", "\" \"", ".", "join", "(", "snt", ".", "split", "(", ")", ")", "\n", "self", ".", "bpe_snt", "=", "snt", ".", "split", "(", ")", "+", "[", "\"</s>\"", "]", "\n", "if", "src_vocab", "is", "not", "None", ":", "\n", "            ", "self", ".", "bpe_snt", "=", "tokenize", "(", "src_vocab", ",", "self", ".", "bpe_snt", ")", "\n", "", "self", ".", "snt", "=", "tknzr", "(", "snt", ".", "replace", "(", "\"@@ \"", ",", "\"\"", ")", ")", "# for XLMRobertaTokenizer()", "\n", "self", ".", "attn_mask", "=", "self", ".", "snt", "[", "'attention_mask'", "]", "\n", "self", ".", "snt", "=", "self", ".", "snt", "[", "'input_ids'", "]", "\n", "self", ".", "snt_len", "=", "len", "(", "self", ".", "snt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.SrcSent.__len__": [[22, 24], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "snt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.__init__": [[26, 34], ["type", "data_loader.InferenceDataLoader.load_data_list", "data_loader.InferenceDataLoader.load_data"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.load_data_list", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.load_data"], ["    ", "def", "__init__", "(", "self", ",", "src_filename", ",", "batch_size", ",", "tknzr", ",", "src_vocab", ")", ":", "\n", "        ", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "tknzr_pad_id", "=", "tknzr", ".", "pad_token_id", "\n", "self", ".", "src_ls", "=", "[", "]", "\n", "if", "type", "(", "src_filename", ")", "==", "list", ":", "\n", "            ", "self", ".", "load_data_list", "(", "src_filename", ",", "tknzr", ",", "src_vocab", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "load_data", "(", "src_filename", ",", "tknzr", ",", "src_vocab", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.load_data": [[35, 42], ["open", "print", "data_loader.InferenceDataLoader.src_ls.append", "data_loader.SrcSent"], "methods", ["None"], ["", "", "def", "load_data", "(", "self", ",", "src_filename", ",", "tknzr", ",", "src_vocab", ")", ":", "\n", "        ", "f", "=", "open", "(", "src_filename", ",", "encoding", "=", "'utf-8'", ")", "\n", "idx", "=", "0", "\n", "for", "line", "in", "f", ":", "\n", "            ", "idx", "+=", "1", "\n", "print", "(", "idx", ")", "\n", "self", ".", "src_ls", ".", "append", "(", "SrcSent", "(", "line", ",", "tknzr", ",", "src_vocab", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.load_data_list": [[43, 62], ["open", "open", "print", "eng_src_ls.append", "print", "tgt_src_ls.append", "tgt_src_ls[].snt.extend", "tgt_src_ls[].attn_mask.extend", "len", "len", "data_loader.SrcSent", "data_loader.SrcSent"], "methods", ["None"], ["", "", "def", "load_data_list", "(", "self", ",", "src_filename_ls", ",", "tknzr", ",", "src_vocab", ")", ":", "\n", "        ", "eng_src_ls", "=", "[", "]", "\n", "tgt_src_ls", "=", "[", "]", "\n", "f", "=", "open", "(", "src_filename_ls", "[", "0", "]", ",", "encoding", "=", "'utf-8'", ")", "\n", "idx", "=", "0", "\n", "for", "line", "in", "f", ":", "\n", "            ", "idx", "+=", "1", "\n", "print", "(", "idx", ")", "\n", "eng_src_ls", ".", "append", "(", "SrcSent", "(", "line", ",", "tknzr", ",", "src_vocab", ")", ")", "\n", "", "f", "=", "open", "(", "src_filename_ls", "[", "1", "]", ",", "encoding", "=", "'utf-8'", ")", "\n", "idx", "=", "0", "\n", "for", "line", "in", "f", ":", "\n", "            ", "idx", "+=", "1", "\n", "print", "(", "idx", ")", "\n", "tgt_src_ls", ".", "append", "(", "SrcSent", "(", "line", ",", "tknzr", ",", "src_vocab", ")", ")", "\n", "tgt_src_ls", "[", "-", "1", "]", ".", "snt", ".", "extend", "(", "eng_src_ls", "[", "idx", "-", "1", "]", ".", "snt", "[", "1", ":", "]", ")", "\n", "tgt_src_ls", "[", "-", "1", "]", ".", "attn_mask", ".", "extend", "(", "eng_src_ls", "[", "idx", "-", "1", "]", ".", "attn_mask", "[", "1", ":", "]", ")", "\n", "", "assert", "len", "(", "tgt_src_ls", ")", "==", "len", "(", "eng_src_ls", ")", "\n", "self", ".", "src_ls", "=", "tgt_src_ls", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.batch": [[63, 83], ["range", "len", "len", "len", "data.append", "data_loader.InferenceDataLoader.batchify", "len", "data_loader.InferenceDataLoader.batchify"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batchify", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batchify"], ["", "def", "batch", "(", "self", ")", ":", "\n", "        ", "data", "=", "[", "]", "\n", "idx_span", "=", "0", "\n", "tmp_max_src", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "src_ls", ")", ")", ":", "\n", "            ", "src_num", "=", "len", "(", "self", ".", "src_ls", "[", "i", "]", ")", "\n", "if", "src_num", ">", "tmp_max_src", ":", "\n", "                ", "tmp_max_src", "=", "src_num", "\n", "", "if", "src_num", "*", "idx_span", ">", "self", ".", "batch_size", ":", "\n", "                ", "if", "len", "(", "data", ")", "!=", "0", ":", "\n", "                    ", "yield", "self", ".", "batchify", "(", "data", ")", "\n", "", "data", "=", "[", "self", ".", "src_ls", "[", "i", "]", "]", "\n", "idx_span", "=", "1", "\n", "tmp_max_src", "=", "src_num", "\n", "", "else", ":", "\n", "                ", "idx_span", "+=", "1", "\n", "data", ".", "append", "(", "self", ".", "src_ls", "[", "i", "]", ")", "\n", "", "", "if", "len", "(", "data", ")", "!=", "0", ":", "\n", "            ", "yield", "self", ".", "batchify", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.InferenceDataLoader.batchify": [[84, 98], ["min", "max", "xlm_ls.append", "attn_ls.append", "str_snt.append", "torch.Tensor().long", "torch.Tensor().long", "len", "torch.Tensor", "torch.Tensor", "len", "len"], "methods", ["None"], ["", "", "def", "batchify", "(", "self", ",", "data", ")", ":", "\n", "        ", "max_src_length", "=", "0", "\n", "for", "datum", "in", "data", ":", "\n", "            ", "max_src_length", "=", "max", "(", "max_src_length", ",", "len", "(", "datum", ".", "snt", ")", ")", "\n", "", "max_src_length", "=", "min", "(", "max_src_length", ",", "512", ")", "\n", "\n", "xlm_ls", "=", "[", "]", "\n", "attn_ls", "=", "[", "]", "\n", "str_snt", "=", "[", "]", "\n", "for", "datum", "in", "data", ":", "\n", "            ", "xlm_ls", ".", "append", "(", "datum", ".", "snt", "[", ":", "max_src_length", "]", "+", "[", "self", ".", "tknzr_pad_id", "]", "*", "(", "max_src_length", "-", "len", "(", "datum", ".", "snt", ")", ")", ")", "# for tgt_language-AMR", "\n", "attn_ls", ".", "append", "(", "datum", ".", "attn_mask", "[", ":", "max_src_length", "]", "+", "[", "0", "]", "*", "(", "max_src_length", "-", "len", "(", "datum", ".", "attn_mask", ")", ")", ")", "\n", "str_snt", ".", "append", "(", "datum", ".", "str_snt", ")", "\n", "", "return", "torch", ".", "Tensor", "(", "xlm_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "attn_ls", ")", ".", "long", "(", ")", ",", "str_snt", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.__init__": [[100, 154], ["len", "range", "range", "open", "print", "len", "open", "len", "range", "data_loader.DataLoader.tgt_ls.append", "data_loader.tokenize", "range", "range", "data_loader.DataLoader.src_ls[].append", "len", "len", "range", "range", "len", "data_loader.SrcSent", "new_src_ls[].append", "new_tgt_ls.append", "len", "range", "line.split", "[].snt.extend", "[].attn_mask.extend", "new_src_ls[].append", "new_tgt_ls.append"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.tokenize"], ["    ", "def", "__init__", "(", "self", ",", "src_filename_ls", ",", "tgt_filename", ",", "batch_size", ",", "tknzr", ",", "src_vocab", ",", "tgt_vocab", ",", "train", ",", "world_size", "=", "1", ",", "\n", "rank", "=", "0", ",", "flatten", "=", "1", ",", "mask_rate", "=", "0.0", ")", ":", "\n", "# src_ls[i] = samples in the i-th language", "\n", "        ", "self", ".", "mask_rate", "=", "mask_rate", "\n", "self", ".", "max_src_num", "=", "150", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "language_num", "=", "len", "(", "src_filename_ls", ")", "\n", "self", ".", "world_size", "=", "world_size", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "src_pad_id", "=", "src_vocab", ".", "stoi", "[", "\"<blank>\"", "]", "\n", "self", ".", "tknzr_pad_id", "=", "tknzr", ".", "pad_token_id", "\n", "self", ".", "tknzr_mask_id", "=", "tknzr", ".", "mask_token_id", "\n", "self", ".", "tgt_pad_id", "=", "tgt_vocab", ".", "stoi", "[", "\"<blank>\"", "]", "\n", "self", ".", "train", "=", "train", "\n", "self", ".", "src_ls", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "src_filename_ls", ")", ")", "]", "\n", "self", ".", "tgt_ls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "src_filename_ls", ")", ")", ":", "\n", "            ", "f", "=", "open", "(", "src_filename_ls", "[", "i", "]", ",", "encoding", "=", "'utf-8'", ")", "\n", "for", "line", "in", "f", ":", "\n", "                ", "self", ".", "src_ls", "[", "i", "]", ".", "append", "(", "SrcSent", "(", "line", ",", "tknzr", ",", "src_vocab", "=", "src_vocab", "if", "i", "==", "0", "else", "None", ")", ")", "\n", "", "", "for", "i", "in", "range", "(", "1", ",", "len", "(", "src_filename_ls", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "len", "(", "self", ".", "src_ls", "[", "i", "]", ")", ")", ":", "\n", "                ", "self", ".", "src_ls", "[", "i", "]", "[", "j", "]", ".", "bpe_snt", "=", "self", ".", "src_ls", "[", "0", "]", "[", "j", "]", ".", "bpe_snt", "\n", "", "", "f", "=", "open", "(", "tgt_filename", ",", "encoding", "=", "'utf-8'", ")", "\n", "for", "line", "in", "f", ":", "\n", "            ", "self", ".", "tgt_ls", ".", "append", "(", "[", "\"<s2>\"", "]", "+", "line", ".", "split", "(", ")", "+", "[", "\"</s>\"", "]", ")", "\n", "self", ".", "tgt_ls", "[", "-", "1", "]", "=", "tokenize", "(", "tgt_vocab", ",", "self", ".", "tgt_ls", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "flatten", "==", "1", ":", "\n", "# flatten the src_ls ", "\n", "            ", "new_src_ls", "=", "[", "[", "]", "]", "\n", "new_tgt_ls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "tgt_ls", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "language_num", ")", ":", "\n", "                    ", "new_src_ls", "[", "0", "]", ".", "append", "(", "self", ".", "src_ls", "[", "j", "]", "[", "i", "]", ")", "\n", "new_tgt_ls", ".", "append", "(", "self", ".", "tgt_ls", "[", "i", "]", ")", "\n", "", "", "self", ".", "src_ls", "=", "new_src_ls", "\n", "self", ".", "tgt_ls", "=", "new_tgt_ls", "\n", "self", ".", "language_num", "=", "1", "\n", "", "elif", "flatten", "==", "2", ":", "\n", "# flatten the src_ls, concat the Eng snt and the foreign language snt", "\n", "            ", "self", ".", "max_src_num", "=", "300", "\n", "new_src_ls", "=", "[", "[", "]", "]", "\n", "new_tgt_ls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "tgt_ls", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "1", ",", "self", ".", "language_num", ")", ":", "\n", "                    ", "self", ".", "src_ls", "[", "j", "]", "[", "i", "]", ".", "snt", ".", "extend", "(", "self", ".", "src_ls", "[", "0", "]", "[", "i", "]", ".", "snt", "[", "1", ":", "]", ")", "# add Eng snt, remove BOS of eng snt", "\n", "self", ".", "src_ls", "[", "j", "]", "[", "i", "]", ".", "attn_mask", ".", "extend", "(", "self", ".", "src_ls", "[", "0", "]", "[", "i", "]", ".", "attn_mask", "[", "1", ":", "]", ")", "\n", "new_src_ls", "[", "0", "]", ".", "append", "(", "self", ".", "src_ls", "[", "j", "]", "[", "i", "]", ")", "\n", "new_tgt_ls", ".", "append", "(", "self", ".", "tgt_ls", "[", "i", "]", ")", "\n", "", "", "self", ".", "src_ls", "=", "new_src_ls", "\n", "self", ".", "tgt_ls", "=", "new_tgt_ls", "\n", "self", ".", "language_num", "=", "1", "\n", "", "print", "(", "\"data finished\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batch": [[155, 227], ["list", "range", "list.sort", "range", "random.shuffle", "len", "len", "range", "range", "len", "max", "max", "len", "max", "max", "len", "yield_data.append", "random.shuffle", "len", "max", "len", "len", "yield_data.append", "random.shuffle", "len", "len", "len", "data.append", "data.append", "data_loader.DataLoader.batchify", "data.append", "data_loader.DataLoader.batchify", "len", "len", "yield_data.append", "len", "len", "yield_data.append", "range", "range", "len", "range", "range", "range", "range", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batchify", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batchify"], ["", "def", "batch", "(", "self", ")", ":", "\n", "        ", "idx_ls", "=", "list", "(", "range", "(", "len", "(", "self", ".", "tgt_ls", ")", ")", ")", "\n", "if", "self", ".", "train", ":", "\n", "            ", "random", ".", "shuffle", "(", "idx_ls", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "idx_ls", ")", ")", ":", "\n", "            ", "idx_ls", "[", "i", "]", "=", "[", "i", ",", "max", "(", "len", "(", "self", ".", "tgt_ls", "[", "i", "]", ")", ",", "len", "(", "self", ".", "src_ls", "[", "0", "]", "[", "i", "]", ")", ")", "]", "\n", "", "idx_ls", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "# idx_ls[i]: [idx, len]", "\n", "\n", "data", "=", "[", "]", "\n", "idx_span", "=", "0", "\n", "tmp_max_src", "=", "0", "\n", "tmp_max_tgt", "=", "0", "\n", "\n", "yield_data", "=", "[", "]", "\n", "\n", "if", "self", ".", "world_size", ">", "1", ":", "\n", "            ", "length", "=", "len", "(", "idx_ls", ")", "\n", "for", "ptr", "in", "range", "(", "length", ")", ":", "\n", "                ", "idx", "=", "idx_ls", "[", "ptr", "]", "[", "0", "]", "\n", "src_num", "=", "max", "(", "[", "len", "(", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", ")", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", ")", "\n", "tgt_num", "=", "len", "(", "self", ".", "tgt_ls", "[", "idx", "]", ")", "\n", "if", "self", ".", "train", "and", "src_num", ">", "self", ".", "max_src_num", ":", "\n", "                    ", "continue", "\n", "", "tmp_max_src", "=", "max", "(", "tmp_max_src", ",", "src_num", ")", "\n", "tmp_max_tgt", "=", "max", "(", "tmp_max_tgt", ",", "tgt_num", ")", "\n", "if", "len", "(", "data", ")", "<", "self", ".", "world_size", ":", "\n", "                    ", "data", ".", "append", "(", "[", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", "+", "[", "self", ".", "tgt_ls", "[", "idx", "]", "]", ")", "\n", "continue", "\n", "", "flag", "=", "0", "if", "(", "len", "(", "data", ")", "+", "1", ")", "%", "self", ".", "world_size", "==", "0", "else", "1", "\n", "if", "tmp_max_src", "*", "(", "(", "len", "(", "data", ")", "+", "1", ")", "//", "self", ".", "world_size", "+", "flag", ")", "*", "self", ".", "language_num", "+", "tmp_max_tgt", "*", "self", ".", "language_num", "*", "(", "(", "len", "(", "data", ")", "+", "1", ")", "//", "self", ".", "world_size", "+", "flag", ")", ">", "self", ".", "batch_size", ":", "\n", "                    ", "if", "len", "(", "data", ")", ">=", "self", ".", "world_size", ":", "\n", "                        ", "yield_data", ".", "append", "(", "data", ")", "\n", "", "data", "=", "[", "[", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", "+", "[", "self", ".", "tgt_ls", "[", "idx", "]", "]", "]", "\n", "tmp_max_src", "=", "src_num", "\n", "tmp_max_tgt", "=", "tgt_num", "\n", "", "else", ":", "\n", "                    ", "data", ".", "append", "(", "[", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", "+", "[", "self", ".", "tgt_ls", "[", "idx", "]", "]", ")", "\n", "", "", "if", "len", "(", "data", ")", ">=", "self", ".", "world_size", ":", "\n", "                ", "yield_data", ".", "append", "(", "data", ")", "\n", "", "if", "self", ".", "train", ":", "\n", "                ", "random", ".", "shuffle", "(", "yield_data", ")", "\n", "", "for", "ele", "in", "yield_data", ":", "\n", "                ", "yield", "self", ".", "batchify", "(", "ele", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "idx_ls", ")", ")", ":", "\n", "                ", "idx", "=", "idx_ls", "[", "i", "]", "[", "0", "]", "\n", "src_num", "=", "max", "(", "[", "len", "(", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", ")", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", ")", "\n", "tgt_num", "=", "len", "(", "self", ".", "tgt_ls", "[", "idx", "]", ")", "\n", "if", "self", ".", "train", "and", "src_num", ">", "self", ".", "max_src_num", ":", "\n", "                    ", "continue", "\n", "", "if", "src_num", ">", "tmp_max_src", ":", "\n", "                    ", "tmp_max_src", "=", "src_num", "\n", "", "if", "tgt_num", ">", "tmp_max_tgt", ":", "\n", "                    ", "tmp_max_tgt", "=", "tgt_num", "\n", "", "if", "(", "tmp_max_src", "+", "tmp_max_tgt", ")", "*", "(", "idx_span", "+", "1", ")", "*", "self", ".", "language_num", ">", "self", ".", "batch_size", ":", "\n", "                    ", "if", "len", "(", "data", ")", "!=", "0", ":", "\n", "                        ", "yield_data", ".", "append", "(", "data", ")", "\n", "", "data", "=", "[", "[", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", "+", "[", "self", ".", "tgt_ls", "[", "idx", "]", "]", "]", "\n", "idx_span", "=", "1", "\n", "tmp_max_src", "=", "src_num", "\n", "tmp_max_tgt", "=", "tgt_num", "\n", "", "else", ":", "\n", "                    ", "idx_span", "+=", "1", "\n", "data", ".", "append", "(", "[", "self", ".", "src_ls", "[", "t", "]", "[", "idx", "]", "for", "t", "in", "range", "(", "self", ".", "language_num", ")", "]", "+", "[", "self", ".", "tgt_ls", "[", "idx", "]", "]", ")", "\n", "", "", "if", "len", "(", "data", ")", "!=", "0", ":", "\n", "                ", "yield_data", ".", "append", "(", "data", ")", "\n", "", "if", "self", ".", "train", ":", "\n", "                ", "random", ".", "shuffle", "(", "yield_data", ")", "\n", "", "for", "ele", "in", "yield_data", ":", "\n", "                ", "yield", "self", ".", "batchify", "(", "ele", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.DataLoader.batchify": [[228, 294], ["list", "len", "range", "len", "enumerate", "range", "range", "range", "max", "max", "enumerate", "len", "range", "max", "len", "len", "range", "src_ls.append", "tgt_ls.append", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "range", "src_ls.append", "tgt_ls.append", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "len", "range", "xlm_ls.append", "attn_ls.append", "range", "xlm_ls.append", "attn_ls.append", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "random.random", "len", "random.random", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "", "", "def", "batchify", "(", "self", ",", "data", ")", ":", "\n", "# data: list", "\n", "# data[i]: [SrcSent_1, ..., SrcSent_5, tgt]", "\n", "# tgt is a list", "\n", "        ", "idx_ls", "=", "list", "(", "range", "(", "len", "(", "data", ")", ")", ")", "\n", "length", "=", "len", "(", "data", ")", "\n", "per_length", "=", "[", "length", "//", "self", ".", "world_size", "for", "_", "in", "range", "(", "self", ".", "world_size", ")", "]", "\n", "if", "length", "%", "self", ".", "world_size", "!=", "0", ":", "\n", "            ", "for", "i", "in", "range", "(", "length", "%", "self", ".", "world_size", ")", ":", "\n", "                ", "per_length", "[", "i", "]", "+=", "1", "\n", "", "", "for", "i", "in", "range", "(", "1", ",", "self", ".", "world_size", ")", ":", "\n", "            ", "per_length", "[", "i", "]", "+=", "per_length", "[", "i", "-", "1", "]", "\n", "", "batch_size", "=", "len", "(", "data", ")", "\n", "max_src_length_1", "=", "max_src_length_2", "=", "max_tgt_length", "=", "0", "\n", "for", "idx", ",", "datum", "in", "enumerate", "(", "data", ")", ":", "\n", "            ", "if", "self", ".", "rank", "==", "0", ":", "\n", "                ", "if", "idx", ">=", "per_length", "[", "0", "]", ":", "\n", "                    ", "continue", "\n", "", "", "else", ":", "\n", "                ", "if", "idx", "<", "per_length", "[", "self", ".", "rank", "-", "1", "]", "or", "idx", ">=", "per_length", "[", "self", ".", "rank", "]", ":", "\n", "                    ", "continue", "\n", "", "", "for", "i", "in", "range", "(", "self", ".", "language_num", ")", ":", "\n", "                ", "max_src_length_1", "=", "max", "(", "max_src_length_1", ",", "len", "(", "datum", "[", "i", "]", ".", "snt", ")", ")", "\n", "", "max_src_length_2", "=", "max", "(", "max_src_length_2", ",", "len", "(", "datum", "[", "0", "]", ".", "bpe_snt", ")", ")", "\n", "max_tgt_length", "=", "max", "(", "max_tgt_length", ",", "len", "(", "datum", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "xlm_ls", "=", "[", "]", "\n", "src_ls", "=", "[", "]", "\n", "tgt_ls", "=", "[", "]", "\n", "attn_ls", "=", "[", "]", "\n", "if", "self", ".", "world_size", "==", "1", ":", "\n", "            ", "for", "datum", "in", "data", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "language_num", ")", ":", "\n", "                    ", "new_snt", "=", "datum", "[", "i", "]", ".", "snt", "\n", "new_attn_mask", "=", "datum", "[", "i", "]", ".", "attn_mask", "\n", "for", "t", "in", "range", "(", "len", "(", "new_snt", ")", "-", "1", ",", "datum", "[", "i", "]", ".", "snt_len", "-", "1", ",", "-", "1", ")", ":", "\n", "                        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "mask_rate", ":", "\n", "#new_snt[t] = self.tknzr_mask_id    # for masking", "\n", "                            ", "new_snt", "=", "new_snt", "[", ":", "t", "]", "+", "new_snt", "[", "t", "+", "1", ":", "]", "# for deleting", "\n", "new_attn_mask", "=", "new_attn_mask", "[", ":", "t", "]", "+", "new_attn_mask", "[", "t", "+", "1", ":", "]", "\n", "", "", "xlm_ls", ".", "append", "(", "new_snt", "+", "[", "self", ".", "tknzr_pad_id", "]", "*", "(", "max_src_length_1", "-", "len", "(", "new_snt", ")", ")", ")", "\n", "attn_ls", ".", "append", "(", "new_attn_mask", "+", "[", "0", "]", "*", "(", "max_src_length_1", "-", "len", "(", "new_attn_mask", ")", ")", ")", "\n", "", "src_ls", ".", "append", "(", "datum", "[", "0", "]", ".", "bpe_snt", "+", "[", "self", ".", "src_pad_id", "]", "*", "(", "max_src_length_2", "-", "len", "(", "datum", "[", "0", "]", ".", "bpe_snt", ")", ")", ")", "\n", "tgt_ls", ".", "append", "(", "datum", "[", "-", "1", "]", "+", "[", "self", ".", "tgt_pad_id", "]", "*", "(", "max_tgt_length", "-", "len", "(", "datum", "[", "-", "1", "]", ")", ")", ")", "\n", "", "return", "torch", ".", "Tensor", "(", "xlm_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "attn_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "src_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "tgt_ls", ")", ".", "long", "(", ")", "\n", "", "else", ":", "\n", "            ", "for", "idx", ",", "datum", "in", "enumerate", "(", "data", ")", ":", "\n", "                ", "if", "self", ".", "rank", "==", "0", ":", "\n", "                    ", "if", "idx", ">=", "per_length", "[", "0", "]", ":", "\n", "                        ", "continue", "\n", "", "", "else", ":", "\n", "                    ", "if", "idx", "<", "per_length", "[", "self", ".", "rank", "-", "1", "]", "or", "idx", ">=", "per_length", "[", "self", ".", "rank", "]", ":", "\n", "                        ", "continue", "\n", "", "", "for", "i", "in", "range", "(", "self", ".", "language_num", ")", ":", "\n", "                    ", "new_snt", "=", "datum", "[", "i", "]", ".", "snt", "\n", "new_attn_mask", "=", "datum", "[", "i", "]", ".", "attn_mask", "\n", "for", "t", "in", "range", "(", "len", "(", "new_snt", ")", "-", "1", ",", "datum", "[", "i", "]", ".", "snt_len", "-", "1", ",", "-", "1", ")", ":", "\n", "                        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "mask_rate", ":", "\n", "#new_snt[t] = self.tknzr_mask_id    # for masking", "\n", "                            ", "new_snt", "=", "new_snt", "[", ":", "t", "]", "+", "new_snt", "[", "t", "+", "1", ":", "]", "# for deleting", "\n", "new_attn_mask", "=", "new_attn_mask", "[", ":", "t", "]", "+", "new_attn_mask", "[", "t", "+", "1", ":", "]", "\n", "", "", "xlm_ls", ".", "append", "(", "new_snt", "+", "[", "self", ".", "tknzr_pad_id", "]", "*", "(", "max_src_length_1", "-", "len", "(", "new_snt", ")", ")", ")", "\n", "attn_ls", ".", "append", "(", "new_attn_mask", "+", "[", "0", "]", "*", "(", "max_src_length_1", "-", "len", "(", "new_attn_mask", ")", ")", ")", "\n", "", "src_ls", ".", "append", "(", "datum", "[", "0", "]", ".", "bpe_snt", "+", "[", "self", ".", "src_pad_id", "]", "*", "(", "max_src_length_2", "-", "len", "(", "datum", "[", "0", "]", ".", "bpe_snt", ")", ")", ")", "\n", "tgt_ls", ".", "append", "(", "datum", "[", "-", "1", "]", "+", "[", "self", ".", "tgt_pad_id", "]", "*", "(", "max_tgt_length", "-", "len", "(", "datum", "[", "-", "1", "]", ")", ")", ")", "\n", "", "return", "torch", ".", "Tensor", "(", "xlm_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "attn_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "src_ls", ")", ".", "long", "(", ")", ",", "torch", ".", "Tensor", "(", "tgt_ls", ")", ".", "long", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.data_loader.tokenize": [[6, 10], ["range", "len", "vocab.stoi.get"], "function", ["None"], ["def", "tokenize", "(", "vocab", ",", "snt", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "snt", ")", ")", ":", "\n", "        ", "snt", "[", "i", "]", "=", "vocab", ".", "stoi", ".", "get", "(", "snt", "[", "i", "]", ",", "vocab", ".", "stoi", "[", "'<unk>'", "]", ")", "\n", "", "return", "snt", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter.__init__": [[162, 174], ["dataset.DatasetIter._next_dataset_iterator"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter._next_dataset_iterator"], ["def", "__init__", "(", "self", ",", "datasets", ",", "fields", ",", "batch_size", ",", "batch_size_fn", ",", "\n", "device", ",", "is_train", ")", ":", "\n", "    ", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "fields", "=", "fields", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "batch_size_fn", "=", "batch_size_fn", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "is_train", "=", "is_train", "\n", "\n", "self", ".", "cur_iter", "=", "self", ".", "_next_dataset_iterator", "(", "datasets", ")", "\n", "# We have at least one dataset.", "\n", "assert", "self", ".", "cur_iter", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter.__iter__": [[175, 181], ["dataset.DatasetIter._next_dataset_iterator"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter._next_dataset_iterator"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "    ", "dataset_iter", "=", "(", "d", "for", "d", "in", "self", ".", "datasets", ")", "\n", "while", "self", ".", "cur_iter", "is", "not", "None", ":", "\n", "      ", "for", "batch", "in", "self", ".", "cur_iter", ":", "\n", "        ", "yield", "batch", "\n", "", "self", ".", "cur_iter", "=", "self", ".", "_next_dataset_iterator", "(", "dataset_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter.__len__": [[182, 188], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "# We return the len of cur_dataset, otherwise we need to load", "\n", "# all datasets to determine the real len, which loses the benefit", "\n", "# of lazy loading.", "\n", "    ", "assert", "self", ".", "cur_iter", "is", "not", "None", "\n", "return", "len", "(", "self", ".", "cur_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.DatasetIter._next_dataset_iterator": [[189, 213], ["dataset.OrderedIterator", "hasattr", "next", "gc.collect", "gc.collect"], "methods", ["None"], ["", "def", "_next_dataset_iterator", "(", "self", ",", "dataset_iter", ")", ":", "\n", "    ", "try", ":", "\n", "# Drop the current dataset for decreasing memory", "\n", "      ", "if", "hasattr", "(", "self", ",", "\"cur_dataset\"", ")", ":", "\n", "        ", "self", ".", "cur_dataset", ".", "examples", "=", "None", "\n", "gc", ".", "collect", "(", ")", "\n", "del", "self", ".", "cur_dataset", "\n", "gc", ".", "collect", "(", ")", "\n", "\n", "", "self", ".", "cur_dataset", "=", "next", "(", "dataset_iter", ")", "\n", "", "except", "StopIteration", ":", "\n", "      ", "return", "None", "\n", "\n", "# We clear `fields` when saving, restore when loading.", "\n", "", "self", ".", "cur_dataset", ".", "fields", "=", "self", ".", "fields", "\n", "\n", "# Sort batch by decreasing lengths of sentence required by pytorch.", "\n", "# sort=False means \"Use dataset's sortkey instead of iterator's\".", "\n", "return", "OrderedIterator", "(", "\n", "dataset", "=", "self", ".", "cur_dataset", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "batch_size_fn", "=", "self", ".", "batch_size_fn", ",", "\n", "device", "=", "self", ".", "device", ",", "train", "=", "self", ".", "is_train", ",", "\n", "sort", "=", "False", ",", "sort_within_batch", "=", "True", ",", "\n", "repeat", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.OrderedIterator.create_batches": [[217, 252], ["dataset.OrderedIterator.create_batches._pool"], "methods", ["None"], ["def", "create_batches", "(", "self", ")", ":", "\n", "    ", "\"\"\" Create batches \"\"\"", "\n", "if", "self", ".", "train", ":", "\n", "      ", "def", "_pool", "(", "data", ",", "random_shuffler", ")", ":", "\n", "        ", "for", "p", "in", "torchtext", ".", "data", ".", "batch", "(", "data", ",", "self", ".", "batch_size", "*", "100", ")", ":", "\n", "          ", "p_batch", "=", "torchtext", ".", "data", ".", "batch", "(", "\n", "sorted", "(", "p", ",", "key", "=", "self", ".", "sort_key", ")", ",", "\n", "self", ".", "batch_size", ",", "self", ".", "batch_size_fn", ")", "\n", "for", "b", "in", "random_shuffler", "(", "list", "(", "p_batch", ")", ")", ":", "\n", "            ", "batch_size", "=", "len", "(", "b", ")", "\n", "token_ls", "=", "[", "len", "(", "ele", ".", "src", ")", "+", "len", "(", "ele", ".", "tgt2", ")", "for", "ele", "in", "b", "]", "\n", "num_tokens", "=", "max", "(", "[", "len", "(", "ele", ".", "src", ")", "+", "len", "(", "ele", ".", "tgt2", ")", "for", "ele", "in", "b", "]", ")", "*", "batch_size", "\n", "if", "num_tokens", "<=", "4444", ":", "\n", "              ", "yield", "b", "\n", "", "else", ":", "\n", "              ", "tmp_max_token", "=", "0", "\n", "prev", "=", "-", "1", "\n", "ret", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "token_ls", ")", ")", ":", "\n", "                ", "tmp_max_token", "=", "max", "(", "tmp_max_token", ",", "token_ls", "[", "i", "]", ")", "\n", "ret", ".", "append", "(", "b", "[", "i", "]", ")", "\n", "if", "tmp_max_token", "*", "(", "i", "-", "prev", ")", ">", "4444", ":", "\n", "                  ", "yield", "ret", "[", ":", "-", "1", "]", "\n", "ret", "=", "[", "b", "[", "i", "]", "]", "\n", "tmp_max_token", "=", "token_ls", "[", "i", "]", "\n", "prev", "=", "i", "-", "1", "\n", "", "", "if", "len", "(", "ret", ")", "!=", "0", ":", "\n", "                ", "yield", "ret", "\n", "\n", "", "", "", "", "", "self", ".", "batches", "=", "_pool", "(", "self", ".", "data", "(", ")", ",", "self", ".", "random_shuffler", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "batches", "=", "[", "]", "\n", "for", "b", "in", "torchtext", ".", "data", ".", "batch", "(", "self", ".", "data", "(", ")", ",", "self", ".", "batch_size", ",", "\n", "self", ".", "batch_size_fn", ")", ":", "\n", "        ", "self", ".", "batches", ".", "append", "(", "sorted", "(", "b", ",", "key", "=", "self", ".", "sort_key", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.__init__": [[359, 407], ["dataset.get_source_fields", "get_target2_fields.keys", "super().__init__", "dict", "torchtext.data.Example", "zip", "out_examples.append", "hasattr", "itertools.chain", "dataset.Dataset.__init__._join_dicts"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_source_fields", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__"], ["  ", "def", "__init__", "(", "self", ",", "fields", ",", "src_examples_iter", ",", "tgt_examples_iter", ",", "\n", "src_seq_length", "=", "0", ",", "tgt_seq_length", "=", "0", ",", "\n", "use_filter_pred", "=", "True", ",", "task_type", "=", "\"task\"", ")", ":", "\n", "\n", "    ", "self", ".", "src_vocabs", "=", "[", "]", "\n", "\n", "def", "_join_dicts", "(", "*", "args", ")", ":", "\n", "      ", "return", "dict", "(", "chain", "(", "*", "[", "d", ".", "items", "(", ")", "for", "d", "in", "args", "]", ")", ")", "\n", "\n", "", "out_fields", "=", "get_source_fields", "(", ")", "\n", "if", "tgt_examples_iter", "is", "not", "None", ":", "\n", "      ", "examples_iter", "=", "(", "_join_dicts", "(", "src", ",", "tgt", ")", "for", "src", ",", "tgt", "in", "\n", "zip", "(", "src_examples_iter", ",", "tgt_examples_iter", ")", ")", "\n", "if", "task_type", "==", "'task'", ":", "\n", "        ", "out_fields", "=", "get_target_fields", "(", "out_fields", ")", "\n", "", "else", ":", "\n", "        ", "out_fields", "=", "get_target2_fields", "(", "out_fields", ")", "\n", "", "", "else", ":", "\n", "      ", "examples_iter", "=", "src_examples_iter", "\n", "\n", "", "keys", "=", "out_fields", ".", "keys", "(", ")", "\n", "out_fields", "=", "[", "(", "k", ",", "fields", "[", "k", "]", ")", "for", "k", "in", "keys", "]", "\n", "example_values", "=", "(", "[", "ex", "[", "k", "]", "for", "k", "in", "keys", "]", "for", "ex", "in", "examples_iter", ")", "\n", "\n", "out_examples", "=", "[", "]", "\n", "for", "ex_values", "in", "example_values", ":", "\n", "      ", "example", "=", "torchtext", ".", "data", ".", "Example", "(", ")", "\n", "for", "(", "name", ",", "field", ")", ",", "val", "in", "zip", "(", "out_fields", ",", "ex_values", ")", ":", "\n", "        ", "if", "field", "is", "not", "None", ":", "\n", "          ", "setattr", "(", "example", ",", "name", ",", "field", ".", "preprocess", "(", "val", ")", ")", "\n", "", "else", ":", "\n", "          ", "setattr", "(", "example", ",", "name", ",", "val", ")", "\n", "", "", "out_examples", ".", "append", "(", "example", ")", "\n", "\n", "", "def", "filter_pred", "(", "example", ")", ":", "\n", "      ", "\"\"\" ? \"\"\"", "\n", "if", "hasattr", "(", "example", ",", "\"tgt\"", ")", ":", "\n", "        ", "return", "0", "<", "len", "(", "example", ".", "src", ")", "<=", "src_seq_length", "and", "0", "<", "len", "(", "example", ".", "tgt", ")", "<=", "tgt_seq_length", "\n", "", "else", ":", "\n", "        ", "return", "0", "<", "len", "(", "example", ".", "src", ")", "<=", "src_seq_length", "and", "0", "<", "len", "(", "example", ".", "tgt2", ")", "<=", "tgt_seq_length", "\n", "\n", "\n", "", "", "filter_pred", "=", "filter_pred", "if", "use_filter_pred", "else", "lambda", "x", ":", "True", "\n", "\n", "super", "(", "Dataset", ",", "self", ")", ".", "__init__", "(", "\n", "out_examples", ",", "out_fields", ",", "filter_pred", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.__getstate__": [[408, 410], ["None"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "__dict__", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.__setstate__": [[411, 413], ["dataset.Dataset.__dict__.update"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "_d", ")", ":", "\n", "    ", "self", ".", "__dict__", ".", "update", "(", "_d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.sort_key": [[414, 420], ["hasattr", "hasattr", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "sort_key", "(", "self", ",", "ex", ")", ":", "\n", "    ", "if", "hasattr", "(", "ex", ",", "\"tgt\"", ")", ":", "\n", "      ", "return", "len", "(", "ex", ".", "src", ")", ",", "len", "(", "ex", ".", "tgt", ")", "\n", "", "if", "hasattr", "(", "ex", ",", "\"tgt2\"", ")", ":", "\n", "      ", "return", "len", "(", "ex", ".", "src", ")", ",", "len", "(", "ex", ".", "tgt2", ")", "\n", "", "return", "len", "(", "ex", ".", "src", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.make_examples": [[421, 430], ["enumerate", "line.strip().split", "tuple", "line.strip"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_examples", "(", "text_iter", ",", "truncate", ",", "side", ",", "task_type", ")", ":", "\n", "    ", "for", "i", ",", "line", "in", "enumerate", "(", "text_iter", ")", ":", "\n", "      ", "words", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "if", "truncate", ":", "\n", "        ", "words", "=", "words", "[", ":", "truncate", "]", "\n", "\n", "", "example_dict", "=", "{", "side", ":", "tuple", "(", "words", ")", ",", "\"indices\"", ":", "i", ",", "\"task_type\"", ":", "task_type", "}", "\n", "yield", "example_dict", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset._getstate": [[13, 15], ["dict", "dict"], "function", ["None"], ["def", "_getstate", "(", "self", ")", ":", "\n", "  ", "return", "dict", "(", "self", ".", "__dict__", ",", "stoi", "=", "dict", "(", "self", ".", "stoi", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset._setstate": [[17, 20], ["dataset..__dict__.update", "collections.defaultdict"], "function", ["None"], ["", "def", "_setstate", "(", "self", ",", "state", ")", ":", "\n", "  ", "self", ".", "__dict__", ".", "update", "(", "state", ")", "\n", "self", ".", "stoi", "=", "defaultdict", "(", "lambda", ":", "0", ",", "self", ".", "stoi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.make_text_iterator_from_file": [[25, 29], ["codecs.open"], "function", ["None"], ["def", "make_text_iterator_from_file", "(", "path", ")", ":", "\n", "  ", "with", "codecs", ".", "open", "(", "path", ",", "\"r\"", ",", "\"utf-8\"", ")", "as", "corpus_file", ":", "\n", "    ", "for", "line", "in", "corpus_file", ":", "\n", "      ", "yield", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.make_features": [[30, 46], ["isinstance"], "function", ["None"], ["", "", "", "def", "make_features", "(", "batch", ",", "side", ")", ":", "\n", "  ", "\"\"\"\n  Args:\n      batch (Tensor): a batch of source or target data.\n      side (str): for source or for target.\n  Returns:\n      A sequence of src/tgt tensors with optional feature tensors\n      of size (len x batch).\n  \"\"\"", "\n", "assert", "side", "in", "[", "'src'", ",", "'tgt'", ",", "'tgt2'", "]", "\n", "if", "isinstance", "(", "batch", ".", "__dict__", "[", "side", "]", ",", "tuple", ")", ":", "\n", "    ", "data", "=", "batch", ".", "__dict__", "[", "side", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "    ", "data", "=", "batch", ".", "__dict__", "[", "side", "]", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.save_fields_to_vocab": [[47, 57], ["fields.items", "vocab.append"], "function", ["None"], ["", "def", "save_fields_to_vocab", "(", "fields", ")", ":", "\n", "  ", "\"\"\"\n  Save Vocab objects in Field objects to `vocab.pt` file.\n  \"\"\"", "\n", "vocab", "=", "[", "]", "\n", "for", "k", ",", "f", "in", "fields", ".", "items", "(", ")", ":", "\n", "    ", "if", "f", "is", "not", "None", "and", "'vocab'", "in", "f", ".", "__dict__", ":", "\n", "      ", "f", ".", "vocab", ".", "stoi", "=", "f", ".", "vocab", ".", "stoi", "\n", "vocab", ".", "append", "(", "(", "k", ",", "f", ".", "vocab", ")", ")", "\n", "", "", "return", "vocab", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_source_fields": [[58, 72], ["torchtext.data.Field", "torchtext.data.Field"], "function", ["None"], ["", "def", "get_source_fields", "(", "fields", "=", "None", ")", ":", "\n", "  ", "if", "fields", "is", "None", ":", "\n", "    ", "fields", "=", "{", "}", "\n", "\n", "", "fields", "[", "\"src\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "pad_token", "=", "Constants", ".", "PAD_WORD", ",", "\n", "eos_token", "=", "Constants", ".", "EOS_WORD", ",", "\n", "include_lengths", "=", "True", ")", "\n", "\n", "fields", "[", "\"indices\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "use_vocab", "=", "False", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "sequential", "=", "False", ")", "\n", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target_fields": [[73, 87], ["torchtext.data.Field", "torchtext.data.Field"], "function", ["None"], ["", "def", "get_target_fields", "(", "fields", "=", "None", ")", ":", "\n", "  ", "if", "fields", "is", "None", ":", "\n", "    ", "fields", "=", "{", "}", "\n", "\n", "", "fields", "[", "\"tgt\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "init_token", "=", "Constants", ".", "BOS_WORD", ",", "\n", "eos_token", "=", "Constants", ".", "EOS_WORD", ",", "\n", "pad_token", "=", "Constants", ".", "PAD_WORD", ")", "\n", "\n", "fields", "[", "\"indices\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "use_vocab", "=", "False", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "sequential", "=", "False", ")", "\n", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target2_fields": [[88, 102], ["torchtext.data.Field", "torchtext.data.Field"], "function", ["None"], ["", "def", "get_target2_fields", "(", "fields", "=", "None", ")", ":", "\n", "  ", "if", "fields", "is", "None", ":", "\n", "    ", "fields", "=", "{", "}", "\n", "\n", "", "fields", "[", "\"tgt2\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "init_token", "=", "Constants", ".", "BOS_WORD2", ",", "\n", "eos_token", "=", "Constants", ".", "EOS_WORD", ",", "\n", "pad_token", "=", "Constants", ".", "PAD_WORD", ")", "\n", "\n", "fields", "[", "\"indices\"", "]", "=", "torchtext", ".", "data", ".", "Field", "(", "\n", "use_vocab", "=", "False", ",", "dtype", "=", "torch", ".", "long", ",", "\n", "sequential", "=", "False", ")", "\n", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_fields": [[103, 111], ["dataset.get_source_fields", "dataset.get_target_fields", "dataset.get_target2_fields"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_source_fields", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target_fields", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target2_fields"], ["", "def", "get_fields", "(", ")", ":", "\n", "  ", "fields", "=", "{", "}", "\n", "\n", "fields", "=", "get_source_fields", "(", "fields", ")", "\n", "fields", "=", "get_target_fields", "(", "fields", ")", "\n", "fields", "=", "get_target2_fields", "(", "fields", ")", "\n", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_task_fields": [[112, 117], ["dataset.get_source_fields", "dataset.get_target_fields"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_source_fields", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target_fields"], ["", "def", "get_task_fields", "(", ")", ":", "\n", "  ", "fields", "=", "{", "}", "\n", "fields", "=", "get_source_fields", "(", "fields", ")", "\n", "fields", "=", "get_target_fields", "(", "fields", ")", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_task2_fields": [[118, 123], ["dataset.get_source_fields", "dataset.get_target2_fields"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_source_fields", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_target2_fields"], ["", "def", "get_task2_fields", "(", ")", ":", "\n", "  ", "fields", "=", "{", "}", "\n", "fields", "=", "get_source_fields", "(", "fields", ")", "\n", "fields", "=", "get_target2_fields", "(", "fields", ")", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_fields_from_vocab": [[125, 136], ["dict", "dataset.get_fields", "dict.items", "collections.defaultdict"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.get_fields"], ["", "def", "load_fields_from_vocab", "(", "vocab", ")", ":", "\n", "  ", "\"\"\"\n  Load Field objects from `vocab.pt` file.\n  \"\"\"", "\n", "vocab", "=", "dict", "(", "vocab", ")", "\n", "fields", "=", "get_fields", "(", ")", "\n", "for", "k", ",", "v", "in", "vocab", ".", "items", "(", ")", ":", "\n", "# Hack. Can't pickle defaultdict :(", "\n", "    ", "v", ".", "stoi", "=", "defaultdict", "(", "lambda", ":", "0", ",", "v", ".", "stoi", ")", "\n", "fields", "[", "k", "]", ".", "vocab", "=", "v", "\n", "", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_fields": [[137, 148], ["utils.logging.logger.info", "utils.logging.logger.info", "dataset.load_fields_from_vocab", "dataset.load_fields_from_vocab", "torch.load", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_fields_from_vocab", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_fields_from_vocab", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "def", "load_fields", "(", "opt", ",", "checkpoint", ")", ":", "\n", "  ", "if", "checkpoint", "is", "not", "None", ":", "\n", "    ", "logger", ".", "info", "(", "'Loading vocab from checkpoint at %s.'", "%", "opt", ".", "train_from", ")", "\n", "fields", "=", "load_fields_from_vocab", "(", "checkpoint", "[", "'vocab'", "]", ")", "\n", "", "else", ":", "\n", "    ", "fields", "=", "load_fields_from_vocab", "(", "torch", ".", "load", "(", "opt", ".", "data", "+", "'_vocab.pt'", ")", ")", "\n", "\n", "", "logger", ".", "info", "(", "' * vocabulary size. source = %d; target = %d; target2 = %d'", "%", "\n", "(", "len", "(", "fields", "[", "'src'", "]", ".", "vocab", ")", ",", "len", "(", "fields", "[", "'tgt'", "]", ".", "vocab", ")", ",", "len", "(", "fields", "[", "'tgt2'", "]", ".", "vocab", ")", ")", ")", "\n", "\n", "return", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.load_dataset": [[255, 274], ["sorted", "torch.load", "utils.logging.logger.info", "glob.glob", "dataset.load_dataset._dataset_loader"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "", "", "", "def", "load_dataset", "(", "corpus_type", ",", "task_type", ",", "opt", ")", ":", "\n", "  ", "assert", "corpus_type", "in", "[", "\"train\"", ",", "\"valid\"", "]", "\n", "assert", "task_type", "in", "[", "\"task\"", ",", "\"task2\"", "]", "\n", "\n", "\n", "def", "_dataset_loader", "(", "pt_file", ",", "corpus_type", ",", "task_type", ")", ":", "\n", "    ", "dataset", "=", "torch", ".", "load", "(", "pt_file", ")", "\n", "logger", ".", "info", "(", "'Loading %s %s dataset from %s, number of examples: %d'", "%", "\n", "(", "task_type", ",", "corpus_type", ",", "pt_file", ",", "len", "(", "dataset", ")", ")", ")", "\n", "return", "dataset", "\n", "\n", "# Sort the glob output by file name (by increasing indexes).", "\n", "", "pts", "=", "sorted", "(", "glob", ".", "glob", "(", "opt", ".", "data", "+", "'_'", "+", "task_type", "+", "'_'", "+", "corpus_type", "+", "'.[0-9]*.pt'", ")", ")", "\n", "if", "pts", ":", "\n", "    ", "for", "pt", "in", "pts", ":", "\n", "      ", "yield", "_dataset_loader", "(", "pt", ",", "corpus_type", ",", "task_type", ")", "\n", "", "", "else", ":", "\n", "    ", "pt", "=", "opt", ".", "data", "+", "'_'", "+", "corpus_type", "+", "'.pt'", "\n", "yield", "_dataset_loader", "(", "pt", ",", "corpus_type", ",", "task_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.build_dataset": [[275, 300], ["dataset.Dataset.make_examples", "dataset.Dataset", "dataset.Dataset.make_examples", "dataset.Dataset.make_examples"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.make_examples", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.make_examples", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.Dataset.make_examples"], ["", "", "def", "build_dataset", "(", "fields", ",", "\n", "src_data_iter", ",", "\n", "tgt_data_iter", ",", "\n", "src_seq_length", "=", "0", ",", "tgt_seq_length", "=", "0", ",", "\n", "src_seq_length_trunc", "=", "0", ",", "tgt_seq_length_trunc", "=", "0", ",", "\n", "use_filter_pred", "=", "True", ",", "\n", "task_type", "=", "'task'", ")", ":", "\n", "  ", "assert", "src_data_iter", "!=", "None", "\n", "src_examples_iter", "=", "Dataset", ".", "make_examples", "(", "src_data_iter", ",", "src_seq_length_trunc", ",", "\"src\"", ",", "task_type", ")", "\n", "\n", "if", "tgt_data_iter", "!=", "None", ":", "\n", "    ", "if", "task_type", "==", "'task'", ":", "\n", "      ", "tgt_examples_iter", "=", "Dataset", ".", "make_examples", "(", "tgt_data_iter", ",", "tgt_seq_length_trunc", ",", "\"tgt\"", ",", "task_type", ")", "\n", "", "else", ":", "\n", "      ", "tgt_examples_iter", "=", "Dataset", ".", "make_examples", "(", "tgt_data_iter", ",", "tgt_seq_length_trunc", ",", "\"tgt2\"", ",", "task_type", ")", "\n", "", "", "else", ":", "\n", "    ", "tgt_examples_iter", "=", "None", "\n", "\n", "", "dataset", "=", "Dataset", "(", "fields", ",", "src_examples_iter", ",", "tgt_examples_iter", ",", "\n", "src_seq_length", "=", "src_seq_length", ",", "\n", "tgt_seq_length", "=", "tgt_seq_length", ",", "\n", "use_filter_pred", "=", "use_filter_pred", ",", "\n", "task_type", "=", "task_type", ")", "\n", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.inputters.dataset.build_dataset_iter": [[302, 356], ["dataset.DatasetIter", "max", "hasattr", "max", "max", "max", "len", "len", "len"], "function", ["None"], ["", "def", "build_dataset_iter", "(", "datasets", ",", "fields", ",", "opt", ",", "is_train", "=", "True", ",", "task_type", "=", "\"task\"", ")", ":", "\n", "  ", "\"\"\"\n  This returns user-defined train/validate data iterator for the trainer\n  to iterate over. We implement simple ordered iterator strategy here,\n  but more sophisticated strategy like curriculum learning is ok too.\n  \"\"\"", "\n", "# batch_size = opt.batch_size if is_train else opt.valid_batch_size", "\n", "if", "is_train", ":", "\n", "    ", "if", "task_type", "==", "\"task\"", ":", "\n", "      ", "batch_size", "=", "opt", ".", "batch_size", "\n", "", "else", ":", "\n", "      ", "batch_size", "=", "opt", ".", "batch_size2", "\n", "", "", "else", ":", "\n", "# if task_type == \"task\":", "\n", "#   batch_size = opt.task_valid_batch_size", "\n", "# else:", "\n", "#   batch_size = opt.task_valid_batch_size", "\n", "    ", "batch_size", "=", "opt", ".", "valid_batch_size", "\n", "", "if", "is_train", "and", "opt", ".", "batch_type", "==", "\"tokens\"", ":", "\n", "    ", "def", "batch_size_fn", "(", "new", ",", "count", ",", "sofar", ")", ":", "\n", "      ", "\"\"\"\n      In token batching scheme, the number of sequences is limited\n      such that the total number of src/tgt tokens (including padding)\n      in a batch <= batch_size\n      \"\"\"", "\n", "# Maintains the longest src and tgt length in the current batch", "\n", "global", "max_src_in_batch", ",", "max_tgt_in_batch", "\n", "# Reset current longest length at a new batch (count=1)", "\n", "if", "count", "==", "1", ":", "\n", "          ", "max_src_in_batch", "=", "0", "\n", "max_tgt_in_batch", "=", "0", "\n", "# Src: <bos> w1 ... wN <eos>", "\n", "", "max_src_in_batch", "=", "max", "(", "max_src_in_batch", ",", "len", "(", "new", ".", "src", ")", "+", "2", ")", "\n", "# Tgt: w1 ... wN <eos>", "\n", "\n", "# Prepare 4 multask Jointly Learning", "\n", "if", "hasattr", "(", "new", ",", "\"tgt\"", ")", ":", "\n", "        ", "max_tgt_in_batch", "=", "max", "(", "max_tgt_in_batch", ",", "len", "(", "new", ".", "tgt", ")", "+", "1", ")", "\n", "", "else", ":", "\n", "        ", "max_tgt_in_batch", "=", "max", "(", "max_tgt_in_batch", ",", "len", "(", "new", ".", "tgt2", ")", "+", "1", ")", "\n", "\n", "", "src_elements", "=", "count", "*", "max_src_in_batch", "\n", "tgt_elements", "=", "count", "*", "max_tgt_in_batch", "\n", "return", "max", "(", "src_elements", ",", "tgt_elements", ")", "\n", "", "", "else", ":", "\n", "    ", "batch_size_fn", "=", "None", "\n", "\n", "", "if", "opt", ".", "gpu_ranks", ":", "\n", "    ", "device", "=", "\"cuda\"", "\n", "", "else", ":", "\n", "    ", "device", "=", "\"cpu\"", "\n", "\n", "", "return", "DatasetIter", "(", "datasets", ",", "fields", ",", "batch_size", ",", "batch_size_fn", ",", "\n", "device", ",", "is_train", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.create_arg_parser": [[28, 40], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "'''Create argument parser'''", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"directory that contains the amrs\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "'--folder'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Add to do multiple files in a folder - if not, -f is a file'", ")", "\n", "parser", ".", "add_argument", "(", "'-a'", ",", "'--amr_ext'", ",", "default", "=", "'.txt'", ",", "help", "=", "\"extension of AMR files (default .txt, only necessary when doing folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--output_ext'", ",", "default", "=", "'.tf'", ",", "help", "=", "\"extension of output AMR files (default .tf)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "\"--path\"", ",", "required", "=", "True", ",", "choices", "=", "[", "'rel'", ",", "'abs'", "]", ",", "help", "=", "'Add relative or absolute path (only abs implemented)'", ")", "\n", "parser", ".", "add_argument", "(", "'-k'", ",", "'--keep_wiki'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Keep Wiki link when processing'", ")", "\n", "parser", ".", "add_argument", "(", "'-ps'", ",", "'--print_stats'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Print coreference statistics'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.replace_coreference": [[42, 111], ["enumerate", "amr_utils.space_brackets_amr().split", "create_coref_paths.get_var_dict", "range", "amr_utils.reverse_tokenize", "new_amrs.append", "len", "len", "create_coref_paths.print_coref_stats", "len", "new_spl.append", "create_coref_paths.variable_match", "amr_utils.space_brackets_amr", "create_coref_paths.find_cur_path_addition", "len", "spl[].startswith", "spl[].startswith", "create_coref_paths.add_path_to_amr"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.get_var_dict", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.print_coref_stats", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.variable_match", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.find_cur_path_addition", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.add_path_to_amr"], ["", "def", "replace_coreference", "(", "one_line_amrs", ",", "print_stats", ")", ":", "\n", "    ", "'''Function that replaces coreference entities by its relative or absolute path\n       Also normalizes the input, references to variables can not be before instantiation'''", "\n", "new_amrs", "=", "[", "]", "\n", "coref_amrs", "=", "[", "]", "\n", "path_dict", "=", "{", "}", "\n", "\n", "# Tokenize AMRs", "\n", "amrs", "=", "[", "space_brackets_amr", "(", "x", ")", ".", "split", "(", ")", "for", "x", "in", "one_line_amrs", "]", "\n", "# We always skip stuff such as :mode interrogative as possible variables", "\n", "no_var_list", "=", "[", "'interrogative'", ",", "'expressive'", ",", "'imperative'", "]", "\n", "\n", "# Loop over all AMRs", "\n", "for", "count", ",", "spl", "in", "enumerate", "(", "amrs", ")", ":", "\n", "# Find the path for each variable, save in dict", "\n", "        ", "var_dict", "=", "get_var_dict", "(", "spl", ")", "\n", "cur_path", "=", "[", "]", "\n", "all_paths", "=", "[", "]", "\n", "new_spl", "=", "[", "]", "\n", "vars_seen", "=", "[", "]", "\n", "level", ",", "previous_close", "=", "0", ",", "False", "\n", "# Loop over all tokens in AMR", "\n", "# Skip first parenthesis to make things easier, add later", "\n", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "spl", ")", ")", ":", "\n", "# Add all parts, if it is a variable and needs changing we do that later", "\n", "            ", "new_spl", ".", "append", "(", "spl", "[", "idx", "]", ")", "\n", "\n", "# Skip last item, never coreference variable", "\n", "if", "idx", "==", "(", "len", "(", "spl", ")", "-", "1", ")", ":", "\n", "                ", "continue", "\n", "\n", "# Check if entity looks like a coreference variable", "\n", "", "var_check", ",", "vars_seen", "=", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ",", "vars_seen", ")", "\n", "\n", "# Opening parenthesis, means we have to add the previous argument to our path", "\n", "if", "spl", "[", "idx", "]", "==", "'('", ":", "\n", "                ", "level", "+=", "1", "\n", "cur_path", ",", "all_paths", "=", "find_cur_path_addition", "(", "cur_path", ",", "spl", ",", "idx", ",", "all_paths", ")", "\n", "previous_close", "=", "False", "\n", "# Closing, decrease level by 1", "\n", "", "elif", "spl", "[", "idx", "]", "==", "')'", ":", "\n", "                ", "level", "-=", "1", "\n", "previous_close", "=", "True", "\n", "# We previously saw a closing parenthesis, means we have finished the last part of our path", "\n", "", "elif", "previous_close", ":", "\n", "                ", "cur_path", "=", "cur_path", "[", "0", ":", "level", "]", "\n", "previous_close", "=", "False", "\n", "", "elif", "var_check", ":", "\n", "                ", "previous_close", "=", "False", "\n", "# Not a relation or value, often re-entrancy, check whether it exists", "\n", "if", "not", "(", "spl", "[", "idx", "]", ".", "startswith", "(", "':'", ")", "or", "spl", "[", "idx", "]", ".", "startswith", "(", "'\"'", ")", ")", ":", "\n", "                    ", "if", "spl", "[", "idx", "]", "in", "var_dict", ":", "\n", "# Found variable, check paths here", "\n", "                        ", "path_dict", ",", "all_paths", ",", "new_spl", ",", "_", "=", "add_path_to_amr", "(", "spl", ",", "idx", ",", "var_dict", ",", "cur_path", ",", "count", ",", "path_dict", ",", "all_paths", ",", "new_spl", ",", "coref_amrs", ")", "\n", "# We saw a non-interesting entity, just continue", "\n", "", "", "", "else", ":", "\n", "                ", "previous_close", "=", "False", "\n", "\n", "# Reverse tokenization process of AMRs regarding parentheses", "\n", "", "", "new_line", "=", "'('", "+", "\" \"", ".", "join", "(", "new_spl", ")", "\n", "new_line", "=", "reverse_tokenize", "(", "new_line", ")", "\n", "new_amrs", ".", "append", "(", "new_line", ")", "\n", "\n", "# Sanity check", "\n", "", "assert", "len", "(", "amrs", ")", "==", "len", "(", "new_amrs", ")", "\n", "# Print some stats", "\n", "if", "print_stats", ":", "\n", "        ", "print_coref_stats", "(", "coref_amrs", ",", "path_dict", ")", "\n", "", "return", "new_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.get_var_dict": [[113, 144], ["dict", "range", "len", "create_coref_paths.find_cur_path_addition"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.find_cur_path_addition"], ["", "def", "get_var_dict", "(", "spl", ")", ":", "\n", "    ", "'''Function that returns a dictionary with all variables and their absolute path for an AMR'''", "\n", "\n", "cur_path", "=", "[", "]", "\n", "level", "=", "0", "\n", "all_paths", "=", "[", "]", "\n", "var_dict", "=", "dict", "(", ")", "\n", "previous_close", "=", "False", "\n", "\n", "# Skip first parenthesis", "\n", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "spl", ")", ")", ":", "\n", "        ", "if", "spl", "[", "idx", "]", "==", "'('", ":", "\n", "            ", "level", "+=", "1", "\n", "cur_path", ",", "all_paths", "=", "find_cur_path_addition", "(", "cur_path", ",", "spl", ",", "idx", ",", "all_paths", ")", "\n", "previous_close", "=", "False", "\n", "", "elif", "spl", "[", "idx", "]", "==", "')'", ":", "\n", "            ", "level", "-=", "1", "\n", "previous_close", "=", "True", "\n", "", "elif", "spl", "[", "idx", "]", "==", "'/'", ":", "\n", "# Var found", "\n", "            ", "var_name", "=", "spl", "[", "idx", "-", "1", "]", "\n", "var_value", "=", "spl", "[", "idx", "+", "1", "]", "\n", "if", "var_name", "not", "in", "var_dict", ":", "\n", "                ", "var_dict", "[", "var_name", "]", "=", "[", "var_value", ",", "\" \"", ".", "join", "(", "cur_path", ")", "]", "\n", "", "previous_close", "=", "False", "\n", "", "elif", "previous_close", ":", "\n", "            ", "cur_path", "=", "cur_path", "[", "0", ":", "level", "]", "\n", "previous_close", "=", "False", "\n", "", "else", ":", "\n", "            ", "previous_close", "=", "False", "\n", "", "", "return", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.variable_match": [[146, 155], ["vars_seen.append", "any", "amr_utils.between_quotes", "spl[].startswith", "char.isalpha"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.between_quotes"], ["", "def", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ",", "vars_seen", ")", ":", "\n", "    ", "'''Function that matches entities that are variables'''", "\n", "if", "spl", "[", "idx", "+", "1", "]", "==", "'/'", ":", "\n", "        ", "vars_seen", ".", "append", "(", "spl", "[", "idx", "]", ")", "\n", "return", "False", ",", "vars_seen", "\n", "", "elif", "spl", "[", "idx", "-", "1", "]", "!=", "'/'", "and", "any", "(", "char", ".", "isalpha", "(", ")", "for", "char", "in", "spl", "[", "idx", "]", ")", "and", "spl", "[", "idx", "]", "not", "in", "no_var_list", "and", "not", "between_quotes", "(", "spl", "[", "idx", "]", ")", "and", "not", "spl", "[", "idx", "]", ".", "startswith", "(", "':'", ")", ":", "\n", "        ", "return", "True", ",", "vars_seen", "\n", "", "else", ":", "\n", "        ", "return", "False", ",", "vars_seen", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.find_cur_path_addition": [[157, 180], ["range", "cur_path.append", "all_paths.append", "len", "len", "print", "set"], "function", ["None"], ["", "", "def", "find_cur_path_addition", "(", "cur_path", ",", "spl", ",", "idx", ",", "all_paths", ")", ":", "\n", "    ", "'''Function that finds what we have to add to our current path'''", "\n", "counter", "=", "1", "\n", "found_before", "=", "False", "\n", "for", "c", "in", "range", "(", "15", ",", "1", ",", "-", "1", ")", ":", "\n", "# If there are multiple occurences, add the next one (2,3,4,5 etc)", "\n", "        ", "to_add", "=", "\"\"", ".", "join", "(", "cur_path", ")", "+", "spl", "[", "idx", "-", "1", "]", "+", "'|{0}|'", ".", "format", "(", "c", ")", "\n", "if", "to_add", "in", "all_paths", ":", "\n", "            ", "counter", "=", "c", "\n", "found_before", "=", "True", "\n", "break", "\n", "", "prev_add", "=", "to_add", "\n", "\n", "", "if", "not", "found_before", ":", "\n", "        ", "counter", "=", "1", "\n", "\n", "", "cur_path", ".", "append", "(", "spl", "[", "idx", "-", "1", "]", "+", "'|{0}|'", ".", "format", "(", "counter", ")", ")", "\n", "all_paths", ".", "append", "(", "prev_add", ")", "\n", "\n", "if", "len", "(", "all_paths", ")", "!=", "len", "(", "set", "(", "all_paths", ")", ")", ":", "\n", "        ", "print", "(", "'Something is wrong'", ")", "\n", "\n", "", "return", "cur_path", ",", "all_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.remove_variables": [[182, 194], ["re.sub", "re.findall", "amr_utils.left_space_for_char", "new_amrs.append", "amr_utils.reverse_tokenize", "add_enter.replace.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.left_space_for_char", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize"], ["", "def", "remove_variables", "(", "amrs", ")", ":", "\n", "    ", "'''Replace variables in AMR'''", "\n", "new_amrs", "=", "[", "]", "\n", "for", "a", "in", "amrs", ":", "\n", "        ", "add_enter", "=", "re", ".", "sub", "(", "r'(:[a-zA-Z0-9-]+)(\\|\\d\\|)'", ",", "r'\\1 \\2'", ",", "a", ")", "\n", "p", "=", "re", ".", "findall", "(", "r'\\(([a-zA-Z0-9-_\\. ]+/)'", ",", "add_enter", ")", "\n", "for", "x", "in", "p", ":", "\n", "            ", "if", "'\"'", "not", "in", "x", ":", "\n", "                ", "add_enter", "=", "add_enter", ".", "replace", "(", "x", ",", "''", ")", "\n", "", "", "final_string", "=", "left_space_for_char", "(", "add_enter", ",", "'('", ")", "\n", "new_amrs", ".", "append", "(", "reverse_tokenize", "(", "final_string", ")", ")", "\n", "", "return", "new_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.add_path_to_amr": [[196, 214], ["spl[].startswith", "create_coref_paths.find_cur_path_addition", "NotImplementedError", "amr_utils.add_to_dict", "coref_amrs.append"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.find_cur_path_addition", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.add_to_dict"], ["", "def", "add_path_to_amr", "(", "spl", ",", "idx", ",", "var_dict", ",", "cur_path", ",", "count", ",", "path_dict", ",", "all_paths", ",", "new_spl", ",", "coref_amrs", ")", ":", "\n", "    ", "'''Function that finds the path that needs to be added and adds it'''", "\n", "# We skipped this part of the path because it doesn't start with a parenthesis, still add it here", "\n", "if", "spl", "[", "idx", "-", "1", "]", ".", "startswith", "(", "':'", ")", ":", "\n", "        ", "cur_path", ",", "all_paths", "=", "find_cur_path_addition", "(", "cur_path", ",", "spl", ",", "idx", ",", "all_paths", ")", "\n", "\n", "", "if", "args", ".", "path", "==", "'rel'", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Relative paths are not implemented yet\"", ")", "\n", "", "else", ":", "\n", "# Add absolute path here", "\n", "        ", "new_spl", "[", "-", "1", "]", "=", "'{ '", "+", "var_dict", "[", "spl", "[", "idx", "]", "]", "[", "1", "]", "+", "' }'", "\n", "add_path", "=", "var_dict", "[", "spl", "[", "idx", "]", "]", "[", "1", "]", "\n", "\n", "# Check if we already added this AMR", "\n", "if", "not", "coref_amrs", "or", "coref_amrs", "[", "-", "1", "]", "!=", "count", ":", "\n", "            ", "coref_amrs", ".", "append", "(", "count", ")", "\n", "", "path_dict", "=", "add_to_dict", "(", "path_dict", ",", "add_path", ",", "1", ")", "\n", "", "return", "path_dict", ",", "all_paths", ",", "new_spl", ",", "add_path", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.print_coref_stats": [[216, 235], ["print", "print", "print", "len", "len", "len", "key.split", "key.split"], "function", ["None"], ["", "def", "print_coref_stats", "(", "coref_amrs", ",", "path_dict", ")", ":", "\n", "    ", "'''Print interesting statistics about coref parsing'''", "\n", "print", "(", "'Length of AMRs with coref: {0}'", ".", "format", "(", "len", "(", "coref_amrs", ")", ")", ")", "\n", "total", ",", "once", ",", "max_len", "=", "0", ",", "0", ",", "0", "\n", "\n", "# Check in the path dictionary", "\n", "for", "key", "in", "path_dict", ":", "\n", "        ", "total", "+=", "1", "\n", "if", "path_dict", "[", "key", "]", "==", "1", ":", "\n", "            ", "once", "+=", "1", "\n", "\n", "", "if", "len", "(", "key", ".", "split", "(", ")", ")", ">", "max_len", ":", "\n", "            ", "max_len", "=", "len", "(", "key", ".", "split", "(", ")", ")", "\n", "long_path", "=", "key", "\n", "\n", "# Print results for longest path only if we have it", "\n", "", "", "if", "max_len", ">", "0", ":", "\n", "        ", "print", "(", "'Longest path: {0}\\nOf length: {1}\\n'", ".", "format", "(", "long_path", ",", "max_len", ")", ")", "\n", "", "print", "(", "'{0} out of {1} are unique'", ".", "format", "(", "once", ",", "total", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.create_coref_paths": [[237, 248], ["var_free_amrs.single_line_convert", "create_coref_paths.replace_coreference", "create_coref_paths.remove_variables", "amr_utils.write_to_file", "var_free_amrs.delete_wiki", "x.rstrip", "open"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.replace_coreference", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_paths.remove_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki"], ["", "def", "create_coref_paths", "(", "input_file", ",", "output_ext", ",", "keep_wiki", ",", "print_stats", ")", ":", "\n", "    ", "'''Main function to create the coreference paths'''", "\n", "# Delete wiki links only if we want to", "\n", "amr_file_no_wiki", "=", "delete_wiki", "(", "input_file", ")", "if", "not", "keep_wiki", "else", "[", "x", ".", "rstrip", "(", ")", "for", "x", "in", "open", "(", "input_file", ",", "'r'", ")", "]", "\n", "# Put the AMRs on a single line", "\n", "single_amrs", ",", "_", "=", "single_line_convert", "(", "amr_file_no_wiki", ",", "''", ")", "\n", "# Replace coreference with paths of our choice", "\n", "repl_amrs", "=", "replace_coreference", "(", "single_amrs", ",", "print_stats", ")", "\n", "final_amrs", "=", "remove_variables", "(", "repl_amrs", ")", "\n", "# Write final AMRs to a file", "\n", "write_to_file", "(", "final_amrs", ",", "input_file", "+", "output_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.create_arg_parser": [[33, 39], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "'--input_file'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "'Path to a single file for Wikification - AMRs should be in one line format'", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--sentence_file'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "'Sentence file for Wikification'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.get_wiki_from_spotlight_by_name": [[41, 57], ["bs4.BeautifulSoup", "bs4.BeautifulSoup.find_all", "bs4.BeautifulSoup.find_all", "wiki_tag.string.lower", "name.lower", "name.lower", "wiki_tag.string.lower", "wiki_tag.get().split", "len", "wiki_tag.get().split", "wiki_tag.get", "wiki_tag.get"], "function", ["None"], ["", "def", "get_wiki_from_spotlight_by_name", "(", "spotlight", ",", "name", ")", ":", "\n", "    ", "'''Given the spotlight output, and a name string, e.g. 'hong kong'\n    returns the wikipedia tag assigned by spotlight, if it exists, else '-'.'''", "\n", "actual_found", "=", "0", "\n", "parsed_spotlight", "=", "BeautifulSoup", "(", "spotlight", ".", "text", ",", "'lxml'", ")", "\n", "for", "wiki_tag", "in", "parsed_spotlight", ".", "find_all", "(", "'a'", ")", ":", "\n", "        ", "if", "wiki_tag", ".", "string", ".", "lower", "(", ")", "==", "name", ".", "lower", "(", ")", ":", "\n", "            ", "actual_found", "+=", "1", "\n", "return", "wiki_tag", ".", "get", "(", "'href'", ")", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ",", "actual_found", "\n", "\n", "# If nothing found, try to match based on prefixes, e.g. match the name Estonia to the tag for 'Estonian'", "\n", "", "", "for", "wiki_tag", "in", "parsed_spotlight", ".", "find_all", "(", "'a'", ")", ":", "\n", "        ", "if", "wiki_tag", ".", "string", ".", "lower", "(", ")", "[", ":", "len", "(", "name", ")", "]", "==", "name", ".", "lower", "(", ")", ":", "\n", "            ", "actual_found", "+=", "1", "\n", "return", "wiki_tag", ".", "get", "(", "'href'", ")", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ",", "actual_found", "\n", "", "", "return", "'-'", ",", "actual_found", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.get_wiki_from_dict": [[58, 65], ["name.lower", "name.lower"], "function", ["None"], ["", "def", "get_wiki_from_dict", "(", "name", ")", ":", "\n", "    ", "global", "save_dict", "\n", "actual_found", "=", "0", "\n", "if", "name", ".", "lower", "(", ")", "in", "save_dict", ":", "\n", "        ", "actual_found", "+=", "1", "\n", "return", "save_dict", "[", "name", ".", "lower", "(", ")", "]", ",", "actual_found", "\n", "", "return", "'-'", ",", "actual_found", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.get_name_from_amr_line": [[67, 73], ["re.findall"], "function", ["None"], ["", "def", "get_name_from_amr_line", "(", "line", ")", ":", "\n", "    ", "'''Takes an AMR-line with a :name, returns the full name as a string'''", "\n", "name_parts", "=", "re", ".", "findall", "(", "':op[0-9]+ \".*?\"'", ",", "line", ")", "\n", "# Remove garbage around name parts", "\n", "name_parts", "=", "[", "x", "[", "6", ":", "-", "1", "]", "for", "x", "in", "name_parts", "]", "\n", "return", "' '", ".", "join", "(", "name_parts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.wikify_file": [[75, 128], ["open", "open", "enumerate", "line.strip", "line.split", "range", "outfile.write", "len", "wikify_file.get_name_from_amr_line", "wikify_file.get_wiki_from_dict"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.get_name_from_amr_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.get_wiki_from_dict"], ["", "def", "wikify_file", "(", "in_file", ",", "in_sents", ")", ":", "\n", "    ", "'''Takes .amr-files as input, outputs .amr.wiki-files\n    with wikification using DBPedia Spotlight.'''", "\n", "#sentences = [x.strip() for x in open(in_sents, 'r')]", "\n", "all_found", "=", "0", "\n", "unicode_errors", "=", "0", "\n", "\n", "with", "open", "(", "in_file", ",", "'r'", ")", "as", "infile", ":", "\n", "        ", "with", "open", "(", "in_file", "+", "'.wiki'", ",", "'w'", ")", "as", "outfile", ":", "\n", "            ", "spotlight", "=", "''", "# Spotlight results", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "infile", ")", ":", "\n", "                ", "if", "line", ".", "strip", "(", ")", ":", "\n", "                    ", "'''\n                    if idx % 20 == 0:\n                        print (idx)\n                        '''", "\n", "#sentence = sentences[idx]", "\n", "\n", "# Spotlight raises an error if too many requests are posted at once", "\n", "'''\n                    success = False\n                    while not success:\n                        try:\n                            #Old servers here\n                            #spotlight = requests.post(\"http://spotlight.sztaki.hu:2222/rest/annotate\", data = {'text':sentence, 'confidence':0.3})\n                            #spotlight = requests.post(\"http://model.dbpedia-spotlight.org:2222/rest/annotate\", data = {'text':sentence, 'confidence':0.3})\n\n                            #spotlight = requests.post(\"http://model.dbpedia-spotlight.org/en/annotate\", data={'text':sentence, 'confidence':0.3})\n                            print(\"sending...\")\n                            spotlight = requests.post(\"https://api.dbpedia-spotlight.org/de/annotate\", data={'text':sentence, 'confidence':0.3})\n                            print(\"finished!\")\n                            spotlight.encoding = 'utf-8'\n                        except requests.exceptions.ConnectionError:\n                            print ('sleeping a bit (spotlight overload) - if this keeps happening server is down or changed')\n                            sleep(0.1)\n                            continue\n                        success = True\n                        '''", "\n", "\n", "#if sentence:", "\n", "name_split", "=", "line", ".", "split", "(", "':name'", ")", "\n", "# Skip first in split because name did not occur there yet", "\n", "for", "name_idx", "in", "range", "(", "1", ",", "len", "(", "name_split", ")", ")", ":", "\n", "                        ", "name", "=", "get_name_from_amr_line", "(", "name_split", "[", "name_idx", "]", ")", "\n", "if", "name", "!=", "''", ":", "\n", "#wiki_tag, actual_found = get_wiki_from_spotlight_by_name(spotlight, name)", "\n", "                            ", "wiki_tag", ",", "actual_found", "=", "get_wiki_from_dict", "(", "name", ")", "\n", "all_found", "+=", "actual_found", "\n", "if", "wiki_tag", "!=", "'-'", ":", "# Only add when we found an actual result", "\n", "                                ", "name_split", "[", "name_idx", "-", "1", "]", "+=", "':wiki \"'", "+", "wiki_tag", "+", "'\" '", "\n", "\n", "", "", "", "wikified_line", "=", "\":name\"", ".", "join", "(", "name_split", ")", ".", "strip", "(", ")", "\n", "outfile", ".", "write", "(", "wikified_line", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.create_arg_parser": [[18, 33], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "''' If using -fol, -f and -s are directories. In that case the filenames of the sentence file and output file should match (except extension)\n        If not using -fol, -f and -s are directories'''", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "'--input_file'", ",", "required", "=", "True", ",", "help", "=", "\"File or folder to be post-processed\"", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--sentence_file'", ",", "default", "=", "''", ",", "help", "=", "\"Sentence file or folder, only necessary for Wikification\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "'--folder'", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Whether -f is a folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-se'", ",", "'--sent_ext'", ",", "default", "=", "'.sent'", ",", "help", "=", "\"Sentence extension - only necessary when doing folder (default .sent)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out_ext'", ",", "default", "=", "'.seq.amr'", ",", "help", "=", "\"Output extension - only necessary when doing folder (default .seq.amr)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-t'", ",", "'--threads'", ",", "default", "=", "16", ",", "type", "=", "int", ",", "help", "=", "\"Maximum number of parallel threads\"", ")", "\n", "parser", ".", "add_argument", "(", "'-c'", ",", "'--coreference'", ",", "default", "=", "'dupl'", ",", "choices", "=", "[", "'dupl'", ",", "'index'", ",", "'abs'", "]", ",", "help", "=", "'How to handle coreference - input was either duplicated/indexed/absolute path (default dupl)'", ")", "\n", "parser", ".", "add_argument", "(", "'-n'", ",", "'--no_wiki'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Not doing Wikification, since it takes a long time sometimes we want to skip it'", ")", "\n", "parser", ".", "add_argument", "(", "'-fo'", ",", "'--force'", ",", "action", "=", "'store_true'", ",", "help", "=", "'For reprocessing of file even if file already exists'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.check_valid": [[35, 59], ["open", "print", "out_f.close", "amr_utils.valid_amr", "print", "amr_utils.get_default_amr", "all_amrs.append", "all_amrs.append", "open", "out_f.write", "line.strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.valid_amr", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.get_default_amr"], ["", "def", "check_valid", "(", "restore_file", ",", "rewrite", ")", ":", "\n", "    ", "'''Checks whether the AMRS in a file are valid, possibly rewrites to default AMR'''", "\n", "idx", "=", "0", "\n", "warnings", "=", "0", "\n", "all_amrs", "=", "[", "]", "\n", "\n", "# For each AMR, check if it is valid, and write default when invalid", "\n", "for", "line", "in", "open", "(", "restore_file", ",", "'r'", ")", ":", "\n", "        ", "idx", "+=", "1", "\n", "if", "not", "valid_amr", "(", "line", ")", ":", "\n", "            ", "print", "(", "(", "'Error or warning in line {0}, write default\\n'", ".", "format", "(", "idx", ")", ")", ")", "\n", "warnings", "+=", "1", "\n", "default_amr", "=", "get_default_amr", "(", ")", "\n", "all_amrs", ".", "append", "(", "default_amr", ")", "## add default when error", "\n", "", "else", ":", "\n", "            ", "all_amrs", ".", "append", "(", "line", ")", "\n", "\n", "# Write new AMRs to file if there are warnings", "\n", "", "", "print", "(", "(", "'There are {0} AMRs with error'", ".", "format", "(", "warnings", ")", ")", ")", "\n", "if", "rewrite", "and", "warnings", ">", "0", ":", "\n", "        ", "with", "open", "(", "restore_file", ",", "'w'", ")", "as", "out_f", ":", "\n", "            ", "for", "line", "in", "all_amrs", ":", "\n", "                ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_wikification": [[61, 81], ["wikify_file.wikify_file", "postprocess_AMRs.check_valid", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.wikify_file.wikify_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.check_valid"], ["", "", "def", "add_wikification", "(", "in_file", ",", "sent_file", ",", "force", ")", ":", "\n", "    ", "'''Function that adds wiki-links to produced AMRs'''", "\n", "wiki_file", "=", "in_file", "+", "'.wiki'", "\n", "\n", "# Check if wiki file doesn't exist already, if exists, skip", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "wiki_file", ")", "or", "force", ":", "\n", "# Do wikification here", "\n", "        ", "wikify_file", ".", "wikify_file", "(", "in_file", ",", "sent_file", ")", "\n", "# Sanity check", "\n", "'''\n        if len([x for x in open(sent_file, 'r')]) != len([x for x in open(wiki_file, 'r')]):\n            print('Wikification failed for some reason (different lengths)\\n\\tSave file as backup with failed_wiki extension, no validating\\n')\n            os.system('mv {0} {1}'.format(wiki_file, wiki_file.replace('.wiki', '.failed_wiki')))\n            return wiki_file, False\n        else:\n        '''", "\n", "check_valid", "(", "wiki_file", ",", "True", ")", "\n", "return", "wiki_file", ",", "True", "\n", "", "else", ":", "\n", "        ", "return", "wiki_file", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_coreference": [[83, 92], ["os.system", "os.path.isfile"], "function", ["None"], ["", "", "def", "add_coreference", "(", "in_file", ",", "ext", ",", "force", ")", ":", "\n", "    ", "'''Function that adds coreference back for each concept that occurs more than once\n       Only works for -c dupl'''", "\n", "coref_file", "=", "in_file", "+", "ext", "\n", "\n", "# Only do if file doesn't exist yet", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "coref_file", ")", "or", "force", ":", "\n", "        ", "os", ".", "system", "(", "'python3 restore_duplicate_coref.py -f {0} --output_ext {1}'", ".", "format", "(", "in_file", ",", "ext", ")", ")", "\n", "", "return", "coref_file", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.do_pruning": [[94, 105], ["os.system", "postprocess_AMRs.check_valid", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.check_valid"], ["", "def", "do_pruning", "(", "in_file", ",", "force", ")", ":", "\n", "    ", "'''Function that prunes duplicate output'''", "\n", "prune_file", "=", "in_file", "+", "'.pruned'", "\n", "\n", "# Only prune if output file doesn't already exist", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "prune_file", ")", "or", "force", ":", "\n", "# Do pruning here", "\n", "        ", "os", ".", "system", "(", "'python3 prune_amrs.py -f {0}'", ".", "format", "(", "in_file", ")", ")", "\n", "# Check if they're still all valid", "\n", "check_valid", "(", "prune_file", ",", "True", ")", "\n", "", "return", "prune_file", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.restore_amr": [[107, 115], ["os.system", "postprocess_AMRs.check_valid", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.check_valid"], ["", "def", "restore_amr", "(", "in_file", ",", "out_file", ",", "coref_type", ",", "force", ")", ":", "\n", "    ", "'''Function that restores variables in output AMR\n       Also restores coreference for index/absolute paths methods'''", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "out_file", ")", "or", "force", ":", "\n", "        ", "restore_call", "=", "'python3 restoreAMR/restore_amr.py -f {0} -o {1} -c {2}'", ".", "format", "(", "in_file", ",", "out_file", ",", "coref_type", ")", "\n", "os", ".", "system", "(", "restore_call", ")", "\n", "check_valid", "(", "out_file", ",", "True", ")", "\n", "", "return", "out_file", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.process_file": [[117, 163], ["postprocess_AMRs.restore_amr", "postprocess_AMRs.do_pruning", "postprocess_AMRs.add_coreference", "postprocess_AMRs.add_wikification", "postprocess_AMRs.add_wikification", "os.system", "ValueError", "postprocess_AMRs.add_coreference"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.restore_amr", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.do_pruning", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_coreference", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_wikification", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_wikification", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.add_coreference"], ["", "def", "process_file", "(", "input_list", ")", ":", "\n", "    ", "'''Postproces AMR file'''", "\n", "# Unpack arguments", "\n", "input_file", ",", "sent_file", ",", "no_wiki", ",", "coreference", ",", "force", "=", "input_list", "\n", "\n", "# Sanity check first", "\n", "#if (not os.path.isfile(sent_file) and not no_wiki) or not os.path.isfile(input_file) or not os.path.getsize(input_file):", "\n", "#    raise ValueError('Something is wrong, sent-file or amr-file does not exist or has no content')", "\n", "\n", "# Restore AMR first (variables)", "\n", "restore_file", "=", "input_file", "+", "'.restore'", "\n", "restore_file", "=", "restore_amr", "(", "input_file", ",", "restore_file", ",", "coreference", ",", "force", ")", "\n", "\n", "# Then do all postprocessing steps separately so we can see the individual impact of them", "\n", "# We always do pruning", "\n", "prune_file", "=", "do_pruning", "(", "restore_file", ",", "force", ")", "\n", "\n", "# Coreference restoring we only do for duplicating", "\n", "if", "coreference", "==", "'dupl'", ":", "\n", "        ", "_", "=", "add_coreference", "(", "restore_file", ",", "'.coref'", ",", "force", ")", "\n", "\n", "# We don't always want to do Wikification because it takes time", "\n", "", "if", "not", "no_wiki", ":", "\n", "        ", "_", ",", "success", "=", "add_wikification", "(", "restore_file", ",", "sent_file", ",", "force", ")", "\n", "\n", "# To get the final output file, we add all postprocessing steps together as well", "\n", "# We can already start from the prune file", "\n", "# Start with Wikification (if we want)", "\n", "", "if", "not", "no_wiki", ":", "\n", "        ", "next_file", ",", "success", "=", "add_wikification", "(", "prune_file", ",", "sent_file", ",", "force", ")", "\n", "", "else", ":", "\n", "        ", "next_file", "=", "prune_file", "\n", "success", "=", "True", "\n", "\n", "# Only continue if Wikification worked (or we skipped it)", "\n", "", "if", "success", ":", "\n", "# Then only do coreference for the duplicated coreference", "\n", "        ", "if", "coreference", "==", "'dupl'", ":", "\n", "            ", "final_file", "=", "add_coreference", "(", "next_file", ",", "'.coref.all'", ",", "force", ")", "\n", "", "else", ":", "\n", "            ", "final_file", "=", "next_file", "\n", "\n", "# Write the final file to file that's always called the same", "\n", "", "os", ".", "system", "(", "\"cp {0} {1}.final\"", ".", "format", "(", "final_file", ",", "restore_file", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wikification failed, consider using --no_wiki'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.match_files_by_name": [[165, 178], ["[].split", "[].split", "matches.append", "amr.split", "sent.split"], "function", ["None"], ["", "", "def", "match_files_by_name", "(", "amr_files", ",", "sent_files", ",", "no_wiki", ",", "coreference", ",", "force", ")", ":", "\n", "    ", "'''Input is a list of both amr and sentence files, return matching pairs to test in parallel in the main function'''", "\n", "matches", "=", "[", "]", "\n", "for", "amr", "in", "amr_files", ":", "\n", "# Return filename when given file /home/user/folder/folder2/filename.txt", "\n", "        ", "match_amr", "=", "amr", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "for", "sent", "in", "sent_files", ":", "\n", "            ", "match_sent", "=", "sent", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "# Matching sentence and AMR file, we can process those, so save them", "\n", "if", "match_sent", "==", "match_amr", ":", "\n", "                ", "matches", ".", "append", "(", "[", "amr", ",", "sent", ",", "no_wiki", ",", "coreference", ",", "force", "]", ")", "\n", "break", "\n", "", "", "", "return", "matches", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.postprocess_AMRs.get_files": [[180, 187], ["os.walk", "sorted", "f.endswith", "keep_files.append", "os.path.join"], "function", ["None"], ["", "def", "get_files", "(", "folder", ",", "ext", ")", ":", "\n", "    ", "keep_files", "=", "[", "]", "\n", "for", "root", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "folder", ")", ":", "\n", "        ", "for", "f", "in", "files", ":", "\n", "            ", "if", "f", ".", "endswith", "(", "ext", ")", "and", "'.char'", "not", "in", "f", ":", "\n", "                ", "keep_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "root", ",", "f", ")", ")", "\n", "", "", "", "return", "sorted", "(", "keep_files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.create_arg_parser": [[26, 37], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "'--input_file'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"Input AMR file or folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "'--folder'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Add to do multiple files in a folder - if not, args.f is a file'", ")", "\n", "parser", ".", "add_argument", "(", "'-sen'", ",", "\"--sent_ext\"", ",", "default", "=", "'.sent'", ",", "type", "=", "str", ",", "help", "=", "\"Input extension of AMRs (default .sent)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-a'", ",", "'--amr_ext'", ",", "default", "=", "'.tf'", ",", "type", "=", "str", ",", "help", "=", "\"Output extension of AMRs (default .tf)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--super_chars'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Adding super characters for AMR files'", ")", "\n", "parser", ".", "add_argument", "(", "'-c'", ",", "'--coreference'", ",", "action", "=", "'store_true'", ",", "help", "=", "'If there is path-coreference or index-coreference in the input'", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "'--pos'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Whether input is POS-tagged'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.get_fixed_lines": [[39, 68], ["line.split", "enumerate", "fixed_lines.append", "re.sub", "re.sub", "re.sub", "new_lines.append", "any", "len", "new_str.strip"], "function", ["None"], ["", "def", "get_fixed_lines", "(", "file_lines", ",", "coreference", ")", ":", "\n", "    ", "'''Fix lines, filter out non-relation and put back coreference paths'''", "\n", "\n", "fixed_lines", "=", "[", "]", "\n", "\n", "for", "line", "in", "file_lines", ":", "\n", "        ", "spl", "=", "line", ".", "split", "(", ")", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "spl", ")", ":", "\n", "            ", "if", "len", "(", "item", ")", ">", "1", "and", "item", "[", "0", "]", "==", "':'", ":", "\n", "# Filter out non-structure words, due to links etc", "\n", "                ", "if", "any", "(", "x", "in", "item", "for", "x", "in", "[", "')'", ",", "'<'", ",", "')'", ",", "'>'", ",", "'/'", ",", "'jwf9X'", "]", ")", ":", "\n", "                    ", "new_str", "=", "''", "\n", "for", "ch", "in", "item", ":", "\n", "                        ", "new_str", "+=", "ch", "+", "' '", "\n", "", "spl", "[", "idx", "]", "=", "new_str", ".", "strip", "(", ")", "\n", "", "", "", "fixed_lines", ".", "append", "(", "\" \"", ".", "join", "(", "spl", ")", ")", "\n", "\n", "# Step that is coreference-specific: change | 1 | to |1|, as to not treat the indexes as normal numbers, but as separate super characters", "\n", "# Also change * 1 * to *1* and * 1 2 * to *12*", "\n", "", "if", "coreference", ":", "\n", "        ", "new_lines", "=", "[", "]", "\n", "for", "l", "in", "fixed_lines", ":", "\n", "            ", "new_l", "=", "re", ".", "sub", "(", "r'\\| (\\d) \\|'", ",", "r'|\\1|'", ",", "l", ")", "\n", "new_l", "=", "re", ".", "sub", "(", "r'\\* (\\d) \\*'", ",", "r'*\\1*'", ",", "new_l", ")", "\n", "new_l", "=", "re", ".", "sub", "(", "r'\\* (\\d) (\\d) \\*'", ",", "r'*\\1\\2*'", ",", "new_l", ")", "\n", "new_lines", ".", "append", "(", "new_l", ")", "\n", "", "return", "new_lines", "\n", "", "else", ":", "\n", "        ", "return", "fixed_lines", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.get_amr_lines": [[70, 94], ["open", "line.replace.replace", "enumerate", "file_lines.append", "line[].isalpha"], "function", ["None"], ["", "", "def", "get_amr_lines", "(", "f_path", ")", ":", "\n", "    ", "'''Put AMR lines in character-level format'''", "\n", "file_lines", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "f_path", ",", "'r'", ")", ":", "\n", "# Replace actual spaces with '+'", "\n", "        ", "line", "=", "line", ".", "replace", "(", "' '", ",", "'+'", ")", "\n", "new_l", "=", "''", "\n", "add_space", "=", "True", "\n", "for", "idx", ",", "ch", "in", "enumerate", "(", "line", ")", ":", "\n", "# After ':' there should always be a letter, otherwise it is some URL probably and we just continue", "\n", "            ", "if", "ch", "==", "':'", "and", "line", "[", "idx", "+", "1", "]", ".", "isalpha", "(", ")", ":", "\n", "                ", "add_space", "=", "False", "\n", "new_l", "+=", "' '", "+", "ch", "\n", "", "elif", "ch", "==", "'+'", ":", "\n", "                ", "add_space", "=", "True", "\n", "new_l", "+=", "' '", "+", "ch", "\n", "", "else", ":", "\n", "                ", "if", "add_space", ":", "\n", "                    ", "new_l", "+=", "' '", "+", "ch", "\n", "", "else", ":", "\n", "# We previously saw a ':', so we do not add a space", "\n", "                    ", "new_l", "+=", "ch", "\n", "", "", "", "file_lines", ".", "append", "(", "new_l", ")", "\n", "", "return", "file_lines", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.process_pos_tagged": [[96, 123], ["open", "line.replace.replace", "enumerate", "fixed_lines.append"], "function", ["None"], ["", "def", "process_pos_tagged", "(", "f_path", ")", ":", "\n", "    ", "'''Process a POS-tagged sentence file'''", "\n", "fixed_lines", "=", "[", "]", "\n", "\n", "for", "line", "in", "open", "(", "f_path", ",", "'r'", ")", ":", "\n", "        ", "new_l", "=", "''", "\n", "no_spaces", "=", "False", "\n", "# Replace actual spaces with '+'", "\n", "line", "=", "line", ".", "replace", "(", "' '", ",", "'+'", ")", "\n", "for", "idx", ",", "ch", "in", "enumerate", "(", "line", ")", ":", "\n", "            ", "if", "ch", "==", "'|'", ":", "\n", "# Skip identifier '|' in the data", "\n", "                ", "no_spaces", "=", "True", "\n", "new_l", "+=", "' '", "\n", "", "elif", "ch", "==", "':'", "and", "line", "[", "idx", "-", "1", "]", "==", "'|'", ":", "\n", "# Structure words are also chunks", "\n", "                ", "no_spaces", "=", "True", "\n", "", "elif", "ch", "==", "'+'", ":", "\n", "                ", "no_spaces", "=", "False", "\n", "new_l", "+=", "' '", "+", "ch", "\n", "", "elif", "no_spaces", ":", "\n", "# Only do no space when uppercase letters (VBZ, NNP, etc), special case PRP$    (not necessary)", "\n", "                ", "new_l", "+=", "ch", "\n", "", "else", ":", "\n", "                ", "new_l", "+=", "' '", "+", "ch", "\n", "", "", "fixed_lines", ".", "append", "(", "new_l", ")", "\n", "", "return", "fixed_lines", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.char_level_file": [[125, 156], ["input_file.endswith", "input_file.replace", "input_file.endswith", "print", "char_level_AMR.get_amr_lines", "char_level_AMR.get_fixed_lines", "amr_utils.write_to_file", "print", "os.system", "input_file.replace", "print", "char_level_AMR.process_pos_tagged", "amr_utils.write_to_file", "print", "os.system"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.get_amr_lines", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.get_fixed_lines", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.char_level_AMR.process_pos_tagged", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file"], ["", "def", "char_level_file", "(", "input_file", ",", "amr_ext", ",", "sent_ext", ",", "pos", ",", "super_chars", ",", "coreference", ")", ":", "\n", "    ", "'''Given an input file, put it in char-level format and write output'''", "\n", "if", "input_file", ".", "endswith", "(", "amr_ext", ")", ":", "\n", "# File ends with AMR extension, do AMR char-level processing", "\n", "        ", "out_f", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.char'", "+", "amr_ext", ")", "\n", "\n", "if", "super_chars", ":", "\n", "# Super characters get a different treatment", "\n", "            ", "print", "(", "'AMR file, super characters'", ")", "\n", "amr_lines", "=", "get_amr_lines", "(", "input_file", ")", "\n", "fixed_lines", "=", "get_fixed_lines", "(", "amr_lines", ",", "coreference", ")", "\n", "write_to_file", "(", "fixed_lines", ",", "out_f", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'AMR file, no super characters'", ")", "\n", "# If there are no super character we can just process with sed", "\n", "os_call", "=", "'sed -e \"s/\\ /+/g\"  -e \"s/./&\\ /g\" < {0} > {1}'", ".", "format", "(", "input_file", ",", "out_f", ")", "\n", "os", ".", "system", "(", "os_call", ")", "\n", "\n", "", "", "elif", "input_file", ".", "endswith", "(", "sent_ext", ")", ":", "\n", "# File ends with sent ext, do sentence processing", "\n", "        ", "out_f", "=", "input_file", ".", "replace", "(", "sent_ext", ",", "'.char'", "+", "sent_ext", ")", "\n", "if", "pos", ":", "\n", "# POS-tagged files get a different treatment", "\n", "            ", "print", "(", "'Sentence file, POS-tagged'", ")", "\n", "lines", "=", "process_pos_tagged", "(", "input_file", ")", "\n", "write_to_file", "(", "lines", ",", "out_f", ")", "\n", "", "else", ":", "\n", "# Not POS-tagged, so we can just use sed", "\n", "            ", "print", "(", "'Sentence file, not POS-tagged'", ")", "\n", "os_call", "=", "'sed -e \"s/\\ /+/g\"  -e \"s/./&\\ /g\" < {0} > {1}'", ".", "format", "(", "input_file", ",", "out_f", ")", "\n", "os", ".", "system", "(", "os_call", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.restore_duplicate_coref.create_arg_parser": [[22, 28], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"File that contains AMRs to be processed\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output_ext\"", ",", "default", "=", "'.coref'", ",", "type", "=", "str", ",", "help", "=", "\"Output extension of AMRs (default .coref)\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.restore_duplicate_coref.process_var_line": [[30, 80], ["var_list.append", "var_name.strip", "amr_utils.remove_char_outside_quotes", "var_value.strip", "print", "[].isdigit", "len", "amr_utils.remove_char_outside_quotes", "var_list.append", "item[].split", "item[].split", "var_value.strip", "var_name.strip", "item[].split"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes"], ["", "def", "process_var_line", "(", "line", ",", "f", ")", ":", "\n", "    ", "'''Function that processes line with a variable in it. Returns the string without\n       variables and the dictionary with var-name + var - value'''", "\n", "var_list", "=", "[", "]", "\n", "curr_var_name", ",", "curr_var_value", ",", "skip_first", ",", "current_quotes", "=", "False", ",", "False", ",", "False", ",", "False", "\n", "var_value", ",", "var_name", "=", "''", ",", "''", "\n", "\n", "# Loop over line character by character", "\n", "for", "ch", "in", "line", ":", "\n", "# We start adding the variable value (if not between quotes)", "\n", "        ", "if", "ch", "==", "'/'", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_value", "=", "True", "\n", "curr_var_name", "=", "False", "\n", "var_value", "=", "''", "\n", "continue", "\n", "# We start adding the variable value", "\n", "", "elif", "ch", "==", "'('", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_name", "=", "True", "\n", "curr_var_value", "=", "False", "\n", "# We found a name-value pair, add it now", "\n", "if", "var_value", "and", "var_name", ":", "\n", "# Skip first entry, but only do it once. We never want to refer to the full AMR.", "\n", "                ", "if", "not", "var_list", "and", "skip_first", ":", "\n", "                    ", "skip_first", "=", "False", "\n", "", "else", ":", "\n", "                    ", "add_var_value", "=", "remove_char_outside_quotes", "(", "var_value", ".", "strip", "(", ")", ",", "')'", ")", "\n", "var_list", ".", "append", "(", "[", "var_name", ".", "strip", "(", ")", ",", "add_var_value", "]", ")", "\n", "", "", "var_name", "=", "''", "\n", "continue", "\n", "# Keep track of quotes, for tricky instances like :wiki \"HIV/AIDS\" or :value \"2/3\"", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "\n", "# Check if we are adding the current characters to var value/name", "\n", "", "if", "curr_var_name", ":", "\n", "            ", "var_name", "+=", "ch", "\n", "", "elif", "curr_var_value", ":", "\n", "            ", "var_value", "+=", "ch", "\n", "# Add last one", "\n", "", "", "var_list", ".", "append", "(", "[", "var_name", ".", "strip", "(", ")", ",", "remove_char_outside_quotes", "(", "var_value", ".", "strip", "(", ")", ",", "')'", ")", "]", ")", "\n", "\n", "# Check if all output looks valid", "\n", "for", "item", "in", "var_list", ":", "\n", "        ", "try", ":", "\n", "# Keep in :quant 5 as last one, but not ARG1: or :mod", "\n", "            ", "if", "not", "item", "[", "1", "]", ".", "split", "(", ")", "[", "-", "1", "]", ".", "isdigit", "(", ")", "and", "len", "(", "item", "[", "1", "]", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "                ", "item", "[", "1", "]", "=", "\" \"", ".", "join", "(", "item", "[", "1", "]", ".", "split", "(", ")", "[", "0", ":", "-", "1", "]", ")", "\n", "", "", "except", ":", "\n", "            ", "print", "(", "'Small error, just ignore: {0}'", ".", "format", "(", "item", ")", ")", "#should not happen often, but strange, unexpected output is always possible", "\n", "", "", "return", "var_list", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.restore_duplicate_coref.process_file": [[82, 112], ["enumerate", "open", "restore_duplicate_coref.process_var_line", "range", "new_line.replace().replace.replace().replace", "coref_amrs.append", "len", "range", "new_line.replace().replace.strip", "len", "len", "new_line.replace().replace.replace", "re.sub", "amr_utils.valid_amr"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.valid_amr"], ["", "def", "process_file", "(", "f", ")", ":", "\n", "    ", "'''Restore duplicate coreference output for a file of AMRs'''", "\n", "coref_amrs", "=", "[", "]", "\n", "# Loop over AMRs (one per line in file)", "\n", "for", "indx", ",", "line", "in", "enumerate", "(", "open", "(", "f", ",", "'r'", ")", ")", ":", "\n", "# Get list of variables and concepts present in full AMR", "\n", "        ", "var_list", "=", "process_var_line", "(", "line", ",", "f", ")", "\n", "new_line", "=", "line", "\n", "\n", "# Loop over this var list to rewrite variable + value to a previous instantiation of this value", "\n", "# In other words, if we saw (b / boy) already, rewrite (b2 / boy) to b", "\n", "for", "idx", "in", "range", "(", "len", "(", "var_list", ")", "-", "1", ")", ":", "\n", "            ", "for", "y", "in", "range", "(", "idx", "+", "1", ",", "len", "(", "var_list", ")", ")", ":", "\n", "# Match - we see a concept (var-value) we already saw before", "\n", "                ", "if", "var_list", "[", "idx", "]", "[", "1", "]", "==", "var_list", "[", "y", "]", "[", "1", "]", ":", "\n", "                    ", "replace_item", "=", "var_list", "[", "y", "]", "[", "0", "]", "+", "' / '", "+", "var_list", "[", "y", "]", "[", "1", "]", "\n", "# The part that needs to be replaced should be present", "\n", "if", "replace_item", "in", "line", ":", "\n", "# Do the actual replacing here, e.g. replace :ARG1 (var / value) by :ARG refvar", "\n", "                        ", "new_line_replaced", "=", "re", ".", "sub", "(", "r'\\({0} / [^\\(]*?\\)'", ".", "format", "(", "var_list", "[", "y", "]", "[", "0", "]", ")", ",", "' '", "+", "var_list", "[", "idx", "]", "[", "0", "]", ",", "new_line", ")", "\n", "# Only do replacing if resulting AMR is valid", "\n", "if", "new_line_replaced", "!=", "new_line", "and", "valid_amr", "(", "new_line_replaced", ")", ":", "\n", "                            ", "new_line", "=", "new_line_replaced", "\n", "# Perhaps fix some weird tokenization issues", "\n", "", "", "", "", "", "new_line", "=", "new_line", ".", "replace", "(", "'_ ('", ",", "'_('", ")", ".", "replace", "(", "') \"'", ",", "')\"'", ")", "\n", "coref_amrs", ".", "append", "(", "new_line", ".", "strip", "(", ")", ")", "\n", "\n", "# Sanity check", "\n", "", "assert", "len", "(", "coref_amrs", ")", "==", "indx", "+", "1", "\n", "return", "coref_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.reformat_single_amrs.create_arg_parser": [[12, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"File with the to be formatted AMRs\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-e\"", ",", "\"--extension\"", ",", "default", "=", "'.txt'", ",", "type", "=", "str", ",", "help", "=", "\"New extension of formatted AMRs\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-v\"", ",", "\"--valid\"", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Error when encountering an invalid AMR\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.reformat_single_amrs.variable_match": [[21, 27], ["len", "any", "any", "token.isalpha", "token.startswith", "len", "len", "char.isalpha", "char.isdigit", "x.isalpha", "x.isdigit"], "function", ["None"], ["", "def", "variable_match", "(", "token", ")", ":", "\n", "    ", "'''Function that matches entities that are variables occurring for the second time'''", "\n", "if", "len", "(", "token", ")", "==", "1", ":", "\n", "        ", "if", "not", "token", ".", "isalpha", "(", ")", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "any", "(", "char", ".", "isalpha", "(", ")", "for", "char", "in", "token", ")", "and", "any", "(", "char", ".", "isdigit", "(", ")", "for", "char", "in", "token", ")", "and", "not", "token", ".", "startswith", "(", "':'", ")", "and", "len", "(", "[", "x", "for", "x", "in", "token", "if", "x", ".", "isalpha", "(", ")", "or", "x", ".", "isdigit", "(", ")", "or", "x", "==", "'-'", "]", ")", "==", "len", "(", "token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.reformat_single_amrs.reformat_amr": [[29, 65], ["open", "amr_utils.tokenize_line().split", "enumerate", "amr_utils.reverse_tokenize", "original_line.replace().replace.replace().replace", "fixed_amrs.append", "amr_utils.tokenize_line", "amr_string.append", "original_line.replace().replace.replace", "amr_string.append", "part.startswith", "amr_string.append", "amr_string.append", "reformat_single_amrs.variable_match", "amr_string.append", "amr_string.append", "amr_string.append"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.tokenize_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.variable_match"], ["", "def", "reformat_amr", "(", "input_file", ")", ":", "\n", "    ", "'''Reformat AMRs -- go from single line to indented AMR on multiple lines'''", "\n", "fixed_amrs", "=", "[", "]", "\n", "\n", "# Loop over input file with one AMR per line", "\n", "for", "line", "in", "open", "(", "input_file", ",", "'r'", ")", ":", "\n", "        ", "tokenized_line", "=", "tokenize_line", "(", "line", ")", ".", "split", "(", ")", "\n", "num_tabs", "=", "0", "\n", "amr_string", "=", "[", "]", "\n", "# Loop over parts of tokenized line", "\n", "for", "count", ",", "part", "in", "enumerate", "(", "tokenized_line", ")", ":", "\n", "            ", "if", "part", "==", "'('", ":", "\n", "                ", "num_tabs", "+=", "1", "\n", "amr_string", ".", "append", "(", "part", ")", "\n", "", "elif", "part", "==", "')'", ":", "\n", "                ", "num_tabs", "-=", "1", "\n", "amr_string", ".", "append", "(", "part", ")", "\n", "", "elif", "part", ".", "startswith", "(", "':'", ")", ":", "\n", "                ", "try", ":", "\n", "# Variable coming up", "\n", "                    ", "if", "tokenized_line", "[", "count", "+", "3", "]", "==", "'/'", ":", "\n", "                        ", "amr_string", ".", "append", "(", "'\\n'", "+", "num_tabs", "*", "'\\t'", "+", "part", ")", "\n", "# Variable coming, add newline here", "\n", "", "elif", "variable_match", "(", "tokenized_line", "[", "count", "+", "1", "]", ")", ":", "\n", "                        ", "amr_string", ".", "append", "(", "'\\n'", "+", "num_tabs", "*", "'\\t'", "+", "part", ")", "\n", "", "else", ":", "\n", "                        ", "amr_string", ".", "append", "(", "part", ")", "\n", "", "", "except", ":", "\n", "                    ", "amr_string", ".", "append", "(", "part", ")", "\n", "", "", "else", ":", "\n", "                ", "amr_string", ".", "append", "(", "part", ")", "\n", "\n", "", "", "original_line", "=", "reverse_tokenize", "(", "\" \"", ".", "join", "(", "amr_string", ")", ")", "\n", "original_line", "=", "original_line", ".", "replace", "(", "'_ ('", ",", "'_('", ")", ".", "replace", "(", "') \"'", ",", "')\"'", ")", "\n", "fixed_amrs", ".", "append", "(", "original_line", "+", "'\\n\\n'", ")", "\n", "", "return", "fixed_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.prune_amrs.create_arg_parser": [[27, 33], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"File with AMRs (one line)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--cut_off\"", ",", "default", "=", "15", ",", "type", "=", "int", ",", "help", "=", "\"When to cut-off number of permutations\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.prune_amrs.restore_variables": [[35, 43], ["amr_utils.write_to_file", "os.system", "os.system"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file"], ["", "def", "restore_variables", "(", "input_file", ",", "filtered_amrs", ")", ":", "\n", "    ", "'''Restore the removed variables for the pruned file'''", "\n", "# Write variable-less AMRs to file", "\n", "write_to_file", "(", "filtered_amrs", ",", "input_file", "+", "'.pruned_temp'", ")", "\n", "# Then restore the AMR", "\n", "os", ".", "system", "(", "'python3 restoreAMR/restore_amr.py -f {0} -o {1}'", ".", "format", "(", "input_file", "+", "'.pruned_temp'", ",", "input_file", "+", "'.pruned'", ")", ")", "\n", "# Remove temp file again", "\n", "os", ".", "system", "(", "\"rm {0}\"", ".", "format", "(", "input_file", "+", "'.pruned_temp'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.prune_amrs.prune_file": [[45, 77], ["open", "prune_amrs.restore_variables", "print", "re.sub().strip", "amr_utils.count_not_between_quotes", "best_amr_permutation.get_permutations", "best_amr_permutation.get_best_perm", "filtered_amrs.append", "filtered_amrs.append", "re.sub", "best_amr_permutation.create_final_line().split", "re.sub().strip.split", "re.sub().strip.strip", "best_amr_permutation.create_final_line"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.prune_amrs.restore_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.count_not_between_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_best_perm", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_final_line"], ["", "def", "prune_file", "(", "input_file", ",", "cut_off", ")", ":", "\n", "    ", "'''Prune input file for duplicate input'''", "\n", "filtered_amrs", "=", "[", "]", "\n", "changed", "=", "0", "\n", "\n", "for", "line", "in", "open", "(", "input_file", ",", "'r'", ")", ":", "\n", "# Delete variables from line", "\n", "#clean_line = re.sub(r'\\([A-Za-z0-9-_~]+ / ', r'(', line).strip()", "\n", "        ", "clean_line", "=", "re", ".", "sub", "(", "r'\\(\\S+ / '", ",", "r'('", ",", "line", ")", ".", "strip", "(", ")", "\n", "\n", "# Only try to do something if we can actually permute", "\n", "if", "count_not_between_quotes", "(", "':'", ",", "clean_line", ")", ">", "1", ":", "\n", "# Get initial permutations", "\n", "            ", "permutations", ",", "keep_string1", ",", "all_perms", "=", "get_permutations", "(", "clean_line", ",", "1", ",", "[", "]", ",", "'prune'", ",", "cut_off", ")", "\n", "keep_str", "=", "'('", "+", "keep_string1", "\n", "# Prune duplicate output here", "\n", "final_string", "=", "get_best_perm", "(", "permutations", ",", "keep_str", ",", "all_perms", ",", "'prune'", ",", "cut_off", ")", "\n", "\n", "# Create final AMR line", "\n", "add_to", "=", "\" \"", ".", "join", "(", "create_final_line", "(", "final_string", ")", ".", "split", "(", ")", ")", "\n", "clean_line", "=", "\" \"", ".", "join", "(", "clean_line", ".", "split", "(", ")", ")", "\n", "filtered_amrs", ".", "append", "(", "add_to", ")", "\n", "\n", "# Keep track of number of pruned AMRs", "\n", "if", "add_to", "!=", "clean_line", ":", "\n", "                ", "changed", "+=", "1", "\n", "", "", "else", ":", "\n", "            ", "filtered_amrs", ".", "append", "(", "clean_line", ".", "strip", "(", ")", ")", "\n", "\n", "# Restore variables and write to file", "\n", "", "", "restore_variables", "(", "input_file", ",", "filtered_amrs", ")", "\n", "print", "(", "'Changed {0} AMRs by pruning'", ".", "format", "(", "changed", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_indexing.create_arg_parser": [[28, 37], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "'--input_file'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"File with AMRs\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "'--folder'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Add to do multiple files in a folder - if not, args.f is a file'", ")", "\n", "parser", ".", "add_argument", "(", "'-a'", ",", "'--amr_ext'", ",", "default", "=", "'.txt'", ",", "help", "=", "\"Extension of AMR files (default .txt, only necessary when doing folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--output_ext'", ",", "default", "=", "'.tf'", ",", "help", "=", "\"Extension of output AMR files (default .tf)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-k'", ",", "'--keep_wiki'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Keep Wiki link when processing'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_indexing.coreference_index": [[39, 81], ["amr_utils.space_brackets_amr().split", "range", "range", "amr_utils.reverse_tokenize", "new_amrs.append", "len", "len", "len", "amr_utils.variable_match", "len", "amr_utils.variable_match", "amr_utils.space_brackets_amr", "all_vars.append", "all_vars.count", "new_spl.append", "new_spl.append", "new_spl.append", "vars_seen.append", "vars_seen.index", "len"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.variable_match", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.variable_match", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr"], ["", "def", "coreference_index", "(", "one_line_amrs", ")", ":", "\n", "    ", "'''Function that replaces coreference entities by its relative or absolute path'''", "\n", "new_amrs", "=", "[", "]", "\n", "# Tokenize AMRs", "\n", "amrs", "=", "[", "space_brackets_amr", "(", "x", ")", ".", "split", "(", ")", "for", "x", "in", "one_line_amrs", "]", "\n", "# We always skip stuff such as :mode interrogative as possible variables", "\n", "no_var_list", "=", "[", "'interrogative'", ",", "'expressive'", ",", "'imperative'", "]", "\n", "\n", "# Loop over AMRs", "\n", "for", "spl", "in", "amrs", ":", "\n", "        ", "all_vars", "=", "[", "]", "\n", "# Loop over all tokens in AMR and save variables", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "spl", ")", ")", ":", "\n", "# Check if entity looks like a coreference variable", "\n", "            ", "if", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ")", ":", "\n", "                ", "all_vars", ".", "append", "(", "spl", "[", "idx", "]", ")", "\n", "\n", "", "", "vars_seen", ",", "new_spl", "=", "[", "]", ",", "[", "]", "\n", "# Loop over tokens again and check if we want to rewrite variables", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "spl", ")", ")", ":", "\n", "            ", "if", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ")", ":", "\n", "# If entity occurs at least twice, make mention of it", "\n", "                ", "if", "all_vars", ".", "count", "(", "spl", "[", "idx", "]", ")", ">", "1", ":", "\n", "                    ", "if", "spl", "[", "idx", "]", "in", "vars_seen", ":", "\n", "# Already saw the variable, add index path", "\n", "                        ", "new_spl", ".", "append", "(", "'*{0}*'", ".", "format", "(", "vars_seen", ".", "index", "(", "spl", "[", "idx", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "# Did not see variable before, add new one", "\n", "                        ", "new_spl", ".", "append", "(", "'*{0}*'", ".", "format", "(", "len", "(", "vars_seen", ")", ")", ")", "\n", "vars_seen", ".", "append", "(", "spl", "[", "idx", "]", ")", "\n", "# Skip items that were part of a variable (not there anymore)", "\n", "", "", "", "elif", "spl", "[", "idx", "]", "!=", "'/'", ":", "\n", "                ", "new_spl", ".", "append", "(", "spl", "[", "idx", "]", ")", "\n", "\n", "# Reverse tokenize and save AMRs", "\n", "", "", "new_line", "=", "\" \"", ".", "join", "(", "new_spl", ")", "\n", "new_line", "=", "reverse_tokenize", "(", "new_line", ")", "\n", "new_amrs", ".", "append", "(", "new_line", ")", "\n", "\n", "# Sanity check", "\n", "", "assert", "len", "(", "amrs", ")", "==", "len", "(", "new_amrs", ")", "\n", "return", "new_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_indexing.create_coref_indexing": [[83, 93], ["var_free_amrs.single_line_convert", "create_coref_indexing.coreference_index", "amr_utils.write_to_file", "var_free_amrs.delete_wiki", "x.rstrip", "open"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.create_coref_indexing.coreference_index", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki"], ["", "def", "create_coref_indexing", "(", "input_file", ",", "output_ext", ",", "keep_wiki", ")", ":", "\n", "    ", "'''Go from full AMR to one-line AMR without wiki with coreference indexed'''", "\n", "# Remove all Wiki instances", "\n", "amr_file_no_wiki", "=", "delete_wiki", "(", "input_file", ")", "if", "not", "keep_wiki", "else", "[", "x", ".", "rstrip", "(", ")", "for", "x", "in", "open", "(", "input_file", ",", "'r'", ")", "]", "\n", "# Put everything on a single line, sent_file is empty", "\n", "single_amrs", ",", "_", "=", "single_line_convert", "(", "amr_file_no_wiki", ",", "''", ")", "\n", "# Add the coference index we want", "\n", "repl_amrs", "=", "coreference_index", "(", "single_amrs", ")", "\n", "# Write output to file", "\n", "write_to_file", "(", "repl_amrs", ",", "input_file", "+", "output_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.create_args_parser": [[26, 36], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_args_parser", "(", ")", ":", "\n", "    ", "'''Creating arg parser'''", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"AMR file or folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "\"--folder\"", ",", "action", "=", "'store_true'", ",", "help", "=", "'Add to do multiple files in a folder - if not, args.f is a file'", ")", "\n", "parser", ".", "add_argument", "(", "'-a'", ",", "\"--amr_ext\"", ",", "default", "=", "'.txt'", ",", "type", "=", "str", ",", "help", "=", "\"Input files must have this extension (default .txt, only necesary when using -fol)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--output_ext'", ",", "default", "=", "'.tf'", ",", "help", "=", "\"extension of output AMR files (default .tf)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-k'", ",", "'--keep_wiki'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Keep Wiki link when processing'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.single_line_convert": [[38, 64], ["all_amrs.append", "os.path.isfile", "all_amrs.append", "line.strip", "cur_amr_line.strip", "line.startswith", "line.startswith", "re.sub().strip", "sents.append", "x.strip", "len", "len", "len", "len", "line.startswith", "cur_amr.append", "open", "re.sub", "line.strip"], "function", ["None"], ["", "def", "single_line_convert", "(", "lines", ",", "sent_file", ")", ":", "\n", "    ", "'''Convert AMRs to a single line, ignoring lines that start with \"# ::\"\n      If a sentence file is specified we also try to get the sentences'''", "\n", "all_amrs", ",", "cur_amr", ",", "sents", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "line", "in", "lines", ":", "\n", "        ", "if", "not", "line", ".", "strip", "(", ")", "and", "cur_amr", ":", "\n", "            ", "cur_amr_line", "=", "\" \"", ".", "join", "(", "cur_amr", ")", "\n", "all_amrs", ".", "append", "(", "cur_amr_line", ".", "strip", "(", ")", ")", "\n", "cur_amr", "=", "[", "]", "\n", "", "elif", "line", ".", "startswith", "(", "'# ::snt'", ")", "or", "line", ".", "startswith", "(", "'# ::tok'", ")", ":", "\n", "# Save sentences as well (don't always need them)", "\n", "            ", "sent", "=", "re", ".", "sub", "(", "'(^# ::(tok|snt))'", ",", "''", ",", "line", ")", ".", "strip", "(", ")", "#remove # ::snt or # ::tok", "\n", "sents", ".", "append", "(", "sent", ")", "\n", "", "elif", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "            ", "cur_amr", ".", "append", "(", "line", ".", "strip", "(", ")", ")", "\n", "# File did not end with newline, so add AMR here", "\n", "", "", "if", "cur_amr", ":", "\n", "        ", "all_amrs", ".", "append", "(", "\" \"", ".", "join", "(", "cur_amr", ")", ".", "strip", "(", ")", ")", "\n", "\n", "# If we didn't find sentences, but we did have a sentence file, read the sentences from there (if possible)", "\n", "", "if", "not", "sents", "and", "sent_file", ":", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "sent_file", ")", ":", "\n", "            ", "sents", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "open", "(", "sent_file", ",", "'r'", ")", "]", "\n", "# Sanity check", "\n", "assert", "len", "(", "all_amrs", ")", "==", "len", "(", "sents", ")", ",", "\"{0} vs {1}\"", ".", "format", "(", "len", "(", "all_amrs", ")", ",", "len", "(", "sents", ")", ")", "\n", "", "", "return", "all_amrs", ",", "sents", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.delete_wiki": [[66, 75], ["open", "re.sub", "re.sub", "no_wiki.append", "re.sub.split", "len", "len", "re.sub.lstrip"], "function", ["None"], ["", "def", "delete_wiki", "(", "input_file", ")", ":", "\n", "    ", "'''Delete wiki links from AMRs'''", "\n", "no_wiki", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "input_file", ",", "'r'", ")", ":", "\n", "        ", "n_line", "=", "re", ".", "sub", "(", "r':wiki \"(.*?)\"'", ",", "''", ",", "line", ",", "1", ")", "\n", "n_line", "=", "re", ".", "sub", "(", "':wiki -'", ",", "''", ",", "n_line", ")", "\n", "# Merge double whitespace but keep leading whitespace", "\n", "no_wiki", ".", "append", "(", "(", "len", "(", "n_line", ")", "-", "len", "(", "n_line", ".", "lstrip", "(", ")", ")", ")", "*", "' '", "+", "' '", ".", "join", "(", "n_line", ".", "split", "(", ")", ")", ")", "\n", "", "return", "no_wiki", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.process_var_line": [[77, 125], ["amr_utils.remove_char_outside_quotes", "re.sub().replace", "var_name.strip", "re.sub", "amr_utils.remove_char_outside_quotes", "[].startswith", "var_value.strip", "var_name.strip", "amr_utils.remove_char_outside_quotes.split", "amr_utils.remove_char_outside_quotes.split"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes"], ["", "def", "process_var_line", "(", "line", ",", "var_dict", ")", ":", "\n", "    ", "'''Function that processes line with a variable in it. Returns the string without\n       variables and the dictionary with var-name + var - value\n       Only works if AMR is shown as multiple lines and input correctly!'''", "\n", "curr_var_name", "=", "False", "\n", "curr_var_value", "=", "False", "\n", "var_value", "=", "''", "\n", "var_name", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "# We start adding the variable value", "\n", "        ", "if", "ch", "==", "'/'", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_value", "=", "True", "\n", "curr_var_name", "=", "False", "\n", "var_value", "=", "''", "\n", "continue", "\n", "# We start adding the variable name", "\n", "", "elif", "ch", "==", "'('", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_name", "=", "True", "\n", "curr_var_value", "=", "False", "\n", "# We already found a name-value pair, add it now", "\n", "if", "var_value", "and", "var_name", ":", "\n", "# Remove closing brackets that were not in between quotes", "\n", "                ", "add_value", "=", "remove_char_outside_quotes", "(", "var_value", ".", "strip", "(", ")", ",", "')'", ")", "\n", "# Now we have to check: if this previous item starts with ':', we remove it,", "\n", "# because that means it started a new part ( :name (n / name ..)", "\n", "if", "add_value", ".", "split", "(", ")", "[", "-", "1", "]", ".", "startswith", "(", "':'", ")", ":", "\n", "                    ", "add_value", "=", "\" \"", ".", "join", "(", "add_value", ".", "split", "(", ")", "[", ":", "-", "1", "]", ")", "\n", "", "var_dict", "[", "var_name", ".", "strip", "(", ")", "]", "=", "add_value", "\n", "", "var_name", "=", "''", "\n", "continue", "\n", "# Check if we are currently within quotes", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "\n", "# Add to variable name/value", "\n", "", "if", "curr_var_name", ":", "\n", "            ", "var_name", "+=", "ch", "\n", "", "if", "curr_var_value", ":", "\n", "            ", "var_value", "+=", "ch", "\n", "\n", "# Remove brackets that were not within quotes for final var value", "\n", "", "", "final_var", "=", "remove_char_outside_quotes", "(", "var_value", ",", "')'", ")", "\n", "# Save information to dictionary", "\n", "var_dict", "[", "var_name", ".", "strip", "(", ")", "]", "=", "final_var", "\n", "# Remove variable information from the AMR line", "\n", "deleted_var_string", "=", "re", ".", "sub", "(", "r'\\([a-zA-Z-_0-9]+[\\d]? /'", ",", "'('", ",", "line", ")", ".", "replace", "(", "'( '", ",", "'('", ")", "\n", "return", "deleted_var_string", ",", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.delete_amr_variables": [[127, 164], ["var_free_amrs.process_var_line", "line.strip", "del_amr.append", "var_free_amrs.process_var_line", "del_amr.append", "line.split", "split_line[].replace", "split_line[].replace", "del_amr.append", "del_amr.append", "ref_value.strip", "len", "len", "line.lstrip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line"], ["", "def", "delete_amr_variables", "(", "amrs", ")", ":", "\n", "    ", "'''Function that deletes variables from AMRs'''", "\n", "full_var_dict", "=", "{", "}", "\n", "del_amr", "=", "[", "]", "\n", "\n", "# First get the var dict", "\n", "for", "line", "in", "amrs", ":", "\n", "        ", "_", ",", "full_var_dict", "=", "process_var_line", "(", "line", ",", "full_var_dict", ")", "\n", "\n", "# Loop over AMRs to rewrite", "\n", "", "for", "line", "in", "amrs", ":", "\n", "        ", "if", "line", ".", "strip", "(", ")", "and", "line", "[", "0", "]", "!=", "'#'", ":", "\n", "            ", "if", "'/'", "in", "line", ":", "\n", "# Found variable here", "\n", "# Get the deleted variable string and save", "\n", "                ", "deleted_var_string", ",", "_", "=", "process_var_line", "(", "line", ",", "full_var_dict", ")", "\n", "del_amr", ".", "append", "(", "deleted_var_string", ")", "\n", "", "else", ":", "\n", "# Probable reference to variable here!", "\n", "                ", "split_line", "=", "line", ".", "split", "(", ")", "\n", "ref_var", "=", "split_line", "[", "1", "]", ".", "replace", "(", "')'", ",", "''", ")", "\n", "\n", "# Check if the variable occurs in our dictionary", "\n", "if", "ref_var", "in", "full_var_dict", ":", "\n", "# Get value to replace the variable name with", "\n", "                    ", "ref_value", "=", "full_var_dict", "[", "ref_var", "]", "\n", "# Do the replacing and add brackets for alignment", "\n", "split_line", "[", "1", "]", "=", "split_line", "[", "1", "]", ".", "replace", "(", "ref_var", ",", "'('", "+", "ref_value", ".", "strip", "(", ")", "+", "')'", ")", "\n", "n_line", "=", "(", "len", "(", "line", ")", "-", "len", "(", "line", ".", "lstrip", "(", ")", ")", ")", "*", "' '", "+", "\" \"", ".", "join", "(", "split_line", ")", "\n", "del_amr", ".", "append", "(", "n_line", ")", "\n", "", "else", ":", "\n", "# No reference found, add line without editing (usually there are numbers in this line)", "\n", "                    ", "del_amr", ".", "append", "(", "line", ")", "\n", "", "", "", "else", ":", "\n", "# Line with other info, just add", "\n", "            ", "del_amr", ".", "append", "(", "line", ")", "\n", "", "", "return", "del_amr", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.var_free_amrs.var_free_amrs": [[166, 175], ["var_free_amrs.delete_amr_variables", "var_free_amrs.single_line_convert", "amr_utils.write_to_file", "var_free_amrs.delete_wiki", "x.rstrip", "open"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_amr_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki"], ["", "def", "var_free_amrs", "(", "input_file", ",", "out_ext", ",", "keep_wiki", ")", ":", "\n", "    ", "'''Create variable-free AMRs and sentence files'''", "\n", "# Delete wiki link if wanted", "\n", "amr_no_wiki", "=", "delete_wiki", "(", "input_file", ")", "if", "not", "keep_wiki", "else", "[", "x", ".", "rstrip", "(", ")", "for", "x", "in", "open", "(", "input_file", ",", "'r'", ")", "]", "\n", "# Remove all variables by duplicating coreference nodes", "\n", "del_amrs", "=", "delete_amr_variables", "(", "amr_no_wiki", ")", "\n", "# Put AMR on single line and write output", "\n", "single_amrs", ",", "_", "=", "single_line_convert", "(", "del_amrs", ",", "''", ")", "\n", "write_to_file", "(", "single_amrs", ",", "input_file", "+", "out_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.create_arg_parser": [[38, 46], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"folder that contains to be processed files\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-a\"", ",", "\"--amr_ext\"", ",", "default", "=", "'.txt'", ",", "type", "=", "str", ",", "help", "=", "\"AMR extension (default .txt) - should have alignments\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--cut_off\"", ",", "default", "=", "15", ",", "type", "=", "int", ",", "help", "=", "\"When to cut-off number of permutations\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "\"--double\"", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Add best permutation AMR AND normal AMR\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_tokenized_sentences": [[48, 52], ["l.replace().replace().strip", "open", "l.replace().replace", "l.startswith", "l.startswith", "l.replace"], "function", ["None"], ["", "def", "get_tokenized_sentences", "(", "f", ")", ":", "\n", "    ", "'''Get sentences from AMR file'''", "\n", "sents", "=", "[", "l", ".", "replace", "(", "'# ::snt'", ",", "''", ")", ".", "replace", "(", "'# ::tok'", ",", "''", ")", ".", "strip", "(", ")", "for", "l", "in", "open", "(", "f", ",", "'r'", ")", "if", "l", ".", "startswith", "(", "'# ::snt'", ")", "or", "l", ".", "startswith", "(", "'# ::tok'", ")", "]", "\n", "return", "sents", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.remove_alignment": [[54, 58], ["re.sub"], "function", ["None"], ["", "def", "remove_alignment", "(", "string", ")", ":", "\n", "    ", "'''Function that removes alignment information from AMR'''", "\n", "string", "=", "re", ".", "sub", "(", "r'~e\\.[\\d,]+'", ",", "''", ",", "string", ")", "\n", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_word_and_sense": [[60, 109], ["enumerate", "best_amr_permutation.get_sense", "comb.append", "line.split", "print", "int", "len", "comb[].append", "s.isdigit"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense"], ["", "def", "get_word_and_sense", "(", "line", ")", ":", "\n", "    ", "'''Character based extraction because I couldn't figure it out using regex'''", "\n", "quotes", "=", "0", "\n", "adding", "=", "False", "\n", "comb", "=", "[", "]", "\n", "word", "=", "''", "\n", "if", "'\"'", "in", "line", ":", "\n", "        ", "for", "idx", ",", "ch", "in", "enumerate", "(", "line", ")", ":", "\n", "            ", "if", "ch", "==", "'\"'", ":", "\n", "                ", "quotes", "+=", "1", "\n", "if", "quotes", "%", "2", "!=", "0", ":", "\n", "                    ", "adding", "=", "True", "\n", "", "else", ":", "\n", "# Finished quotations", "\n", "                    ", "comb", ".", "append", "(", "[", "word", "]", ")", "\n", "word", "=", "''", "\n", "adding", "=", "False", "\n", "", "", "elif", "ch", "==", "'~'", ":", "\n", "                ", "if", "adding", ":", "\n", "                    ", "word", "+=", "ch", "\n", "", "elif", "':op'", "in", "\"\"", ".", "join", "(", "line", "[", "idx", "-", "4", ":", "idx", "-", "1", "]", ")", ":", "\n", "# Bugfix for strange constructions, e.g. name :op1~e.4 \"Algeria\"~e.2", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "if", "idx", "+", "4", "<", "len", "(", "line", ")", ":", "\n", "                        ", "sense_line", "=", "line", "[", "idx", "+", "1", "]", "+", "line", "[", "idx", "+", "2", "]", "+", "line", "[", "idx", "+", "3", "]", "+", "line", "[", "idx", "+", "4", "]", "\n", "", "else", ":", "\n", "                        ", "sense_line", "=", "line", "[", "idx", "+", "1", "]", "+", "line", "[", "idx", "+", "2", "]", "+", "line", "[", "idx", "+", "3", "]", "\n", "", "sense", "=", "int", "(", "\"\"", ".", "join", "(", "[", "s", "for", "s", "in", "sense_line", "if", "s", ".", "isdigit", "(", ")", "]", ")", ")", "\n", "try", ":", "\n", "                        ", "comb", "[", "-", "1", "]", ".", "append", "(", "sense", ")", "\n", "", "except", ":", "\n", "                        ", "pass", "\n", "", "", "", "else", ":", "\n", "                ", "if", "adding", ":", "\n", "                    ", "word", "+=", "ch", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "", "", "", "", "elif", "':op'", "not", "in", "line", ":", "\n", "        ", "return", "[", "[", "''", ",", "''", "]", "]", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "tmp", "=", "line", ".", "split", "(", ")", "[", "2", "]", "\n", "sense", ",", "word", "=", "get_sense", "(", "tmp", ")", "\n", "comb", "=", "[", "[", "word", ",", "sense", "]", "]", "\n", "", "except", ":", "\n", "            ", "print", "(", "'Strange occurrence in AMR, ignore'", ")", "\n", "return", "[", "[", "''", ",", "''", "]", "]", "\n", "", "", "return", "comb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_sense": [[111, 128], ["[].split", "round", "int", "word.split", "float", "float", "word.split", "sum", "len", "int.split", "int", "int.split"], "function", ["None"], ["", "def", "get_sense", "(", "word", ")", ":", "\n", "    ", "'''Function that gets the sense of a certain word in aligned AMR'''", "\n", "if", "'~'", "in", "word", ":", "\n", "# Extract 16 in e.g. house~e.16", "\n", "        ", "sense", "=", "word", ".", "split", "(", "'~'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "if", "','", "in", "sense", ":", "\n", "# Some amr-words refer to multiple tokens. If that's the case, we take the average for calculating distance", "\n", "# Although this means that the actual sense does not refer to the tokens anymore", "\n", "# e.g. the sense of house~e.4,12 becomes 8", "\n", "            ", "sense", "=", "round", "(", "(", "float", "(", "sum", "(", "[", "int", "(", "i", ")", "for", "i", "in", "sense", ".", "split", "(", "','", ")", "]", ")", ")", ")", "/", "(", "float", "(", "len", "(", "sense", ".", "split", "(", "','", ")", ")", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "sense", "=", "int", "(", "sense", ")", "\n", "# Remove sense information to process rest of the word", "\n", "", "word", "=", "word", ".", "split", "(", "'~'", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "sense", "=", "''", "\n", "", "return", "sense", ",", "word", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.find_words": [[130, 161], ["line.split", "enumerate", "range", "best_amr_permutation.get_sense", "len", "len", "comb[].append", "line.count", "len", "[].replace", "line.split", "line.split", "best_amr_permutation.get_word_and_sense", "best_amr_permutation.get_sense", "sum", "comb.append", "spl_line[].split", "spl_line[].strip().split", "c.isdigit", "[].replace.count", "[].replace.split", "spl_line[].strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_word_and_sense", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense"], ["", "def", "find_words", "(", "line", ")", ":", "\n", "    ", "'''Finds all words in the AMR structure'''", "\n", "comb", "=", "[", "]", "\n", "spl_line", "=", "line", ".", "split", "(", "'('", ")", "\n", "if", "'('", "not", "in", "line", ":", "\n", "        ", "if", "line", ".", "count", "(", "'~'", ")", ">", "0", "and", "len", "(", "line", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "            ", "sense", ",", "word", "=", "get_sense", "(", "line", ".", "split", "(", ")", "[", "1", "]", ")", "\n", "return", "[", "[", "word", ",", "sense", "]", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "[", "'none-found'", ",", "0", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "spl_line", ")", ")", ":", "\n", "            ", "if", "spl_line", "[", "idx", "]", ":", "\n", "                ", "word", "=", "spl_line", "[", "idx", "]", ".", "strip", "(", ")", ".", "split", "(", ")", "[", "0", "]", ".", "replace", "(", "')'", ",", "''", ")", "\n", "# Name gets special treatment by AMRs", "\n", "if", "word", "==", "'name'", ":", "\n", "                    ", "cut_word", "=", "spl_line", "[", "idx", "]", ".", "split", "(", "')'", ")", "[", "0", "]", "\n", "comb", "+=", "get_word_and_sense", "(", "cut_word", ")", "\n", "", "else", ":", "\n", "                    ", "sense", ",", "word", "=", "get_sense", "(", "word", ")", "\n", "num_digits", "=", "sum", "(", "c", ".", "isdigit", "(", ")", "for", "c", "in", "word", ")", "\n", "# Tricky: we want to change break-01 to break, but do not want to screw up dates (08-09-2016 or 28-10)", "\n", "if", "word", ".", "count", "(", "'-'", ")", "==", "1", "and", "num_digits", "<", "3", "and", "num_digits", ">", "0", ":", "\n", "                        ", "word", "=", "word", ".", "split", "(", "'-'", ")", "[", "0", "]", "\n", "", "comb", ".", "append", "(", "[", "word", ",", "sense", "]", ")", "\n", "\n", "# Add empty sense if needed", "\n", "", "", "", "", "for", "idx", ",", "value", "in", "enumerate", "(", "comb", ")", ":", "\n", "        ", "if", "len", "(", "value", ")", "<", "2", ":", "\n", "            ", "comb", "[", "idx", "]", ".", "append", "(", "''", ")", "\n", "", "", "return", "comb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.matching_words": [[163, 171], ["best_amr_permutation.find_words", "all_found.append", "best_amr_permutation.find_words"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.find_words", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.find_words"], ["", "def", "matching_words", "(", "permutations", ")", ":", "\n", "    ", "'''Finds all words in different order for all the permutations'''", "\n", "all_found", "=", "[", "]", "\n", "for", "per", "in", "permutations", ":", "\n", "        ", "found_words", "=", "find_words", "(", "per", ")", "\n", "if", "found_words", ":", "\n", "            ", "all_found", ".", "append", "(", "find_words", "(", "per", ")", ")", "\n", "", "", "return", "all_found", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.calc_distance": [[173, 186], ["min", "enumerate", "int", "abs", "len"], "function", ["None"], ["", "def", "calc_distance", "(", "l", ")", ":", "\n", "    ", "'''Calculates distance between list items in two lists'''", "\n", "# l needs to start from zero, get lowest number and substract it from all numbers", "\n", "min_l", "=", "min", "(", "[", "int", "(", "x", "[", "1", "]", ")", "for", "x", "in", "l", "if", "x", "[", "1", "]", "!=", "''", "]", ")", "\n", "l", "=", "[", "[", "x", "[", "0", "]", ",", "(", "x", "[", "1", "]", "-", "min_l", ")", "]", "for", "x", "in", "l", "if", "x", "[", "1", "]", "!=", "''", "]", "\n", "distance", "=", "0", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "l", ")", ":", "\n", "# Check if we found a sense", "\n", "        ", "if", "len", "(", "item", ")", ">", "1", "and", "item", "[", "1", "]", "!=", "''", ":", "\n", "# Check how far away we are in our token list", "\n", "            ", "diff", "=", "abs", "(", "item", "[", "1", "]", "-", "idx", ")", "\n", "distance", "+=", "diff", "\n", "", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.do_swap": [[188, 193], ["best_amr_permutation.calc_distance", "best_amr_permutation.calc_distance"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.calc_distance", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.calc_distance"], ["", "def", "do_swap", "(", "w_list1", ",", "w_list2", ")", ":", "\n", "    ", "'''Checks if we should swap two list items'''", "\n", "distance_now", "=", "calc_distance", "(", "w_list1", "+", "w_list2", ")", "\n", "distance_swap", "=", "calc_distance", "(", "w_list2", "+", "w_list1", ")", "\n", "return", "distance_now", ">", "distance_swap", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.filter_colons": [[195, 208], ["part.split", "range", "len", "new_parts.append", "[].isalpha", "new_parts.append"], "function", ["None"], ["", "def", "filter_colons", "(", "part", ")", ":", "\n", "    ", "'''Funtion to filter out timestamps (e.g. 08:30) and websites (e.g. http://site.com)'''", "\n", "new_parts", "=", "[", "]", "\n", "split_part", "=", "part", ".", "split", "(", "':'", ")", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "split_part", ")", ")", ":", "\n", "        ", "if", "idx", "==", "0", ":", "\n", "            ", "new_parts", ".", "append", "(", "split_part", "[", "idx", "]", ")", "\n", "", "elif", "split_part", "[", "idx", "]", "[", "0", "]", ".", "isalpha", "(", ")", ":", "\n", "            ", "new_parts", ".", "append", "(", "split_part", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "# Not actually a new part, just add to last one", "\n", "            ", "new_parts", "[", "-", "1", "]", "+=", "':'", "+", "split_part", "[", "idx", "]", "\n", "", "", "return", "new_parts", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.bracket_in_string": [[210, 220], ["None"], "function", ["None"], ["", "def", "bracket_in_string", "(", "line", ")", ":", "\n", "    ", "'''Check if there are no brackets in a string\n       NOTE: between quotes does not count'''", "\n", "between_quotes", "=", "False", "\n", "for", "char", "in", "line", ":", "\n", "        ", "if", "char", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "", "elif", "char", "in", "[", "'('", ",", "')'", "]", "and", "not", "between_quotes", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_add_string": [[222, 266], ["enumerate", "permutations.append", "enumerate", "var_free_amrs.remove_char_outside_quotes().strip", "best_amr_permutation.bracket_in_string", "permutations[].count", "permutations[].count", "p.count", "var_free_amrs.remove_char_outside_quotes", "p.split", "permutations.append", "x.strip", "add_string.strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.bracket_in_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes"], ["", "def", "get_add_string", "(", "search_part", ")", ":", "\n", "    ", "'''Get the initial permutations and add_string'''", "\n", "paren_count", "=", "0", "\n", "start_adding", "=", "False", "\n", "permutations", "=", "[", "]", "\n", "add_string", "=", "''", "\n", "between_quotes", "=", "False", "\n", "\n", "for", "idx", ",", "ch", "in", "enumerate", "(", "search_part", ")", ":", "\n", "        ", "if", "ch", "==", "'('", "and", "not", "between_quotes", ":", "\n", "            ", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "paren_count", "+=", "1", "\n", "", "elif", "ch", "==", "':'", "and", "not", "between_quotes", ":", "\n", "            ", "start_adding", "=", "True", "\n", "add_string", "+=", "ch", "\n", "", "elif", "ch", "==", "')'", "and", "not", "between_quotes", ":", "\n", "            ", "paren_count", "-=", "1", "\n", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "if", "paren_count", "==", "0", ":", "\n", "                ", "permutations", ".", "append", "(", "add_string", ".", "strip", "(", ")", ")", "\n", "add_string", "=", "''", "\n", "", "", "elif", "start_adding", ":", "\n", "            ", "add_string", "+=", "ch", "\n", "# Keep track of quotes", "\n", "", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "\n", "# Fix parentheses", "\n", "", "", "if", "add_string", "and", "':'", "in", "add_string", ":", "\n", "        ", "permutations", ".", "append", "(", "remove_char_outside_quotes", "(", "add_string", ",", "')'", ")", ".", "strip", "(", ")", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "permutations", ")", ":", "\n", "            ", "while", "permutations", "[", "idx", "]", ".", "count", "(", "')'", ")", "<", "permutations", "[", "idx", "]", ".", "count", "(", "'('", ")", ":", "\n", "                ", "permutations", "[", "idx", "]", "+=", "')'", "\n", "\n", "# Permutate without brackets (e.g. :op1 \"name1\" :op2 \"name2\" :op3 \"name3\" etc", "\n", "", "", "", "for", "p", "in", "permutations", ":", "\n", "        ", "if", "not", "bracket_in_string", "(", "p", ")", ":", "\n", "            ", "if", "p", ".", "count", "(", "':'", ")", ">", "2", ":", "\n", "                ", "p_split", "=", "p", ".", "split", "(", "':'", ")", "[", "1", ":", "]", "\n", "new_perms", "=", "[", "':'", "+", "x", ".", "strip", "(", ")", "for", "x", "in", "p_split", "]", "\n", "return", "add_string", ",", "new_perms", "\n", "", "", "", "return", "add_string", ",", "permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_keep_string": [[268, 276], ["None"], "function", ["None"], ["", "def", "get_keep_string", "(", "new_parts", ",", "level", ")", ":", "\n", "    ", "'''Obtain string we keep, it differs for level 1'''", "\n", "if", "level", ">", "1", ":", "\n", "        ", "keep_string", "=", "':'", "+", "\":\"", ".", "join", "(", "new_parts", "[", ":", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "keep_string", "=", "\":\"", ".", "join", "(", "new_parts", "[", ":", "1", "]", ")", "\n", "", "search_part", "=", "':'", "+", "\":\"", ".", "join", "(", "new_parts", "[", "1", ":", "]", ")", "\n", "return", "keep_string", ",", "search_part", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.combine_permutations": [[278, 286], ["len", "random.shuffle"], "function", ["None"], ["", "def", "combine_permutations", "(", "permutations", ",", "cut_off", ")", ":", "\n", "    ", "'''Combine permutations if they exceed the cut-off specified'''", "\n", "if", "len", "(", "permutations", ")", ">", "cut_off", ":", "\n", "        ", "shuffle", "(", "permutations", ")", "\n", "# Add extra permutations to the last permutation", "\n", "# to avoid losing information", "\n", "permutations", "=", "permutations", "[", "0", ":", "cut_off", "-", "1", "]", "+", "[", "\" \"", ".", "join", "(", "permutations", "[", "cut_off", "-", "1", ":", "]", ")", "]", "\n", "", "return", "permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.change_possible": [[288, 294], ["part.count"], "function", ["None"], ["", "def", "change_possible", "(", "part", ")", ":", "\n", "    ", "'''Check if there is anything to permute'''", "\n", "if", "':'", "not", "in", "part", "or", "(", "part", ".", "count", "(", "':'", ")", "==", "1", "and", "(", "'http:'", "in", "part", "or", "'https:'", "in", "part", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_permutations": [[296, 350], ["best_amr_permutation.filter_colons", "best_amr_permutation.get_keep_string", "best_amr_permutation.get_add_string", "best_amr_permutation.combine_permutations", "best_amr_permutation.matching_words", "best_amr_permutation.change_possible", "all_perms.append", "len", "len", "print", "range", "len", "range", "permutations_set.append", "best_amr_permutation.do_swap", "all_perms.count", "permutations_set.append", "len"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.filter_colons", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_keep_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_add_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.combine_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.matching_words", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.change_possible", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_swap"], ["", "", "def", "get_permutations", "(", "part", ",", "level", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", ":", "\n", "    ", "'''Function that returns the permutations in the best order'''", "\n", "# Make life easier by skipping first '(' or ':'", "\n", "part", "=", "part", "[", "1", ":", "]", "\n", "\n", "# If there is nothing to change then we return", "\n", "if", "not", "change_possible", "(", "part", ")", ":", "\n", "        ", "if", "level", "==", "1", ":", "\n", "            ", "return", "[", "part", "]", ",", "''", ",", "all_perms", "\n", "", "else", ":", "\n", "            ", "return", "[", "':'", "+", "part", "]", ",", "''", ",", "all_perms", "\n", "\n", "# Remove non-arguments that have a colon such as timestamps and websites", "\n", "", "", "new_parts", "=", "filter_colons", "(", "part", ")", "\n", "# Find the part of the string we keep", "\n", "keep_string", ",", "search_part", "=", "get_keep_string", "(", "new_parts", ",", "level", ")", "\n", "# Get the initial permutations", "\n", "_", ",", "permutations", "=", "get_add_string", "(", "search_part", ")", "\n", "\n", "# Check the cut_off so that we don't do more permutations than we want", "\n", "permutations", "=", "combine_permutations", "(", "permutations", ",", "cut_off", ")", "\n", "# Find the list of lists that contain word-sense pairs", "\n", "word_list", "=", "matching_words", "(", "permutations", ")", "\n", "\n", "# Two possibilities here, ordering or pruning. This script only does ordering,", "\n", "# but prune_amrs.py does pruning and uses this function as well", "\n", "if", "type_script", "==", "'prune'", ":", "\n", "        ", "permutations_set", "=", "[", "]", "\n", "for", "p", "in", "permutations", ":", "\n", "# Remove all nodes with same parent", "\n", "            ", "if", "p", "in", "permutations_set", ":", "\n", "                ", "continue", "\n", "", "elif", "p", "not", "in", "all_perms", ":", "\n", "                ", "permutations_set", ".", "append", "(", "p", ")", "\n", "", "elif", "all_perms", ".", "count", "(", "p", ")", "<", "2", ":", "\n", "# If we saw the node twice, stop adding", "\n", "                ", "permutations_set", ".", "append", "(", "p", ")", "\n", "", "all_perms", ".", "append", "(", "p", ")", "\n", "", "return", "permutations_set", ",", "keep_string", ",", "all_perms", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "word_list", ")", "!=", "len", "(", "permutations", ")", ":", "\n", "# Something strange is going on here, just ignore it and do nothing to avoid errors", "\n", "            ", "print", "(", "'Strange AMR part'", ")", "\n", "all_perms", "+=", "permutations", "\n", "return", "permutations", ",", "keep_string", ",", "all_perms", "\n", "", "else", ":", "\n", "            ", "for", "p", "in", "range", "(", "len", "(", "permutations", ")", ")", ":", "\n", "                ", "for", "idx", "in", "range", "(", "len", "(", "permutations", ")", "-", "1", ")", ":", "\n", "# Permuting takes place here, check if swapping results in better order", "\n", "                    ", "if", "do_swap", "(", "word_list", "[", "idx", "]", ",", "word_list", "[", "idx", "+", "1", "]", ")", ":", "\n", "                        ", "permutations", "[", "idx", "]", ",", "permutations", "[", "idx", "+", "1", "]", "=", "permutations", "[", "idx", "+", "1", "]", ",", "permutations", "[", "idx", "]", "\n", "word_list", "[", "idx", "]", ",", "word_list", "[", "idx", "+", "1", "]", "=", "word_list", "[", "idx", "+", "1", "]", ",", "word_list", "[", "idx", "]", "\n", "", "", "", "all_perms", "+=", "permutations", "\n", "return", "permutations", ",", "keep_string", ",", "all_perms", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.do_string_adjustments": [[352, 361], ["add_string.count", "add_string.count"], "function", ["None"], ["", "", "", "def", "do_string_adjustments", "(", "permutations_new", ",", "keep_string2", ")", ":", "\n", "    ", "'''Make sure the string is correct'''", "\n", "add_string", "=", "keep_string2", "+", "' '", "+", "\" \"", ".", "join", "(", "permutations_new", ")", "+", "' '", "\n", "\n", "# Check if we need to add a parenthesis", "\n", "while", "add_string", ".", "count", "(", "')'", ")", "<", "add_string", ".", "count", "(", "'('", ")", ":", "\n", "# Avoid extra unnecessary space", "\n", "        ", "add_string", "+=", "')'", "\n", "", "return", "add_string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.create_final_line": [[363, 374], ["final_string.replace().strip", "best_amr_permutation.fix_paren", "best_amr_permutation.remove_alignment", "add_to.replace.replace().replace().replace", "add_to.replace.replace", "final_string.replace", "add_to.replace.replace().replace", "add_to.replace.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment"], ["", "def", "create_final_line", "(", "final_string", ")", ":", "\n", "    ", "'''Do final adjustments for line'''", "\n", "add_to", "=", "final_string", ".", "replace", "(", "'  '", ",", "' '", ")", ".", "strip", "(", ")", "\n", "while", "' )'", "in", "add_to", ":", "\n", "        ", "add_to", "=", "add_to", ".", "replace", "(", "' )'", ",", "')'", ")", "\n", "# Fix parentheses and remove alignment information", "\n", "", "add_to", "=", "fix_paren", "(", "add_to", ")", "\n", "add_to", "=", "remove_alignment", "(", "add_to", ")", "\n", "# Fix tokenization", "\n", "add_to", "=", "add_to", ".", "replace", "(", "'):'", ",", "') :'", ")", ".", "replace", "(", "' :)'", ",", "')'", ")", ".", "replace", "(", "': :'", ",", "':'", ")", "\n", "return", "add_to", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.fix_paren": [[376, 381], ["string.count", "string.count"], "function", ["None"], ["", "def", "fix_paren", "(", "string", ")", ":", "\n", "    ", "'''Add parentheses when necessary'''", "\n", "while", "string", ".", "count", "(", "'('", ")", ">", "string", ".", "count", "(", "')'", ")", ":", "\n", "        ", "string", "+=", "')'", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_best_perm": [[383, 421], ["best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.do_string_adjustments", "do_string_adjustments.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_string_adjustments"], ["", "def", "get_best_perm", "(", "permutations", ",", "final_string", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", ":", "\n", "    ", "'''This must also be possible recursive - I tried...\n       For each (sub)-AMR, get the best permutation based on input words'''", "\n", "for", "p2", "in", "permutations", ":", "\n", "        ", "permutations_2", ",", "keep_string2", ",", "all_perms", "=", "get_permutations", "(", "p2", ",", "2", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p3", "in", "permutations_2", ":", "\n", "            ", "permutations_3", ",", "keep_string3", ",", "all_perms", "=", "get_permutations", "(", "p3", ",", "3", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p4", "in", "permutations_3", ":", "\n", "                ", "permutations_4", ",", "keep_string4", ",", "all_perms", "=", "get_permutations", "(", "p4", ",", "4", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p5", "in", "permutations_4", ":", "\n", "                    ", "permutations_5", ",", "keep_string5", ",", "all_perms", "=", "get_permutations", "(", "p5", ",", "5", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p6", "in", "permutations_5", ":", "\n", "                        ", "permutations_6", ",", "keep_string6", ",", "all_perms", "=", "get_permutations", "(", "p6", ",", "6", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p7", "in", "permutations_6", ":", "\n", "                            ", "permutations_7", ",", "keep_string7", ",", "all_perms", "=", "get_permutations", "(", "p7", ",", "7", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p8", "in", "permutations_7", ":", "\n", "                                ", "permutations_8", ",", "keep_string8", ",", "all_perms", "=", "get_permutations", "(", "p8", ",", "8", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p9", "in", "permutations_8", ":", "\n", "                                    ", "permutations_9", ",", "keep_string9", ",", "all_perms", "=", "get_permutations", "(", "p9", ",", "9", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p10", "in", "permutations_9", ":", "\n", "                                        ", "permutations_10", ",", "keep_string10", ",", "all_perms", "=", "get_permutations", "(", "p10", ",", "10", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p11", "in", "permutations_10", ":", "\n", "                                            ", "permutations_11", ",", "keep_string11", ",", "all_perms", "=", "get_permutations", "(", "p11", ",", "11", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p12", "in", "permutations_11", ":", "\n", "                                                ", "permutations_12", ",", "keep_string12", ",", "all_perms", "=", "get_permutations", "(", "p12", ",", "12", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "add_string", "=", "do_string_adjustments", "(", "permutations_12", ",", "keep_string12", ")", "\n", "keep_string11", "+=", "add_string", ".", "replace", "(", "'  '", ",", "' '", ")", "\n", "", "keep_string10", "+=", "fix_paren", "(", "keep_string11", ")", "\n", "", "keep_string9", "+=", "fix_paren", "(", "keep_string10", ")", "\n", "", "keep_string8", "+=", "fix_paren", "(", "keep_string9", ")", "\n", "", "keep_string7", "+=", "fix_paren", "(", "keep_string8", ")", "\n", "", "keep_string6", "+=", "fix_paren", "(", "keep_string7", ")", "\n", "", "keep_string5", "+=", "fix_paren", "(", "keep_string6", ")", "\n", "", "keep_string4", "+=", "fix_paren", "(", "keep_string5", ")", "\n", "", "keep_string3", "+=", "fix_paren", "(", "keep_string4", ")", "\n", "", "keep_string2", "+=", "fix_paren", "(", "keep_string3", ")", "\n", "", "final_string", "+=", "fix_paren", "(", "keep_string2", ")", "\n", "", "return", "fix_paren", "(", "final_string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.process_file_best": [[423, 451], ["enumerate", "enumerate", "print", "len", "len", "amr.replace", "best_amr_permutation.remove_alignment", "len", "len", "amr.count", "best_amr_permutation.get_permutations", "best_amr_permutation.get_best_perm", "save_all_amrs.append", "save_all_amrs.append", "len", "best_amr_permutation.create_final_line", "best_amr_permutation.remove_alignment", "zip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_best_perm", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_final_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment"], ["", "def", "process_file_best", "(", "amrs", ",", "sent_amrs", ",", "cut_off", ")", ":", "\n", "    ", "'''Permute AMR so that it best matches the word order'''", "\n", "save_all_amrs", "=", "[", "]", "\n", "\n", "# Sanity check", "\n", "assert", "len", "(", "amrs", ")", "==", "len", "(", "sent_amrs", ")", "\n", "\n", "# Loop over all AMRs and return best matching permutation", "\n", "for", "idx", ",", "amr", "in", "enumerate", "(", "amrs", ")", ":", "\n", "# Only try to do something if we can actually permute", "\n", "        ", "if", "amr", ".", "count", "(", "':'", ")", ">", "1", ":", "\n", "            ", "permutations", ",", "keep_string1", ",", "_", "=", "get_permutations", "(", "amr", ",", "1", ",", "[", "]", ",", "'order'", ",", "cut_off", ")", "\n", "final_string", "=", "get_best_perm", "(", "permutations", ",", "'('", "+", "keep_string1", ",", "[", "]", ",", "'order'", ",", "cut_off", ")", "\n", "# Save final output string", "\n", "save_all_amrs", ".", "append", "(", "create_final_line", "(", "final_string", ")", ")", "\n", "", "else", ":", "\n", "# Just save AMR if there's nothing to do", "\n", "            ", "save_all_amrs", ".", "append", "(", "remove_alignment", "(", "amr", ")", ")", "\n", "\n", "# Fix tokenization and remove alignment", "\n", "", "", "for", "idx", ",", "amr", "in", "enumerate", "(", "amrs", ")", ":", "\n", "        ", "amrs", "[", "idx", "]", "=", "amr", ".", "replace", "(", "' )'", ",", "')'", ")", "\n", "amrs", "[", "idx", "]", "=", "remove_alignment", "(", "amr", ")", "\n", "\n", "# Print how many AMRs we actually changed by doing this", "\n", "", "changed_amrs", "=", "len", "(", "amrs", ")", "-", "len", "(", "[", "i", "for", "i", ",", "j", "in", "zip", "(", "amrs", ",", "save_all_amrs", ")", "if", "i", "==", "j", "]", ")", "\n", "print", "(", "'Changed {0} out of {1} amrs'", ".", "format", "(", "changed_amrs", ",", "len", "(", "amrs", ")", ")", ")", "\n", "return", "save_all_amrs", ",", "amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.preprocess": [[453, 462], ["var_free_amrs.delete_wiki", "var_free_amrs.delete_amr_variables", "var_free_amrs.single_line_convert"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_amr_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert"], ["", "def", "preprocess", "(", "f_path", ")", ":", "\n", "    ", "'''Preprocess the AMR file, deleting variables/wiki-links and tokenizing'''", "\n", "# Delete Wiki links from AMRs", "\n", "no_wiki_amrs", "=", "delete_wiki", "(", "f_path", ")", "\n", "# Remove variables from AMR", "\n", "del_amrs", "=", "delete_amr_variables", "(", "no_wiki_amrs", ")", "\n", "# Old amrs with deleted wiki and variables", "\n", "old_amrs", ",", "sent_amrs", "=", "single_line_convert", "(", "del_amrs", ",", "''", ")", "\n", "return", "sent_amrs", ",", "old_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.create_output": [[464, 474], ["best_amr_permutation.get_filenames", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_filenames", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file"], ["", "def", "create_output", "(", "input_file", ",", "old_amrs", ",", "new_amrs", ",", "sent_amrs", ",", "double", ",", "amr_ext", ")", ":", "\n", "    ", "'''Print output to the correct files - also keep no-var AMR'''", "\n", "permuted_amr", ",", "no_var_amr", ",", "sent_file", ",", "double_sent_file", ",", "double_amr_file", "=", "get_filenames", "(", "input_file", ",", "amr_ext", ")", "\n", "write_to_file", "(", "old_amrs", ",", "no_var_amr", ")", "\n", "write_to_file", "(", "new_amrs", ",", "permuted_amr", ")", "\n", "write_to_file", "(", "sent_amrs", ",", "sent_file", ")", "\n", "# Potentially we want to keep BOTH the original AMR and the best-permuted AMR", "\n", "if", "double", ":", "\n", "        ", "write_to_file", "(", "old_amrs", "+", "new_amrs", ",", "double_amr_file", ")", "\n", "write_to_file", "(", "sent_amrs", "+", "sent_amrs", ",", "double_sent_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.best_amr_permutation.get_filenames": [[476, 484], ["input_file.replace", "input_file.replace", "input_file.replace", "input_file.replace", "input_file.replace"], "function", ["None"], ["", "", "def", "get_filenames", "(", "input_file", ",", "amr_ext", ")", ":", "\n", "    ", "'''Return list of filenames for output of this script'''", "\n", "permuted_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf.best'", ")", "\n", "no_var_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf'", ")", "\n", "sent_file", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.sent'", ")", "\n", "double_sent", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.sent.double'", ")", "\n", "double_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf.double'", ")", "\n", "return", "permuted_amr", ",", "no_var_amr", ",", "sent_file", ",", "double_sent", ",", "double_amr", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.__init__": [[221, 253], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "node_list", "=", "None", ",", "node_value_list", "=", "None", ",", "relation_list", "=", "None", ",", "attribute_list", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        node_list: names of nodes in AMR graph, e.g. \"a11\", \"n\"\n        node_value_list: values of nodes in AMR graph, e.g. \"group\" for a node named \"g\"\n        relation_list: list of relations between two nodes\n        attribute_list: list of attributes (links between one node and one constant value)\n\n        \"\"\"", "\n", "# initialize AMR graph nodes using list of nodes name", "\n", "# root, by default, is the first in var_list", "\n", "\n", "if", "node_list", "is", "None", ":", "\n", "            ", "self", ".", "nodes", "=", "[", "]", "\n", "self", ".", "root", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "nodes", "=", "node_list", "[", ":", "]", "\n", "if", "len", "(", "node_list", ")", "!=", "0", ":", "\n", "                ", "self", ".", "root", "=", "node_list", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "root", "=", "None", "\n", "", "", "if", "node_value_list", "is", "None", ":", "\n", "            ", "self", ".", "node_values", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "node_values", "=", "node_value_list", "[", ":", "]", "\n", "", "if", "relation_list", "is", "None", ":", "\n", "            ", "self", ".", "relations", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "relations", "=", "relation_list", "[", ":", "]", "\n", "", "if", "attribute_list", "is", "None", ":", "\n", "            ", "self", ".", "attributes", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "attributes", "=", "attribute_list", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.rename_node": [[254, 272], ["range", "enumerate", "enumerate", "len", "list", "str", "d.items"], "methods", ["None"], ["", "", "def", "rename_node", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n        Rename AMR graph nodes to prefix + node_index to avoid nodes with the same name in two different AMRs.\n\n        \"\"\"", "\n", "node_map_dict", "=", "{", "}", "\n", "# map each node to its new name (e.g. \"a1\")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "node_map_dict", "[", "self", ".", "nodes", "[", "i", "]", "]", "=", "prefix", "+", "str", "(", "i", ")", "\n", "# update node name", "\n", "", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "nodes", ")", ":", "\n", "            ", "self", ".", "nodes", "[", "i", "]", "=", "node_map_dict", "[", "v", "]", "\n", "# update node name in relations", "\n", "", "for", "i", ",", "d", "in", "enumerate", "(", "self", ".", "relations", ")", ":", "\n", "            ", "new_dict", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "list", "(", "d", ".", "items", "(", ")", ")", ":", "\n", "                ", "new_dict", "[", "node_map_dict", "[", "k", "]", "]", "=", "v", "\n", "", "self", ".", "relations", "[", "i", "]", "=", "new_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.get_triples": [[273, 295], ["range", "len", "instance_triple.append", "list", "list", "amr_utils.AMR.relations[].items", "relation_triple.append", "amr_utils.AMR.attributes[].items", "attribute_triple.append"], "methods", ["None"], ["", "", "def", "get_triples", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in three lists.\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        attribute triple: relation of attributes, e.g. polarity(w, - )\n        and relation triple, e.g. arg0 (w, b)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n", "attribute_triple", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# k is the other node this node has relation with", "\n", "# v is relation name", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "v", ",", "self", ".", "nodes", "[", "i", "]", ",", "k", ")", ")", "\n", "# k2 is the attribute name", "\n", "# v2 is the attribute value", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "attribute_triple", ".", "append", "(", "(", "k2", ",", "self", ".", "nodes", "[", "i", "]", ",", "v2", ")", ")", "\n", "", "", "return", "instance_triple", ",", "attribute_triple", ",", "relation_triple", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.get_triples2": [[297, 322], ["range", "len", "instance_triple.append", "list", "list", "amr_utils.AMR.relations[].items", "relation_triple.append", "amr_utils.AMR.attributes[].items", "relation_triple.append"], "methods", ["None"], ["", "def", "get_triples2", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in two lists:\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        relation_triple: a triple representing all relations. E.g arg0 (w, b) or E.g. polarity(w, - )\n        Note that we do not differentiate between attribute triple and relation triple. Both are considered as relation\n        triples.\n        All triples are represented by (triple_type, argument 1 of the triple, argument 2 of the triple)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "# an instance triple is instance(node name, node value).", "\n", "# For example, instance(b, boy).", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# k is the other node this node has relation with", "\n", "# v is relation name", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "v", ",", "self", ".", "nodes", "[", "i", "]", ",", "k", ")", ")", "\n", "# k2 is the attribute name", "\n", "# v2 is the attribute value", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "k2", ",", "self", ".", "nodes", "[", "i", "]", ",", "v2", ")", ")", "\n", "", "", "return", "instance_triple", ",", "relation_triple", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.__str__": [[324, 339], ["range", "len", "lines.append", "lines.append", "lines.append", "list", "list", "amr_utils.AMR.relations[].items", "lines.append", "amr_utils.AMR.attributes[].items", "lines.append", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate AMR string for better readability\n\n        \"\"\"", "\n", "lines", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "lines", ".", "append", "(", "\"Node \"", "+", "str", "(", "i", ")", "+", "\" \"", "+", "self", ".", "nodes", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Value: \"", "+", "self", ".", "node_values", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Relations:\"", ")", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "lines", ".", "append", "(", "\"Node \"", "+", "k", "+", "\" via \"", "+", "v", ")", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "lines", ".", "append", "(", "\"Attribute: \"", "+", "k2", "+", "\" value \"", "+", "v2", ")", "\n", "", "", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.__repr__": [[340, 342], ["amr_utils.AMR.__str__"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.AMR.parse_AMR_line": [[343, 579], ["collections.defaultdict", "collections.defaultdict", "enumerate", "amr_utils.AMR", "line.strip", "relation_list.append", "attribute_list.append", "print", "node_value_list.append", "cur_charseq.append", "cur_charseq.append", "cur_charseq.append", "print", "cur_charseq.append", "temp_attr_value.split", "parts[].strip", "parts[].strip", "cur_charseq.append", "stack.append", "node_name_list.append", "print", "stack.pop", "cur_charseq.append", "len", "print", "len", "print", "node_relation_dict2[].append", "node_relation_dict1[].append", "print", "cur_charseq.append", "len", "print", "temp_attr_value.split", "parts[].strip", "parts[].strip", "parts[].strip.endswith", "cur_relation_name.endswith", "node_relation_dict1[].append", "node_relation_dict1[].append", "len", "print", "node_relation_dict1[].append", "node_relation_dict2[].append", "node_relation_dict1[].append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "parse_AMR_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"\n        Parse a AMR from line representation to an AMR object.\n        This parsing algorithm scans the line once and process each character, in a shift-reduce style.\n\n        \"\"\"", "\n", "# Current state. It denotes the last significant symbol encountered. 1 for (, 2 for :, 3 for /,", "\n", "# and 0 for start state or ')'", "\n", "# Last significant symbol is ( --- start processing node name", "\n", "# Last significant symbol is : --- start processing relation name", "\n", "# Last significant symbol is / --- start processing node value (concept name)", "\n", "# Last significant symbol is ) --- current node processing is complete", "\n", "# Note that if these symbols are inside parenthesis, they are not significant symbols.", "\n", "state", "=", "0", "\n", "# node stack for parsing", "\n", "stack", "=", "[", "]", "\n", "# current not-yet-reduced character sequence", "\n", "cur_charseq", "=", "[", "]", "\n", "# key: node name value: node value", "\n", "node_dict", "=", "{", "}", "\n", "# node name list (order: occurrence of the node)", "\n", "node_name_list", "=", "[", "]", "\n", "# key: node name:  value: list of (relation name, the other node name)", "\n", "node_relation_dict1", "=", "defaultdict", "(", "list", ")", "\n", "# key: node name, value: list of (attribute name, const value) or (relation name, unseen node name)", "\n", "node_relation_dict2", "=", "defaultdict", "(", "list", ")", "\n", "# current relation name", "\n", "cur_relation_name", "=", "\"\"", "\n", "# having unmatched quote string", "\n", "in_quote", "=", "False", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "line", ".", "strip", "(", ")", ")", ":", "\n", "            ", "if", "c", "==", "\" \"", ":", "\n", "# allow space in relation name", "\n", "                ", "if", "state", "==", "2", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "", "continue", "\n", "", "if", "c", "==", "\"\\\"\"", ":", "\n", "# flip in_quote value when a quote symbol is encountered", "\n", "# insert placeholder if in_quote from last symbol", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "'_'", ")", "\n", "", "in_quote", "=", "not", "in_quote", "\n", "", "elif", "c", "==", "\"(\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# get the attribute name", "\n", "# e.g :arg0 (x ...", "\n", "# at this point we get \"arg0\"", "\n", "", "if", "state", "==", "2", ":", "\n", "# in this state, current relation name should be empty", "\n", "                    ", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "                        ", "print", "(", "\"Format error when processing \"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# update current relation name for future use", "\n", "", "cur_relation_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", ".", "strip", "(", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "", "state", "=", "1", "\n", "", "elif", "c", "==", "\":\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"/\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :OR (o2 / *OR*", "\n", "#    :mod (o3 / official)", "\n", "#  gets node value \"*OR*\" at this point", "\n", "", "if", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "# clear current char sequence", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# pop node name (\"o2\" in the above example)", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# update node name/value map", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# Last significant symbol is \":\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :op1 w :quant 30", "\n", "# or :day 14 :month 3", "\n", "# the problem is that we cannot decide if node value is attribute value (constant)", "\n", "# or node value (variable) at this moment", "\n", "", "elif", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error in processing; part len < 2\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# For the above example, node name is \"op1\", and node value is \"w\"", "\n", "# Note that this node name might not be encountered before", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# We need to link upper level node to the current", "\n", "# top of stack is upper level node", "\n", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                        ", "print", "(", "\"Error in processing\"", ",", "line", "[", ":", "i", "]", ",", "relation_name", ",", "relation_value", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# if we have not seen this node name before", "\n", "", "if", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "node_relation_dict2", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "else", ":", "\n", "                        ", "node_relation_dict1", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "", "state", "=", "2", "\n", "", "elif", "c", "==", "\"/\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"(\". Now we encounter \"/\"", "\n", "# Example:", "\n", "# (d / default-01", "\n", "# get \"d\" here", "\n", "", "if", "state", "==", "1", ":", "\n", "                    ", "node_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# if this node name is already in node_dict, it is duplicate", "\n", "if", "node_name", "in", "node_dict", ":", "\n", "                        ", "print", "(", "\"Duplicate node name \"", ",", "node_name", ",", "\" in parsing AMR\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# push the node name to stack", "\n", "", "stack", ".", "append", "(", "node_name", ")", "\n", "# add it to node name list", "\n", "node_name_list", ".", "append", "(", "node_name", ")", "\n", "# if this node is part of the relation", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# cur_relation_name is arg1", "\n", "# node name is n", "\n", "# we have a relation arg1(upper level node, n)", "\n", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "# if relation name ends with \"-of\", e.g.\"arg0-of\",", "\n", "# it is reverse of some relation. For example, if a is \"arg0-of\" b,", "\n", "# we can also say b is \"arg0\" a.", "\n", "# If the relation name ends with \"-of\", we store the reverse relation.", "\n", "                        ", "if", "not", "cur_relation_name", ".", "endswith", "(", "\"-of\"", ")", ":", "\n", "# stack[-2] is upper_level node we encountered, as we just add node_name to stack", "\n", "                            ", "node_relation_dict1", "[", "stack", "[", "-", "2", "]", "]", ".", "append", "(", "(", "cur_relation_name", ",", "node_name", ")", ")", "\n", "", "else", ":", "\n", "# cur_relation_name[:-3] is to delete \"-of\"", "\n", "                            ", "node_relation_dict1", "[", "node_name", "]", ".", "append", "(", "(", "cur_relation_name", "[", ":", "-", "3", "]", ",", "stack", "[", "-", "2", "]", ")", ")", "\n", "# clear current_relation_name", "\n", "", "cur_relation_name", "=", "\"\"", "\n", "", "", "else", ":", "\n", "# error if in other state", "\n", "                    ", "print", "(", "\"Error in parsing AMR\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "state", "=", "3", "\n", "", "elif", "c", "==", "\")\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# stack should be non-empty to find upper level node", "\n", "", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                    ", "print", "(", "\"Unmatched parenthesis at position\"", ",", "i", ",", "\"in processing\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# Last significant symbol is \":\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :op2 \"Brown\") or :op2 w)", "\n", "# get \\\"Brown\\\" or w here", "\n", "", "if", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error processing\"", ",", "line", "[", ":", "i", "+", "1", "]", ",", "temp_attr_value", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# store reverse of the relation", "\n", "# we are sure relation_value is a node here, as \"-of\" relation is only between two nodes", "\n", "if", "relation_name", ".", "endswith", "(", "\"-of\"", ")", ":", "\n", "                        ", "node_relation_dict1", "[", "relation_value", "]", ".", "append", "(", "(", "relation_name", "[", ":", "-", "3", "]", ",", "stack", "[", "-", "1", "]", ")", ")", "\n", "# attribute value not seen before", "\n", "# Note that it might be a constant attribute value, or an unseen node", "\n", "# process this after we have seen all the node names", "\n", "", "elif", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "node_relation_dict2", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "else", ":", "\n", "                        ", "node_relation_dict1", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "# Last significant symbol is \"/\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# we get \"nation\" here", "\n", "", "", "elif", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# map node name to its value", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# pop from stack, as the current node has been processed", "\n", "", "stack", ".", "pop", "(", ")", "\n", "cur_relation_name", "=", "\"\"", "\n", "state", "=", "0", "\n", "", "else", ":", "\n", "# not significant symbols, so we just shift.", "\n", "                ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "#create data structures to initialize an AMR", "\n", "", "", "node_value_list", "=", "[", "]", "\n", "relation_list", "=", "[", "]", "\n", "attribute_list", "=", "[", "]", "\n", "for", "v", "in", "node_name_list", ":", "\n", "            ", "if", "v", "not", "in", "node_dict", ":", "\n", "                ", "print", "(", "\"Error: Node name not found\"", ",", "v", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "else", ":", "\n", "                ", "node_value_list", ".", "append", "(", "node_dict", "[", "v", "]", ")", "\n", "# build relation map and attribute map for this node", "\n", "", "relation_dict", "=", "{", "}", "\n", "attribute_dict", "=", "{", "}", "\n", "if", "v", "in", "node_relation_dict1", ":", "\n", "                ", "for", "v1", "in", "node_relation_dict1", "[", "v", "]", ":", "\n", "                    ", "relation_dict", "[", "v1", "[", "1", "]", "]", "=", "v1", "[", "0", "]", "\n", "", "", "if", "v", "in", "node_relation_dict2", ":", "\n", "                ", "for", "v2", "in", "node_relation_dict2", "[", "v", "]", ":", "\n", "# if value is in quote, it is a constant value", "\n", "# strip the quote and put it in attribute map", "\n", "                    ", "if", "v2", "[", "1", "]", "[", "0", "]", "==", "\"\\\"\"", "and", "v2", "[", "1", "]", "[", "-", "1", "]", "==", "\"\\\"\"", ":", "\n", "                        ", "attribute_dict", "[", "v2", "[", "0", "]", "]", "=", "v2", "[", "1", "]", "[", "1", ":", "-", "1", "]", "\n", "# if value is a node name", "\n", "", "elif", "v2", "[", "1", "]", "in", "node_dict", ":", "\n", "                        ", "relation_dict", "[", "v2", "[", "1", "]", "]", "=", "v2", "[", "0", "]", "\n", "", "else", ":", "\n", "                        ", "attribute_dict", "[", "v2", "[", "0", "]", "]", "=", "v2", "[", "1", "]", "\n", "# each node has a relation map and attribute map", "\n", "", "", "", "relation_list", ".", "append", "(", "relation_dict", ")", "\n", "attribute_list", ".", "append", "(", "attribute_dict", ")", "\n", "# add TOP as an attribute. The attribute value is the top node value", "\n", "", "attribute_list", "[", "0", "]", "[", "\"TOP\"", "]", "=", "node_value_list", "[", "0", "]", "\n", "#print node_name_list", "\n", "#print node_value_list", "\n", "#print relation_list", "\n", "#print attribute_list,'\\n\\n'", "\n", "result_amr", "=", "AMR", "(", "node_name_list", ",", "node_value_list", ",", "relation_list", ",", "attribute_list", ")", "\n", "return", "result_amr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.get_default_amr": [[13, 16], ["None"], "function", ["None"], ["def", "get_default_amr", "(", ")", ":", "\n", "    ", "default", "=", "'(w / want-01 :ARG0 (b / boy) :ARG1 (g / go-01 :ARG0 b))'", "\n", "return", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.write_to_file": [[18, 26], ["out_f.close", "open", "out_f.write", "out_f.write", "line.strip", "line.strip"], "function", ["None"], ["", "def", "write_to_file", "(", "lst", ",", "file_new", ",", "extra_newline", "=", "False", ")", ":", "\n", "    ", "with", "open", "(", "file_new", ",", "'w'", ")", "as", "out_f", ":", "\n", "        ", "for", "line", "in", "lst", ":", "\n", "            ", "if", "extra_newline", ":", "\n", "                ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n\\n'", ")", "\n", "", "else", ":", "\n", "                ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.get_files_by_ext": [[28, 38], ["os.walk", "f.endswith", "return_files.append", "os.path.join"], "function", ["None"], ["", "def", "get_files_by_ext", "(", "direc", ",", "ext", ")", ":", "\n", "    ", "'''Function that traverses a directory and returns all files that match a certain extension'''", "\n", "\n", "return_files", "=", "[", "]", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "direc", ")", ":", "\n", "        ", "for", "f", "in", "files", ":", "\n", "            ", "if", "f", ".", "endswith", "(", "ext", ")", ":", "\n", "                ", "return_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "root", ",", "f", ")", ")", "\n", "\n", "", "", "", "return", "return_files", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.is_number": [[40, 46], ["float"], "function", ["None"], ["", "def", "is_number", "(", "s", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.tokenize_line": [[48, 54], ["line.replace().replace", "new_l.replace().replace.replace().replace", "new_l.replace().replace.split", "line.replace", "new_l.replace().replace.replace"], "function", ["None"], ["", "", "def", "tokenize_line", "(", "line", ")", ":", "\n", "    ", "new_l", "=", "line", ".", "replace", "(", "'('", ",", "' ( '", ")", ".", "replace", "(", "')'", ",", "' ) '", ")", "\n", "# We want to make sure that we do Wiki links correctly", "\n", "# They always look like this :wiki \"link_(information)\"", "\n", "new_l", "=", "new_l", ".", "replace", "(", "'_ ('", ",", "'_('", ")", ".", "replace", "(", "') \"'", ",", "')\"'", ")", "\n", "return", "\" \"", ".", "join", "(", "new_l", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.reverse_tokenize": [[56, 61], ["new_line.replace().replace.replace().replace", "new_line.replace().replace.replace"], "function", ["None"], ["", "def", "reverse_tokenize", "(", "new_line", ")", ":", "\n", "    ", "while", "' )'", "in", "new_line", "or", "'( '", "in", "new_line", ":", "#restore tokenizing", "\n", "        ", "new_line", "=", "new_line", ".", "replace", "(", "' )'", ",", "')'", ")", ".", "replace", "(", "'( '", ",", "'('", ")", "\n", "\n", "", "return", "new_line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.between_quotes": [[63, 66], ["string.startswith", "string.endswith", "string.startswith", "string.endswith"], "function", ["None"], ["", "def", "between_quotes", "(", "string", ")", ":", "\n", "    ", "'''Return true if a value is between quotes'''", "\n", "return", "(", "string", ".", "startswith", "(", "'\"'", ")", "and", "string", ".", "endswith", "(", "'\"'", ")", ")", "or", "(", "string", ".", "startswith", "(", "\"'\"", ")", "and", "string", ".", "endswith", "(", "\"'\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.replace_not_in_quotes": [[68, 81], ["None"], "function", ["None"], ["", "def", "replace_not_in_quotes", "(", "line", ",", "to_replace", ",", "replace_with", ")", ":", "\n", "    ", "'''Replace a character with another character if not between quotes'''", "\n", "new_str", "=", "''", "\n", "between_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "new_str", "+=", "ch", "\n", "", "elif", "ch", "==", "to_replace", "and", "not", "between_quotes", ":", "\n", "            ", "new_str", "+=", "replace_with", "\n", "", "else", ":", "\n", "            ", "new_str", "+=", "ch", "\n", "", "", "return", "new_str", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.space_brackets_amr": [[83, 98], ["new_line.split"], "function", ["None"], ["", "def", "space_brackets_amr", "(", "line", ")", ":", "\n", "    ", "'''Add space around brackets for AMR, except if it's between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "')'", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' ) '", "\n", "", "elif", "ch", "==", "'('", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' ( '", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "new_line", "+=", "ch", "\n", "", "else", ":", "\n", "            ", "new_line", "+=", "ch", "\n", "", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.left_space_for_char": [[100, 113], ["new_line.split"], "function", ["None"], ["", "def", "left_space_for_char", "(", "line", ",", "check_char", ")", ":", "\n", "    ", "'''Add a left space for a certain character in a certain line, only if not between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "check_char", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' '", "+", "ch", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "new_line", "+=", "ch", "\n", "", "else", ":", "\n", "            ", "new_line", "+=", "ch", "\n", "", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.remove_char_outside_quotes": [[115, 126], ["new_line.split"], "function", ["None"], ["", "def", "remove_char_outside_quotes", "(", "line", ",", "check_char", ")", ":", "\n", "    ", "'''Remove a character from a string, if it's not between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "check_char", "and", "not", "current_quotes", ":", "\n", "            ", "continue", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "", "new_line", "+=", "ch", "\n", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.count_not_between_quotes": [[128, 138], ["None"], "function", ["None"], ["", "def", "count_not_between_quotes", "(", "char", ",", "string", ")", ":", "\n", "    ", "'''Count number of occurences for a certain character, don't count if it's between quotes'''", "\n", "count", "=", "0", "\n", "between_quotes", "=", "False", "\n", "for", "ch", "in", "string", ":", "\n", "        ", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "", "elif", "ch", "==", "char", "and", "not", "between_quotes", ":", "\n", "            ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.variable_match": [[140, 146], ["any", "len", "spl[].startswith", "len", "len", "char.isalpha", "len", "[].isdigit", "len", "x.isalpha", "x.isdigit"], "function", ["None"], ["", "def", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ")", ":", "\n", "    ", "'''Function that matches entities that are variables occurring for the second time'''", "\n", "# Beginning or end are never variables", "\n", "if", "idx", ">=", "len", "(", "spl", ")", "or", "idx", "==", "0", ":", "\n", "        ", "return", "False", "\n", "", "return", "spl", "[", "idx", "-", "1", "]", "!=", "'/'", "and", "any", "(", "char", ".", "isalpha", "(", ")", "for", "char", "in", "spl", "[", "idx", "]", ")", "and", "spl", "[", "idx", "]", "not", "in", "no_var_list", "and", "not", "spl", "[", "idx", "]", ".", "startswith", "(", "':'", ")", "and", "len", "(", "[", "x", "for", "x", "in", "spl", "[", "idx", "]", "if", "x", ".", "isalpha", "(", ")", "or", "x", ".", "isdigit", "(", ")", "]", ")", "==", "len", "(", "spl", "[", "idx", "]", ")", "and", "(", "len", "(", "spl", "[", "idx", "]", ")", "==", "1", "or", "(", "len", "(", "spl", "[", "idx", "]", ")", ">", "1", "and", "spl", "[", "idx", "]", "[", "-", "1", "]", ".", "isdigit", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.load_dict": [[148, 155], ["in_f.close", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "def", "load_dict", "(", "d", ")", ":", "\n", "    ", "'''Funcion that loads json dictionaries'''", "\n", "# Load reference dict (based on training data) to settle disputes based on frequency", "\n", "with", "open", "(", "d", ",", "'r'", ")", "as", "in_f", ":", "\n", "        ", "dic", "=", "json", ".", "load", "(", "in_f", ")", "\n", "", "in_f", ".", "close", "(", ")", "\n", "return", "dic", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.add_to_dict": [[157, 164], ["None"], "function", ["None"], ["", "def", "add_to_dict", "(", "d", ",", "key", ",", "base", ")", ":", "\n", "    ", "'''Function to add key to dictionary, either add base or start with base'''", "\n", "if", "key", "in", "d", ":", "\n", "        ", "d", "[", "key", "]", "+=", "base", "\n", "", "else", ":", "\n", "        ", "d", "[", "key", "]", "=", "base", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.countparens": [[166, 175], ["None"], "function", ["None"], ["", "def", "countparens", "(", "text", ")", ":", "\n", "    ", "''' proper nested parens counting '''", "\n", "currcount", "=", "0", "\n", "for", "i", "in", "text", ":", "\n", "        ", "if", "i", "==", "\"(\"", ":", "\n", "            ", "currcount", "+=", "1", "\n", "", "elif", "i", "==", "\")\"", ":", "\n", "            ", "currcount", "-=", "1", "\n", "", "", "return", "currcount", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.AMR_scripts.amr_utils.valid_amr": [[177, 192], ["amr_utils.countparens", "amr_utils.AMR.parse_AMR_line", "print", "print"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.countparens", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.parse_AMR_line"], ["", "def", "valid_amr", "(", "amrtext", ")", ":", "\n", "# Wrong parentheses, return false", "\n", "    ", "if", "not", "countparens", "(", "amrtext", ")", ":", "\n", "        ", "return", "False", "\n", "", "try", ":", "\n", "        ", "theamr", "=", "AMR", ".", "parse_AMR_line", "(", "amrtext", ")", "\n", "if", "theamr", "is", "None", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "", "", "except", "(", "AttributeError", ",", "Exception", ")", "as", "e", ":", "\n", "        ", "print", "(", "'Error:'", ",", "e", ")", "\n", "print", "(", "amrtext", ")", "\n", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.create_arg_parser": [[40, 49], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"File with AMRs (one line)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"Output file\"", ")", "\n", "parser", ".", "add_argument", "(", "'-c'", ",", "\"--coreference\"", ",", "default", "=", "'dupl'", ",", "choices", "=", "[", "'dupl'", ",", "'index'", ",", "'abs'", "]", ",", "help", "=", "'How to handle coreference - input was either duplicated/indexed/absolute path (default dupl)'", ")", "\n", "parser", ".", "add_argument", "(", "\"-r\"", ",", "\"--ref_dict\"", ",", "default", "=", "'restoreAMR/ref_dict'", ",", "type", "=", "str", ",", "help", "=", "\"Ref dict file\"", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "'--print_stats'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Print coreference statistics'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.preprocess": [[51, 61], ["preprocess_abs.replace", "preprocess_abs.replace", "amr_utils.replace_not_in_quotes", "restore_amr.preprocess_abs"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.replace_not_in_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.preprocess_abs"], ["", "def", "preprocess", "(", "line", ",", "coreference", ")", ":", "\n", "    ", "'''Preprocess line back to format without + for space. Special case:\n       :polite +, we need to keep that'''", "\n", "line", "=", "line", ".", "replace", "(", "':polite +'", ",", "':polite 100'", ")", "\n", "line", "=", "line", ".", "replace", "(", "' '", ",", "''", ")", "\n", "line", "=", "replace_not_in_quotes", "(", "line", ",", "'+'", ",", "' '", ")", "\n", "# Absolute paths need a different preprocessing step", "\n", "if", "coreference", "==", "'abs'", ":", "\n", "        ", "line", "=", "preprocess_abs", "(", "line", ")", "\n", "", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.initial_check": [[63, 80], ["amr_utils.load_dict", "dict.fromkeys"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.load_dict"], ["", "def", "initial_check", "(", "coreference", ",", "ref_file", ")", ":", "\n", "    ", "'''Do initial checks and prints, load dicts as well'''", "\n", "if", "coreference", "==", "'index'", ":", "\n", "        ", "replace_types", "=", "[", "'Normal case'", ",", "'Replace by variable that is not referred to'", ",", "'Replace by most frequent index'", ",", "'Replace by most frequent concept'", ",", "'No concepts found - do person'", "]", "\n", "index_dict", "=", "dict", ".", "fromkeys", "(", "replace_types", ",", "0", ")", "\n", "", "elif", "coreference", "==", "'abs'", ":", "\n", "        ", "replace_types", "=", "[", "'Path lead to variable'", ",", "'Path did not lead to variable'", "]", "\n", "index_dict", "=", "{", "}", "\n", "index_dict", "[", "replace_types", "[", "0", "]", "]", "=", "[", "]", "\n", "index_dict", "[", "replace_types", "[", "1", "]", "]", "=", "[", "]", "\n", "", "else", ":", "\n", "        ", "index_dict", "=", "{", "}", "\n", "replace_types", "=", "[", "]", "\n", "\n", "# Load dictionary with frequency information", "\n", "", "ref_dict", "=", "load_dict", "(", "ref_file", ")", "\n", "return", "ref_dict", ",", "index_dict", ",", "replace_types", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.remove_dangling_edges": [[84, 89], ["line.split"], "function", ["None"], ["", "def", "remove_dangling_edges", "(", "line", ")", ":", "\n", "    ", "'''Remove unfinished edges (can happen with char-level output)'''", "\n", "if", "line", "[", "-", "1", "]", "!=", "')'", ":", "\n", "        ", "line", "=", "\")\"", ".", "join", "(", "line", ".", "split", "(", "')'", ")", "[", ":", "-", "1", "]", ")", "+", "')'", "\n", "", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.replace_var": [[91, 106], ["cc.count", "cc.append", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "str", "str", "str", "m.group", "str", "str", "str"], "function", ["None"], ["", "def", "replace_var", "(", "m", ")", ":", "\n", "    ", "global", "c", "\n", "global", "cc", "\n", "global", "ggg", "\n", "if", "[", "'name'", ",", "'date'", "]", ".", "count", "(", "m", ".", "group", "(", "1", ")", ")", "==", "1", ":", "\n", "        ", "c", "+=", "1", "\n", "return", "'(v'", "+", "str", "(", "ggg", ")", "+", "str", "(", "c", ")", "+", "' / '", "+", "m", ".", "group", "(", "1", ")", "+", "m", ".", "group", "(", "2", ")", "\n", "", "if", "cc", ".", "count", "(", "m", ".", "group", "(", "1", ")", ")", "==", "0", ":", "\n", "        ", "cc", ".", "append", "(", "m", ".", "group", "(", "1", ")", ")", "\n", "return", "'(vv'", "+", "str", "(", "ggg", ")", "+", "m", ".", "group", "(", "1", ")", "+", "' / '", "+", "m", ".", "group", "(", "1", ")", "+", "m", ".", "group", "(", "2", ")", "\n", "# Don't replace duplicates for abs/index", "\n", "", "if", "m", ".", "group", "(", "2", ")", "==", "' )'", "and", "args", ".", "coreference", "not", "in", "[", "'abs'", ",", "'index'", "]", ":", "\n", "        ", "return", "' vv'", "+", "str", "(", "ggg", ")", "+", "m", ".", "group", "(", "1", ")", "\n", "", "c", "+=", "1", "\n", "return", "'(vvvv'", "+", "str", "(", "ggg", ")", "+", "str", "(", "c", ")", "+", "' / '", "+", "m", ".", "group", "(", "1", ")", "+", "m", ".", "group", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.replace_var2": [[108, 118], ["m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group", "m.group"], "function", ["None"], ["", "def", "replace_var2", "(", "m", ")", ":", "\n", "    ", "if", "m", ".", "group", "(", "2", ")", "==", "\"-\"", ":", "\n", "        ", "return", "\"%s %s\"", "%", "(", "m", ".", "group", "(", "1", ")", ",", "m", ".", "group", "(", "2", ")", ")", "\n", "", "if", "m", ".", "group", "(", "2", ")", "==", "\"interrogative\"", ":", "\n", "        ", "return", "\"%s %s\"", "%", "(", "m", ".", "group", "(", "1", ")", ",", "m", ".", "group", "(", "2", ")", ")", "\n", "", "if", "m", ".", "group", "(", "2", ")", "==", "\"expressive\"", ":", "\n", "        ", "return", "\"%s %s\"", "%", "(", "m", ".", "group", "(", "1", ")", ",", "m", ".", "group", "(", "2", ")", ")", "\n", "", "if", "m", ".", "group", "(", "2", ")", "==", "\"imperative\"", ":", "\n", "        ", "return", "\"%s %s\"", "%", "(", "m", ".", "group", "(", "1", ")", ",", "m", ".", "group", "(", "2", ")", ")", "\n", "", "return", "\"%s \\\"%s\\\"\"", "%", "(", "m", ".", "group", "(", "1", ")", ",", "m", ".", "group", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_quotes": [[120, 125], ["m.group().strip", "m.group", "m.group", "m.group"], "function", ["None"], ["", "def", "add_quotes", "(", "m", ")", ":", "\n", "    ", "value", "=", "m", ".", "group", "(", "2", ")", ".", "strip", "(", ")", "\n", "if", "value", "==", "'-'", ":", "\n", "        ", "return", "'%s %s '", "%", "(", "m", ".", "group", "(", "1", ")", ",", "value", ")", "\n", "", "return", "'%s \"%s\" '", "%", "(", "m", ".", "group", "(", "1", ")", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.convert": [[127, 196], ["line.rstrip.rstrip().lstrip", "line.rstrip.rstrip().lstrip", "re.sub", "enumerate", "unbracket.sub", "dangling_edges.sub", "missing_edges.sub", "missing_variable.sub", "missing_quotes.sub", "misplaced_colon.sub", "missing_concept_and_variable.sub", "dangling_quotes.sub", "line.rstrip.split", "re.sub", "len", "len", "re.sub", "line.rstrip.replace", "line.rstrip.rstrip", "line.rstrip.rstrip", "line[].strip", "re.findall", "re.findall", "range", "line.rstrip.rstrip", "line.rstrip.rstrip"], "function", ["None"], ["", "def", "convert", "(", "line", ")", ":", "\n", "    ", "line", "=", "line", ".", "rstrip", "(", ")", ".", "lstrip", "(", "' \\xef\\xbb\\xbf\\\\ufeff'", ")", "\n", "line", "=", "line", ".", "rstrip", "(", ")", ".", "lstrip", "(", "'> '", ")", "\n", "line", "=", "\" \"", ".", "join", "(", "line", ".", "split", "(", ")", ")", "\n", "global", "cc", "\n", "global", "c", "\n", "global", "ggg", "\n", "c", "=", "0", "\n", "cc", "=", "[", "]", "\n", "old_line", "=", "line", "\n", "while", "True", ":", "\n", "        ", "line", "=", "re", ".", "sub", "(", "r'(\\( ?name [^()]*:op\\d+|:wiki) ([^\\-_():\"][^():\"]*)(?=[:\\)])'", ",", "add_quotes", ",", "line", ",", "re", ".", "I", ")", "\n", "if", "old_line", "==", "line", ":", "\n", "            ", "break", "\n", "", "old_line", "=", "line", "\n", "# Add variables back here", "\n", "", "line", "=", "' '", "+", "line", "\n", "line", "=", "re", ".", "sub", "(", "r'[^_]\\(\\s*([\\w\\-\\d]+)(\\W|\\))'", ",", "replace_var", ",", "line", ")", "\n", "\n", "# Make sure parentheses match", "\n", "open_count", "=", "0", "\n", "close_count", "=", "0", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "line", ")", ":", "\n", "        ", "if", "c", "==", "'('", ":", "\n", "            ", "open_count", "+=", "1", "\n", "", "elif", "c", "==", "')'", ":", "\n", "            ", "close_count", "+=", "1", "\n", "", "if", "open_count", "==", "close_count", "and", "open_count", ">", "0", ":", "\n", "            ", "line", "=", "line", "[", ":", "i", "]", ".", "strip", "(", ")", "\n", "break", "\n", "\n", "", "", "old_line", "=", "line", "\n", "while", "True", ":", "\n", "        ", "open_count", "=", "len", "(", "re", ".", "findall", "(", "r'\\('", ",", "line", ")", ")", "\n", "close_count", "=", "len", "(", "re", ".", "findall", "(", "r'\\)'", ",", "line", ")", ")", "\n", "if", "open_count", ">", "close_count", ":", "\n", "            ", "line", "+=", "')'", "*", "(", "open_count", "-", "close_count", ")", "\n", "", "elif", "close_count", ">", "open_count", ":", "\n", "            ", "for", "i", "in", "range", "(", "close_count", "-", "open_count", ")", ":", "\n", "                ", "line", "=", "line", ".", "rstrip", "(", "')'", ")", "\n", "line", "=", "line", ".", "rstrip", "(", "' '", ")", "\n", "\n", "", "", "if", "old_line", "==", "line", ":", "\n", "            ", "break", "\n", "", "old_line", "=", "line", "\n", "\n", "", "old_line", "=", "line", "\n", "\n", "while", "True", ":", "\n", "        ", "line", "=", "re", ".", "sub", "(", "r'(:\\w+) ([^\\W\\d\\-][\\w\\-]*)(?=\\W)'", ",", "replace_var2", ",", "line", ",", "re", ".", "I", ")", "\n", "if", "old_line", "==", "line", ":", "\n", "            ", "break", "\n", "", "old_line", "=", "line", "\n", "\n", "# Add the extra spaces that are sometimes needed", "\n", "", "extra_space_needed", "=", "[", "'imperative'", ",", "'interrogative'", ",", "'expressive'", "]", "\n", "for", "esn", "in", "extra_space_needed", ":", "\n", "        ", "line", "=", "line", ".", "replace", "(", "esn", ",", "' {0} '", ".", "format", "(", "esn", ")", ")", "\n", "\n", "# Fix other problems that might still be there", "\n", "", "line", "=", "unbracket", ".", "sub", "(", "r'\\1'", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "dangling_edges", ".", "sub", "(", "''", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "missing_edges", ".", "sub", "(", "r'\\1 :ARG2 ('", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "missing_variable", ".", "sub", "(", "r'vvvx / \\1 '", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "missing_quotes", ".", "sub", "(", "r'\\1\"'", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "misplaced_colon", ".", "sub", "(", "r''", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "missing_concept_and_variable", ".", "sub", "(", "r'd / dummy '", ",", "line", ",", "re", ".", "U", ")", "\n", "line", "=", "dangling_quotes", ".", "sub", "(", "r'\\1'", ",", "line", ",", "re", ".", "U", ")", "\n", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_space_when_digit": [[198, 226], ["line.split", "range", "len", "spl[].strip().replace", "spl[].replace().replace().strip", "spl[].replace().replace().strip", "spl[].strip", "[].isdigit", "amr_utils.is_number", "spl[].replace().replace", "spl[].replace().replace", "any", "ch.isdigit", "re.sub", "amr_utils.is_number", "re.sub", "spl[].replace", "spl[].replace", "spl[].strip().replace", "spl[].strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.is_number", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.is_number"], ["", "def", "add_space_when_digit", "(", "line", ")", ":", "\n", "    ", "'''Add a space when see a digit, except for arguments of id_list'''", "\n", "id_list", "=", "[", "'ARG'", ",", "'op'", ",", "'snt'", ",", "'-'", "]", "\n", "\n", "spl", "=", "line", ".", "split", "(", "':'", ")", "\n", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "spl", ")", ")", ":", "\n", "        ", "if", "spl", "[", "idx", "]", ".", "strip", "(", ")", ".", "replace", "(", "')'", ",", "''", ")", ":", "\n", "            ", "check_arg", "=", "spl", "[", "idx", "]", ".", "replace", "(", "')'", ",", "''", ")", ".", "replace", "(", "'ARG'", ",", "''", ")", ".", "strip", "(", ")", "\n", "check_op", "=", "spl", "[", "idx", "]", ".", "replace", "(", "')'", ",", "''", ")", ".", "replace", "(", "'op'", ",", "''", ")", ".", "strip", "(", ")", "\n", "# If there is a digit after quant or value, put a space so we don't error, e.g. :value3 becomes :value 3, but not for op, snt and ARG", "\n", "if", "spl", "[", "idx", "]", ".", "strip", "(", ")", ".", "replace", "(", "')'", ",", "''", ")", "[", "-", "1", "]", ".", "isdigit", "(", ")", "and", "(", "not", "any", "(", "x", "in", "spl", "[", "idx", "]", "for", "x", "in", "id_list", ")", ")", ":", "\n", "                ", "new_string", "=", "''", "\n", "added_space", "=", "False", "\n", "for", "ch", "in", "spl", "[", "idx", "]", ":", "\n", "                    ", "if", "ch", ".", "isdigit", "(", ")", ":", "\n", "                        ", "if", "not", "added_space", ":", "\n", "                            ", "new_string", "+=", "' '", "+", "ch", "\n", "added_space", "=", "True", "\n", "", "else", ":", "\n", "                            ", "new_string", "+=", "ch", "\n", "", "", "else", ":", "\n", "                        ", "new_string", "+=", "ch", "\n", "", "", "spl", "[", "idx", "]", "=", "new_string", "\n", "", "elif", "is_number", "(", "check_arg", ")", ":", "#change ARG2444 to ARG2 444", "\n", "                ", "spl", "[", "idx", "]", "=", "re", ".", "sub", "(", "r'(ARG\\d)([\\d\\.]+)'", ",", "r'\\1 \\2'", ",", "spl", "[", "idx", "]", ")", "\n", "", "elif", "is_number", "(", "check_op", ")", ":", "#change op124 to op1 24", "\n", "                ", "spl", "[", "idx", "]", "=", "re", ".", "sub", "(", "r'(op\\d)([\\d\\.]+)'", ",", "r'\\1 \\2'", ",", "spl", "[", "idx", "]", ")", "\n", "", "", "", "return", "':'", ".", "join", "(", "spl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.separate_quotes": [[228, 244], ["None"], "function", ["None"], ["", "def", "separate_quotes", "(", "line", ")", ":", "\n", "    ", "'''Separate quotes from an argument + value, i.e.\n       :op1\"tom\" to :op1 \"tom\" '''", "\n", "quotes", "=", "0", "\n", "new_line", "=", "''", "\n", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "'\"'", ":", "\n", "            ", "quotes", "+=", "1", "\n", "if", "quotes", "%", "2", "!=", "0", "and", "new_line", "[", "-", "1", "]", "!=", "' '", ":", "\n", "                ", "new_line", "+=", "' \"'", "#add space for quote", "\n", "", "else", ":", "\n", "                ", "new_line", "+=", "ch", "\n", "", "", "else", ":", "\n", "            ", "new_line", "+=", "ch", "\n", "", "", "return", "new_line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.do_extra_steps": [[245, 271], ["separate_quotes.replace", "separate_quotes.replace", "restore_amr.separate_quotes", "separate_quotes.replace().replace", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub.replace().replace", "re.sub.replace().replace", "re.sub", "separate_quotes.replace", "re.sub.replace", "re.sub.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.separate_quotes"], ["", "def", "do_extra_steps", "(", "line", ")", ":", "\n", "    ", "'''Do some extra necessary postprocessing/fixing steps'''", "\n", "# Add extra space for colons and parentheses", "\n", "line", "=", "line", ".", "replace", "(", "':'", ",", "' :'", ")", "\n", "line", "=", "line", ".", "replace", "(", "'('", ",", "' ('", ")", "\n", "\n", "# Make sure quotes always start with a leading space (but not end)", "\n", "line", "=", "separate_quotes", "(", "line", ")", "\n", "\n", "# We want to make sure that we do Wiki links correctly", "\n", "# They always look like this :wiki \"link_(information)\"", "\n", "new_line", "=", "line", ".", "replace", "(", "'_ ('", ",", "'_('", ")", ".", "replace", "(", "') \"'", ",", "')\"'", ")", "\n", "\n", "# Fix problem with op and numbers, e.g. change op123.5 to op1 23.5", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(op\\d)(\\d\\d+)'", ",", "r'\\1 \\2'", ",", "new_line", ")", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(op\\d)(\\d+)\\.(\\d+)'", ",", "r'\\1 \\2.\\3'", ",", "new_line", ")", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(mod\\d)(\\d+)\\.(\\d+)'", ",", "r'\\1 \\2.\\3'", ",", "new_line", ")", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(ARG\\d)(\\d+)\\.(\\d+)'", ",", "r'\\1 \\2.\\3'", ",", "new_line", ")", "\n", "\n", "# Make sure polarity and wiki links do not accidentally get removed, this will be", "\n", "# restored in a later step", "\n", "new_line", "=", "new_line", ".", "replace", "(", "':polarity-'", ",", "':polarity 100'", ")", ".", "replace", "(", "':wiki-'", ",", "':wiki \"100\"'", ")", "\n", "new_line", "=", "new_line", ".", "replace", "(", "':polarity -'", ",", "':polarity 100'", ")", ".", "replace", "(", "':wiki -'", ",", "':wiki \"100\"'", ")", "\n", "# Make sure that the paths are treated as separate tokens later", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(\\*[\\d]+\\*)'", ",", "r' \\1 '", ",", "new_line", ")", "\n", "return", "new_line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_coref_instance": [[273, 297], ["enumerate", "amr_utils.remove_char_outside_quotes", "amr_utils.remove_char_outside_quotes", "item.startswith", "item.strip", "add_items.append", "add_items.append", "amr_utils.remove_char_outside_quotes", "len", "amr_utils.is_number", "amr_utils.between_quotes"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.is_number", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.between_quotes"], ["", "def", "add_coref_instance", "(", "next_items", ")", ":", "\n", "    ", "'''Add coreference items that are instantiated by this:\n    *0* country :wiki \"possible value\" :add \"more_values\"'''", "\n", "add_items", "=", "[", "]", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "next_items", ")", ":", "\n", "        ", "if", "item", ".", "strip", "(", ")", "[", "0", "]", "in", "[", "')'", ",", "'('", "]", ":", "\n", "# We are done with adding, return", "\n", "            ", "return", "remove_char_outside_quotes", "(", "\"-----\"", ".", "join", "(", "add_items", ")", ",", "')'", ")", "\n", "", "elif", "item", ".", "startswith", "(", "':'", ")", ":", "\n", "# Only add this item if next one is a constant, i.e. between quotes or number", "\n", "# If not, we stop", "\n", "            ", "if", "idx", "+", "1", "<", "len", "(", "next_items", ")", "and", "(", "is_number", "(", "next_items", "[", "idx", "+", "1", "]", ")", "or", "between_quotes", "(", "next_items", "[", "idx", "+", "1", "]", ")", ")", ":", "\n", "                ", "add_items", ".", "append", "(", "item", ")", "\n", "", "else", ":", "\n", "                ", "return", "remove_char_outside_quotes", "(", "\"-----\"", ".", "join", "(", "add_items", ")", ",", "')'", ")", "\n", "", "", "else", ":", "\n", "            ", "add_items", ".", "append", "(", "item", ")", "\n", "# If we never returned perhaps we were at the end with content (AMR is not valid then though)", "\n", "# Just return items we have so far", "\n", "", "", "if", "add_items", ":", "\n", "        ", "return", "remove_char_outside_quotes", "(", "\"-----\"", ".", "join", "(", "add_items", ")", ",", "')'", ")", "\n", "# Just a reference, not an instantiation", "\n", "", "else", ":", "\n", "        ", "return", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.restore_coref_indexing": [[299, 354], ["re.compile", "line.split", "enumerate", "enumerate", "re.compile.match", "re.compile.match", "new_line.replace().replace.replace().replace", "new_tok.append", "restore_amr.add_coref_instance", "restore_amr.get_most_frequent_word", "new_tok.append", "[].isalpha", "new_line.replace().replace.replace", "len", "len", "new_tok.append", "len", "restore_amr.get_most_frequent_referent", "restore_amr.get_most_frequent_word"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_coref_instance", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_most_frequent_word", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_most_frequent_referent", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_most_frequent_word"], ["", "", "def", "restore_coref_indexing", "(", "line", ",", "ref_dict", ")", ":", "\n", "    ", "'''Restore coreference items, e.g. *3* and *2* with actual word'''", "\n", "pattern", "=", "re", ".", "compile", "(", "r'^\\*[\\d]+\\*$'", ")", "\n", "# Make sure coref indexes are separate", "\n", "tok_line", "=", "line", ".", "split", "(", ")", "\n", "seen_coref", "=", "{", "}", "\n", "new_tok", "=", "[", "]", "\n", "\n", "# First find all instantiated indexes", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "tok_line", ")", ":", "\n", "        ", "if", "pattern", ".", "match", "(", "item", ")", ":", "\n", "            ", "if", "idx", "<", "len", "(", "tok_line", ")", "-", "1", ":", "\n", "                ", "instant_value", "=", "add_coref_instance", "(", "tok_line", "[", "idx", "+", "1", ":", "]", ")", "\n", "# Only add if it actually was an instantiation", "\n", "if", "instant_value", ":", "\n", "                    ", "seen_coref", "[", "item", "]", "=", "instant_value", "\n", "\n", "", "", "", "", "for", "idx", ",", "item", "in", "enumerate", "(", "tok_line", ")", ":", "\n", "# Check if we have a match for a index variable", "\n", "        ", "if", "pattern", ".", "match", "(", "item", ")", ":", "\n", "# Can't look ahead to idx + 1 here", "\n", "            ", "if", "idx", "==", "len", "(", "tok_line", ")", "-", "1", ":", "\n", "                ", "referent", "=", "get_most_frequent_word", "(", "tok_line", ",", "ref_dict", ")", "\n", "new_tok", ".", "append", "(", "'(coref-{0})'", ".", "format", "(", "referent", ")", ")", "\n", "# Instantiated case, just removing index is enough", "\n", "# I.e. *0* work, we remove the *0* and just keep work", "\n", "", "elif", "tok_line", "[", "idx", "+", "1", "]", "[", "0", "]", ".", "isalpha", "(", ")", ":", "\n", "                ", "pass", "\n", "# Replace coref instance", "\n", "", "else", ":", "\n", "                ", "if", "item", "in", "seen_coref", ":", "\n", "# Normal case, reference to instantiated index", "\n", "                    ", "referent", "=", "seen_coref", "[", "item", "]", "\n", "index_dict", "[", "replace_types", "[", "0", "]", "]", "+=", "1", "\n", "# Problem: we have an index but it was never instantiated", "\n", "", "else", ":", "\n", "# Solution: add most frequent other referent (most rather have one that was never instantiated),", "\n", "# if they are all not in train set add one at random", "\n", "                    ", "if", "len", "(", "seen_coref", ")", ">", "0", ":", "\n", "                        ", "referent", "=", "get_most_frequent_referent", "(", "seen_coref", ",", "ref_dict", ",", "tok_line", ")", "\n", "# If there are no other referents just add the most frequent one in general based on all words in sentence", "\n", "", "else", ":", "\n", "                        ", "referent", "=", "get_most_frequent_word", "(", "tok_line", ",", "ref_dict", ")", "\n", "# Hacky: we have no variables here, we need to recognize that we need to replace this word in a later stage without", "\n", "# messing up the restoring variables process. We also add unneccesary brackets to not mess up the variable restoring", "\n", "# process, we remove them in a later stage as well", "\n", "", "", "new_tok", ".", "append", "(", "'(coref-{0})'", ".", "format", "(", "referent", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "new_tok", ".", "append", "(", "item", ")", "\n", "\n", "# Fix some tokenization problems again", "\n", "", "", "new_line", "=", "\" \"", ".", "join", "(", "new_tok", ")", "\n", "while", "' )'", "in", "new_line", "or", "'( '", "in", "new_line", ":", "\n", "        ", "new_line", "=", "new_line", ".", "replace", "(", "' )'", ",", "')'", ")", ".", "replace", "(", "'( '", ",", "'('", ")", "\n", "", "return", "new_line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_most_frequent_word": [[356, 383], ["item[].isalpha", "words.append", "random.choice", "random.choice", "len"], "function", ["None"], ["", "def", "get_most_frequent_word", "(", "tok_line", ",", "ref_dict", ")", ":", "\n", "    ", "'''Function that returns the concept in the AMR (tok_line) that is most frequently a referent in the training set (ref_dict)'''", "\n", "most_freq", ",", "score", "=", "''", ",", "-", "1", "\n", "words", "=", "[", "]", "\n", "\n", "# Collect frequency information", "\n", "for", "item", "in", "tok_line", ":", "\n", "        ", "if", "item", "[", "0", "]", ".", "isalpha", "(", ")", ":", "\n", "            ", "words", ".", "append", "(", "item", ")", "\n", "if", "item", "in", "ref_dict", ":", "\n", "                ", "if", "ref_dict", "[", "item", "]", ">", "score", ":", "\n", "                    ", "score", "=", "ref_dict", "[", "item", "]", "\n", "most_freq", "=", "item", "\n", "\n", "", "", "", "", "if", "score", ">", "-", "1", ":", "\n", "# Return word that most often has a referent in training set", "\n", "        ", "index_dict", "[", "replace_types", "[", "3", "]", "]", "+=", "1", "\n", "return", "most_freq", "\n", "", "elif", "words", ":", "\n", "# No known words from our training set, return random one, last one might be cut-off though so ignore that one", "\n", "        ", "index_dict", "[", "replace_types", "[", "3", "]", "]", "+=", "1", "\n", "rand_return", "=", "random", ".", "choice", "(", "words", "[", "0", ":", "-", "1", "]", ")", "if", "len", "(", "words", ")", ">", "1", "else", "random", ".", "choice", "(", "words", ")", "\n", "return", "rand_return", "\n", "", "else", ":", "\n", "# If all else fails just return person", "\n", "        ", "index_dict", "[", "replace_types", "[", "4", "]", "]", "+=", "1", "\n", "return", "'person'", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_most_frequent_referent": [[385, 429], ["line.count", "random.choice", "list", "seen_coref.keys"], "function", ["None"], ["", "", "def", "get_most_frequent_referent", "(", "seen_coref", ",", "ref_dict", ",", "tok_line", ")", ":", "\n", "    ", "'''Takes care of indexes that were never instantiated'''", "\n", "\n", "# First check if we have instantiated variables that were never referred to", "\n", "line", "=", "\" \"", ".", "join", "(", "tok_line", ")", "\n", "most_freq", "=", "''", "\n", "score", "=", "-", "1", "\n", "\n", "for", "item", "in", "seen_coref", ":", "\n", "# Index only occurs once - never used as reference", "\n", "        ", "if", "line", ".", "count", "(", "item", ")", "==", "1", ":", "\n", "# If this word in general dict, check if it is the most frequent", "\n", "            ", "if", "seen_coref", "[", "item", "]", "in", "ref_dict", ":", "\n", "                ", "if", "ref_dict", "[", "seen_coref", "[", "item", "]", "]", ">", "score", ":", "\n", "                    ", "score", "=", "ref_dict", "[", "seen_coref", "[", "item", "]", "]", "\n", "most_freq", "=", "seen_coref", "[", "item", "]", "\n", "", "", "else", ":", "\n", "                ", "most_freq", "=", "seen_coref", "[", "item", "]", "\n", "score", "=", "0", "\n", "\n", "# If we found once, return that one", "\n", "", "", "", "if", "score", ">", "-", "1", ":", "\n", "        ", "index_dict", "[", "replace_types", "[", "1", "]", "]", "+=", "1", "\n", "return", "most_freq", "\n", "# Else find the most frequent in general", "\n", "", "else", ":", "\n", "        ", "most_freq", "=", "''", "\n", "score", "=", "-", "1", "\n", "# If this word in general dict, check if it is the most frequent", "\n", "for", "item", "in", "seen_coref", ":", "\n", "            ", "if", "seen_coref", "[", "item", "]", "in", "ref_dict", ":", "\n", "                ", "if", "ref_dict", "[", "seen_coref", "[", "item", "]", "]", ">", "score", ":", "\n", "                    ", "score", "=", "ref_dict", "[", "seen_coref", "[", "item", "]", "]", "\n", "most_freq", "=", "seen_coref", "[", "item", "]", "\n", "\n", "", "", "", "if", "score", ">", "-", "1", ":", "\n", "# Return most frequent referent we saw", "\n", "            ", "index_dict", "[", "replace_types", "[", "2", "]", "]", "+=", "1", "\n", "return", "most_freq", "\n", "", "else", ":", "\n", "# If no referents with score, return a random one", "\n", "            ", "index_dict", "[", "replace_types", "[", "2", "]", "]", "+=", "1", "\n", "rand_key", "=", "random", ".", "choice", "(", "list", "(", "seen_coref", ".", "keys", "(", ")", ")", ")", "\n", "return", "seen_coref", "[", "rand_key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_coref": [[431, 470], ["amr_utils.space_brackets_amr().split", "enumerate", "enumerate", "amr_utils.reverse_tokenize", "item.startswith", "amr_utils.space_brackets_amr", "item.replace", "restore_amr.add_coref_instance", "new_tok.append", "new_tok.append", "new_tok.append", "var_dict[].replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.add_coref_instance"], ["", "", "", "def", "add_coref", "(", "line", ")", ":", "\n", "    ", "'''Do the replacement; line includes variables, but we still need to replace 'COREF-person' with 'p', for example'''", "\n", "var_dict", "=", "{", "}", "\n", "tok_line", "=", "space_brackets_amr", "(", "line", ")", ".", "split", "(", ")", "\n", "\n", "# Get variable-value pairs first", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "tok_line", ")", ":", "\n", "# Variable in previous tok and value in tok afterwards", "\n", "        ", "if", "item", "==", "'/'", ":", "\n", "            ", "if", "'coref-'", "not", "in", "tok_line", "[", "idx", "+", "1", "]", ":", "\n", "                ", "value", "=", "add_coref_instance", "(", "tok_line", "[", "idx", "+", "1", ":", "]", ")", "\n", "var_dict", "[", "value", "]", "=", "tok_line", "[", "idx", "-", "1", "]", "\n", "\n", "# Add back the coreference here", "\n", "", "", "", "new_tok", "=", "[", "]", "\n", "ignore_next", "=", "False", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "tok_line", ")", ":", "#add coref back", "\n", "        ", "if", "item", ".", "startswith", "(", "'coref-'", ")", ":", "\n", "            ", "ignore_next", "=", "False", "\n", "it", "=", "item", ".", "replace", "(", "'coref-'", ",", "''", ")", "\n", "if", "it", "in", "var_dict", ":", "\n", "                ", "new_tok", ".", "append", "(", "var_dict", "[", "it", "]", ".", "replace", "(", "'-----'", ",", "' '", ")", ")", "\n", "# Remove previous 3 items, \" ( var / \" and next item \" ) \"", "\n", "new_tok", "[", "-", "2", "]", ",", "new_tok", "[", "-", "3", "]", ",", "new_tok", "[", "-", "4", "]", "=", "''", ",", "''", ",", "''", "\n", "ignore_next", "=", "True", "\n", "", "else", ":", "\n", "# If the reference is unknown, just add person", "\n", "                ", "new_tok", ".", "append", "(", "'person'", ")", "\n", "new_tok", "[", "-", "2", "]", ",", "new_tok", "[", "-", "3", "]", ",", "new_tok", "[", "-", "4", "]", "=", "''", ",", "''", ",", "''", "\n", "ignore_next", "=", "True", "\n", "", "", "elif", "not", "ignore_next", ":", "\n", "            ", "new_tok", ".", "append", "(", "item", ")", "\n", "ignore_next", "=", "False", "\n", "", "else", ":", "\n", "            ", "ignore_next", "=", "False", "\n", "\n", "# Join back the line and return in format we expect later", "\n", "", "", "new_line", "=", "\" \"", ".", "join", "(", "new_tok", ")", "\n", "return", "reverse_tokenize", "(", "new_line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.preprocess_abs": [[472, 505], ["amr_utils.left_space_for_char", "re.sub", "amr_utils.space_brackets_amr", "re.sub.replace().replace().split", "re.sub.split", "re.sub.split", "re.sub.replace().replace", "line_parts.append", "line_parts.append", "line_parts.append", "re.sub.replace", "coref_parts.append", "line_parts.append"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.left_space_for_char", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr"], ["", "def", "preprocess_abs", "(", "line", ")", ":", "\n", "    ", "'''Put in such a format that restoring still works'''", "\n", "# First restore the general format we expect, make sure there are spaces", "\n", "# between all our information carrying tokens", "\n", "new_line", "=", "left_space_for_char", "(", "space_brackets_amr", "(", "line", ")", ",", "':'", ")", "\n", "new_line", "=", "\" \"", ".", "join", "(", "new_line", ".", "replace", "(", "'}'", ",", "' } '", ")", ".", "replace", "(", "'{'", ",", "' { '", ")", ".", "split", "(", ")", ")", "\n", "new_line", "=", "re", ".", "sub", "(", "r'(\\|[\\d]+\\|)'", ",", "r' \\1 '", ",", "new_line", ")", "\n", "new_line", "=", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n", "# Rewrite the absolute paths to coref links so we can restore the coreference later", "\n", "# without the convert() function messing everything up", "\n", "if", "'{'", "in", "new_line", ":", "\n", "        ", "line_parts", "=", "[", "]", "\n", "coref_parts", "=", "[", "]", "\n", "coref", "=", "False", "\n", "for", "item", "in", "new_line", ".", "split", "(", ")", ":", "\n", "            ", "if", "item", "==", "'{'", ":", "\n", "# Add brackets to keep structure", "\n", "                ", "line_parts", ".", "append", "(", "'('", ")", "\n", "coref", "=", "True", "\n", "", "elif", "item", "==", "'}'", ":", "\n", "                ", "add_part", "=", "'COREF*'", "+", "\"*\"", ".", "join", "(", "coref_parts", ")", ".", "replace", "(", "':'", ",", "'COLON'", ")", "\n", "line_parts", ".", "append", "(", "add_part", ")", "\n", "line_parts", ".", "append", "(", "')'", ")", "\n", "coref", "=", "False", "\n", "coref_parts", "=", "[", "]", "\n", "", "elif", "coref", ":", "\n", "                ", "coref_parts", ".", "append", "(", "item", ")", "\n", "", "else", ":", "\n", "                ", "line_parts", ".", "append", "(", "item", ")", "\n", "", "", "return", "\" \"", ".", "join", "(", "line_parts", ")", "\n", "", "else", ":", "\n", "        ", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.replace_absolute_paths": [[507, 529], ["amr_utils.tokenize_line().split", "enumerate", "amr_utils.reverse_tokenize", "amr_utils.tokenize_line", "restore_amr.find_replacement", "amr_utils.tokenize_line", "new_line.replace.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.tokenize_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.find_replacement", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.tokenize_line"], ["", "", "def", "replace_absolute_paths", "(", "line", ",", "ref_dict", ")", ":", "\n", "    ", "'''Replace absolute paths by the correct variable referent'''", "\n", "# Put line in format we expect", "\n", "spl_line", "=", "tokenize_line", "(", "line", ")", ".", "split", "(", ")", "\n", "new_line", "=", "line", "\n", "\n", "# Loop over line and find the replacement for the coreference items", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "spl_line", ")", ":", "\n", "        ", "if", "'COREF*'", "in", "item", ":", "\n", "# Find actual replacement here", "\n", "            ", "repl", "=", "find_replacement", "(", "line", ",", "item", ",", "ref_dict", ")", "\n", "if", "repl", ":", "\n", "# Replace this part with the reference", "\n", "                ", "to_be_replaced", "=", "\" \"", ".", "join", "(", "spl_line", "[", "idx", "-", "3", ":", "idx", "+", "2", "]", ")", "\n", "", "else", ":", "\n", "# Remove reference, so also include the argument", "\n", "                ", "to_be_replaced", "=", "\" \"", ".", "join", "(", "spl_line", "[", "idx", "-", "4", ":", "idx", "+", "2", "]", ")", "\n", "\n", "", "new_line", "=", "tokenize_line", "(", "new_line", ")", "\n", "# Do actual replacement here (adding coreference)", "\n", "new_line", "=", "new_line", ".", "replace", "(", "to_be_replaced", ",", "repl", ")", "\n", "", "", "return", "reverse_tokenize", "(", "new_line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.find_replacement": [[531, 564], ["item.replace().replace().replace().strip", "restore_amr.get_concepts", "best_amr_permutation.filter_colons", "best_amr_permutation.get_keep_string", "restore_amr.possible_path", "amr_utils.space_brackets_amr().split", "int", "line.split", "index_dict[].append", "restore_amr.get_reference", "index_dict[].append", "restore_amr.most_frequent_var", "item.replace().replace().replace", "enumerate", "enumerate", "x.replace().strip", "amr_utils.space_brackets_amr", "item.replace().replace().replace().strip.split", "item.replace().replace().replace().strip.split", "item.replace().replace", "x.replace", "item.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_concepts", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.filter_colons", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_keep_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.possible_path", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_reference", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.most_frequent_var", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr"], ["", "def", "find_replacement", "(", "line", ",", "item", ",", "ref_dict", ")", ":", "\n", "    ", "'''Find variable replacement for the path described in the output'''", "\n", "line", "=", "\" \"", ".", "join", "(", "space_brackets_amr", "(", "line", ")", ".", "split", "(", ")", ")", "\n", "\n", "# We made temporary changes before as to not mess up the AMR, put those back first", "\n", "path", "=", "item", ".", "replace", "(", "'COREF'", ",", "''", ")", ".", "replace", "(", "'COLON'", ",", "':'", ")", ".", "replace", "(", "'*'", ",", "' '", ")", ".", "strip", "(", ")", "\n", "\n", "# Differentiate between arguments and number of arguments", "\n", "args", "=", "[", "x", "for", "idx", ",", "x", "in", "enumerate", "(", "path", ".", "split", "(", ")", ")", "if", "idx", "%", "2", "==", "0", "]", "\n", "num", "=", "[", "x", "for", "idx", ",", "x", "in", "enumerate", "(", "path", ".", "split", "(", ")", ")", "if", "idx", "%", "2", "!=", "0", "]", "\n", "nums", "=", "[", "int", "(", "x", ".", "replace", "(", "'|'", ",", "''", ")", ".", "strip", "(", ")", ")", "for", "x", "in", "num", "]", "\n", "\n", "# Find the concepts in this AMR", "\n", "concept_dict", "=", "get_concepts", "(", "line", ")", "\n", "\n", "# Remove non-arguments that have a colon such as timestamps and websites", "\n", "tok_line", "=", "\" \"", ".", "join", "(", "line", ".", "split", "(", ")", ")", "\n", "new_parts", "=", "filter_colons", "(", "tok_line", ")", "\n", "\n", "# Find the part we have to search", "\n", "_", ",", "search_part", "=", "get_keep_string", "(", "new_parts", ",", "0", ")", "\n", "\n", "# Check if we found a correct path for this AMR", "\n", "path_found", ",", "search_part", "=", "possible_path", "(", "args", ",", "nums", ",", "search_part", ")", "\n", "\n", "# If we found correct path, return it", "\n", "if", "path_found", ":", "\n", "        ", "index_dict", "[", "replace_types", "[", "0", "]", "]", ".", "append", "(", "path", ")", "\n", "return", "get_reference", "(", "search_part", ")", "\n", "# Else return the variable the is most frequently a referent in the training set (default)", "\n", "", "else", ":", "\n", "        ", "index_dict", "[", "replace_types", "[", "1", "]", "]", ".", "append", "(", "path", ")", "\n", "return", "most_frequent_var", "(", "concept_dict", ",", "ref_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_path_to_search": [[566, 588], ["None"], "function", ["None"], ["", "", "def", "get_path_to_search", "(", "search_part", ")", ":", "\n", "    ", "'''Find the path that we will search for this AMR'''", "\n", "add_str", ",", "cur_rel", ",", "prev_rel", ",", "add_cur_rel", ",", "start_adding", "=", "''", ",", "''", ",", "''", ",", "False", ",", "False", "\n", "\n", "for", "ch", "in", "search_part", ":", "\n", "        ", "if", "ch", "==", "':'", ":", "\n", "            ", "add_cur_rel", "=", "True", "\n", "cur_rel", "=", "':'", "\n", "if", "start_adding", ":", "\n", "                ", "add_str", "+=", "ch", "\n", "", "", "elif", "ch", "==", "'('", ":", "\n", "            ", "start_adding", "=", "True", "\n", "add_str", "+=", "ch", "\n", "", "elif", "start_adding", ":", "\n", "            ", "add_str", "+=", "ch", "\n", "", "elif", "ch", "==", "' '", ":", "\n", "            ", "prev_rel", "=", "cur_rel", "\n", "cur_rel", "=", "''", "\n", "add_cur_rel", "=", "False", "\n", "", "elif", "add_cur_rel", ":", "\n", "            ", "cur_rel", "+=", "ch", "\n", "", "", "return", "prev_rel", "+", "' '", "+", "add_str", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_permutations_by_string": [[590, 649], ["re.compile", "re.compile", "enumerate", "restore_amr.get_path_to_search", "get_path_to_search.split", "permutations.append", "enumerate", "permutations.append", "add_string.replace().strip", "re.compile.match", "re.compile.match", "search_part[].isdigit", "add_string.strip", "permutations[].count", "permutations[].count", "p.count", "get_path_to_search.split", "len", "add_string.strip", "add_string.strip", "add_string.replace", "p.split", "permutations.append", "x.strip", "add_string.strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_path_to_search"], ["", "def", "get_permutations_by_string", "(", "search_part", ",", "level", ")", ":", "\n", "    ", "'''Get the initial permutations and add_string'''", "\n", "\n", "paren_count", "=", "0", "\n", "start_adding", "=", "False", "\n", "permutations", "=", "[", "]", "\n", "add_string", "=", "''", "\n", "\n", "if", "level", ">", "0", ":", "\n", "        ", "search_part", "=", "':'", "+", "\":\"", ".", "join", "(", "search_part", ".", "split", "(", "':'", ")", "[", "2", ":", "]", ")", "\n", "search_part", "=", "get_path_to_search", "(", "search_part", ")", "\n", "\n", "# Make sure to handle some special cases", "\n", "", "num_pattern", "=", "re", ".", "compile", "(", "r':[a-zA-Z0-9]+[ ]+(-\\d+|\\d+|imperative|interrogative|expressive|-)'", ")", "\n", "li_pattern", "=", "re", ".", "compile", "(", "r':li+[ ]+\"[A-Za-z-0-9]+\"'", ")", "\n", "\n", "# Remove double spaces from search part", "\n", "search_part", "=", "\" \"", ".", "join", "(", "search_part", ".", "split", "(", ")", ")", "\n", "\n", "for", "idx", ",", "ch", "in", "enumerate", "(", "search_part", ")", ":", "\n", "        ", "if", "ch", "==", "'('", ":", "\n", "            ", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "paren_count", "+=", "1", "\n", "", "elif", "ch", "==", "':'", ":", "\n", "            ", "start_adding", "=", "True", "\n", "add_string", "+=", "ch", "\n", "", "elif", "ch", "==", "')'", ":", "\n", "            ", "paren_count", "-=", "1", "\n", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "if", "paren_count", "==", "0", ":", "\n", "                ", "permutations", ".", "append", "(", "add_string", ".", "strip", "(", ")", ")", "\n", "add_string", "=", "''", "\n", "", "", "elif", "start_adding", ":", "\n", "            ", "add_string", "+=", "ch", "\n", "# Special case, numbers such as :li 2 and :quant 300 mess everything up, or :mode imperative", "\n", "", "if", "idx", "!=", "len", "(", "search_part", ")", "-", "1", "and", "(", "num_pattern", ".", "match", "(", "add_string", ".", "strip", "(", ")", ")", "or", "li_pattern", ".", "match", "(", "add_string", ".", "strip", "(", ")", ")", ")", "and", "not", "search_part", "[", "idx", "+", "1", "]", ".", "isdigit", "(", ")", ":", "\n", "# Then just add permutation now already and continue", "\n", "            ", "permutations", ".", "append", "(", "add_string", ".", "strip", "(", ")", ")", "\n", "add_string", "=", "''", "\n", "\n", "# Check the final string we have left as well", "\n", "", "", "if", "add_string", "and", "':'", "in", "add_string", ":", "\n", "        ", "permutations", ".", "append", "(", "add_string", ".", "replace", "(", "')'", ",", "''", ")", ".", "strip", "(", ")", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "permutations", ")", ":", "\n", "            ", "while", "permutations", "[", "idx", "]", ".", "count", "(", "')'", ")", "<", "permutations", "[", "idx", "]", ".", "count", "(", "'('", ")", ":", "\n", "                ", "permutations", "[", "idx", "]", "+=", "')'", "\n", "\n", "\n", "# Permute without brackets (e.g. :op1 \"name1\" :op2 \"name2\" :op3 \"name3\"", "\n", "", "", "", "for", "p", "in", "permutations", ":", "\n", "        ", "if", "')'", "not", "in", "p", "or", "'('", "not", "in", "p", ":", "\n", "            ", "if", "p", ".", "count", "(", "':'", ")", ">", "2", ":", "\n", "                ", "p_split", "=", "p", ".", "split", "(", "':'", ")", "[", "1", ":", "]", "\n", "new_perms", "=", "[", "':'", "+", "x", ".", "strip", "(", ")", "for", "x", "in", "p_split", "]", "\n", "return", "add_string", ",", "new_perms", "\n", "\n", "", "", "", "return", "add_string", ",", "permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_concepts": [[651, 662], ["var_free_amrs.process_var_line", "line.split", "var_dict[].split", "spl[].startswith"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line"], ["", "def", "get_concepts", "(", "line", ")", ":", "\n", "    ", "'''Function that returns AMR concepts while restoring for the paths method'''", "\n", "line", "=", "\" \"", ".", "join", "(", "line", ".", "split", "(", ")", ")", "\n", "_", ",", "var_dict", "=", "process_var_line", "(", "line", ",", "{", "}", ")", "\n", "\n", "for", "key", "in", "var_dict", ":", "\n", "        ", "spl", "=", "var_dict", "[", "key", "]", ".", "split", "(", ")", "\n", "if", "spl", "[", "-", "1", "]", ".", "startswith", "(", "':'", ")", ":", "\n", "# Solve problems with everything being in one line, e.g. change concept :ARG1 to just concept", "\n", "            ", "var_dict", "[", "key", "]", "=", "\" \"", ".", "join", "(", "spl", "[", "0", ":", "-", "1", "]", ")", "\n", "", "", "return", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.restore_rewrites": [[664, 672], ["re.sub.replace().replace().replace", "re.sub.replace", "re.sub", "re.sub.split", "re.sub.replace().replace", "re.sub.replace"], "function", ["None"], ["", "def", "restore_rewrites", "(", "line", ")", ":", "\n", "    ", "'''Restore rewrites we did for wiki - , polarity - and polite +'''", "\n", "line", "=", "\" \"", ".", "join", "(", "line", ".", "split", "(", ")", ")", "\n", "line", "=", "line", ".", "replace", "(", "':polarity 100'", ",", "':polarity -'", ")", ".", "replace", "(", "':wiki \"100\"'", ",", "':wiki -'", ")", ".", "replace", "(", "\":polite 100\"", ",", "\":polite +\"", ")", "\n", "line", "=", "line", ".", "replace", "(", "'http ://'", ",", "'http://'", ")", "\n", "# Fix problem with clocktimes: e.g. \" 07 :00\" becomes \"07:00\"", "\n", "line", "=", "re", ".", "sub", "(", "r' ([\\d])+ :([\\d]+)'", ",", "r'\\1:\\2'", ",", "line", ")", "\n", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.possible_path": [[673, 685], ["range", "len", "restore_amr.get_permutations_by_string", "restore_amr.matching_perm"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_permutations_by_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.matching_perm"], ["", "def", "possible_path", "(", "args", ",", "nums", ",", "search_part", ")", ":", "\n", "    ", "'''Function that returns whether it is possible to follow the path to a referent'''", "\n", "path_found", "=", "True", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "args", ")", ")", ":", "\n", "        ", "_", ",", "permutations", "=", "get_permutations_by_string", "(", "search_part", ",", "idx", ")", "\n", "# Check if the output path matches with a path in the AMR", "\n", "search_part", "=", "matching_perm", "(", "permutations", ",", "args", "[", "idx", "]", ",", "nums", "[", "idx", "]", ")", "\n", "if", "not", "search_part", ":", "\n", "# Did not find a correct path", "\n", "            ", "path_found", "=", "False", "\n", "break", "\n", "", "", "return", "path_found", ",", "search_part", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.matching_perm": [[687, 697], ["p.split"], "function", ["None"], ["", "def", "matching_perm", "(", "permutations", ",", "rel", ",", "count", ")", ":", "\n", "    ", "'''Check if the current path value matches a possible path in the AMR'''", "\n", "num_matches", ",", "matching_perm", "=", "0", ",", "''", "\n", "for", "p", "in", "permutations", ":", "\n", "        ", "rel_p", "=", "p", ".", "split", "(", ")", "[", "0", "]", "\n", "if", "rel_p", "==", "rel", ":", "\n", "            ", "num_matches", "+=", "1", "\n", "if", "num_matches", "==", "count", ":", "\n", "                ", "matching_perm", "=", "p", "\n", "", "", "", "return", "matching_perm", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.get_reference": [[699, 707], ["search_part.split", "enumerate", "ref_var.replace"], "function", ["None"], ["", "def", "get_reference", "(", "search_part", ")", ":", "\n", "    ", "'''Get the correct reference'''", "\n", "spl_line", "=", "search_part", ".", "split", "(", ")", "\n", "for", "idx", ",", "part", "in", "enumerate", "(", "spl_line", ")", ":", "\n", "        ", "if", "part", "==", "'/'", ":", "\n", "            ", "ref_var", "=", "spl_line", "[", "idx", "-", "1", "]", "\n", "break", "\n", "", "", "return", "ref_var", ".", "replace", "(", "'('", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.most_frequent_var": [[709, 723], ["random.choice", "list", "concept_dict.keys"], "function", ["None"], ["", "def", "most_frequent_var", "(", "concept_dict", ",", "ref_dict", ")", ":", "\n", "    ", "'''Get the variable in AMR that is most frequent in training set, based on dictionary of concepts'''", "\n", "most_freq", ",", "score", "=", "''", ",", "-", "1", "\n", "for", "item", "in", "concept_dict", ":", "\n", "        ", "if", "concept_dict", "[", "item", "]", "in", "ref_dict", ":", "\n", "            ", "if", "ref_dict", "[", "concept_dict", "[", "item", "]", "]", ">", "score", ":", "\n", "                ", "score", "=", "ref_dict", "[", "concept_dict", "[", "item", "]", "]", "\n", "most_freq", "=", "item", "\n", "\n", "", "", "", "if", "score", "==", "-", "1", ":", "\n", "# No best score found, just return random", "\n", "        ", "return", "random", ".", "choice", "(", "list", "(", "concept_dict", ".", "keys", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "most_freq", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.restore_amr.print_coref_stats": [[725, 748], ["print", "print", "range", "print", "print", "print", "print", "print", "print", "len", "len", "len", "len", "len", "len", "x.split", "x.split", "x.split"], "function", ["None"], ["", "", "def", "print_coref_stats", "(", "coreference", ",", "replace_types", ",", "index_dict", ")", ":", "\n", "    ", "'''Print some statistics of how we handled coreference (for indexing and absolute method)'''", "\n", "if", "coreference", "==", "'index'", ":", "\n", "        ", "print", "(", "'Results for types of replacements:\\n'", ")", "\n", "for", "key", "in", "replace_types", ":", "\n", "            ", "print", "(", "'{0}: {1}'", ".", "format", "(", "key", ",", "index_dict", "[", "key", "]", ")", ")", "\n", "", "", "elif", "coreference", "==", "'abs'", ":", "\n", "        ", "for", "idx", "in", "range", "(", "1", ",", "4", ")", ":", "\n", "            ", "for", "key", "in", "replace_types", ":", "\n", "# Only get paths of certain length", "\n", "                ", "cur_paths", "=", "[", "x", "for", "x", "in", "index_dict", "[", "key", "]", "if", "(", "len", "(", "x", ".", "split", "(", ")", ")", "/", "2", ")", "==", "idx", "]", "\n", "print", "(", "key", ")", "\n", "print", "(", "'Len cur_paths: {0} for idx {1}\\n'", ".", "format", "(", "len", "(", "cur_paths", ")", ",", "idx", ")", ")", "\n", "# All paths", "\n", "", "", "for", "key", "in", "replace_types", ":", "\n", "            ", "cur_paths", "=", "[", "x", "for", "x", "in", "index_dict", "[", "key", "]", "if", "(", "len", "(", "x", ".", "split", "(", ")", ")", "/", "2", ")", ">", "0", "]", "\n", "print", "(", "key", ")", "\n", "print", "(", "'Len cur_paths: {0} for idx {1}\\n'", ".", "format", "(", "len", "(", "cur_paths", ")", ",", "0", ")", ")", "\n", "# All longer paths", "\n", "", "for", "key", "in", "replace_types", ":", "\n", "            ", "cur_paths", "=", "[", "x", "for", "x", "in", "index_dict", "[", "key", "]", "if", "(", "len", "(", "x", ".", "split", "(", ")", ")", "/", "2", ")", ">", "3", "]", "\n", "print", "(", "key", ")", "\n", "print", "(", "'Len cur_paths: {0} for idx {1}\\n'", ".", "format", "(", "len", "(", "cur_paths", ")", ",", "'>3'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.create_args_parser": [[26, 36], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_args_parser", "(", ")", ":", "\n", "    ", "'''Creating arg parser'''", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"AMR file or folder\"", ")", "\n", "parser", ".", "add_argument", "(", "'-fol'", ",", "\"--folder\"", ",", "action", "=", "'store_true'", ",", "help", "=", "'Add to do multiple files in a folder - if not, args.f is a file'", ")", "\n", "parser", ".", "add_argument", "(", "'-a'", ",", "\"--amr_ext\"", ",", "default", "=", "'.txt'", ",", "type", "=", "str", ",", "help", "=", "\"Input files must have this extension (default .txt, only necesary when using -fol)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--output_ext'", ",", "default", "=", "'.tf'", ",", "help", "=", "\"extension of output AMR files (default .tf)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-k'", ",", "'--keep_wiki'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Keep Wiki link when processing'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert": [[38, 64], ["all_amrs.append", "os.path.isfile", "all_amrs.append", "line.strip", "cur_amr_line.strip", "line.startswith", "line.startswith", "re.sub().strip", "sents.append", "x.strip", "len", "len", "len", "len", "line.startswith", "cur_amr.append", "open", "re.sub", "line.strip"], "function", ["None"], ["", "def", "single_line_convert", "(", "lines", ",", "sent_file", ")", ":", "\n", "    ", "'''Convert AMRs to a single line, ignoring lines that start with \"# ::\"\n      If a sentence file is specified we also try to get the sentences'''", "\n", "all_amrs", ",", "cur_amr", ",", "sents", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "line", "in", "lines", ":", "\n", "        ", "if", "not", "line", ".", "strip", "(", ")", "and", "cur_amr", ":", "\n", "            ", "cur_amr_line", "=", "\" \"", ".", "join", "(", "cur_amr", ")", "\n", "all_amrs", ".", "append", "(", "cur_amr_line", ".", "strip", "(", ")", ")", "\n", "cur_amr", "=", "[", "]", "\n", "", "elif", "line", ".", "startswith", "(", "'# ::snt'", ")", "or", "line", ".", "startswith", "(", "'# ::tok'", ")", ":", "\n", "# Save sentences as well (don't always need them)", "\n", "            ", "sent", "=", "re", ".", "sub", "(", "'(^# ::(tok|snt))'", ",", "''", ",", "line", ")", ".", "strip", "(", ")", "#remove # ::snt or # ::tok", "\n", "sents", ".", "append", "(", "sent", ")", "\n", "", "elif", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "            ", "cur_amr", ".", "append", "(", "line", ".", "strip", "(", ")", ")", "\n", "# File did not end with newline, so add AMR here", "\n", "", "", "if", "cur_amr", ":", "\n", "        ", "all_amrs", ".", "append", "(", "\" \"", ".", "join", "(", "cur_amr", ")", ".", "strip", "(", ")", ")", "\n", "\n", "# If we didn't find sentences, but we did have a sentence file, read the sentences from there (if possible)", "\n", "", "if", "not", "sents", "and", "sent_file", ":", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "sent_file", ")", ":", "\n", "            ", "sents", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "open", "(", "sent_file", ",", "'r'", ")", "]", "\n", "# Sanity check", "\n", "assert", "len", "(", "all_amrs", ")", "==", "len", "(", "sents", ")", ",", "\"{0} vs {1}\"", ".", "format", "(", "len", "(", "all_amrs", ")", ",", "len", "(", "sents", ")", ")", "\n", "", "", "return", "all_amrs", ",", "sents", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki": [[66, 75], ["open", "re.sub", "re.sub", "no_wiki.append", "re.sub.split", "len", "len", "re.sub.lstrip"], "function", ["None"], ["", "def", "delete_wiki", "(", "input_file", ")", ":", "\n", "    ", "'''Delete wiki links from AMRs'''", "\n", "no_wiki", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "input_file", ",", "'r'", ")", ":", "\n", "        ", "n_line", "=", "re", ".", "sub", "(", "r':wiki \"(.*?)\"'", ",", "''", ",", "line", ",", "1", ")", "\n", "n_line", "=", "re", ".", "sub", "(", "':wiki -'", ",", "''", ",", "n_line", ")", "\n", "# Merge double whitespace but keep leading whitespace", "\n", "no_wiki", ".", "append", "(", "(", "len", "(", "n_line", ")", "-", "len", "(", "n_line", ".", "lstrip", "(", ")", ")", ")", "*", "' '", "+", "' '", ".", "join", "(", "n_line", ".", "split", "(", ")", ")", ")", "\n", "", "return", "no_wiki", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line": [[77, 125], ["amr_utils.remove_char_outside_quotes", "re.sub().replace", "var_name.strip", "re.sub", "amr_utils.remove_char_outside_quotes", "[].startswith", "var_value.strip", "var_name.strip", "amr_utils.remove_char_outside_quotes.split", "amr_utils.remove_char_outside_quotes.split"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes"], ["", "def", "process_var_line", "(", "line", ",", "var_dict", ")", ":", "\n", "    ", "'''Function that processes line with a variable in it. Returns the string without\n       variables and the dictionary with var-name + var - value\n       Only works if AMR is shown as multiple lines and input correctly!'''", "\n", "curr_var_name", "=", "False", "\n", "curr_var_value", "=", "False", "\n", "var_value", "=", "''", "\n", "var_name", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "# We start adding the variable value", "\n", "        ", "if", "ch", "==", "'/'", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_value", "=", "True", "\n", "curr_var_name", "=", "False", "\n", "var_value", "=", "''", "\n", "continue", "\n", "# We start adding the variable name", "\n", "", "elif", "ch", "==", "'('", "and", "not", "current_quotes", ":", "\n", "            ", "curr_var_name", "=", "True", "\n", "curr_var_value", "=", "False", "\n", "# We already found a name-value pair, add it now", "\n", "if", "var_value", "and", "var_name", ":", "\n", "# Remove closing brackets that were not in between quotes", "\n", "                ", "add_value", "=", "remove_char_outside_quotes", "(", "var_value", ".", "strip", "(", ")", ",", "')'", ")", "\n", "# Now we have to check: if this previous item starts with ':', we remove it,", "\n", "# because that means it started a new part ( :name (n / name ..)", "\n", "if", "add_value", ".", "split", "(", ")", "[", "-", "1", "]", ".", "startswith", "(", "':'", ")", ":", "\n", "                    ", "add_value", "=", "\" \"", ".", "join", "(", "add_value", ".", "split", "(", ")", "[", ":", "-", "1", "]", ")", "\n", "", "var_dict", "[", "var_name", ".", "strip", "(", ")", "]", "=", "add_value", "\n", "", "var_name", "=", "''", "\n", "continue", "\n", "# Check if we are currently within quotes", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "\n", "# Add to variable name/value", "\n", "", "if", "curr_var_name", ":", "\n", "            ", "var_name", "+=", "ch", "\n", "", "if", "curr_var_value", ":", "\n", "            ", "var_value", "+=", "ch", "\n", "\n", "# Remove brackets that were not within quotes for final var value", "\n", "", "", "final_var", "=", "remove_char_outside_quotes", "(", "var_value", ",", "')'", ")", "\n", "# Save information to dictionary", "\n", "var_dict", "[", "var_name", ".", "strip", "(", ")", "]", "=", "final_var", "\n", "# Remove variable information from the AMR line", "\n", "deleted_var_string", "=", "re", ".", "sub", "(", "r'\\([a-zA-Z-_0-9]+[\\d]? /'", ",", "'('", ",", "line", ")", ".", "replace", "(", "'( '", ",", "'('", ")", "\n", "return", "deleted_var_string", ",", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_amr_variables": [[127, 164], ["var_free_amrs.process_var_line", "line.strip", "del_amr.append", "var_free_amrs.process_var_line", "del_amr.append", "line.split", "split_line[].replace", "split_line[].replace", "del_amr.append", "del_amr.append", "ref_value.strip", "len", "len", "line.lstrip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.process_var_line"], ["", "def", "delete_amr_variables", "(", "amrs", ")", ":", "\n", "    ", "'''Function that deletes variables from AMRs'''", "\n", "full_var_dict", "=", "{", "}", "\n", "del_amr", "=", "[", "]", "\n", "\n", "# First get the var dict", "\n", "for", "line", "in", "amrs", ":", "\n", "        ", "_", ",", "full_var_dict", "=", "process_var_line", "(", "line", ",", "full_var_dict", ")", "\n", "\n", "# Loop over AMRs to rewrite", "\n", "", "for", "line", "in", "amrs", ":", "\n", "        ", "if", "line", ".", "strip", "(", ")", "and", "line", "[", "0", "]", "!=", "'#'", ":", "\n", "            ", "if", "'/'", "in", "line", ":", "\n", "# Found variable here", "\n", "# Get the deleted variable string and save", "\n", "                ", "deleted_var_string", ",", "_", "=", "process_var_line", "(", "line", ",", "full_var_dict", ")", "\n", "del_amr", ".", "append", "(", "deleted_var_string", ")", "\n", "", "else", ":", "\n", "# Probable reference to variable here!", "\n", "                ", "split_line", "=", "line", ".", "split", "(", ")", "\n", "ref_var", "=", "split_line", "[", "1", "]", ".", "replace", "(", "')'", ",", "''", ")", "\n", "\n", "# Check if the variable occurs in our dictionary", "\n", "if", "ref_var", "in", "full_var_dict", ":", "\n", "# Get value to replace the variable name with", "\n", "                    ", "ref_value", "=", "full_var_dict", "[", "ref_var", "]", "\n", "# Do the replacing and add brackets for alignment", "\n", "split_line", "[", "1", "]", "=", "split_line", "[", "1", "]", ".", "replace", "(", "ref_var", ",", "'('", "+", "ref_value", ".", "strip", "(", ")", "+", "')'", ")", "\n", "n_line", "=", "(", "len", "(", "line", ")", "-", "len", "(", "line", ".", "lstrip", "(", ")", ")", ")", "*", "' '", "+", "\" \"", ".", "join", "(", "split_line", ")", "\n", "del_amr", ".", "append", "(", "n_line", ")", "\n", "", "else", ":", "\n", "# No reference found, add line without editing (usually there are numbers in this line)", "\n", "                    ", "del_amr", ".", "append", "(", "line", ")", "\n", "", "", "", "else", ":", "\n", "# Line with other info, just add", "\n", "            ", "del_amr", ".", "append", "(", "line", ")", "\n", "", "", "return", "del_amr", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.var_free_amrs": [[166, 175], ["var_free_amrs.delete_amr_variables", "var_free_amrs.single_line_convert", "amr_utils.write_to_file", "var_free_amrs.delete_wiki", "x.rstrip", "open"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_amr_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki"], ["", "def", "var_free_amrs", "(", "input_file", ",", "out_ext", ",", "keep_wiki", ")", ":", "\n", "    ", "'''Create variable-free AMRs and sentence files'''", "\n", "# Delete wiki link if wanted", "\n", "amr_no_wiki", "=", "delete_wiki", "(", "input_file", ")", "if", "not", "keep_wiki", "else", "[", "x", ".", "rstrip", "(", ")", "for", "x", "in", "open", "(", "input_file", ",", "'r'", ")", "]", "\n", "# Remove all variables by duplicating coreference nodes", "\n", "del_amrs", "=", "delete_amr_variables", "(", "amr_no_wiki", ")", "\n", "# Put AMR on single line and write output", "\n", "single_amrs", ",", "_", "=", "single_line_convert", "(", "del_amrs", ",", "''", ")", "\n", "write_to_file", "(", "single_amrs", ",", "input_file", "+", "out_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_arg_parser": [[38, 46], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "create_arg_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--input_file\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"folder that contains to be processed files\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-a\"", ",", "\"--amr_ext\"", ",", "default", "=", "'.txt'", ",", "type", "=", "str", ",", "help", "=", "\"AMR extension (default .txt) - should have alignments\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--cut_off\"", ",", "default", "=", "15", ",", "type", "=", "int", ",", "help", "=", "\"When to cut-off number of permutations\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "\"--double\"", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Add best permutation AMR AND normal AMR\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_tokenized_sentences": [[48, 52], ["l.replace().replace().strip", "open", "l.replace().replace", "l.startswith", "l.startswith", "l.replace"], "function", ["None"], ["", "def", "get_tokenized_sentences", "(", "f", ")", ":", "\n", "    ", "'''Get sentences from AMR file'''", "\n", "sents", "=", "[", "l", ".", "replace", "(", "'# ::snt'", ",", "''", ")", ".", "replace", "(", "'# ::tok'", ",", "''", ")", ".", "strip", "(", ")", "for", "l", "in", "open", "(", "f", ",", "'r'", ")", "if", "l", ".", "startswith", "(", "'# ::snt'", ")", "or", "l", ".", "startswith", "(", "'# ::tok'", ")", "]", "\n", "return", "sents", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment": [[54, 58], ["re.sub"], "function", ["None"], ["", "def", "remove_alignment", "(", "string", ")", ":", "\n", "    ", "'''Function that removes alignment information from AMR'''", "\n", "string", "=", "re", ".", "sub", "(", "r'~e\\.[\\d,]+'", ",", "''", ",", "string", ")", "\n", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_word_and_sense": [[60, 109], ["enumerate", "best_amr_permutation.get_sense", "comb.append", "line.split", "print", "int", "len", "comb[].append", "s.isdigit"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense"], ["", "def", "get_word_and_sense", "(", "line", ")", ":", "\n", "    ", "'''Character based extraction because I couldn't figure it out using regex'''", "\n", "quotes", "=", "0", "\n", "adding", "=", "False", "\n", "comb", "=", "[", "]", "\n", "word", "=", "''", "\n", "if", "'\"'", "in", "line", ":", "\n", "        ", "for", "idx", ",", "ch", "in", "enumerate", "(", "line", ")", ":", "\n", "            ", "if", "ch", "==", "'\"'", ":", "\n", "                ", "quotes", "+=", "1", "\n", "if", "quotes", "%", "2", "!=", "0", ":", "\n", "                    ", "adding", "=", "True", "\n", "", "else", ":", "\n", "# Finished quotations", "\n", "                    ", "comb", ".", "append", "(", "[", "word", "]", ")", "\n", "word", "=", "''", "\n", "adding", "=", "False", "\n", "", "", "elif", "ch", "==", "'~'", ":", "\n", "                ", "if", "adding", ":", "\n", "                    ", "word", "+=", "ch", "\n", "", "elif", "':op'", "in", "\"\"", ".", "join", "(", "line", "[", "idx", "-", "4", ":", "idx", "-", "1", "]", ")", ":", "\n", "# Bugfix for strange constructions, e.g. name :op1~e.4 \"Algeria\"~e.2", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "if", "idx", "+", "4", "<", "len", "(", "line", ")", ":", "\n", "                        ", "sense_line", "=", "line", "[", "idx", "+", "1", "]", "+", "line", "[", "idx", "+", "2", "]", "+", "line", "[", "idx", "+", "3", "]", "+", "line", "[", "idx", "+", "4", "]", "\n", "", "else", ":", "\n", "                        ", "sense_line", "=", "line", "[", "idx", "+", "1", "]", "+", "line", "[", "idx", "+", "2", "]", "+", "line", "[", "idx", "+", "3", "]", "\n", "", "sense", "=", "int", "(", "\"\"", ".", "join", "(", "[", "s", "for", "s", "in", "sense_line", "if", "s", ".", "isdigit", "(", ")", "]", ")", ")", "\n", "try", ":", "\n", "                        ", "comb", "[", "-", "1", "]", ".", "append", "(", "sense", ")", "\n", "", "except", ":", "\n", "                        ", "pass", "\n", "", "", "", "else", ":", "\n", "                ", "if", "adding", ":", "\n", "                    ", "word", "+=", "ch", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "", "", "", "", "elif", "':op'", "not", "in", "line", ":", "\n", "        ", "return", "[", "[", "''", ",", "''", "]", "]", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "tmp", "=", "line", ".", "split", "(", ")", "[", "2", "]", "\n", "sense", ",", "word", "=", "get_sense", "(", "tmp", ")", "\n", "comb", "=", "[", "[", "word", ",", "sense", "]", "]", "\n", "", "except", ":", "\n", "            ", "print", "(", "'Strange occurrence in AMR, ignore'", ")", "\n", "return", "[", "[", "''", ",", "''", "]", "]", "\n", "", "", "return", "comb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense": [[111, 128], ["[].split", "round", "int", "word.split", "float", "float", "word.split", "sum", "len", "int.split", "int", "int.split"], "function", ["None"], ["", "def", "get_sense", "(", "word", ")", ":", "\n", "    ", "'''Function that gets the sense of a certain word in aligned AMR'''", "\n", "if", "'~'", "in", "word", ":", "\n", "# Extract 16 in e.g. house~e.16", "\n", "        ", "sense", "=", "word", ".", "split", "(", "'~'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "if", "','", "in", "sense", ":", "\n", "# Some amr-words refer to multiple tokens. If that's the case, we take the average for calculating distance", "\n", "# Although this means that the actual sense does not refer to the tokens anymore", "\n", "# e.g. the sense of house~e.4,12 becomes 8", "\n", "            ", "sense", "=", "round", "(", "(", "float", "(", "sum", "(", "[", "int", "(", "i", ")", "for", "i", "in", "sense", ".", "split", "(", "','", ")", "]", ")", ")", ")", "/", "(", "float", "(", "len", "(", "sense", ".", "split", "(", "','", ")", ")", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "sense", "=", "int", "(", "sense", ")", "\n", "# Remove sense information to process rest of the word", "\n", "", "word", "=", "word", ".", "split", "(", "'~'", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "sense", "=", "''", "\n", "", "return", "sense", ",", "word", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.find_words": [[130, 161], ["line.split", "enumerate", "range", "best_amr_permutation.get_sense", "len", "len", "comb[].append", "line.count", "len", "[].replace", "line.split", "line.split", "best_amr_permutation.get_word_and_sense", "best_amr_permutation.get_sense", "sum", "comb.append", "spl_line[].split", "spl_line[].strip().split", "c.isdigit", "[].replace.count", "[].replace.split", "spl_line[].strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_word_and_sense", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_sense"], ["", "def", "find_words", "(", "line", ")", ":", "\n", "    ", "'''Finds all words in the AMR structure'''", "\n", "comb", "=", "[", "]", "\n", "spl_line", "=", "line", ".", "split", "(", "'('", ")", "\n", "if", "'('", "not", "in", "line", ":", "\n", "        ", "if", "line", ".", "count", "(", "'~'", ")", ">", "0", "and", "len", "(", "line", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "            ", "sense", ",", "word", "=", "get_sense", "(", "line", ".", "split", "(", ")", "[", "1", "]", ")", "\n", "return", "[", "[", "word", ",", "sense", "]", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "[", "'none-found'", ",", "0", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "spl_line", ")", ")", ":", "\n", "            ", "if", "spl_line", "[", "idx", "]", ":", "\n", "                ", "word", "=", "spl_line", "[", "idx", "]", ".", "strip", "(", ")", ".", "split", "(", ")", "[", "0", "]", ".", "replace", "(", "')'", ",", "''", ")", "\n", "# Name gets special treatment by AMRs", "\n", "if", "word", "==", "'name'", ":", "\n", "                    ", "cut_word", "=", "spl_line", "[", "idx", "]", ".", "split", "(", "')'", ")", "[", "0", "]", "\n", "comb", "+=", "get_word_and_sense", "(", "cut_word", ")", "\n", "", "else", ":", "\n", "                    ", "sense", ",", "word", "=", "get_sense", "(", "word", ")", "\n", "num_digits", "=", "sum", "(", "c", ".", "isdigit", "(", ")", "for", "c", "in", "word", ")", "\n", "# Tricky: we want to change break-01 to break, but do not want to screw up dates (08-09-2016 or 28-10)", "\n", "if", "word", ".", "count", "(", "'-'", ")", "==", "1", "and", "num_digits", "<", "3", "and", "num_digits", ">", "0", ":", "\n", "                        ", "word", "=", "word", ".", "split", "(", "'-'", ")", "[", "0", "]", "\n", "", "comb", ".", "append", "(", "[", "word", ",", "sense", "]", ")", "\n", "\n", "# Add empty sense if needed", "\n", "", "", "", "", "for", "idx", ",", "value", "in", "enumerate", "(", "comb", ")", ":", "\n", "        ", "if", "len", "(", "value", ")", "<", "2", ":", "\n", "            ", "comb", "[", "idx", "]", ".", "append", "(", "''", ")", "\n", "", "", "return", "comb", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.matching_words": [[163, 171], ["best_amr_permutation.find_words", "all_found.append", "best_amr_permutation.find_words"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.find_words", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.find_words"], ["", "def", "matching_words", "(", "permutations", ")", ":", "\n", "    ", "'''Finds all words in different order for all the permutations'''", "\n", "all_found", "=", "[", "]", "\n", "for", "per", "in", "permutations", ":", "\n", "        ", "found_words", "=", "find_words", "(", "per", ")", "\n", "if", "found_words", ":", "\n", "            ", "all_found", ".", "append", "(", "find_words", "(", "per", ")", ")", "\n", "", "", "return", "all_found", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.calc_distance": [[173, 186], ["min", "enumerate", "int", "abs", "len"], "function", ["None"], ["", "def", "calc_distance", "(", "l", ")", ":", "\n", "    ", "'''Calculates distance between list items in two lists'''", "\n", "# l needs to start from zero, get lowest number and substract it from all numbers", "\n", "min_l", "=", "min", "(", "[", "int", "(", "x", "[", "1", "]", ")", "for", "x", "in", "l", "if", "x", "[", "1", "]", "!=", "''", "]", ")", "\n", "l", "=", "[", "[", "x", "[", "0", "]", ",", "(", "x", "[", "1", "]", "-", "min_l", ")", "]", "for", "x", "in", "l", "if", "x", "[", "1", "]", "!=", "''", "]", "\n", "distance", "=", "0", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "l", ")", ":", "\n", "# Check if we found a sense", "\n", "        ", "if", "len", "(", "item", ")", ">", "1", "and", "item", "[", "1", "]", "!=", "''", ":", "\n", "# Check how far away we are in our token list", "\n", "            ", "diff", "=", "abs", "(", "item", "[", "1", "]", "-", "idx", ")", "\n", "distance", "+=", "diff", "\n", "", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_swap": [[188, 193], ["best_amr_permutation.calc_distance", "best_amr_permutation.calc_distance"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.calc_distance", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.calc_distance"], ["", "def", "do_swap", "(", "w_list1", ",", "w_list2", ")", ":", "\n", "    ", "'''Checks if we should swap two list items'''", "\n", "distance_now", "=", "calc_distance", "(", "w_list1", "+", "w_list2", ")", "\n", "distance_swap", "=", "calc_distance", "(", "w_list2", "+", "w_list1", ")", "\n", "return", "distance_now", ">", "distance_swap", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.filter_colons": [[195, 208], ["part.split", "range", "len", "new_parts.append", "[].isalpha", "new_parts.append"], "function", ["None"], ["", "def", "filter_colons", "(", "part", ")", ":", "\n", "    ", "'''Funtion to filter out timestamps (e.g. 08:30) and websites (e.g. http://site.com)'''", "\n", "new_parts", "=", "[", "]", "\n", "split_part", "=", "part", ".", "split", "(", "':'", ")", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "split_part", ")", ")", ":", "\n", "        ", "if", "idx", "==", "0", ":", "\n", "            ", "new_parts", ".", "append", "(", "split_part", "[", "idx", "]", ")", "\n", "", "elif", "split_part", "[", "idx", "]", "[", "0", "]", ".", "isalpha", "(", ")", ":", "\n", "            ", "new_parts", ".", "append", "(", "split_part", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "# Not actually a new part, just add to last one", "\n", "            ", "new_parts", "[", "-", "1", "]", "+=", "':'", "+", "split_part", "[", "idx", "]", "\n", "", "", "return", "new_parts", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.bracket_in_string": [[210, 220], ["None"], "function", ["None"], ["", "def", "bracket_in_string", "(", "line", ")", ":", "\n", "    ", "'''Check if there are no brackets in a string\n       NOTE: between quotes does not count'''", "\n", "between_quotes", "=", "False", "\n", "for", "char", "in", "line", ":", "\n", "        ", "if", "char", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "", "elif", "char", "in", "[", "'('", ",", "')'", "]", "and", "not", "between_quotes", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_add_string": [[222, 266], ["enumerate", "permutations.append", "enumerate", "var_free_amrs.remove_char_outside_quotes().strip", "best_amr_permutation.bracket_in_string", "permutations[].count", "permutations[].count", "p.count", "var_free_amrs.remove_char_outside_quotes", "p.split", "permutations.append", "x.strip", "add_string.strip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.bracket_in_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes"], ["", "def", "get_add_string", "(", "search_part", ")", ":", "\n", "    ", "'''Get the initial permutations and add_string'''", "\n", "paren_count", "=", "0", "\n", "start_adding", "=", "False", "\n", "permutations", "=", "[", "]", "\n", "add_string", "=", "''", "\n", "between_quotes", "=", "False", "\n", "\n", "for", "idx", ",", "ch", "in", "enumerate", "(", "search_part", ")", ":", "\n", "        ", "if", "ch", "==", "'('", "and", "not", "between_quotes", ":", "\n", "            ", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "paren_count", "+=", "1", "\n", "", "elif", "ch", "==", "':'", "and", "not", "between_quotes", ":", "\n", "            ", "start_adding", "=", "True", "\n", "add_string", "+=", "ch", "\n", "", "elif", "ch", "==", "')'", "and", "not", "between_quotes", ":", "\n", "            ", "paren_count", "-=", "1", "\n", "if", "start_adding", ":", "\n", "                ", "add_string", "+=", "ch", "\n", "", "if", "paren_count", "==", "0", ":", "\n", "                ", "permutations", ".", "append", "(", "add_string", ".", "strip", "(", ")", ")", "\n", "add_string", "=", "''", "\n", "", "", "elif", "start_adding", ":", "\n", "            ", "add_string", "+=", "ch", "\n", "# Keep track of quotes", "\n", "", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "\n", "# Fix parentheses", "\n", "", "", "if", "add_string", "and", "':'", "in", "add_string", ":", "\n", "        ", "permutations", ".", "append", "(", "remove_char_outside_quotes", "(", "add_string", ",", "')'", ")", ".", "strip", "(", ")", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "permutations", ")", ":", "\n", "            ", "while", "permutations", "[", "idx", "]", ".", "count", "(", "')'", ")", "<", "permutations", "[", "idx", "]", ".", "count", "(", "'('", ")", ":", "\n", "                ", "permutations", "[", "idx", "]", "+=", "')'", "\n", "\n", "# Permutate without brackets (e.g. :op1 \"name1\" :op2 \"name2\" :op3 \"name3\" etc", "\n", "", "", "", "for", "p", "in", "permutations", ":", "\n", "        ", "if", "not", "bracket_in_string", "(", "p", ")", ":", "\n", "            ", "if", "p", ".", "count", "(", "':'", ")", ">", "2", ":", "\n", "                ", "p_split", "=", "p", ".", "split", "(", "':'", ")", "[", "1", ":", "]", "\n", "new_perms", "=", "[", "':'", "+", "x", ".", "strip", "(", ")", "for", "x", "in", "p_split", "]", "\n", "return", "add_string", ",", "new_perms", "\n", "", "", "", "return", "add_string", ",", "permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_keep_string": [[268, 276], ["None"], "function", ["None"], ["", "def", "get_keep_string", "(", "new_parts", ",", "level", ")", ":", "\n", "    ", "'''Obtain string we keep, it differs for level 1'''", "\n", "if", "level", ">", "1", ":", "\n", "        ", "keep_string", "=", "':'", "+", "\":\"", ".", "join", "(", "new_parts", "[", ":", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "keep_string", "=", "\":\"", ".", "join", "(", "new_parts", "[", ":", "1", "]", ")", "\n", "", "search_part", "=", "':'", "+", "\":\"", ".", "join", "(", "new_parts", "[", "1", ":", "]", ")", "\n", "return", "keep_string", ",", "search_part", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.combine_permutations": [[278, 286], ["len", "random.shuffle"], "function", ["None"], ["", "def", "combine_permutations", "(", "permutations", ",", "cut_off", ")", ":", "\n", "    ", "'''Combine permutations if they exceed the cut-off specified'''", "\n", "if", "len", "(", "permutations", ")", ">", "cut_off", ":", "\n", "        ", "shuffle", "(", "permutations", ")", "\n", "# Add extra permutations to the last permutation", "\n", "# to avoid losing information", "\n", "permutations", "=", "permutations", "[", "0", ":", "cut_off", "-", "1", "]", "+", "[", "\" \"", ".", "join", "(", "permutations", "[", "cut_off", "-", "1", ":", "]", ")", "]", "\n", "", "return", "permutations", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.change_possible": [[288, 294], ["part.count"], "function", ["None"], ["", "def", "change_possible", "(", "part", ")", ":", "\n", "    ", "'''Check if there is anything to permute'''", "\n", "if", "':'", "not", "in", "part", "or", "(", "part", ".", "count", "(", "':'", ")", "==", "1", "and", "(", "'http:'", "in", "part", "or", "'https:'", "in", "part", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations": [[296, 350], ["best_amr_permutation.filter_colons", "best_amr_permutation.get_keep_string", "best_amr_permutation.get_add_string", "best_amr_permutation.combine_permutations", "best_amr_permutation.matching_words", "best_amr_permutation.change_possible", "all_perms.append", "len", "len", "print", "range", "len", "range", "permutations_set.append", "best_amr_permutation.do_swap", "all_perms.count", "permutations_set.append", "len"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.filter_colons", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_keep_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_add_string", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.combine_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.matching_words", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.change_possible", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_swap"], ["", "", "def", "get_permutations", "(", "part", ",", "level", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", ":", "\n", "    ", "'''Function that returns the permutations in the best order'''", "\n", "# Make life easier by skipping first '(' or ':'", "\n", "part", "=", "part", "[", "1", ":", "]", "\n", "\n", "# If there is nothing to change then we return", "\n", "if", "not", "change_possible", "(", "part", ")", ":", "\n", "        ", "if", "level", "==", "1", ":", "\n", "            ", "return", "[", "part", "]", ",", "''", ",", "all_perms", "\n", "", "else", ":", "\n", "            ", "return", "[", "':'", "+", "part", "]", ",", "''", ",", "all_perms", "\n", "\n", "# Remove non-arguments that have a colon such as timestamps and websites", "\n", "", "", "new_parts", "=", "filter_colons", "(", "part", ")", "\n", "# Find the part of the string we keep", "\n", "keep_string", ",", "search_part", "=", "get_keep_string", "(", "new_parts", ",", "level", ")", "\n", "# Get the initial permutations", "\n", "_", ",", "permutations", "=", "get_add_string", "(", "search_part", ")", "\n", "\n", "# Check the cut_off so that we don't do more permutations than we want", "\n", "permutations", "=", "combine_permutations", "(", "permutations", ",", "cut_off", ")", "\n", "# Find the list of lists that contain word-sense pairs", "\n", "word_list", "=", "matching_words", "(", "permutations", ")", "\n", "\n", "# Two possibilities here, ordering or pruning. This script only does ordering,", "\n", "# but prune_amrs.py does pruning and uses this function as well", "\n", "if", "type_script", "==", "'prune'", ":", "\n", "        ", "permutations_set", "=", "[", "]", "\n", "for", "p", "in", "permutations", ":", "\n", "# Remove all nodes with same parent", "\n", "            ", "if", "p", "in", "permutations_set", ":", "\n", "                ", "continue", "\n", "", "elif", "p", "not", "in", "all_perms", ":", "\n", "                ", "permutations_set", ".", "append", "(", "p", ")", "\n", "", "elif", "all_perms", ".", "count", "(", "p", ")", "<", "2", ":", "\n", "# If we saw the node twice, stop adding", "\n", "                ", "permutations_set", ".", "append", "(", "p", ")", "\n", "", "all_perms", ".", "append", "(", "p", ")", "\n", "", "return", "permutations_set", ",", "keep_string", ",", "all_perms", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "word_list", ")", "!=", "len", "(", "permutations", ")", ":", "\n", "# Something strange is going on here, just ignore it and do nothing to avoid errors", "\n", "            ", "print", "(", "'Strange AMR part'", ")", "\n", "all_perms", "+=", "permutations", "\n", "return", "permutations", ",", "keep_string", ",", "all_perms", "\n", "", "else", ":", "\n", "            ", "for", "p", "in", "range", "(", "len", "(", "permutations", ")", ")", ":", "\n", "                ", "for", "idx", "in", "range", "(", "len", "(", "permutations", ")", "-", "1", ")", ":", "\n", "# Permuting takes place here, check if swapping results in better order", "\n", "                    ", "if", "do_swap", "(", "word_list", "[", "idx", "]", ",", "word_list", "[", "idx", "+", "1", "]", ")", ":", "\n", "                        ", "permutations", "[", "idx", "]", ",", "permutations", "[", "idx", "+", "1", "]", "=", "permutations", "[", "idx", "+", "1", "]", ",", "permutations", "[", "idx", "]", "\n", "word_list", "[", "idx", "]", ",", "word_list", "[", "idx", "+", "1", "]", "=", "word_list", "[", "idx", "+", "1", "]", ",", "word_list", "[", "idx", "]", "\n", "", "", "", "all_perms", "+=", "permutations", "\n", "return", "permutations", ",", "keep_string", ",", "all_perms", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_string_adjustments": [[352, 361], ["add_string.count", "add_string.count"], "function", ["None"], ["", "", "", "def", "do_string_adjustments", "(", "permutations_new", ",", "keep_string2", ")", ":", "\n", "    ", "'''Make sure the string is correct'''", "\n", "add_string", "=", "keep_string2", "+", "' '", "+", "\" \"", ".", "join", "(", "permutations_new", ")", "+", "' '", "\n", "\n", "# Check if we need to add a parenthesis", "\n", "while", "add_string", ".", "count", "(", "')'", ")", "<", "add_string", ".", "count", "(", "'('", ")", ":", "\n", "# Avoid extra unnecessary space", "\n", "        ", "add_string", "+=", "')'", "\n", "", "return", "add_string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_final_line": [[363, 374], ["final_string.replace().strip", "best_amr_permutation.fix_paren", "best_amr_permutation.remove_alignment", "add_to.replace.replace().replace().replace", "add_to.replace.replace", "final_string.replace", "add_to.replace.replace().replace", "add_to.replace.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment"], ["", "def", "create_final_line", "(", "final_string", ")", ":", "\n", "    ", "'''Do final adjustments for line'''", "\n", "add_to", "=", "final_string", ".", "replace", "(", "'  '", ",", "' '", ")", ".", "strip", "(", ")", "\n", "while", "' )'", "in", "add_to", ":", "\n", "        ", "add_to", "=", "add_to", ".", "replace", "(", "' )'", ",", "')'", ")", "\n", "# Fix parentheses and remove alignment information", "\n", "", "add_to", "=", "fix_paren", "(", "add_to", ")", "\n", "add_to", "=", "remove_alignment", "(", "add_to", ")", "\n", "# Fix tokenization", "\n", "add_to", "=", "add_to", ".", "replace", "(", "'):'", ",", "') :'", ")", ".", "replace", "(", "' :)'", ",", "')'", ")", ".", "replace", "(", "': :'", ",", "':'", ")", "\n", "return", "add_to", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren": [[376, 381], ["string.count", "string.count"], "function", ["None"], ["", "def", "fix_paren", "(", "string", ")", ":", "\n", "    ", "'''Add parentheses when necessary'''", "\n", "while", "string", ".", "count", "(", "'('", ")", ">", "string", ".", "count", "(", "')'", ")", ":", "\n", "        ", "string", "+=", "')'", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_best_perm": [[383, 421], ["best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.fix_paren", "best_amr_permutation.get_permutations", "best_amr_permutation.do_string_adjustments", "do_string_adjustments.replace"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.fix_paren", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.do_string_adjustments"], ["", "def", "get_best_perm", "(", "permutations", ",", "final_string", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", ":", "\n", "    ", "'''This must also be possible recursive - I tried...\n       For each (sub)-AMR, get the best permutation based on input words'''", "\n", "for", "p2", "in", "permutations", ":", "\n", "        ", "permutations_2", ",", "keep_string2", ",", "all_perms", "=", "get_permutations", "(", "p2", ",", "2", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p3", "in", "permutations_2", ":", "\n", "            ", "permutations_3", ",", "keep_string3", ",", "all_perms", "=", "get_permutations", "(", "p3", ",", "3", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p4", "in", "permutations_3", ":", "\n", "                ", "permutations_4", ",", "keep_string4", ",", "all_perms", "=", "get_permutations", "(", "p4", ",", "4", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p5", "in", "permutations_4", ":", "\n", "                    ", "permutations_5", ",", "keep_string5", ",", "all_perms", "=", "get_permutations", "(", "p5", ",", "5", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p6", "in", "permutations_5", ":", "\n", "                        ", "permutations_6", ",", "keep_string6", ",", "all_perms", "=", "get_permutations", "(", "p6", ",", "6", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p7", "in", "permutations_6", ":", "\n", "                            ", "permutations_7", ",", "keep_string7", ",", "all_perms", "=", "get_permutations", "(", "p7", ",", "7", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p8", "in", "permutations_7", ":", "\n", "                                ", "permutations_8", ",", "keep_string8", ",", "all_perms", "=", "get_permutations", "(", "p8", ",", "8", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p9", "in", "permutations_8", ":", "\n", "                                    ", "permutations_9", ",", "keep_string9", ",", "all_perms", "=", "get_permutations", "(", "p9", ",", "9", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p10", "in", "permutations_9", ":", "\n", "                                        ", "permutations_10", ",", "keep_string10", ",", "all_perms", "=", "get_permutations", "(", "p10", ",", "10", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p11", "in", "permutations_10", ":", "\n", "                                            ", "permutations_11", ",", "keep_string11", ",", "all_perms", "=", "get_permutations", "(", "p11", ",", "11", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "for", "p12", "in", "permutations_11", ":", "\n", "                                                ", "permutations_12", ",", "keep_string12", ",", "all_perms", "=", "get_permutations", "(", "p12", ",", "12", ",", "all_perms", ",", "type_script", ",", "cut_off", ")", "\n", "add_string", "=", "do_string_adjustments", "(", "permutations_12", ",", "keep_string12", ")", "\n", "keep_string11", "+=", "add_string", ".", "replace", "(", "'  '", ",", "' '", ")", "\n", "", "keep_string10", "+=", "fix_paren", "(", "keep_string11", ")", "\n", "", "keep_string9", "+=", "fix_paren", "(", "keep_string10", ")", "\n", "", "keep_string8", "+=", "fix_paren", "(", "keep_string9", ")", "\n", "", "keep_string7", "+=", "fix_paren", "(", "keep_string8", ")", "\n", "", "keep_string6", "+=", "fix_paren", "(", "keep_string7", ")", "\n", "", "keep_string5", "+=", "fix_paren", "(", "keep_string6", ")", "\n", "", "keep_string4", "+=", "fix_paren", "(", "keep_string5", ")", "\n", "", "keep_string3", "+=", "fix_paren", "(", "keep_string4", ")", "\n", "", "keep_string2", "+=", "fix_paren", "(", "keep_string3", ")", "\n", "", "final_string", "+=", "fix_paren", "(", "keep_string2", ")", "\n", "", "return", "fix_paren", "(", "final_string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.process_file_best": [[423, 451], ["enumerate", "enumerate", "print", "len", "len", "amr.replace", "best_amr_permutation.remove_alignment", "len", "len", "amr.count", "best_amr_permutation.get_permutations", "best_amr_permutation.get_best_perm", "save_all_amrs.append", "save_all_amrs.append", "len", "best_amr_permutation.create_final_line", "best_amr_permutation.remove_alignment", "zip"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_permutations", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_best_perm", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_final_line", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.remove_alignment"], ["", "def", "process_file_best", "(", "amrs", ",", "sent_amrs", ",", "cut_off", ")", ":", "\n", "    ", "'''Permute AMR so that it best matches the word order'''", "\n", "save_all_amrs", "=", "[", "]", "\n", "\n", "# Sanity check", "\n", "assert", "len", "(", "amrs", ")", "==", "len", "(", "sent_amrs", ")", "\n", "\n", "# Loop over all AMRs and return best matching permutation", "\n", "for", "idx", ",", "amr", "in", "enumerate", "(", "amrs", ")", ":", "\n", "# Only try to do something if we can actually permute", "\n", "        ", "if", "amr", ".", "count", "(", "':'", ")", ">", "1", ":", "\n", "            ", "permutations", ",", "keep_string1", ",", "_", "=", "get_permutations", "(", "amr", ",", "1", ",", "[", "]", ",", "'order'", ",", "cut_off", ")", "\n", "final_string", "=", "get_best_perm", "(", "permutations", ",", "'('", "+", "keep_string1", ",", "[", "]", ",", "'order'", ",", "cut_off", ")", "\n", "# Save final output string", "\n", "save_all_amrs", ".", "append", "(", "create_final_line", "(", "final_string", ")", ")", "\n", "", "else", ":", "\n", "# Just save AMR if there's nothing to do", "\n", "            ", "save_all_amrs", ".", "append", "(", "remove_alignment", "(", "amr", ")", ")", "\n", "\n", "# Fix tokenization and remove alignment", "\n", "", "", "for", "idx", ",", "amr", "in", "enumerate", "(", "amrs", ")", ":", "\n", "        ", "amrs", "[", "idx", "]", "=", "amr", ".", "replace", "(", "' )'", ",", "')'", ")", "\n", "amrs", "[", "idx", "]", "=", "remove_alignment", "(", "amr", ")", "\n", "\n", "# Print how many AMRs we actually changed by doing this", "\n", "", "changed_amrs", "=", "len", "(", "amrs", ")", "-", "len", "(", "[", "i", "for", "i", ",", "j", "in", "zip", "(", "amrs", ",", "save_all_amrs", ")", "if", "i", "==", "j", "]", ")", "\n", "print", "(", "'Changed {0} out of {1} amrs'", ".", "format", "(", "changed_amrs", ",", "len", "(", "amrs", ")", ")", ")", "\n", "return", "save_all_amrs", ",", "amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.preprocess": [[453, 462], ["var_free_amrs.delete_wiki", "var_free_amrs.delete_amr_variables", "var_free_amrs.single_line_convert"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_wiki", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.delete_amr_variables", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.var_free_amrs.single_line_convert"], ["", "def", "preprocess", "(", "f_path", ")", ":", "\n", "    ", "'''Preprocess the AMR file, deleting variables/wiki-links and tokenizing'''", "\n", "# Delete Wiki links from AMRs", "\n", "no_wiki_amrs", "=", "delete_wiki", "(", "f_path", ")", "\n", "# Remove variables from AMR", "\n", "del_amrs", "=", "delete_amr_variables", "(", "no_wiki_amrs", ")", "\n", "# Old amrs with deleted wiki and variables", "\n", "old_amrs", ",", "sent_amrs", "=", "single_line_convert", "(", "del_amrs", ",", "''", ")", "\n", "return", "sent_amrs", ",", "old_amrs", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.create_output": [[464, 474], ["best_amr_permutation.get_filenames", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file", "amr_utils.write_to_file"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_filenames", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file"], ["", "def", "create_output", "(", "input_file", ",", "old_amrs", ",", "new_amrs", ",", "sent_amrs", ",", "double", ",", "amr_ext", ")", ":", "\n", "    ", "'''Print output to the correct files - also keep no-var AMR'''", "\n", "permuted_amr", ",", "no_var_amr", ",", "sent_file", ",", "double_sent_file", ",", "double_amr_file", "=", "get_filenames", "(", "input_file", ",", "amr_ext", ")", "\n", "write_to_file", "(", "old_amrs", ",", "no_var_amr", ")", "\n", "write_to_file", "(", "new_amrs", ",", "permuted_amr", ")", "\n", "write_to_file", "(", "sent_amrs", ",", "sent_file", ")", "\n", "# Potentially we want to keep BOTH the original AMR and the best-permuted AMR", "\n", "if", "double", ":", "\n", "        ", "write_to_file", "(", "old_amrs", "+", "new_amrs", ",", "double_amr_file", ")", "\n", "write_to_file", "(", "sent_amrs", "+", "sent_amrs", ",", "double_sent_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.best_amr_permutation.get_filenames": [[476, 484], ["input_file.replace", "input_file.replace", "input_file.replace", "input_file.replace", "input_file.replace"], "function", ["None"], ["", "", "def", "get_filenames", "(", "input_file", ",", "amr_ext", ")", ":", "\n", "    ", "'''Return list of filenames for output of this script'''", "\n", "permuted_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf.best'", ")", "\n", "no_var_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf'", ")", "\n", "sent_file", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.sent'", ")", "\n", "double_sent", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.sent.double'", ")", "\n", "double_amr", "=", "input_file", ".", "replace", "(", "amr_ext", ",", "'.tf.double'", ")", "\n", "return", "permuted_amr", ",", "no_var_amr", ",", "sent_file", ",", "double_sent", ",", "double_amr", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__init__": [[210, 242], ["len"], "methods", ["None"], ["\n", "\n", "from", "collections", "import", "defaultdict", "\n", "import", "sys", "\n", "\n", "# change this if needed", "\n", "ERROR_LOG", "=", "sys", ".", "stderr", "\n", "\n", "# change this if needed", "\n", "DEBUG_LOG", "=", "sys", ".", "stderr", "\n", "\n", "def", "__init__", "(", "self", ",", "node_list", "=", "None", ",", "node_value_list", "=", "None", ",", "relation_list", "=", "None", ",", "attribute_list", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        node_list: names of nodes in AMR graph, e.g. \"a11\", \"n\"\n        node_value_list: values of nodes in AMR graph, e.g. \"group\" for a node named \"g\"\n        relation_list: list of relations between two nodes\n        attribute_list: list of attributes (links between one node and one constant value)\n\n        \"\"\"", "\n", "# initialize AMR graph nodes using list of nodes name", "\n", "# root, by default, is the first in var_list", "\n", "\n", "if", "node_list", "is", "None", ":", "\n", "            ", "self", ".", "nodes", "=", "[", "]", "\n", "self", ".", "root", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "nodes", "=", "node_list", "[", ":", "]", "\n", "if", "len", "(", "node_list", ")", "!=", "0", ":", "\n", "                ", "self", ".", "root", "=", "node_list", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "root", "=", "None", "\n", "", "", "if", "node_value_list", "is", "None", ":", "\n", "            ", "self", ".", "node_values", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.rename_node": [[243, 259], ["range", "enumerate", "len", "enumerate", "str"], "methods", ["None"], ["", "else", ":", "\n", "            ", "self", ".", "node_values", "=", "node_value_list", "[", ":", "]", "\n", "", "if", "relation_list", "is", "None", ":", "\n", "            ", "self", ".", "relations", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "relations", "=", "relation_list", "[", ":", "]", "\n", "", "if", "attribute_list", "is", "None", ":", "\n", "            ", "self", ".", "attributes", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "attributes", "=", "attribute_list", "[", ":", "]", "\n", "\n", "", "", "def", "rename_node", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n        Rename AMR graph nodes to prefix + node_index to avoid nodes with the same name in two different AMRs.\n\n        \"\"\"", "\n", "node_map_dict", "=", "{", "}", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.get_triples": [[260, 282], ["range", "len", "instance_triple.append", "relation_triple.append", "attribute_triple.append"], "methods", ["None"], ["# map each node to its new name (e.g. \"a1\")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "node_map_dict", "[", "self", ".", "nodes", "[", "i", "]", "]", "=", "prefix", "+", "str", "(", "i", ")", "\n", "# update node name", "\n", "", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "nodes", ")", ":", "\n", "            ", "self", ".", "nodes", "[", "i", "]", "=", "node_map_dict", "[", "v", "]", "\n", "# update node name in relations", "\n", "", "for", "i", ",", "d", "in", "enumerate", "(", "self", ".", "relations", ")", ":", "\n", "            ", "new_dict", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "list", "(", "d", ".", "items", "(", ")", ")", ":", "\n", "                ", "new_dict", "[", "node_map_dict", "[", "k", "]", "]", "=", "v", "\n", "", "self", ".", "relations", "[", "i", "]", "=", "new_dict", "\n", "\n", "", "", "def", "get_triples", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in three lists.\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        attribute triple: relation of attributes, e.g. polarity(w, - )\n        and relation triple, e.g. arg0 (w, b)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.get_triples2": [[284, 309], ["range", "len", "instance_triple.append", "relation_triple.append", "relation_triple.append"], "methods", ["None"], ["for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# k is the other node this node has relation with", "\n", "# v is relation name", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "v", ",", "self", ".", "nodes", "[", "i", "]", ",", "k", ")", ")", "\n", "# k2 is the attribute name", "\n", "# v2 is the attribute value", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "attribute_triple", ".", "append", "(", "(", "k2", ",", "self", ".", "nodes", "[", "i", "]", ",", "v2", ")", ")", "\n", "", "", "return", "instance_triple", ",", "attribute_triple", ",", "relation_triple", "\n", "\n", "\n", "", "def", "get_triples2", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in two lists:\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        relation_triple: a triple representing all relations. E.g arg0 (w, b) or E.g. polarity(w, - )\n        Note that we do not differentiate between attribute triple and relation triple. Both are considered as relation\n        triples.\n        All triples are represented by (triple_type, argument 1 of the triple, argument 2 of the triple)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__str__": [[311, 326], ["range", "len", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "str"], "methods", ["None"], ["# For example, instance(b, boy).", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# k is the other node this node has relation with", "\n", "# v is relation name", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "v", ",", "self", ".", "nodes", "[", "i", "]", ",", "k", ")", ")", "\n", "# k2 is the attribute name", "\n", "# v2 is the attribute value", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "k2", ",", "self", ".", "nodes", "[", "i", "]", ",", "v2", ")", ")", "\n", "", "", "return", "instance_triple", ",", "relation_triple", "\n", "\n", "\n", "", "def", "__str__", "(", "self", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__repr__": [[327, 329], ["amr_utils.AMR.__str__"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__str__"], ["\n", "lines", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.output_amr": [[330, 336], ["print", "amr_utils.AMR.__str__"], "methods", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.__str__"], ["for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "lines", ".", "append", "(", "\"Node \"", "+", "str", "(", "i", ")", "+", "\" \"", "+", "self", ".", "nodes", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Value: \"", "+", "self", ".", "node_values", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Relations:\"", ")", "\n", "for", "k", ",", "v", "in", "list", "(", "self", ".", "relations", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n", "                ", "lines", ".", "append", "(", "\"Node \"", "+", "k", "+", "\" via \"", "+", "v", ")", "\n", "", "for", "k2", ",", "v2", "in", "list", "(", "self", ".", "attributes", "[", "i", "]", ".", "items", "(", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.get_amr_line": [[337, 363], ["line.strip.strip.strip", "line.strip.strip.strip().startswith", "cur_amr.append", "line.strip.strip.strip", "line.strip.strip.strip"], "methods", ["None"], ["                ", "lines", ".", "append", "(", "\"Attribute: \"", "+", "k2", "+", "\" value \"", "+", "v2", ")", "\n", "", "", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n", "", "@", "staticmethod", "\n", "def", "parse_AMR_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"\n        Parse a AMR from line representation to an AMR object.\n        This parsing algorithm scans the line once and process each character, in a shift-reduce style.\n\n        \"\"\"", "\n", "# Current state. It denotes the last significant symbol encountered. 1 for (, 2 for :, 3 for /,", "\n", "# and 0 for start state or ')'", "\n", "# Last significant symbol is ( --- start processing node name", "\n", "# Last significant symbol is : --- start processing relation name", "\n", "# Last significant symbol is / --- start processing node value (concept name)", "\n", "# Last significant symbol is ) --- current node processing is complete", "\n", "# Note that if these symbols are inside parenthesis, they are not significant symbols.", "\n", "state", "=", "0", "\n", "# node stack for parsing", "\n", "stack", "=", "[", "]", "\n", "# current not-yet-reduced character sequence", "\n", "cur_charseq", "=", "[", "]", "\n", "# key: node name value: node value", "\n", "node_dict", "=", "{", "}", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.parse_AMR_line": [[364, 604], ["set", "collections.defaultdict", "collections.defaultdict", "enumerate", "attribute_list[].append", "amr_utils.AMR", "line.strip", "relation_list.append", "attribute_list.append", "r.endswith", "node_relation_dict[].append", "print", "node_value_list.append", "node_relation_dict[].append", "node_relation_dict[].append", "cur_charseq.append", "cur_charseq.append", "node_rel_list.append", "cur_charseq.append", "node_attr_list.append", "print", "cur_charseq.append", "node_rel_list.append", "node_attr_list.append", "temp_attr_value.split", "parts[].strip", "parts[].strip", "cur_charseq.append", "stack.append", "node_name_list.append", "print", "stack.pop", "cur_charseq.append", "len", "print", "print", "len", "print", "amr_utils.AMR.parse_AMR_line.update_triple"], "methods", ["None"], ["# node name list (order: occurrence of the node)", "\n", "node_name_list", "=", "[", "]", "\n", "# key: node name:  value: list of (relation name, the other node name)", "\n", "node_relation_dict1", "=", "defaultdict", "(", "list", ")", "\n", "# key: node name, value: list of (attribute name, const value) or (relation name, unseen node name)", "\n", "node_relation_dict2", "=", "defaultdict", "(", "list", ")", "\n", "# current relation name", "\n", "cur_relation_name", "=", "\"\"", "\n", "# having unmatched quote string", "\n", "in_quote", "=", "False", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "line", ".", "strip", "(", ")", ")", ":", "\n", "            ", "if", "c", "==", "\" \"", ":", "\n", "# allow space in relation name", "\n", "                ", "if", "state", "==", "2", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "", "continue", "\n", "", "if", "c", "==", "\"\\\"\"", ":", "\n", "# flip in_quote value when a quote symbol is encountered", "\n", "# insert placeholder if in_quote from last symbol", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "'_'", ")", "\n", "", "in_quote", "=", "not", "in_quote", "\n", "", "elif", "c", "==", "\"(\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# get the attribute name", "\n", "# e.g :arg0 (x ...", "\n", "# at this point we get \"arg0\"", "\n", "", "if", "state", "==", "2", ":", "\n", "# in this state, current relation name should be empty", "\n", "                    ", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "                        ", "print", "(", "\"Format error when processing \"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# update current relation name for future use", "\n", "", "cur_relation_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", ".", "strip", "(", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "", "state", "=", "1", "\n", "", "elif", "c", "==", "\":\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"/\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :OR (o2 / *OR*", "\n", "#    :mod (o3 / official)", "\n", "#  gets node value \"*OR*\" at this point", "\n", "", "if", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "# clear current char sequence", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# pop node name (\"o2\" in the above example)", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# update node name/value map", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# Last significant symbol is \":\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :op1 w :quant 30", "\n", "# or :day 14 :month 3", "\n", "# the problem is that we cannot decide if node value is attribute value (constant)", "\n", "# or node value (variable) at this moment", "\n", "", "elif", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error in processing; part len < 2\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# For the above example, node name is \"op1\", and node value is \"w\"", "\n", "# Note that this node name might not be encountered before", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# We need to link upper level node to the current", "\n", "# top of stack is upper level node", "\n", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                        ", "print", "(", "\"Error in processing\"", ",", "line", "[", ":", "i", "]", ",", "relation_name", ",", "relation_value", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# if we have not seen this node name before", "\n", "", "if", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "node_relation_dict2", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "else", ":", "\n", "                        ", "node_relation_dict1", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "", "state", "=", "2", "\n", "", "elif", "c", "==", "\"/\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"(\". Now we encounter \"/\"", "\n", "# Example:", "\n", "# (d / default-01", "\n", "# get \"d\" here", "\n", "", "if", "state", "==", "1", ":", "\n", "                    ", "node_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# if this node name is already in node_dict, it is duplicate", "\n", "if", "node_name", "in", "node_dict", ":", "\n", "                        ", "print", "(", "\"Duplicate node name \"", ",", "node_name", ",", "\" in parsing AMR\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# push the node name to stack", "\n", "", "stack", ".", "append", "(", "node_name", ")", "\n", "# add it to node name list", "\n", "node_name_list", ".", "append", "(", "node_name", ")", "\n", "# if this node is part of the relation", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# cur_relation_name is arg1", "\n", "# node name is n", "\n", "# we have a relation arg1(upper level node, n)", "\n", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "# if relation name ends with \"-of\", e.g.\"arg0-of\",", "\n", "# it is reverse of some relation. For example, if a is \"arg0-of\" b,", "\n", "# we can also say b is \"arg0\" a.", "\n", "# If the relation name ends with \"-of\", we store the reverse relation.", "\n", "                        ", "if", "not", "cur_relation_name", ".", "endswith", "(", "\"-of\"", ")", ":", "\n", "# stack[-2] is upper_level node we encountered, as we just add node_name to stack", "\n", "                            ", "node_relation_dict1", "[", "stack", "[", "-", "2", "]", "]", ".", "append", "(", "(", "cur_relation_name", ",", "node_name", ")", ")", "\n", "", "else", ":", "\n", "# cur_relation_name[:-3] is to delete \"-of\"", "\n", "                            ", "node_relation_dict1", "[", "node_name", "]", ".", "append", "(", "(", "cur_relation_name", "[", ":", "-", "3", "]", ",", "stack", "[", "-", "2", "]", ")", ")", "\n", "# clear current_relation_name", "\n", "", "cur_relation_name", "=", "\"\"", "\n", "", "", "else", ":", "\n", "# error if in other state", "\n", "                    ", "print", "(", "\"Error in parsing AMR\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "state", "=", "3", "\n", "", "elif", "c", "==", "\")\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# stack should be non-empty to find upper level node", "\n", "", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                    ", "print", "(", "\"Unmatched parenthesis at position\"", ",", "i", ",", "\"in processing\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "# Last significant symbol is \":\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :op2 \"Brown\") or :op2 w)", "\n", "# get \\\"Brown\\\" or w here", "\n", "", "if", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error processing\"", ",", "line", "[", ":", "i", "+", "1", "]", ",", "temp_attr_value", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# store reverse of the relation", "\n", "# we are sure relation_value is a node here, as \"-of\" relation is only between two nodes", "\n", "if", "relation_name", ".", "endswith", "(", "\"-of\"", ")", ":", "\n", "                        ", "node_relation_dict1", "[", "relation_value", "]", ".", "append", "(", "(", "relation_name", "[", ":", "-", "3", "]", ",", "stack", "[", "-", "1", "]", ")", ")", "\n", "# attribute value not seen before", "\n", "# Note that it might be a constant attribute value, or an unseen node", "\n", "# process this after we have seen all the node names", "\n", "", "elif", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "node_relation_dict2", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "", "else", ":", "\n", "                        ", "node_relation_dict1", "[", "stack", "[", "-", "1", "]", "]", ".", "append", "(", "(", "relation_name", ",", "relation_value", ")", ")", "\n", "# Last significant symbol is \"/\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# we get \"nation\" here", "\n", "", "", "elif", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# map node name to its value", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# pop from stack, as the current node has been processed", "\n", "", "stack", ".", "pop", "(", ")", "\n", "cur_relation_name", "=", "\"\"", "\n", "state", "=", "0", "\n", "", "else", ":", "\n", "# not significant symbols, so we just shift.", "\n", "                ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "#create data structures to initialize an AMR", "\n", "", "", "node_value_list", "=", "[", "]", "\n", "relation_list", "=", "[", "]", "\n", "attribute_list", "=", "[", "]", "\n", "for", "v", "in", "node_name_list", ":", "\n", "            ", "if", "v", "not", "in", "node_dict", ":", "\n", "                ", "print", "(", "\"Error: Node name not found\"", ",", "v", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "None", "\n", "", "else", ":", "\n", "                ", "node_value_list", ".", "append", "(", "node_dict", "[", "v", "]", ")", "\n", "# build relation map and attribute map for this node", "\n", "", "relation_dict", "=", "{", "}", "\n", "attribute_dict", "=", "{", "}", "\n", "if", "v", "in", "node_relation_dict1", ":", "\n", "                ", "for", "v1", "in", "node_relation_dict1", "[", "v", "]", ":", "\n", "                    ", "relation_dict", "[", "v1", "[", "1", "]", "]", "=", "v1", "[", "0", "]", "\n", "", "", "if", "v", "in", "node_relation_dict2", ":", "\n", "                ", "for", "v2", "in", "node_relation_dict2", "[", "v", "]", ":", "\n", "# if value is in quote, it is a constant value", "\n", "# strip the quote and put it in attribute map", "\n", "                    ", "if", "v2", "[", "1", "]", "[", "0", "]", "==", "\"\\\"\"", "and", "v2", "[", "1", "]", "[", "-", "1", "]", "==", "\"\\\"\"", ":", "\n", "                        ", "attribute_dict", "[", "v2", "[", "0", "]", "]", "=", "v2", "[", "1", "]", "[", "1", ":", "-", "1", "]", "\n", "# if value is a node name", "\n", "", "elif", "v2", "[", "1", "]", "in", "node_dict", ":", "\n", "                        ", "relation_dict", "[", "v2", "[", "1", "]", "]", "=", "v2", "[", "0", "]", "\n", "", "else", ":", "\n", "                        ", "attribute_dict", "[", "v2", "[", "0", "]", "]", "=", "v2", "[", "1", "]", "\n", "# each node has a relation map and attribute map", "\n", "", "", "", "relation_list", ".", "append", "(", "relation_dict", ")", "\n", "attribute_list", ".", "append", "(", "attribute_dict", ")", "\n", "# add TOP as an attribute. The attribute value is the top node value", "\n", "", "attribute_list", "[", "0", "]", "[", "\"TOP\"", "]", "=", "node_value_list", "[", "0", "]", "\n", "#print node_name_list", "\n", "#print node_value_list", "\n", "#print relation_list", "\n", "#print attribute_list,'\\n\\n'", "\n", "result_amr", "=", "AMR", "(", "node_name_list", ",", "node_value_list", ",", "relation_list", ",", "attribute_list", ")", "\n", "return", "result_amr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.get_default_amr": [[13, 16], ["None"], "function", ["None"], ["def", "get_default_amr", "(", ")", ":", "\n", "    ", "default", "=", "'(w / want-01 :ARG0 (b / boy) :ARG1 (g / go-01 :ARG0 b))'", "\n", "return", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.write_to_file": [[18, 26], ["out_f.close", "open", "out_f.write", "out_f.write", "line.strip", "line.strip"], "function", ["None"], ["", "def", "write_to_file", "(", "lst", ",", "file_new", ",", "extra_newline", "=", "False", ")", ":", "\n", "    ", "with", "open", "(", "file_new", ",", "'w'", ")", "as", "out_f", ":", "\n", "        ", "for", "line", "in", "lst", ":", "\n", "            ", "if", "extra_newline", ":", "\n", "                ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n\\n'", ")", "\n", "", "else", ":", "\n", "                ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.get_files_by_ext": [[28, 38], ["os.walk", "f.endswith", "return_files.append", "os.path.join"], "function", ["None"], ["", "def", "get_files_by_ext", "(", "direc", ",", "ext", ")", ":", "\n", "    ", "'''Function that traverses a directory and returns all files that match a certain extension'''", "\n", "\n", "return_files", "=", "[", "]", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "direc", ")", ":", "\n", "        ", "for", "f", "in", "files", ":", "\n", "            ", "if", "f", ".", "endswith", "(", "ext", ")", ":", "\n", "                ", "return_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "root", ",", "f", ")", ")", "\n", "\n", "", "", "", "return", "return_files", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.is_number": [[40, 46], ["float"], "function", ["None"], ["", "def", "is_number", "(", "s", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.tokenize_line": [[48, 54], ["line.replace().replace", "new_l.replace().replace.replace().replace", "new_l.replace().replace.split", "line.replace", "new_l.replace().replace.replace"], "function", ["None"], ["", "", "def", "tokenize_line", "(", "line", ")", ":", "\n", "    ", "new_l", "=", "line", ".", "replace", "(", "'('", ",", "' ( '", ")", ".", "replace", "(", "')'", ",", "' ) '", ")", "\n", "# We want to make sure that we do Wiki links correctly", "\n", "# They always look like this :wiki \"link_(information)\"", "\n", "new_l", "=", "new_l", ".", "replace", "(", "'_ ('", ",", "'_('", ")", ".", "replace", "(", "') \"'", ",", "')\"'", ")", "\n", "return", "\" \"", ".", "join", "(", "new_l", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.reverse_tokenize": [[56, 61], ["new_line.replace().replace.replace().replace", "new_line.replace().replace.replace"], "function", ["None"], ["", "def", "reverse_tokenize", "(", "new_line", ")", ":", "\n", "    ", "while", "' )'", "in", "new_line", "or", "'( '", "in", "new_line", ":", "#restore tokenizing", "\n", "        ", "new_line", "=", "new_line", ".", "replace", "(", "' )'", ",", "')'", ")", ".", "replace", "(", "'( '", ",", "'('", ")", "\n", "\n", "", "return", "new_line", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.between_quotes": [[63, 66], ["string.startswith", "string.endswith", "string.startswith", "string.endswith"], "function", ["None"], ["", "def", "between_quotes", "(", "string", ")", ":", "\n", "    ", "'''Return true if a value is between quotes'''", "\n", "return", "(", "string", ".", "startswith", "(", "'\"'", ")", "and", "string", ".", "endswith", "(", "'\"'", ")", ")", "or", "(", "string", ".", "startswith", "(", "\"'\"", ")", "and", "string", ".", "endswith", "(", "\"'\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.replace_not_in_quotes": [[68, 81], ["None"], "function", ["None"], ["", "def", "replace_not_in_quotes", "(", "line", ",", "to_replace", ",", "replace_with", ")", ":", "\n", "    ", "'''Replace a character with another character if not between quotes'''", "\n", "new_str", "=", "''", "\n", "between_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "new_str", "+=", "ch", "\n", "", "elif", "ch", "==", "to_replace", "and", "not", "between_quotes", ":", "\n", "            ", "new_str", "+=", "replace_with", "\n", "", "else", ":", "\n", "            ", "new_str", "+=", "ch", "\n", "", "", "return", "new_str", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.space_brackets_amr": [[83, 98], ["new_line.split"], "function", ["None"], ["", "def", "space_brackets_amr", "(", "line", ")", ":", "\n", "    ", "'''Add space around brackets for AMR, except if it's between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "')'", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' ) '", "\n", "", "elif", "ch", "==", "'('", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' ( '", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "new_line", "+=", "ch", "\n", "", "else", ":", "\n", "            ", "new_line", "+=", "ch", "\n", "", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.left_space_for_char": [[100, 113], ["new_line.split"], "function", ["None"], ["", "def", "left_space_for_char", "(", "line", ",", "check_char", ")", ":", "\n", "    ", "'''Add a left space for a certain character in a certain line, only if not between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "check_char", "and", "not", "current_quotes", ":", "\n", "            ", "new_line", "+=", "' '", "+", "ch", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "new_line", "+=", "ch", "\n", "", "else", ":", "\n", "            ", "new_line", "+=", "ch", "\n", "", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.remove_char_outside_quotes": [[115, 126], ["new_line.split"], "function", ["None"], ["", "def", "remove_char_outside_quotes", "(", "line", ",", "check_char", ")", ":", "\n", "    ", "'''Remove a character from a string, if it's not between quotes'''", "\n", "new_line", "=", "''", "\n", "current_quotes", "=", "False", "\n", "for", "ch", "in", "line", ":", "\n", "        ", "if", "ch", "==", "check_char", "and", "not", "current_quotes", ":", "\n", "            ", "continue", "\n", "", "elif", "ch", "==", "'\"'", ":", "\n", "            ", "current_quotes", "=", "not", "current_quotes", "\n", "", "new_line", "+=", "ch", "\n", "", "return", "\" \"", ".", "join", "(", "new_line", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.count_not_between_quotes": [[128, 138], ["None"], "function", ["None"], ["", "def", "count_not_between_quotes", "(", "char", ",", "string", ")", ":", "\n", "    ", "'''Count number of occurences for a certain character, don't count if it's between quotes'''", "\n", "count", "=", "0", "\n", "between_quotes", "=", "False", "\n", "for", "ch", "in", "string", ":", "\n", "        ", "if", "ch", "==", "'\"'", ":", "\n", "            ", "between_quotes", "=", "not", "between_quotes", "\n", "", "elif", "ch", "==", "char", "and", "not", "between_quotes", ":", "\n", "            ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.variable_match": [[140, 146], ["any", "len", "spl[].startswith", "len", "len", "char.isalpha", "len", "[].isdigit", "len", "x.isalpha", "x.isdigit"], "function", ["None"], ["", "def", "variable_match", "(", "spl", ",", "idx", ",", "no_var_list", ")", ":", "\n", "    ", "'''Function that matches entities that are variables occurring for the second time'''", "\n", "# Beginning or end are never variables", "\n", "if", "idx", ">=", "len", "(", "spl", ")", "or", "idx", "==", "0", ":", "\n", "        ", "return", "False", "\n", "", "return", "spl", "[", "idx", "-", "1", "]", "!=", "'/'", "and", "any", "(", "char", ".", "isalpha", "(", ")", "for", "char", "in", "spl", "[", "idx", "]", ")", "and", "spl", "[", "idx", "]", "not", "in", "no_var_list", "and", "not", "spl", "[", "idx", "]", ".", "startswith", "(", "':'", ")", "and", "len", "(", "[", "x", "for", "x", "in", "spl", "[", "idx", "]", "if", "x", ".", "isalpha", "(", ")", "or", "x", ".", "isdigit", "(", ")", "]", ")", "==", "len", "(", "spl", "[", "idx", "]", ")", "and", "(", "len", "(", "spl", "[", "idx", "]", ")", "==", "1", "or", "(", "len", "(", "spl", "[", "idx", "]", ")", ">", "1", "and", "spl", "[", "idx", "]", "[", "-", "1", "]", ".", "isdigit", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.load_dict": [[148, 155], ["in_f.close", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.None.train.load"], ["", "def", "load_dict", "(", "d", ")", ":", "\n", "    ", "'''Funcion that loads json dictionaries'''", "\n", "# Load reference dict (based on training data) to settle disputes based on frequency", "\n", "with", "open", "(", "d", ",", "'r'", ")", "as", "in_f", ":", "\n", "        ", "dic", "=", "json", ".", "load", "(", "in_f", ")", "\n", "", "in_f", ".", "close", "(", ")", "\n", "return", "dic", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.add_to_dict": [[157, 164], ["None"], "function", ["None"], ["", "def", "add_to_dict", "(", "d", ",", "key", ",", "base", ")", ":", "\n", "    ", "'''Function to add key to dictionary, either add base or start with base'''", "\n", "if", "key", "in", "d", ":", "\n", "        ", "d", "[", "key", "]", "+=", "base", "\n", "", "else", ":", "\n", "        ", "d", "[", "key", "]", "=", "base", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.countparens": [[166, 175], ["None"], "function", ["None"], ["", "def", "countparens", "(", "text", ")", ":", "\n", "    ", "''' proper nested parens counting '''", "\n", "currcount", "=", "0", "\n", "for", "i", "in", "text", ":", "\n", "        ", "if", "i", "==", "\"(\"", ":", "\n", "            ", "currcount", "+=", "1", "\n", "", "elif", "i", "==", "\")\"", ":", "\n", "            ", "currcount", "-=", "1", "\n", "", "", "return", "currcount", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.valid_amr": [[177, 192], ["amr_utils.countparens", "amr_utils.AMR.parse_AMR_line", "print", "print"], "function", ["home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.countparens", "home.repos.pwc.inspect_result.headacheboy_cross-lingual-amr-parsing.restoreAMR.amr_utils.AMR.parse_AMR_line"], ["", "def", "valid_amr", "(", "amrtext", ")", ":", "\n", "# Wrong parentheses, return false", "\n", "    ", "if", "not", "countparens", "(", "amrtext", ")", ":", "\n", "        ", "return", "False", "\n", "", "try", ":", "\n", "        ", "theamr", "=", "AMR", ".", "parse_AMR_line", "(", "amrtext", ")", "\n", "if", "theamr", "is", "None", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "", "", "except", "(", "AttributeError", ",", "Exception", ")", "as", "e", ":", "\n", "        ", "print", "(", "'Error:'", ",", "e", ")", "\n", "print", "(", "amrtext", ")", "\n", "return", "False", "\n", "", "return", "True", "\n", "\n"]]}